<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html>
<head>
<title>IOMemoryDescriptor</title>
<meta http-equiv="Content-Type" content="text/html; charset=ascii">
<meta name="generator" content="HeaderDoc">
<style><!--
#tocMenu {
		display: block;
		position:fixed;
		top:0px;
		left:0px;
		width:210px;
		height:100%;
		background:transparent;
}
#bodyText {
		margin-left: 210px;
}
--></style>
<meta id="toc-file" name="toc-file" content="toc.html">
<script language="JavaScript" src="../../../../../../Resources/JavaScript/page.js" type="text/javascript"></script><link rel="stylesheet" type="text/css" href="../../../../../../Resources/CSS/frameset_styles.css">
<style type="text/css"><!--.keyword {background:#ffffff; color:#761550;}.template {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.function {background:#ffffff; color:#000000;}.string {background: #ffffff; color:#891315;}.preprocessor {background:#ffffff; color:#236e25}.comment {background:#ffffff; color:#236e25}.char {background: #ffffff; color:#0000ff;}.var {background:#ffffff; color:#000000;}.type {background:#ffffff; color:#761550;}.param {background:#ffffff; color:#000000;}.graybox {         border-top: 1px solid #919699;         border-left: 1px solid #919699;         margin-bottom: 10px;         }  .graybox th {         padding: 4px 8px 4px 8px;         background: #E2E2E2;         font-size: 12px;         font-weight: bold;         border-bottom: 1px solid #919699;         border-right: 1px solid #919699;         }  .graybox td {         padding: 8px;         font-size: 12px;         text-align: left;         vertical-align: top;         border-bottom: 1px solid #919699;         border-right: 1px solid #919699;         }  --></style>
</head>
<body bgcolor="#ffffff" onload="initialize_page();">
<noscript>
<div id="tocMenu">
<iframe id="toc_content" name="toc_content" src="toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
</div>
</noscript>
<div id="bodyText">
<!-- start of header -->

<!-- start of header -->
<!--#include virtual="/includes/framesetheader"-->
<!-- end of header -->

<table width="600"><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <a href="../../../../../../../reference/Darwin/index.html#//apple_ref/doc/uid/TP30001281-TP30000422" target="_top">Darwin</a> <b>&gt;</b> <a href="../../../index.html#//apple_ref/doc/framework/kernel_fw_leo" target="_top">Kernel Framework Reference</a></font>
<!-- end breadcrumb insert request -->
<p>&#160;</p>
</td></tr></table>
<!-- end of header --><a name="top"></a>
<a name="//apple_ref/doc/class/IOMemoryDescriptor" title="IOMemoryDescriptor"></a>
<hr>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h1><a name="IOMemoryDescriptor">IOMemoryDescriptor</a></h1>
</td></tr></table>
<div class="spec_sheet_info_box"><table cellspacing="0" class="specbox">
<tr>
<td scope="row"><b>Inherits from:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text">
<a href="../../../OSObject_h/Classes/OSObject/index.html#//apple_ref/cpp/cl/OSObject" target="_top">OSObject</a>
</div></div></td>
</tr>
<tr>
<td scope="row"><b>Declared In:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text"><a href="../../index.html" target="_top">IOMemoryDescriptor.h</a></div></div></td>
</tr>
</table></div>
<h2>Overview</h2>
<p><!-- begin abstract --></p>
<p>An abstract base class defining common methods for describing physical or virtual memory.
<!-- end abstract --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The IOMemoryDescriptor object represents a buffer or range of memory, specified as one or more physical or virtual address ranges. It contains methods to return the memory's physically contiguous segments (fragments), for use with the IOMemoryCursor, and methods to map the memory into any address space with caching and placed mapping options.
</p>
<p>Some of the methods in this class require parameters of type <code>task_t</code>. This type refers to a Mach task, which is a unit of resource ownership that consists of a virtual address space, a port-right namespace, and at least one thread. In Mac OS X, each process is based on a Mach task and one or more Mach threads. For more information on the composition of a Mach task and its relationship with Mach threads, see <i><a href="../../../../../Conceptual/KernelProgramming/Mach/Mach.html#//apple_ref/doc/uid/TP30000905-CH209-TPXREF103" target="_top">"Tasks and Threads"</a></i>.
</p>
<p>The value of the <code>task_t</code> parameter depends on the task into which the memory is being mapped. If the kernel's task is the target of the memory mapping, use the global value <code>kernel_task</code> (note that the definition of <code>kernel_task</code> is automatically included when you <code>#include</code> this header file). To map memory into the task currently running in the kernel, use <code>current_task()</code> to get the <code>task_t</code> value that represents the currently running task. 
</p>
<p>Note that if <code>current_task()</code> is called from a user client method running in the kernel, it returns the currently running user process, which may or may not be the user process that initiated the user client. To map memory into the task of the user process that initiatied the user client, use the <code>task_t</code> value that was passed into <!-- a -->IOUserClient::initWithTask<!-- /a -->. 
</p>
<p>To learn more about the virtual memory system in Mac OS X, see <i><a href="../../../../../../Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html#//apple_ref/doc/uid/20001880" target="_top">"Memory Management in Mac OS X"</a></i>.
<!-- end discussion -->
</p>
<hr>
<br><h2>Functions</h2>
<a name="HeaderDoc_functions"></a>
<dl>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/complete/IOReturn/(IODirection)" target="_top">complete</a></tt></dt>
<dd><p>Completes processing of the memory after an I/O transfer finishes.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/createMappingInTask/IOMemoryMap*/(task_t,mach_vm_address_t,IOOptionBits,mach_vm_size_t,mach_vm_size_t)" target="_top">createMappingInTask</a></tt></dt>
<dd><p>Maps a IOMemoryDescriptor into a task.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/getDirection/IODirection/()" target="_top">getDirection</a></tt></dt>
<dd><p>Accessor to get the direction the memory descriptor was created with.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/getLength/IOByteCount/()" target="_top">getLength</a></tt></dt>
<dd><p>Accessor to get the length of the memory descriptor (over all its ranges).
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/getPhysicalAddress/IOPhysicalAddress/()" target="_top">getPhysicalAddress</a></tt></dt>
<dd><p>Returns the physical address of the first byte in the memory.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/getPhysicalSegment/IOPhysicalAddress/(IOByteCount,IOByteCount*)" target="_top">getPhysicalSegment</a></tt></dt>
<dd><p>Breaks a memory descriptor into its physically contiguous segments.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/getTag/IOOptionBits/()" target="_top">getTag</a></tt></dt>
<dd><p>Accessor to the retrieve the tag for the memory descriptor.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/initWithAddress/bool/(vm_address_t,IOByteCount,IODirection,task_t)" target="_top">initWithAddress(vm_address_t, IOByteCount, IODirection, task_t)</a></tt></dt>
<dd><p>Initializes or reinitializes an IOMemoryDescriptor to describe one virtual range of the specified map.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/initWithAddress/bool/(void*,IOByteCount,IODirection)" target="_top">initWithAddress(void *, IOByteCount, IODirection)</a></tt></dt>
<dd><p>Initializes or reinitializes an IOMemoryDescriptor to describe one virtual range of the kernel task.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/initWithOptions/bool/(void*,UInt32,UInt32,task_t,IOOptionBits,IOMapper*)" target="_top">initWithOptions</a></tt></dt>
<dd><p>Master initializer for all variants of memory descriptors (for a more complete description see <a href="index.html#//apple_ref/cpp/clm/IOMemoryDescriptor/withOptions/IOMemoryDescriptor*/(void*,UInt32,UInt32,task_t,IOOptionBits,IOMapper*)" target="_top">withOptions</a> ).
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/initWithPhysicalAddress/bool/(IOPhysicalAddress,IOByteCount,IODirection)" target="_top">initWithPhysicalAddress</a></tt></dt>
<dd><p>Initializes or reinitializes an IOMemoryDescriptor to describe one physical range.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/initWithPhysicalRanges/bool/(IOPhysicalRange*,UInt32,IODirection,bool)" target="_top">initWithPhysicalRanges</a></tt></dt>
<dd><p>Initializes or reinitializes an IOMemoryDescriptor to describe one or more physical ranges.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/initWithRanges/bool/(IOVirtualRange*,UInt32,IODirection,task_t,bool)" target="_top">initWithRanges</a></tt></dt>
<dd><p>Initializes or reinitializes an IOMemoryDescriptor to describe one or more virtual ranges.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/map/IOMemoryMap*/(IOOptionBits)" target="_top">map(IOOptionBits)</a></tt></dt>
<dd><p>Maps a IOMemoryDescriptor into the kernel map.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/map/IOMemoryMap*/(task_t,IOVirtualAddress,IOOptionBits,IOByteCount,IOByteCount)" target="_top">map(task_t, IOVirtualAddress, IOOptionBits, IOByteCount, IOByteCount)</a></tt></dt>
<dd><p>Maps a IOMemoryDescriptor into a task - deprecated, only safe for 32 bit tasks. Use createMappingInTask instead.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/performOperation/IOReturn/(IOOptionBits,IOByteCount,IOByteCount)" target="_top">performOperation</a></tt></dt>
<dd><p>Performs an operation on the memory descriptor's memory.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/prepare/IOReturn/(IODirection)" target="_top">prepare</a></tt></dt>
<dd><p>Prepares the memory for an I/O transfer.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/readBytes/IOByteCount/(IOByteCount,void*,IOByteCount)" target="_top">readBytes</a></tt></dt>
<dd><p>Copy data from the memory descriptor's buffer to the specified buffer.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/setMapping/IOMemoryMap*/(task_t,IOVirtualAddress,IOOptionBits)" target="_top">setMapping</a></tt></dt>
<dd><p>Establishes an already existing mapping.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/setPurgeable/IOReturn/(IOOptionBits,IOOptionBits*)" target="_top">setPurgeable</a></tt></dt>
<dd><p>Controls the purgeable status of a memory descriptor's memory.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/setTag/void/(IOOptionBits)" target="_top">setTag</a></tt></dt>
<dd><p>Set the tag for the memory descriptor.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOMemoryDescriptor/withAddress/IOMemoryDescriptor*/(vm_address_t,IOByteCount,IODirection,task_t)" target="_top">withAddress(vm_address_t, IOByteCount, IODirection, task_t)</a></tt></dt>
<dd><p>Creates an IOMemoryDescriptor to describe one virtual range of the specified map.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOMemoryDescriptor/withAddress/IOMemoryDescriptor*/(void*,IOByteCount,IODirection)" target="_top">withAddress(void *, IOByteCount, IODirection)</a></tt></dt>
<dd><p>Creates an IOMemoryDescriptor to describe one virtual range of the kernel task.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOMemoryDescriptor/withAddressRange/IOMemoryDescriptor*/(mach_vm_address_t,mach_vm_size_t,IOOptionBits,task_t)" target="_top">withAddressRange</a></tt></dt>
<dd><p>Create an IOMemoryDescriptor to describe one virtual range of the specified map.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOMemoryDescriptor/withAddressRanges/IOMemoryDescriptor*/(IOAddressRange*,UInt32,IOOptionBits,task_t)" target="_top">withAddressRanges</a></tt></dt>
<dd><p>Create an IOMemoryDescriptor to describe one or more virtual ranges.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOMemoryDescriptor/withOptions/IOMemoryDescriptor*/(void*,UInt32,UInt32,task_t,IOOptionBits,IOMapper*)" target="_top">withOptions</a></tt></dt>
<dd><p>Master initialiser for all variants of memory descriptors.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOMemoryDescriptor/withPersistentMemoryDescriptor/IOMemoryDescriptor*/(IOMemoryDescriptor*)" target="_top">withPersistentMemoryDescriptor</a></tt></dt>
<dd><p>Copy constructor that generates a new memory descriptor if the backing memory for the same task's virtual address and length has changed.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOMemoryDescriptor/withPhysicalAddress/IOMemoryDescriptor*/(IOPhysicalAddress,IOByteCount,IODirection)" target="_top">withPhysicalAddress</a></tt></dt>
<dd><p>Creates an IOMemoryDescriptor to describe one physical range.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOMemoryDescriptor/withPhysicalRanges/IOMemoryDescriptor*/(IOPhysicalRange*,UInt32,IODirection,bool)" target="_top">withPhysicalRanges</a></tt></dt>
<dd><p>Creates an IOMemoryDescriptor to describe one or more physical ranges.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOMemoryDescriptor/withRanges/IOMemoryDescriptor*/(IOVirtualRange*,UInt32,IODirection,task_t,bool)" target="_top">withRanges</a></tt></dt>
<dd><p>Create an IOMemoryDescriptor to describe one or more virtual ranges.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOMemoryDescriptor/withSubRange/IOMemoryDescriptor*/(IOMemoryDescriptor*,IOByteCount,IOByteCount,IODirection)" target="_top">withSubRange</a></tt></dt>
<dd><p>Creates an IOMemoryDescriptor to describe a subrange of an existing descriptor.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/writeBytes/IOByteCount/(IOByteCount,constvoid*,IOByteCount)" target="_top">writeBytes</a></tt></dt>
<dd><p>Copy data to the memory descriptor's buffer from the specified buffer.
</p></dd>
</dl>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/complete/IOReturn/(IODirection);   name=IOMemoryDescriptor::complete --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/complete/IOReturn/(IODirection)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="complete">complete</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Completes processing of the memory after an I/O transfer finishes.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <a href="../../../IOFWPhysicalAddressSpace_h/index.html#//apple_ref/c/func/complete" target="_top" class="function"><span class="function">complete</span></a>(
    <!-- a --><span class="type">IODirection</span><!-- /a --> <!-- a --><span class="type">forDirection</span><!-- /a --> = <span class="param">kIODirectionNone</span>) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>forDirection</code></dt>
<dd><p>DEPRECATED The direction of the I/O just completed, or kIODirectionNone for the direction specified by the memory descriptor.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method should not be called unless a prepare was previously issued; the <a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/prepare/IOReturn/(IODirection)" target="_top">prepare</a> and complete() must occur in pairs, before and after an I/O transfer involving pageable memory.  In 10.3 or greater systems the direction argument to complete is not longer respected.  The direction is totally determined at <a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/prepare/IOReturn/(IODirection)" target="_top">prepare</a> time.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/createMappingInTask/IOMemoryMap*/(task_t,mach_vm_address_t,IOOptionBits,mach_vm_size_t,mach_vm_size_t);   name=IOMemoryDescriptor::createMappingInTask --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/createMappingInTask/IOMemoryMap*/(task_t,mach_vm_address_t,IOOptionBits,mach_vm_size_t,mach_vm_size_t)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="createMappingInTask">createMappingInTask</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Maps a IOMemoryDescriptor into a task.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><a href="../IOMemoryMap/index.html#//apple_ref/cpp/cl/IOMemoryMap" target="_top" class="type"><span class="type">IOMemoryMap</span></a> <span class="type">*</span> <!-- a --><span class="function">createMappingInTask</span><!-- /a -->( 
    <!-- a --><span class="type">task_t</span><!-- /a --> <span class="param">intoTask</span>, 
    <!-- a --><span class="type">mach_vm_address_t</span><!-- /a --> <span class="param">atAddress</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span>, 
    <!-- a --><span class="type">mach_vm_size_t</span><!-- /a --> <!-- a --><span class="type">offset</span><!-- /a --> = <span class="number">0</span>, 
    <!-- a --><span class="type">mach_vm_size_t</span><!-- /a --> <!-- a --><span class="type">length</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>intoTask</code></dt>
<dd><p>Sets the target task for the mapping. To map into the kernel's task, pass <code>kernel_task</code>. To map into the task currently running in the kernel, use the <code>task_t</code> value returned by <code>current_task()</code>. When calling this method from a user client method running in the kernel, pass the <code>task_t</code> value that was passed into <!-- a -->IOUserClient::initWithTask<!-- /a --> to map into the user process that initiated the user client.</p></dd>
<dt><code>atAddress</code></dt>
<dd><p>If a placed mapping is requested, <code>atAddress</code> specifies its address, and the <code>kIOMapAnywhere</code> should not be set. Otherwise, <code>atAddress</code> is ignored.</p></dd>
<dt><code>options</code></dt>
<dd><p>Mapping options are defined in <code>IOTypes.h</code>,<br><code>kIOMapAnywhere</code> should be passed if the mapping can be created anywhere. If not set, the <code>atAddress</code> parameter sets the location of the mapping, if it is available in the target map.<br><code>kIOMapDefaultCache</code> to inhibit the cache in I/O areas, kIOMapCopybackCache in general purpose RAM.<br><code>kIOMapInhibitCache</code>, <code>kIOMapWriteThruCache</code>, <code>kIOMapCopybackCache</code> to set the appropriate caching.<br><code>kIOMapReadOnly</code> to allow only read only accesses to the memory - writes will cause and access fault.<br><code>kIOMapReference</code> will only succeed if the mapping already exists, and the IOMemoryMap object is just an extra reference, ie. no new mapping will be created.<br><code>kIOMapUnique</code> allows a special kind of mapping to be created that may be used with the IOMemoryMap::redirect() API. These mappings will not be shared as is the default - there will always be a unique mapping created for the caller, not an existing mapping with an extra reference.<br></p></dd>
<dt><code>offset</code></dt>
<dd><p>Is a beginning offset into the IOMemoryDescriptor's memory where the mapping starts. Zero is the default to map all the memory.</p></dd>
<dt><code>length</code></dt>
<dd><p>Is the length of the mapping requested for a subset of the IOMemoryDescriptor. Zero is the default to map all the memory.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A reference to an IOMemoryMap object representing the mapping, which can supply the virtual address of the mapping and other information. The mapping may be shared with multiple callers - multiple maps are avoided if a compatible one exists. The IOMemoryMap object returned should be released only when the caller has finished accessing the mapping, as freeing the object destroys the mapping. The IOMemoryMap instance also retains the IOMemoryDescriptor it maps while it exists. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This is the general purpose method to map all or part of the memory described by a memory descriptor into a task at any available address, or at a fixed address if possible. Caching &amp; read-only options may be set for the mapping. The mapping is represented as a returned reference to a IOMemoryMap object, which may be shared if the mapping is compatible with an existing mapping of the IOMemoryDescriptor. The IOMemoryMap object returned should be released only when the caller has finished accessing the mapping, as freeing the object destroys the mapping. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/getDirection/IODirection/();   name=IOMemoryDescriptor::getDirection --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/getDirection/IODirection/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getDirection">getDirection</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Accessor to get the direction the memory descriptor was created with.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">IODirection</span><!-- /a --> <!-- a --><span class="function">getDirection</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The direction. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the direction the memory descriptor was created with.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/getLength/IOByteCount/();   name=IOMemoryDescriptor::getLength --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/getLength/IOByteCount/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getLength">getLength</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Accessor to get the length of the memory descriptor (over all its ranges).
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">IOByteCount</span><!-- /a --> <a href="../../../IOFWPhysicalAddressSpace_h/index.html#//apple_ref/c/func/getLength" target="_top" class="function"><span class="function">getLength</span></a>() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The byte count. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the total length of the memory described by the descriptor, ie. the sum of its ranges' lengths.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/getPhysicalAddress/IOPhysicalAddress/();   name=IOMemoryDescriptor::getPhysicalAddress --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/getPhysicalAddress/IOPhysicalAddress/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getPhysicalAddress">getPhysicalAddress</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the physical address of the first byte in the memory.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><!-- a --><span class="type">IOPhysicalAddress</span><!-- /a --> <!-- a --><span class="function">getPhysicalAddress</span><!-- /a -->(); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A physical address. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the physical address of the  first byte in the memory. It is most useful on memory known to be physically contiguous.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/getPhysicalSegment/IOPhysicalAddress/(IOByteCount,IOByteCount*);   name=IOMemoryDescriptor::getPhysicalSegment --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/getPhysicalSegment/IOPhysicalAddress/(IOByteCount,IOByteCount*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getPhysicalSegment">getPhysicalSegment</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Breaks a memory descriptor into its physically contiguous segments.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">IOPhysicalAddress</span><!-- /a --> <!-- a --><span class="function">getPhysicalSegment</span><!-- /a -->(
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">offset</span>, 
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="type">*</span><span class="param">length</span>) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>offset</code></dt>
<dd><p>A byte offset into the memory whose physical address to return.</p></dd>
<dt><code>length</code></dt>
<dd><p>If non-zero, <code>getPhysicalSegment</code> will store here the length of the physically contiguous segement at the given offset.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A physical address, or zero if the offset is beyond the length of the memory. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the physical address of the byte at the given offset into the memory, and optionally the length of the physically contiguous segment from that offset.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/getTag/IOOptionBits/();   name=IOMemoryDescriptor::getTag --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/getTag/IOOptionBits/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getTag">getTag</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Accessor to the retrieve the tag for the memory descriptor.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <!-- a --><span class="function">getTag</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The tag. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the tag for the memory descriptor. Tag bits are not interpreted by IOMemoryDescriptor.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/initWithAddress/bool/(vm_address_t,IOByteCount,IODirection,task_t);   name=IOMemoryDescriptor::initWithAddress --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/initWithAddress/bool/(vm_address_t,IOByteCount,IODirection,task_t)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="initWithAddress(vm_address_t,IOByteCount,IODirection,task_t)">initWithAddress(vm_address_t, IOByteCount, IODirection, task_t)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Initializes or reinitializes an IOMemoryDescriptor to describe one virtual range of the specified map.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">initWithAddress</span><!-- /a -->(
    <!-- a --><span class="type">vm_address_t</span><!-- /a --> <span class="param">address</span>, 
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">withLength</span>, 
    <!-- a --><span class="type">IODirection</span><!-- /a --> <span class="param">withDirection</span>, 
    <!-- a --><span class="type">task_t</span><!-- /a --> <span class="param">withTask</span>) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>address</code></dt>
<dd><p>The virtual address of the first byte in the memory.</p></dd>
<dt><code>withLength</code></dt>
<dd><p>The length of memory.</p></dd>
<dt><code>withDirection</code></dt>
<dd><p>An I/O direction to be associated with the descriptor, which may affect the operation of the <code>prepare</code> and <code>complete</code> methods on some architectures.</p></dd>
<dt><code>withTask</code></dt>
<dd><p>The task the virtual range is mapped into. To map into the kernel's task, pass <code>kernel_task</code>. To map into the task currently running in the kernel, use the <code>task_t</code> value returned by <code>current_task()</code>. When calling this method from a user client method running in the kernel, pass the <code>task_t</code> value that was passed into <!-- a -->IOUserClient::initWithTask<!-- /a --> to map into the user process that initiated the user client.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->true on success, false on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method initializes an IOMemoryDescriptor for memory consisting of a single virtual memory range mapped into the specified map. An IOMemoryDescriptor can be re-used by calling initWithAddress or initWithRanges again on an existing instance -- note this behavior is not commonly supported in other IOKit classes, although it is supported here.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/initWithAddress/bool/(void*,IOByteCount,IODirection);   name=IOMemoryDescriptor::initWithAddress --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/initWithAddress/bool/(void*,IOByteCount,IODirection)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="initWithAddress(void*,IOByteCount,IODirection)">initWithAddress(void *, IOByteCount, IODirection)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Initializes or reinitializes an IOMemoryDescriptor to describe one virtual range of the kernel task.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">initWithAddress</span><!-- /a -->(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">address</span>, 
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">withLength</span>, 
    <!-- a --><span class="type">IODirection</span><!-- /a --> <span class="param">withDirection</span>) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>address</code></dt>
<dd><p>The virtual address of the first byte in the memory.</p></dd>
<dt><code>withLength</code></dt>
<dd><p>The length of memory.</p></dd>
<dt><code>withDirection</code></dt>
<dd><p>An I/O direction to be associated with the descriptor, which may affect the operation of the <code>prepare</code> and <code>complete</code> methods on some architectures.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->true on success, false on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method initializes an IOMemoryDescriptor for memory consisting of a single virtual memory range mapped into the kernel map. An IOMemoryDescriptor can be re-used by calling <code>initWithAddress</code> or <a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/initWithRanges/bool/(IOVirtualRange*,UInt32,IODirection,task_t,bool)" target="_top">initWithRanges</a> again on an existing instance -- note this behavior is not commonly supported in other I/O Kit classes, although it is supported here.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/initWithOptions/bool/(void*,UInt32,UInt32,task_t,IOOptionBits,IOMapper*);   name=IOMemoryDescriptor::initWithOptions --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/initWithOptions/bool/(void*,UInt32,UInt32,task_t,IOOptionBits,IOMapper*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="initWithOptions">initWithOptions</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Master initializer for all variants of memory descriptors (for a more complete description see <a href="index.html#//apple_ref/cpp/clm/IOMemoryDescriptor/withOptions/IOMemoryDescriptor*/(void*,UInt32,UInt32,task_t,IOOptionBits,IOMapper*)" target="_top">withOptions</a>).
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">initWithOptions</span><!-- /a -->(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">buffers</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">count</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">offset</span>, 
    <!-- a --><span class="type">task_t</span><!-- /a --> <span class="param">task</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span>, 
    <!-- a --><span class="type">IOMapper</span><!-- /a --> <span class="type">*</span><!-- a --><span class="type">mapper</span><!-- /a --> = <span class="number">0</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->true on success, false on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Note this function can be used to re-init a previously created memory descriptor.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/initWithPhysicalAddress/bool/(IOPhysicalAddress,IOByteCount,IODirection);   name=IOMemoryDescriptor::initWithPhysicalAddress --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/initWithPhysicalAddress/bool/(IOPhysicalAddress,IOByteCount,IODirection)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="initWithPhysicalAddress">initWithPhysicalAddress</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Initializes or reinitializes an IOMemoryDescriptor to describe one physical range.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">initWithPhysicalAddress</span><!-- /a -->( 
    <!-- a --><span class="type">IOPhysicalAddress</span><!-- /a --> <span class="param">address</span>, 
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">withLength</span>, 
    <!-- a --><span class="type">IODirection</span><!-- /a --> <span class="param">withDirection</span> ) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>address</code></dt>
<dd><p>The physical address of the first byte in the memory.</p></dd>
<dt><code>withLength</code></dt>
<dd><p>The length of memory.</p></dd>
<dt><code>withDirection</code></dt>
<dd><p>An I/O direction to be associated with the descriptor, which may affect the operation of the <code>prepare</code> and <code>complete</code> methods on some architectures.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->true on success, false on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method initializes an IOMemoryDescriptor for memory consisting of a single physical memory range. An IOMemoryDescriptor can be re-used by calling <code>initWithAddress</code> or <a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/initWithRanges/bool/(IOVirtualRange*,UInt32,IODirection,task_t,bool)" target="_top">initWithRanges</a> again on an existing instance -- note this behavior is not commonly supported in other I/O Kit classes, although it is supported here.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/initWithPhysicalRanges/bool/(IOPhysicalRange*,UInt32,IODirection,bool);   name=IOMemoryDescriptor::initWithPhysicalRanges --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/initWithPhysicalRanges/bool/(IOPhysicalRange*,UInt32,IODirection,bool)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="initWithPhysicalRanges">initWithPhysicalRanges</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Initializes or reinitializes an IOMemoryDescriptor to describe one or more physical ranges.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">initWithPhysicalRanges</span><!-- /a -->(
    <!-- a --><span class="type">IOPhysicalRange</span><!-- /a --> <span class="type">*</span><span class="param">ranges</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">withCount</span>, 
    <!-- a --><span class="type">IODirection</span><!-- /a --> <span class="param">withDirection</span>, 
    <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="type">asReference</span><!-- /a --> = <span class="keyword">false</span>) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>ranges</code></dt>
<dd><p>An array of IOPhysicalRange structures which specify the physical ranges which make up the memory to be described.</p></dd>
<dt><code>withCount</code></dt>
<dd><p>The member count of the <code>ranges</code> array.</p></dd>
<dt><code>withDirection</code></dt>
<dd><p>An I/O direction to be associated with the descriptor, which may affect the operation of the <code>prepare</code> and <code>complete</code> methods on some architectures.</p></dd>
<dt><code>asReference</code></dt>
<dd><p>If false, the IOMemoryDescriptor object will make a copy of the <code>ranges</code> array, otherwise, the array will be used in situ, avoiding an extra allocation.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->true on success, false on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method initializes an IOMemoryDescriptor for memory consisting of an array of physical memory ranges. An IOMemoryDescriptor can be re-used by calling initWithAddress or initWithRanges again on an existing instance -- note this behavior is not commonly supported in other I/O Kit classes, although it is supported here.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/initWithRanges/bool/(IOVirtualRange*,UInt32,IODirection,task_t,bool);   name=IOMemoryDescriptor::initWithRanges --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/initWithRanges/bool/(IOVirtualRange*,UInt32,IODirection,task_t,bool)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="initWithRanges">initWithRanges</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Initializes or reinitializes an IOMemoryDescriptor to describe one or more virtual ranges.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">initWithRanges</span><!-- /a -->(
    <!-- a --><span class="type">IOVirtualRange</span><!-- /a --> <span class="type">*</span><span class="param">ranges</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">withCount</span>, 
    <!-- a --><span class="type">IODirection</span><!-- /a --> <span class="param">withDirection</span>, 
    <!-- a --><span class="type">task_t</span><!-- /a --> <span class="param">withTask</span>, 
    <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="type">asReference</span><!-- /a --> = <span class="keyword">false</span>) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>ranges</code></dt>
<dd><p>An array of IOVirtualRange structures which specify the virtual ranges in the specified map which make up the memory to be described.</p></dd>
<dt><code>withCount</code></dt>
<dd><p>The member count of the <code>ranges</code> array.</p></dd>
<dt><code>withDirection</code></dt>
<dd><p>An I/O direction to be associated with the descriptor, which may affect the operation of the <code>prepare</code> and <code>complete</code> methods on some architectures.</p></dd>
<dt><code>withTask</code></dt>
<dd><p>The task each of the virtual ranges are mapped into. To map into the kernel's task, pass <code>kernel_task</code>. To map into the task currently running in the kernel, use the <code>task_t</code> value returned by <code>current_task()</code>. When calling this method from a user client method running in the kernel, pass the <code>task_t</code> value that was passed into <!-- a -->IOUserClient::initWithTask<!-- /a --> to map into the user process that initiated the user client.</p></dd>
<dt><code>asReference</code></dt>
<dd><p>If false, the IOMemoryDescriptor object will make a copy of the <code>ranges</code> array, otherwise, the array will be used in situ, avoiding an extra allocation.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->true on success, false on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method initializes an IOMemoryDescriptor for memory consisting of an array of virtual memory ranges each mapped into a specified source task. An IOMemoryDescriptor can be re-used by calling <!-- a -->address, IOByteCount withLength, IODirection withDirection, task_t withTask) initWithAddress<!-- /a --> or <code>initWithRanges again</code> on an existing instance -- note this behavior is not commonly supported in other I/O Kit classes, although it is supported here.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/map/IOMemoryMap*/(IOOptionBits);   name=IOMemoryDescriptor::map --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/map/IOMemoryMap*/(IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="map(IOOptionBits)">map(IOOptionBits)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Maps a IOMemoryDescriptor into the kernel map.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../IOMemoryMap/index.html#//apple_ref/cpp/cl/IOMemoryMap" target="_top" class="type"><span class="type">IOMemoryMap</span></a> <span class="type">*</span> <!-- a --><span class="function">map</span><!-- /a -->( 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <!-- a --><span class="type">options</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>options</code></dt>
<dd><p>Mapping options as in the full version of the createMappingInTask method, with kIOMapAnywhere assumed.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->See the full version of the createMappingInTask method. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This is a shortcut method to map all the memory described by a memory descriptor into the kernel map at any available address. See the full version of the createMappingInTask method for further details.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/map/IOMemoryMap*/(task_t,IOVirtualAddress,IOOptionBits,IOByteCount,IOByteCount);   name=IOMemoryDescriptor::map --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/map/IOMemoryMap*/(task_t,IOVirtualAddress,IOOptionBits,IOByteCount,IOByteCount)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="map(task_t,IOVirtualAddress,IOOptionBits,IOByteCount,IOByteCount)">map(task_t, IOVirtualAddress, IOOptionBits, IOByteCount, IOByteCount)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Maps a IOMemoryDescriptor into a task - deprecated, only safe for 32 bit tasks. Use createMappingInTask instead.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../IOMemoryMap/index.html#//apple_ref/cpp/cl/IOMemoryMap" target="_top" class="type"><span class="type">IOMemoryMap</span></a> <span class="type">*</span> <!-- a --><span class="function">map</span><!-- /a -->( 
    <!-- a --><span class="type">task_t</span><!-- /a --> <span class="param">intoTask</span>, 
    <!-- a --><span class="type">IOVirtualAddress</span><!-- /a --> <span class="param">atAddress</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span>, 
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <!-- a --><span class="type">offset</span><!-- /a --> = <span class="number">0</span>, 
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <!-- a --><span class="type">length</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>intoTask</code></dt>
<dd><p>Sets the target task for the mapping. Pass kernel_task for the kernel address space.</p></dd>
<dt><code>atAddress</code></dt>
<dd><p>If a placed mapping is requested, atAddress specifies its address, and the kIOMapAnywhere should not be set. Otherwise, atAddress is ignored.</p></dd>
<dt><code>options</code></dt>
<dd><p>Mapping options are defined in IOTypes.h,<br>
kIOMapAnywhere should be passed if the mapping can be created anywhere. If not set, the atAddress parameter sets the location of the mapping, if it is available in the target map.<br>
kIOMapDefaultCache to inhibit the cache in I/O areas, kIOMapCopybackCache in general purpose RAM.<br>
kIOMapInhibitCache, kIOMapWriteThruCache, kIOMapCopybackCache to set the appropriate caching.<br>
kIOMapReadOnly to allow only read only accesses to the memory - writes will cause and access fault.<br>
kIOMapReference will only succeed if the mapping already exists, and the IOMemoryMap object is just an extra reference, ie. no new mapping will be created.<br>
kIOMapUnique allows a special kind of mapping to be created that may be used with the IOMemoryMap::redirect() API. These mappings will not be shared as is the default - there will always be a unique mapping created for the caller, not an existing mapping with an extra reference.<br></p></dd>
<dt><code>offset</code></dt>
<dd><p>Is a beginning offset into the IOMemoryDescriptor's memory where the mapping starts. Zero is the default to map all the memory.</p></dd>
<dt><code>length</code></dt>
<dd><p>Is the length of the mapping requested for a subset of the IOMemoryDescriptor. Zero is the default to map all the memory.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A reference to an IOMemoryMap object representing the mapping, which can supply the virtual address of the mapping and other information. The mapping may be shared with multiple callers - multiple maps are avoided if a compatible one exists. The IOMemoryMap object returned should be released only when the caller has finished accessing the mapping, as freeing the object destroys the mapping. The IOMemoryMap instance also retains the IOMemoryDescriptor it maps while it exists. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This is the general purpose method to map all or part of the memory described by a memory descriptor into a task at any available address, or at a fixed address if possible. Caching &amp; read-only options may be set for the mapping. The mapping is represented as a returned reference to a IOMemoryMap object, which may be shared if the mapping is compatible with an existing mapping of the IOMemoryDescriptor. The IOMemoryMap object returned should be released only when the caller has finished accessing the mapping, as freeing the object destroys the mapping. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/performOperation/IOReturn/(IOOptionBits,IOByteCount,IOByteCount);   name=IOMemoryDescriptor::performOperation --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/performOperation/IOReturn/(IOOptionBits,IOByteCount,IOByteCount)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="performOperation">performOperation</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Performs an operation on the memory descriptor's memory.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">performOperation</span><!-- /a -->(
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span>, 
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">offset</span>,
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">length</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>options</code></dt>
<dd><p>The operation to perform on the memory:<br><code>kIOMemoryIncoherentIOFlush</code> - pass this option to store to memory and flush any data in the processor cache for the memory range, with synchronization to ensure the data has passed through all levels of processor cache. It may not be supported on all architectures. This type of flush may be used for non-coherent I/O such as AGP - it is NOT required for PCI coherent operations. The memory descriptor must have been previously prepared.<br><code>kIOMemoryIncoherentIOStore</code> - pass this option to store to memory any data in the processor cache for the memory range, with synchronization to ensure the data has passed through all levels of processor cache. It may not be supported on all architectures. This type of flush may be used for non-coherent I/O such as AGP - it is NOT required for PCI coherent operations. The memory descriptor must have been previously prepared.</p></dd>
<dt><code>offset</code></dt>
<dd><p>A byte offset into the memory descriptor's memory.</p></dd>
<dt><code>length</code></dt>
<dd><p>The length of the data range.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method performs some operation on a range of the memory descriptor's memory. When a memory descriptor's memory is not mapped, it should be more efficient to use this method than mapping the memory to perform the operation virtually.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/prepare/IOReturn/(IODirection);   name=IOMemoryDescriptor::prepare --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/prepare/IOReturn/(IODirection)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="prepare">prepare</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Prepares the memory for an I/O transfer.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <a href="../../../IOFWPhysicalAddressSpace_h/index.html#//apple_ref/c/func/prepare" target="_top" class="function"><span class="function">prepare</span></a>(
    <!-- a --><span class="type">IODirection</span><!-- /a --> <!-- a --><span class="type">forDirection</span><!-- /a --> = <span class="param">kIODirectionNone</span>) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>forDirection</code></dt>
<dd><p>The direction of the I/O just completed, or kIODirectionNone for the direction specified by the memory descriptor.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This involves paging in the memory, if necessary, and wiring it down for the duration of the transfer.  The <a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/complete/IOReturn/(IODirection)" target="_top">complete</a> method completes the processing of the memory after the I/O transfer finishes.  Note that the <code>prepare</code> call is not thread safe and it is expected that the client will more easily be able to guarantee single threading a particular memory descriptor.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/readBytes/IOByteCount/(IOByteCount,void*,IOByteCount);   name=IOMemoryDescriptor::readBytes --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/readBytes/IOByteCount/(IOByteCount,void*,IOByteCount)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="readBytes">readBytes</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Copy data from the memory descriptor's buffer to the specified buffer.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">IOByteCount</span><!-- /a --> <!-- a --><span class="function">readBytes</span><!-- /a -->(
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">offset</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">bytes</span>,
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">withLength</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>offset</code></dt>
<dd><p>A byte offset into the memory descriptor's memory.</p></dd>
<dt><code>bytes</code></dt>
<dd><p>The caller supplied buffer to copy the data to.</p></dd>
<dt><code>withLength</code></dt>
<dd><p>The length of the data to copy.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The number of bytes copied, zero will be returned if the specified offset is beyond the length of the descriptor. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method copies data from the memory descriptor's memory at the given offset, to the caller's buffer.  The memory descriptor MUST have the kIODirectionOut direcction bit set  and be prepared.  kIODirectionOut means that this memory descriptor will be output to an external device, so readBytes is used to get memory into a local buffer for a PIO transfer to the device.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/setMapping/IOMemoryMap*/(task_t,IOVirtualAddress,IOOptionBits);   name=IOMemoryDescriptor::setMapping --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/setMapping/IOMemoryMap*/(task_t,IOVirtualAddress,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setMapping">setMapping</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Establishes an already existing mapping.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../IOMemoryMap/index.html#//apple_ref/cpp/cl/IOMemoryMap" target="_top" class="type"><span class="type">IOMemoryMap</span></a> <span class="type">*</span> <!-- a --><span class="function">setMapping</span><!-- /a -->( 
    <!-- a --><span class="type">task_t</span><!-- /a --> <span class="param">task</span>, 
    <!-- a --><span class="type">IOVirtualAddress</span><!-- /a --> <span class="param">mapAddress</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <!-- a --><span class="type">options</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>task</code></dt>
<dd><p>Address space in which the mapping exists.</p></dd>
<dt><code>mapAddress</code></dt>
<dd><p>Virtual address of the mapping.</p></dd>
<dt><code>options</code></dt>
<dd><p>Caching and read-only attributes of the mapping.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A IOMemoryMap object created to represent the mapping. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method tells the IOMemoryDescriptor about a mapping that exists, but was created elsewhere. It allows later callers of the map method to share this externally created mapping. The IOMemoryMap object returned is created to represent it. This method is not commonly needed.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/setPurgeable/IOReturn/(IOOptionBits,IOOptionBits*);   name=IOMemoryDescriptor::setPurgeable --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/setPurgeable/IOReturn/(IOOptionBits,IOOptionBits*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setPurgeable">setPurgeable</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Controls the purgeable status of a memory descriptor's memory.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setPurgeable</span><!-- /a -->(
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">newState</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="type">*</span><span class="param">oldState</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>newState</code></dt>
<dd><p>The desired new purgeable state of the memory:<br><code>kIOMemoryPurgeableKeepCurrent</code> - make no changes to the memory's purgeable state.<br><code>kIOMemoryPurgeableVolatile</code> - make the memory volatile - the memory may be reclaimed by the VM system without saving its contents to backing store.<br><code>kIOMemoryPurgeableNonVolatile</code> - make the memory nonvolatile - the memory is treated as with usual allocations and must be saved to backing store if paged.<br><code>kIOMemoryPurgeableEmpty</code>       - make the memory volatile, and discard any pages allocated to it.</p></dd>
<dt><code>oldState</code></dt>
<dd><p>If non-NULL, the previous purgeable state of the memory is returned here:<br><code>kIOMemoryPurgeableNonVolatile</code> - the memory was nonvolatile.<br><code>kIOMemoryPurgeableVolatile</code> - the memory was volatile but its content has not been discarded by the VM system.<br><code>kIOMemoryPurgeableEmpty</code> - the memory was volatile and has been discarded by the VM system.<br></p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Buffers may be allocated with the ability to have their purgeable status changed - <a href="../../../IOBufferMemoryDescriptor_h/Classes/IOBufferMemoryDescriptor/index.html#//apple_ref/cpp/cl/IOBufferMemoryDescriptor" target="_top">IOBufferMemoryDescriptor</a> with the <code>kIOMemoryPurgeable</code> option, <code>VM_FLAGS_PURGEABLE</code> may be passed to <code>vm_allocate()</code> in user space to allocate such buffers. The purgeable status of such a buffer may be controlled with <a href="index.html#//apple_ref/cpp/instm/IOMemoryDescriptor/setPurgeable/IOReturn/(IOOptionBits,IOOptionBits*)" target="_top">setPurgeable</a>. The process of making a purgeable memory descriptor non-volatile and determining its previous state is atomic - if a purgeable memory descriptor is made nonvolatile and the old state is returned as <code>kIOMemoryPurgeableVolatile</code>, then the memory's previous contents are completely intact and will remain so until the memory is made volatile again.  If the old state is returned as <code>kIOMemoryPurgeableEmpty</code> then the memory was reclaimed while it was in a volatile state and its previous contents have been lost.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/setTag/void/(IOOptionBits);   name=IOMemoryDescriptor::setTag --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/setTag/void/(IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setTag">setTag</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Set the tag for the memory descriptor.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">setTag</span><!-- /a -->(
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">tag</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>tag</code></dt>
<dd><p>The tag.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method sets the tag for the memory descriptor. Tag bits are not interpreted by IOMemoryDescriptor.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOMemoryDescriptor/withAddress/IOMemoryDescriptor*/(vm_address_t,IOByteCount,IODirection,task_t);   name=IOMemoryDescriptor::withAddress --><a name="//apple_ref/cpp/clm/IOMemoryDescriptor/withAddress/IOMemoryDescriptor*/(vm_address_t,IOByteCount,IODirection,task_t)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="withAddress(vm_address_t,IOByteCount,IODirection,task_t)">withAddress(vm_address_t, IOByteCount, IODirection, task_t)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates an IOMemoryDescriptor to describe one virtual range of the specified map.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span> <!-- a --><span class="function">withAddress</span><!-- /a -->(
    <!-- a --><span class="type">vm_address_t</span><!-- /a --> <span class="param">address</span>, 
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">withLength</span>, 
    <!-- a --><span class="type">IODirection</span><!-- /a --> <span class="param">withDirection</span>, 
    <!-- a --><span class="type">task_t</span><!-- /a --> <span class="param">withTask</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>address</code></dt>
<dd><p>The virtual address of the first byte in the memory.</p></dd>
<dt><code>withLength</code></dt>
<dd><p>The length of memory.</p></dd>
<dt><code>withDirection</code></dt>
<dd><p>An I/O direction to be associated with the descriptor, which may affect the operation of the prepare and complete methods on some architectures.</p></dd>
<dt><code>withTask</code></dt>
<dd><p>The task the virtual range is mapped into. To map into the kernel's task, pass <code>kernel_task</code>. To map into the task currently running in the kernel, use the <code>task_t</code> value returned by <code>current_task()</code>. When calling this method from a user client method running in the kernel, pass the <code>task_t</code> value that was passed into <!-- a -->IOUserClient::initWithTask<!-- /a --> to map into the user process that initiated the user client.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method creates and initializes an IOMemoryDescriptor for memory consisting of a single virtual memory range mapped into the specified map.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOMemoryDescriptor/withAddress/IOMemoryDescriptor*/(void*,IOByteCount,IODirection);   name=IOMemoryDescriptor::withAddress --><a name="//apple_ref/cpp/clm/IOMemoryDescriptor/withAddress/IOMemoryDescriptor*/(void*,IOByteCount,IODirection)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="withAddress(void*,IOByteCount,IODirection)">withAddress(void *, IOByteCount, IODirection)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates an IOMemoryDescriptor to describe one virtual range of the kernel task.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span> <!-- a --><span class="function">withAddress</span><!-- /a -->(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">address</span>, 
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">withLength</span>, 
    <!-- a --><span class="type">IODirection</span><!-- /a --> <span class="param">withDirection</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>address</code></dt>
<dd><p>The virtual address of the first byte in the memory.</p></dd>
<dt><code>withLength</code></dt>
<dd><p>The length of memory.</p></dd>
<dt><code>withDirection</code></dt>
<dd><p>An I/O direction to be associated with the descriptor, which may affect the operation of the prepare and complete methods on some architectures.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method creates and initializes an IOMemoryDescriptor for memory consisting of a single virtual memory range mapped into the kernel map.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOMemoryDescriptor/withAddressRange/IOMemoryDescriptor*/(mach_vm_address_t,mach_vm_size_t,IOOptionBits,task_t);   name=IOMemoryDescriptor::withAddressRange --><a name="//apple_ref/cpp/clm/IOMemoryDescriptor/withAddressRange/IOMemoryDescriptor*/(mach_vm_address_t,mach_vm_size_t,IOOptionBits,task_t)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="withAddressRange">withAddressRange</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Create an IOMemoryDescriptor to describe one virtual range of the specified map.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span> <!-- a --><span class="function">withAddressRange</span><!-- /a -->( 
    <!-- a --><span class="type">mach_vm_address_t</span><!-- /a --> <span class="param">address</span>, 
    <!-- a --><span class="type">mach_vm_size_t</span><!-- /a --> <span class="param">length</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span>, 
    <!-- a --><span class="type">task_t</span><!-- /a --> <span class="param">task</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>address</code></dt>
<dd><p>The virtual address of the first byte in the memory.</p></dd>
<dt><code>withLength</code></dt>
<dd><p>The length of memory.</p></dd>
<dt><code>options</code></dt>
<dd><p>kIOMemoryDirectionMask (options:direction)        This nibble indicates the I/O direction to be associated with the descriptor, which may affect the operation of the prepare and complete methods on some architectures.</p></dd>
<dt><code>task</code></dt>
<dd><p>The task the virtual ranges are mapped into. Note that unlike IOMemoryDescriptor::withAddress(), kernel_task memory must be explicitly prepared when passed to this api.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method creates and initializes an IOMemoryDescriptor for memory consisting of a single virtual memory range mapped into the specified map. Note that unlike IOMemoryDescriptor::withAddress(), kernel_task memory must be explicitly prepared when passed to this api.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOMemoryDescriptor/withAddressRanges/IOMemoryDescriptor*/(IOAddressRange*,UInt32,IOOptionBits,task_t);   name=IOMemoryDescriptor::withAddressRanges --><a name="//apple_ref/cpp/clm/IOMemoryDescriptor/withAddressRanges/IOMemoryDescriptor*/(IOAddressRange*,UInt32,IOOptionBits,task_t)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="withAddressRanges">withAddressRanges</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Create an IOMemoryDescriptor to describe one or more virtual ranges.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span> <!-- a --><span class="function">withAddressRanges</span><!-- /a -->( 
    <!-- a --><span class="type">IOAddressRange</span><!-- /a --> <span class="type">*</span><span class="param">ranges</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">rangeCount</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span>, 
    <!-- a --><span class="type">task_t</span><!-- /a --> <span class="param">withTask</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>ranges</code></dt>
<dd><p>An array of IOAddressRange structures which specify the virtual ranges in the specified map which make up the memory to be described. IOAddressRange is the 64bit version of IOVirtualRange.</p></dd>
<dt><code>rangeCount</code></dt>
<dd><p>The member count of the ranges array.</p></dd>
<dt><code>options</code></dt>
<dd><p>kIOMemoryDirectionMask (options:direction)        This nibble indicates the I/O direction to be associated with the descriptor, which may affect the operation of the prepare and complete methods on some architectures. 
kIOMemoryAsReference        For options:type = Virtual or Physical this indicate that the memory descriptor need not copy the ranges array into local memory.  This is an optimisation to try to minimise unnecessary allocations.</p></dd>
<dt><code>task</code></dt>
<dd><p>The task each of the virtual ranges are mapped into. Note that unlike IOMemoryDescriptor::withAddress(), kernel_task memory must be explicitly prepared when passed to this api.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method creates and initializes an IOMemoryDescriptor for memory consisting of an array of virtual memory ranges each mapped into a specified source task. Note that unlike IOMemoryDescriptor::withAddress(), kernel_task memory must be explicitly prepared when passed to this api.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOMemoryDescriptor/withOptions/IOMemoryDescriptor*/(void*,UInt32,UInt32,task_t,IOOptionBits,IOMapper*);   name=IOMemoryDescriptor::withOptions --><a name="//apple_ref/cpp/clm/IOMemoryDescriptor/withOptions/IOMemoryDescriptor*/(void*,UInt32,UInt32,task_t,IOOptionBits,IOMapper*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="withOptions">withOptions</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Master initialiser for all variants of memory descriptors.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span><!-- a --><span class="function">withOptions</span><!-- /a -->(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">buffers</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">count</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">offset</span>, 
    <!-- a --><span class="type">task_t</span><!-- /a --> <span class="param">task</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span>, 
    <!-- a --><span class="type">IOMapper</span><!-- /a --> <span class="type">*</span><!-- a --><span class="type">mapper</span><!-- /a --> = <span class="number">0</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>buffers</code></dt>
<dd><p>A pointer to an array of IOVirtualRanges or IOPhysicalRanges if the options:type is Virtual or Physical.  For type UPL it is a upl_t returned by the mach/memory_object_types.h apis, primarily used internally by the UBC.</p></dd>
<dt><code>count</code></dt>
<dd><p>options:type = Virtual or Physical count contains a count of the number of entires in the buffers array.  For options:type = UPL this field contains a total length.</p></dd>
<dt><code>offset</code></dt>
<dd><p>Only used when options:type = UPL, in which case this field contains an offset for the memory within the buffers upl.</p></dd>
<dt><code>task</code></dt>
<dd><p>Only used options:type = Virtual, The task each of the virtual ranges are mapped into.</p></dd>
<dt><code>options</code></dt>
<dd><p>kIOMemoryDirectionMask (options:direction)        This nibble indicates the I/O direction to be associated with the descriptor, which may affect the operation of the prepare and complete methods on some architectures. 
kIOMemoryTypeMask (options:type)        kIOMemoryTypeVirtual, kIOMemoryTypePhysical, kIOMemoryTypeUPL Indicates that what type of memory basic memory descriptor to use.  This sub-field also controls the interpretation of the buffers, count, offset &amp; task parameters.
kIOMemoryAsReference        For options:type = Virtual or Physical this indicate that the memory descriptor need not copy the ranges array into local memory.  This is an optimisation to try to minimise unnecessary allocations.
kIOMemoryBufferPageable        Only used by the IOBufferMemoryDescriptor as an indication that the kernel virtual memory is in fact pageable and we need to use the kernel pageable submap rather than the default map.
kIOMemoryNoAutoPrepare        Indicates that the temporary AutoPrepare of kernel_task memory should not be performed.</p></dd>
<dt><code>mapper</code></dt>
<dd><p>Which IOMapper should be used to map the in-memory physical addresses into I/O space addresses.  Defaults to 0 which indicates that the system mapper is to be used, if present.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method creates and initializes an IOMemoryDescriptor for memory it has three main variants: Virtual, Physical &amp; mach UPL.  These variants are selected with the options parameter, see below.  This memory descriptor needs to be prepared before it can be used to extract data from the memory described.  However we temporarily have setup a mechanism that automatically prepares kernel_task memory descriptors at creation time.
</p>

<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOMemoryDescriptor/withPersistentMemoryDescriptor/IOMemoryDescriptor*/(IOMemoryDescriptor*);   name=IOMemoryDescriptor::withPersistentMemoryDescriptor --><a name="//apple_ref/cpp/clm/IOMemoryDescriptor/withPersistentMemoryDescriptor/IOMemoryDescriptor*/(IOMemoryDescriptor*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="withPersistentMemoryDescriptor">withPersistentMemoryDescriptor</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Copy constructor that generates a new memory descriptor if the backing memory for the same task's virtual address and length has changed.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span> <!-- a --><span class="function">withPersistentMemoryDescriptor</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span><span class="param">originalMD</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Either the original memory descriptor with an additional retain or a new memory descriptor, 0 for a bad original memory descriptor or some other resource shortage. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>If the original memory descriptor's address and length is still backed by the same real memory, i.e. the user hasn't deallocated and the reallocated memory at the same address then the original memory descriptor is returned with a additional reference.  Otherwise we build a totally new memory descriptor with the same characteristics as the previous one but with a new view of the vm.  Note that it is not legal to call this function with anything except an IOGeneralMemoryDescriptor that was created with the <code>kIOMemoryPersistent</code> option.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOMemoryDescriptor/withPhysicalAddress/IOMemoryDescriptor*/(IOPhysicalAddress,IOByteCount,IODirection);   name=IOMemoryDescriptor::withPhysicalAddress --><a name="//apple_ref/cpp/clm/IOMemoryDescriptor/withPhysicalAddress/IOMemoryDescriptor*/(IOPhysicalAddress,IOByteCount,IODirection)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="withPhysicalAddress">withPhysicalAddress</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates an IOMemoryDescriptor to describe one physical range.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span> <!-- a --><span class="function">withPhysicalAddress</span><!-- /a -->( 
    <!-- a --><span class="type">IOPhysicalAddress</span><!-- /a --> <span class="param">address</span>, 
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">withLength</span>, 
    <!-- a --><span class="type">IODirection</span><!-- /a --> <span class="param">withDirection</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>address</code></dt>
<dd><p>The physical address of the first byte in the memory.</p></dd>
<dt><code>withLength</code></dt>
<dd><p>The length of memory.</p></dd>
<dt><code>withDirection</code></dt>
<dd><p>An I/O direction to be associated with the descriptor, which may affect the operation of the prepare and complete methods on some architectures.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method creates and initializes an IOMemoryDescriptor for memory consisting of a single physical memory range.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOMemoryDescriptor/withPhysicalRanges/IOMemoryDescriptor*/(IOPhysicalRange*,UInt32,IODirection,bool);   name=IOMemoryDescriptor::withPhysicalRanges --><a name="//apple_ref/cpp/clm/IOMemoryDescriptor/withPhysicalRanges/IOMemoryDescriptor*/(IOPhysicalRange*,UInt32,IODirection,bool)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="withPhysicalRanges">withPhysicalRanges</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates an IOMemoryDescriptor to describe one or more physical ranges.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span> <!-- a --><span class="function">withPhysicalRanges</span><!-- /a -->( 
    <!-- a --><span class="type">IOPhysicalRange</span><!-- /a --> <span class="type">*</span><span class="param">ranges</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">withCount</span>, 
    <!-- a --><span class="type">IODirection</span><!-- /a --> <span class="param">withDirection</span>, 
    <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="type">asReference</span><!-- /a --> = <span class="keyword">false</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>ranges</code></dt>
<dd><p>An array of IOPhysicalRange structures which specify the physical ranges which make up the memory to be described.</p></dd>
<dt><code>withCount</code></dt>
<dd><p>The member count of the ranges array.</p></dd>
<dt><code>withDirection</code></dt>
<dd><p>An I/O direction to be associated with the descriptor, which may affect the operation of the <code>prepare</code> and <code>complete</code> methods on some architectures.</p></dd>
<dt><code>asReference</code></dt>
<dd><p>If false, the IOMemoryDescriptor object will make a copy of the <code>ranges</code> array, otherwise, the array will be used in situ, avoiding an extra allocation.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method creates and initializes an IOMemoryDescriptor for memory consisting of an array of physical memory ranges.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOMemoryDescriptor/withRanges/IOMemoryDescriptor*/(IOVirtualRange*,UInt32,IODirection,task_t,bool);   name=IOMemoryDescriptor::withRanges --><a name="//apple_ref/cpp/clm/IOMemoryDescriptor/withRanges/IOMemoryDescriptor*/(IOVirtualRange*,UInt32,IODirection,task_t,bool)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="withRanges">withRanges</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Create an IOMemoryDescriptor to describe one or more virtual ranges.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span> <!-- a --><span class="function">withRanges</span><!-- /a -->(
    <!-- a --><span class="type">IOVirtualRange</span><!-- /a --> <span class="type">*</span><span class="param">ranges</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">withCount</span>, 
    <!-- a --><span class="type">IODirection</span><!-- /a --> <span class="param">withDirection</span>, 
    <!-- a --><span class="type">task_t</span><!-- /a --> <span class="param">withTask</span>, 
    <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="type">asReference</span><!-- /a --> = <span class="keyword">false</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>ranges</code></dt>
<dd><p>An array of IOVirtualRange structures which specify the virtual ranges in the specified map which make up the memory to be described.</p></dd>
<dt><code>withCount</code></dt>
<dd><p>The member count of the ranges array.</p></dd>
<dt><code>withDirection</code></dt>
<dd><p>An I/O direction to be associated with the descriptor, which may affect the operation of the prepare and complete methods on some architectures.</p></dd>
<dt><code>withTask</code></dt>
<dd><p>The task each of the virtual ranges are mapped into. To map into the kernel's task, pass <code>kernel_task</code>. To map into the task currently running in the kernel, use the <code>task_t</code> value returned by <code>current_task()</code>. When calling this method from a user client method running in the kernel, pass the <code>task_t</code> value that was passed into <!-- a -->IOUserClient::initWithTask<!-- /a --> to map into the user process that initiated the user client.</p></dd>
<dt><code>asReference</code></dt>
<dd><p>If false, the IOMemoryDescriptor object will make a copy of the ranges array, otherwise, the array will be used in situ, avoiding an extra allocation.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method creates and initializes an IOMemoryDescriptor for memory consisting of an array of virtual memory ranges each mapped into a specified source task.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOMemoryDescriptor/withSubRange/IOMemoryDescriptor*/(IOMemoryDescriptor*,IOByteCount,IOByteCount,IODirection);   name=IOMemoryDescriptor::withSubRange --><a name="//apple_ref/cpp/clm/IOMemoryDescriptor/withSubRange/IOMemoryDescriptor*/(IOMemoryDescriptor*,IOByteCount,IOByteCount,IODirection)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="withSubRange">withSubRange</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates an IOMemoryDescriptor to describe a subrange of an existing descriptor.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span> <!-- a --><span class="function">withSubRange</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span><span class="param">of</span>, 
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">offset</span>, 
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">length</span>, 
    <!-- a --><span class="type">IODirection</span><!-- /a --> <span class="param">withDirection</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>of</code></dt>
<dd><p>The parent IOMemoryDescriptor of which a subrange is to be used for the new descriptor, which will be retained by the subrange IOMemoryDescriptor.</p></dd>
<dt><code>offset</code></dt>
<dd><p>A byte offset into the parent memory descriptor's memory.</p></dd>
<dt><code>length</code></dt>
<dd><p>The length of the subrange.</p></dd>
<dt><code>withDirection</code></dt>
<dd><p>An I/O direction to be associated with the descriptor, which may affect the operation of the <code>prepare</code> and <code>complete</code> methods on some architectures. This is used over the direction of the parent descriptor.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method creates and initializes an IOMemoryDescriptor for memory consisting of a subrange of the specified memory descriptor. The parent memory descriptor is retained by the new descriptor.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOMemoryDescriptor/writeBytes/IOByteCount/(IOByteCount,constvoid*,IOByteCount);   name=IOMemoryDescriptor::writeBytes --><a name="//apple_ref/cpp/instm/IOMemoryDescriptor/writeBytes/IOByteCount/(IOByteCount,constvoid*,IOByteCount)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="writeBytes">writeBytes</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Copy data to the memory descriptor's buffer from the specified buffer.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">IOByteCount</span><!-- /a --> <!-- a --><span class="function">writeBytes</span><!-- /a -->(
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">offset</span>, 
    <span class="keyword">const</span> <!-- a --><span class="var">void</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">bytes</span><!-- /a -->,
    <!-- a --><span class="var">IOByteCount</span><!-- /a --> <!-- a --><span class="var">withLength</span><!-- /a -->); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>offset</code></dt>
<dd><p>A byte offset into the memory descriptor's memory.</p></dd>
<dt><code>bytes</code></dt>
<dd><p>The caller supplied buffer to copy the data from.</p></dd>
<dt><code>withLength</code></dt>
<dd><p>The length of the data to copy.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The number of bytes copied, zero will be returned if the specified offset is beyond the length of the descriptor. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method copies data to the memory descriptor's memory at the given offset, from the caller's buffer.  The memory descriptor MUST have the kIODirectionIn direcction bit set  and be prepared.  kIODirectionIn means that this memory descriptor will be input from an external device, so writeBytes is used to write memory into the descriptor for PIO drivers.
<!-- end discussion -->
</p>
<p></p>
<h2>Structs and Unions</h2>
<hr>
<!-- headerDoc=tag;  uid=//apple_ref/cpp/tag/IOMemoryDescriptor/ExpansionData;   name=IOMemoryDescriptor::ExpansionData --><a name="//apple_ref/cpp/tag/IOMemoryDescriptor/ExpansionData"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="ExpansionData">ExpansionData</a></h3>
</td></tr></table>
<hr>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">struct</span> <a href="../../../IOFWAddressSpace_h/index.html#//apple_ref/c/tag/ExpansionData" target="_top" class="type"><span class="type">ExpansionData</span></a> { 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="var">devicePager</span><!-- /a -->; 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">int</span><!-- /a --> <!-- a --><span class="type">pagerContig</span><!-- /a -->:<span class="number">1</span>; 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">int</span><!-- /a --> <!-- a --><span class="type">unused</span><!-- /a -->:<span class="number">31</span>; 
    <a href="index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top" class="type"><span class="type">IOMemoryDescriptor</span></a> <span class="type">*</span><!-- a --><span class="var">memory</span><!-- /a -->; 
}; </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This structure will be used to expand the capablilties of this class in the future.
<!-- end discussion -->
</p>
<p></p>
<h2>Member Data</h2>
<hr>
<!-- headerDoc=data;  uid=//apple_ref/cpp/data/IOMemoryDescriptor/reserved;   name=IOMemoryDescriptor::reserved --><a name="//apple_ref/cpp/data/IOMemoryDescriptor/reserved"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="reserved">reserved</a></h3>
</td></tr></table>
<hr>
<p></p>
<pre><tt>protected</tt>
<br><a href="../../../IOFWAddressSpace_h/index.html#//apple_ref/c/tag/ExpansionData" target="_top" class="type"><span class="type">ExpansionData</span></a> <span class="type">*</span> <a href="../../../IOFWAddressSpace_h/index.html#//apple_ref/c/data/reserved" target="_top" class="var"><span class="var">reserved</span></a>; </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Reserved for future use.  (Internal use only)<!-- end discussion -->
</p>
<p></p>
<p><!-- start of footer -->

<!-- start of footer --> 
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/KernelIOKitFramework/IOMemoryDescriptor_h/Classes/IOMemoryDescriptor/index.html%3Fid%3DTP30000816-3.4&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/KernelIOKitFramework/IOMemoryDescriptor_h/Classes/IOMemoryDescriptor/index.html%3Fid%3DTP30000816-3.4&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/KernelIOKitFramework/IOMemoryDescriptor_h/Classes/IOMemoryDescriptor/index.html%3Fid%3DTP30000816-3.4&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</p>
<p>&#160;</p>
<!--#include virtual="/footer"-->
<!-- end of footer -->


<!-- end of footer -->
Last Updated: 2008-12-19
</div>
<!-- headerDoc=cl; uid=//apple_ref/cpp/cl/IOMemoryDescriptor;  name=IOMemoryDescriptor--><a name="//apple_ref/cpp/cl/IOMemoryDescriptor"></a>
</body>
</html>
