<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Archives and Serializations Programming Guide for Cocoa: Archives</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Archives"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20000946" title="Archives"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DataManagement-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000445" target="_top">Data Management</a> &gt; <a href="../index.html" target="_top">Archives and Serializations Programming Guide for Cocoa</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="objectgraphs.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Tasks/creating.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20000946-BAJDBJAI" title="Archives"></a><hr /><H1>Archives</H1><p>Archives provide a means to convert objects and values into an architecture-independent stream of bytes that preserves the identity of and the relationships between the objects and values.</p><p>Cocoa archives can hold Objective-C and Java objects, scalars, arrays, structures, and strings. They do not hold types whose implementation varies across platforms, such as <code>union</code>, <code>void *</code>, function pointers, and long chains of pointers.</p><p>Archives store object type information along with the data, so an object decoded from a stream of bytes is normally of the same class as the object that was originally encoded into the stream. Exceptions to this rule are described in <span class="content_text"><a href="../Tasks/codingobjects.html#//apple_ref/doc/uid/20000948-97072">“Making Substitutions During Coding.”</a></span></p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="archives.html#//apple_ref/doc/uid/20000946-142023">Coders</a>
				
			<br/>
			
        
			
			
				<a href="archives.html#//apple_ref/doc/uid/20000946-133256-BAJDGHID">Keyed Archives</a>
				
			<br/>
			
        
			
			
				<a href="archives.html#//apple_ref/doc/uid/20000946-133517-BAJCEGDA">Sequential Archives</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20000946-142023" title="Coders"></a><h2>Coders</h2><p>Objects are written to and read from archives with coder objects. Coder objects are instances of concrete subclasses of the abstract class <code>NSCoder</code>. <code>NSCoder</code> declares an extensive interface for taking the information stored in an object and putting it into another format suitable for writing to a file, transmitting between processes or across a network, or performing other types of data exchange. <code>NSCoder</code> also declares the interface for reversing the process, taking the information stored in a byte stream and converting it back into an object. Subclasses implement the appropriate portions of this interface to support a specific archiving format. <span class="content_text"><a href="archives.html#//apple_ref/doc/uid/20000946-133413-BAJIBHHF">Figure 1</a></span> shows the class hierarchy of the coders provided by Cocoa.</p><br/><div><a name="//apple_ref/doc/uid/20000946-133413-BAJIBHHF" title="Figure 1Class hierarchy for coders"></a><p><a name="//apple_ref/doc/uid/20000946-133413" title="Figure 1Class hierarchy for coders"></a><strong>Figure 1&nbsp;&nbsp;</strong>Class hierarchy for coders</p><img src = "art/nscoder_class_hierarchy.gif" alt = "Class hierarchy for coders" width="244" height="213"></div><br/><p>As shown in <span class="content_text"><a href="archives.html#//apple_ref/doc/uid/20000946-133413-BAJIBHHF">Figure 1</a></span>, there are three types of coders: sequential archive coders, keyed archive coders, and distributed object coders. Sequential archive coders read and write sequential archives, which must be processed linearly. In other words, objects must be decoded in the same sequence in which they were encoded in the archive. Keyed archive coders read and write keyed archives. The objects in a keyed archive are assigned names, or keys, allowing random access to archived objects. Sequential and keyed archives are described in more detail below in <span class="content_text"><a href="archives.html#//apple_ref/doc/uid/20000946-133256">“Keyed Archives”</a></span> and<span class="content_text"><a href="archives.html#//apple_ref/doc/uid/20000946-133517">“Sequential Archives.”</a></span> The distributed object coder is used only by the distributed objects architecture in Cocoa and is not described here; <code>NSPortCoder</code> is instead described in the Programming Topic <em><a href="../../DistrObjects/index.html#//apple_ref/doc/uid/10000102i" target="_top">Distributed Objects Programming Topics</a></em>.</p><p><code>NSCoder</code> defines separate methods for reading and writing objects with and without keys. The coding methods that encode and decode objects without keys are named like <code>encodeObject:</code> and <code>decodeObject</code>. The coding methods that use keys are named like <code>encodeObject:forKey:</code> and <code>decodeObjectForKey:</code>. Sequential archive coders only support the methods without keys. Coders indicate whether they support the keyed coding methods by returning <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/YES" target="_top">YES</a></code> from its <code>allowsKeyedCoding</code> method. Objects being encoded or decoded invoke this method to determine which coding methods to use. If the coder returns <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/NO" target="_top">NO</a></code>, the object must encode or decode itself using only non-keyed coding methods.</p><p>Coder objects read and write objects by sending one of two messages to the objects to be encoded or decoded. A coder sends <code>encodeWithCoder:</code> to objects when creating an archive and <code>initWithCoder:</code> when reading an archive. These messages are defined by the <code>NSCoding</code> protocol. Only objects whose class conforms to the <code>NSCoding</code> protocol can be written to an archive. (The reference for each Cocoa class indicates whether the class adopts the <code>NSCoding</code> protocol.) When an object receives one of these messages, the object sends messages back to the coder to tell the coder which objects or values, usually instance variables, to read or write next. When encoding objects, the coder records in the archive the class identity of the objects (or type of Objective-C values) and their position in the hierarchy.</p><p>Object graphs, such as the one shown in <span class="content_text"><a href="objectgraphs.html#//apple_ref/doc/uid/20001293-111742-BBCDBFCA">Figure 1</a></span>, pose two problems for a coder: redundancy and constraint. To solve these problems, <code>NSCoder</code> introduces the concepts of root objects and conditional objects, which are described in the following sections.</p><a name="//apple_ref/doc/uid/20000946-142097" title="Root Object"></a><a name="//apple_ref/doc/uid/20000946-142097-BAJFFEJA" title="Root Object"></a><h3>Root Object</h3><p>An object graph is not necessarily a simple tree structure. Two objects can contain references to each other, for example, creating a cycle. If a coder follows every link and blindly encodes each object it encounters, this circular reference will generate an infinite loop in the coder. Also, a single object can be referenced by several other objects. The coder must be able to recognize and handle multiple and circular references so that it does not encode more than one copy of each object, but still regenerate all the references when decoding.</p><p>To solve this problem, <code>NSCoder</code> introduces the concept of a root object. The root object is the starting point of an object graph. To encode an object graph, you invoke the <code>NSCoder</code> method <code>encodeRootObject:</code>, passing in the first object to encode. Every object encoded within the context of this invocation is tracked. If the coder is asked to encode an object more than once, the coder encodes a reference to the first encoding instead of encoding the object again.</p><p><code>NSCoder</code> does not implement support for root objects; <code>NSCoder</code>’s implementation of <code>encodeRootObject:</code> simply encodes the object by invoking <code>encodeObject:</code>. It is the responsibility of its concrete subclasses to keep track of multiple references to objects, thus preserving the structure of any object graphs.</p><a name="//apple_ref/doc/uid/20000946-142208" title="Conditional Objects"></a><a name="//apple_ref/doc/uid/20000946-142208-BBCFHBHA" title="Conditional Objects"></a><h3>Conditional Objects</h3><p>Another problem presented by object graphs is that it is not always appropriate to archive the entire graph. For example, when you encode an <code>NSView</code> object, the view can have many links to other objects: subviews, superviews, formatters, targets, windows, menus, and so on. If a view encoded all of its references to these objects, the entire application would get pulled in. Some objects are more important than others, though. A view’s subviews always should be archived, but not necessarily its superview. In this case, the superview is considered an extraneous part of the graph; a view can exist without its superview, but not its subviews. A view, however, needs to keep a reference to its superview, if the superview is also being encoded in the archive.</p><p>To solve this dilemma, <code>NSCoder</code> introduces the concept of a conditional object. A conditional object is an object that should be encoded only if it is being encoded unconditionally elsewhere in the object graph. A conditional object is encoded by invoking the <code>NSCoder</code> methods <code>encodeConditionalObject:</code> and <code>encodeConditionalObject:forKey:</code>. If all requests to encode an object are made with these conditional methods, the object is not encoded and references to it decode to <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/nil" target="_top">nil</a></code>. If the object is encoded elsewhere, all the conditional references decode to the single encoded object.</p><p>Typically, conditional objects are used to encode weak, or non-retained, references to objects.</p><p><code>NSCoder</code> does not implement support for conditional objects; <code>NSCoder</code>’s implementations of <code>encodeConditionalObject:</code> and <code>encodeConditionalObject:forKey:</code> simply encode the object by invoking <code>encodeObject:</code> or <code>encodeObject:forKey:</code>. It is the responsibility of its concrete subclasses to keep track of conditional objects and to not encode objects unless they are needed. Both <code>NSArchiver</code> and <code>NSKeyedArchiver</code> provide full support for conditional objects.</p><a name="//apple_ref/doc/uid/20000946-133256" title="Keyed Archives"></a><a name="//apple_ref/doc/uid/20000946-133256-BAJDGHID" title="Keyed Archives"></a><h2>Keyed Archives</h2><p>Keyed archives are created by <code>NSKeyedArchiver</code> objects and decoded by <code>NSKeyedUnarchiver</code> objects. Keyed archives differ from sequential archives in that every value encoded in a keyed archive is given a name, or key. When decoding the archive, the values can be requested by name, allowing the values to be requested in any order or not at all. This freedom enables greater flexibility for making your classes forward and backward compatible.</p><p>Keyed archives are the preferred archive type in Mac OS X version 10.2 and later.</p><p>The following sections describe how to use keyed archives.</p><a name="//apple_ref/doc/uid/20000946-133744" title="Naming Values"></a><h3>Naming Values</h3><p>Values that an object encodes to a keyed archive can be individually named with an arbitrary string. Archives are hierarchical with each object defining a separate name space for its encoded values, similar to the object’s instance variables. Therefore, keys must be unique only within the scope of the current object being encoded. The keys used by object A to encode its instance variables do not conflict with the keys used by object B, even if A and B are instances of the same class. Within a single object, however, the keys used by a subclass can conflict with keys used in its superclasses.</p><p>Public classes, such as those in a framework, which can be subclassed, should add a prefix to the name string to avoid collisions with keys that may be used now or in the future by the subclasses of the class. A reasonable prefix is the full name of the class. Cocoa classes use the prefix “NS” in their keys, the same as the API prefix, and carefully makes sure that there are no collisions in the class hierarchy. Another possibility is to use the same string as the bundle identifier for the framework. </p><p>You should avoid using “$” as a prefix for your keys. The keyed archiver and unarchiver use keys prefixed with “$” for internal values. Although they test for and mangle user-defined keys that have a “$” prefix, this overhead slows down archiving performance.</p><p>Subclasses also need to be somewhat aware of the prefix used by superclasses to avoid accidental collisions on key names. Subclasses of Cocoa classes should avoid unintentionally starting their key names with “NS”. For example, don’t name a key “NSString search options”.</p><a name="//apple_ref/doc/uid/20000946-133787" title="Return Values for Missing Keys"></a><h3>Return Values for Missing Keys</h3><p>While decoding, if you request a keyed value that does not exist, the unarchiver returns a default value based on the return type of the decode method you invoked. The default values are the equivalent of zero for each data type: <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/nil" target="_top">nil</a></code> for objects, <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/NO" target="_top">NO</a></code> for booleans, <code>0.0</code> for reals, <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Constants/Reference/reference.html#//apple_ref/doc/c_ref/NSZeroSize" target="_top">NSZeroSize</a></code> for sizes, and so on. If you need to detect the absence of a keyed value, use the <code>NSKeyedUnarchiver</code> instance method <code>containsValueForKey:</code>, which returns <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/NO" target="_top">NO</a></code> if the supplied key is not present. For performance reasons, you should avoid explicitly testing for keys when the default values are sufficient.</p><a name="//apple_ref/doc/uid/20000946-133832" title="Type Coercions"></a><h3>Type Coercions</h3><p><code>NSKeyedUnarchiver</code> supports limited type coercion. A value encoded as any type of integer, be it a standard <code>int</code> or an explicit 32-bit or 64-bit integer, can be decoded using any of the integer decode methods. Likewise, a value encoded as a <code>float</code> or <code>double</code> can be decoded as either a <code>float</code> or a <code>double</code> value. When decoding a <code>double</code> value as a <code>float</code>, though, the decoded value loses precision. If an encoded value is too large to fit within the coerced decoded type, the decoding method throws an <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Constants/Reference/reference.html#//apple_ref/doc/c_ref/NSRangeException" target="_top">NSRangeException</a></code>. Further, when trying to coerce a value to an incompatible type, such as decoding an <code>int</code> as a <code>float</code>, the decoding method throws an <code><a href="../../../Reference/Foundation/Classes/NSKeyedUnarchiver_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSInvalidUnarchiveOperationException" target="_top">NSInvalidUnarchiveOperationException</a></code>.</p><a name="//apple_ref/doc/uid/20000946-133075" title="Class Versioning"></a><h3>Class Versioning</h3><p>Versioning of encoded data is not handled through class versioning with keyed coding as it is in sequential archives. In fact, no automatic versioning is done for a class; this allows a class to at least get a look at the encoded values without the unarchiver deciding on its own that the versions fatally mismatch. A class is free to decide to encode some type of version information with its other values if it wishes, and this information can be of any type or quantity.</p><a name="//apple_ref/doc/uid/20000946-142959" title="Root Object"></a><h3>Root Object</h3><p>For keyed archives, the distinction between the root object and other objects does not apply. The regular <code>encodeObject:</code> and <code>encodeObject:forKey:</code> methods are able to track multiple references to objects in multiple object graphs. As many object graphs or values as desired may be encoded at the top level of a keyed archive.</p><p>To be consistent with the methods of <code>NSArchiver</code>, <code>NSKeyedArchiver</code> implements <code>archiveRootObject:toFile:</code> and <code>archivedDataWithRootObject:</code> to produce archives with a single object graph. These archives, however, have to be unarchived using the <code>NSKeyedUnarchiver</code> methods <code>unarchiveObjectWithFile:</code> and <code>unarchiveObjectWithData:</code>.</p><a name="//apple_ref/doc/uid/20000946-143243" title="Delegates"></a><h3>Delegates</h3><p><code>NSKeyedArchiver</code> and <code>NSKeyedUnarchiver</code> objects, unlike their non-keyed equivalents, can have delegate objects. The delegates are notified as each object is encoded or decoded. You can use the delegates to perform substitutions, replacing one object for another, if desired.</p><a name="//apple_ref/doc/uid/20000946-133051" title="Non-Keyed Coding Methods"></a><h3>Non-Keyed Coding Methods</h3><p>Keyed archivers do not have to provide names for every value encoded in the archive. The <code>NSKeyedArchiver</code> and <code>NSKeyedUnarchiver</code> classes implement the non-keyed encoding and decoding methods that they inherit from <code>NSCoder</code>. This way, a class written to work with sequential archiver objects should continue to work properly when encoded by a keyed archiver object.</p><p>The use of these non-keyed coding methods is subject to the same restrictions they have for sequential archives (see <span class="content_text"><a href="archives.html#//apple_ref/doc/uid/20000946-133517">“Sequential Archives”</a></span>): (1) you must use the proper decode method for the encode method that was used, and (2) the decoding of items must be in the same order in which they were encoded. Also, even if all the values in the archive are encoded without keys, the archive is still a keyed archive and cannot be decoded by an <code>NSUnarchiver</code> object.</p><p>With <code>NSKeyedArchiver</code> and <code>NSKeyedUnarchiver</code>, you can intermix keyed and non-keyed methods. On decode you can ask for the keyed values in any order, but the non-keyed values must be requested in the same order. If you attempt to decode non-keyed values out of order, the unarchiver may give you the wrong values or throw exceptions.</p><p>Use of the non-keyed methods within keyed coding is discouraged. Essentially, keyed coding with the non-keyed methods doesn’t solve any of the problems or limitations of non-keyed coding—it’s just writing the results to a different format.  </p><a name="//apple_ref/doc/uid/20000946-133517" title="Sequential Archives"></a><a name="//apple_ref/doc/uid/20000946-133517-BAJCEGDA" title="Sequential Archives"></a><h2>Sequential Archives</h2><p>Sequential archives were the only available archive type in Mac OS X version 10.0 and version 10.1. They are deprecated in Mac OS X v10.2 in favor of keyed archives described in <span class="content_text"><a href="archives.html#//apple_ref/doc/uid/20000946-133256">“Keyed Archives.”</a></span> Use sequential archives only for backward compatibility with earlier systems. </p><p>Sequential archives are created by <code>NSArchiver</code> objects and decoded by <code>NSUnarchiver</code> objects. Because different classes are used to encode and decode the archives, the instances are referred to as encoder and decoder objects. The sequential archive classes implement methods to create and decode archives stored in either files or <code>NSData</code> objects. <code>NSArchiver</code> and <code>NSUnarchiver</code> objects, unlike their non-keyed equivalents, can <em>not</em> have delegate objects.</p><p>Sequential archives are characterized as such because the values in the archive must be decoded in the same order in which they were encoded. You cannot skip values nor request them out of order. You must also specify the exact data type of Objective-C values when decoding the value. The decoder objects do not perform any type coercions; if a value was originally encoded as a short integer, it has to be decoded as a short integer. If you attempt to read values out of order or as the wrong data type, you will get incorrect results or cause an exception to be raised.</p><p>All the objects to be placed in a single sequential archive must be interconnected members of a single graph. In other words, there can be only one root object per archive. The only recommended way to archive objects is to send an <code>NSArchiver</code> object a single <code>encodeRootObject:</code> message, whether directly, or indirectly by invoking <code>archiveRootObject:toFile:</code> or <code>archivedDataWithRootObject:</code>. Don’t try to add data to the archive by invoking any of <code>NSCoder</code>’s other <code>encode...</code> methods, except from within the <code>encodeWithCoder:</code> method of each object that is part of the graph.</p><p>While unarchiving, <code>NSUnarchiver</code> performs a variety of consistency checks on the incoming data stream. <code>NSUnarchiver</code> raises an <code><a href="../../../Reference/Foundation/Classes/NSArchiver_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSInconsistentArchiveException" target="_top">NSInconsistentArchiveException</a></code> when</p><ul class="ul"><li class="li"><p>a class name is missing where one is expected</p></li><li class="li"><p>a class name is found that refers to an unknown class</p></li><li class="li"><p>a type code is found that is different from the one expected</p></li><li class="li"><p>an unknown type code is found</p></li><li class="li"><p>excess characters are found in a type code, or characters are missing</p></li></ul><p>To aid in backward compatibility, sequential archives have built-in support for class versioning. When an object is encoded, its class version, which is set with the <code>NSObject</code> class method <code>setVersion:</code>, is recorded in the archive. When the object is decoded, you can ask for the version number of its class in the archive. You can then decode the appropriate values for each version of the class. Typically, you have an if-else block containing separate decode sequences for each version number.</p><p>Because of the need to decode archives in a specific order and with specific data types, forward and backward compatibility becomes increasingly difficult to maintain as the application evolves. Each time the class of an archived object changes, you have to add special code to handle each version of the class that may be encountered in a pre-existing archive. If new versions of the class must create archives that can be read by older versions, you have to create the older archive, leaving out newer data. Keyed archives solve many of these problems.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="objectgraphs.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Tasks/creating.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/Archiving/Concepts/archives.html%3Fid%3D10000047i-3.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/Archiving/Concepts/archives.html%3Fid%3D10000047i-3.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/Archiving/Concepts/archives.html%3Fid%3D10000047i-3.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
