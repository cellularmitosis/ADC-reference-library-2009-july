<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>I/O Kit Fundamentals: Handling Events</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Handling Events"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP0000018" title="Handling Events"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP0000011-CH204-TPXREF101">I/O Kit Fundamentals</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Families/Families.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../DataMgmt/DataMgmt.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP0000018-BAJFFJAD" title="Handling Events"></a><h1>Handling Events</h1><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_691"></a><p>A device driver works in perhaps the most chaotic of environments within an operating system. Many devices require a sequence of commands to perform a single I/O operation. However, multiple threads can enter the driver’s code at any place and at any time, whether through client I/O requests, hardware interrupts, or timeout events; on a multiprocessor system, threads can even be running concurrently. The driver must be prepared to handle them all.</p><p>This flurry of incoming threads, each with its own event, poses some problems for a driver. The driver needs a way to protect its data structures from access by different threads because such simultaneous access can lead to data corruption, or worse. It needs to guarantee exclusive access to a thread for any single command or operation that must complete in order to preserve the integrity of the driver’s data, or to prevent a deadlock or race condition. In the I/O Kit, this protection is provided by the IOWorkLoop class and its attendant event-source classes.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJFICDI">Work Loops</a>
				
			<br/>
			
        
			
			
				<a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-TPXREF101">Event Sources</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP0000018-BAJFICDI" title="Work Loops "></a><h2>Work Loops </h2><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_692"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_693"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_694"></a><p>An <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_695"></a>IOWorkLoop object (or simply, a work loop) is primarily a gating mechanism that ensures single-threaded access to the data structures used by hardware. For some event contexts, a work loop is also a thread. In essence, a work loop is a mutually exclusive (mutex) lock associated with a thread. It does several things: </p><ul class="ul"><li class="li"><p>Its gating mechanism synchronizes the actions among event sources.</p></li><li class="li"><p>It provides a stackable environment for event handling.</p></li><li class="li"><p>It spawns a dedicated thread for the completion of indirect interrupts delivered by the interrupt controller. This mechanism serializes interrupt handling for the work loop’s driver, preventing simultaneous access to driver data by multiple interrupts.</p></li></ul><p>To put the role of the work loop in perspective, it helps first to consider the <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_696"></a>event sources that it is designed for. In the I/O Kit there are five broad categories of asynchronous events:</p><ul class="ul"><li class="li"><p><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_697"></a>Interrupt events—<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_698"></a>indirect (secondary) interrupts originating from devices</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_699"></a>Timer events—events delivered periodically by timers, such as timeouts</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_700"></a>I/O commands—I/O requests issued by driver clients to their providers</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_701"></a>Power events—typically generated through calls down the driver stack</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_702"></a>Structural events—typically events involving the I/O Registry</p></li></ul><p>The I/O Kit provides classes to handle these <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_703"></a>event sources: <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_704"></a>IOInterruptEventSource, <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_705"></a>IOTimerEventSource, and <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_706"></a>IOCommandGate. (You handle power and structural events using the mechanism provided by IOCommandGate objects.) Each of the event-source classes defines a mechanism specific to an event type for invoking a single function within the protected context of the work loop. If a thread carrying an event needs access to a driver’s critical data, it must do so through an object of one of these classes. </p><p>Generally, client drivers set up their work loops, event sources, and event handlers in their <code><!--a-->start<!--/a--></code><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_707"></a> function. In order to avoid deadlocks and race conditions, all code that accesses the same data should share a single work loop, registering their event sources with it so that a single gating mechanism is used. Work loops can be safely shared among unrelated objects, of course, and often are shared by objects at different levels in a single driver stack. Work loops can also be dedicated for use by a particular driver and its clients. See <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJDABEJ">“Shared and Dedicated Work Loops ”</a></span> for more information.<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_708"></a></p><p>The I/O Kit work-loop mechanism offers functionality roughly similar to that of the Vertical Retrace Manager, the Time Manager, and the Deferred Task Manager of Mac OS 9.</p><a name="//apple_ref/doc/uid/TP0000018-TPXREF111" title="Work Loop Architecture"></a><h3>Work Loop Architecture</h3><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_709"></a><p>The I/O Kit’s work-loop mechanism mitigates the performance penalty exacted by <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_710"></a>context switching, a by-product of the underlying event-handling model commonly used in some operating systems. To guarantee a single-threaded context for event handling, this model completes everything on one thread. Unfortunately, the transfer of work to the thread requires a switch in the context of the event-bearing thread. More precisely, when this thread goes from a running context to a non-running context, its current register state must be saved. When the secure thread completes its work, the state of the originating thread is restored and control branches back to the function originally referenced by the thread. This switching back and forth between thread contexts consumes cycles.</p><p>The work-loop model works quite differently for I/O commands and timer events. In these instances, the thread of the respective event source simply grabs the mutex lock held by the work loop. No other event from any source can be processed until the <code>Action</code> routine<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_711"></a> for the current event returns. Although the lock is mutually exclusive, it doesn’t prevent reentrancy. Also, you can have multiple work loops in the same driver stack, and this increases the possibility of <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_712"></a>deadlock. However, work loops do avoid self-<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_713"></a>deadlocks because they are based on a recursive lock: They always check to see if they are the thread that currently own the lock.</p><p>The way the I/O Kit manages interrupt event sources does involve context switching. The completion routines for interrupts run on the work loop’s thread and not on the thread delivering the interrupt. Context switching is required in this case because the <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_714"></a>interrupt controller must immediately dispatch direct (primary) interrupts to other threads to run the <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_715"></a>completion routines for those interrupts. See <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-TPXREF106">“Handling Interrupts”</a></span> for more information.</p><p>Two factors influence the order in which a <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_716"></a>work loop queries its event sources for work. The relative priority of threads is the main determinant, with timers having the highest priority. A client thread can modify its own priority and thereby expedite the delivery of I/O requests (it might not affect how soon they are processed, however, because I/O requests are usually queued in FIFO order). For interrupt event sources, which also have a relatively high priority, the order in which they are added to the work loop determines the order in which they are queried for work. See <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-TPXREF106">“Handling Interrupts”</a></span> for further details. </p><p>Regardless of event source and mechanism, a work loop is primarily used for one thing: to run the <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_717"></a>completion or <code>Action</code> routines specified by the event source. It guarantees that the routine handling an event is the only one running at any given time. This aspect of work loops raises a design point. When a thread is running code to handle an event, other events can be asynchronously delivered to their event sources, but they cannot be processed until the handler returns. Therefore event handlers should not attempt to complete large chunks of work or do anything that might <em>block</em> (that is, wait for some other process to complete), such as allocating memory or other resources. Instead they should, if possible, queue up the work or otherwise defer it for later processing.</p><a name="//apple_ref/doc/uid/TP0000018-BAJDABEJ" title="Shared and Dedicated Work Loops "></a><h3>Shared and Dedicated Work Loops </h3><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_718"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_719"></a><p>All I/O Kit services can easily share their provider’s work loop. The base of the driver Registry, representing the logic board of the computer, always contains a work loop, so a driver is assured of having a work loop even if it doesn’t create one itself. All a driver needs to do is call the IOService <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_720"></a>function <code><!--a-->getWorkLoop<!--/a--></code> to access its provider’s work loop.</p><p>In this way, an entire stack of driver objects, or a subset of such objects, can share one work loop. <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-CCDEHFDB">Figure 7-1</a></span> shows how a work loop shared by multiple driver objects uses event sources to manage access to its gating mechanism.</p><br/><div><a name="//apple_ref/doc/uid/TP0000018-CCDEHFDB" title="Figure 7-1Driver objects sharing a work loop"></a><p><strong>Figure 7-1&nbsp;&nbsp;</strong>Driver objects sharing a work loop</p><img src = "../art/workloop.gif" alt = "Driver objects sharing a work loop" width="239" height="257"></div><br/><p>Most drivers won’t create their own work loop. If hardware doesn’t directly raise interrupts in your driver, or if interrupts rarely occur in your driver, then you don’t need your own work loop. However, a driver that takes <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_721"></a>direct interrupts—in other words, that interacts directly with the interrupt controller—should create its own dedicated work loop<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_722"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_723"></a>. Examples of such drivers are PCI controller drivers (or any similar driver with a provider class of <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_724"></a>IOPCIDevice) and RAID controller drivers. Even these work loops may be shared by the driver’s clients, however, so it’s important to realize that in either case, the driver must not assume that it has exclusive use of the work loop. This means that a driver should rarely enable or disable all events on its work loop, since doing so may affect other I/O Kit services using the work loop.</p><p>If a driver handles interrupts or for some other reason needs its own work loop, it should override the IOService function <code><!--a-->getWorkLoop<!--/a--></code> to create a dedicated work loop, used by just the driver and its clients. If <code><!--a-->getWorkLoop<!--/a--></code> isn’t overridden, a driver object gets the next work loop down in its stack. </p><a name="//apple_ref/doc/uid/TP0000018-TPXREF102" title="Examples of Obtaining Work Loops"></a><h3>Examples of Obtaining Work Loops</h3><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_725"></a><p>To obtain a work loop for your client driver, you should usually use your provider’s work loop or, if necessary, create your own. To obtain your provider’s work loop, all you have to do is call the IOService function <code><!--a-->getWorkLoop<!--/a--></code> and retain the returned object. Immediately after getting your work loop you should create your event sources and add them to the work loop (making sure they are enabled).</p><p>To create a dedicated work loop for your driver, override the <code><!--a-->getWorkLoop<!--/a--></code> function. <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJDBIEG">Listing 7-1</a></span> illustrates a thread-safe implementation of <code><!--a-->getWorkLoop<!--/a--></code> that creates the work loop lazily and safely.</p><a name="//apple_ref/doc/uid/TP0000018-BAJDBIEG" title="Listing 7-1Creating a dedicated work loop"></a><p class="codesample"><strong>Listing 7-1&nbsp;&nbsp;</strong>Creating a dedicated work loop</p><div class="codesample"><table><tr><td scope="row"><pre>protected:<span></span></pre></td></tr><tr><td scope="row"><pre>    IOWorkLoop *cntrlSync;/* Controllers Synchronizing context */<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>IOWorkLoop * AppleDeviceDriver::getWorkLoop()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Do we have a work loop already?, if so return it NOW.<span></span></pre></td></tr><tr><td scope="row"><pre>    if ((vm_address_t) cntrlSync >> 1)<span></span></pre></td></tr><tr><td scope="row"><pre>        return cntrlSync;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (OSCompareAndSwap(0, 1, (UInt32 *) &amp;cntrlSync)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Construct the workloop and set the cntrlSync variable<span></span></pre></td></tr><tr><td scope="row"><pre>        // to whatever the result is and return<span></span></pre></td></tr><tr><td scope="row"><pre>        cntrlSync = IOWorkLoop::workLoop();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else while ((IOWorkLoop *) cntrlSync == (IOWorkLoop *) 1)<span></span></pre></td></tr><tr><td scope="row"><pre>        // Spin around the cntrlSync variable until the<span></span></pre></td></tr><tr><td scope="row"><pre>        // initialization finishes.<span></span></pre></td></tr><tr><td scope="row"><pre>        thread_block(0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return cntrlSync;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This code first checks if <code>cntrlSync</code> is a valid memory address; if it is, a work loop already exists, so the code returns it. Then it tests to see if some other thread is trying to create a work loop by atomically trying to compare and swap the controller synchronizer variable from 0 to 1 (1 cannot be a valid address for a work loop). If no swap occurred, then some other thread is initializing the work loop and so the function waits for the <code>cntrlSync</code> variable to stop being 1. If the swap occurred then no work loop exists and no other thread is in the process of creating one. In this case, the function creates and returns the work loop, which unblocks any other threads that might be waiting.</p><p>As you would when getting a shared work loop, invoke <code><!--a-->getWorkLoop<!--/a--></code> in <code><!--a-->start<!--/a--></code> to get your work-loop object (and then retain it). After creating and initializing a work loop, you must create and add your event sources to it. See the following section for more on event sources in the I/O Kit.<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_726"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_727"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_728"></a></p><a name="//apple_ref/doc/uid/TP0000018-TPXREF101" title="Event Sources"></a><h2>Event Sources</h2><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_729"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_730"></a><p>A work loop can have any number of event sources added to it. An event source is an object that corresponds to a type of event that a device driver can be expected to handle; there are currently event sources for hardware interrupts, timer events, and I/O commands. The I/O Kit defines a class for each of these event types<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_731"></a>: <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_732"></a>IOInterruptEventSource, <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_733"></a>IOTimerEventSource, and <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_734"></a>IOCommandGate, respectively. Each of these classes directly inherits from the abstract class <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_735"></a>IOEventSource. </p><p>An event-source object acts as a queue for events arriving from a particular event source and hands off those events to the work-loop context when it asks them for work. When you create an event-source object, you specify a <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_736"></a>callback function (also known as an “action” function) to be invoked to handle the event. Similar to the Cocoa environment’s target/action mechanism, the I/O Kit stores as instance variables in an event source the target of the event (the driver object, usually) and the action to perform. The handler’s signature must conform to an <code>Action</code> prototype declared in the header file of the event-source class. As required, the work loop asks each of its event sources in turn (by invoking their <code><!--a-->checkForWork<!--/a--></code><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_737"></a> function) for events to process. If an event source has a queued event, the work loop runs the handler code for that event in its own protected context. <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_738"></a> Note that when you register an event source with a work loop, the event source is provided with the work loop's signaling semaphore, which it uses to wake the work loop. (For more information on how the work loop sleeps and wakes, see the <code><!--a-->threadMain<!--/a--></code> function in IOWorkLoop documentation.)</p><p>A client driver, in its activation phase (usually the <code><!--a-->start<!--/a--></code> function), creates the event sources it needs and adds them to its work loop. The driver must also implement an event handler for each event source, ensuring that the function’s signature conforms to the <code>Action</code> function prototype defined for the event-source class. For performance reasons, the event handler should avoid doing anything that might block (such as allocating memory) and defer processing of large amounts of data. See <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJFICDI">“Work Loops ”</a></span> for further information on event priority and deferring work in <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_739"></a>event handlers.</p><p>The procedure for adding event sources to a work loop is similar for each type of event source. It involves four simple steps:<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_740"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_741"></a></p><ol class="ol"><li class="li"><p>Obtain your work loop.</p></li><li class="li"><p>Create the event-source object.</p></li><li class="li"><p>Add the object to the work loop.</p></li><li class="li"><p>Enable the event source.</p></li></ol><p>Disposing of an event source also has a common procedural pattern:<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_742"></a></p><ol class="ol"><li class="li"><p>Disable the event source.</p></li><li class="li"><p>Remove it from the work loop.</p></li><li class="li"><p>Release the event source.</p></li></ol><p>The following sections discuss the particulars of each event source and give examples specific to each kind.</p><a name="//apple_ref/doc/uid/TP0000018-TPXREF106" title="Handling Interrupts"></a><h3>Handling Interrupts</h3><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_743"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_744"></a><p>Interrupts are typically the most important type of event that drivers handle. They are the way that devices attached to a computer inform the operating system that an asynchronous action has occurred and that, consequently, they have some data. For example, when the user moves a mouse or plugs a Zip drive into a USB port, a hardware interrupt is generated and the affected driver is notified of this event. This section discusses interrupt handling in the I/O Kit, with particular attention to the role played by objects of IOInterruptEventSource and its subclasses.</p><a name="//apple_ref/doc/uid/TP0000018-TPXREF112" title="Interrupt Handling in the I/O Kit"></a><h4>Interrupt Handling in the I/O Kit</h4><p>The I/O Kit’s model for interrupt handling does not conform to the standard UNIX model. I/O Kit drivers nearly always work in the indirect-interrupt context instead of dealing with direct interrupts, as does the UNIX model. <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_745"></a>Indirect interrupts are less restrictive and permit the <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_746"></a>Mach scheduler to do its job. (Indirect interrupts are sometimes known as <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_747"></a>secondary interrupts and direct interrupts as <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_748"></a>primary interrupts.) The difference between the two types of interrupts has to do with the context in which the interrupt is dealt with.</p><p>Two types of events trigger an interrupt: <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_749"></a></p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_750"></a>Command-based events, such as incoming networking packets and reads of storage media</p></li><li class="li"><p>Asynchronous events, such as keyboard presses</p></li></ul><p>When an interrupt occurs, a specific interrupt line is set and, once the interrupted thread finishes the current instruction, control branches to the <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_751"></a>interrupt controller registered with the Platform Expert. When the interrupt controller receives the interrupt, its thread becomes that of the direct (primary) interrupt. There is typically only one direct interrupt in the system at any one time, and the direct-interrupt context has the highest priority in the system. The following list indicates the relative priorities of threads in the system:</p><ol class="ol"><li class="li"><p>Direct interrupt<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_752"></a></p></li><li class="li"><p>Timers and page-out<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_753"></a></p></li><li class="li"><p>Real time (multimedia)</p></li><li class="li"><p>Indirect interrupts (drivers)<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_754"></a></p></li><li class="li"><p>Window Manager<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_755"></a></p></li><li class="li"><p>User threads (including I/O requests)<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_756"></a></p></li></ol><p>Because of its extremely high priority, the direct-interrupt context has a design responsibility to hand off the interrupt to lower-priority threads as soon as possible. The interrupt controller must decode why the interrupt was taken, assign it to the appropriate driver object, and return.</p><p>In the direct-interrupt model, the target driver assumes the context carrying the direct interrupt. It must handle the interrupt in this highest-priority context. The problem with direct interrupts is that they can be neither lowered in priority nor preempted. All other interrupts are effectively disabled until the current interrupt is handled. Direct interrupts especially don’t scale well in the Mac OS X multiprocessing environment.</p><p>With indirect interrupts, the <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_757"></a>interrupt controller dispatches the interrupt it reads off the interrupt line to the appropriate interrupt event-source object of the target driver, effectively causing it to schedule on the driver’s work-loop thread. The completion (or <code><!--a-->Action<!--/a--></code>) routine defined by the event source is then run on the work-loop thread to handle the interrupt. The priority of the work-loop thread, although high compared to most client threads, is lower than the thread carrying the direct interrupt. Thus the completion routine running in the work-loop thread can be preempted by another direct interrupt. </p><p>The I/O Kit does not prohibit access to the direct-interrupt context, and in fact provides a separate programming interface for this purpose (see <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJBEFIH">“Using Interrupt Handlers With No Work Loops”</a></span>). However, use of direct interrupts is strongly discouraged.<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_758"></a></p><p>A work loop can have several <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_759"></a>IOInterruptEventSource objects attached to it. The order in which these objects are added to the work loop (through IOWorkLoop’s <code><!--a-->addEventSource<!--/a--></code><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_760"></a> function) determines the general order in which interrupts from different sources are handled.</p><p><span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJBEIFD">Figure 7-2</a></span> illustrates some of these concepts. It shows events originating from different sources being delivered to the corresponding event-source objects “attached” to the work loop. As with any event-source object, each <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_761"></a>interrupt event source acts as a queue for events of that type; when there is an event in the queue, the object signals the work loop that it has work for it. The <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_762"></a>work loop (that is, the dedicated thread) awakes and queries each installed event source in turn. If an event source has work, the work loop runs the completion routine for the event (in this case, an interrupt) in its own protected thread. The previous thread—the client thread running the event-source code—is blocked until the routine finishes processing the event. Then the work loop moves to the next interrupt event source and, if there is work, runs the completion routine for that interrupt in its protected context. When there is no more work to do, the work loop sleeps.</p><br/><div><a name="//apple_ref/doc/uid/TP0000018-BAJBEIFD" title="Figure 7-2A work loop and its event sources"></a><p><strong>Figure 7-2&nbsp;&nbsp;</strong>A work loop and its event sources</p><img src = "../art/ioworkloop.gif" alt = "A work loop and its event sources" width="566" height="270"></div><br/><p>Remember that the order in which you add interrupt event sources to a work loop determines the order of handling for specific interrupt events. <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_763"></a></p><a name="//apple_ref/doc/uid/TP0000018-TPXREF107" title="Setting Up an Interrupt Handler Attached to a Work Loop"></a><h4>Setting Up an Interrupt Handler Attached to a Work Loop</h4><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_764"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_765"></a><p>A driver typically creates an interrupt event-source object—generally of the IOInterruptEventSource or IOFilterInterruptEventSource class—in its <code><!--a-->start<!--/a--></code> function by calling the factory creation method for the class (for example,  <code><!--a-->interruptEventSource<!--/a--></code>). This method specifies the driver itself as a target and identifies an action member function (conforming to the <code><!--a-->Action<!--/a--></code> type defined for the event-source class) to be invoked as the completion routine for the event source. The factory method also associates the driver with a provider that deals with the hardware interrupt facility (usually a nub such as an IOPCIDevice). The driver then registers the event source with the work loop through IOWorkLoop’s <code><!--a-->addEventSource<!--/a--></code> function. </p><p><span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJFBHJF">Listing 7-2</a></span> provides an example for setting up an interrupt event source.<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_766"></a></p><a name="//apple_ref/doc/uid/TP0000018-BAJFBHJF" title="Listing 7-2Adding an interrupt event source to a work loop"></a><p class="codesample"><strong>Listing 7-2&nbsp;&nbsp;</strong>Adding an interrupt event source to a work loop</p><div class="codesample"><table><tr><td scope="row"><pre>myWorkLoop = (IOWorkLoop *)getWorkLoop();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>interruptSource = IOInterruptEventSource::interruptEventSource(this,<span></span></pre></td></tr><tr><td scope="row"><pre>    (IOInterruptEventAction)&amp;MyDriver::interruptOccurred,<span></span></pre></td></tr><tr><td scope="row"><pre>    provider);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (!interruptSource) {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("%s: Failed to create interrupt event source!\n", getName());<span></span></pre></td></tr><tr><td scope="row"><pre>    // Handle error (typically by returning a failure result).<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (myWorkLoop->addEventSource(interruptSource) != kIOReturnSuccess) {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("%s: Failed to add interrupt event source to work loop!\n",<span></span></pre></td></tr><tr><td scope="row"><pre>        getName());<span></span></pre></td></tr><tr><td scope="row"><pre>    // Handle error (typically by returning a failure result).<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In this example, if you do not specify a provider in the <code><!--a-->interruptEventSource<!--/a--></code> call, the event source assumes that the client will call IOInterruptEventSource’s <code><!--a-->interruptOccurred<!--/a--></code> method explicitly. Invocation of this function causes the safe delivery of asynchronous events to the driver’s IOInterruptEventSource.</p><p>Events originating from direct interrupts are handled within the work loop’s thread, which should never block indefinitely. This specifically means that the completion routines that handle interrupts, and any function they invoke, must not allocate memory or create objects, as allocation can block for unbounded periods of time.</p><p>You destroy an <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_767"></a>interrupt event source in a driver’s deactivation function (usually <code><!--a-->stop<!--/a--></code>). Before you release the IOInterruptEventSource object, you should disable it and then remove it from the work loop. <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJFBGFA">Listing 7-3</a></span> gives an example of how to do this.</p><a name="//apple_ref/doc/uid/TP0000018-BAJFBGFA" title="Listing 7-3Disposing of an IOInterruptEventSource"></a><p class="codesample"><strong>Listing 7-3&nbsp;&nbsp;</strong>Disposing of an IOInterruptEventSource</p><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_768"></a><div class="codesample"><table><tr><td scope="row"><pre>if (interruptSource) {<span></span></pre></td></tr><tr><td scope="row"><pre>    interruptSource->disable();<span></span></pre></td></tr><tr><td scope="row"><pre>    myWorkLoop->removeEventSource(interruptSource);<span></span></pre></td></tr><tr><td scope="row"><pre>    interruptSource->release();<span></span></pre></td></tr><tr><td scope="row"><pre>    interruptSource = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000018-TPXREF113" title="Filter Interrupt Event Sources "></a><h4>Filter Interrupt Event Sources </h4><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_769"></a><p>The I/O Kit supports <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_770"></a>shared interrupts, where drivers share a single interrupt line. For this purpose it defines the <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_771"></a>IOFilterInterruptEventSource class, a subclass of IOInterruptEventSource. Apple highly recommends that third-party device driver writers base their interrupt event sources on the <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_772"></a>IOFilterInterruptEventSource class instead of the <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_773"></a>IOInterruptEventSource class. The latter class does not ensure that  the sharing of interrupt lines is safe.</p><p>The IOFilterInterruptEventSource class follows the same model as its superclass except that it defines, in addition to the <code>Action</code> completion routine, a special callback function. When an interrupt occurs the interrupt invokes this function for each driver sharing the interrupt line. In this function, the driver responds by indicating whether the interrupt is something that it should handle. </p><p><span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-CJBIGCCH">Listing 7-4</a></span> shows how to set up and use an IOFilterInterruptEventSource.</p><a name="//apple_ref/doc/uid/TP0000018-CJBIGCCH" title="Listing 7-4Setting up an IOFilterInterruptEventSource"></a><p class="codesample"><strong>Listing 7-4&nbsp;&nbsp;</strong>Setting up an IOFilterInterruptEventSource</p><div class="codesample"><table><tr><td scope="row"><pre>bool myDriver::start(IOService * provider)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // stuff happens here<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOWorkLoop * myWorkLoop = (IOWorkLoop *) getWorkLoop();<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!myWorkLoop)<span></span></pre></td></tr><tr><td scope="row"><pre>        return false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create and register an interrupt event source. The provider will<span></span></pre></td></tr><tr><td scope="row"><pre>    // take care of the low-level interrupt registration stuff.<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre>    interruptSrc =<span></span></pre></td></tr><tr><td scope="row"><pre>        IOFilterInterruptEventSource::filterInterruptEventSource(this,<span></span></pre></td></tr><tr><td scope="row"><pre>                    (IOInterruptEventAction) &amp;myDriver::interruptOccurred,<span></span></pre></td></tr><tr><td scope="row"><pre>                    (IOFilterInterruptAction) &amp;myDriver::checkForInterrupt,<span></span></pre></td></tr><tr><td scope="row"><pre>                    provider);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (myWorkLoop->addEventSource(interruptSrc) != kIOReturnSuccess) {<span></span></pre></td></tr><tr><td scope="row"><pre>        IOLog("%s: Failed to add FIES to work loop.\n", getName());<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // and more stuff here...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bool myDriver::checkForInterrupt(IOFilterInterruptEventSource * src)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // check if this interrupt belongs to me<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return true; // go ahead and invoke completion routine<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void myDriver::interruptOccurred(IOInterruptEventSource * src, int cnt)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // handle the interrupt<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If your filter routine (the <code><!--a-->checkForInterrupt<!--/a--></code> routine in <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-CJBIGCCH">Listing 7-4</a></span>) returns <code>true</code>, the I/O Kit will automatically start your interrupt handler routine on your work loop. The interrupt will remain disabled in hardware until your interrupt service routine (<code><!--a-->interruptOccurred<!--/a--></code> in <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-CJBIGCCH">Listing 7-4</a></span>) completes.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_60" title="Note"></a><p><strong>Note:</strong>&nbsp;In some cases, such as the implementation of pseudo-DMA, this behavior may not be desirable.  In this case, you may choose to have your filter routine schedule the work on the work loop itself and then return <code>false</code>.  If you do this, the interrupt will not be disabled in hardware and you could receive additional primary interrupts before your work loop–level service routine completes.  Because this scheme has implications for synchronization between your filter routine and your interrupt service routine, you should avoid doing this unless your driver requires pseudo-DMA.</p></div><a name="//apple_ref/doc/uid/TP0000018-BAJBEFIH" title="Using Interrupt Handlers With No Work Loops"></a><h4>Using Interrupt Handlers With No Work Loops</h4><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_774"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_775"></a><p>The IOService class provides member functions for registering interrupt handlers that operate outside of the work-loop mechanism. These handlers can be invoked in a direct interrupt context and must call the interrupt management code of a provider such as an IOPCIDevice nub. Only one handler can be installed per interrupt source. It must be prepared to create and run its own threads and do its own locking.</p><p>Few drivers need to use interrupt handlers that are created and controlled in this way. One example where such an interrupt handler is justified is a multifunction card that needs to route direct interrupts to drivers. If you take this course, be careful. Very few system APIs are safe to call in the direct-interrupt context. </p><p>More information on this subject is forthcoming. <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_776"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_777"></a></p><a name="//apple_ref/doc/uid/TP0000018-TPXREF103" title="Handling Timer Events "></a><h3>Handling Timer Events </h3><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_778"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_779"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_780"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_781"></a><p>Device drivers occasionally need to set timers, usually to implement a <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_782"></a>timeout so the driver can determine if an I/O request doesn’t complete within a reasonable period. The <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_783"></a>IOTimerEventSource class is designed for that purpose.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_61" title="Important:"></a><p><strong>Important:</strong>&nbsp;The absolute accuracy of timeouts in the I/O Kit cannot be guaranteed. The <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_784"></a>Mach scheduler can always run a higher priority thread, which might delay the execution of the timer <code>Action</code> routine.</p><p></p></div><p>A driver creates an IOTimerEventSource with a callback <code>Action</code> function<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_785"></a> and a time at which to invoke that function, and then registers it with the work loop to run on. When the timeout passes, the event source is scheduled with the work loop. When the work loop queries it for work, the event source closes the work-loop gate (by taking the work loop’s lock), invokes the callback function, and then releases the work-loop lock to open the gate. <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJFGJGF">Listing 7-5</a></span> show how to create and register a timer event source.</p><a name="//apple_ref/doc/uid/TP0000018-BAJFGJGF" title="Listing 7-5Creating and registering a timer event source"></a><p class="codesample"><strong>Listing 7-5&nbsp;&nbsp;</strong>Creating and registering a timer event source</p><div class="codesample"><table><tr><td scope="row"><pre>myWorkLoop = (IOWorkLoop *)getWorkLoop();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>timerSource = IOTimerEventSource::timerEventSource(this,<span></span></pre></td></tr><tr><td scope="row"><pre>    (IOTimerEventSource::Action)&amp;MyDriver::timeoutOccurred);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (!timerSource) {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("%s: Failed to create timer event source!\n", getName());<span></span></pre></td></tr><tr><td scope="row"><pre>    // Handle error (typically by returning a failure result).<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (myWorkLoop->addEventSource(timerSource) != kIOReturnSuccess) {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("%s: Failed to add timer event source to work loop!\n", getName());<span></span></pre></td></tr><tr><td scope="row"><pre>    // Handle error (typically by returning a failure result).<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>timerSource->setTimeoutMS(MYDRIVER_TIMEOUT);<span></span></pre></td></tr></table></div><p>Often a driver wants to set the timer and issue an I/O request at the same time. If the I/O request completes before the timer event is triggered, the driver should cancel the timer immediately. If a timer event is triggered first, the driver typically  reissues the time-out I/O request (at which time it resets the timer). </p><p>If you want the timer event to be recurrent, you should reset the timer to the desired interval in the <code>Action</code> handler. The IOTimerEventSource class does not have a mechanism for setting periodic timers. The class does provide a few functions for setting relative and absolute timer intervals at various granularities (nanoseconds, microseconds, and so on). The code fragment in <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJFGJGF">Listing 7-5</a></span> uses <code><!--a-->setTimeoutMS<!--/a--></code> to set the timer with a specific time-out millisecond interval.</p><p>Events originating from timers are handled by the driver’s <code>Action</code> routine. As with other event handlers, this routine should never block indefinitely. This specifically means that timer handlers, and any function they invoke, must not allocate memory or create objects, as allocation can block for unbounded periods of time.</p><p>To dispose of a timer event source, you should cancel the pending timer event before removing the event source from the work loop and releasing it. <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJCGBED">Listing 7-6</a></span> illustrates how you might do this in your driver’s deactivation function.<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_786"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_787"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_788"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_789"></a></p><a name="//apple_ref/doc/uid/TP0000018-BAJCGBED" title="Listing 7-6Disposing of a timer event source"></a><p class="codesample"><strong>Listing 7-6&nbsp;&nbsp;</strong>Disposing of a timer event source</p><div class="codesample"><table><tr><td scope="row"><pre>if (timerSource) {<span></span></pre></td></tr><tr><td scope="row"><pre>    timerSource->cancelTimeout();<span></span></pre></td></tr><tr><td scope="row"><pre>    myWorkLoop->removeEventSource(timerSource);<span></span></pre></td></tr><tr><td scope="row"><pre>    timerSource->release();<span></span></pre></td></tr><tr><td scope="row"><pre>    timerSource = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000018-TPXREF104" title="I/O Requests and Command Gates "></a><h3>I/O Requests and Command Gates </h3><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_790"></a><p>Driver clients use <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_791"></a>IOCommandGate objects to issue <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_792"></a>I/O requests to a driver. A command gate controls access to the work-loop lock, and in this way it serializes access to the data involved in I/O requests. It does not require a thread context switch to ensure single-threaded access. An IOCommandGate event source simply takes the work-loop lock before it runs its <code>Action</code> routine; by doing so, it prevents other event sources on the same work loop from scheduling. This makes it an efficient mechanism for I/O transfers.</p><p>Note that nub classes usually define <code>Action</code> functions for their own clients to use, so that driver classes don’t have to use command gates themselves.</p><a name="//apple_ref/doc/uid/TP0000018-TPXREF114" title="Up Calls and Down Calls"></a><h4>Up Calls and Down Calls</h4><p>Calls originated by clients through a command gate are known as <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_793"></a>down calls. These always originate in a thread other than the work loop’s context, and so they may safely block without causing a <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_794"></a>deadlock (as long as they don’t hold the work-loop gate). All allocation should occur on the down-call side of an I/O request before the command gate is closed.</p><p><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_795"></a>Up calls, which are originated by an interrupt or timer event, occur within the work loop’s context and should never block indefinitely. This specifically means that interrupt and timeout handlers, and any function they invoke, must not allocate memory or create objects, as allocation can block and, as a potential consequence, cause a <a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_796"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_797"></a>paging deadlock.</p><p>It’s possible for an up call to result in a client notification that immediately results in another I/O request through the command gate. A work loop can handle recursive closing of its gate by the same thread, so this situation never results in deadlock. However, because the new request is occurring on the context of an up call, that request cannot block; this concern belongs to the system client making the I/O request, though, so you need never worry about this as a driver developer.</p><a name="//apple_ref/doc/uid/TP0000018-TPXREF105" title="Setting Up and Using Command Gates"></a><h4>Setting Up and Using Command Gates</h4><p>Prior to closing a command gate, you should adequately prepare the I/O request. An I/O request involves three things: the command itself (which is family-specific), the memory involved in the transfer (defined as an IOMemoryDescriptor object), and the function to call to process the request within the context of the command gate.   See <span class="content_text"><a href="../DataMgmt/DataMgmt.html#//apple_ref/doc/uid/TP0000019-BCIFGGBI">“Managing Data”</a></span> for information on IOMemoryDescriptors and related objects. </p><p>Command gates should be closed for the briefest possible period, during which the least amount of work possible is performed. The longer a command gate holds the work-loop lock, the greater the likelihood of contention. As with all event sources, the command-gate function should not allocate memory or any other unbounded resource because of the danger of blocking. Instead, the client should preallocate the required resources before control is transferred to the work-loop context. For example, it could allocate a pool of resources in its <code><!--a-->start<!--/a--></code> function.</p><p>You create an IOCommandGate object by calling the <code><!--a-->commandGate<!--/a--></code> factory method<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_798"></a>, specifying as parameters the object “owner” of the event source (usually <code>this</code>) and a pointer to a function conforming to the <code>Action</code> prototype. You then register the command gate with the client’s work loop using IOWorkLoop’s <code><!--a-->addEventSource<!--/a--></code> function<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_799"></a>. <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJECHEC">Listing 7-7</a></span> gives an example of this procedure.<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_800"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_801"></a></p><a name="//apple_ref/doc/uid/TP0000018-BAJECHEC" title="Listing 7-7Creating and registering a command gate"></a><p class="codesample"><strong>Listing 7-7&nbsp;&nbsp;</strong>Creating and registering a command gate</p><div class="codesample"><table><tr><td scope="row"><pre>workLoop = (IOWorkLoop *)getWorkLoop();<span></span></pre></td></tr><tr><td scope="row"><pre>commandGate = IOCommandGate::commandGate(this,<span></span></pre></td></tr><tr><td scope="row"><pre>                 (IOCommandGate::Action)receiveMsg);<span></span></pre></td></tr><tr><td scope="row"><pre>if (!commandGate ||<span></span></pre></td></tr><tr><td scope="row"><pre>    (workLoop->addEventSource(commandGate) != kIOReturnSuccess) ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    kprintf("can't create or add commandGate\n");<span></span></pre></td></tr><tr><td scope="row"><pre>    return false;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The IOCommandGate class provides two alternatives for initiating the execution of an I/O request within the command gate. One is the <code>runCommand</code> member function<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_802"></a> and the other is the <code><!--a-->runAction<!--/a--></code> member function<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_803"></a>. These functions work similarly. When the client wishes to invoke the <code><!--a-->Action<!--/a--></code> function, rather than invoking it directly, it invokes the command gate’s <code><!--a-->runCommand<!--/a--></code> or <code><!--a-->runAction<!--/a--></code> function, passing in all required arguments. The command gate then grabs the work-loop lock (that is, it closes the command gate), invokes the <code><!--a-->Action<!--/a--></code> function, and then opens the gate. </p><p>Where the two functions differ is in their flexibility. The <code><!--a-->runCommand<!--/a--></code> function makes use of the same target/action mechanism used by the other event-source classes. In this mechanism, the created IOCommandGate object encapsulates (a pointer to) an <code><!--a-->Action<!--/a--></code> function as well as the target (or “owner”) object that implements this function. In this model, only  one <code><!--a-->Action<!--/a--></code> function can be invoked for an I/O request. </p><p>However, a driver often has to deal with multiple sources of I/O requests. If this is the case, you can use the <code><!--a-->runAction<!--/a--></code> function to issue I/O requests in multiple command gates. This function lets you define the function to be called within the command-gate context; you must specify a pointer to this function as the first parameter.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_62" title="Important:"></a><p><strong>Important:</strong>&nbsp;Do not call the <code><!--a-->runAction<!--/a--></code> or <code><!--a-->runCommand<!--/a--></code> function from interrupt context.</p><p></p></div><p><span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJFEDJD">Listing 7-8</a></span> illustrates one the use of the <code><!--a-->runCommand<!--/a--></code> function to issue an I/O request.</p><a name="//apple_ref/doc/uid/TP0000018-BAJFEDJD" title="Listing 7-8Issuing an I/O request through the command gate"></a><p class="codesample"><strong>Listing 7-8&nbsp;&nbsp;</strong>Issuing an I/O request through the command gate</p><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_804"></a><div class="codesample"><table><tr><td scope="row"><pre>void ApplePMU::enqueueCommand ( PMUrequest * request )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    commandGate->runCommand(request);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void receiveMsg ( OSObject * theDriver, void * newRequest, void *, void *, void * )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ApplePMU * PMUdriver = (ApplePMU *) theDriver;<span></span></pre></td></tr><tr><td scope="row"><pre>    PMUrequest * theRequest = (PMUrequest*)newRequest;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Inserts the request in the queue:<span></span></pre></td></tr><tr><td scope="row"><pre>    theRequest->prev = PMUdriver->queueTail;<span></span></pre></td></tr><tr><td scope="row"><pre>    theRequest->next = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( PMUdriver->queueTail != NULL ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        PMUdriver->queueTail->next = theRequest;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        PMUdriver->queueHead = theRequest;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    PMUdriver->queueTail =  theRequest;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If we can, we process the next request in the queue:<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( (PMUdriver->PGE_ISR_state == kPMUidle) &amp;&amp; !PMUdriver->adb_reading) {<span></span></pre></td></tr><tr><td scope="row"><pre>        PMUdriver->CheckRequestQueue();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In this example, the <code><!--a-->runCommand<!--/a--></code> function is used to indirectly invoke the command gate’s <code><!--a-->Action<!--/a--></code> function, <code><!--a-->receiveMsg<!--/a--></code>. One important tactic that this example shows is how to defer processing I/O requests—when allocation of memory and other resources might be necessary—until no more events are queued at the command gate. The <code><!--a-->receiveMsg<!--/a--></code> function queues up each incoming request and, if no more requests are pending, calls a <code><!--a-->CheckRequestQueue<!--/a--></code> function to do the actual I/O work.</p><p>A typical procedure is to set a timeout (using an IOTimerEventSource object) at the same time you issue an I/O request. If the I/O request does not complete within a reasonable period, the timer is triggered, giving you the opportunity to correct any problem (if possible) and reissue the I/O request. If the I/O request is successful, remember to disable the timer. See <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-TPXREF103">“Handling Timer Events ”</a></span> for details on using IOTimerEventSources.</p><p>You destroy an command-gate event source in a driver’s deactivation function (usually <code><!--a-->stop<!--/a--></code>). Before you release the IOCommandGate object, you should remove it from the work loop. <span class="content_text"><a href="HandlingEvents.html#//apple_ref/doc/uid/TP0000018-CJBDACGB">Listing 7-9</a></span> gives an example of how to do this.</p><a name="//apple_ref/doc/uid/TP0000018-CJBDACGB" title="Listing 7-9Disposing of an IOCommandGate"></a><p class="codesample"><strong>Listing 7-9&nbsp;&nbsp;</strong>Disposing of an IOCommandGate</p><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_805"></a><div class="codesample"><table><tr><td scope="row"><pre>if (commandGate) {<span></span></pre></td></tr><tr><td scope="row"><pre>    myWorkLoop->removeEventSource(commandGate);<span></span></pre></td></tr><tr><td scope="row"><pre>    commandGate->release();<span></span></pre></td></tr><tr><td scope="row"><pre>    commandGate = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000018-TPXREF116" title="Completion Chaining"></a><h4>Completion Chaining</h4><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_806"></a><p>Occasionally, the driver writer must deal with constraints imposed by hardware, such as a maximum byte size for requests that are at odds with what the driver’s client expects. For example, the hardware may transfer data in 64-kilobyte chunks, but the driver’s client expects to transfer data in 128-byte buffers.</p><p>For situations such as this, the driver writer can do completion chaining. In completion chaining, one I/O request is used to trigger another I/O request asynchronously. Completion chaining is a way to break up an original I/O request into a series of smaller requests in response to the constraints of hardware. For example, the first requests can be to read the data, the second to modify it appropriately, and the third to write the data in the expected size to the provider and return, as expected, to the originator of the request. Each leg of the compound request is asynchronous; it issues the next request upon completion of the current request.</p><p>It generally works like this. A driver’s command gate initiates an I/O request. The request carries a pointer to the new completion routine, implemented in your driver, along with an opaque context structure known only to your driver. The original completion information from your driver’s client is also saved away inside this context. When the request completes, your completion routine is called in place of the original one, with your context passed in. Your completion routine would submit the next leg of the request, if any; otherwise, it would invoke the original completion when the compound request completes. Completion chaining thus permits a linked list of I/O requests that are scheduled one after another, entirely asynchronously. </p><p>For an example of completion chaining, look at the implementation of the IOBlockStorageDriver class, especially the <code><!--a-->deblockRequestCompletion<!--/a--></code> and <code><!--a-->deblockRequest<!--/a--></code> methods. You can find the implementation of this class in the IOStorageFamily project in the Darwin Open Source project.<a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_807"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_808"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_809"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_810"></a><a name="//apple_ref/doc/uid/TP0000018-DontLinkElementID_811"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Families/Families.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../DataMgmt/DataMgmt.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-05-17<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/HandlingEvents/HandlingEvents.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/HandlingEvents/HandlingEvents.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/HandlingEvents/HandlingEvents.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>