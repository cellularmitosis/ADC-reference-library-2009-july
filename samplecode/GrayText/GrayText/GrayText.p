{	File:		GrayText.p	Contains:	GrayText demonstrates two methods of creating grayscale text.  On PostScript				printers it sends PostScript, on QuickDraw printers it sends Color QuickDraw calls. 				If a QuickDraw printer does not use a CGrafPort, the gray text comes out as black.				Unfortunately, there's currently no good way to handle that situation.							Note: I'm assuming Color QuickDraw is present, but the app should really check for				that with Gestalt.	Written by: Dave Hersey		Copyright:	Copyright © 1991-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/26/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				} PROGRAM GrayText;USES	Memory, QuickDraw, Traps, Printing, Packages, PrintComments,Fonts;{*------ SendPostScript ------------------------------------------------------------*}PROCEDURE SendPostScript(theComment: Str255);VAR    PSCommand	: Str255;    CommandHdl	: Handle;    CRString	: Str255;    theError	: OSErr;BEGIN    CRString := ' ';    CRString[1] := CHR(13);    PSCommand := theComment;    PSCommand := CONCAT(PSCommand, CRString);    theError := PtrToHand(POINTER(ORD(@PSCommand) + 1), CommandHdl, LENGTH(PSCommand));    PicComment(PostScriptHandle, LENGTH(PSCommand), CommandHdl);    DisposeHandle(CommandHdl);END;{*------ DrawStuff -----------------------------------------------------------------*}{** **  	DrawStuff will send some PostScript that draws gray text to a printer **		that talks PostScript. It will also send the correct QuickDraw **		representation of this to printers that do not talk PostScript. **} PROCEDURE DrawStuff (boundsRect : Rect; theGPort : GrafPtr); VAR   oldPort  : 	GrafPtr;   fNum		:	Integer;   rgb		:	RGBColor;    BEGIN	GetPort (oldPort);	SetPort (theGPort);	PenSize(0, 0);	MoveTo(10, 10); 	Line(0, 0);	PenSize(1, 1);		{**	 ** This line tells the LaserWriter driver to ignore Quickdraw calls until it         ** receives a PostScriptEnd picture comment.  This line is ignored by Quickdraw      ** printer drivers (ie. the ImageWriter driver).	 **}		PicComment (PostScriptBegin, 0, NIL);		{**		 ** QuickDraw representation of the document. These calls		 ** will only be executed by QuickDraw printers.		 **}		GetFNum('Times', fNum);		(* Set the font to Times Bold Italic 96 pt. *)	TextFont(fNum);	TextSize(96);	TextFace([bold, italic]);	rgb.red := 52428;			(* 80% of 65535. *)	rgb.green := 52428;	rgb.blue := 52428;	RGBForeColor(rgb);			(* Set an 80% gray pen. *)	MoveTo(10, 100);			(* Move and draw. *)	DrawString('Sample Text.');	ForeColor(blackColor);		(* Reset foreground color. *)		{**		 ** PostScript representation of the document. These calls		 ** will only be executed by PostScript printers.		 **}	SendPostScript('0 760 translate 1 -1 scale');	SendPostScript('/Times-BoldItalic findfont 96 scalefont setfont');	SendPostScript('10 660 moveto .8 setgray (Sample Text.) show');		 	{**	 ** This comment tells the LaserWriter driver tro start executing 	 ** QuickDraw calls normally.	 **}	PicComment (PostScriptEnd, 0, NIL);    SetPort(oldPort); END;  {**  DrawStuff  **}{*------ PrintStuff ----------------------------------------------------------------*}{** **		PrintStuff will call all of the necessary Print Manager calls to print  **		a document. It checks PrError() after each Print Manager call. If an error  **     is found, all of the Print Manager open calls (i.e. PrOpen, PrOpenDoc...)  **		will have a corresponding close call before the error is posted to the user.  **		You want to use this approach to make sure the Print Manager closes properly  **		and all temporary memory is released. **}PROCEDURE PrintStuff;VAR  oldPort  			: GrafPtr;  thePrRecHdl		: THPrint;  thePrPort			: TPPrPort;  theStatus			: TPrStatus;	BEGIN   GetPort(oldPort);	   thePrRecHdl := THPrint(NewHandle(SIZEOF(TPrint)));	   IF (MemError = noErr) AND (thePrRecHdl <> NIL) THEN	BEGIN	   PrOpen;	   IF (PrError = noErr) THEN		BEGIN		   PrintDefault(thePrRecHdl);           IF (PrError = noErr) THEN		    BEGIN			   IF (PrStlDialog(thePrRecHdl)) THEN			    BEGIN				   IF (PrJobDialog(thePrRecHdl)) THEN 					BEGIN     			   	  thePrPort := PrOpenDoc(thePrRecHdl, NIL, NIL);					  IF (PrError = noErr) THEN						BEGIN           		          PrOpenPage(thePrPort, NIL);													      IF (PrError = noErr) THEN							BEGIN        					  {**        					 	 rPage (IM II-150) is the printable area for the          					 	 currently selected printer. By passing the current          					 	 port to the draw routine, enables your app        					 	 to use the same routine to draw to the screen        					 	 and the printer's GrafPort.        					   **}									        			           DrawStuff (thePrRecHdl^^.prInfo.rPage,         			         			  GrafPtr (thePrPort));								 							 END;							PrClosePage(thePrPort);						  END;							 						  PrCloseDoc(thePrPort);							 						  IF (thePrRecHdl^^.prJob.bJDocLoop = bSpoolLoop) and (PrError = noErr) THEN           					PrPicFile(thePrRecHdl, NIL, NIL, NIL, @theStatus);					  END;				  END;			  END;		  END;				PrClose;	 END;END;  {**  PrintStuff  **}{*------ main ----------------------------------------------------------------------*}BEGIN	    InitGraf(@qd.thePort);	InitFonts;	FlushEvents(everyEvent, 0);		InitWindows;	InitMenus;	TEInit;	InitDialogs(NIL);	InitCursor;	PrintStuff;END. {**  main  **}