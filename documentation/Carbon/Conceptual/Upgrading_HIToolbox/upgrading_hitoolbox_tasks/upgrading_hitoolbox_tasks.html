<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Upgrading to the Mac OS X HIToolbox: Porting Steps</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Porting Steps"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001140-CH203" title="Porting Steps"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../HumanInterfaceToolbox-date.html#//apple_ref/doc/uid/TP30000440-TP30000420-TP30000516" target="_top">Human Interface Toolbox</a> &gt; <a href="../upgrading_hitoolbox_intro/upgrading_hitoolbox_intro.html#//apple_ref/doc/uid/TP30001140-CH201-DontLinkElementID_17">Upgrading to the Mac OS X HIToolbox</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../upgrading_hitoolbox_conc/upgrading_hitoolbox_conc.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../upgrading_hitoolbox_samp/upgrading_hitoolbox_samp.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_27" title="Porting Steps"></a><h1><a name="//apple_ref/doc/uid/TP30001140-CH203-BABHCIAC" title="Porting Steps"></a>Porting Steps</h1><p>This chapter focuses on the steps required to modernize your user interface code, moving your application to views and composited windows. The following sections describe the porting process:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABHECGE">“Convert Resources to Nibs”</a></span>: Part of this process is to move away from old Dialog Manager calls.</p></li><li class="li"><p><span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABFAHDB">“Adopt Carbon Events”</a></span>: If you are still using <code>WaitNextEvent</code>, now is the time to move to the more efficient Carbon event model. </p></li><li class="li"><p><span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABCCBIJ">“Put Custom Content Into Views”</a></span>: If you have nonstandard controls or content, you may need to implement your own views.</p></li><li class="li"><p><span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABJEAGH">“Turn On Compositing”</a></span>: Only composited windows gain the full benefits of using HIViews. </p></li><li class="li"><p><span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABDCIHG">“Additional Steps”</a></span>: These steps are miscellaneous changes resulting from moving to HIViews, such as translating graphics coordinates.</p></li></ul><p>Before you begin adopting views, you should be familiar with the contents of <em><a href="../../HIViewDoc/index.html#//apple_ref/doc/uid/TP30000923" target="_top">HIView Programming Guide</a></em>. This document outlines the concepts behind HIView, how the older control, windows, and menus map to the HIView world, and gives examples of implementing views. You should examine all your windows and menus to estimate the changes that would be required to adopt HIView. In most cases, the more you rely on standard user interface elements, the easier the porting process. You can choose to port on a window-by-window basis, as time and resources permit. </p><p>If you have custom controls, check to see if their functionality is now available in a standard control or view. For example, in the past combining an editable text field with an integral pop-up menu required custom code; now you can simply create an HIView-based combo box to gain the same functionality. Adopting other views, such as the scroll view, might help to reduce or eliminate large chunks of legacy code. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-BABHECGE" title="Convert Resources to Nibs"></a><h2>Convert Resources to Nibs</h2><p>If you have legacy Mac OS code, many of your windows, controls, and menus are likely stored as resources. Similarly, you may be relying on the Dialog Manager to handle many of your windows. In both cases, in order to prepare your application for views and composited windows, you must move from resource-based interface elements to Interface Builder nibs.</p><p>Nibs provide an XML-based description for windows, controls, and menus. You create and manipulate them using the Interface Builder tool in Xcode. Interface Builder provides a simple graphical interface for building user interfaces, in which you can simply drag interface elements around to build menus, dialogs, and so on. If you are not familiar with Interface Builder, the <span class="content_text"><a href="../../../../DeveloperTools/Conceptual/XcodeQuickTour/qt_interfaces/qt_interfaces.html#//apple_ref/doc/uid/TP30000890-CH206" target="_top">“Designing a User Interface”</a></span> section in <em><a href="../../../../DeveloperTools/Conceptual/XcodeQuickTour/index.html#//apple_ref/doc/uid/TP30000890" target="_top">Xcode Quick Tour for Mac OS X</a></em> is a good introduction. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_28" title="Note"></a><p><strong>Note:</strong>&nbsp;You do not need to build your application with Xcode to use Interface Builder or nib files. </p></div><p>For Mac OS X v10.3 and later, Interface Builder (version 2.4) allows you to import older compiled resource files (<code>.rsrc</code>) files, converting them automatically into nibs. In some ways, Interface Builder is like a more modern, advanced version of the ResEdit resource editor (<span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-CECGFFIJ">Figure 3-1</a></span>). </p><br/><div><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_29" title="Figure 2-1A dialog resource in ResEdit"></a><p><a name="//apple_ref/doc/uid/TP30001140-CH203-CECGFFIJ" title="Figure 2-1A dialog resource in ResEdit"></a><strong>Figure 2-1&nbsp;&nbsp;</strong>A dialog resource in ResEdit</p><img src = "../art/resedit_dialog.gif" alt = "A dialog resource in ResEdit" width="505" height="425"></div><br/><p>To import a file, simply choose Import Resource File from the Import submenu of the File menu and choose your file from the resulting dialog window. Selecting a <code>.rsrc</code> file brings up a resource selection dialog as shown in <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABCHAED">Figure 3-2</a></span>.</p><p>You can choose to import some or all of the resources contained in your <code>.rsrc</code> file. You can import any of the standard <code>'WIND'</code>, <code>'DLOG'</code>, and <code>'MENU'</code> resources. Note that if your <code>'DLOG'</code> resource uses an item list (<code>'DITL'</code>) resource, Interface Builder automatically imports items in the list into the dialog window. </p><br/><div><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_30" title="Figure 2-2The resource selection dialog window"></a><p><a name="//apple_ref/doc/uid/TP30001140-CH203-BABCHAED" title="Figure 2-2The resource selection dialog window"></a><strong>Figure 2-2&nbsp;&nbsp;</strong>The resource selection dialog window</p><img src = "../art/resource_chooser.gif" alt = "The resource selection dialog window" width="273" height="318"></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_31" title="Note"></a><p><strong>Note:</strong>&nbsp;Depending on the number of resources you are converting, you can also choose to ignore your old resources and simply rebuild your user interface elements in Interface Builder. </p></div><p>You should check the windows, controls, and menus to make sure that they were imported correctly. Note that in a nib file, dialog resources simply become windows, and any dialog items are translated into controls (<span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-CECJHHFA">Figure 3-3</a></span>). Because of this mapping, you will probably need to update any Dialog Manager calls. See <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-CECIGBHG">“Update Dialog Manager Functions”</a></span> for more information. </p><br/><div><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_32" title="Figure 2-3A dialog resource imported into Interface Builder"></a><p><a name="//apple_ref/doc/uid/TP30001140-CH203-CECJHHFA" title="Figure 2-3A dialog resource imported into Interface Builder"></a><strong>Figure 2-3&nbsp;&nbsp;</strong>A dialog resource imported into Interface Builder</p><img src = "../art/IB_dialog.gif" alt = "A dialog resource imported into Interface Builder" width="475" height="357"></div><br/><p>Some tips:</p><ul class="ul"><li class="li"><p>The Info window in Interface Builder lets you choose Default and Cancel behavior for simple push buttons. Specifying these behaviors also enables the keyboard shortcuts (that is, Esc for Cancel, and Return or Enter for the default), so you do not need to handle them yourself. </p></li><li class="li"><p>Be sure to specify the window class and theme brush for each window you import using the Info window. Doing so ensures that your window has the look appropriate to its type. </p></li></ul><p>In addition, you should be aware of the following changes:</p><ul class="ul"><li class="li"><p>If your resources used custom controls, the nib replaces them with generic custom control placeholders. While the Info window shows that you can use a procedure pointer–based custom definition, you should convert your control to an event-based HIView. Note that if you use HIView-based controls, you need to replace the custom control placeholder with the HIView placeholder. </p></li><li class="li"><p>All user items are translated into user panes. Depending on what you used the user item for, you probably want to change this to a different control. For example, if you used it to visually group several controls, you should replace it with a group box. For simple static images and drawing, you can simply add <code>kEventControlDraw</code> handlers to the user pane that Interface Builder substituted for your item. More complex user items may need to be reimplemented as custom views. See <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABCCBIJ">“Put Custom Content Into Views”</a></span> for more information.</p></li><li class="li"><p>Modern windows and controls are based on a hierarchy, which means that some controls may be embedded in others. If your old resources did not use hierarchies, you should update the resulting nib file appropriately. For example, if you used a user item to group controls, you should replace the user item with a group box and then embed the controls within the group box. In Interface Builder, dragging a control into the bounds of the group box embeds it automatically.</p></li></ul><p>Note that window resources imported into Interface Builder do not automatically become Aqua compliant; if you have not already done so, you will probably have to reposition, resize, or otherwise tweak controls, text, and so on, to conform to <em><a href="../../../../UserExperience/Conceptual/AppleHIGuidelines/index.html#//apple_ref/doc/uid/20000957" target="_top">Apple Human Interface Guidelines</a></em>. While this may seem like an afterthought, taking the extra time to adjust your windows now pays off in a better overall user experience. </p><p>Next, you need to update your application code to load the user interface elements from the nib. Note that you need to place the nib file in the Resources folder of your application’s bundle. </p><p><span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BCIBCDFB">Listing 3-1</a></span> shows how you would load a menu bar from a nib file. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_33" title="Listing 2-1Creating a menu bar from a nib file"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001140-CH203-BCIBCDFB" title="Listing 2-1Creating a menu bar from a nib file"></a><strong>Listing 2-1&nbsp;&nbsp;</strong>Creating a menu bar from a nib file</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus err;<span></span></pre></td></tr><tr><td scope="row"><pre>IBNibRef theNib;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>err = CreateNibReference (CFSTR("MyGuitar"), &amp;theNib); <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>if (!err)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>    SetMenuBarFromNib (theNib, CFSTR("GuitarMenu")); <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    DisposeNibReference (theNib); <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>The Interface Builder Services function <code>CreateNibReference<a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_51"></a></code> creates a nib reference that points to the specified file. In this case, the file is <code>MyGuitar.nib</code> (you don’t need to specify the <code>.nib</code> extension when calling this function). The <code>CFSTR</code> macro converts the string into a Core Foundation string, which is the format that <code>CreateNibReference</code> expects. </p></li><li class="li"><p>The Interface Builder Services function <code>SetMenuBarFromNib</code><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_52"></a> uses the nib reference to access a menu bar within the nib file. The name of the menu bar (<code>GuitarMenu</code> in this example) is the name you assigned to it in the Instances pane of the nib file window. Like the <code>CreateNibReference</code> function, <code>SetMenuBarFromNib</code> expects a Core Foundation string for the menu bar name, so it must first be converted using <code>CFSTR</code>. </p><p>Note that <code>SetMenuBarFromNib</code> automatically sets the menu bar you specified to be visible. If for some reason you want to create a menu bar but don’t want it to be immediately visible, you can call <code>CreateMenuBarFromNib</code>. You can then call <code>SetMenuBar</code> to make it the main menu bar. </p><p>If you want to load individual menus, you can call the Interface Builder Services function <code>CreateMenuFromNib</code> after you create the nib reference. </p></li><li class="li"><p>When you no longer need the nib reference, you should call the Interface Builder Services function <code>DisposeNibReference<a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_53"></a></code> to remove it. </p></li></ol><p>Creating a window from a nib file is similar, except that you call <code>CreateWindowFromNib</code>, as shown in <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-CECHDFJG">Listing 3-2</a></span>. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_34" title="Listing 2-2Creating a window from a nib file"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001140-CH203-CECHDFJG" title="Listing 2-2Creating a window from a nib file"></a><strong>Listing 2-2&nbsp;&nbsp;</strong>Creating a window from a nib file</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus err;<span></span></pre></td></tr><tr><td scope="row"><pre>IBNibRef theNib;<span></span></pre></td></tr><tr><td scope="row"><pre>WindowRef theWindow;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>err = CreateNibReference (CFSTR(“MyGuitar”), &amp;theNib);<span></span></pre></td></tr><tr><td scope="row"><pre>if (!err)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>    CreateWindowFromNib (theNib, CFSTR(“GuitarPrefs”), &amp;theWindow);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (theWindow != NULL) ShowWindow(theWindow);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeNibReference (theNib);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>The window is hidden when first created, so you need to call <code>ShowWindow</code> to make it visible. Any controls embedded in the window are automatically created and laid out at the same time. </p><p>After instantiation, you have a valid window or menu reference that your application can then use to perform other actions (obtain the menu ID, add menu items, and so on). In many cases, your existing code should just work once you’ve created your user interface elements from the nib file. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-CECIGBHG" title="Update Dialog Manager Functions"></a><h3>Update Dialog Manager Functions</h3><p>Most Dialog Manager functions were based on the old resource-based method of creating windows. To ensure compatibility with composited windows, you should replace your Dialog Manager calls with more modern equivalents. If you updated dialog resources to use nibs, you must change some Dialog Manager calls. Here are a few guidelines to keep in mind:</p><ul class="spaceabove"><li class="li"><p>Calls that manipulate dialogs are typically replaced by Window Manager equivalents. Nib files do not distinguish between windows and dialogs. </p></li><li class="li"><p>Calls that manipulate dialog items are replaced by their Control Manager or HIView equivalents. </p></li><li class="li"><p>Event management in dialogs is now handled through Carbon events. Any event filtering callbacks must be replaced by the appropriate Carbon event handlers. See <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABCCHEC">“Event Filtering”</a></span> for more infomation. </p></li><li class="li"><p>If you have simple alert dialogs, you may use <code>CreateStandardAlert</code> rather than implement it in a nib file. See <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-CECCAJBC">“Standard Alerts.”</a></span> You can also programmatically create simple sheets for documents windows, as described in <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABEIEEC">“Sheets.”</a></span> </p></li></ul><p>The only Dialog Manager functions still recommended are those that handle standard alerts and sheets. </p><p><span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-CECHBEFA">Table 3-1</a></span> lists a number of common Dialog Manager calls and their replacements.</p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_35" title="Table 2-1HIView-savvy Dialog Manager replacements"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001140-CH203-CECHBEFA" title="Table 2-1HIView-savvy Dialog Manager replacements"></a><strong>Table 2-1&nbsp;&nbsp;</strong>HIView-savvy Dialog Manager replacements</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Dialog Manager function</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>HIView replacement</p></th></tr><tr><td  scope="row"><p><code>AppendDITL</code> or <code>AppendDialogItemList</code></p></td><td ><p><code>HIViewAddSubview</code></p></td></tr><tr><td  scope="row"><p><code>CountDITL</code></p></td><td ><p>Control Manager: <code>CountSubControls</code> with the root control as parent. </p></td></tr><tr><td  scope="row"><p><code>FindDialogItem</code></p></td><td ><p><code>HIViewFindByID</code></p></td></tr><tr><td  scope="row"><p><code>GetDialogItem</code></p></td><td ><p><code>HIViewFindByID</code>. Note that when importing dialog resources into Interface Builder, dialog items are converted into controls with an ID number corresponding to the item index. For example, dialog item 1 turns into a control with control ID 1. However, the signature field is left blank, so you should set this to be your application’s signature. </p><p>If desired, you can also use the Control Manager function <code>GetIndexedSubControl</code></p></td></tr><tr><td  scope="row"><p><code>SetDialogItem</code></p></td><td ><p>Varies depending on what you want to do. </p><p>• If you want to set an application-defined drawing function , you should install a drawing handler on a user pane control. See <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABCCBIJ">“Put Custom Content Into Views.”</a></span></p><p>• If you want to set control bounds, use <code>HIViewSetFrame</code> on the view reference. </p><p>•If you want to actually change the control type, you should create one of each type you want to display and enable/disable/show/hide them appropriately. For example, if you used <code>SetDialogItem</code> to change an edit text control to a static one , you should create one of each control with the same bounds. To switch, you would disable and hide one while enabling and showing the other. </p></td></tr><tr><td  scope="row"><p><code>RemoveDialogItem</code> and <code>ShortenDITL</code></p></td><td ><p>Control Manager: <code>DisposeControl</code> or <code>HIViewRemoveFromSuperview</code>. One advantage of using <code>HIViewRemoveFromSuperview</code> is that you still retain the view, so you can embed it elsewhere later.</p></td></tr><tr><td  scope="row"><p><code>HideDialogItem</code> or <code>ShowDialogItem</code></p></td><td ><p><code>HIViewSetVisible</code></p></td></tr><tr><td  scope="row"><p><code>InsertDialogItem</code></p></td><td ><p><code>HIViewAddSubview</code></p></td></tr><tr><td  scope="row"><p><code>Alert</code>, <code>StandardAlert</code>, <code>StopAlert</code>, <code>NoteAlert</code>, <code>CautionAlert</code>, <code>GetAlertStage</code> and <code>ResetAlertStage</code></p></td><td ><p>Convert alerts to use <code>CreateStandardAlert</code> instead. See <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-CECCAJBC">“Standard Alerts.”</a></span></p></td></tr><tr><td  scope="row"><p><code>GetNewDialog</code></p></td><td ><p>Interface Builder Services: <code>CreateWindowFromNib</code> with appropriate nib file. </p></td></tr><tr><td  scope="row"><p><code>NewFeaturesDialog</code>, <code>NewDialog</code>, and <code>NewColorDialog</code></p></td><td ><p>Window Manager: <code>CreateNewWindow</code></p></td></tr><tr><td  scope="row"><p><code>CloseDialog</code></p></td><td ><p>Not supported in Carbon. Use <code>DisposeWindow</code>.</p></td></tr><tr><td  scope="row"><p><code>DisposeDialog</code></p></td><td ><p>Window Manager: <code>DisposeWindow</code></p></td></tr><tr><td  scope="row"><p><code>DrawDialog</code> and <code>UpdateDialog</code></p></td><td ><p>Draw from within <code>kEventControlDraw</code> handlers only. Do not draw from window drawing or window update handlers. </p></td></tr><tr><td  scope="row"><p><code>GetDialogItemAsControl</code></p></td><td ><p>Control Manager: <code>GetIndexedSubControl</code> or <code>HIViewFindByID</code>.</p></td></tr><tr><td  scope="row"><p><code>GetModalDialogEventMask</code> and <code>SetModalDialogEventMask</code></p></td><td ><p>No longer needed. Events are filtered by registering for specific Carbon events. </p></td></tr><tr><td  scope="row"><p><code>ModalDialog</code></p></td><td ><p>Carbon Event Manager: <code>RunAppModalLoopForWindow</code> on the window you want to be application modal. See <em><a href="../../Carbon_Event_Manager/index.html#//apple_ref/doc/uid/TP30000989" target="_top">Carbon Event Manager Programming Guide</a></em> for more details. </p></td></tr><tr><td  scope="row"><p><code>New/Invoke/DisposeUserItemUPP</code></p></td><td ><p>User items typically replaced by standard or custom views. </p></td></tr><tr><td  scope="row"><p><code>New/Invoke/DisposeModalFilterUPP</code> and <code>New/Invoke/DisposeModalFilterYUPP</code></p></td><td ><p>Event filters not needed in Mac OS X. Use Carbon events instead. See <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABCCHEC">“Event Filtering”</a></span> for more information. </p></td></tr><tr><td  scope="row"><p><code>DialogSelect</code> and <code>IsDialogEvent</code></p></td><td ><p>No longer needed. Events are filtered by registering for specific Carbon events. See <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABCCHEC">“Event Filtering”</a></span> for more information.</p></td></tr><tr><td  scope="row"><p><code>ParamText</code> and <code>GetParamText</code></p></td><td ><p>Control Manager: <code>GetControlData</code> with the <code>kControlStaticTextCFStringTag</code> tag. </p></td></tr><tr><td  scope="row"><p><code>GetDialogItemText</code> and <code>SetDialogItemText</code></p></td><td ><p>Control Manager: <code>GetControlData</code> or <code>SetControlData</code> with the <code>kControlEditTextCFStringTag</code> or <code>kControlStaticTextCFStringTag</code> tag. </p></td></tr><tr><td  scope="row"><p><code>SelectDialogItemText</code></p></td><td ><p>Control Manager: <code>SetControlData</code> with the <code>kControlEditTextSelectionTag</code> tag. </p></td></tr><tr><td  scope="row"><p><code>DialogCut</code>, <code>DialogCopy</code>, <code>DialogPaste</code>, and <code>DialogDelete</code></p></td><td ><p>No longer needed. The standard window event handler handles these actions for you. </p></td></tr><tr><td  scope="row"><p><code>SetDialogCancelItem</code>, <code>GetDialogCancelItem</code>, <code>SetDialogDefaultItem</code>, and <code>GetDialogDefaultItem</code></p></td><td ><p>Carbon Event Manager: <code>GetWindowDefaultButton</code>, <code>SetWindowDefaultButton</code>, <code>GetWindowCancelButton</code>, <code>SetWindowCancelButton</code>. You can also set Default and Cancel buttons in nib file. In most cases, you should set the command ID for the button to <code>kHICommandOK</code> (Default) or <code>kHICommandCancel</code> (Cancel) so that you can handle the command event. </p></td></tr><tr><td  scope="row"><p><code>GetDialogKeyboardFocusItem</code></p></td><td ><p>Control Manager: <code>GetKeyboardFocus</code> on the appropriate window.</p></td></tr><tr><td  scope="row"><p><code>SetDialogTracksCursor</code></p></td><td ><p>The preferred method is to use mouse-tracking regions (as described in <em><a href="../../Carbon_Event_Manager/index.html#//apple_ref/doc/uid/TP30000989" target="_top">Carbon Event Manager Programming Guide</a></em>) and change your cursor based on mouse-entered and mouse-exited events. However, you can also register for the <code>kEventMouseMoved</code> event and change the cursor according to its position. </p></td></tr><tr><td  scope="row"><p><code>MoveDialogItem</code></p></td><td ><p><code>HIViewMoveBy</code> or <code>HIViewPlaceInSuperviewAt</code>.</p></td></tr><tr><td  scope="row"><p><code>SizeDialogItem</code></p></td><td ><p><code>HIViewSetFrame</code>.</p></td></tr><tr><td  scope="row"><p><code>AutoSizeDialog</code></p></td><td ><p>Control Manager: Use <code>GetBestControlRect</code> on text fields that need to be autosized. </p></td></tr><tr><td  scope="row"><p><code>GetDialogTimeout</code> and <code>SetDialogTimeout</code></p></td><td ><p>Use Carbon event timers instead. See <em><a href="../../Carbon_Event_Manager/index.html#//apple_ref/doc/uid/TP30000989" target="_top">Carbon Event Manager Programming Guide</a></em> for more details. </p></td></tr><tr><td  scope="row"><p><code>GetDialogWindow</code></p></td><td ><p>Not needed in most cases, because the dialog is now a window. However, <code>CreateStandardSheet</code> creates a dialog reference,which you must convert to type <code>WindowRef</code> using this function when passing it to <code>ShowSheetWindow</code>.</p></td></tr><tr><td  scope="row"><p><code>GetDialogPort</code></p></td><td ><p>Window Manager: <code>GetWindowPort</code>. However, you should consider using Quartz rather than QuickDraw.</p></td></tr><tr><td  scope="row"><p><code>GetDialogTextEditHandle</code></p></td><td ><p>Control Manager: <code>GetControlData</code> with the <code>kControlEditTextTEHandle</code> on the focused edit text control. However, TextEdit is not recommended, so in most cases, you should upgrade to the Unicode edit text control.</p></td></tr><tr><td  scope="row"><p><code>CreateStandardSheet</code></p></td><td ><p>Still supported. See <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABEIEEC">“Sheets”</a></span> for more details.</p></td></tr><tr><td  scope="row"><p><code>CreateStandardAlert</code></p></td><td ><p>Still supported. See <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-CECCAJBC">“Standard Alerts”</a></span> for more details. </p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001140-CH203-BABCCHEC" title="Event Filtering"></a><h4>Event Filtering</h4><p>If you have event filters for your dialogs, you should remove them when you convert to nibs. In most cases, any action the user takes on a control (clicking it, entering text, sliding a thumb) invokes Carbon events. Thus, registering to receive particular events and then handling them in the application essentially substitutes for dialog event filtering.</p><p>When you want to filter keyboard input to, say, a Unicode edit text field, you should install a control key filter on the control. For example, say you had event filtering–code in your dialog to allow only numbers in an edit text field, as shown in <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABEGHDE">Listing 3-3</a></span>. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_36" title="Listing 2-3Filtering keyboard input from a dialog event filter"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001140-CH203-BABEGHDE" title="Listing 2-3Filtering keyboard input from a dialog event filter"></a><strong>Listing 2-3&nbsp;&nbsp;</strong>Filtering keyboard input from a dialog event filter</p><div class="codesample"><table><tr><td scope="row"><pre>Boolean MyOldDialogFilter(DialogRef theDialog,<span></span></pre></td></tr><tr><td scope="row"><pre>                        EventRecord *theEvent, DialogItemIndex *itemHit)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>    if ((theEvent->what == keyDown) || (theEvent->what == autoKey))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>        char c = (theEvent->message &amp; charCodeMask);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // return or enter key?<span></span></pre></td></tr><tr><td scope="row"><pre>        if ((c == kReturnCharCode) || (c == kEnterCharCode))<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>            *itemHit = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>            return true;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // tab key or arrow keys?<span></span></pre></td></tr><tr><td scope="row"><pre>        if (c == kTabCharCode) return false;<span></span></pre></td></tr><tr><td scope="row"><pre>        if (c == kLeftArrowCharCode) return false;<span></span></pre></td></tr><tr><td scope="row"><pre>        if (c == kRightArrowCharCode) return false;<span></span></pre></td></tr><tr><td scope="row"><pre>        if (c == kUpArrowCharCode) return false;<span></span></pre></td></tr><tr><td scope="row"><pre>        if (c == kDownArrowCharCode) return false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // digits only for edittext box item #9 ?<span></span></pre></td></tr><tr><td scope="row"><pre>        // pre-Carbon, this would have been:<span></span></pre></td></tr><tr><td scope="row"><pre>        // ((DialogPeek)theDialog)->editField+1 == 9<span></span></pre></td></tr><tr><td scope="row"><pre>        if (GetDialogKeyboardFocusItem(theDialog) == 9)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>            if ((c &lt; '0') || (c > '9'))<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                SysBeep(1);<span></span></pre></td></tr><tr><td scope="row"><pre>                return true;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>…<span></span></pre></td></tr><tr><td scope="row"><pre>    return false;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>In Mac OS X (actually, Mac OS 8 and later), you can install a control key filter on your control to do the same thing, as shown in <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABIGABD">Listing 3-4</a></span>. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_37" title="Listing 2-4A control key filter"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001140-CH203-BABIGABD" title="Listing 2-4A control key filter"></a><strong>Listing 2-4&nbsp;&nbsp;</strong>A control key filter</p><div class="codesample"><table><tr><td scope="row"><pre>ControlKeyFilterResult MyEditKeyFilter(ControlRef theControl,<span></span></pre></td></tr><tr><td scope="row"><pre>            SInt16 *keyCode, SInt16 *charCode, EventModifiers *modifiers)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>    // the edit text control can filter keys on its own<span></span></pre></td></tr><tr><td scope="row"><pre>    if ((*charCode &lt; '0') || (*charCode > '9'))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>        SysBeep(1);<span></span></pre></td></tr><tr><td scope="row"><pre>        return kControlKeyFilterBlockKey;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    return kControlKeyFilterPassKey;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>You install the key filter using the <code>SetControlData</code> function, as shown in <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABHDJAC">Listing 3-5</a></span>. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_38" title="Listing 2-5Installing the control key filter"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001140-CH203-BABHDJAC" title="Listing 2-5Installing the control key filter"></a><strong>Listing 2-5&nbsp;&nbsp;</strong>Installing the control key filter</p><div class="codesample"><table><tr><td scope="row"><pre>HIViewID hidnst = {0, 9};<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>HIViewRef numEditText;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIViewFindByID(HIViewGetRoot(window), hidnst, &amp;numEditText);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ControlKeyFilterUPP keyFilter =<span></span></pre></td></tr><tr><td scope="row"><pre>                     NewControlKeyFilterUPP(MyEditKeyFilter);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>SetControlData(numEditText, kControlEntireControl,<span></span></pre></td></tr><tr><td scope="row"><pre>         kControlEditTextKeyFilterTag, sizeof(keyFilter), &amp;keyFilter);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>DisposeControlKeyFilterUPP(keyFilter);<span></span></pre></td></tr></table></div><p>Here is how the code works:</p><ol class="ol"><li class="li"><p>This example assumes that the edit text control is stored in the nib and has been assigned an HIView ID (essentially the same as a control ID).</p></li><li class="li"><p>To obtain a reference to the HIView in the window that contains it, you use the <code>HIViewFindByID</code> function, passing in the parent view in which you want to search (in this case, the root view). </p></li><li class="li"><p>The key filter is a callback function, so you should pass a universal procedure pointer (UPP) rather than a simple procedure pointer. </p></li><li class="li"><p>You specify the key filter for your control by calling <code>SetControlData</code> with the <code>kControlEditTextKeyFilterTag</code> tag and passing the universal procedure pointer (UPP) of your filter function as the data. </p></li></ol><a name="//apple_ref/doc/uid/TP30001140-CH203-CECCAJBC" title="Standard Alerts"></a><h4>Standard Alerts</h4><p>If you have simple alerts in your application, instead of converting them to nibs you can choose to use the Dialog Manager function <code>CreateStandardAlert</code> to create them on the fly. These dialogs assume only minimal user interaction (that is, Cancel and Ok). <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BCICFAFB">Listing 3-6</a></span> shows how to create a simple alert. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_39" title="Listing 2-6Creating a simple alert"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001140-CH203-BCICFAFB" title="Listing 2-6Creating a simple alert"></a><strong>Listing 2-6&nbsp;&nbsp;</strong>Creating a simple alert</p><div class="codesample"><table><tr><td scope="row"><pre>DialogRef theAlert;<span></span></pre></td></tr><tr><td scope="row"><pre>DialogItemIndex itemIndex;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CreateStandardAlert(kAlertPlainAlert, <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>                CFSTR("Be vewy vewy quiet."), <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                CFSTR("I’m hunting wabbits."),<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL, &amp;theAlert);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>RunStandardAlert (theAlert, NULL, &amp;itemIndex); <span>// 4</span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p> When calling <code>CreateStandardAlert</code>, passing <code>kAlertPlainAlert</code> specifies that you want the application icon to be used. Other possible constants you can pass are <code>kAlertNoteAlert</code>, <code>kAlertCautionAlert</code>, and <code>kAlertStopAlert</code>. Note that in most cases you should simply use the plain alert. See <em><a href="../../../../UserExperience/Conceptual/AppleHIGuidelines/index.html#//apple_ref/doc/uid/20000957" target="_top">Apple Human Interface Guidelines</a></em> for more information. Your application icon is automatically added to an alert icon in accordance with the Apple guidelines.</p></li><li class="li"><p>The Core Foundation strings (created using <code>CFSTR</code>) specify the alert message you want displayed. The second string contains the smaller, informative text. </p></li><li class="li"><p>If you have a custom parameter block describing how to create the alert, you would pass it here. Otherwise pass <code>NULL</code>. On return, <code>theAlert</code> contains a reference to the new alert. </p></li><li class="li"><p><code>RunStandardAlert</code> displays the alert and puts the window in an application-modal state. When the user exits the alert (by clicking OK or Cancel), <code>itemIndex</code> contains the index of the control the user clicked. </p></li></ol><a name="//apple_ref/doc/uid/TP30001140-CH203-BABEIEEC" title="Sheets"></a><h4>Sheets</h4><p>Sometimes you may want to make your alerts document-modal, in which case you should implement them as sheets. </p><p>If you want to create a simple alert that appears as a sheet, you can call the function <code>CreateStandardSheet</code>. This function is analogous in format to the <code>CreateStandardAlert</code> function. However, it includes an additional parameter to specify an event target. When the user dismisses the sheet alert (by clicking OK or Cancel), the system sends a command event (class <code>kEventClassCommand</code>, type <code>kEventCommandProcess</code>) to the specified event target. You can use this event to determine which control the user clicked. </p><p>In most cases, the event target you specify in <code>CreateStandardSheet</code> should be the sheet’s parent window. For example, you might want to do the following when you want to display a sheet:</p><ol class="ol"><li class="li"><p>Install an event handler on the parent window for the <code>kEventCommandProcess</code> event.</p></li><li class="li"><p>Call <code>CreateStandardSheet</code> and <code>ShowSheetWindow</code> to create and display the sheet. Note that <code>CreateStandardSheet</code> creates a dialog reference, and <code>ShowSheetWindow</code> requires a window reference. To convert the reference appropriately, you need to use the <code>GetDialogWindow</code> function as follows: </p><div class="codesample"><table><tr><td scope="row"><pre>DialogRef theSheet;<span></span></pre></td></tr><tr><td scope="row"><pre>CreateStandardSheet (…, &amp;theSheet);<span></span></pre></td></tr><tr><td scope="row"><pre>ShowSheetWindow (GetDialogWindow (theSheet));<span></span></pre></td></tr></table></div></li><li class="li"><p>When your parent window receives the <code>kEventCommandProcess</code> event, process it accordingly, based on the command ID.</p></li><li class="li"><p>Remove the event handler from the parent window. </p></li></ol><p>By installing the <code>kEventCommandProcess</code> event handler only when the sheet is visible, you ensure that the handler receives events only from the sheet, not from any other controls. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-BABFAHDB" title="Adopt Carbon Events"></a><h2>Adopt Carbon Events</h2><p>In order to adopt HIViews, your windows must use Carbon events for event processing. You can think of Carbon events as the methods that complement the HIView data store objects. You register for only the Carbon events that you are interested in and implement the event handlers as callback functions.</p><p>Because Mac OS X supports both Carbon events and the <code>WaitNextEvent</code> event model, you can choose to adopt Carbon events at first only for those windows that will use HIViews. If you are converting Dialog Manager dialog windows, most of the event filtering done in event filters and modal dialogs are replaced by Carbon events. </p><p>If you do not plan to implement Carbon events or views immediately throughout your application, you should still consider targeted adoption to improve performance. For example, using Carbon events to eliminate old system-polling code (such as calls to <code>StillDown</code>) can significantly improve your application’s responsiveness. </p><p>For more details about the Carbon Event Manager, read <em><a href="../../Carbon_Event_Manager/index.html#//apple_ref/doc/uid/TP30000989" target="_top">Carbon Event Manager Programming Guide</a></em>. For an example of how to move from the <code>WaitNextEvent</code> event model to Carbon events, see <em><a href="../../carbon_porting_guide/index.html#//apple_ref/doc/uid/TP30000991" target="_top">Carbon Porting Guide</a></em>. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_11" title="Standard Handlers"></a><h3>Standard Handlers</h3><p>The major benefit for Carbon events is the use of standard handlers. That is, the Carbon Event Manager has implemented handlers for common events. For windows and controls, these handlers are installed when you install the standard window handler. For example, the standard window handler includes a routine to drag windows. As a result, your windows can be dragged without your having to write any code. Of course, if you wanted some special dragging behavior for your window, you can override the standard handler with one of your own. </p><p>Standard handlers for windows and controls are installed when you set the <code>kWindowStandardHandlerAttribute</code> attribute for the window. You can set this from the Info window in Interface Builder or programmatically when you call the Window Manager function <code>CreateNewWindow</code>. Note that because this attribute is set on a window-by-window basis, you can choose to use the standard handler in some windows but not others.</p><p>Menus and the application itself have the equivalent of standard handlers; these handlers are installed when you call the Carbon Event Manager function <code>RunApplicationEventLoop</code>.</p><p>Because the standard handlers do so much, you should check your event handling code against the standard hander behavior for those particular events; you may discover that you no longer need to implement certain actions. See information on specific events in <em><a href="../../../Reference/Carbon_Event_Manager_Ref/index.html#//apple_ref/doc/uid/TP30000135" target="_top">Carbon Event Manager Reference</a></em> to determine their standard handler behavior. </p><p>A good rule of thumb for determining standard handler behavior is to test your user interface elements without installing any additional event handlers. Launching the Carbon Simulator application, available from the Test Interface menu item in the Interface Builder File menu, is a simple way to do this. Whatever behavior is present (tracking, keyboard focus, dragging, and so on) is provided by standard event handlers. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_12" title="Command Events"></a><h3>Command Events</h3><p>To handle the behavior of most simple single-action controls, you should use command events. Doing so requires you to assign a unique command ID to each control, typically from the Interface Builder Info window. When the user activates your control, the Carbon Event Manager sends a <code>kEventCommandProcess</code> event containing the control’s command ID to your application. One major advantage of the command event is that you can assign the same command ID to both a menu and a control; you can then handle both cases with a single event handler. </p><p>The Carbon Event Manager defines command IDs for many common commands, such as OK, Cancel, Cut, and Paste. You can also define your own for application-specific commands. Your event handler for the <code>kEventCommandProcess</code> event can then determine which command ID was sent and take appropriate action. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_40" title="Important:"></a><p><strong>Important:</strong>&nbsp;Command IDs containing all lower case letters are defined by Apple; if you create nonstandard command IDs, they must contain at least one upper case letter. </p><p></p></div><p>You assign the command ID to a menu item in the Attributes pane of the Interface Builder Info window. You can also call the Menu Manager function <code>SetMenuItemCommandID</code>. </p><p>The <code>kEventCommandProcess</code> event indicates that your menu item was selected. The actual command ID is stored within an <code>HICommandExtended</code> structure in the event reference. You must call the Carbon Event Manager function <code>GetEventParameter</code> to retrieve it, as shown in <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BCIECIFI">Listing 3-7</a></span>. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_41" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>HICommandExtended</code> structure supersedes the <code>HICommand</code> structure. The extended version adds fields for a control or window reference, while the original <code>HICommand</code> structure had space only for menu information. </p></div><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_42" title="Listing 2-7Obtaining the command ID from the event reference"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001140-CH203-BCIECIFI" title="Listing 2-7Obtaining the command ID from the event reference"></a><strong>Listing 2-7&nbsp;&nbsp;</strong>Obtaining the command ID from the event reference</p><div class="codesample"><table><tr><td scope="row"><pre>HICommandExtended commandStruct;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 the CommandID;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>GetEventParameter (event, kEventParamDirectObject, <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>                    typeHICommand, NULL, sizeof(commandStruct),<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL, &amp;commandStruct);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>theCommandID = commandStruct.commandID;<span>// 2</span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>When calling <code>GetEventParameter</code>, you must specify which parameter you want to obtain. For command events, the direct object (<code>kEventParamDirectObject</code>) is the <code>HICommandExtended</code> structure, which describes the command that occurred. </p></li><li class="li"><p>The command ID of the control (or menu) that generated the event is stored in the <code>commandID</code> field of the <code>HICommandExtended</code> structure. </p></li></ol><p>To respond to events from menus, you should install your command event handler at the window or application level. Doing so also allows you to use the same handler to catch command events coming from controls, if so desired. Also, attaching your handler at the window level makes sense if you have menu items that apply to one type of document window but not to another, because command events are dispatched only to the active window, not to any other window. </p><p>After handling a command, your application may need to change the state of a menu item. For example, after saving a document, the Save menu item should be disabled until the document changes. Whenever the status of a command item might be in question, the system makes a note of it. When the user takes an action that may require updating the status (such as pulling down a menu), your application receives a <code>kEventCommandUpdateStatus</code> event. To make sure that the states of your menus are properly synchronized, you should install a handler for the <code>kEventCommandUpdateStatus</code> event. This handler should check the attributes bit of the command event to determine which items may need updating. Some examples of possible updates include:</p><ul class="spaceabove"><li class="li"><p>Enabling or disabling menu items</p></li><li class="li"><p>Changing the text of a menu item (for example, from Show <em>xxxx</em> to Hide <em>xxxx</em>).</p></li></ul><p>If the <code>kHICommandFromMenu</code> bit in the <code>attributes</code> field of the <code>HICommandExtended</code> structure (shown in <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABHCIIH">Listing 3-8</a></span>) is set, then you should check the menu item in question to see if you need to update it. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_43" title="Listing 2-8The extended HICommand structure"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001140-CH203-BABHCIIH" title="Listing 2-8The extended HICommand structure"></a><strong>Listing 2-8&nbsp;&nbsp;</strong>The extended HICommand structure</p><div class="codesample"><table><tr><td scope="row"><pre>struct HICommandExtended {<span></span></pre></td></tr><tr><td scope="row"><pre>   UInt32 attributes<span></span></pre></td></tr><tr><td scope="row"><pre>   UInt32 commandID<span></span></pre></td></tr><tr><td scope="row"><pre>   union     {<span></span></pre></td></tr><tr><td scope="row"><pre>        controlRef;<span></span></pre></td></tr><tr><td scope="row"><pre>        windowRef;<span></span></pre></td></tr><tr><td scope="row"><pre>        struct         {<span></span></pre></td></tr><tr><td scope="row"><pre>            MenuRef menuRef;<span></span></pre></td></tr><tr><td scope="row"><pre>            MenuItemIndex menuItemIndex;<span></span></pre></td></tr><tr><td scope="row"><pre>        } menu;<span></span></pre></td></tr><tr><td scope="row"><pre>    } source;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct HICommandExtended HICommandExtended;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001140-CH203-BABCCBIJ" title="Put Custom Content Into Views"></a><h2>Put Custom Content Into Views</h2><p>The transition to views and composited windows is simpler if you use only the standard Apple-supplied user interface elements. However, in many cases you may have custom content that has no standard equivalent. </p><p>One constraint of the compositing drawing model is that all your drawing must occur in a view. In the past, if you wanted to modify a window, you could simply draw to the screen as necessary. The drawback was that drawing was not predictable and could result in unnecessary redraws. For example, you may have used a standard dialog and then added additional images by drawing directly onscreen. This method no longer works in compositing mode, because you can no longer dictate when you can draw to the screen. </p><p>If you have custom content, you must draw it in a manner that supports compositing mode. This means that you can no longer draw:</p><ul class="ul"><li class="li"><p>By calling <code>DrawControl</code>, <code>Draw1Control</code>, or <code>UpdateControls</code></p></li><li class="li"><p>During a classic update event or <code>kEventWindowUpdate</code> event.</p></li><li class="li"><p>During a <code>kEventWindowDrawContent</code> event</p></li></ul><p>Typically this means you must create a view that handles the <code>kEventControlDraw</code> event to draw its content. In addition, you should be aware of the following restrictions:</p><ul class="ul"><li class="li"><p>Don’t erase behind your view when before drawing. </p></li><li class="li"><p>Make sure you draw using view-local coordinates (rather than, say global coordinates, or content region–local coordinates).</p></li><li class="li"><p>If you draw with Quartz, you must draw into the Core Graphics context supplied to you in the draw event. </p></li></ul><p>If you want to update your view content, you must first mark the areas to be redrawn. You do so by calling the <code>HIViewSetNeedsDisplay</code> or <code>HIViewSetNeedsDisplayInRegion</code> function, and then draw only when the view receives the <code>kEventControlDraw</code> event. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_44" title="Note"></a><p><strong>Note:</strong>&nbsp;While Apple recommends implementing custom controls as HIView subclasses (using <code>HIObjectRegisterSubclass</code>), it is possible for older CDEFs to work in compositing mode if they adhere to the above restrictions. For example, if you want to draw using Quartz, a custom control can install a <code>kEventControlDraw</code> handler on its control reference and use that single event to draw, while otherwise supporting the classic CDEF interface. </p></div><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_13" title="Custom Drawing in User Panes"></a><h3>Custom Drawing in User Panes</h3><p>If you have only simple drawing needs, you can attach a <code>kEventControlDraw</code> handler to a user pane control. Conveniently, Interface Builder converts dialog user items to user panes when importing from resources. </p><p><span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABBCDJD">Listing 3-9</a></span> shows how you would install a simple, one-event drawing handler onto a user pane.</p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_45" title="Listing 2-9Installing a draw ing handler onto a user pane"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001140-CH203-BABBCDJD" title="Listing 2-9Installing a draw ing handler onto a user pane"></a><strong>Listing 2-9&nbsp;&nbsp;</strong>Installing a draw ing handler onto a user pane</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef window;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIViewRef       userPane;<span></span></pre></td></tr><tr><td scope="row"><pre>static const HIViewID userPaneID = { 'Moof', 127 };<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static const EventTypeSpec myEventTypes =<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                        { kEventClassControl, kEventControlDraw };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIViewFindByID (HIViewGetRoot(window), userPaneID, &amp;userPane);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>InstallControlEventHandler (userPane, myUserDraw, 1, &amp;myEventTypes,<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>                            userPane, NULL);<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>Identifies a view generated from a nib by specifying its HIView ID, which is identical to a control ID. This must match the application signature and the view/control ID value you set for the user pane in the Info window, as shown in <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABHIJID">Figure 3-4</a></span>. </p></li><li class="li"><p>Specify the events you want to register for by inserting them in an array of type <code>EventTypeSpec</code>. Each event is defined by its class and kind. In this case, you are only registering for the one control class event, <code>kEventControlDraw</code>.</p></li><li class="li"><p>Obtains the user pane’s HIView reference. This example specifies the root view (obtained using the <code>HIViewGetRoot</code> function) as the parent within which you want to look for the user pane. </p></li><li class="li"><p>Calls the Carbon Event Manager macro <code>InstallControEventHandler</code> (a macro variant of <code>InstallEventHandler</code>) to register <code>myUserDraw</code> as the handler for your user pane drawing event. This example also passes a reference to the user pane in the application-defined user data parameter. Doing so eliminates the need to call <code>GetEventParameter</code> in the event handler to obtain the user pane reference. </p></li></ol><br/><div><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_46" title="Figure 2-4Specifying the user pane signature and HIView ID in the Info window"></a><p><a name="//apple_ref/doc/uid/TP30001140-CH203-BABHIJID" title="Figure 2-4Specifying the user pane signature and HIView ID in the Info window"></a><strong>Figure 2-4&nbsp;&nbsp;</strong>Specifying the user pane signature and HIView ID in the Info window</p><img src = "../art/userpane_id.gif" alt = "Specifying the user pane signature and HIView ID in the Info window" width="401" height="329"></div><br/><p><span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABBCDJD">Listing 3-9</a></span> shows a possible implementation for the <code>myUserDraw</code> function. This example draws a 10-unit wide border inside the user pane’s bounds. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_47" title="Listing 2-10A simple drawing handler for the user pane"></a><p class="codesample"><strong>Listing 2-10&nbsp;&nbsp;</strong>A simple drawing handler for the user pane</p><div class="codesample"><table><tr><td scope="row"><pre>pascal OSStatus myUserDraw (EventHandlerCallRef nextHandler,<span></span></pre></td></tr><tr><td scope="row"><pre>                                EventRef theEvent, void * userData)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus err;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRef theCGContext;<span></span></pre></td></tr><tr><td scope="row"><pre>    HIRect paneBounds, myHIRect;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    HIViewRef thePane = (HIViewRef)userData;<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = GetEventParameter( theEvent, kEventParamCGContextRef,<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                         typeCGContextRef, NULL, sizeof( CGContextRef ),<span></span></pre></td></tr><tr><td scope="row"><pre>                         NULL, &amp;theCGContext );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    HIViewGetBounds (thePane, &amp;paneBounds);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    myHIRect = CGRectInset (paneBounds, 5.0, 5.0);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextStrokeRectWithWidth (theCGContext, myHIRect,10.0); <span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>Casts the incoming user data (which is a reference to the user pane) to be type <code>HIViewRef</code>. </p></li><li class="li"><p>Calls the Carbon Event Manager function <code>GetEventParameter</code> to obtain the Core Graphics drawing context for the user pane. You need to specify this context whenever you make any Quartz drawing calls. </p></li><li class="li"><p>Obtain the bounds of the user pane by calling <code>HIViewGetBounds</code>. Note that these bounds are of type <code>HIRect</code>, which is structured differently from the old QuickDraw <code>Rect</code> type. </p></li><li class="li"><p>Lines drawn in Quartz are centered on the line you specify; that is, a line of width 10.0 units extends 5.0 units to either side of the specified drawing line. To keep the line from extending beyond the bounds of the user pane, the code shrinks the drawing rectangle by 5.0 units on each side. The drawing context is clipped to the bounds of the view when you receive it, so anything drawn outside the bounds will not appear. While you could adjust each of the <code>HIRect</code> fields individually, the simplest way is to use the <code>CGRectInset</code> function. </p></li><li class="li"><p><code>CGContextStrokeRectWithWidth</code> draws a rectangle with a line of the specified width (10.0 units in this example). </p></li></ol><p>If you have nonstandard controls or other widgets in your window, you need to implement them as custom HIViews. You can implement a custom view as a subclass of a standard control or as a subclass of the base HIView class. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_48" title="Note"></a><p><strong>Note:</strong>&nbsp;If you are using C++, you may want to look at the HIFramework sample code installed in Developer/Examples/Carbon/HIFramework provides simple wrapper classes for many HIView APIs as well as an HIView subclass to use as your base class when using C++.</p></div><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_14" title="Subclassing Standard Controls"></a><h3>Subclassing Standard Controls</h3><p>Because of the object-oriented nature of views, subclassing existing views often reduces the amount of code you need to write. For example, if you have a custom round pushbutton, you can subclass the standard pushbutton view and override only the drawing, hit-testing, and region calculation event handlers. Other functionality, such as mouse tracking, is inherited from the pushbutton view.</p><p>However, if you subclass an existing control, there is currently no simple way to set or change its attributes from the nib file. For example, say you create a custom text holder <code>kHIViewMyWhizzyTextClassID</code> that is a subclass of the standard static text control (<code>kHIStaticTextViewClassID</code>). If you specify <code>kHIViewMyWhizzyTextClassID</code> directly in the HIView custom element in Interface Builder, you cannot easily set the base class attributes such as the text size or font. You would have to call <code>SetControlFontStyle</code> programmatically within your application.</p><p>The alternative is to attach the event handlers that make up your subclass to the instance of the standard control. </p><p>For example, for the static text case, you would create a standard text control in the nib file, which lets you set the text, font, size, and so on. After calling <code>GetWindowFromNib</code>, you need to obtain the HIView reference for the standard text control, (for example, by using <code>HIViewFindByID</code>) then call <code>InstallControlEventHandler</code> to install your custom event handlers onto it. These handlers override any existing handlers (that is, your <code>kEventControlDraw</code> handler overrides the standard one defined for the control). The net result is a control that behaves as your subclass. </p><p>If you choose to create a true subclass of an HIView element, you must write construct and destruct handlers for your view in addition to your usual event handlers. You register your subclass using <code>HIObjectRegisterSubclass</code>. For more information about creating view subclasses, see <span class="content_text"><a href="../upgrading_hitoolbox_samp/upgrading_hitoolbox_samp.html#//apple_ref/doc/uid/TP30001140-CH204-BABHCIAC">“A Porting Example: Converting a User Item to a Custom View”</a></span> and <span class="content_text"><!--a target="_top" -->“Creating Custom Views”<!--/a--></span> in <span class="content_text"><a href="../../HIViewDoc/index.html#//apple_ref/doc/uid/TP30000923" target="_top">Introducing HIView</a></span>.</p><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_15" title="Custom Views in Nib Files"></a><h3>Custom Views in Nib Files</h3><p>You’ll find when you use nib files in your application that some of the procedures for creating custom views are slightly different than if you were creating them programmatically. For example, you would not use <code>HIObjectCreate</code> to instantiate your view, because that is done for you when you call <code>CreateWindowFromNib</code>.</p><p>You should use the HIView element in Interface Builder as the placeholder for your custom view rather than the custom control element. One major reason for this is that the HIView element allows you to specify any number of parameters comparable to the ones you would specify in your <code>kEventHIObjectInitialize</code> event. These parameters could correspond to initial state, color, title text, and so on. Note that you should set the view’s bounds from the Size tab of the Info window, not as an input parameter. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_49" title="Important:"></a><p><strong>Important:</strong>&nbsp;If you use the nib file to hold your custom HIView, you must specify any initialization parameters in the nib using the Info window. Due to the nature of creating an HIView from a nib, your application never gets the opportunity to create an initialization event for the view before the view is instantiated. </p><p></p></div><p>You specify your input or initialization parameters in the Interface Builder Info window under Attributes, as shown in <span class="content_text"><a href="upgrading_hitoolbox_tasks.html#//apple_ref/doc/uid/TP30001140-CH203-BABEEGBF">Figure 3-5</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001140-CH203-DontLinkElementID_50" title="Figure 2-5Specifying input parameters in the Info window"></a><p><a name="//apple_ref/doc/uid/TP30001140-CH203-BABEEGBF" title="Figure 2-5Specifying input parameters in the Info window"></a><strong>Figure 2-5&nbsp;&nbsp;</strong>Specifying input parameters in the Info window</p><img src = "../art/view_input_params.gif" alt = "Specifying input parameters in the Info window" width="204" height="315"></div><br/><p>The ClassID is the actual string representing your custom view class. To ensure uniqueness, you should specify this ID in the form <em>CompanyName.Application.ClassName</em></p><p>You add parameters by hitting the Add button and then specifying the parameter name, type, and value. The parameter name should be a unique four-character string. Where possible, you should use standard Apple-defined control tags, such as the control collection tag constants, to set common values such as control value, bounds, and so on. You cannot set more complex data, such as pointers to structures, window references, and so on, from the Info window. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-BABJEAGH" title="Turn On Compositing"></a><h2>Turn On Compositing</h2><p>An application window does not use the composited drawing model (and therefore can’t gain the full benefits of HIViews) unless you specify the <code>kWindowCompositingAttribute</code> attribute. You can set this from the Info window in Interface Builder, or programmatically when you create the window using <code>CreateNewWindow</code>. Note that you cannot change this attribute after instantiating the window. </p><p>Composited windows keep track of the layering hierarchy of their views, drawing only when necessary and drawing only the visible portions of each view. </p><a name="//apple_ref/doc/uid/TP30001140-CH203-BABDCIHG" title="Additional Steps"></a><h2>Additional Steps</h2><p>Here are some additional things to keep in mind during the porting process: </p><ul class="ul"><li class="li"><p>Any code that moves or positions items within a window may need to be updated to reflect the new view-relative coordinate system (that is, the local or frame coordinates). </p></li><li class="li"><p>When importing dialogs into Interface Builder, items in a dialog list are automatically assigned an HIView ID (control ID) equivalent to its item index. That is, the first item in a dialog is given an HIView ID of {0,1}, the second {0.2}, and so on. This assignment may make it easier to update code for specific dialog items. After importing, you should set the signature field for each item to be your application’s signature. </p></li><li class="li"><p>You may want to consider using some of the <code>HILayout</code> functions to automatically position views with respect to the parent window or each other. </p></li><li class="li"><p>If you need to add custom data to a view, you can use the Info window in Interface Builder to add properties or the <code>GetControlProperty</code> and <code>SetControlProperty</code> functions .</p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../upgrading_hitoolbox_conc/upgrading_hitoolbox_conc.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../upgrading_hitoolbox_samp/upgrading_hitoolbox_samp.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2004-06-28<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/Upgrading_HIToolbox/upgrading_hitoolbox_tasks/upgrading_hitoolbox_tasks.html%3Fid%3DTP30001140-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/Upgrading_HIToolbox/upgrading_hitoolbox_tasks/upgrading_hitoolbox_tasks.html%3Fid%3DTP30001140-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/Upgrading_HIToolbox/upgrading_hitoolbox_tasks/upgrading_hitoolbox_tasks.html%3Fid%3DTP30001140-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>