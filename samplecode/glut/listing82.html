<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLUT - /GLUTWindow.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLUT</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLUT</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/GLUTWindow.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/gle/copy.h</option>
<option value="listing2.html">/gle/ex_angle.c</option>
<option value="listing3.html">/gle/ex_cut_round.c</option>
<option value="listing4.html">/gle/ex_raw.c</option>
<option value="listing5.html">/gle/extrude.c</option>
<option value="listing6.html">/gle/extrude.h</option>
<option value="listing7.html">/gle/gle_osx.h</option>
<option value="listing8.html">/gle/gutil.h</option>
<option value="listing9.html">/gle/intersect.c</option>
<option value="listing10.html">/gle/intersect.h</option>
<option value="listing11.html">/gle/port.h</option>
<option value="listing12.html">/gle/rot.h</option>
<option value="listing13.html">/gle/rot_prince.c</option>
<option value="listing14.html">/gle/rotate.c</option>
<option value="listing15.html">/gle/round_cap.c</option>
<option value="listing16.html">/gle/segment.c</option>
<option value="listing17.html">/gle/segment.h</option>
<option value="listing18.html">/gle/texgen.c</option>
<option value="listing19.html">/gle/tube.h</option>
<option value="listing20.html">/gle/tube_gc.h</option>
<option value="listing21.html">/gle/urotate.c</option>
<option value="listing22.html">/gle/view.c</option>
<option value="listing23.html">/gle/vvector.h</option>
<option value="listing24.html">/glsmap/glsmap.h</option>
<option value="listing25.html">/glsmap/glsmapint.h</option>
<option value="listing26.html">/glsmap/smap_buildsmap.c</option>
<option value="listing27.html">/glsmap/smap_context.c</option>
<option value="listing28.html">/glsmap/smap_create.c</option>
<option value="listing29.html">/glsmap/smap_destroy.c</option>
<option value="listing30.html">/glsmap/smap_drawmesh.c</option>
<option value="listing31.html">/glsmap/smap_flag.c</option>
<option value="listing32.html">/glsmap/smap_get.c</option>
<option value="listing33.html">/glsmap/smap_getfunc.c</option>
<option value="listing34.html">/glsmap/smap_gettexdim.c</option>
<option value="listing35.html">/glsmap/smap_gettexobj.c</option>
<option value="listing36.html">/glsmap/smap_getvec.c</option>
<option value="listing37.html">/glsmap/smap_makemesh.c</option>
<option value="listing38.html">/glsmap/smap_nearfar.c</option>
<option value="listing39.html">/glsmap/smap_origin.c</option>
<option value="listing40.html">/glsmap/smap_render.c</option>
<option value="listing41.html">/glsmap/smap_rvec2st.c</option>
<option value="listing42.html">/glsmap/smap_set.c</option>
<option value="listing43.html">/glsmap/smap_setfunc.c</option>
<option value="listing44.html">/glsmap/smap_setvec.c</option>
<option value="listing45.html">/glsmap/smap_texdim.c</option>
<option value="listing46.html">/glsmap/smap_texobj.c</option>
<option value="listing47.html">/glut.h</option>
<option value="listing48.html">/glut_8x13.c</option>
<option value="listing49.html">/glut_9x15.c</option>
<option value="listing50.html">/glut_bitmap.c</option>
<option value="listing51.html">/glut_bwidth.c</option>
<option value="listing52.html">/glut_cindex.c</option>
<option value="listing53.html">/glut_ext.c</option>
<option value="listing54.html">/glut_hel10.c</option>
<option value="listing55.html">/glut_hel12.c</option>
<option value="listing56.html">/glut_hel18.c</option>
<option value="listing57.html">/glut_mroman.c</option>
<option value="listing58.html">/glut_roman.c</option>
<option value="listing59.html">/glut_shapes.c</option>
<option value="listing60.html">/glut_stroke.c</option>
<option value="listing61.html">/glut_swidth.c</option>
<option value="listing62.html">/glut_teapot.c</option>
<option value="listing63.html">/glut_tr10.c</option>
<option value="listing64.html">/glut_tr24.c</option>
<option value="listing65.html">/glut_vidresize.c</option>
<option value="listing66.html">/GLUTApplication.h</option>
<option value="listing67.html">/GLUTApplication.m</option>
<option value="listing68.html">/glutbitmap.h</option>
<option value="listing69.html">/GLUTClipboardController.h</option>
<option value="listing70.html">/GLUTClipboardController.m</option>
<option value="listing71.html">/glutf90.h</option>
<option value="listing72.html">/GLUTMenu.h</option>
<option value="listing73.html">/GLUTMenu.m</option>
<option value="listing74.html">/GLUTMenuItem.h</option>
<option value="listing75.html">/GLUTMenuItem.m</option>
<option value="listing76.html">/GLUTPreferencesController.h</option>
<option value="listing77.html">/GLUTPreferencesController.m</option>
<option value="listing78.html">/glutstroke.h</option>
<option value="listing79.html">/GLUTView.h</option>
<option value="listing80.html">/GLUTView.m</option>
<option value="listing81.html">/GLUTWindow.h</option>
<option value="listing82.html">/GLUTWindow.m</option>
<option value="listing83.html">/HID_Config_Utilities.c</option>
<option value="listing84.html">/HID_Config_Utilities.h</option>
<option value="listing85.html">/HID_Error_Handler.c</option>
<option value="listing86.html">/HID_Error_Handler.h</option>
<option value="listing87.html">/HID_Name_Lookup.c</option>
<option value="listing88.html">/HID_Name_Lookup.h</option>
<option value="listing89.html">/HID_Queue_Utilities.c</option>
<option value="listing90.html">/HID_Queue_Utilities.h</option>
<option value="listing91.html">/HID_Utilities.c</option>
<option value="listing92.html">/HID_Utilities.h</option>
<option value="listing93.html">/HID_Utilities_External.h</option>
<option value="listing94.html">/HID_Utilities_Internal.h</option>
<option value="listing95.html">/libForeground.a</option>
<option value="listing96.html">/macx_cursor.m</option>
<option value="listing97.html">/macx_dials.m</option>
<option value="listing98.html">/macx_dstr.m</option>
<option value="listing99.html">/macx_event.m</option>
<option value="listing100.html">/macx_fortran.m</option>
<option value="listing101.html">/macx_gamemode.m</option>
<option value="listing102.html">/macx_get.m</option>
<option value="listing103.html">/macx_glut.h</option>
<option value="listing104.html">/macx_init.m</option>
<option value="listing105.html">/macx_input.m</option>
<option value="listing106.html">/macx_joy.m</option>
<option value="listing107.html">/macx_key.m</option>
<option value="listing108.html">/macx_menu.m</option>
<option value="listing109.html">/macx_modifier.m</option>
<option value="listing110.html">/macx_overlay.m</option>
<option value="listing111.html">/macx_space.m</option>
<option value="listing112.html">/macx_swap.m</option>
<option value="listing113.html">/macx_tablet.m</option>
<option value="listing114.html">/macx_util.m</option>
<option value="listing115.html">/macx_utilities.h</option>
<option value="listing116.html">/macx_warp.m</option>
<option value="listing117.html">/macx_win.m</option>
<option value="listing118.html">/ReadMe.txt</option></select>
				</p>
				</form>
				<p><strong><a href="glut.zip">Download Sample</a></strong> (&#147;glut.zip&#148;, 374.3K)<BR>
<strong><a href="glut.dmg">Download Sample</a></strong> (&#147;glut.dmg&#148;, 680.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">
/* Copyright (c) Dietmar Planitzer, 1998, 2002 - 2003 */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#import &quot;macx_glut.h&quot;
#import &quot;GLUTWindow.h&quot;
#import &quot;GLUTView.h&quot;
#import &quot;GLUTApplication.h&quot;


NSString *GLUTWindowFrame = @&quot;GLUTWindowFrame&quot;;


@interface GLUTView(GLUTPrivate)
- (void)_commonReshape;
@end


@interface GLUTWindow(GLUTPrivate)
- (id)_initWithContentRect: (NSRect)rect styleMask: (unsigned int)mask contentView: (GLUTView *)aView;
- (id)_initWithWindow: (GLUTWindow *)aWindow operation: (int)op arguments: (NSDictionary *)operands;
- (NSWindow *)_windowWithTIFFInsideRect: (NSRect)rect;
- (NSData *)_dataWithTIFFOfContentView;
- (NSData *)_dataWithRTFDOfContentView;
@end


/////////////////////////////////////////////
#pragma mark -


@implementation GLUTWindow

static BOOL         gInitialized = NO;
static NSArray *    gServicesTypes = nil;


+ (void)initialize
{    
    if(!gInitialized) {
        gInitialized = YES;
        
        gServicesTypes = [[NSArray arrayWithObjects: NSTIFFPboardType, NSRTFDPboardType, nil] retain];
        [NSApp registerServicesMenuSendTypes: gServicesTypes returnTypes: nil];
    }
}

+ (id)windowByMorphingWindow: (GLUTWindow *)aWindow operation: (int)op arguments: (NSDictionary *)dict
{
   return [[[self alloc] _initWithWindow: aWindow operation: op arguments: dict] autorelease];
}


/* Designated initializer */
- (id)_initWithContentRect: (NSRect)rect styleMask: (unsigned int)mask contentView: (GLUTView *)aView
{
   if((self = [super initWithContentRect: rect styleMask: mask backing: NSBackingStoreBuffered defer: NO]) != nil) {
      [self setReleasedWhenClosed: NO];
      [self setMinSize: NSMakeSize(80.0, 80.0)];
      [self setShowsResizeIndicator:NO]; // turn off the grow box.
      [self setContentView: aView];
      [self makeFirstResponder: aView];
      [self setDelegate: self];
      return self;
   }
   return nil;
}

- (id)initWithContentRect: (NSRect)rect pixelFormat: (NSOpenGLPixelFormat *)pixelFormat
            windowID: (int)winid gameMode: (BOOL)gameMode fullscreenStereo: (BOOL)pfStereo treatAsSingle: (BOOL)treatAsSingle
{
   unsigned int    mask;
   GLUTView *        view = nil;
   
   if(gameMode) { // set to fill screen
      float                offsetY = 0.0f;
      /* XXX NSScreen BUG WORKAROUND
         The purpose of the following code is to workaround a bug in the NSScreen class.
         The problem is that this class doesn't realize that we switched from the original
         screen mode to another mode via the CGDisplaySwitchToMode() function and thus
         keeps on reporting now out-dated screen attributes like screen width &amp; height.
         This however has the unfortunate consequence that our NSWindow would be positioned
         incorrectly if the new mode has a smaller Y resolution than the old one. I.e.
         if the old Y res was 870 and the new is 480 the window would be placed by 390 pixels
         too far below.
      */
      NSScreen *    screen = [[NSScreen screens] objectAtIndex: 0];
      NSSize        screenSize = [screen frame].size;
      
      if(screenSize.height - rect.size.height &gt; 0.0f)
         offsetY = screenSize.height - rect.size.height;
      rect.origin.y = offsetY;
      mask = NSBorderlessWindowMask;
   } else {
      mask = (NSTitledWindowMask | NSMiniaturizableWindowMask | NSResizableWindowMask);
   }
   
   /* create and configure content view */
   view = [[[GLUTView alloc]    initWithFrame: rect
                              pixelFormat: pixelFormat
                              windowID: winid
                              treatAsSingle: treatAsSingle
                              isSubwindow: NO
                              fullscreenStereo:pfStereo 
                              isVBLSynced: __glutSyncToVBL] autorelease];
   if(view)
      return [self _initWithContentRect: rect styleMask: mask contentView: view];
   else
      return nil;
}

- (id)_initWithWindow: (GLUTWindow *)aWindow operation: (int)op arguments: (NSDictionary *)dict
{
   GLUTView *        contentView = nil;
   NSResponder *    savedFirstResponder;
   NSRect            rect = {{0.0f, 0.0f}, {0.0f, 0.0f}};
   unsigned int        mask = 0;
   int                level = 0;
   
   switch(op) {
      case kGLUTMorphOperationFullscreen:
            /* Make a fullscreen window */
            if (NO == __glutUseExtendedDesktop) {
                rect = [[aWindow screen] frame];
            } else { // look at all screens
                NSEnumerator *enumerator = [[NSScreen screens] objectEnumerator];
                NSScreen *    screen = nil;
                while (nil != (screen = (NSScreen *)[enumerator nextObject])) {
                    if([screen frame].origin.x &lt; rect.origin.x)
                        rect.origin.x = [screen frame].origin.x;
                    if([screen frame].origin.y &lt; rect.origin.y)
                        rect.origin.y = [screen frame].origin.y;
                    if(([screen frame].origin.x + [screen frame].size.width - rect.origin.x) &gt; rect.size.width)
                        rect.size.width = [screen frame].origin.x + [screen frame].size.width - rect.origin.x;
                    if(([screen frame].origin.y + [screen frame].size.height -  rect.origin.y) &gt; rect.size.height)
                        rect.size.height = [screen frame].origin.y + [screen frame].size.height -  rect.origin.y;
                }
            }
            mask = NSBorderlessWindowMask;
            level = GLUT_FULLSCREEN_LEVEL;

            break;
            
      case kGLUTMorphOperationRegular:
            /* Make a standard window */
            rect = [[dict objectForKey: GLUTWindowFrame] rectValue];
            mask = (NSTitledWindowMask | NSMiniaturizableWindowMask | NSResizableWindowMask);
            level = GLUT_NORMAL_LEVEL;
            break;
   }
   
   savedFirstResponder = [aWindow firstResponder];
   contentView = (GLUTView *) [[aWindow contentView] retain];
   [contentView recursiveWillBeginMorph: op];
   [aWindow setContentView: nil];
   
   if((self = [self _initWithContentRect: rect styleMask: mask contentView: contentView]) != nil) {
      [self setLevel: level];

      switch(op) {
         case kGLUTMorphOperationFullscreen: // new window is full screen
            _isFullscreen = YES;
            /* put window on fullscreen window list */
            _nextFullscreenWindow = __glutFullscreenWindows;
            __glutFullscreenWindows = self;
               break;
         case kGLUTMorphOperationRegular: // new window is not full screen
            _isFullscreen = NO;
               break;
      }
      

      _imagePath = [aWindow-&gt;_imagePath copy];
      _enabledMouseMovedEvents = aWindow-&gt;_enabledMouseMovedEvents;
      if(_enabledMouseMovedEvents &gt; 0)
         [self setAcceptsMouseMovedEvents: YES];
      [contentView recursiveDidEndMorph: op];
      [self makeFirstResponder: savedFirstResponder];
      // Call _commonReshape on the window's content view in order
      // to simulate a resize event (we don't automatically get one
      // because we just moved the content view from one window to
      // to another one...)
      [contentView _commonReshape];
      [contentView release];
      
      return self;
   }
   return nil;
}

- (void)dealloc
{
    // remove from full screen window list
   if(_isFullscreen) {
      GLUTWindow *    prev = nil;
      GLUTWindow *    cur = __glutFullscreenWindows;
      
      while(cur != nil &amp;&amp; cur != self) {
         prev = cur;
         cur = cur-&gt;_nextFullscreenWindow;
      }
      
      if(prev)
         prev-&gt;_nextFullscreenWindow = _nextFullscreenWindow;
      else
         __glutFullscreenWindows = _nextFullscreenWindow;
   }
   
   [super dealloc];
}

- (void)finalize
{
   if(_isFullscreen) {
      GLUTWindow *    prev = nil;
      GLUTWindow *    cur = __glutFullscreenWindows;
      while(cur != nil &amp;&amp; cur != self) {
         prev = cur;
         cur = cur-&gt;_nextFullscreenWindow;
      }
      if(prev)
         prev-&gt;_nextFullscreenWindow = _nextFullscreenWindow;
      else
         __glutFullscreenWindows = _nextFullscreenWindow;
   }
   [super finalize];
}

- (BOOL)isFullscreen
{
   return _isFullscreen;
}

/* Returns YES if the window 'me' is either above or below the frame rectangle
   of any fullscreen window and NO otherwise */
- (BOOL)isAffectedByFullscreenWindow
{
   NSRect            frame = [self frame];
   GLUTWindow *    cur = __glutFullscreenWindows;
   
   while(cur != nil) {
      NSRect    othFrame = [cur frame];
      
      if(NSContainsRect(othFrame, frame) ||
         NSEqualRects(othFrame, frame) ||
         NSIntersectsRect(othFrame, frame))
         return YES;
         
      cur = cur-&gt;_nextFullscreenWindow;
   }
   return NO;
}


/////////////////////////////////////////////
#pragma mark -
#pragma mark Events
#pragma mark -


- (void)enableMouseMovedEvents
{
   _enabledMouseMovedEvents++;
   if(_enabledMouseMovedEvents == 1)
      [self setAcceptsMouseMovedEvents: YES];
}

- (void)disableMouseMovedEvents
{
   NSAssert(_enabledMouseMovedEvents &gt;= 0, @&quot;bogus -disableMouseMovedEvents&quot;);
   _enabledMouseMovedEvents--;
   if(_enabledMouseMovedEvents == 0)
      [self setAcceptsMouseMovedEvents: NO];
}

- (BOOL)canBecomeKeyWindow
{
   return (!__glutGameModeWindow &amp;&amp; !_isFullscreen) ? [super canBecomeKeyWindow] : YES;
}

- (void)sendEvent: (NSEvent *)event
{
   [super sendEvent: event];
   if(__glutMappedMenu) {
      /* use mapped menu to determine if menu finishing needs to be done, regardless of button */
         __glutFinishMenu([NSEvent mouseLocation]); /* sets mapped menu to nil */
         __glutMenuWindow = nil;
    }
}

- (BOOL)validateMenuItem: (NSMenuItem *)menuItem
{
   SEL    action = [menuItem action];
   
   if(action == @selector(save:) || action == @selector(saveAs:))
      return (!__glutDisableGrabbing) ? [self isDocumentEdited] : NO;
   
   if(action == @selector(copy:))
      return (!__glutDisableGrabbing);
   
   if(__glutDisablePrinting) {
      if(action == @selector(runPageLayout:) || action == @selector(print:))
         return NO;
   }
   return [super validateMenuItem: menuItem];
}

- (IBAction)save: (id)sender
{
   if(_imagePath) {
      NSData *    data = [self contentsAsDataOfType: NSTIFFPboardType];

      if(!data || !__glutWriteDataToFile(data, _imagePath, 'TIFF')) {
         NSBundle *    bdl = __glutGetFrameworkBundle();
         
         NSRunCriticalAlertPanel(NSLocalizedStringFromTableInBundle(@&quot;Save Error&quot;, @&quot;GLUTUI&quot;,
                              bdl, @&quot;Save Error&quot;),
                              NSLocalizedStringFromTableInBundle(@&quot;Unable to save current window contents.&quot;, @&quot;GLUTUI&quot;,
                              bdl, @&quot;Unable to save current window contents.&quot;),
                              @&quot;OK&quot;, nil, nil);
      }
      [self setDocumentEdited: NO];
   } else {
        [self saveAs: sender];
   }
}

   /* Save As */
- (void)savePanelDidEnd: (NSWindow *)sheet returnCode: (int)returnCode contextInfo: (id)savePanel
{
   if(returnCode == NSOKButton) {
      NSData *    data = [self contentsAsDataOfType: NSTIFFPboardType];
      
      [_imagePath release];
      _imagePath = [[savePanel filename] copy];
      
      if(!data || !__glutWriteDataToFile(data, _imagePath, 'TIFF')) {
         NSBundle *    bdl = __glutGetFrameworkBundle();
         
         NSRunCriticalAlertPanel(NSLocalizedStringFromTableInBundle(@&quot;Save Error&quot;, @&quot;GLUTUI&quot;,
                              bdl, @&quot;Save Error&quot;),
                              NSLocalizedStringFromTableInBundle(@&quot;Unable to save current window contents.&quot;, @&quot;GLUTUI&quot;,
                              bdl, @&quot;Unable to save current window contents.&quot;),
                              @&quot;OK&quot;, nil, nil);
      }

      [self setDocumentEdited: NO];
   }
}

- (IBAction)saveAs: (id)sender
{
   NSSavePanel *    savePanel = [NSSavePanel savePanel];
   NSString *        imageDirectory, *imageName;
   
   if(!_imagePath) {
      _imagePath = [[[NSFileManager defaultManager] currentDirectoryPath] copy];
      imageDirectory = _imagePath;
      imageName = @&quot;&quot;;
   } else {
      imageDirectory = _imagePath;
      imageName = [[_imagePath lastPathComponent] stringByDeletingPathExtension];
   }
   
   [savePanel setCanSelectHiddenExtension: YES];
   [savePanel setRequiredFileType: @&quot;tiff&quot;];
   [savePanel    beginSheetForDirectory: imageDirectory
               file: imageName
               modalForWindow: self
               modalDelegate: self
               didEndSelector: @selector(savePanelDidEnd:returnCode:contextInfo:)
               contextInfo: savePanel];
}

- (IBAction)copy: (id)sender
{
   NSString *    type = NSTIFFPboardType;
   NSData *        imageData = [self contentsAsDataOfType: type];
    
   if(imageData) {
      NSPasteboard *    generalPboard = [NSPasteboard generalPasteboard];
      
      [generalPboard declareTypes: [NSArray arrayWithObjects: type, nil] owner: nil];
      [generalPboard setData: imageData forType: type];
   }
}

   /* Page Layout */
- (void)pageLayoutDidEnd: (NSPageLayout *)pageLayout returnCode: (int)returnCode contextInfo: (id)printInfo
{
   if(returnCode == NSOKButton) {
      [NSPrintInfo setSharedPrintInfo: printInfo];
   }
}

- (void)runPageLayout: (id)sender
{
   NSPageLayout *    pageLayout = [NSPageLayout pageLayout];
   NSPrintInfo *    printInfo = [NSPrintInfo sharedPrintInfo];
   
   [pageLayout    beginSheetWithPrintInfo: printInfo
               modalForWindow: self
               delegate: self
               didEndSelector: @selector(pageLayoutDidEnd:returnCode:contextInfo:)
               contextInfo: printInfo];
}

   /* Print Panel */
- (void)printOperationDidRun: (NSPrintOperation *)printOperation success: (BOOL)success contextInfo: (id)window
{
   [window release];
}

- (void)print: (id)sender
{
   NSWindow *    window = [[self _windowWithTIFFInsideRect: NSZeroRect] retain];
   
   if(window) {
      NSPrintOperation *    printOperation = [NSPrintOperation printOperationWithView: [window contentView]];
      
      [printOperation    runOperationModalForWindow: self
                        delegate: self
                        didRunSelector: @selector(printOperationDidRun:success:contextInfo:)
                        contextInfo: window];
   } else {
      NSBundle *    bdl = __glutGetFrameworkBundle();
      
      NSRunCriticalAlertPanel(NSLocalizedStringFromTableInBundle(@&quot;Print Error&quot;, @&quot;GLUTUI&quot;,
                              bdl, @&quot;Print Error&quot;),
                              NSLocalizedStringFromTableInBundle(@&quot;Could not generate PDF data for printing.&quot;, @&quot;GLUTUI&quot;,
                              bdl, @&quot;Could not generate PDF data for printing.&quot;),
                              @&quot;OK&quot;, nil, nil);
   }
}

- (void)zoom:(id)sender
{
   NSMutableSet *    views = [NSMutableSet set];
   GLUTView *        view = (GLUTView *) [self contentView];
   
   [views unionSet: [view coveredViews]];
   [views addObject: view];
   
   [super zoom: sender];
   
   [views unionSet: [view coveredViews]];
   [GLUTView evaluateVisibilityOfViews: views];
}


/////////////////////////////////////////////
#pragma mark -
#pragma mark Services
#pragma mark -


- (id)validRequestorForSendType:(NSString *)sendType returnType:(NSString *)returnType
{
   if([gServicesTypes containsObject: sendType])
      return self;
   
   return [super validRequestorForSendType: sendType returnType: returnType];
}

- (BOOL)writeSelectionToPasteboard:(NSPasteboard *)pboard types:(NSArray *)types
{
   unsigned    i, count = [types count];
   
   for(i = 0; i &lt; count; i++) {
      NSString *    pboardType = [types objectAtIndex: i];
      NSData *        imageData = [self contentsAsDataOfType: pboardType];
      
      if(imageData) {
         [pboard declareTypes: [NSArray arrayWithObject: pboardType] owner: nil];
         [pboard setData: imageData forType: pboardType];
         return YES;
      }
   }
   
   return NO;
}


/////////////////////////////////////////////
#pragma mark -
#pragma mark Image Data Creation
#pragma mark -


- (NSWindow *)_windowWithTIFFInsideRect: (NSRect)rect
{
   NSImage *        image = nil;
   NSImageView *    imageView = nil;
   NSWindow *        window = nil;
   GLUTView *        view = (GLUTView *) [self contentView];
   
   if(NSIsEmptyRect(rect))
      rect = [view bounds];
   
   if((imageView = [[NSImageView alloc] initWithFrame: rect]) == nil)
      return nil;
   
   if((window = [[NSWindow alloc]    initWithContentRect: rect
                                                styleMask: NSBorderlessWindowMask
                                                backing: NSBackingStoreNonretained
                                                defer: NO]) == nil) {
      [imageView release];
      return nil;
   }
      
   [window setContentView: imageView];
   [imageView release];
   
   if((image = [view imageWithTIFFInsideRect: rect]) == nil) {
      [window release];
      return nil;
   }    
   [imageView setImage: image];
   
   return [window autorelease];
}

- (NSData *)_dataWithTIFFOfContentView
{
   NSImage *    image = [(GLUTView *) [self contentView] imageWithTIFFInsideRect: NSZeroRect];
   NSData *        data = nil;
   
   if(image != nil) {
      data = [image TIFFRepresentation];
   }
   return data;
}

- (NSData *)_dataWithRTFDOfContentView
{
    static int                generationCounter = 1;
    NSAttributedString *    myString = nil;
    NSFileWrapper *        myFileWrapper = nil;
    NSTextAttachment *    myTextAttachment = nil;
    NSData *                    tiffData = [self _dataWithTIFFOfContentView];
        
        // create file wrapper
    if((myFileWrapper = [[NSFileWrapper alloc] initRegularFileWithContents: tiffData]) == nil)
      return nil;
    [myFileWrapper setPreferredFilename: [NSString stringWithFormat: @&quot;GLUT Picture No.%d.tiff&quot;, generationCounter++]];
    
        // create the text attachment
    if((myTextAttachment = [[NSTextAttachment alloc] initWithFileWrapper: myFileWrapper]) == nil) {
      [myFileWrapper release];
      return nil;
   }
    [myFileWrapper release];
    
        // create the attributed string
    if((myString = [NSAttributedString attributedStringWithAttachment: myTextAttachment]) == nil) {
      [myTextAttachment release];
      return nil;
   }
    [myTextAttachment release];
        
        // return the flattend data
    return [myString RTFDFromRange: NSMakeRange(0, [myString length]) documentAttributes: nil];
}

    /* Returns a data object containing the current contents of the receiving window */
- (NSData *)contentsAsDataOfType: (NSString *)pboardType
{
   NSData *    data = nil;
   
   if([pboardType isEqualToString: NSTIFFPboardType] == YES) {
        data = [self _dataWithTIFFOfContentView];
    } else if([pboardType isEqualToString: NSRTFDPboardType] == YES) {
        data = [self _dataWithRTFDOfContentView];
    }
    
    return data;
}


/////////////////////////////////////////////
#pragma mark -
#pragma mark Delegate 
#pragma mark -


- (BOOL)windowShouldClose: (id)sender
{
   GLUTView *        view = (GLUTView *) [self contentView];
   GLUTwmcloseCB    closeFunc = [view wmCloseCallback];
   
   /* Enable special behavior of glutDestroyWindow() while we're here */
   __glutInsideWindowShouldClose = YES;
   __glutShouldWindowClose = NO;
   __glutSetWindow(view);
   closeFunc();
   __glutInsideWindowShouldClose = NO;
   
   /* Only return with YES, if the application called glutDestroyWindow().
      Return NO otherwise. */
   return __glutShouldWindowClose;
}

    /* Update the window status of the receiver and all of it's sub windows. */
- (void)windowWillMiniaturize:(NSNotification *)notification
{
   GLUTView *    view = (GLUTView *) [self contentView];

   /* Miniaturizing a window with an OpenGL content view in it is a bit tricky,
      because the OpenGL graphics is drawn in its own surface which floats above
      the Quartz window and thus is not directly accessible to the latter.
      In order to get around this, we tell our GLUTView to copy its OpenGL pixels
      from its associated surface into its Quartz context. The copied pixels will
      finally end up in the window's backing store where they can be easily
      grabbed from by the window minaturization engine. */
   [view prepareForMiniaturization];
   _viewStorage = [[NSMutableSet alloc] init];
   [_viewStorage unionSet: [view coveredViews]];
   [_viewStorage addObject: view];
}

- (void)windowDidMiniaturize:(NSNotification *)notification
{
   [GLUTView evaluateVisibilityOfViews: _viewStorage];
   [_viewStorage release];
   _viewStorage = nil;
   [(GLUTView *) [self contentView] setShown: NO];
}

- (void)windowWillMove:(NSNotification *)notification
{
   GLUTView *    view = (GLUTView *) [self contentView];

   _viewStorage = [[NSMutableSet alloc] init];
   [_viewStorage unionSet: [view coveredViews]];
   [_viewStorage addObject: view];
}

- (void)windowDidMove:(NSNotification *)notification
{
   [_viewStorage unionSet: [(GLUTView *) [self contentView] coveredViews]];
   [GLUTView evaluateVisibilityOfViews: _viewStorage];
   [_viewStorage release];
   _viewStorage = nil;
}

- (void)orderWindow:(NSWindowOrderingMode)place relativeTo:(int)otherWin
{
   GLUTView *    view = (GLUTView *) [self contentView];

   if(view != nil) {
      NSMutableSet *    views = [NSMutableSet set];
      
      if(place == NSWindowOut) {
         [views unionSet: [view coveredViews]];
         [views addObject: view];
      }
  
      [view setShown: (place != NSWindowOut)];
      [super orderWindow: place relativeTo: otherWin];
      
      if(place != NSWindowOut) {
         [views unionSet: [view coveredViews]];
         [view recursiveCollectViewsIntoSet: views];
      }
      
      [GLUTView evaluateVisibilityOfViews: views];
   } else {
      [super orderWindow: place relativeTo: otherWin];
   }
}

@end
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/glut/listing82.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/glut/listing82.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/glut/listing82.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>