<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OffSample - /Offscreen.p</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">OffSample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OffSample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Offscreen.p</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/OffSample.h</option>
<option value="listing2.html">/OffSample.p</option>
<option value="listing3.html">/OffSample.r</option>
<option value="listing4.html">/Offscreen.inc1.p</option>
<option value="listing5.html">/Offscreen.p</option>
<option value="listing6.html">/UFailure.a</option>
<option value="listing7.html">/UFailure.inc1.p</option>
<option value="listing8.html">/UFailure.p</option></select>
				</p>
				</form>
				<p><strong><a href="OffSample.zip">Download Sample</a></strong> (&#147;OffSample.zip&#148;, 56.6K)<BR>
<strong><a href="OffSample.dmg">Download Sample</a></strong> (&#147;OffSample.dmg&#148;, 118.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">{------------------------------------------------------------------------------##  Apple Macintosh Developer Technical Support##  &quot;Skippy White's Famous High Level Off-Screen Map Routines&quot;##  Offscreen.p    -  Pascal Header##  Copyright &copy; 1989 Apple Computer, Inc.#  All rights reserved.#  The characters depicted herein (except Skippy White) are fictitious.##  Versions:  #        1.00        04/89#        1.01        06/92##  Components:#        Offscreen.p      April 1, 1988#        Offscreen.inc1.p  April 1, 1988##  These routines provide a high-level interface to the QuickDraw &amp; Color#  Manager routines which allow the creation and manipulation of off-screen#  bitmaps and pixmaps. They are designed to run on any machine with 128K or#  later ROMs (sorry 64K ROM fans).#  Note that the design incorporates the idea that you can go along pretending#  there is an offscreen buffer even when one couldn't be allocated, and the#  calls will do nothing.#-------------------------------------------------------------------------------}UNIT Offscreen;INTERFACE  USES Types, QuickDraw, Events, Controls, Windows, TextEdit, Dialogs, Fonts, Lists,  Menus, Resources, Scrap, ToolUtils,   OSUtils, Files, Devices, DeskBus, DiskInit, Disks, Errors, Memory, Retrace, SegLoad, Serial,  ShutDown, Slots, Sound, Start, Timer;CONST  noDeviceIntersectErr = -6969;  kMaxDepth = 0;    kOffscreenReserve = 8196;{Must be called before any routines of the unit are used.}PROCEDURE InitOffscreen; {Create an off-screen pixel map for drawing into and then bltting elsewhere.}FUNCTION NewOffscreen(bounds: Rect; depth: INTEGER; colors: CTabHandle;            memoryPolite: BOOLEAN; VAR buffNotNeeded: BOOLEAN; VAR offscreenHandle: Handle): OSErr;{  Memory Manager errors may occur. In addition, if the requested depth is  not supported by QuickDraw, memFullErr will be returned.  bounds:    The bounds rectangle to be used for the pixmap (in global coordinates).  This will often be the same as the bounding rectangle of a port or window  to be used. It must be in global coordinates, however, so you can't (directly)  use a window's portRect.  The bounds will be offset so that topLeft is at (0, 0) before setting up the  off-screen port. The global version will be stored as the requested bounds,  and updated by calls to MoveOffscreen.    NOTE: if you'll pass in a depth &gt; 0, you can use a &quot;local&quot; boundsRect.  depth:    The desired pixel depth of the map. Use kMaxDepth (0) if you want the  maximum depth device for the (global) bounds rectangle.  colors: (only applies if depth &gt; 0; ignored otherwise)    The color table you want the off-screen pixmap to have. If you pass in NIL  the color table from the System or ROM (for that depth) will be used.  memoryPolite:    If true, the bits will be kept in a purgeable block. If it gets purged, then  CheckOffscreen or CheckBoundsOffscreen will reallocate it and a redraw will be needed.  offscreenHandle:    The new handle to the (private) data is returned in offscreenHandle.  A new graphics device will be created if requestedDepth &gt; 0. NewHandle will  be used to allocate storage for the actual pixels.}{Dispose of the entire off-screen data structure.}PROCEDURE DisposeOffscreen(offscreenHandle: Handle);{Prepare to draw to an off-screen port and map. The port and handle to the bits will be locked down. If you don't have a specific port you want to use, pass in NIL for port and the private one for this buffer will be used. Although you can use this for a buffered window and pass in the WindowPtr, you would normally use BeginUpdateOffscreen instead (see below).}PROCEDURE BeginOffscreenDrawing(offscreenHandle: Handle; port: GrafPtr);{Call this when through drawing to the off-screen map. Must match a previous StartDO call, of course. }PROCEDURE EndOffscreenDrawing(offscreenHandle: Handle);{Check to see if the depth or color table of the principal graphic device associated with the bits has changed. Call this when you get an update event that relates to this buffer, and if you have some idle time and want to redraw any part of the offscreen map that is invalid.  For buffered windows, call this right before you call BeginUpdateOffscreen; don't skip the Begin- EndUpdateOffscreen stuff even if drawNeeded returns FALSE.  drawNeeded will return TRUE if you need to redraw the contents of the map. The result, if &lt;&gt; noErr, will usually be a Memory Manager error indicating that the block of bits for a new (greater) depth couldn't be allocated.}FUNCTION CheckOffscreen(offscreenHandle: Handle; VAR drawNeeded: BOOLEAN): OSErr;{Call this when the rectangle of the off-screen map needs to change, perhaps due to a window moving on the main screen. This will also check for any change in depth. drawNeeded will return TRUE if you need to redraw the contents of the map. The result, if &lt;&gt; noErr, will usually be a Memory Manager error indicating that the block of bits for a new (greater) size (or depth) couldn't be allocated.}FUNCTION CheckBoundsOffscreen(offscreenHandle: Handle; newBounds: Rect;             VAR drawNeeded: BOOLEAN): OSErr;{When buffering the contents of a window, use this instead of ValidRect. If offscreenHandle isn't a buffer for a window, pass in NIL for the window parameter.}PROCEDURE ValidRectOffscreen(offscreenHandle: Handle; window: WindowPtr; validRect: Rect);{When buffering the contents of a window, use this instead of ValidRgn. If offscreenHandle isn't a buffer for a window, pass in NIL for the window parameter.}PROCEDURE ValidRgnOffscreen(offscreenHandle: Handle; window: WindowPtr; validRegion: RgnHandle);{When buffering the contents of a window, use this instead of InvalRect. If offscreenHandle isn't a buffer for a window, pass in NIL for the window parameter.}PROCEDURE InvalRectOffscreen(offscreenHandle: Handle; window: WindowPtr; invalidRect: Rect);{When buffering the contents of a window, use this instead of InvalRgn. If offscreenHandle isn't a buffer for a window, pass in NIL for the window parameter.}PROCEDURE InvalRgnOffscreen(offscreenHandle: Handle; window: WindowPtr; invalidRgn: RgnHandle);{Get a map pointer, suitable for CopyBits. Note that neither the map itself, nor the bits pointed to are locked down. Thus this map, and the bits pointed to by GetMap^.baseAddr will move. Also note that this will be a BitMapPtr for Classic QD systems, and will be a PixMapPtr for Color QD systems. NIL will be returned if there are no bits. It may be possible to re-allocate them with CheckOffscreen.}FUNCTION GetMap(offscreenHandle: Handle): BitMapPtr;{Returns a handle to the bits. NIL means either that it got purged, or that the bits aren't in a heap block after all.}FUNCTION GetBitsHandle(offscreenHandle: Handle): Handle;{---------- Here are routines specific to buffered windows ----------}  {Create an off-screen pixel map for a port. It will always use kMaxDepth and always be memoryPolite (???and shouldn't return buffNotNeeded?).}FUNCTION NewOffscreenForWindow(window: WindowPtr; VAR buffNotNeeded: BOOLEAN;                 VAR offscreenHandle: Handle): OSErr;{When buffering a window you should use this instead of BeginUpdate. The visRgn will be setup properly. window must be a valid window (don't pass in NIL). Call EndUpdateOffscreen when you are through drawing.} PROCEDURE BeginUpdateOffscreen(offscreenHandle: Handle; window: WindowPtr);{The sequence is BeginUpdateOffscreen, draw, EndUpdateOffscreen}PROCEDURE EndUpdateOffscreen(offscreenHandle: Handle; window: WindowPtr);IMPLEMENTATION{$I Offscreen.inc1.p}END.</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OffSample/listing5.html%3Fid%3DDTS10000144-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OffSample/listing5.html%3Fid%3DDTS10000144-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OffSample/listing5.html%3Fid%3DDTS10000144-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>