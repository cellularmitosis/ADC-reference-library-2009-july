<html><head><title>Mac OS X
 Manual Page For XML::LibXML::Parser(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/XML::LibXML::Parser" title="Mac OS X
 Manual Page for XML::LibXML::Parser(3pm)"><a name="//apple_ref/doc/man/3/XML::LibXML::Parser" title="Mac OS X
 Manual Page for XML::LibXML::Parser(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/XML::LibXML::Parser"; name=XML::LibXML::Parser(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
XML::LibXML::Parser(3)               User Contributed Perl Documentation              XML::LibXML::Parser(3)



<b>NAME</b>
       XML::LibXML::Parser - Parsing XML Data with XML::LibXML

<b>SYNOPSIS</b>
         $parser = XML::LibXML-&gt;new();
         $doc = $parser-&gt;parse_file( $xmlfilename );
         $doc = $parser-&gt;parse_fh( $io_fh );
         $doc = $parser-&gt;parse_string( $xmlstring);
         $doc = $parser-&gt;parse_html_file( $htmlfile );
         $doc = $parser-&gt;parse_html_fh( $io_fh );
         $doc = $parser-&gt;parse_html_string( $htmlstring );
         $fragment = $parser-&gt;parse_balanced_chunk( $wbxmlstring );
         $fragment = $parser-&gt;parse_xml_chunk( $wbxmlstring );
         $parser-&gt;process_xincludes( $doc );
         $parser-&gt;processXIncludes( $doc );
         $parser-&gt;parse_chunk($string, $terminate);
         $parser-&gt;start_push();
         $parser-&gt;push(@data);
         $doc = $parser-&gt;finish_push( $recover );
         $parser-&gt;validation(1);
         $parser-&gt;recover(1);
         $parser-&gt;recover_silently(1);
         $parser-&gt;expand_entities(0);
         $parser-&gt;keep_blanks(0);
         $parser-&gt;pedantic_parser(1);
         $parser-&gt;line_numbers(1);
         $parser-&gt;load_ext_dtd(1);
         $parser-&gt;complete_attributes(1);
         $parser-&gt;expand_xinclude(1);
         $parser-&gt;load_catalog( $catalog_file );
         $parser-&gt;base_uri( $your_base_uri );
         $parser-&gt;gdome_dom(1);
         $parser-&gt;clean_namespaces( 1 );

<b>DESCRIPTION</b>
<b>SYNOPSIS</b>
         use XML::LibXML;
         my $parser = XML::LibXML-&gt;new();

         my $doc = $parser-&gt;parse_string(&lt;&lt;'EOT');
         &lt;some-xml/&gt;
         EOT
         my $fdoc = $parser-&gt;parse_file( $xmlfile );

         my $fhdoc = $parser-&gt;parse_fh( $xmlstream );

         my $fragment = $parser-&gt;parse_xml_chunk( $xml_wb_chunk );

<b>PARSING</b>
       A XML document is read into a datastructure such as a DOM tree by a piece of software, called a
       parser. XML::LibXML currently provides four diffrent parser interfaces:

          A DOM Pull-Parser

          A DOM Push-Parser

          A SAX Parser

          A DOM based SAX Parser.

       <b>Creating</b> <b>a</b> <b>Parser</b> <b>Instance</b>

       XML::LibXML provides an OO interface to the libxml2 parser functions. Thus you have to create a
       parser instance before you can parse any XML data.

       <b>new</b>
             $parser = XML::LibXML-&gt;new();

           There is nothing much to say about the constructor. It simply creates a new parser instance.

           Although libxml2 uses mainly global flags to alter the behaviour of the parser, each XML::LibXML
           parser instance has its own flags or callbacks and does not interfere with other instances.

       <b>DOM</b> <b>Parser</b>

       One of the common parser interfaces of XML::LibXML is the DOM parser. This parser reads XML data into
       a DOM like datastructure, so each tag can get accessed and transformed.

       XML::LibXML's DOM parser is not only capable to parse XML data, but also (strict) HTML files. There
       are three ways to parse documents - as a string, as a Perl filehandle, or as a filename. The return
       value from each is a XML::LibXML::Document object, which is a DOM object.

       All of the functions listed below will throw an exception if the document is invalid. To prevent this
       causing your program exiting, wrap the call in an eval{} block

       <b>parse_file</b>
             $doc = $parser-&gt;parse_file( $xmlfilename );

           This function reads an absolute filename into the memory. It causes XML::LibXML to use libxml2's
           file parser instead of letting perl reading the file such as with <u>parse</u><b>_</b><u>fh()</u>. If you need to
           parse files directly, this function would be the faster choice, since this function is about 6-8
           times faster then <u>parse</u><b>_</b><u>fh()</u>.

       <b>parse_fh</b>
             $doc = $parser-&gt;parse_fh( $io_fh );

           <u>parse</u><b>_</b><u>fh()</u> parses a IOREF or a subclass of IO::Handle.

           Because the data comes from an open handle, libxml2's parser does not know about the base URI of
           the document. To set the base URI one should use <u>parse</u><b>_</b><u>fh()</u> as follows:

             my $doc = $parser-&gt;parse_fh( $io_fh, $baseuri );

       <b>parse_string</b>
             $doc = $parser-&gt;parse_string( $xmlstring);

           This function is similar to <u>parse</u><b>_</b><u>fh()</u>, but it parses a XML document that is available as a
           single string in memory. Again, you can pass an optional base URI to the function.

             my $doc = $parser-&gt;parse_string( $xmlstring, $baseuri );

       <b>parse_html_file</b>
             $doc = $parser-&gt;parse_html_file( $htmlfile );

           Similar to <u>parse</u><b>_</b><u>file()</u> but parses HTML (strict) documents.

       <b>parse_html_fh</b>
             $doc = $parser-&gt;parse_html_fh( $io_fh );

           Similar to <u>parse</u><b>_</b><u>fh()</u> but parses HTML (strict) streams.

       <b>parse_html_string</b>
             $doc = $parser-&gt;parse_html_string( $htmlstring );

           Similar to <u>parse</u><b>_</b><u>file()</u> but parses HTML (strict) strings.

       Parsing HTML may cause problems, especially if the ampersand ('&amp;') is used.  This is a common problem
       if HTML code is parsed that contains links to CGI-scripts. Such links cause the parser to throw
       errors. In such cases libxml2 still parses the entire document as there was no error, but the error
       causes XML::LibXML to stop the parsing process. However, the document is not lost.  Such HTML
       documents should be parsed using the recover flag. By default recovering is deactivated.

       The functions described above are implemented to parse well formed documents.  In some cases a
       program gets well balanced XML instead of well formed documents (e.g. a XML fragment from a
       Database). With XML::LibXML it is not required to wrap such fragments in the code, because
       XML::LibXML is capable even to parse well balanced XML fragments.

       <b>parse_balanced_chunk</b>
             $fragment = $parser-&gt;parse_balanced_chunk( $wbxmlstring );

           This function parses a well balanced XML string into a XML::LibXML::DocumentFragment.

       <b>parse_xml_chunk</b>
             $fragment = $parser-&gt;parse_xml_chunk( $wbxmlstring );

           This is the old name of <u>parse</u><b>_</b><u>balanced</u><b>_</b><u>chunk()</u>. Because it may causes confusion with the push
           parser interface, this function should be used anymore.

       By default XML::LibXML does not process XInclude tags within a XML Document (see options section
       below). XML::LibXML allows to post process a document to expand XInclude tags.

       <b>process_xincludes</b>
             $parser-&gt;process_xincludes( $doc );

           After a document is parsed into a DOM structure, you may want to expand the documents XInclude
           tags. This function processes the given document structure and expands all XInclude tags (or
           throws an error) by using the flags and callbacks of the given parser instance.

           Note that the resulting Tree contains some extra nodes (of type XML_XINCLUDE_START and
           XML_XINCLUDE_END) after successfully processing the document. These nodes indicate where data was
           included into the original tree.  if the document is serialized, these extra nodes will not show
           up.

           Remember: A Document with processed XIncludes differs from the original document after
           serialization, because the original XInclude tags will not get restored!

           If the parser flag "expand_xincludes" is set to 1, you need not to post process the parsed
           document.

       <b>processXIncludes</b>
             $parser-&gt;processXIncludes( $doc );

           This is an alias to process_xincludes, but through a JAVA like function name.

       <b>Push</b> <b>Parser</b>

       XML::LibXML provides a push parser interface. Rather than pulling the data from a given source the
       push parser waits for the data to be pushed into it.

       This allows one to parse large documents without waiting for the parser to finish. The interface is
       especially useful if a program needs to preprocess the incoming pieces of XML (e.g. to detect
       document boundaries).

       While XML::LibXML parse_*() functions force the data to be a wellformed XML, the push parser will
       take any arbitrary string that contains some XML data. The only requirement is that all the pushed
       strings are together a well formed document. With the push parser interface a programm can interrupt
       the parsing process as required, where the parse_*() functions give not enough flexibility.

       Different to the pull parser implemented in <u>parse</u><b>_</b><u>fh()</u> or <u>parse</u><b>_</b><u>file()</u>, the push parser is not able
       to find out about the documents end itself. Thus the calling program needs to indicate explicitly
       when the parsing is done.

       In XML::LibXML this is done by a single function:

       <b>parse_chunk</b>
             $parser-&gt;parse_chunk($string, $terminate);

           <u>parse</u><b>_</b><u>chunk()</u> tries to parse a given chunk of data, which isn't nessecarily well balanced data.
           The function takes two parameters: The chunk of data as a string and optional a termination flag.
           If the termination flag is set to a true value (e.g. 1), the parsing will be stopped and the
           resulting document will be returned as the following exable describes:

             my $parser = XML::LibXML-&gt;new;
             for my $string ( "&lt;", "foo", ' bar="hello worls"', "/&gt;") {
                  $parser-&gt;parse_chunk( $string );
             }
             my $doc = $parser-&gt;parse_chunk("", 1); # terminate the parsing

       Internally XML::LibXML provides three functions that control the push parser process:

       <b>start_push</b>
             $parser-&gt;start_push();

           Initializes the push parser.

       <b>push</b>
             $parser-&gt;push(@data);

           This function pushes the data stored inside the array to libxml2's parser. Each entry in @data
           must be a normal scalar!

       <b>finish_push</b>
             $doc = $parser-&gt;finish_push( $recover );

           This function returns the result of the parsing process. If this function is called without a
           parameter it will complain about non wellformed documents. If $restore is 1, the push parser can
           be used to restore broken or non well formed (XML) documents as the following example shows:

             eval {
                 $parser-&gt;push( "&lt;foo&gt;", "bar" );
                 $doc = $parser-&gt;finish_push();    # will report broken XML
             };
             if ( $@ ) {
                # ...
             }

           This can be annoying if the closing tag is missed by accident. The following code will restore
           the document:

             eval {
                 $parser-&gt;push( "&lt;foo&gt;", "bar" );
                 $doc = $parser-&gt;finish_push(1);   # will return the data parsed
                                                   # unless an error happened
             };

             print $doc-&gt;toString(); # returns "&lt;foo&gt;bar&lt;/foo&gt;"

           Of course <u>finish</u><b>_</b><u>push()</u> will return nothing if there was no data pushed to the parser before.

       <b>DOM</b> <b>based</b> <b>SAX</b> <b>Parser</b>

       XML::LibXML provides a DOM based SAX parser. The SAX parser is defined in XML::LibXML::SAX::Parser.
       As it is not a stream based parser, it parses documents into a DOM and traverses the DOM tree
       instead.

       The API of this parser is exactly the same as any other Perl SAX2 parser. See XML::SAX::Intro for
       details.

       Aside from the regular parsing methods, you can access the DOM tree traverser directly, using the
       <u>generate()</u> method:

         my $doc = build_yourself_a_document();
         my $saxparser = $XML::LibXML::SAX::Parser-&gt;new( ... );
         $parser-&gt;generate( $doc );

       This is useful for serializing DOM trees, for example that you might have done prior processing on,
       or that you have as a result of XSLT processing.

       WARNING

       This is NOT a streaming SAX parser. As I said above, this parser reads the entire document into a DOM
       and serialises it. Some people couldn't read that in the paragraph above so I've added this warning.

       If you want a streaming SAX parser look at the XML::LibXML::SAX man page

<b>SERIALIZATION</b>
       XML::LibXML provides some functions to serialize nodes and documents. The serialization functions are
       described on the XML::LibXML::Node manpage or the XML::LibXML::Document manpage. XML::LibXML checks
       three global flags that alter the serialization process:

          skipXMLDeclaration

          skipDTD

          setTagCompression

       of that three functions only setTagCompression is available for all serialization functions.

       Because XML::LibXML does these flags not itself, one has to define them locally as the following
       example shows:

         local $XML::LibXML::skipXMLDeclaration = 1;
         local $XML::LibXML::skipDTD = 1;
         local $XML::LibXML::setTagCompression = 1;

       If skipXMLDeclaration is defined and not '0', the XML declaration is omitted during serialization.

       If skipDTD is defined and not '0', an existing DTD would not be serialized with the document.

       If setTagCompression is defined and not '0' empty tags are displayed as open and closing tags ranther
       than the shortcut. For example the empty tag foo will be rendered as &lt;foo&gt;&lt;/foo&gt; rather than &lt;foo/&gt;.

<b>PARSER</b> <b>OPTIONS</b>
       LibXML options are global (unfortunately this is a limitation of the underlying implementation, not
       this interface). They can either be set using $parser-&gt;option(...), or XML::LibXML-&gt;option(...), both
       are treated in the same manner. Note that even two parser processes will share some of the same
       options, so be careful out there!

       Every option returns the previous value, and can be called without parameters to get the current
       value.

       <b>validation</b>
             $parser-&gt;validation(1);

           Turn validation on (or off). Defaults to off.

       <b>recover</b>
             $parser-&gt;recover(1);

           Turn the parsers recover mode on (or off). Defaults to off.

           This allows one to parse broken XML data into memory. This switch will only work with XML data
           rather than HTML data. Also the validation will be switched off automaticly.

           The recover mode helps to recover documents that are almost wellformed very efficiently. That is
           for example a document that forgets to close the document tag (or any other tag inside the
           document). The recover mode of XML::LibXML has problems restoring documents that are more like
           well ballanced chunks.

           XML::LibXML will only parse until the first fatal error occours, reporting recoverable parsing
           errors as warnings. To suppress these warnings use $parser-&gt;<u>recover</u><b>_</b><u>silently</u>(1); or,
           equivalently, $parser-&gt;<u>recover</u>(2).

       <b>recover_silently</b>
             $parser-&gt;recover_silently(1);

           Turns the parser warnings off (or on). Defaults to on.

           This allows to switch off warnings printed to STDERR when parsing documents with <!-- a --><u>recover</u>(1)<!-- /a -->.

           Please note that calling <u>recover</u><b>_</b><u>silently</u>(0) also turns the parser recover mode off and calling
           <!-- a --><u>recover</u><b>_</b><u>silently</u>(1)<!-- /a --> automatically activates the parser recover mode.

       <b>expand_entities</b>
             $parser-&gt;expand_entities(0);

           Turn entity expansion on or off, enabled by default. If entity expansion is off, any external
           parsed entities in the document are left as entities.  Probably not very useful for most
           purposes.

       <b>keep_blanks</b>
             $parser-&gt;keep_blanks(0);

           Allows you to turn off XML::LibXML's default behaviour of maintaining whitespace in the document.

       <b>pedantic_parser</b>
             $parser-&gt;pedantic_parser(1);

           You can make XML::LibXML more pedantic if you want to.

       <b>line_numbers</b>
             $parser-&gt;line_numbers(1);

           If this option is activated XML::LibXML will store the line number of a node.  This gives more
           information where a validation error occoured. It could be also used to find out about the
           position of a node after parsing (see also <u>XML::LibXML::Node::line</u><b>_</b><u>number()</u>)

           By default line numbering is switched off (0).

       <b>load_ext_dtd</b>
             $parser-&gt;load_ext_dtd(1);

           Load external DTD subsets while parsing.

           This flag is also required for DTD Validation, to provide complete attribute, and to expand
           entities, regardless if the document has an internal subset. Thus switching off external DTD
           loading, will disable entity expansion, validation, and complete attributes on internal subsets
           as well.

           If you leave this parser flag untouched, everythig will work, because the default is 1
           (activated)

       <b>complete_attributes</b>
             $parser-&gt;complete_attributes(1);

           Complete the elements attributes lists with the ones defaulted from the DTDs.  By default, this
           option is enabled.

       <b>expand_xinclude</b>
             $parser-&gt;expand_xinclude(1);

           Expands XIinclude tags immediately while parsing the document. This flag assures that the parser
           callbacks are used while parsing the included document.

       <b>load_catalog</b>
             $parser-&gt;load_catalog( $catalog_file );

           Will use $catalog_file as a catalog during all parsing processes. Using a catalog will
           significantly speed up parsing processes if many external resources are loaded into the parsed
           documents (such as DTDs or XIncludes).

           Note that catalogs will not be available if an external entity handler was specified. At the
           current state it is not possible to make use of both types of resolving systems at the same time.

       <b>base_uri</b>
             $parser-&gt;base_uri( $your_base_uri );

           In case of parsing strings or file handles, XML::LibXML doesn't know about the base uri of the
           document. To make relative references such as XIncludes work, one has to set a separate base URI,
           that is then used for the parsed documents.

       <b>gdome_dom</b>
             $parser-&gt;gdome_dom(1);

           THIS FLAG IS EXPERIMENTAL!

           Although quite powerful XML:LibXML's DOM implementation is limited if one needs or wants full DOM
           level 2 or level 3 support. XML::GDOME is based on libxml2 as well but provides a rather complete
           DOM implementation by wrapping libgdome.  This allows you to make use of XML::LibXML's full
           parser options and XML::GDOME's DOM implementation at the same time.

           To make use of this function, one has to install libgdome and configure XML::LibXML to use this
           library. For this you need to rebuild XML::LibXML!

       <b>clean_namespaces</b>
             $parser-&gt;clean_namespaces( 1 );

           libxml2 2.6.0 and later allows to strip redundant namespace declarations from the DOM tree. To do
           this, one has to set <u>clean</u><b>_</b><u>namespaces()</u> to 1 (TRUE). By default no namespace cleanup is done.

<b>ERROR</b> <b>REPORTING</b>
       XML::LibXML throws exceptions during parsing, validation or XPath processing (and some other
       occations). These errors can be caught by using eval blocks.  The error then will be stored in $@.

       XML::LibXML throws errors as they occour and does not wait if a user test for them. This is a very
       common misunderstanding in the use of XML::LibXML. If the eval is ommited, XML::LibXML will allways
       halt your script by "croaking" (see Carp man page for details).

       Also note that an increasing number of functions throw errors if bad data is passed. If you cannot
       asure valid data passed to XML::LibXML you should eval these functions.

       Note: since version 1.59, <u>get</u><b>_</b><u>last</u><b>_</b><u>error()</u> is no longer available in XML::LibXML for thread-safety
       reasons.

<b>AUTHORS</b>
       Matt Sergeant, Christian Glahn, Petr Pajas,

<b>VERSION</b>
       1.60

<b>COPYRIGHT</b>
       2001-2006, AxKit.com Ltd; 2002-2006 Christian Glahn; 2006 Petr Pajas, All rights reserved.



perl v5.8.8                                      2006-08-26                           XML::LibXML::Parser(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/XML__LibXML__Parser.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/XML__LibXML__Parser.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/XML__LibXML__Parser.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
