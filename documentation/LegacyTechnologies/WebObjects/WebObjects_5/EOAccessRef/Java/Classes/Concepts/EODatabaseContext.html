<html>	<head>		<title>EODatabaseContext Concepts</title>	</head><BODY bgcolor=#ffffff>		<!-- start of header -->		<!--#include virtual="/includes/framesetheader" -->		<!-- end of header --><!-- start of path --><table cellspacing=0 border=0 width=600 valign="left"><tr><td scope="row"><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="../../../../../index.html" target="_top">Documentation</a> <b>></b> <a href="../../../../webobjects.html" target="_top">WebObjects</a></font></td></tr></table><br><!-- end of path -->		<a href="../../EOAccessTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> <a name="EODatabaseContext"></a>		<h1><font color="#000066"><a name="//apple_ref/UNKNOWN_LANGUAGE/cl/EODatabaseContext.Concepts">EODatabaseContext.Concepts</a></font></h1>		<br>		<br>		<a name="BGJEBBCH"></a>		<h2>EODatabaseContext's Interaction with Other Classes</h2>		<p>The relationship between EODatabaseContext and other classes in the control and access layers is illustrated in <a href="#CEFEEAAI">Figure 0-3</a>.</p>		<center>			<a name="CEFEEAAI"></a>			<p><b>Figure 0-3 The Role of an EODatabaseContext</b></p>			<img src="../Art/DbcnTxt.GIF" alt="[image: ../Art/DbcnTxt.GIF]"> </center>		<p>As a subclass of EOCooperatingObjectStore, EODatabaseContext acts as one of possibly several EOCooperatingObjectStores for an EOObjectStoreCoordinator, which mediates between EOEditingContexts and EOCooperatingObjectStores. (EOObjectStore, EOCooperatingObjectStore, and EOObjectStoreCoordinator are provided by the control layer.)</p>		<p>An EODatabaseContext creates an EOAdaptorContext when initialized, and uses this object to communicate with the database server.</p>		<br>		<a name="BGJBBGFF"></a>		<h2>Creating and Using an EODatabaseContext</h2>		<p>Though you can create an EODatabaseContext explicitly by using the static method registeredDatabaseContextForModel, you should rarely need to do so. If you're using the &quot;higher-level&quot; objects EOEditingContexts (EOControl) and EODatabaseDataSources, the database contexts those objects need are created automatically, on demand. When you create database data source (typically for use with a display group-the interface layer's EODisplayGroup or WebObject's WODisplayGroup), it registers a database context that's capable of fetching objects for the data source's entities. If objects fetched into an editing context (described more in the following section) have references to objects from EOModels that are based on another database, an EODatabaseContext is creates and registered for each of the additional databases.</p>		<p>EODatabaseContexts are created on demand when an EOObjectStoreCoordinator (EOControl) posts an <code>CooperatingObjectStoreNeeded</code> notification. The EODatabaseContext class registers for the notification, and it provides the coordinator with a new EODatabaseContext instance that can handle the request. For more discussion of this topic, see the chapter &quot;Application Configurations&quot; in the <i>Enterprise Objects Framework Developer's Guide</i>.</p>		<p>For the most part, you don't need to programmatically interact with an EODatabaseContext. However, some of the reasons you might want to are as follows:</p>		<ul>			<li>To implement your own locking strategy, either application-wide, or on a per-fetch basis. This is described in the section <a href="#CCJCGJAG">&quot;Updating And Locking Strategies&quot; (page 170)</a>. 			<li>To do performance tuning, which is described in the section <a href="#BGJDIIGI">&quot;Faulting&quot; (page 168)</a>. 			<li>To intervene when objects are created and fetched to provide custom behavior. This is described in the section <a href="#BGJCJCCE">&quot;Delegate Methods&quot; (page 169)</a>, and in the individual delegate method descriptions in the section &quot;Instance Methods&quot; (page 346). 		</ul>		<br>		<a name="BGJBDBIE"></a>		<h2>Fetching and Saving Objects</h2>		<p>Conceptually, an EODatabaseContext fetches and saves objects on behalf of an EOEditingContext (EOControl). However, the two objects don't interact with each other directly-an EOObjectStoreCoordinator (EOControl) acts as a mediator between them. The relationship between EOEditingContext, EOObjectStoreCoordinator, and EODatabaseContext is illustrated in <a href="#CEFEBIJA">Figure 0-4</a>. This configuration includes one EOObjectStoreCoordinator, and can include one or more EOEditingContexts, and one or more EODatabaseContexts.</p>		<center>			<a name="CEFEBIJA"></a>			<p><b>Figure 0-4 EOEditingContexts, EOObjectStoreCoordinators, and EODatabaseContexts</b></p>			<img src="../Art/DBBASC2.GIF" alt="[image: ../Art/DBBASC2.GIF]"> </center>		<p>When an editing context fetches objects, the request is passed through the coordinator, which forwards it to the appropriate database context based on the fetch specification or global ID. When the database context receives a request to fetch or write information to the database, it tries to use one of its EODatabaseChannels. If all of its channels are busy, it broadcasts an DatabaseChannelNeededNotification in the hopes that an observer can provide a new channel or that an existing channel can be freed up. This observer could be a manager that decides how many database cursors can be opened by a particular client.</p>		<p>EODatabaseContext knows how to interact with other EOCooperatingObjectStores to save changes made to an object graph in more than one database server. For a more detailed discussion of this subject, see the class specifications for EOObjectStoreCoordinator and EOCooperatingObjectStore.</p>		<br>		<a name="BGJDIBIG"></a>		<h2>Using a Custom Query</h2>		<p>EODatabaseContext defines a hint for use with an EOFetchSpecification (EOControl) in the objectsWithFetchSpecification method. Named by the key <code>CustomQueryExpressionHintKey</code>, the hint's value is a SQL string for performing the fetch. The expression must query the same attributes in the same order that Enterprise Objects Framework would if it were generating the SELECT expression dynamically. If this key is supplied, other characteristics of the EOFetchSpecification such as <b>isDeep</b>, <b>qualifier</b>, and <b>sortOrderings</b> are ignored-in that sense this key is more of a directive than a hint. For more information on hint keys, see the method description for <b>objectsWithFetchSpecification</b>.</p>		<br>		<a name="BGJDIIGI"></a>		<h2>Faulting</h2>		<p>When an EODatabaseContext fetches an object, it examines the relationships defined in the model and creates objects representing the destinations of the fetched object's relationships. For example, if you fetch an employee object, you can ask for its manager and immediately receive an object; you don't have to get the manager's employee ID from the object you just fetched and fetch the manager yourself.</p>		<p>However, EODatabaseContext doesn't immediately fetch data for the destination objects of relationships since fetching is fairly expensive. To avoid this waste of time and resources, the destination objects aren't initially filled with fetched data. Instead, they exist without any of their values until those values are actually needed. When the &quot;empty&quot; destination object (called a <em>fault</em>) is accessed (sent a message), the object triggers its EODatabaseContext to fetch its data.</p>		<p>Faults come in two varieties: single object faults for to-one relationships, and array faults for to-many relationships. When an array fault is accessed, it fetches all of the destination objects and replaces itself with an array of those objects.</p>		<p>You can fine-tune faulting behavior for additional performance gains by using two different mechanisms: batch faulting, and prefetching relationships.</p>		<br>		<h3>Batch Faulting</h3>		<p>When you access a fault, its data is fetched from the database. However, triggering one fault has no effect on other faults-it just fetches the object or array of objects for the one fault. You can take advantage of this expensive round trip to the database server by batching faults together. EODatabaseContext provides the batchFetchRelationship method for doing this. For example, given an array of Employee objects, this method can fetch all of their departments with one round trip to the server, rather than asking the server for each of the employee's departments individually. You can use the delegate methodsdatabaseContextShouldFetchArrayFault anddatabaseContextShouldFetchObjectFault to fine-tune batch faulting behavior.</p>		<p>You can also set batch faulting in an EOModel. In that approach, you specify the <em>number</em> of faults that should be triggered along with the first fault; you don't actually control which faults are triggered the way you do with <b>batchFetchRelationship</b>. For more information on setting batch faulting in an EOModel, see the book <i>Enterprise Objects Framework Tools and Techniques</i>.</p>		<br>		<a name="BGJCJCCE"></a>		<h2>Delegate Methods</h2>		<p>An EODatabaseContext shares its delegate with its EODatabaseChannels. These delegate methods are actually sent from EODatabaseChannel, but they're defined in EODatabaseContext for ease of access:</p>		<ul>			<li>databaseContextDidSelectObjects 			<li>databaseContextShouldSelectObjects 			<li>databaseContextShouldUpdateCurrentSnapshot 			<li>databaseContextShouldUsePessimisticLock 		</ul>		<p>You can use the EODatabaseContext delegate methods to intervene when objects are created and when they're fetched from the database. This gives you more fine-grained control over such issues as how an object's primary key is generated (databaseContextNewPrimaryKey), how and if objects are locked (databaseContextShouldLockObjectWithGlobalID), what fetch specification is used to fetch objects (databaseContextShouldSelectObjects), how batch faulting is performed (databaseContextShouldFetchArrayFault and databaseContextShouldFetchObjectFault), and so on. For more information, see the individual delegate method descriptions in the section &quot;Instance Methods&quot; (page 346).</p>		<br>		<a name="BGJDCJAF"></a>		<h2>Snapshots</h2>		<p>An EODatabase records snapshots for its EODatabaseContexts. These snapshots form the application's view of the current state of the database server. This global view is overridden locally by database contexts, which form their own snapshots as they make changes during a transaction. When a database context commits its top-level transaction, it reconciles all changed snapshots with the global view of the database object, so that other database contexts (except those with open transactions) immediately use the new snapshots as well.</p>		<br>		<a name="CCJCGJAG"></a>		<h2>Updating And Locking Strategies</h2>		<p>EODatabaseContext supports three updating strategies defined in the EODatabaseContext class as integer values:</p>		<br>		<table border="1">			<tr>				<td scope="row"><b>Constant</b></td>				<td><b>Description</b></td>			</tr>			<tr>				<td scope="row"><code>UpdateWithOptimisticLocking</code></td>				<td>The default update strategy. Under optimistic locking, objects aren't locked immediately on being fetched from the server. Instead, whenever you attempt to save updates to an object in the database, the object's snapshot is used to ensure that the values in the corresponding database row haven't changed since the object was fetched. As long as the snapshot matches the values in the database, the update is allowed to proceed.</td>			</tr>			<tr>				<td scope="row"><code>UpdateWithPessimisticLocking</code></td>				<td>Causes objects to be locked in the database when they're selected. This ensures that no one else can modify the objects until the transaction ends. However, this doesn't necessarily mean that either the select or the update operation will succeed.</td>			</tr>			<tr>				<td scope="row"><code>UpdateWithNoLocking</code></td>				<td>Objects are never locked. No comparisons are made between the snapshot and the row to ensure that the values in the corresponding database row haven't changed since the object was fetched.</td>			</tr>		</table><br>		<p>EODatabaseContext also supports &quot;on-demand&quot; locking, in which specific optimistic locks can be promoted to database locks during the course of program execution. You can either use lockObjectWithGlobalID to lock a database row for a particular object, or objectsWithFetchSpecification to fetch objects with a fetch specification that includes locking. </p>		<p>For more discussion of locking strategies, see the chapter &quot;Behind the Scenes&quot; in the <i>Enterprise Objects Framework Developer's Guide</i>.</p>		<dd>		<p>&copy; 2001 Apple Computer, Inc. (Last Published April 13, 2001)</p>		<br>		<a href="../../EOAccessTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> <!-- start of footer -->		<!--#include virtual="/includes/framesetfooter" -->		<!-- end of footer -->	</body></html>