<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note HW01: ADB - The Untold Story: Space Aliens Ate My Mouse</title><meta name="categories" content="Hardware"><meta name="week-posted" content="Aug 31, 1998 - Sep 4, 1998"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><a name="//apple_ref/doc/uid/DTS10002470" title="ADB - The Untold Story: Space Aliens Ate My Mouse"></a><a name="top"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/index.html" target="_blank">Reference Library > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note HW01</div>
<div id="pageheadsub">ADB - The Untold Story: Space Aliens Ate My Mouse</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->                     <P id = "menutext"><A HREF = "#Section1">The ADB         Hardware</a><BR><BR>                  <A HREF = "#Section2">The ADB         Protocol</a><BR><BR>                  <A HREF = "#Section3">ADB         Drivers</a><BR><BR>                  <A HREF = "#Section4">The Cursor Device         Manager (CDM)</A><BR><BR>                  <A HREF = "#Section5">Using         the CDM in Native Code  </a><BR><BR>                 <A HREF = "#Section6">Apple         Devices</a><BR><BR>                  <A HREF = "#Licensing">Licensing</A><BR><BR>                          <A HREF = "#References">References</a><BR><BR>         <A HREF = "#Changes">Change History</a><BR><BR>         <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text -->         <P id = "introtext">This Technical         Note explains a number of esoteric and unknown issues         concerning the Apple Desktop Bus (ADB). It is intended to         detail information concerning all levels of the ADB, from         the hardware to the application usage level. This note is         supplementary to the information in <I>The Guide To         Macintosh Family Hardware</I> and in the <I>Apple Desktop         Bus Specification</I>. The information in the specification         is the most accurate source of data, and unless it is         specifically refuted, it should be treated as the         authoritative source.</P>                      <!-- end_intro_text --><!-- begin_date --><h3 align=center>[Sep 28 1998]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR><!-- begin_content -->         <H2><A NAME="Section1"></A>The ADB Hardware</H2>                  <P>The ADB is a simple serial bus with collision detection.         A common implementation platform for the protocol is a         simple microcontroller: a 2-MHz Motorola 68HC11 has been         used with success, although any number of microcontrollers         would do a more than adequate job. The 2-MHz clock seemed to         be close to minimal for this application; the bus has a         relatively low bandwidth, and, given the packet structure, the         theoretical maximum bandwidth is on the order of 100 - 200         bytes/second. In practice, the bus is not suitable for data-         xtransfer applications; it serves well as a general purpose         input device bus, but high data rates will not work well.         </P>                  <P>In general, the timing for the ADB is fairly tolerant of         small variances; however, many Macintoshes are more         demanding than their predecessors. For this reason, devices         should be tested on a wide range of machines; the best test         for compliance is testing. Specifically, the <CODE>Tlt</CODE>          (stop to start time) parameter has become much less tolerant; fairly         close adherence to its 200-<I>us</I> timing is important. In         particular, devices which respond more rapidly than the 140-<I>us</I>          minimum delay will often fail to initialize properly.         </P>                  <P>It is important that your device be fairly tolerant of         problems on the bus; if a command packet begins but never         seems to complete, your device should time out rather than         hang.  The design of the bus and its connectors means that         there can be occasional glitches in the connection with the         host, and you should try to be as tolerant of these as         possible.</P>                  <P>Because the ADB bus is open collector, collisions can be         detected when a device is attempting to drive the bus high         and another device pulls it low. This means that whenever         the device is driving the bus high, it should be watching to         make sure the bus is actually high; if the bus goes low,         some other device is sending at the same time. When a device         detects a collision, it should immediately stop         transmitting: this means that if two devices are colliding,         one of them will detect the collision, while one will not.         This occurs because a device can only detect the collision if it         is driving the bus high and another device drives it low.         The device driving it low has no way to tell that there was         a collision, as the bus follows it. Since the detecting         device immediately stops transmitting, the other device will         not detect the collision. Thus, if there are a number of         devices transmitting on the bus, only one of them will         complete its transmission without detecting the collision,         unless the unlikely occurrence of more than one device         transmitting exactly the same data with the same timing         occurs, and neither detects the collision.</P>                  <P>The ADB is not particularly tolerant of devices being         connected and disconnected while the bus is live. There         isn't any software architecture to detect the presence of         new devices or the absence of old ones; furthermore, on some         CPUs, the motherboard is not well protected from voltage         transients on the ADB connector.  Plugging in a device while         the Macintosh is powered on could cause damage to the ADB         transceiver or other portions of the Macintosh's circuitry.         </P>                  <P>On some portable Macintoshes, the voltage characteristics         do not adhere to the ADB specification. Clearly, power is very          valuable on all portable computers, so if your device is targeted          towards portable use, you should be extremely careful to keep          your power consumption as low as possible.  While the ADB can          supply the full voltage stated in the specification, drawing          this much power will lead to much more rapid battery draining. On          the PowerBook 140 and 170, there was a specific problem which         caused the low-level input voltage to go above the specified         maximum of 0.8 volts: it commonly came close to 1.5 volts.         This has caused problems for some third-party devices, and it         has been corrected on subsequent machines. (There is a         recommended service procedure for repairing this problem         available from Apple Service representatives, should this be         a problem for a user.)</P>                  <h3>Soft Power</h3>                  <P>On Macintoshes with software power control, the machine         can be turned on by an ADB device. This is accomplished by         momentarily connecting pin 2 on the ADB connector (reserved)         to pin 4 (ground). Pin 2 should be kept grounded until pin 3         (+5 volts) comes up to power, letting you know that the         machine has actually come on. Some Macintoshes do not have         soft-power capabilities; on these machines, grounding pin 2         will have no effect.</P>                  <P><A HREF="#top">Back to top</A></P><h2><A NAME="Section2"></A>The ADB Protocol</H2>                  <h3>Registers</h3>                  <P>Each ADB device has four logical registers; the host can         ask the device to talk to or listen on each one of these         registers.  A talk command asks the device to output the         stored value from that register; a listen commands asks the         device to accept a new value for that register. A register         can contain between two and eight bytes. Some of the registers         have predefined functions: register 0 is used as the primary         data transfer register for most devices; it is this register         which is polled by the input mechanism (as described below).         Register 1 has no specified use; it is available for any use         the device might require. Register 2 has no specified use         for most devices; the ADB specification does define an         "extended address device" protocol for register 2 on devices         at address 1, but this is unused by most developers.         Register 3 is used to identify devices and to separate         devices which occupy the same address, as discussed in         "Address Resolution" below.</P>                  <A NAME="Default"></A>        <h3> Default addresses and handler         IDs</h3>                  <P>Each ADB device identifies its software interface with         two constants: the default address and the handler ID. This         pair uniquely identifies a device's software interface; the         default address usually specifies a device's general type         (such as relative pointing device or keyboard), while the         handler ID specified the particular data protocol this         device uses for communication. The default address         categories are as follows:</p>         <BR>         <TABLE BORDER=1 WIDTH="100%">            <TR>               <TD WIDTH=81 align="center" align="left">                  <B>Default<BR>                                    Address</B>               </TD><td align="left">                  <B>Device Type</B>               </TD></TR>            <TR>               <TD WIDTH=81 align="center" align="left">                  <P>1</p>               </TD><td align="left">                  <P>Security and Dongles</p>               </TD></TR>            <TR>               <TD WIDTH=81 align="center" align="left">                  <P>2</p>               </TD><td align="left">                  <P>Keyboards</p>               </TD></TR>            <TR>               <TD WIDTH=81 align="center" align="left">                  <P>3</p>               </TD><td align="left">                  <P>Relative pointing devices (mice)</p>               </TD></TR>            <TR>               <TD WIDTH=81 align="center" align="left">                  <P>4</p>               </TD><td align="left">                  <P>Absolute pointing devices (tablets)</p>               </TD></TR>            <TR>               <TD WIDTH=81 align="center" align="left">                  <P>5</p>               </TD><td align="left">                  <P>Low speed data transfer devices</p>               </TD></TR>            <TR>               <TD WIDTH=81 align="center" align="left">                  <P>6</p>               </TD><td align="left">                  <P>Reserved (PowerBook Duo charger)</p>               </TD></TR>            <TR>               <TD WIDTH=81 align="center" align="left">                  <P>7</p>               </TD><td align="left">                  <P>Appliances (Miscellaneous catch-all)</p>               </TD></TR>         </TABLE>                  <BR>         <h3>Table 1 -Default address categories</h3>                  <P>The default address is only a guide; there's no real         reason a mouse can't be at address 7, but default addresses         are assigned on a category basis to try to avoid the case         where a user has more than one device at a particular         address. By putting all the relative devices at address 3,         collisions will be avoided at address 3 for all users who         have only one relative pointing device. While the bus is         robust with respect to separating devices which are at the         same address, the ADBS driver-loading mechanism, which is         described below, made it useful to try to avoid having         several dissimilar devices at the same address.</P>                  <P>Default addresses and handler IDs are assigned by Apple         Software Licensing when an ADB license contract is         completed. Default address 0 is used by the ADB host;         addresses 8 through 15 are used as locations for          locating devices dynamically.</P>                  <P>Some devices support more than one data protocol. An         example is the extended keyboard, which can be asked to send         separate key codes for the left and right shift keys. This         change is accomplished by changing its handler ID to 3; the         new handler ID reflects the new data protocol. If your         device receives a request to change handler IDs (via a         listen register 3 command), it should only obey the request         if it knows how to speak the protocol specified by the new         handler ID. For example, the extended keyboard, when         receiving a request to change handler IDs, should accept the         change if it is going to ID 3 or some other ID it knows         about, and should thereafter report that ID as its own in         response to talk register 3 commands.  If it receives a         request to change to handler ID <CODE>$52</CODE>, it should ignore it, as         it does not know what handler ID <CODE>$52</CODE> implies, and continue         to report its original handler ID in response to talk         register 3 commands.</P>                  <P>A special case is devices which emulate Apple device         protocols. For example, you may be constructing a 17-button         mouse for use by specially trained squid; this device has a special         software protocol to allow it to convey the state of all 17         mouse buttons. However, you may wish to emulate the Apple         mouse protocol so your device can be used as a one-button         mouse on machines which don't have your driver software         installed. Due to the software design of the ADB Manager, if         your device is at default address 3, it will have the         default mouse driver installed as its driver at startup         regardless of its handler ID. When your software loads, you         can install a new driver for your device and tell it to         begin talking the 17-button protocol. You have two options:         </P>                  <OL>            <LI>You can have your device power up with the default            Apple mouse handler ID (<CODE>$01</CODE>) or with your own handler ID            as assigned by Apple Software Licensing. If you power up            with the <CODE>$01</CODE> handler ID, your software will have to            locate your device by trying to change the handler ID of            each device which started out at address 3 to you custom            ID, then reading the handler ID of that device back. If            the change sticks, then you know you're talking to your            device, and can install your custom driver. In addition,            the command to change handler IDs told the device to            begin using your custom protocol.</li>                        <LI>Alternatively, you could have your device power up            with your custom handler ID; this would make identifying            your device somewhat easier, as your device could be            identified by its special handler ID. However, you would            have to use some special command to tell the device that            you have installed the new driver and that it can begin            speaking the custom protocol. For example, you could use            a talk register 1 to tell the device that you're ready            for the 17-button data protocol.</li>         </OL>                 <P>Both approaches work well, but the first one is         recommended.  It ensures that the current protocol can always         be determined by looking at the current handler ID; however,         it relies on all devices at that default address handling         commands asking them to change to a different handler ID         properly, as a device which incorrectly changes its handler         ID to your assigned ID would fool you into thinking it was         your device. This doesn't seem to be a large problem, but         there could be some obscure devices with this bug.</P>                  <h3>Address Resolution</h3>                  <P>Address resolution is the process the ADB Manager uses to         separate devices that share the same default address so         they power up shadowing each other at a particular address.         It relies on devices using collision detection to determine         when there is more than one device at a particular address.         </P>                  <P>An ADB device's register 3 is 2 bytes long, and includes 4         bits in which the address is stored. When the device         receives a listen register 3 command, it should take its         address from this 4-bit field. When it receives a talk         register 3 command, it would be redundant to put the         device's address in that field: the device's address is         already uniquely determined by the fact that the device is         responding to the talk register 3 command, which was sent to         a specific address. Instead, a random 4-bit value should be         returned in this field; this makes it easier to detect         collisions between two devices responding to a talk register         3.</P>                  <P>When a device receives a talk register 3 command, it         should send back all of register 3, including the random         field, and it should pay careful attention to collision         detection. Should a device detect a collision when         responding to a talk register 3 request, there is a special         provision in the ADB protocol which says that the device         should ignore the next listen register 3, which asks it to         change address. The next time the device receives a listen         register 3 command, it should check to see if the handler ID         field is set to <CODE>$FE</CODE>. This is a reserved handler ID         used to distinguish this type of listen request. If the handler         ID field is <CODE>$FE</CODE>, the device should only change         address if it has safely transmitted a complete packet since         its last collision. Of course, the device should not adopt the         handler ID of <CODE>$FE</CODE>.</P>                  <P>Here is a summary of a typical sequence where the host is         attempting to separate two devices. There are two devices of         the same type, which I will call Fred and Wilma, at address         3.</P>                  <OL>            <LI>The host will send a talk register 3 command to            address 3.</li>                        <LI>Both Fred and Wilma will receive the command and            begin to respond.</li>                        <LI>Even though they are sending the same data, and they            begin sending at the same time, they select different            random numbers to insert into the "device address" field            of register 3, bits 7-10.</li>                        <LI>Wilma detects a collision while trying to send bit 7            and immediately stops sending.</li>                        <LI>Fred does not detect a collision and completes his            transmission of register 3.</li>                        <LI>The host, seeing that a device has responded to its            talk register 3, sends a listen register 3 to address 3,            asking the device there to move to address <CODE>$F</CODE>.            The handler ID field is <CODE>$FE</CODE>, indicating that a            device should not move if it has detected a collision.</li>                        <LI>Both Fred and Wilma receive the request.</li>                        <LI>Fred moves to address <CODE>$F</CODE>; however, Wilma            does not, as she has been locked out of moving because she            detected a collision while responding to her last talk            register 3 command.</li>                        <LI>The host sends a talk register 3 to address            <CODE>$F</CODE> to ensure that a device moved there. Fred            responds, assuring the host he has moved.</li>                        <LI>The host repeats the separation procedure, sending a            talk register 3 to address 3, followed by a listen            register 3 to address 3, asking the device there to move            to address <CODE>$E</CODE>.</li>                        <LI>This time, Wilma does not detect a collision, as she            is the only device remaining at address 3, so she moves            to address <CODE>$E</CODE>.</li>                        <LI>The host sends yet another talk register 3 to address            3, but does not receive a response, as there are no more            devices remaining at address 3.</li>                        <LI>The host relocates Wilma from address <CODE>$E</CODE>            back to address 3, with a listen register 3 command sent to            address <CODE>$E</CODE>.</li>                        <LI>The host moves on and repeats the process for address            4.</li>         </OL>                  <P>Each and every ADB controller isn't guaranteed to follow         this procedure precisely, but it gives a feeling for the         principle behind the address resolution process. You may see         some implementations moving devices many more times than is         necessary.  This is done because some devices have been         manufactured to tolerances close enough that not only do         they send their bits at exactly the same time and so cannot         detect collisions with each other, but they select the same         random numbers to transmit. We recommend that you include         some low-tolerance device (such as a capacitor on your reset         line) to ensure that various devices will respond         differently and be able to detect their collisions with each         other.</P>                  <h3>Autopolling</h3>                  <P>Autopolling is the primary method by which the host         fetches data from your device. The host repeatedly issues talk         register 0 commands to your device; if your device responds         with data, it is passed to your device's driver, which should         act on it as new data.         </P>                  <P>This implies that register 0 should be the primary data         transfer register for most devices; registers 1 and 2 are         usually only used for supplementary data to configure the         device. Most device drivers have no need to issue commands         to their device, as all necessary data has been transferred         within register 0.</P>                  <P>When a device wishes to transmit data, it should wait         until a command is issued to it or some other device. If,         when this transmission is completing, it still wishes to         transfer data (if the command was sent to our device, it         might have fetched the data already), it should assert SRQ         after the data portion of the command by holding the bus low         for 300 <I>us</I> after the stop bit. This will alert the host         that some device wishes to transmit data. It will then begin         polling those addresses which it knows hold devices. If a         device does not have any data, the host will move on to the         next address, asking each device in turn, until SRQ is no         longer asserted, indicating that all pending data has been         fetched.</P>                  <P>When an SRQ is not asserted, the host will continually         poll the last device to send it data, sending it talk         register 0 commands periodically. This is done under the         assumption that this is likely to be the next place the user         interacts; if the user types a character, she is very likely         to type another soon. On current hosts, this can happen up         to 150 times a second, although it can happen much less         frequently in some cases. If the device responds with any         data, the host will call the device's driver with the data.         </P>                  <P>Your device should only respond with data when sent a         talk register 0 command if it has new data. If the status of         the device has not changed since the last talk register 0,         then it should not respond at all, allowing the bus to time         out. This is useful for two reasons.  First, it tends to         reduce the demands on the host, as your driver need not be         called when your device has nothing useful to say. Second,         in some ADB implementations, the host can get "hung up" on         your device if you always respond. For example, say that you         have a device at address 4 which will always respond         regardless of whether it has new data; there is another         device at address 7.  Moreover, the system is currently         autopolling address 2. If the device at address 7 asserts SRQ,         the system will begin looking through the addresses for         the device which has data to send. When it reaches your         device at address 4, your device will respond, although it         has nothing new to say. On some implementations, this will         cause the host to repeatedly ask your device for more data,         and your device will continue responding. Meanwhile, device         7 is withering away at the end of the bus, and will never get         serviced. What your device should do is not respond to the         talk register 0 (since it has no new data); this will allow all         host implementations to pass you by and reach the device at         address 7, which needs the host's attention.</P>                  <P>A useful summary of a reasonable algorithm is:</P>                  <UL>            <LI>Wait for a command to begin.</li>                        <LI>If the command is directed to my address, handle it.            If it is a talk register 0 command, only respond if there            is new data waiting to be sent.</li>                        <LI>At the end of the command, if there is data waiting            to be sent, assert SRQ, regardless of whom the original            command was directed toward.</li>         </UL>                  <P>This simple behavior will produce the appropriate         responses and SRQ generation for proper bus functioning. It         shouldn't be necessary for your device to have any          explicit knowledge of whether it is the "active" device or not;         a robust basic behavior will eliminate any need for such         information.</P>                  <P>As an optimization, all recent versions of the ADB         Manager will not automatically poll a device which does not         have a driver service routine installed. In this case, they         will switch to autopolling some other device, even if the         manager has not been recently communicated with that device.         However, the host may poll a device, even if it does not have a         service request, in order to try to clear an SRQ on the         bus.</P>                  <h3>Bus Initialization</h3>                  <P>Bus initialization doesn't work exactly as it might seem         from looking at some documentation. A <CODE>SendReset</CODE>         command is never sent to individual devices; rather, when a bus         reset is requested, the ADB Manager sends a         <CODE>SendReset</CODE> command which is broadcast to all         devices, causing them to reset themselves and go to their         default addresses and handler IDs. The relocation and driver         loading procedure will follow immediately after the reset         command is sent.</P>                  <P><A HREF="#top">Back to top</A></P><h2><A NAME="Section3"></A>ADB          Drivers</H2>                  <h3>Driver Installation</h3>                  <P>In the past, the recommended way to install an ADB driver         was to install a resource of type <CODE>'ADBS'</CODE> with the         same resource ID as your device's default address in the         system file (which held code to install the driver for the         ADB driver, along with the driver itself). When the system         was booted or when the bus was reinitialized, the system         would get the <CODE>'ADBS'</CODE> resource and execute it,         which would let your code set up the driver for that device.         Unfortunately, this system is not well-designed for the wide         variety of devices available; the most prominent flaw is         that the <CODE>'ADBS'</CODE >resources are indexed by default         address only.  Thus, there is no way to use the         <CODE>'ADBS'</CODE> mechanism to load drivers for two different         devices at address 7, since there can be only one resource with         ID 7. A further flaw is that it requires installation into         the system file, which is not currently recommended for a         number of reasons. In any case, it has always required a         special installation and deinstallation program, which has been         more than a little confusing for users.</P>                  <P>Currently, the recommended method is to supply the user         with a system extension which will load your driver.  This         can either be a simple extension, or it can be contained         within a control panel, should your device require some user         interface for configuration. Your code, when loaded, should         look for your device and install your driver for it. If your         device is at a default address which is not shared with         standard Apple devices, you don't have to concerned with         what driver is installed for you by default--your device can         just power up at its standard address with its handler ID.         Your extension can then locate your device's current address         by indexing through all the known devices with the ADB         Manager call <CODE>GetADBInfo</CODE>. When you find a device         whose initial address and handler ID match your device's,         you can call <CODE>SetADBInfo</CODE> to install your driver's         completion routine to handle autopolled data from your         device.</P>                  <P>Because your ADB driver is in a system extension which         will not load until well into the system startup process, you         might need to provide standard system functionality before your         driver loads in order to allow the user to interact with the         system during the startup process if your device is a standard         one (a pointing device or keyboard).                  This arrangement also allows the user to use your device to         control their machine even if they don't have the software         installed, such as when they are booting from a floppy. In         this case, your device will need to be able to emulate the         Apple protocol for mouse or keyboard devices until your         software driver loads, as discussed above in         <A HREF = "#Default">"Default         Addresses and Handler IDs"</A>. Until your driver is         installed, your device will be serviced by the default         driver for this address. Even if it cannot emulate an Apple         device, a device at address 2 or 3 must supply harmless data         in register 0 until your driver loads and is installed, as         the Apple ADB driver for that address may inadvertently         receive the contents of your register 0 and attempt to use         it as input data. If the data in your field caused effects         such as the mouse button or shift key sticking down, this         could cause problems for the user.</P>                  <P>If you use the recommended procedure for handler IDs in         this case (powering up with the appropriate Apple handler ID         and switching to your custom ID when your driver loads), you         will need to use ADB commands to find your device at         startup. You should index through the connected ADB devices         with <CODE>GetADBInfo</CODE>, and if you find a device that         has an original address and handler ID which indicates that it         might be your device, attempt to switch it to your handler         ID by using <CODE>ADBOp</CODE> to send it a listen register 3         to change its handler ID. (You will first need to read its         register 3 with a talk register 3 command so you can         correctly copy the various flag bits in the register you         send to the device.) You should then issue a talk register 3         command to the device and examine the response to see if the         new handler ID was accepted and reported back by the device.         If so, you can be certain that this device is yours,         and you can then call <CODE>SetADBInfo</CODE> to install your         driver as the handler for that device.</P>                  <P>In the original method using <CODE>'ADBS'</CODE> resources,         the system could automatically reload your driver any time         the bus was reinitialized. If your driver is loaded via a         system extension, there isn't any way for the system to find         your device and driver, and reconnect them after the bus is         reinitialized and devices are relocated. Thus, you must         manually reconnect your driver to your device each time the         bus is reinitialized. Fortunately, there is a system         provision for you to be notified each time the bus is         reinitialized. There is a low-memory global called         <CODE>jADBProc</CODE> (at address <CODE>$6B8</CODE>) which is a         pointer to a procedure to be called just before and just after         the bus is initialized. When the procedure is called before the         bus is initialized, register <CODE>D0</CODE> is set to 0;         afterword, it is set to 1. When your extension loads and         installs your driver, you should remember the value in the         <CODE>jADBProc</CODE> global and then install a pointer to a         procedure of your own in that location. When your procedure         is called and has finished its processing, it should then         call through to the previous procedure whose address was in         <CODE>jADBProc</CODE> before you replaced it. (If         <CODE>jADBProc</CODE> was equal to 0 before you installed, just         return from your procedure.) Don't forget to preserve         register <CODE>D0</CODE> so subsequent procedures can tell if         they are being called before or after the reinitialization.         The actions you take in the post-initialization case should         basically duplicate your original installation procedure,         including looking through all the devices for devices of         your type and calling <CODE>SetADBInfo</CODE> to install your         driver for your devices.</p>                     <P>For history buffs, this is the second time the         recommended procedure for loading ADB drivers has changed.         Initially, it was recommended that ADB drivers be loaded         with INITs; however, at the time, <CODE>jADBProc</CODE> did not         exist, so when the Macintosh Portable came out, INIT-handled         devices had the fatal flaw of not reloading their drivers when         the Macintosh was put to sleep and reawakened, since this         procedure involved resetting the bus. This caused us to         begin recommending the use of the <CODE>'ADBS'</CODE> resource,         since in this way the driver could be reloaded from the System         file.  However, the <CODE>'ADBS'</CODE> approach has so many         major flaws that we have stopped recommending it now that the         <CODE>jADBProc</CODE> global has been introduced. The         <CODE>jADBProc</CODE> global has been available since System          6.0.4.</P>                  <P>For true history buffs, or possibly for specialized         applications, here is the description of the          <CODE>'ADBS'</CODE> resource functionality. The          <CODE>'ADBS'</CODE> resource is loaded into the           system heap by the system and detached with         <CODE>DetachResource</CODE>. The resource is then called by         <CODE>JSRing</CODE> to the first byte of the         resource. At this time, the registers are set up as follows:         <CODE>A0</CODE> holds the address of the <CODE>'ADBS'</CODE>         resource data (although it is no longer in a resource handle,         thanks to the <CODE>DetachResource</CODE> call); if a handle to         the resource is needed, <CODE>RecoverHandle</CODE> can be         called to retrieve it. The low byte of register <CODE>D0</CODE>         holds the ADB device's current address (due to         relocation, this might not be the same as the default         address) and the low byte of register <CODE>D1</CODE> holds          the handler ID of the device in question.</p>     <P><A HREF="#top">Back to top</A></P><h2><A NAME="Section4"></A>The Cursor Device Manager</H2>         <P>In order to be able to manage an expanding set of         relative movement devices, Apple has created the Cursor         Device Manager, which is a software architecture which         provides a standard interface to devices of widely varying         resolutions and capabilities. This also allows better         management of multiple relative devices on a single bus. In         the old architecture, all connected devices shared a single         button state and acceleration curve, which became a problem         for Apple and for third-party device manufacturers. The         Cursor Device Manager provides a number of calls for         finding, configuring, and manipulating relative devices         connected to the bus. It also supports the new extended         mouse protocol, which is described below in the "Apple         Devices" section.</p>         <h3>Cursor Device Manager types</h3>      <P>The Cursor Device Manager treats each relative or         absolute device as a <B>Cursor Device</B>. Each one is         specified by a <CODE>CursorDeviceRec</CODE> which is defined as         follows:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef struct CursorDevice {    struct CursorDevice    *nextCursorDevice;    // pointer to next record in                                                 // linked list    CursorData             *whichCursor;         // pointer to data for target cursor    long                   refCon;               // application-defined    long                   unused;               // reserved for future    OSType                 devID;                // device identifier (from ADB reg 1)    Fixed                  resolution;           // units/inch (orig. from ADB reg 1)    UInt8                  devClass;             // device class (from ADB reg 1)    UInt8                  cntButton;            // number of buttons (from ADB reg 1)    UInt8                  filler1;              // reserved for future    UInt8                  buttons;              // state of all buttons    UInt8                  buttonOp[8];          // action performed per button    unsigned long          buttonTicks[8];       // ticks when button last went                                                 // up (for debounce)    long                   buttonData[8];        // data for the button operation    unsigned long          doubleClickTime;      // device-specific double click speed    Fixed                  acceleration;         // current acceleration    short                  privateFields[15];    // fields used internally to CDM}CursorDevice,*CursorDevicePtr;</pre>	</TD></TR></TABLE></CENTER><P>The cursor controlled by this cursor device is described         with a <CODE>CursorDataRec</CODE>:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef struct CursorData {    struct CursorData    *nextCursorData;      // next in global list    Ptr                  displayInfo;          // unused (reserved for future)    Fixed                whereX;               // horizontal position    Fixed                whereY;               // vertical position    Point                where;                // the pixel position    Boolean              isAbs;                // has been stuffed with absolute coords    UInt8                buttonCount;          // number of buttons currently pressed    long                 screenRes;            // pixels per inch on the current display    short                privateFields[22];    // fields use internally by CDM}CursorData,*CursorDataPtr;</pre>	</TD></TR></TABLE></CENTER>         <P>Most of the fields are fairly self-explanatory. The         fields labeled as private at the end of the         <CODE>CursorDeviceRec</CODE> are used to manage cursor         acceleration, and shouldn't be modified by your software.         Some of the usage of the other fields will be explained         below in the description of the Cursor Device Manager         routines.</p>         <h3>Cursor Device Manager Routines</h3><h3>CursorDeviceNextDevice:</h3>                  <P><CODE>pascal OSErr CursorDeviceNextDevice(CursorDevicePtr         *ourDevice);</CODE></P>                  <P><CODE>CursorDeviceNextDevice</CODE> can be used to index         through the various devices the Cursor Device Manager is         aware of. You pass it a <CODE>CursorDevicePtr</CODE>; initialize         this variable to <CODE>nil</CODE> to get the first device in the         list, then call <CODE>CursorDeviceNextDevice</CODE> repeatedly,         each time passing the <CODE>CursorDevicePtr</CODE> as it was         last modified; when you have reached the end of the device         list, the pointer returned in the <CODE>curDevice</CODE>         parameter will be 0.</P>                  <h3>CursorDeviceNewDevice:</h3>                  <P><CODE>pascal OSErr CursorDeviceNewDevice(CursorDevicePtr         *ourDevice);</CODE></P>                  <P>Call <CODE>CursorDeviceNewDevice</CODE> to create a new         cursor device and link it into the device chain. The new         device record will be initialized with values representing a         standard one-button mouse; you should call         <CODE>CursorDeviceSetAcceleration</CODE> for the device after         creating it. A pointer to the created device is returned in         the <CODE>ourDevice</CODE> variable.</P>                  <P>New cursor devices are created for all ADB devices with a         type 3 or 4 handler ID. This routine should only be needed         by devices which are connected though some other method,         such as the serial port.</P>                  <h3>CursorDeviceDisposeDevice:</h3>                  <P><CODE>pascal OSErr         CursorDeviceDisposeDevice(CursorDevicePtr ourDevice);</CODE>         </P>                  <P>This routine disposes of a cursor device and unlinks it         from the device chain. This isn't needed by most developers,         but could be useful for non-ADB devices which might be         connected and disconnected.</P>                  <h3>CursorDeviceMove:</h3>                  <P><CODE>pascal OSErr CursorDeviceMove(CursorDevicePtr         ourDevice,long deltaX,long deltaY);</CODE></P>                  <P><CODE>CursorDeviceMove</CODE> accumulates the         <CODE>deltaX</CODE> and <CODE>deltaY</CODE> values into the         recorded movement of the device; the next time the cursor         position is calculated, these deltas will be fed through the         acceleration algorithm and used to move the cursor. This         routine should be called by a relative device driver with the         data it receives from its device, even if the deltas are both         zero.  This lets the acceleration algorithm properly calculate         the appropriate motion. This routine is automatically called by         the default driver for all devices with a type 3 or 4 handler         ID. You would only need to call it if you were using an ADB         device that isn't handled by the default driver, or a non-ADB         device.</P>                  <h3><CODE>CursorDeviceMoveTo</CODE>:</h3>                  <P><CODE>pascal OSErr CursorDeviceMoveTo(CursorDevicePtr         ourDevice,long absX,long absY);</CODE></P>                  <P><CODE>CursorDeviceMoveTo</CODE> sets the absolute position         of the cursor to (<CODE>absX</CODE>, <CODE>absY</CODE>). The         next time the cursor position is calculated, it will be moved         to this absolute location. This would normally be used by a         driver for an absolute pointing device to position the         cursor.</P>                  <h3><CODE>CursorDeviceFlush</CODE>:</h3>                  <P><CODE>pascal OSErr CursorDeviceFlush(CursorDevicePtr         ourDevice);</CODE></P>                  <P><CODE>CursorDeviceFlush</CODE> causes the acceleration and         motion algorithms to flush out all their error collection         and motion deltas into the cursor position: it indicates         that your device is done moving temporarily. This may be         useful for devices which can tell when they become idle         (such as a stylus pointing device); if they call this         routine when they become idle, it ensures that all unused         motion data will be worked into the cursor position at the         next time it is calculated.</P>                  <h3>CursorDeviceButtons:</h3>                  <P><CODE>pascal OSErr CursorDeviceButtons(CursorDevicePtr         ourDevice,short buttons);</CODE></P>                  <P><CODE>CursorDeviceButtons</CODE> handles posting         <CODE>mouseUp</CODE> and <CODE>mouseDown</CODE> events and also         deals with debouncing mouse clicks. Pass the current button         status in the <CODE>buttons</CODE> parameter, going from bit 0         is button 0 to bit 7 representing button 7. For each button,         a one-bit represents down, a zero-bit represents up. This         routine debounces mouse clicks to keep them from looking         like double clicks; if the button goes down less than 2         ticks after coming up, then the <CODE>mouseDown</CODE> will be         ignored. Button up events are never ignored to avoid         problems such as continuous scrolling, which are confusing         and difficult for the user to deal with. A device driver         should call this routine any time it gets a data packet;         this routine deals with keeping track of whether the button         state has changed. This routine automatically calls routines         installed with <CODE>CursorDeviceButtonOp</CODE>.</P>                  <h3>CursorDeviceButtonDown:</h3>                  <P><CODE>pascal OSErr         CursorDeviceButtonDown(CursorDevicePtr         ourDevice);</CODE></P>                  <P><CODE>CursorDeviceButtonDown</CODE> posts a         <CODE>mouseDown</CODE> event if this is the first button to go         down for this device. It is called by the standard button         operation routines, and you should need to call it only if you         use a custom button operation routine.</P>                  <h3>CursorDeviceButtonUp:</h3>                  <P><CODE><CODE>pascal OSErr         CursorDeviceButtonUp(CursorDevicePtr ourDevice);</CODE></CODE>         </P>                  <P><CODE>CursorDeviceButtonUp</CODE> posts a         <CODE>mouseUp</CODE> event if this is the last button to come         up for this device. It is called by the standard button         operation routines; you should need to call it only if you use         a custom button operation routine.</P>                  <h3>CursorDeviceButtonOp:</h3>                  <P><CODE>pascal OSErr CursorDeviceButtonOp(CursorDevicePtr         ourDevice,short buttonNumber,ButtonOpcode opcode,long         data</CODE><CODE><CODE>);</CODE></CODE></P>                  <P><CODE>CursorDeviceButtonOp</CODE> sets a new operation to be         associated with a particular button. <CODE>btnNo</CODE> may         range from 0 to 7, and <CODE>opCode</CODE> specifies what         operation to use. The data field specifies a parameter for         the operation you are setting for the         <CODE>kButtonCustom</CODE> operation. The <CODE>opCode</CODE>          parameter may have one of the following values:</P>                <TABLE BORDER=1 width=500>            <TR>               <td width=157 align=left>                  <CODE>kButtonNoOp</CODE>               </TD>               <td width=250 align=left>                  No action               </TD>               </TR>            <TR>               <td width=157 align=left>                  <CODE>kButtonSingleClick</CODE>               </TD><td width=250 align=left>                  Normal mouse button               </TD></TR>            <TR>               <td width=157 align=left>                  <CODE>kButtonDoubleClickkButton</CODE>               </TD>               <td width=250 align=left>                  Click, release, and click again when pressed               </TD></TR>           <TR>               <td width=157 align=left>                  <CODE>kButtonClickLock</CODE>               </TD>               <td width=250 align=left>                  Click on press, release on next press               </TD></TR>            <TR>               <td width=157 align=left>Custom</TD>               <td width=250 align=left>Call a custom procedure; data holds its address               </TD>               </TR>         </TABLE>         <BR>                  <P>Using the <CODE>btnCustom</CODE> operation will cause a         procedure whose address is passed in data to be called         whenever this button changes state. The procedure takes the         following parameters: the address of the         <CODE>CursorDeviceRec</CODE> record for its device is passed in         register <CODE>A2</CODE>; the button being pressed or released         is in register <CODE>D3</CODE>. The new state of the button will         already have been filled into the buttons field in the         <CODE>CursorDeviceRec</CODE>, so you may use that flag to         determine if the button is being clicked or released. Your         routine does not need to preserve registers <CODE>D0</CODE>,         <CODE>D2</CODE>, <CODE>A0</CODE>, and <CODE>A1</CODE>; it must          preserve all others.</p>                  <P>The <CODE>kButtonCharStroke</CODE> and         <CODE>kButtonAppleScript</CODE> operations are currently         unimplemented and will simply cause the button press to be         ignored.</p>                  <h3>CursorDeviceSetButtons:</h3>                  <P><CODE>pascal OSErr CursorDeviceSetButtons(CursorDevicePtr         ourDevice,short         numberOfButtons</CODE><CODE><CODE>);</CODE></CODE></P>                  <P><CODE>CursorDeviceSetButtons</CODE> allows you to set the         number of buttons on the device specified by         <CODE>ourDevice</CODE> to <CODE>numButtons</CODE>.</P>                  <h3>CursorDeviceSetAcceleration:</h3>                  <P><CODE>pascal OSErr         CursorDeviceSetAcceleration(CursorDevicePtr ourDevice,Fixed         acceleration</CODE><CODE><CODE>);</CODE></CODE></P>                  <p><CODE>CursorDeviceSetAcceleration</CODE> lets you set the         acceleration for the device specified by <CODE>ourDevice</CODE>         to the value specified by <CODE>acceleration</CODE>, where 0         &lt;= <CODE>acceleration</CODE> &lt;= 1. The Cursor Device         Manager will build an acceleration table for the device         based on its device ID or device class and the desired         acceleration value. For details on acceleration resources,         see <A HREF = "#Acceleration">"Acceleration Tables"</A>         below. The acceleration table set by         <CODE>CursorDeviceSetAcceleration</CODE> is found by         interpolating the tables stored in the appropriate         acceleration resource. All <CODE>'accl'</CODE> resources in the         resource chain or in the ROM are searched looking for the         one applying to the specified device, so a control panel         which called <CODE>CursorDeviceSetAcceleration</CODE> could         implicitly use <CODE>'accl'</CODE> resources stored within the         control panel's resource fork.</p>                  <h3>CursorDeviceDoubleTime:</h3>                  <P>pascal OSErr CursorDeviceDoubleTime(CursorDevicePtr         ourDevice;</P>                  <P><CODE>duration: LongInt);</CODE></P>                  <p><CODE>CursorDeviceDoubleTime</CODE> lets you set the         double-click time associated with a particular device. The         duration parameter specifies the time, in ticks, to use as         the double-click time for this device. An application could         be written to check the double-click time for the particular         device in checking for a double-click.</p>                  <h3>CursorDeviceUnitsPerInch:</h3>                  <P>pascal OSErr C<CODE>ursorDeviceUnitsPerInch(CursorDevicePtr         ourDevice;</CODE></P>                  <P><CODE>resolution: Fixed);</CODE></P>                  <p><CODE>CursorDeviceUnitsPerInch</CODE> lets you set the         resolution of a particular device to its physical         resolution, in units per inch. For devices adhering to the         Apple extended mouse protocol, this call shouldn't be         needed, as the resolution can be read from the device's         register 1; however, this call might be made by a driver for         a device which doesn't use the ADB.</p>                  <A NAME="Acceleration"></A>     <h3>Acceleration Tables</h3>                  <p>Acceleration tables are stored in resources of type         <CODE>'accl'</CODE>, which have the following <CODE>Rez</CODE>          description:         </p>             <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>type 'accl' {    literal longInt /* Device identifier or device class */    classAbsolute, /* A flat-response device */    classMouse, /* Mechanical or optical mouse */    classTrackball; /* Trackball */&nbsp;    integer = $$CountOf(AcclTable);    /* Number of tables for this device */    array AcclTable    { /* Entries sorted by first value; must have */ /* at least 0.0 and 1.0 tables */        unsigned hex longint;        /* Acceleration provided by this table (Fixed) */&nbsp;        integer = $$CountOf(AcclPoint); /* Number of control points for this device */        wide array AcclPoint { /* Entries sorted by first value; implicit */            /* first entry (0.0, 0.0); at least one more */            /* entry required. */            unsigned hex longint; /* Device speed (inches per second) (Fixed) */            unsigned hex longint; /* Cursor speed (inches per second) (Fixed) */        };    };};</pre>	</TD></TR></TABLE></CENTER>           <P>The identifier for this <CODE>'accl'</CODE> resource is         stored in the first long word; this is either an         <CODE>OSType</CODE> four-character device identifier or an         integer value specifying the device class. In either case,         the device's identity is generally read from the device's         register 1, as described below in the section         <A HREF = "#Extended">"Extended Apple         Mouse Protocol."</A> The Cursor Device Manager first tries         to match against the specific device identifier, then         against the more general class. Each <CODE>'accl'</CODE>         resource can contain a number of acceleration tables for         different acceleration values; each table contains a number         of entries that match a particular device speed to a         particular cursor speed. An <CODE>'accl'</CODE> resource must         contain at least two acceleration tables, one for an         acceleration of 0.0, and one for an acceleration value of         1.0. When an acceleration value is set for a particular         device, the acceleration table is calculated by         interpolating between the two nearest tables from the         <CODE>'accl'</CODE> resource. There is an implicit entry in         each acceleration table of (0.0, 0.0), which indicates that the         cursor should not move if the device does not. At least one         additional entry is required; the Cursor Device Manager will         use the table entries to figure the cursor movement by using         the device movement to interpolate based on the specified         movement control points.</P>                  <h3>Availability Of The Cursor Device Manager</h3>                  <p>The Cursor Device Manager was introduced in the ROMs of         Macintoshes introduced in February, 1993. It may be         installed via software on any Macintosh. To check to see if         the Cursor Device Manager is available, you should use the         standard <CODE>TrapAvailable</CODE> routine to check to see if         its trap is implemented. The Cursor Device Manager trap is         <CODE>$AADB</CODE>, making it a toolbox trap, trap number         <CODE>$2DB</CODE>.</p>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#include &lt;Traps.h&gt;#include &lt;OSUtils.h&gt;&nbsp;static Boolean CursorDeviceManagerAvailable(void){    return GetToolboxTrapAddress(_CursorDeviceDispatch) !=            GetToolboxTrapAddress(_Unimplemented);}</pre>	</TD></TR></TABLE></CENTER>                  <h3>Compatibility</h3>                  <p>When the Cursor Device Manager is installed, all Apple         mouse drivers use its interface to move the cursor; this         means that the low memory globals such as <CODE>Mouse</CODE>         and <CODE>RawMouse</CODE> are no longer used. While a         compatibility mode keeps drivers which still modify these         globals continue to work, the cursor position can no longer be         read from these globals.      </p>         <P><A HREF="#top">Back to top</A></P><A NAME="Section5"></A><h2>Using         the CursorDevice Manager in Native Code</h2>                  <P>With the original release of the <CODE>CursorDevice</CODE>         Manager, a problem was introduced in the native         <CODE>InterfaceLib</CODE> code such that the glue         code for the following <CODE>CrsrDev</CODE> calls was         broken.</P>                  <P><code>extern pascal OSErr CrsrDevButtons(CrsrDevicePtr         ourDevice);</code></P>                  <P><code>extern pascal OSErr CrsrDevButtonOp(CrsrDevicePtr         ourDevice);</code></P>                  <P><code>extern pascal OSErr CrsrDevSetButtons(CrsrDevicePtr         ourDevice);</code></P>                  <P><code>extern pascal OSErr         CrsrDevSetAcceleration(CrsrDevicePtr ourDevice);</code></P>                  <P><code>extern pascal OSErr CrsrDevDoubleTime(CrsrDevicePtr         ourDevice);</code></P>                  <P><code>extern pascal OSErr         CrsrDevUnitsPerInch(CrsrDevicePtr ourDevice);</code></P>                  <P>To address this problem, an updated set of         <CODE>CursorDevices</CODE> interfaces were released in which         the calls were modified by changing the call prefix to         <CODE>CursorDevice</CODE>.... This change introduced a new          problem. One could no longer link <CODE>CursorDevice</CODE>          Manager calls with the <CODE>InterfaceLib</CODE> stub         library.  To address this new issue, the "CursorDevices.Glue.c"         file was made available. The downside of using this code was         that it statically linked to the 68K ADB trap code. If in a         future release of MacOS, we were to fix a problem with the         <CODE>CursorDevice</CODE> Manager, code linked to         "CursorDevices.Glue.c" might not benefit from these fixes.          </P>                  <P>Since the release of ETO #24, there is now the         "CursorDevicesGlue.o" object library which all         <CODE>CursorDevice</CODE> Manager processes should link with.         This library will properly detect for an updated         <CODE>CursorDevice</CODE> Manager, else use          the existing 68K ADB trap code. This library expects one         to use the <CODE>CursorDevice</CODE>... calls as prototyped in         the <CODE>CursorDevices</CODE> interface files.</P>         <P><A HREF="#top">Back to top</A></P><h2><A NAME="Section6"></A>Apple Devices</H2>                  <h3>Classic Apple Mouse Protocol</h3>                  <P>The original Apple mouse protocol allows for mice with a         resolution of 100 or 200 units per inch with 7-bit         accumulation of relative movement with one or two buttons.         Handler ID 1 was used to indicate 100 cpi operation; handler         2 to indicate 200 cpi operation. All data is transferred         through register 0 in the following format:</P>                  <p align=center><img src="images/hw_01_001.gif" width=480 height=109 align=bottom alt="Classic Mouse Register 0 Format"></p>                  <P align=center><B>Figure 1</b> - Classic Mouse Register 0 Format</p>                  <P>A relative motion in each axis is accumulated until         fetched with a talk register 0 command sent by the host. The         X value represents left-to-right motion. The Y value holds         accumulated forward-to-back motion.</P>                  <A NAME="Extended"></A><h3>Extended         Apple Mouse Protocol</h3>                  <P>In order to take advantage of the higher movement          resolution support available with the <CODE>CursorDevice</CODE>         Manager, an extended mouse protocol has been defined. The         extended mouse protocol allows a device to communicate up to         16 bits of movement data with each polling, and allows a         standard device to communicate the state of up to 8 buttons.         In addition, the new format allows each device to         communicate its exact type, resolution, and class. This new         format applies to all relative devices at default address 3,         handler ID 4.</P>                  <P>During startup or after a reset of the ADB bus, devices         which power up at default address 3 with handler ID 1 will         be switched to handler ID 4 with a listen register 3         command. If the device accepts the switch and reports the         new handler ID of 4 back in response to a talk register 3         command, all subsequent communication with the device will         be assumed to follow the extended mouse protocol. Currently,         the ADB Manager makes an additional check, making sure that         a talk register 1 returns 8 bytes (the format of register 1         is specified below). If a device accepts a handler ID change         but does not return 8 bytes from register 1, it is assumed         to not actually be an extended mouse protocol device and it is         switched back to its original handler ID.</P>                  <P>All movement and button data still passes through         register 0, which can now hold between 2 and 5 bytes, where         2 bytes provides the device with the data transfer         capability of the original mouse protocol and additional         bytes allow added resolution and buttons.</P>                  <P>Bytes 0 and 1 of register 0 have the same format as they         did in the classic mouse protocol, communicating the state         of the first two buttons and the low order 7 bits of the         accumulated motion in the X and Y axes. There can be up to 3         bytes of additional information: each one of these bytes can         communicate the state of 2 more buttons and add 3 higher         order bits of resolution to each of the X and Y axes. The         format of each additional byte is:</P>                  <P align=center><img src="images/hw_01_002.gif" width=352 height=109 align=bottom alt="Format Of Additional Register 0 Bytes For         Extended Mouse Protocol">         </P>                  <P align=center><b>Figure 2</b> - Format Of Additional Register 0 Bytes For         Extended Mouse Protocol</p>                  <P>As a specific example, in a maximal 5-byte transmission,         the data would be transferred in this format:</P>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P>Bit #:</p>               </TD><td align="left">                  <P>7</p>               </TD><td align="left">                  <P>6</p>               </TD><td align="left">                  <P>5</p>               </TD><td align="left">                  <P>4</p>               </TD><td align="left">                  <P>3</p>               </TD><td align="left">                  <P>2</p>               </TD><td align="left">                  <P>1</p>               </TD><td align="left">                  <P>0</p>               </TD></TR>            <TR>               <td align="left">                  <P>Byte 0:</p>               </TD><td align="left">                  <P>b0</p>               </TD><td align="left">                  <P>y06</p>               </TD><td align="left">                  <P>y05</p>               </TD><td align="left">                  <P>y04</p>               </TD><td align="left">                  <P>y03</p>               </TD><td align="left">                  <P>y02</p>               </TD><td align="left">                  <P>y01</p>               </TD><td align="left">                  <P>y00</p>               </TD></TR>            <TR>               <td align="left">                  <P>Byte 1:</p>               </TD><td align="left">                  <P>b1</p>               </TD><td align="left">                  <P>x06</p>               </TD><td align="left">                  <P>x05</p>               </TD><td align="left">                  <P>x04</p>               </TD><td align="left">                  <P>x03</p>               </TD><td align="left">                  <P>x02</p>               </TD><td align="left">                  <P>x01</p>               </TD><td align="left">                  <P>x00</p>               </TD></TR>            <TR>               <td align="left">                  <P>Byte 2:</p>               </TD><td align="left">                  <P>b2</p>               </TD><td align="left">                  <P>y09</p>               </TD><td align="left">                  <P>y08</p>               </TD><td align="left">                  <P>y07</p>               </TD><td align="left">                  <P>b3</p>               </TD><td align="left">                  <P>x09</p>               </TD><td align="left">                  <P>x08</p>               </TD><td align="left">                  <P>x07</p>               </TD></TR>            <TR>               <td align="left">                  <P>Byte 3:</p>               </TD><td align="left">                  <P>b4</p>               </TD><td align="left">                  <P>y12</p>               </TD><td align="left">                  <P>y11</p>               </TD><td align="left">                  <P>y10</p>               </TD><td align="left">                  <P>b5</p>               </TD><td align="left">                  <P>x12</p>               </TD><td align="left">                  <P>x11</p>               </TD><td align="left">                  <P>x10</p>               </TD></TR>            <TR>               <td align="left">                  <P>Byte 4:</p>               </TD><td align="left">                  <P>b6</p>               </TD><td align="left">                  <P>y15</p>               </TD><td align="left">                  <P>y14</p>               </TD><td align="left">                  <P>y13</p>               </TD><td align="left">                  <P>b7</p>               </TD><td align="left">                  <P>x15</p>               </TD><td align="left">                  <P>x14</p>               </TD><td align="left">                  <P>x13</p>               </TD></TR>         </TABLE><BR>                  <h3>Table 2 - Format of a 5-Byte Register 0 Data         Transfer</h3>                  <P>Where b<I>n</I> indicates the status of button <I>n</I>         and x<I>aa</I> or y<I>bb</I> indicates the value of bit         <I>aa</I> or <I>bb</I> of the X or Y movement.</P>                  <P>In addition, register 1 is used in the extended mouse         protocol to provide some general information about the         device. Register 1 is 8 bytes long and is formatted in this         way:</P>                   <TABLE BORDER=1>            <TR>               <td width=137 align=left>                  <P>Byte Range</p>               </TD><td align="left">                  <P>Format</p>               </TD></TR>            <TR>               <td width=137 align=left>                  <P>0-3</p>               </TD><td align="left">                  <P>Unique device identifier</p>               </TD></TR>            <TR>               <td width=137 align=left>                  <P>4-5</p>               </TD><td align="left">                  <P>Device resolution in units/inch</p>               </TD></TR>            <TR>               <td width=137 align=left>                  <P>6</p>               </TD><td align="left">                  <P>Device class (Mouse, trackball, etc.)</p>               </TD></TR>            <TR>               <td width=137 align=left>                  <P>7</p>               </TD><td align="left">                  <P>Number of buttons (0-8)</p>               </TD></TR>         </TABLE><BR>                  <h3>Table 3 - Format Of Extended Mouse Protocol         Register 1</h3>                  <P>The unique device identifier is intended to be a          four-character ASCII identifier similar to the         <CODE>OSType</CODE> identifiers used as types and creators in         the Macintosh file system; they can be registered using the         same mechanism used to register creator types. A developer          should only use a device identifier in this field if they have         obtained a registration for that identifier's use as a creator          from Apple.</P>                  <P>The device class is a value which is used to identify the         type of device and to control the acceleration curve used         for that device. The currently defined constants include:         </P>                  <TABLE BORDER=1>            <TR>               <td width=137 align=left>                  <P>Device Constant</p>               </TD><td align="left">                  <P>Device Type</p>               </TD></TR>            <TR>               <td width=137 align=left>                  <P>0</p>               </TD><td align="left">                  <P>Tablet device (absolutely positioned)</p>               </TD></TR>            <TR>               <td width=137 align=left>                  <P>1</p>               </TD><td align="left">                  <P>Mouse</p>               </TD></TR>            <TR>               <td width=137 align=left>                  <P>2</p>               </TD><td align="left">                  <P>Trackball</p>               </TD></TR>         </TABLE>         <BR>         <h3>Table 4 - Currently defined device classes</h3>                  <P>There currently isn't any mechanism for developers to         create or register device classes; if a developer needs a         device class not available from Apple, the only alternative         available currently is not to use the handler ID 4 extended         mouse protocol.  Instead they should use a custom handler ID         and custom driver software.</P>                  <h3>Apple Keyboard Protocol</h3>                  <P>The Apple keyboards have a simple data transfer protocol.         Register 0 is used to inform the host as keys are depressed         and released; register 2 is used to communicate the state of         the modifier keys and to control the LED indicators on the         extended keyboards.</P>                  <P>The format of register 0 is:</P>                  <P align=center><img src="images/hw_01_003.gif" width=448 height=109 align=bottom alt="Keyboard Register 0 Format">         </P>                  <p align=center><b>Figure 3</b> - Keyboard Register 0 Format</p>                  <P>Register 0 can communicate up to two key transitions at         once. Each transition consists of a key code and a key         released bit, which is 0 for key depressions and 1 for key         releases. The key codes are described in <I>Inside         Macintosh</I> volume V, pages 191-192. The special case is         the reset key, which returns the value <CODE>$7F7F</CODE> in         register 0 when it is depressed and <CODE>$FFFF</CODE> when         released; thus, it uses both key code positions within register         0.</P>                  <P>The format of register 2 is:</P>                  <P align=center><img src="images/hw_01_004.gif" width=448 height=290 align=bottom alt="Keyboard Register 2 Format">         </P>                  <p align=center><B>Figure 4</b> - Keyboard Register 2 Format</p>                  <P>The current state of the keys listed in figure 4 is         available in bits 6-14 of register 2, if those keys exist on         the keyboard being examined. Bits 0-2 hold the current state         of the LEDs on the extended keyboard; the states of these         LEDs can be changed by sending the keyboard a listen         register 2 command. Note that key transition events are         generated in register 0 for modifier keys, as they are for         all other keys; these keys are available in register 2 in         addition to their status being transmitted through register         0.</P>               <A NAME="Licensing"></A><P><A HREF="#top">Back to top</A></P><h2>Licensing</h2>                  <P>The Apple Desktop Bus is patented. In order to build an         ADB device, you will need to get a license from Apple.</P>                  <p>Contact our <a href="http://developer.apple.com/mkt/registering/swl/llsw.html">         Software Licensing department</A> at         <A HREF = "mailto:sw.license@apple.com">sw.license@apple.com</A>          or 800-793-9378 or 512-919-2645.</p>                  <P>The license is available for a nominal fee in most cases,         and the licensing package includes the latest version of the         ADB specification, which is the definitive reference to the         bus.</p>      <A NAME="References"></A><P><A HREF="#top">Back to top</A></P><h2>References</h2>            <p>The Apple Desktop Bus specification, revision F.</p>                        <p><I>Inside Macintosh</I>, Volume V, chapter 20, "The            Apple Desktop Bus."</p>                        <p><I>Guide to the Macintosh Family Hardware</I>, Second            Edition, Chapter 8, "Apple Desktop Bus."</p>                  <A NAME=changes></A>                  <P><A HREF="#top">Back to top</A></P><h2>Change History</H2>                                  <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>1-October-1991</P>               </TD>               <td align="left">                  <P>New information appears throughout the document.         In particular, the Cursor Device Manager is discussed in         this note for the first time. The information regarding bugs         fixed in System 6.0.4 was omitted.</P>               </TD>            </TR> <TR>               <td width=100 align=left>                  <P ALIGN=center>1-January-1994</P>               </TD>               <td align="left">                  <P>The Cursor Device         Manager API has been updated for Universal Headers 3.1 and         some issues with ROM bugs have been documented.</P>               </TD>            </TR> </table><BR><P><A HREF="#top">Back to top</A></P><P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (252K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/hw_01.pdf">Download</A></P>               </TD>            </TR></table><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/hw/hw_01.html%3Fid%3DDTS10002470-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/hw/hw_01.html%3Fid%3DDTS10002470-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/hw/hw_01.html%3Fid%3DDTS10002470-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>