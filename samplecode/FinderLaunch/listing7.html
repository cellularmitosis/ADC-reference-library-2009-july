<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>FinderLaunch - /CodeWarrior   (OS 9)/TestFinderLaunch.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxInterapplicationCommunication-date.html">Interapplication Communication</a> &gt; <A HREF="javascript:location.replace('index.html');">FinderLaunch</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">FinderLaunch</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/CodeWarrior   (OS 9)/TestFinderLaunch.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CodeWarrior   (OS 9)/FinderLaunch.c</option>
<option value="listing2.html">/CodeWarrior   (OS 9)/FinderLaunch.h</option>
<option value="listing3.html">/CodeWarrior   (OS 9)/MPWTool/FinderLaunch.c</option>
<option value="listing4.html">/CodeWarrior   (OS 9)/MPWTool/FinderLaunch.h</option>
<option value="listing5.html">/CodeWarrior   (OS 9)/MPWTool/FinderLaunchTool.c</option>
<option value="listing6.html">/CodeWarrior   (OS 9)/MPWTool/FinderLaunchTool.r</option>
<option value="listing7.html">/CodeWarrior   (OS 9)/TestFinderLaunch.c</option>
<option value="listing8.html">/CodeWarrior   (OS 9)/TestFinderLaunch.h</option>
<option value="listing9.html">/CodeWarrior   (OS 9)/TestFinderLaunch.r</option>
<option value="listing10.html">/ProjectBuilder (OS X)/FinderLaunch.c</option>
<option value="listing11.html">/ProjectBuilder (OS X)/FinderLaunch.h</option>
<option value="listing12.html">/ProjectBuilder (OS X)/FinderLaunch_Prefix.h</option>
<option value="listing13.html">/ProjectBuilder (OS X)/main.c</option></select>
				</p>
				</form>
				<p><strong><a href="FinderLaunch.zip">Download Sample</a></strong> (&#147;FinderLaunch.zip&#148;, 80.3K)<BR>
<strong><a href="FinderLaunch.dmg">Download Sample</a></strong> (&#147;FinderLaunch.dmg&#148;, 130.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    TestFinderLaunch.c    Description:        A test application for sending an open documents Apple event to the      Finder.  This application calls the FinderLaunch routine defined      in FinderLaunch.c.            This file is organized into the following sections:      HFS OBJECT SELECTION        routines calling Navigation Services or Standard file allowing        the user to select either a file or a directory.      CALLING FinderLaunch        a routine that calls the FinderLaunch routine defined in the file        FinderLaunch.c.  Here, after gathering a list of files/folders        from the user, an open documents apple event is sent to the        Finder specifying the items selected.  The Finder, in turn,        with launch/display/open the items as appropriate.      MAIN WINDOW        routines for drawing and handling clicks in the main window.      MENU HANDLING        menu handleing code      APPLE EVENT HANDLERS        apple event handlers for open and quit application events.      EVENT HANDLING        event dispatching code.  calls to WaitNextEvent are made here.      MAIN PROGRAM        the main program routine including initialization code, the main        loop, and teardown code.  Author:  John Montbriand  Copyright:       Copyright &copy; 1999 by Apple Computer, Inc.      All rights reserved worldwide.    Disclaimer:      You may incorporate this sample code into your applications without      restriction, though the sample code has been provided &quot;AS IS&quot; and the      responsibility for its operation is 100% yours.  However, what you are      not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;      after having made changes. If you're going to re-distribute the source,      we require that you make it clear in the source that the code was      descended from Apple Sample Code, but that you've made changes.    Change History (most recent first):      9/13/99 created by John Montbriand*/#include &quot;TestFinderLaunch.h&quot;#include &quot;FinderLaunch.h&quot;#include &lt;QuickDraw.h&gt;#include &lt;Menus.h&gt;#include &lt;Windows.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Fonts.h&gt;#include &lt;SegLoad.h&gt;#include &lt;Resources.h&gt;#include &lt;Balloons.h&gt;#include &lt;Devices.h&gt;#include &lt;AppleEvents.h&gt;#include &lt;StdIO.h&gt;#include &lt;TextUtils.h&gt;#include &lt;string.h&gt;#include &lt;Gestalt.h&gt;#include &lt;Appearance.h&gt;#include &lt;StandardFile.h&gt;#include &lt;Navigation.h&gt;  /* true while the app is running */Boolean gRunning = true;#ifndef __MWERKS__QDGlobals  qd;  /* QuickDraw globals*/#endifFileFilterYDUPP gFileFilter;DlgHookYDUPP gSFHook;NavEventUPP gNavEventProc;AEIdleUPP gAEIdleProc = NULL; /* idle proc called from AEInteractWithUser */DialogPtr gMainDialog = NULL;Boolean gForground = true;Boolean gAppleEvents = false;Boolean gAppearance = false;/* HFS OBJECT SELECTION ------------------------------------------------ */  /* in this section we define a set of routines for selecting a file or a folder.  Here, NavigationServices is used when it is present, otherwise we fall  back to useing the standard file alerts for system 7.  Note that Navigation  services is strictly PowerPC only, so any parts referring to that API are  bracketed in conditional statements.    These routines are here so there is a way to choose a file or folder from the  main application.  After selecting a file or folder, an Apple event is sent to  the finder asking it to open/launch/display the item. */  /* InvisoFilter is a file filter procedure passed to the CustomGetFile routine.  Its  purpose is to prevent the display of invisible files and folders in the  standard file window. */static pascal Boolean InvisoFilter(ParmBlkPtr PB, void *yourDataPtr) {  CInfoPBRec *cat = (CInfoPBRec *) PB;    /* filter invisible files and folders */  if ((cat-&gt;hFileInfo.ioFlFndrInfo.fdFlags &amp; kIsInvisible) == 0)    return false;  else return true;}/* MySFHook is a dialog hook routine passed to the CustomGetFile routine.  Its purpose  is to maintain the 'Select' button in the bottom right corner of the window.  This  button allows users to select a directory rather than navigate into it.  If the  user clicks on the 'Select' button while a folder is hilited in the list view, then  the folder is passed back to CustomGetFile's caller. */static pascal short MySFHook(short item, DialogPtr dialog, void *yourDataPtr) {    static Boolean gFolderSelected = false;  static ControlHandle gFolderControl = NULL;  StandardFileReply *theReply;    if (GetWRefCon(dialog) != sfMainDialogRefCon) return item;  theReply = (StandardFileReply *) yourDataPtr;  if (item == sfHookFirstCall) {    short itemt;    Rect itemb;    GetDialogItem(dialog, kMySFSelectButton, &amp;itemt, (Handle*) &amp;gFolderControl, &amp;itemb);    HiliteControl(gFolderControl, 255);    gFolderSelected = false;  } else if ((item == kMySFSelectButton) &amp;&amp; gFolderSelected) {    return sfItemOpenButton;  } else {    if (theReply-&gt;sfIsFolder || theReply-&gt;sfIsVolume) {      if ( ! gFolderSelected) {        HiliteControl(gFolderControl, 0);        gFolderSelected = true;      }    } else if (gFolderSelected) {      HiliteControl(gFolderControl, 255);      gFolderSelected = false;    }  }  return item;}#if TARGET_CPU_PPC/* NavEventCallBack is a callback routine provided to the NavChooseObject routine.  In  this routine we process update and activate events for the main window while  navigation services is displaying its window. */ static pascal void NavEventCallBack( NavEventCallbackMessage callBackSelector,      NavCBRecPtr callBackParms, NavCallBackUserData callBackUD) {  if (callBackSelector == kNavCBEvent) {    short ewhat;    ewhat = callBackParms-&gt;eventData.eventDataParms.event-&gt;what;    if ((ewhat == updateEvt) || (ewhat == activateEvt)) {          HandleNextEvent(callBackParms-&gt;eventData.eventDataParms.event);    }  }}#endif/* GetHFSObjectList opens a communication session with the user allowing them to choose  one more file system objects.  After the user has made a selection, a list of the items  chosen is passed back as a AEDescList containing a list of FSSpec records. if the user  cancels the interaction, then no list is returned and a userCanceledErr is returned.*/static OSErr GetHFSObjectList(AEDescList *documents) {#if TARGET_CPU_PPC  NavReplyRecord theReply;#endif  Boolean hasNavReply;  OSErr err;    /* set up locals */  AECreateDesc(typeNull, NULL, 0, documents);  hasNavReply = false;  #if TARGET_CPU_PPC  if (NavServicesAvailable()) {    NavDialogOptions dialogOptions;      /* set the message in the navigation window to indicated multiple      selections are allowed */    memset(&amp;theReply, 0, sizeof(theReply));    err = NavGetDefaultDialogOptions(&amp;dialogOptions);    if (err != noErr) goto bail;    dialogOptions.dialogOptionFlags = (kNavDontAutoTranslate | kNavAllowMultipleFiles);    GetIndString(dialogOptions.message, kMainStrings, kNavTextMessage);      /* run the navigation window */    err = NavChooseObject( NULL, &amp;theReply, &amp;dialogOptions, gNavEventProc, NULL, NULL);    if (err != noErr) goto bail;    if (!theReply.validRecord) { err = userCanceledErr; goto bail; }    hasNavReply = true;      /* duplicate the returned document list */    err = AEDuplicateDesc(&amp;theReply.selection, documents);    if (err != noErr) goto bail;      /* clean up the navigation stuff */    NavDisposeReply(&amp;theReply);  } else#endif  {  Point where = {100, 100};    SFTypeList typeList;    StandardFileReply reply;      /* set up locals    SetPt(&amp;where, 100, 100);      /* run the standard file window */    CustomGetFile(gFileFilter, -1, typeList, &amp;reply, 130, where, gSFHook, NULL, NULL, NULL, &amp;reply);    if (!reply.sfGood) { err = userCanceledErr; goto bail; }      /* if successful, save the selection to a list descriptor */    err = AECreateList(NULL, 0, false, documents);    if (err != noErr) goto bail;    err = AEPutPtr(documents, 0, typeFSS, &amp;reply.sfFile, sizeof(FSSpec));    if (err != noErr) goto bail;  }  return noErr;      /* error recovery */bail:#if TARGET_CPU_PPC  if (hasNavReply) NavDisposeReply(&amp;theReply);#endif  AEDisposeDesc(documents);  return err;}/* CALLING FinderLaunch ------------------------------------------------ */  /* in this section, we call through to the FinderLaunch() routine defined in the  file FinderLaunch.c.  After calling GetHFSObjectList to retrieve a list of one or  more FSSpec records referring to a number of hfs objects, we coerce this list  into an array of FSSpec records and pass it to the FinderLaunch routine. */    /* SelectTargetsToLaunch calls GetHFSObjectList to retrieve a list of files or folders     and then it passes the selected folders and files to the FinderLaunch routine. */static void SelectTargetsToLaunch(void) {  AEDescList documents;  OSErr err;  long index, count;  FSSpec *targets;  AEKeyword keyword;  DescType typecode;  Size actualSize;    /* set up locals */  AECreateDesc(typeNull, NULL, 0, &amp;documents);  targets = NULL;    /* get a list of files from the user */  err = GetHFSObjectList(&amp;documents);  if (err != noErr) goto bail;    /* count the items in the list */  err = AECountItems(&amp;documents, &amp;count);  if (err != noErr) goto bail;    /* allocate an array to store the records */  targets = (FSSpec *) NewPtr(count * sizeof(FSSpec));  if (targets == NULL) { err = memFullErr; goto bail; }    /* copy each record from the list to the array */  for (index = 0; index &lt; count; index++) {    err = AEGetNthPtr(&amp;documents, (index + 1), typeFSS, &amp;keyword, &amp;typecode,      (targets + index), sizeof(FSSpec), &amp;actualSize);    if (err != noErr) goto bail;  }    /* ask the Finder to launch the items */  err = FinderLaunch(count, targets);      /* clean up and leave, report any 'real' errors */bail:  if ((err != noErr) &amp;&amp; (err != userCanceledErr)) {    Str255 errStr;    NumToString(err, errStr);    ParamAlert(kSelectAbortedError, errStr, NULL);  }  if (targets != NULL) DisposePtr((Ptr) targets);  AEDisposeDesc(&amp;documents);}/* MAIN WINDOW ------------------------------------------------ *//* HitMainWindow is called when DialogSelect returns true for the main  dialog window.  This usually indicates that there has been a mouse  down inside of the main window. */static void HitMainWindow(DialogPtr theDialog, EventRecord *ev, short itemNo) {  if (itemNo == kMainSelectButton)    SelectTargetsToLaunch();}/* RedrawMainDialogWindow redraws the main window honoring the current  activation state of the window. */static void RedrawMainDialogWindow(DialogPtr theDialog) {  if (theDialog != NULL) {    short itemt;    ControlHandle theControl;    Rect itemb;        GetDialogItem(theDialog, kMainSelectButton, &amp;itemt, (Handle*) &amp;theControl, &amp;itemb);    if ((theDialog == FrontWindow()) &amp;&amp; gForground)      HiliteControl(theControl, 0);    else HiliteControl(theControl, 255);    DrawDialog(theDialog);  }}/* MENU HANDLING ------------------------------------------------ *//* ResetMenus is called to reset the menus immediately before  either MenuSelect or MenuKey is called.  Here, we disable the  quit command during file copies. */static void ResetMenus(void) {  /* nothing to do here */}/* DoMenuCommand is called after either MenuSelect of MenuKey.  The  parameter rawMenuSelectResult is the result from one of these two routines.   DoMenuCommand parses this result into its two parts, and dispatches  the menu command as appropriate. */static void DoMenuCommand(long rawMenuSelectResult) {  short menu, item;    /* decode the MenuSelect result */  menu = (rawMenuSelectResult &gt;&gt; 16);  if (menu == 0) return;  item = (rawMenuSelectResult &amp; 0x0000FFFF);    /* dispatch on result */  switch (menu) {    case mApple:      if (item == iAbout) {          /* show the about box. */        ParamAlert(kAboutBoxError, NULL, NULL);      } else if (item &gt;= iFirstAppleItem) {        Str255 deskAccName;          /* open an apple menu item. */        GetMenuItemText(GetMenuHandle(mApple), item, deskAccName);        OpenDeskAcc(deskAccName);      }      break;    case mFile:      if (item == iSelectTargets)        SelectTargetsToLaunch();      else if (item == iQuit)         gRunning = false;      break;  }    /* unhilite the menu once we're done the command */  HiliteMenu(0);}/* APPLE EVENT HANDLERS ------------------------------------------------ *//* OpenApplication is an apple event handler called for 'open application' apple events. */static pascal OSErr OpenApplication(const AppleEvent *appleEvt, AppleEvent* reply, long refcon) {  gMainDialog = GetNewDialog(kMainDialog, NULL, (WindowPtr) (-1));  return noErr;}/* CloseApplication is an apple event handler called for 'close application' apple events. */static pascal OSErr CloseApplication(const AppleEvent *appleEvt, AppleEvent* reply, long refcon) {  gRunning = false;  return noErr;}/* EVENT HANDLING ------------------------------------------------ *//* HandleNextEvent handles the event in the event record *ev dispatching  the event to appropriate routines.   */void HandleNextEvent(EventRecord *ev) {  DialogPtr theDialog;  WindowPtr theWindow;  short itemNo;      /* dialog pre-processing */  if (((ev-&gt;what == keyDown) || (ev-&gt;what == autoKey)) &amp;&amp; ((ev-&gt;modifiers &amp; cmdKey) != 0)) {    ResetMenus();    DoMenuCommand(MenuKey((char) (ev-&gt;message &amp; charCodeMask)));  } else if (ev-&gt;what == osEvt) {      /* process manager switches */    if ( (((ev-&gt;message &gt;&gt; 24) &amp; 0x0FF) == suspendResumeMessage) &amp;&amp; ((ev-&gt;message &amp; resumeFlag) != 0)) {      gForground = true;    } else gForground = false;    RedrawMainDialogWindow(gMainDialog);  } else if (ev-&gt;what == activateEvt) {    if ((gMainDialog == ((DialogPtr) ev-&gt;message)))      RedrawMainDialogWindow(gMainDialog);  }    /* handle clicks in the dialog window */  if (IsDialogEvent(ev))    if (DialogSelect(ev, &amp;theDialog, &amp;itemNo)) {      if (theDialog == gMainDialog)        HitMainWindow(theDialog, ev, itemNo);    }    /* clicks and apple events... */  if (ev-&gt;what == kHighLevelEvent) {    AEProcessAppleEvent(ev);  } else if (ev-&gt;what == mouseDown)    switch (FindWindow(ev-&gt;where, &amp;theWindow)) {              /* menu bar clicks */      case inMenuBar:        ResetMenus();        DoMenuCommand(MenuSelect(ev-&gt;where));        break;                /* clicks in the close box, close the app */      case inGoAway:        if (TrackGoAway(theWindow, ev-&gt;where)) {          gRunning = false;        }        break;                /* allow window drags */      case inDrag:        if (theWindow == FrontWindow()) {          Rect boundsRect = { -32000, -32000, 32000, 32000};          DragWindow(theWindow, ev-&gt;where, &amp;boundsRect);        }        break;                /* desktop clicks, etc... */      case inSysWindow:        SystemClick(ev, theWindow);        break;    }}/* ProcessNextEvent calls WaitNextEvent to get the next event and then it passes  the event along to the HandleNextEvent routine.  sleepTime is passed to the  WaitNextEvent routine in the sleep parameter. */void ProcessNextEvent(long sleepTime) {  EventRecord ev;    /* get the next event */  if ( ! WaitNextEvent(everyEvent, &amp;ev,  sleepTime, NULL) )    ev.what = nullEvent;  HandleNextEvent(&amp;ev);}/* FDPIdleProcedure is the idle procedure called by AEInteractWithUser while we are waiting  for the application to be pulled into the forground.  It simply passes the event along  to HandleNextEvent */static pascal Boolean FDPIdleProcedure(EventRecord *theEvent, long *sleepTime, RgnHandle *mouseRgn) {  HandleNextEvent(theEvent);  return false;}/* ParamAlert is a general alert handling routine.  If Apple events exist, then it  calls AEInteractWithUser to ensure the application is in the forground, and then  it displays an alert after passing the s1 and s2 parameters to ParamText. */short ParamAlert(short alertID, StringPtr s1, StringPtr s2) {  AEInteractWithUser(kNoTimeOut, NULL, gAEIdleProc);  ParamText(s1, s2, NULL, NULL);  return Alert(alertID, NULL);}/* MAIN PROGRAM ------------------------------------------------ */int main(void) {  OSErr err;  AEEventHandlerUPP aehandler;  long response;      /* set up our app */  SetApplLimit(GetApplLimit());  MaxApplZone();  InitGraf(&amp;qd.thePort);  InitFonts();  InitWindows();  TEInit();  InitMenus();  InitDialogs(0);  FlushEvents(everyEvent, 0);  InitCursor();    /* apple events??? */  if (Gestalt(gestaltAppleEventsAttr, &amp;response) != noErr) response = 0;  gAppleEvents = ((response &amp; (1&lt;&lt;gestaltAppleEventsPresent)) != 0);  if ( ! gAppleEvents) {    ParamAlert(kReqMgrsNotAvailError, NULL, NULL);    err = userCanceledErr;    goto bail;  }    /* appearance */  if (Gestalt(gestaltAppearanceAttr, &amp;response) != noErr) response = 0;  if ((response &amp; (1&lt;&lt;gestaltAppearanceExists)) != 0) {    err = RegisterAppearanceClient();    if (err != noErr) goto bail;    gAppearance = true;  }#if TARGET_CPU_PPC  if (NavServicesAvailable())    NavLoad();  gNavEventProc = NewNavEventProc(NavEventCallBack);  if (gNavEventProc == NULL) { err = memFullErr; goto bail; }#endif  gFileFilter = NewFileFilterYDProc(InvisoFilter);  if (gFileFilter == NULL) { err = memFullErr; goto bail; }  gSFHook = NewDlgHookYDProc(MySFHook);  if (gSFHook == NULL) { err = memFullErr; goto bail; }  gAEIdleProc = NewAEIdleProc(FDPIdleProcedure);  if (gAEIdleProc == NULL) { err = memFullErr; goto bail; }      /* standard apple events */  aehandler = NewAEEventHandlerProc(OpenApplication);  if (aehandler == NULL) { err = memFullErr; goto bail; }  err = AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, aehandler, 0, false);  if (err != noErr) goto bail;  aehandler = NewAEEventHandlerProc(CloseApplication);  if (aehandler == NULL) { err = memFullErr; goto bail; }  err = AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, aehandler, 0, false);  if (err != noErr) goto bail;    /* set up the menu bar */  SetMenuBar(GetNewMBar(128));  DrawMenuBar();  AppendResMenu(GetMenuHandle(mApple), 'DRVR');    /* run the app */  while (gRunning) {        ProcessNextEvent(-1);      }  bail:#if TARGET_CPU_PPC  if (NavServicesAvailable())    NavUnload();#endif  if (err != noErr &amp;&amp; err != userCanceledErr) {    Str255 errStr;    NumToString(err, errStr);    ParamAlert(kProgramAbortedError, errStr, NULL);  }  if (gAppearance)    UnregisterAppearanceClient();  ExitToShell();  return 0;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/FinderLaunch/listing7.html%3Fid%3DDTS10000666-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/FinderLaunch/listing7.html%3Fid%3DDTS10000666-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/FinderLaunch/listing7.html%3Fid%3DDTS10000666-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>