/******************************************************************************\																				Module:		IRS_Geometry.c																																Purpose: 	plug-in renderer for QD3D: geometry rendering																												Author:		Sun-Inn Shih	+ Roger Holmes																													Parts Copyright (C) 1993-96 Apple Computer, Inc.  All rights reserved.			Parts Copyright (C) 1996 Microspot Ltd.  All rights reserved.																				\*****************************************************************************/#include <QD3D.h>#include <QD3DGeometry.h>#include <QD3DView.h>#include <QD3DDrawContext.h>#include "IRS_Geometry.h"RGBColor ColourFromAttrSet ( TQ3AttributeSet AttributeSet ) ;RGBColor ColourFromAttrSet ( TQ3AttributeSet AttributeSet )	{	RGBColor TheColour ;	if ( AttributeSet )		{		TQ3ColorRGB QColor ;		if ( Q3AttributeSet_Get ( AttributeSet , kQ3AttributeTypeDiffuseColor , &QColor ) )			{			TheColour.red = QColor.r * 0x0000FFFF ;			TheColour.green = QColor.g * 0x0000FFFF ;			TheColour.blue = QColor.b * 0x0000FFFF ;			}		else			{			TheColour.red = 0x7FFF ;			TheColour.green = 0x7FFF ;			TheColour.blue = 0x7FFF ;			}		}	else		{		TheColour.red = 0x7FFF ;		TheColour.green = 0x7FFF ;		TheColour.blue = 0x7FFF ;		}	return TheColour ;	} ;			/* *  IRS_Geometry_Triangle  */TQ3Status IRS_Geometry_Triangle(						TQ3ViewObject 		pView,						irsData				*irsdata,						TQ3GeometryObject	pGeom, 						TQ3TriangleData		*pTriangleData)	{	// local to Frustum	float M00 = irsdata->localToFrustum.value[0][0];	float M01 = irsdata->localToFrustum.value[0][1];	float M02 = irsdata->localToFrustum.value[0][2];	float M03 = irsdata->localToFrustum.value[0][3];	float M10 = irsdata->localToFrustum.value[1][0];	float M11 = irsdata->localToFrustum.value[1][1];	float M12 = irsdata->localToFrustum.value[1][2];	float M13 = irsdata->localToFrustum.value[1][3];	float M20 = irsdata->localToFrustum.value[2][0];	float M21 = irsdata->localToFrustum.value[2][1];	float M22 = irsdata->localToFrustum.value[2][2];	float M23 = irsdata->localToFrustum.value[2][3];	float M30 = irsdata->localToFrustum.value[3][0];	float M31 = irsdata->localToFrustum.value[3][1];	float M32 = irsdata->localToFrustum.value[3][2];	float M33 = irsdata->localToFrustum.value[3][3];		// Triangle data		TQ3DrawContextObject DrawContext ;	if ( Q3View_GetDrawContext ( pView , &DrawContext ) != kQ3Failure )		{		CWindowPtr Window ;		if ( Q3MacDrawContext_GetWindow ( DrawContext , &Window ) != kQ3Failure )			{			TQ3Point2D point2D [ 3 ] ;			for ( long j = 0 ; j < 3 ; ++j )				{				TQ3Point3D point3D = pTriangleData->vertices [ j ].point;								point2D [ j ].x = point3D.x * M00 + point3D.y * M10 + point3D.z * M20 + M30 ;				point2D [ j ].y = point3D.x * M01 + point3D.y * M11 + point3D.z * M21 + M31 ;				float w = 1.0f / ( point3D.x * M03 + point3D.y * M13 + point3D.z * M23 + M33 ) ;							point2D [ j ].x = irsdata->XOffset + point2D [ j ].x * w * irsdata->XScale ;				point2D [ j ].y = irsdata->YOffset - point2D [ j ].y * w * irsdata->YScale ;				} ;			SetPort ( ( GrafPort* ) ( Window ) ) ;			RGBColor TheColour = ColourFromAttrSet ( pTriangleData->triangleAttributeSet ) ;			RGBForeColor ( &TheColour ) ;			MoveTo ( point2D [ 0 ].x , point2D [ 0 ].y ) ;			LineTo ( point2D [ 1 ].x , point2D [ 1 ].y ) ;			LineTo ( point2D [ 2 ].x , point2D [ 2 ].y ) ;			LineTo ( point2D [ 0 ].x , point2D [ 0 ].y ) ;			}			}	return kQ3Success;	}/* *  IRS_Geometry_Line  */TQ3Status IRS_Geometry_Line(					TQ3ViewObject 		pView,					irsData				*irsdata,					TQ3GeometryObject	pGeom, 					TQ3LineData			*pLineData)	{	// local to Frustum	float M00 = irsdata->localToFrustum.value[0][0];	float M01 = irsdata->localToFrustum.value[0][1];	float M02 = irsdata->localToFrustum.value[0][2];	float M03 = irsdata->localToFrustum.value[0][3];	float M10 = irsdata->localToFrustum.value[1][0];	float M11 = irsdata->localToFrustum.value[1][1];	float M12 = irsdata->localToFrustum.value[1][2];	float M13 = irsdata->localToFrustum.value[1][3];	float M20 = irsdata->localToFrustum.value[2][0];	float M21 = irsdata->localToFrustum.value[2][1];	float M22 = irsdata->localToFrustum.value[2][2];	float M23 = irsdata->localToFrustum.value[2][3];	float M30 = irsdata->localToFrustum.value[3][0];	float M31 = irsdata->localToFrustum.value[3][1];	float M32 = irsdata->localToFrustum.value[3][2];	float M33 = irsdata->localToFrustum.value[3][3];		// Line data		TQ3DrawContextObject DrawContext ;	if ( Q3View_GetDrawContext ( pView , &DrawContext ) != kQ3Failure )		{		CWindowPtr Window ;		if ( Q3MacDrawContext_GetWindow ( DrawContext , &Window ) != kQ3Failure )			{			TQ3Point2D point2D [ 2 ] ;			for ( long j = 0 ; j < 2 ; ++j )				{				TQ3Point3D point3D = pLineData->vertices[j].point;								point2D [ j ].x = point3D.x * M00 + point3D.y * M10 + point3D.z * M20 + M30 ;				point2D [ j ].y = point3D.x * M01 + point3D.y * M11 + point3D.z * M21 + M31 ;				float w = 1.0f / ( point3D.x * M03 + point3D.y * M13 + point3D.z * M23 + M33 ) ;							point2D [ j ].x = irsdata->XOffset + point2D[j].x * w * irsdata->XScale ;				point2D [ j ].y = irsdata->YOffset - point2D[j].y * w * irsdata->YScale ;				} ;			SetPort ( ( GrafPort* ) ( Window ) ) ;			RGBColor TheColour = ColourFromAttrSet ( pLineData->lineAttributeSet ) ;			RGBForeColor ( &TheColour ) ;			MoveTo ( point2D [ 0 ].x , point2D [ 0 ].y ) ;			LineTo ( point2D [ 1 ].x , point2D [ 1 ].y ) ;			}			}	return kQ3Success ;	}/* *  IRS_Geometry_Point  */TQ3Status IRS_Geometry_Point(								TQ3ViewObject 		pView,								irsData				*irsdata,								TQ3GeometryObject 	pGeom, 								TQ3PointData		*pPointData)	{	return kQ3Success ;	}/* *  IRS_Geometry_Marker  */TQ3Status IRS_Geometry_Marker(								TQ3ViewObject 		pView,								irsData				*irsdata,								TQ3GeometryObject 	pGeom, 								TQ3MarkerData		*pMarkerData)	{	return kQ3Success;	}/* *  IRS_Geometry_PixmapMarker  */TQ3Status IRS_Geometry_PixmapMarker(								TQ3ViewObject 		pView,								irsData					*irsdata,								TQ3GeometryObject 	pGeom, 								TQ3PixmapMarkerData	*pPixmapMarkerData)	{	return kQ3Success;	}#if 1/* *  IRS_Geometry_TM  */TQ3Status IRS_Geometry_TM (								TQ3ViewObject 		pView,								irsData				*irsdata,								TQ3GeometryObject	pGeom, 								TQ3TriMeshData		*pTriMeshData )	{	// local to Frustum	float M00 = irsdata->localToFrustum.value[0][0];	float M01 = irsdata->localToFrustum.value[0][1];	float M02 = irsdata->localToFrustum.value[0][2];	float M03 = irsdata->localToFrustum.value[0][3];	float M10 = irsdata->localToFrustum.value[1][0];	float M11 = irsdata->localToFrustum.value[1][1];	float M12 = irsdata->localToFrustum.value[1][2];	float M13 = irsdata->localToFrustum.value[1][3];	float M20 = irsdata->localToFrustum.value[2][0];	float M21 = irsdata->localToFrustum.value[2][1];	float M22 = irsdata->localToFrustum.value[2][2];	float M23 = irsdata->localToFrustum.value[2][3];	float M30 = irsdata->localToFrustum.value[3][0];	float M31 = irsdata->localToFrustum.value[3][1];	float M32 = irsdata->localToFrustum.value[3][2];	float M33 = irsdata->localToFrustum.value[3][3];		/* trimesh data */	TQ3TriMeshTriangleData* trianglelist = pTriMeshData->triangles;	TQ3Point3D* pointlist = pTriMeshData->points;	TQ3DrawContextObject DrawContext ;	if ( Q3View_GetDrawContext ( pView , &DrawContext ) != kQ3Failure )		{		CWindowPtr Window ;		if ( Q3MacDrawContext_GetWindow ( DrawContext , &Window ) != kQ3Failure )			{			for ( long i = 0 ; i < pTriMeshData->numTriangles ; ++i , ++trianglelist )				{				TQ3Point2D point2D [ 3 ] ;				for ( long j = 0 ; j < 3 ; ++j )					{					long index = trianglelist->pointIndices [ j ] ;					TQ3Point3D point3D = pointlist [ index ] ;										point2D [ j ].x = point3D.x * M00 + point3D.y * M10 + point3D.z * M20 + M30;					point2D [ j ].y = point3D.x * M01 + point3D.y * M11 + point3D.z * M21 + M31;					float w = 1.0f / ( point3D.x * M03 + point3D.y * M13 + point3D.z * M23 + M33 ) ;									point2D [ j ].x = irsdata->XOffset + point2D [ j ].x * w * irsdata->XScale ;					point2D [ j ].y = irsdata->YOffset - point2D [ j ].y * w * irsdata->YScale ;					}					SetPort ( ( GrafPort* ) ( Window ) ) ;				RGBColor TheColour = ColourFromAttrSet ( pTriMeshData->triMeshAttributeSet ) ;				RGBForeColor ( &TheColour ) ;				MoveTo ( point2D [ 0 ].x , point2D [ 0 ].y ) ;				LineTo ( point2D [ 1 ].x , point2D [ 1 ].y ) ;				LineTo ( point2D [ 2 ].x , point2D [ 2 ].y ) ;				LineTo ( point2D [ 0 ].x , point2D [ 0 ].y ) ;				}			}		}			return kQ3Success ;	}#endif