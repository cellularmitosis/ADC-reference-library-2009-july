/* *	File:		DZSpace.c * *	Contents:	Submits the spacejunk. * *	Copyright © 1996 Apple Computer, Inc. */#include <assert.h>#include <Quickdraw.h>#include "QD3D.h"#include "QD3DGeometry.h"#include "QD3DShader.h"#include "QD3DView.h"#include "DZSpace.h"#ifndef	SPACE_JUNK_IS_LINES#define	SPACE_JUNK_IS_LINES	1#endif#define SPACE_INTERVAL		2.0			// Grid cell size#define SPACE_CUBE			3			// Half side of the cube of cells#define SPACE_SPREAD1		0.0001		// Mulitplier to Random for line start#define SPACE_SPREAD2		0.00002		// Mulitplier to Random for line lengthstatic TQ3AttributeSet	gSpaceColor			= NULL;/* ============================================================================= *		Space_Init (external) * *	Initializes the space stuff. * ========================================================================== */void Space_Init(	void){	gSpaceColor = Q3AttributeSet_New();}/* ============================================================================= *		Space_Exit (external) * *	Prepares for exit. * ========================================================================== */void Space_Exit(	void){	if (gSpaceColor != NULL)	{		Q3Object_Dispose(gSpaceColor);		gSpaceColor = NULL;	}}/* ============================================================================= *		Space_Submit (external) * *	Submits all the 3D geometry of the spacejunk. * ========================================================================== */void Space_Submit(	TQ3ViewObject		inView,	const TQ3Point3D*	inPosition,	const TQ3Vector3D*	inDirection){	long				x;	long				y;	long				z;	long				loX;	long				loY;	long				loZ;	long				hiX;	long				hiY;	long				hiZ;	float				px;	float				py;	float				pz;	TQ3ColorRGB			color;#if	SPACE_JUNK_IS_LINES	TQ3LineData			lineData;#else	// !SPACE_JUNK_IS_LINES	TQ3PointData		pointData;#endif		assert(inView != NULL);	assert(inPosition != NULL);	assert(inDirection != NULL);		// Find the center grid cell	px = inPosition->x + inDirection->x*SPACE_INTERVAL*SPACE_CUBE;	py = inPosition->y + inDirection->y*SPACE_INTERVAL*SPACE_CUBE;	pz = inPosition->z + inDirection->z*SPACE_INTERVAL*SPACE_CUBE;		x = (px + 0.5*SPACE_INTERVAL)/SPACE_INTERVAL;	y = (py + 0.5*SPACE_INTERVAL)/SPACE_INTERVAL;	z = (pz + 0.5*SPACE_INTERVAL)/SPACE_INTERVAL;		// Find the range to cover	loX = x - SPACE_CUBE;	loY = y - SPACE_CUBE;	loZ = z - SPACE_CUBE;		hiX = loX + 2*SPACE_CUBE;	hiY = loY + 2*SPACE_CUBE;	hiZ = loZ + 2*SPACE_CUBE;	#if	SPACE_JUNK_IS_LINES	// Set up the line data	lineData.vertices[0].attributeSet	= NULL;	lineData.vertices[1].attributeSet	= NULL;	lineData.lineAttributeSet			= gSpaceColor;#else	// !SPACE_JUNK_IS_LINES	pointData.pointAttributeSet			= gSpaceColor;#endif			// Do the cube	for (x = loX; x <= hiX; x++)	{		px = (x+0.5)*SPACE_INTERVAL;				for (y = loY; y <= hiY; y++)		{			py = (y+0.5)*SPACE_INTERVAL;						for (z = loZ; z <= hiZ; z++)			{				pz = (z+0.5)*SPACE_INTERVAL;								// Make Random() repeatable based on cell index				qd.randSeed = x^y^z;								// Set up the line color -- blend between purple and green				color.b = ((unsigned short) Random()) * (1.0/65535.0);				color.r = 0.4*color.b;				color.g = 0.8*(1.0-color.b);								Q3AttributeSet_Add(gSpaceColor, kQ3AttributeTypeDiffuseColor, &color);				#if	SPACE_JUNK_IS_LINES				// Set up the endpoints				lineData.vertices[0].point.x = px + Random()*SPACE_SPREAD1;				lineData.vertices[0].point.y = py + Random()*SPACE_SPREAD1;				lineData.vertices[0].point.z = pz + Random()*SPACE_SPREAD1;								lineData.vertices[1].point.x = lineData.vertices[0].point.x + Random()*SPACE_SPREAD2;				lineData.vertices[1].point.y = lineData.vertices[0].point.y + Random()*SPACE_SPREAD2;				lineData.vertices[1].point.z = lineData.vertices[0].point.z + Random()*SPACE_SPREAD2;				// Submit the line				Q3Line_Submit(&lineData, inView);#else	// !SPACE_JUNK_IS_LINES				pointData.point.x = px + Random()*SPACE_SPREAD1;				pointData.point.y = py + Random()*SPACE_SPREAD1;				pointData.point.z = pz + Random()*SPACE_SPREAD1;				Q3Point_Submit(&pointData, inView);#endif						}		}	}}