#ifndef __NETWORKSETUP__#define __NETWORKSETUP__#ifndef __NETWORKSETUPTYPES__#include <NetworkSetupTypes.h>#endif#if PRAGMA_ONCE#pragma once#endif#ifdef __cplusplusextern "C" {#endif#if PRAGMA_IMPORT#pragma import on#endif#if PRAGMA_STRUCT_ALIGN	#pragma options align=mac68k#elif PRAGMA_STRUCT_PACKPUSH	#pragma pack(push, 2)#elif PRAGMA_STRUCT_PACK	#pragma pack(2)#endif/*********************************************************************************	Configuration Information Access API ********************************************************************************//*	-------------------------------------------------------------------------	Database access	------------------------------------------------------------------------- */EXTERN_API( OSStatus )OTCfgOpenDatabase				(CfgDatabaseRef *		dbRef);/*	OTCfgOpenDatabase()	Inputs:		none	Outputs:	CfgDatabaseRef* dbRef			Reference to opened database	Returns:	OSStatus						*** list errors ***	Opens the Configuration API for a given client. This call should be made prior to any other call.*/EXTERN_API( OSStatus )OTCfgCloseDatabase				(CfgDatabaseRef *		dbRef);/*	OTCfgCloseDatabase()	Inputs:		CfgDatabaseRef* dbRef			Reference to opened database	Outputs:	CfgDatabaseRef* dbRef			Reference to opened database is cleared	Returns:	OSStatus						*** list errors ***	Closes the Configuration API for a given client. This call should be made when the client no 	longer wants to use the Configuration API.  *//*	-------------------------------------------------------------------------	Area management	------------------------------------------------------------------------- */EXTERN_API( OSStatus )OTCfgGetAreasCount				(CfgDatabaseRef 		dbRef,								 ItemCount *			itemCount);/*	OTCfgGetAreasCount()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database	Outputs:	ItemCount* itemCount			Number of entities defined	Returns:	OSStatus						*** list errors ***	Returns the number of areas currently defined.*/EXTERN_API( OSStatus )OTCfgGetAreasList				(CfgDatabaseRef 		dbRef,								 ItemCount *			itemCount,								 CfgAreaID 				areaID[],								 Str255 				areaName[]);/*	OTCfgGetAreasList()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				ItemCount* itemCount			Number of entities requested	Outputs:	ItemCount* itemCount			Number of entities defined	Returns:	OSStatus						*** list errors ***	Returns a list of area IDs and names. On entry, count should be set to whatever OTCfgGetAreasCount 	returned.  On exit, count contains the actual number of areas found. This can be less than the 	initial count value if areas were deleted in the meantime.  The id and name parameters are stored 	in arrays that should each be able to contain count values.*/EXTERN_API( OSStatus )OTCfgGetCurrentArea				(CfgDatabaseRef 		dbRef,								 CfgAreaID *			areaID);/*	OTCfgGetCurrentArea()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database	Outputs:	CfgAreaID* areaID				ID of current area	Returns:	OSStatus						*** list errors ***	Returns the id of the current area.*/EXTERN_API( OSStatus )OTCfgSetCurrentArea				(CfgDatabaseRef 		dbRef,								 CfgAreaID 				areaID);/*	OTCfgSetCurrentArea()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgAreaID areaID				ID of area to make active	Outputs:	none	Returns:	OSStatus						*** list errors ***	Sets the current area. If the area doesn’t exist kCfgAreaNotFoundErr is returned.*/EXTERN_API( OSStatus )OTCfgCreateArea					(CfgDatabaseRef 		dbRef,								 ConstStr255Param 		areaName,								 CfgAreaID *			areaID);/*	OTCfgCreateArea()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				ConstStr255Param areaName		Name of area to create	Outputs:	CfgAreaID* areaID				ID of newly created area	Returns:	OSStatus						*** list errors ***	Creates a new area with the specified name. Then name must be unique or kCfgAreaAlreadyExistsErr 	will be returned.*/EXTERN_API( OSStatus )OTCfgDeleteArea					(CfgDatabaseRef 		dbRef,								 CfgAreaID 				areaID);/*	OTCfgDeleteArea()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgAreaID areaID				ID of area to delete	Outputs:	none	Returns:	OSStatus						*** list errors ***	Deletes the specified area. If the area doesn’t exist kCfgAreaNotFoundErr is returned.*/EXTERN_API( OSStatus )OTCfgDuplicateArea				(CfgDatabaseRef 		dbRef,								 CfgAreaID 				sourceAreaID,								 CfgAreaID 				destAreaID);/*	OTCfgDuplicateArea()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgAreaID sourceAreaID			Area to duplicate				CfgAreaID destAreaID			Area to contain duplicate	Outputs:	none	Returns:	OSStatus						*** list errors ***	Duplicates the source area content into the destination area. Both areas should exist prior to 	making this call. If either area doesn’t exist kCfgAreaNotFoundErr is returned.*/EXTERN_API( OSStatus )OTCfgSetAreaName				(CfgDatabaseRef 		dbRef,								 CfgAreaID 				areaID,								 ConstStr255Param 		areaName,								 CfgAreaID *			newAreaID);/*	OTCfgSetAreaName()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgAreaID areaID				ID of area being named				ConstStr255Param areaName			New name for area	Outputs:	CfgAreaID* newAreaID			ID of renamed area	Returns:	OSStatus						*** list errors ***	Renames the specified area. A new id is returned: it should be used from now on. If the area 	doesn’t exist kCfgAreaNotFoundErr is returned.*//*	-------------------------------------------------------------------------	Configuration Database API		Single Writer ONLY!!!	------------------------------------------------------------------------- *//*	-------------------------------------------------------------------------	Opening an area for reading	------------------------------------------------------------------------- */EXTERN_API( OSStatus )OTCfgOpenArea					(CfgDatabaseRef 		dbRef,								 CfgAreaID 				areaID);/*	OTCfgOpenArea()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgAreaID areaID				ID of area to open	Outputs:	none	Returns:	OSStatus						*** list errors ***	Opens the specified area for reading. If the area doesn’t exist kCfgAreaNotFoundErr is returned.*/EXTERN_API( OSStatus )OTCfgCloseArea					(CfgDatabaseRef 		dbRef,								 CfgAreaID 				areaID);/*	OTCfgCloseArea()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgAreaID areaID				ID of area to close	Outputs:	none	Returns:	OSStatus						*** list errors ***	Closes an area opened for reading. If the area doesn’t exist kCfgAreaNotFoundErr is returned.  	Opening an area for writing All modifications to an area should be performed as part of a 	transaction.*//*	For write access*/EXTERN_API( OSStatus )OTCfgBeginAreaModifications		(CfgDatabaseRef 		dbRef,								 CfgAreaID 				readAreaID,								 CfgAreaID *			writeAreaID);/*	OTCfgBeginAreaModifications()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgAreaID readAreaID			ID of area opened for reading	Outputs:	CfgAreaID* writeAreaID			ID of area opened for modification	Returns:	OSStatus						*** list errors ***	Opens the specified area for writing. A new area id is provided.  This area id should be used to 	enumerate, add, delete, read and write to the modified data. The original id can still be used to 	access the original unmodified data. If the area doesn’t exist kCfgAreaNotFoundErr is returned.*/EXTERN_API( OSStatus )OTCfgCommitAreaModifications	(CfgDatabaseRef 		dbRef,								 CfgAreaID 				readAreaID,								 CfgAreaID 				writeAreaID);/*	OTCfgCommitAreaModifications()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgAreaID readAreaID			ID of area opened for reading				CfgAreaID writeAreaID			ID of area opened for modification	Outputs:	none	Returns:	OSStatus						*** list errors ***	Closes an area opened for writing.  All modifications are committed and readers are informed that 	the database changed state ( kCfgStateChangedErr ). The areaID should be the id of the original 	area.  If the area doesn’t exist or the wrong id is passed, kCfgAreaNotFoundErr is returned.*/EXTERN_API( OSStatus )OTCfgAbortAreaModifications		(CfgDatabaseRef 		dbRef,								 CfgAreaID 				readAreaID);/*	OTCfgAbortAreaModifications()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgAreaID readAreaID			ID of area opened for reading	Outputs:	none	Returns:	OSStatus						*** list errors ***	Closes an area opened for writing, discarding any modification. The areaID should be the id of 	the original area. If the area doesn’t exist or the wrong id is passed kCfgAreaNotFoundErr is 	returned.*//*	Working with entities	Entities can be manipulated as soon as an area has been opened.  The same calls work both for 	areas opened for reading or for modification. In the latter case, the calls can be used on the 	original or new area id to access the original data or the modified data.*//*	For everybody	Count receives the actual number of entities*/EXTERN_API( OSStatus )OTCfgGetEntitiesCount			(CfgDatabaseRef 		dbRef,								 CfgAreaID 				areaID,								 CfgEntityClass 		entityClass,								 CfgEntityType 			entityType,								 ItemCount *			itemCount);/*	OTCfgGetEntitiesCount()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgAreaID areaID				ID of area to count				CfgEntityClass entityClass		Class of entities to count				CfgEntityType entityType		Type of entities to count	Outputs:	ItemCount* itemCount			Count of matching entities	Returns:	OSStatus						*** list errors ***	Returns the number of entities of the specified class and type in the specified area. To obtain 	all entities regardless of their class or type pass kCfgAnyEntityClass or kCfgAnyEntityType. If 	the area doesn’t exist or the wrong id is passed kCfgAreaNotFoundErr is returned.*//*	Count as input, is the number of entities to read;	count as output, receives the actual number of entities or the number you specified. */EXTERN_API( OSStatus )OTCfgGetEntitiesList			(CfgDatabaseRef 		dbRef,								 CfgAreaID 				areaID,								 CfgEntityClass 		entityClass,								 CfgEntityType 			entityType,								 ItemCount *			itemCount,								 CfgEntityRef 			entityRef[],								 CfgEntityInfo 			entityInfo[]);/*	OTCfgGetEntitiesList()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgAreaID areaID				ID of area to list				CfgEntityClass entityClass		Class of entities to list				CfgEntityType entityType		Type of entities to list				ItemCount* itemCount			Count of entities requested	Outputs:	ItemCount* itemCount			Count of entities listed	Returns:	OSStatus						*** list errors ***	Returns the list of entities of the specified class and type in the specified area. To obtain all 	entities regardless of their class or type pass kCfgAnyEntityClass or kCfgAnyEntityType. The 	count parameter should have the value obtained by CfgGetEntitiesCount.  On exit count may be less 	if some entities were deleted in the meantime. The id and info parameters should be arrays large 	enough to hold count entries. If the area doesn’t exist or the wrong id is passed 	kCfgAreaNotFoundErr is returned.  The info array contains information about each entity, 	including its class, type, name and the area of its icon:	struct CfgEntityInfo	{		CfgEntityClass		fClass;		CfgEntityType		fType;		ConstStr255Param	fName;		CfgResourceLocator	fIcon;	};*/EXTERN_API( OSStatus )OTCfgCreateEntity				(CfgDatabaseRef 		dbRef,								 CfgAreaID 				areaID,								 const CfgEntityInfo *	entityInfo,								 CfgEntityRef *			entityRef);/*	OTCfgCreateEntity()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgAreaID areaID				ID of area to contain entity				CfgEntityInfo* entityInfo		Information that defines the entity	Outputs:	CfgEntityRef* entityRef			Reference to entity created	Returns:	OSStatus						*** list errors ***	Creates a new entity with the specified class, type and name and returns an id for it. If the 	area doesn’t exist or the wrong id is passed kCfgAreaNotFoundErr is returned. If there is already 	an entity with the same name kCfgEntityAlreadyExistsErr is returned.*/EXTERN_API( OSStatus )OTCfgDeleteEntity				(CfgDatabaseRef 		dbRef,								 const CfgEntityRef *	entityRef);/*	OTCfgDeleteEntity()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgEntityRef* entityRef			Reference to entity to delete	Outputs:	none	Returns:	OSStatus						*** list errors ***	Deletes the specified entity. If there is no entity with this id kCfgEntityNotfoundErr is returned*/EXTERN_API( OSStatus )OTCfgDuplicateEntity			(CfgDatabaseRef 		dbRef,								 const CfgEntityRef *	entityRef,								 const CfgEntityRef *	newEntityRef);/*	OTCfgDuplicateEntity()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgEntityRef* entityRef			Reference to entity to duplicate	Outputs:	CfgEntityRef* newEntityRef		Reference to duplicate entity	Returns:	OSStatus						*** list errors ***	Duplicates the specified entity. Both entities should exit. If any entity doesn’t exist 	kCfgEntityNotFoundErr is returned.*/EXTERN_API( OSStatus )OTCfgSetEntityName				(CfgDatabaseRef 		dbRef,								 const CfgEntityRef *	entityRef,								 ConstStr255Param 		entityName,								 CfgEntityRef *			newEntityRef);/*	OTCfgSetEntityName()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgEntityRef* entityRef			Reference to entity to duplicate				ConstStr255Param entityName		New name for entity	Outputs:	CfgEntityRef* newEntityRef		Reference to renamed entity	Returns:	OSStatus						*** list errors ***	Renames the specified entity. If the entity doesn’t exist kCfgEntityNotfoundErr is returned. If 	there is already an entity with that name kCfgEntityAlreadyExistsErr is returned.*/EXTERN_API( void )OTCfgGetEntityArea				(const CfgEntityRef *	entityRef,								 CfgAreaID *			areaID);/*	OTCfgGetEntityArea()	Inputs:		CfgEntityRef *entityRef			Reference to an entity	Outputs:	CfgAreaID *areaID				ID of area that contains the entity	Returns:	none	Returns the area ID associated with the specified entity reference.*/EXTERN_API( void )OTCfgGetEntityName				(const CfgEntityRef *	entityRef,								 Str255 				entityName);/*	OTCfgGetEntityName()	Inputs:		CfgEntityRef *entityRef			Reference to an entity	Outputs:	Str255 entityName				Name of the entity	Returns:	none	Returns the entity name associated with the specified entity reference.*/EXTERN_API( void )OTCfgChangeEntityArea			(CfgEntityRef *			entityRef,								 CfgAreaID 				newAreaID);/*	OTCfgChangeEntityArea()	Inputs:		CfgEntityRef *entityRef			Reference to an entity				CfgAreaID newAreaID				ID of area to contain moved entity	Outputs:	none	Returns:	none	Changes the area ID associated with the specified entity reference. This effectively moves the 	entity to a different area.*//*	-------------------------------------------------------------------------	These API calls are for the protocol developers to compare the IDs.	------------------------------------------------------------------------- *//*	-------------------------------------------------------------------------	For OTCfgIsSameEntityRef	------------------------------------------------------------------------- */enum {	kOTCfgIgnoreArea			= true,	kOTCfgDontIgnoreArea		= false};EXTERN_API( Boolean )OTCfgIsSameEntityRef			(const CfgEntityRef *	entityRef1,								 const CfgEntityRef *	entityRef2,								 Boolean 				ignoreArea);/*	OTCfgIsSameEntityRef()	Inputs:		CfgEntityRef* entityRef1		Reference to an entity				CfgEntityRef* entityRef2		Reference to another entity				Boolean ignoreArea				If true, ignore the area ID	Outputs:	none	Returns:	Boolean							If true, entity references match	Compare two entity references. If ignoreArea is true, and the two entity names are the same, then return 	true. If ignoreArea is false, then the area IDs must be the same, as well as the entity names 	must be the same, then can return true.*/EXTERN_API( Boolean )OTCfgIsSameAreaID				(CfgAreaID 				areaID1,								 CfgAreaID 				areaID2);/*	OTCfgIsSameAreaID()	Inputs:		CfgAreaID areaID1				ID of an area				CfgAreaID areaID2				ID of another area	Outputs:	none	Returns:	Boolean							If true, area IDs match	Compare two area IDs. Return true for matching area IDs, and return false for the different area IDs.*//*	-------------------------------------------------------------------------	Dealing with individual preferences	------------------------------------------------------------------------- *//*	-------------------------------------------------------------------------	Open Preferences	if writer = true, GetPrefs and SetPrefs are allowed, else only GetPrefs is allowed.	------------------------------------------------------------------------- */EXTERN_API( OSStatus )OTCfgOpenPrefs					(CfgDatabaseRef 		dbRef,								 const CfgEntityRef *	entityRef,								 Boolean 				writer,								 CfgEntityAccessID *	accessID);/*	OTCfgOpenPrefs()	Inputs:		CfgDatabaseRef dbRef			Reference to opened database				CfgEntityRef* entityRef			Reference to an entity				Boolean writer				If true, open for write	Outputs:	CfgEntityAccessID* accessID		ID for entity access	Returns:	OSStatus						*** list errors ***	Open the specified entity and return the CfgEntityAccessID for the following access of the 	content of the entity. If writer is true, CfgGetPrefs and CfgSetPrefs are allowed, otherwise only 	CfgGetPrefs is allowed.*/EXTERN_API( OSStatus )OTCfgClosePrefs					(CfgEntityAccessID 		accessID);/*	OTCfgClosePrefs()	Inputs:		CfgEntityAccessID* accessID		ID for entity to close	Outputs:	none	Returns:	OSStatus						*** list errors ***	Close the entity with the specified CfgEntityAccessID.*//*	-------------------------------------------------------------------------	Get/Set Preferences	Accessing the content of an entity	These API calls are for the protocol developers. It supports multiple records per entity. Each 	record is identified by the prefsType and the size of the record. The protocol stack will provide 	the STRUCT to view the content of each record.	------------------------------------------------------------------------- */EXTERN_API( OSStatus )OTCfgSetPrefs					(CfgEntityAccessID 		accessID,								 OSType 				prefsType,								 const void *			data,								 ByteCount 				length);/*	OTCfgSetPrefs()	Inputs:		CfgEntityAccessID* accessID		ID of entity to access				OSType prefsType				Record type to set				void* data						Address of data				ByteCount length				Number of bytes of data	Outputs:	none	Returns:	OSStatus						*** list errors ***	Write the data to the specified record. The record is identified by the prefsType. If the entity 	is not opened for the writer, an error code is returned.*/EXTERN_API( OSStatus )OTCfgGetPrefs					(CfgEntityAccessID 		accessID,								 OSType 				prefsType,								 void *					data,								 ByteCount 				length);/*	OTCfgGetPrefs()	Inputs:		CfgEntityAccessID* accessID		ID of entity to access				OSType prefsType				Record type to get				void* data						Address for data				ByteCount length				Number of bytes of data requested	Outputs:	none	Returns:	OSStatus						*** list errors ***	Read the data from the specified record to the passed buffer. The record is identified by the 	prefsType. If the passed buffer is too small, kCfgDataTruncatedErr is returned, but will copy as 	many data as possible to the buffer.*/EXTERN_API( OSStatus )OTCfgGetPrefsSize				(CfgEntityAccessID 		accessID,								 OSType 				prefsType,								 ByteCount *			length);/*	OTCfgGetPrefsSize()	Inputs:		CfgEntityAccessID* accessID		ID of entity to access				OSType prefsType				Record type to get				ByteCount length				Number of bytes of data available	Outputs:	none	Returns:	OSStatus						*** list errors ***	Returns the length, in bytes, of the specified record. The record is identified by the prefsType.*//*	-------------------------------------------------------------------------	Get table of contents for prefs	------------------------------------------------------------------------- */EXTERN_API( OSStatus )OTCfgGetPrefsTOCCount			(CfgEntityAccessID 		accessID,								 ItemCount *			itemCount);/*	OTCfgGetPrefsTOCCount()	Inputs:		CfgEntityAccessID* accessID		ID of entity to access	Outputs:	ItemCount* itemCount			Number of entries available	Returns:	OSStatus						*** list errors ***	Get the count of all the record headers in the entity. Return the number of records in the count. */EXTERN_API( OSStatus )OTCfgGetPrefsTOC				(CfgEntityAccessID 		accessID,								 ItemCount *			itemCount,								 CfgPrefsHeader 		PrefsTOC[]);/*	OTCfgGetPrefsTOC()	Inputs:		CfgEntityAccessID* accessID		ID of entity to access				ItemCount* itemCount			Number of entries requested	Outputs:	ItemCount* itemCount			Number of entries available				CfgPrefsHeader PrefsTOC[]		Table of entries	Returns:	OSStatus						*** list errors ***	Get the list of all the record headers in the entity. Return the number of records in the count. 	If the PrefsTOC is specified, it has to be big enough to hold all the record headers. If the 	PrefsTOC is null, only the count is returned.*/EXTERN_API( Handle )OTCfgGetDefault					(ResType 				entityType,								 ResType 				entityClass,								 ResType 				recordType);#if PRAGMA_STRUCT_ALIGN	#pragma options align=reset#elif PRAGMA_STRUCT_PACKPUSH	#pragma pack(pop)#elif PRAGMA_STRUCT_PACK	#pragma pack()#endif#ifdef PRAGMA_IMPORT_OFF#pragma import off#elif PRAGMA_IMPORT#pragma import reset#endif#ifdef __cplusplus}#endif#endif /* __NETWORKSETUP__ */