<HTML>		<HEAD>		<TITLE>					</TITLE>		</HEAD>	<body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../../webobjects.html" target="_top">WebObjects 4.5 Documentation</a> <b>&gt;</b>EOControl Reference</font><br><br><!--end of path --><a href="../../EOControlTOC.html"><img src="../../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> <h1><FONT COLOR="#000066"><a name="//apple_ref/occ/cl/EOQualifier">EOQualifier</a></FONT></h1><br><br><a name = "BCCBFIFH"><h2>Creating a Qualifier</h2></a><p>As described above, there are several EOQualifier subclasses,each of which represents a different semantic. However, in mostcases you simply create a qualifier using the EOQualifier class method <b>qualifierWithQualifierFormat</b>:,as follows:</p><blockquote><pre>EOQualifier *qual = [EOQualifier qualifierWithQualifierFormat:@"lastName = 'Smith'"];</pre></blockquote><br><p>The qualifier or group of qualifiers that result from sucha statement is based on the contents of the format string you provide.For example, giving the format string "lastName = 'Smith'"as an argument to  <a frame= "conv" href="../../Classes/EOQualifier.html#//apple_ref/occ/clm/EOQualifier/qualifierWithQualifierFormat:">qualifierWithQualifierFormat:</a> returnsan EOKeyValueQualifier object. But you don't normally need tobe concerned with this level of detail.</p><p>The format strings you use to create a qualifier can be compoundlogical expressions, such as "firstName = 'Fred' AND age &lt;20". When you create a qualifier, compound logical expressionsare translated into a tree of EOQualifier nodes. Logical operatorssuch as AND and OR become EOAndQualifiers and EOOrQualifiers, respectively.These qualifiers conjoin (AND) or disjoin (OR) a group of sub-qualifiers.This is illustrated in  <a frame= "conv" href="#BBIBFCEI">Figure 0-4</a>, in which the format string "salary &gt; 300 AND firstName= 'Angela' AND manager.name = 'Fred'" has been translatedinto a tree of qualifiers.</p><center><a name = "BBIBFCEI"><p><b>EOQualifier Treefor 'salary &gt; 300 AND firstName = "Angela" AND manager.name= "Fred"'</b></p></a><img src = "Art/QualiferTree.GIF" alt = "[image: Art/QualiferTree.GIF]"></center><p>The <b>qualifierWithQualifierFormat:</b> methodcan't be used to create an instance of EOSQLQualifier. This isbecause EOSQLQualifier uses a non-structured syntax. It also requiresan entity. To create an instance of EOSQLQualifier, you'd usea statement such as the following:</p><blockquote><pre>myQual = [[EOSQLQualifier alloc] initWithEntity:myEntity format:myFormatString];</pre></blockquote><br><br><a name = "BBICFCJF"><h2>Constructing Format Strings</h2></a><p>As described above, you typically create a qualifier froma format string by using  <a frame= "conv" href="../../Classes/EOQualifier.html#//apple_ref/occ/clm/EOQualifier/qualifierWithQualifierFormat:">qualifierWithQualifierFormat:</a>.This method takes as an argument a format string somewhat like that usedwith the standard C <b>printf()</b> function.The format string can embed strings, numbers, and other objectsusing the conversion specifications listed below. This allows qualifiersto be built dynamically. The following table lists the conversionspecifications you can use in a format string and their correspondingdata types.</p><br><table border = "1"><tr><td scope="row"><b>ConversionSpecification</b></td><td><b>Expected Value or Result</b></td></tr><tr><td scope="row">%s</td><td>Aconstant C string (<b>const char *</b>).</td></tr><tr><td scope="row">%d</td><td>An <b>int</b>.</td></tr><tr><td scope="row">%f</td><td>A <b>float</b> or <b>double</b>.</td></tr><tr><td scope="row">%@</td><td>An <b>id</b> argument.The behavior of this conversion specification depends on its position.It can either be an object whose description method returns a key(in other words, an NSString), or a value such as an NSString, NSNumber, NSCalendarDate,and so on.</td></tr><tr><td scope="row">%%</td><td>Resultsin a literal <b>%</b> character.</td></tr></table><br><p>If you use an unrecognized character in a conversion specification(for example, %x), an NSInvalidArgumentException is raised.</p><p>For example, suppose you have an Employee entity with theproperties <b>empID</b>, <b>firstName</b>, <b>lastName</b>, <b>salary</b>,and <b>department</b> (representing a to-one relationshipto the employee's department), and a Department entity with propertiesdeptID, and name. You could construct simple qualifier strings like thefollowing:</p><blockquote><pre>lastName = 'Smith'salary &gt; 2500department.name = 'Personnel'</pre></blockquote><br><p>The following examples build qualifiers similar to the qualifierstrings described above, but take the specific values from already-fetchedenterprise objects:</p><blockquote><pre>myQualifier = [EOQualifier qualifierWithQualifierFormat:@"%@ = %@",     @"lastName", [anEmployee lastName]];myQualifier = [EOQualifier qualifierWithQualifierFormat:@"%@ &gt; %f",     @"salary", [anEmployee salary]];myQualifier = [EOQualifier qualifierWithQualifierFormat:@"%@ = %@",    @"department.name", [aDept name]];</pre></blockquote><br><p>The enterprise objects here implement methods for directlyaccessing the given attributes: <b>lastName</b> and <b>salary</b> forEmployee objects, and <b>name</b> for Departmentobjects. Note that unlike a string literal, the %@ conversion specificationis never surrounded by single quotes:</p><blockquote><pre>// For a literal string value such as Smith, you use single quotes.[EOQualifier qualifierWithQualifierFormat:@"lastName = 'Smith'", null)];// For the conversion specification %@, you don't use quotes[EOQualifier qualifierWithQualifierFormat:@"lastName = %@", @"Jones"];</pre></blockquote><br><p>Typically format strings include only two data types: stringsand numbers. Single-quoted or double-quoted strings are NSStrings,non-quoted numbers are NSNumbers, and non-quoted strings are keys.You can get around this limitation by performing explicit casting,as described in the section  <a frame= "conv" href="#BBIDFEAF">"Using Different Data Types in Format Strings" on page 267</a>.</p><p>The operators you can use in constructing qualifiers are =, ==, !=, &lt;, &gt;, &lt;=, &gt;=, "like", and "caseInsensitiveLike".The <b>like</b> and <b>caseInsensitiveLike</b> operatorscan be used with wildcards to perform pattern matching, as describedin  <a frame= "conv" href="#BBIBIBAB">"Using Wildcards and the like Operator" on page 266</a>.</p><br><a name = "BCCDHDCI"><h2>Checking for NULL Values</h2></a><p>To construct a qualifier that fetches rows matching NULL,use either of the approaches shown in the following example:</p><blockquote><pre>[EOQualifier qualifierWithQualifierFormat:@"bonus = nil"];[EOQualifier qualifierWithQualifierFormat:@"bonus = %@", [EONull null]];[EOQualifier qualifierWithQualifierFormat:@"bonus = %@", nil];</pre></blockquote><br><br><a name = "BBIBIBAB"><h2>Using Wildcards and thelike Operator</h2></a><p>When you use the <b>like</b> or <b>caseInsensitiveLike</b> operatorin a qualifier expression, you can use the wildcard characters *and ? to perform pattern matching, for example:</p><blockquote><pre>@"lastName like 'Jo*'"</pre></blockquote><br><p>matches Jones, Johnson, Jolsen, Josephs, and so on.</p><p>The ? character just matches a single character, for example:</p><blockquote><pre>@"lastName like 'Jone?'"</pre></blockquote><br><p>matches Jones.</p><p>The asterisk character (*) is only interpreted as a wildcardin expressions that use the <b>like</b> or <b>caseInsensitiveLike</b> operator.For example, in the following statement, the character * is treatedas a literal value, not as a wildcard:</p><blockquote><pre>@"lastName = 'Jo*'"     //  The * character doesn't act as a wildcard in this statement.</pre></blockquote><br><br><a name = "BCCDDGCJ"><h2>Using Selectors in QualifierExpressions</h2></a><p>The format strings you use to initialize a qualifier can include selectors.The parser recognizes an unquoted string followed by a colon (suchas <b>myMethod:</b>) as a selector. For example:</p><blockquote><pre>point1 isInside: areafirstName isAnagramOfString: "Computer"</pre></blockquote><br><p>Selectors in a qualifier are parsed and applied only in memory;that is, they can't be used in to qualify fetches in a database.</p><br><a name = "BBIDFEAF"><h2>Using Different Data Typesin Format Strings</h2></a><p>As stated in the section  <a frame= "conv" href="#BBICFCJF">"Constructing Format Strings" on page 264</a>,format strings normally include only two data types: strings andnumbers. To get around this limitation, you can perform explicit casting. </p><p>For example, NSCalendarDate and NSDecimalNumber are two classesthat are likely to be used in qualifiers. You can construct formatstrings for objects of these classes as follows:</p><blockquote><pre>hireDate = (NSCalendarDate)'1990-03-16 00:00:00 +0000'salary = (NSDecimalNumber)'15000.02'</pre></blockquote><br><p>When you use this approach, qualifiers are constructed bylooking up the class and invoking <code>[[class alloc]initWithString:stringValue]</code>. Therefore, thistechnique only works for classes that implement <b>initWithString:</b>. </p><p>Note that to construct a date qualifier using a format string,you must use the default NSCalendarDate format, which is %Y-%m-%d%H:%M:%S %z-for example:</p><blockquote><pre>EOQualifier *qual = [EOQualifier qualifierWithQualifierFormat:    @"dateReleased &lt; (NSCalendarDate)'1990-01-26 00:00:00 +0000'"];</pre></blockquote><br><p>This limitation doesn't apply when you're working withNSCalendarDate objects-you can just construct a qualifier in theusual way:</p><blockquote><pre> EOQualifier *qual = [EOQualifier qualifierWithQualifierFormat:    @"dateReleased &gt; %@", [NSCalendarDate calendarDate]];</pre></blockquote><br><br><a name = "BCCBHHGC"><h2>Using EOQualifier's Subclasses</h2></a><p>You rarely need to explicitly create an instance of EOAndQualifier,EOOrQualifier, or EONotQualifier. However, you may want to createinstances of EOKeyValueQualifier and EOKeyComparisionQualifier.The primary advantage of this is that it lets you exercise morecontrol over how the qualifier is constructed.</p><p>If you want to explicitly create a qualifier subclass, youcan do it using code such as the following excerpt, which uses EOKeyValueQualifierto select all objects whose "isOut" key is equal to <code>YES</code>.In the excerpt, the qualifier is used to filter an in-memory array.</p><blockquote><pre>// Create the qualifierEOQualifier *qual = [[EOKeyValueQualifier alloc]    initWithKey:@"isOut"    operatorSelector:EOQualifierOperatorEqual    value:[NSNumber numberWithBool:YES]];// Filter an array and return it   return [[self allRentals] filteredArrayUsingQualifier:qual];</pre></blockquote><br><p> <a frame= "conv" href="../../Classes/NSArrayAdditions.html#//apple_ref/occ/instm/NSArray Additions/filteredArrayUsingQualifier:">filteredArrayUsingQualifier:</a> isa method that Enterprise Objects Framework adds to NSArray. It's usedfor filtering in-memory arrays.</p><br><a name = "BCCDDGCH"><h2>Creating Subclasses</h2></a><p>EOQualifier offers extensibility across two dimensions: newclasses can be added to extend qualifier semantics, and categoriescan be added to extend functionality (for example, to provide in-memory evaluation).</p><p>Subclasses used to evaluate objects in memory must implementthe EOQualifierEvaluation protocol. Subclasses used to generateSQL queries must conform to the EOQualifierSQLGeneration protocol.</p><br><a href="../../EOControlTOC.html"><img src="../../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> </BODY></HTML>