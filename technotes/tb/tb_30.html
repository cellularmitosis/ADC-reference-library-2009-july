<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><meta name="keywords" content="ZoomWindow"><meta name="Description" content="Technical Note TB30: This Technical Note provides some commentaryabout ways to use the ZoomWindow routine."><title>Technical Note TB30: _ZoomWindow</title>                                       <meta name="categories" content="Human Interface Toolbox"><meta name="week-posted" content="May 26, 1986 - Jun 6, 1986"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002781" title="_ZoomWindow"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxUserExperience-date.html">User Experience</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/UserExperience/index.html" target="_blank">Reference Library > User Experience</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TB30</div>
<div id="pageheadsub">_ZoomWindow</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Basics</A><BR><BR><A HREF="#Section2">For the More Adventurous (or Seeing Double)</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note contains some hints about using <code>_ZoomWindow</code>.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Jun 01 1986]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name="Section1"></a><h2>Basics</h2><p><code>_ZoomWindow</code> allows a window to be toggled between two states (where"state" means size and location):  a default state and a user-selectable state.The default state stays the same unless the application changes it, while theuser-selectable state is altered when the user changes the size or location ofa zoomable window.  The code to handle zoomable windows in a main event loopwould look something like the examples which follow.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR><code>_ZoomWindow</code> assumes that the window that you are zoomingis the current <code>GrafPort</code>.  If <code>thePort</code> is not set to the windowthat is being zoomed, an address error is generated.</P></TD></TR></TABLE></CENTER><BR>   <h3>MPW Pascal</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>       CASE myEvent.what OF         mouseDown: BEGIN           partCode:= FindWindow(myEvent.where, whichWindow);             CASE partCode OF               inZoomIn, InZoomOut:                 IF TrackBox(whichWindow, myEvent.where, partCode) THEN                   BEGIN                     GetPort(oldPort);                     SetPort(whichWindow);                     EraseRect(whichWindow^.portRect);                     ZoomWindow(whichWindow, partCode, TRUE);                     SetPort(oldPort);                   END; {IF}               ...{and so on}             END; {CASE}           END; {mouseDown}         ...{and so on}</pre>	</TD></TR></TABLE></CENTER><h3>MPW C</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>       switch (myEvent.what) {         case mouseDown:           partCode = FindWindow(myEvent.where, &amp;whichWindow);           switch (partCode) {             case inZoomIn:             case inZoomOut:               if (TrackBox(whichWindow, myEvent.where, partCode)) {                 GetPort(&amp;oldPort);                 SetPort(whichWindow);                 EraseRect(whichWindow-&gt;portRect);                 ZoomWindow(whichWindow, partCode, true);                 SetPort(oldPort);                 } /* if */               break;             ... /* and so on */           } /* switch */         ... /* and so on */</pre>	</TD></TR></TABLE></CENTER><p>If a window is zoomable, that is, if it has a window definition <code>ID = 8</code>(using the standard <code>'WDEF'</code>), <code>WindowRecord.dataHandle</code> pointsto a structure that consists of two rectangles.  The user-selectable state isstored in the first rectangle, and the default state is stored in the secondrectangle.  An application can modify either of these states, though modifyingthe user-selectable state might present a surprise to the user when the windowis zoomed from the default state.  An application should also be careful to notchange either rectangle so that the title bar of the window is hidden by themenu bar.</p><p>Before modifying these rectangles, an application must make sure that<code>DataHandle</code> is not <code>NIL</code>.  If it is <code>NIL</code> for a windowwith window definition <code>ID = 8</code>, that means that the program is notexecuting on a system or machine that supports zooming windows.</p><p>One need not be concerned about the use of a window with window definition<code>ID = 8</code> making an application machine-specific--if the system ormachine that the application is running on doesn't support zooming windows,<code>_FindWindow</code> never returns <code>inZoomIn</code> or <code>inZoomOut</code>, soneither <code>_TrackBox</code> nor _<code>ZoomWindow</code> are called.</p><p>If <code>DataHandle</code> is not <code>NIL</code>, an application can set thecoordinates of either rectangle.  For example, the Finder sets the secondrectangle (default state) so that a zoomed-out window does not cover the diskand trash icons.</p><P><A HREF="#top">Back to top</A></p><a name="Section2"></a><h2>For the More Adventurous (or Seeing Double)</h2><p>Developers should long have been aware that they should make no assumptionsabout the screen size and use <code>screenBits.bounds</code> to avoid limitingutilization of large video displays.  Modular Macintoshes and Color QuickDrawsupport multiple display devices, which invalidates the use of<code>screenBits.bounds</code> unless the boundary of only the primary display (theone with the menu bar) is desired.  When dragging and growing windows in a<b>multi-screen environment</b>, developers are now urged to use the boundingrectangle of the <code>GrayRgn</code>.  In most cases, this is not a majormodification and does not add a significant amount of code.  Simply define avariable.</p><p>and use this in place of <code>screenBits.bounds</code>.  When zooming a documentwindow, however, additional work is required to implement a window-zoomingstrategy which fully conforms with Apple's Human Interface Guidelines.</p><p>One difficulty is that when a new window is created with <code>_NewWindow</code> or<code>_GetNewWindow</code>, its default <code>stdState</code> rectangle (the rectangledetermining the size and position of the zoomed window) is set by the WindowManager to be the gray region of the main display device inset by three pixelson each side.  If a window has been moved to reflect a position on a secondarydisplay, that window still zooms onto the main device, requiring the user topan across the desktop to follow the window.  The preferred behavior is to zoomthe window onto the device containing the <b>largest portion</b> of theunzoomed window.  This is a perfect example of a case where it is necessary forthe application to modify the default state rectangle before zooming.</p><p><code>DoWZoom</code> is a Pascal procedure which implements this functionality.  It isa good example of how to manipulate both a <code>WStateData</code> record and theColor QuickDraw device list.  On machines without Color QuickDraw (e.g.,Macintosh Plus, Macintosh SE, Macintosh Portable) the <code>stdState</code>rectangle is left unmodified and the procedure reduces to five instructions,just like it is illustrated under "Basics."  If Color QuickDraw is present, asequence of calculations determines which display device contains most of thewindow prior to zooming.  That device is considered dominant and is the deviceonto which the window is zoomed.  A new <code>stdState</code> rectangle is computedbased on the <code>gdRect</code> of the dominant <code>GDevice</code>.  Allowances aremade for the window's title bar, the menu bar if necessary, and for thestandard three-pixel margin.  (Please note that <code>DoWZoom</code> only mimicsthe behavior of the default <code>_ZoomWindow</code> trap as if it were implementedto support multiple displays.  It does not account for the "natural size" of awindow for a particular purpose.  See Human Interface Note #7, Who's ZoomingWhom?, for details on what constitutes the natural size of a window.)  It isnot necessary to set <code>stdState</code> prior to calling <code>_ZoomWindow</code>when zooming back to <code>userState</code>, so the extra code is not executed inthis case.</p><p><code>DoWZoom</code> is too complex to execute within the main event loop as shown in"Basics," but if an application is already using a similar scheme, it cansimply add the <code>DoWZoom</code> procedure and replace the conditional block ofcode following</p><p>with</p><p>Happy Zooming.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>PROCEDURE DoWZoom (theWindow: WindowPtr; zoomDir: INTEGER);VAR  windRect, theSect, zoomRect : Rect;  nthDevice, dominantGDevice : GDHandle;  sectArea, greatestArea : LONGINT;  bias : INTEGER;  sectFlag : BOOLEAN;  savePort : GrafPtr;BEGIN  { theEvent is a global EventRecord from the main event loop }  IF TrackBox(theWindow,theEvent.where,zoomDir) THEN    BEGIN      GetPort(savePort);      SetPort(theWindow);      EraseRect(theWindow^.portRect);    {recommended for cosmetic reasons}      { If there is the possibility of multiple gDevices, then we  }      { must check them to make sure we are zooming onto the right }      { display device when zooming out. }      { sysConfig is a global SysEnvRec set up during initialization  }      IF (zoomDir = inZoomOut) AND sysConfig.hasColorQD THEN        BEGIN          { window's portRect must be converted to global coordinates }          windRect := theWindow^.portRect;          LocalToGlobal(windRect.topLeft);          LocalToGlobal(windRect.botRight);          { must calculate height of window's title bar }          bias :=   windRect.top - 1              -  WindowPeek(theWindow)^.strucRgn^^.rgnBBox.top;          windRect.top := windRect.top - bias; {Thanks, Wayne!}          nthDevice := GetDeviceList;          greatestArea := 0;          { This loop checks the window against all the gdRects in the   }          { gDevice list and remembers which gdRect contains the largest }          { portion of the window being zoomed. }          WHILE nthDevice &lt;&gt; NIL DO            IF TestDeviceAttribute(nthDevice,screenDevice) THEN              IF TestDeviceAttribute(nthDevice,screenActive) THEN                BEGIN                  sectFlag := SectRect(windRect,nthDevice^^.gdRect,theSect);                  WITH theSect DO                    sectArea := LONGINT(right - left) * (bottom - top);                  IF sectArea &gt; greatestArea THEN                    BEGIN                      greatestArea := sectArea;                      dominantGDevice := nthDevice;                    END;                  nthDevice := GetNextDevice(nthDevice);                END; {of WHILE}          { We must create a zoom rectangle manually in this case. }          { account for menu bar height as well, if on main device }          IF dominantGDevice = GetMainDevice THEN            bias := bias + GetMBarHeight;          WITH dominantGDevice^^.gdRect DO            SetRect(zoomRect,left+3,top+bias+3,right-3,bottom-3);          { Set up the WStateData record for this window. }          WStateDataHandle(WindowPeek(theWindow)^.dataHandle)^^.stdState := zoomRect;        END; {of Color QuickDraw conditional stuff}      ZoomWindow(theWindow,zoomDir,TRUE);      SetPort(savePort);    END;</pre>	</TD></TR></TABLE></CENTER><p>In an attempt to avoid declaring additional variables, the original version ofthis document was flawed.  In addition, the assignment statement responsiblefor setting the <code>stdState</code> rectangle is relatively complex and involvestwo type-casts.  The following may look like C, but it really is Pascal.  Trustme.</p><p>It could be expanded into a more readable form such as:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>       VAR          theWRec : WindowPeek;          zbRec   : WStateDataHandle;       theWRec := WindowPeek(theWindow);       zbRec := WStateDataHandle(theWRec^.dataHandle);</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></p><a name = "References"></a><h2>References</h2><P><i>Inside Macintosh</i>, Volume IV, The Window Manager (pp. 49-52)</p><P><i>Inside Macintosh</i>, Volume V, Graphics Devices (p. 124), The WindowManager (p. 210)</p><P>Human Interface Note #7, Who's Zooming Whom?</p>         <a name="Downloads"></a>       <P><A HREF="#top">Back to top</A></p><h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (48K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tb_30.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tb/tb_30.html%3Fid%3DDTS10002781-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tb/tb_30.html%3Fid%3DDTS10002781-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tb/tb_30.html%3Fid%3DDTS10002781-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>