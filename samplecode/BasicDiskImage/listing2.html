<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>BasicDiskImage - /MoreIsBetterBits/MoreDisks.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">BasicDiskImage</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/idxMassStorageDevices-date.html" target="_blank">Hardware & Drivers > Storage</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">BasicDiskImage</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MoreIsBetterBits/MoreDisks.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BasicDiskImage.c</option>
<option value="listing2.html">/MoreIsBetterBits/MoreDisks.c</option>
<option value="listing3.html">/MoreIsBetterBits/MoreDisks.h</option>
<option value="listing4.html">/MoreIsBetterBits/MoreInterfaceLib.c</option>
<option value="listing5.html">/MoreIsBetterBits/MoreInterfaceLib.h</option>
<option value="listing6.html">/MoreIsBetterBits/MoreMemory.c</option>
<option value="listing7.html">/MoreIsBetterBits/MoreMemory.h</option>
<option value="listing8.html">/MoreIsBetterBits/MoreSetup.h</option>
<option value="listing9.html">/MoreIsBetterBits/RemoteAccessInterface.h</option>
<option value="listing10.html">/MoreIsBetterBits/TradDriverLoaderLib.c</option>
<option value="listing11.html">/MoreIsBetterBits/TradDriverLoaderLib.h</option>
<option value="listing12.html">/ReadMe.html</option></select>
				</p>
				</form>
				<p><strong><a href="BasicDiskImage.zip">Download Sample</a></strong> (&#147;BasicDiskImage.zip&#148;, 51.2K)<BR>
<strong><a href="BasicDiskImage.dmg">Download Sample</a></strong> (&#147;BasicDiskImage.dmg&#148;, 111.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    MoreDisks.c  Contains:  General disk driver utility routines.  Written by:  Quinn  Copyright:  Copyright &copy; 1999 by Apple Computer, Inc., all rights reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):         &lt;2&gt;      7/5/99    Quinn   Added MoreIsDriveCDROM.  Fixed bug in MoreGetDriveRefNum where                                    it was calling MoreUTFindDrive rather than MoreUTFindDriveQ, and                                    hence failing on disks controlled by foreign file systems.         &lt;1&gt;     16/3/99    Quinn   First checked in.*//////////////////////////////////////////////////////////////////// MoreIsBetter Setup#include &quot;MoreSetup.h&quot;// Mac OS Interfaces#include &lt;Devices.h&gt;#include &lt;DriverGestalt.h&gt;#include &lt;Gestalt.h&gt;#include &lt;FSM.h&gt;#include &lt;Disks.h&gt;#include &lt;StringCompare.h&gt;// MIB Prototypes#include &quot;TradDriverLoaderLib.h&quot;#include &quot;MoreInterfaceLib.h&quot;#include &quot;MoreMemory.h&quot;// Our Prototypes#include &quot;MoreDisks.h&quot;/////////////////////////////////////////////////////////////////#pragma mark ----- Basic Disk Driver Utilities -----extern pascal DriveFlagsPtr MoreGetDriveFlags(DrvQElPtr drvQEl)  // See comment in interface part.{  MoreAssertQ(drvQEl != nil);  return ((DriveFlagsPtr) drvQEl) - 1;}extern pascal OSErr MoreUTFindDriveQ(SInt16 drive, DrvQElPtr *foundDrvQEl)  // See comment in interface part.{  OSErr err;  UInt32 fsmVers;  MoreAssertQ(drive &gt; 0);  MoreAssertQ(foundDrvQEl != nil);    // Check to see whether we have a useful version of FSM.  Versions of FSM  // prior to 1.2 do not support the documented FSM API, so we just treat  // them as if FSM wasn't installed.    if ((Gestalt(gestaltFSMVersion, (SInt32 *) &amp;fsmVers) == noErr) &amp;&amp; (fsmVers &gt;= 0x0120)) {    // We have FSM, let's call its version of UTFindDrive,    // and handle the weirdo error we get for non-HFS disks.    err = MoreUTFindDrive(drive, foundDrvQEl);    if (err == extFSErr) {      err = noErr;    }  } else {    DrvQElPtr thisDrv;      // No FSM, let's go poking around in low memory )-:        *foundDrvQEl = nil;    thisDrv = (DrvQElPtr) GetDrvQHdr()-&gt;qHead;    while (thisDrv != nil &amp;&amp; *foundDrvQEl == nil) {      if (thisDrv-&gt;dQDrive == drive) {        *foundDrvQEl = thisDrv;      } else {        thisDrv = (DrvQElPtr) thisDrv-&gt;qLink;      }    }    if (*foundDrvQEl == nil) {      err = nsDrvErr;    } else {      err = noErr;    }  }    return err;}extern pascal DrvQElPtr MoreGetIndDrive(SInt16 index)  // See comment in interface part.{  DrvQElPtr thisDrv;  SInt16    thisDrvIndex;  MoreAssertQ(index &gt; 0);    thisDrvIndex = 1;  thisDrv = (DrvQElPtr) GetDrvQHdr()-&gt;qHead;  while (thisDrv != nil &amp;&amp; thisDrvIndex != index) {    thisDrvIndex += 1;    thisDrv = (DrvQElPtr) thisDrv-&gt;qLink;  }  return thisDrv;}extern pascal SInt16 MoreFindFreeDriveNumber(SInt16 firstDrive)  // See comment in interface part.{  SInt16 candidate;  DrvQElPtr junkDrvQElPtr;    MoreAssertQ(firstDrive &gt;= 5);    candidate = firstDrive;  while ( MoreUTFindDriveQ(candidate, &amp;junkDrvQElPtr) == noErr ) {    candidate += 1;  }    // This post condition checks that we didn't wrap  // around to a negative drive number.  MoreAssertQ(candidate &gt;= 5);  return candidate;}extern pascal OSErr MoreRemoveDrive(DrvQElPtr drvQEl)  // See comment in interface part.{  OSStatus err;    if ( MoreVolumeMountedOnDrive(drvQEl-&gt;dQDrive, false) == 0 ) {    err = Dequeue( (QElemPtr) drvQEl, GetDrvQHdr());  } else {    err = volOnLinErr;  }  return err;}extern pascal DriverRefNum MoreGetDriveRefNum(SInt16 drive)  // See comment in interface part.{  DrvQElPtr foundDrvQEl;  MoreAssertQ(drive &gt; 0);    if ( MoreUTFindDriveQ(drive, &amp;foundDrvQEl) == noErr) {    return foundDrvQEl-&gt;dQRefNum;  } else {    return 0;  }}static pascal Boolean MoreDriveSupportsDriverGestaltInternal(DriverRefNum refNum)  // An internal version of MoreDriveSupportsDriverGestalt that allows  // you to pass in the refNum and the drive number.  You can pass  // in 0 for either refNum or drive (but not both) and the routine  // will do the appropriate mapping.{    OSErr junk;    DriverFlags driverFlags;        junk = TradGetDriverInformation(refNum, nil, &amp;driverFlags, nil, nil);    MoreAssertQ(junk == noErr);    return TradDriverGestaltIsOn(driverFlags);}extern pascal Boolean MoreDriveSupportsDriverGestalt(SInt16 drive)  // See comment in interface part.{  return MoreDriveSupportsDriverGestaltInternal(MoreGetDriveRefNum(drive));}static pascal Boolean MoreDriveSupportFileExchangeInternal(DriverRefNum refNum, SInt16 drive)  // An internal version of MoreDriveSupportFileExchange that allows  // you to pass in the refNum and the drive number.  You can pass  // in 0 for either refNum or drive (but not both) and the routine  // will do the appropriate mapping.{    DriverGestaltParam pb;    Boolean result;    MoreAssertQ( (refNum &lt; 0 &amp;&amp; drive &gt;= 0 &amp;&amp; (drive == 0 || MoreGetDriveRefNum(drive) == refNum)) ||           (refNum == 0 &amp;&amp; drive &gt; 0) );        if (refNum == 0) {      refNum = MoreGetDriveRefNum(drive);    }        result = false;    if ( MoreDriveSupportsDriverGestaltInternal(refNum) ) {        pb.ioVRefNum = drive;        pb.ioCRefNum = refNum;        pb.csCode = kDriverGestaltCode;        pb.driverGestaltSelector = kdgAPI;        if ( PBStatusSync((ParmBlkPtr) &amp;pb) == noErr                 &amp;&amp; GetDriverGestaltAPIResponse(&amp;pb)-&gt;partitionCmds &amp; 0x01 ) {            result = true;        }    }    return result;}extern pascal Boolean MoreDriveSupportFileExchange(SInt16 drive)  // See comment in interface part.{    MoreAssertQ(drive &gt; 0);  return MoreDriveSupportFileExchangeInternal(0, drive);}// This is the number of format list entries we allocate when issuing// the return format list status call.  There's no way we can calculate// the &quot;correct&quot; number, but this should be more than enough.enum {  kFormatListEntryCount = 16};extern pascal OSErr MoreGetDriveSize(SInt16 drive, UInt32 *sizeInBlocks)  // See comment in interface part.{  OSErr err;  DrvQElPtr drvQEl;  CntrlParam pb;  FormatListRec formatList[kFormatListEntryCount];  SInt16 formatIndex;  Boolean foundFormat;  Str255 driverName;    DrvSts status;      MoreAssertQ(drive &gt; 0);    MoreAssertQ(sizeInBlocks != nil);  // Start by finding the drive queue element for  // the drive, and by making sure that there's a disk  // in the drive.    err = MoreUTFindDriveQ(drive, &amp;drvQEl);  if (err == noErr) {    if ( MoreGetDriveFlags(drvQEl)-&gt;diskInPlace &lt;= 0 ) {      err = offLinErr;    }  }  // Wow, this is harder than it should be, all because of the  // silly &quot;.Sony&quot; driver.  The basic problem is that  // the &quot;.Sony&quot; driver doesn't store the disk size in the  // drive queue element like every other disk drive on the  // planet.  The solution is a three step process as described  // in the comments below.    if (err == noErr) {    // Step 1.  If the driver supports the kReturnFormatList status call,    //        use it to get a list of formats for the drive and then    //      return the format marked as current.    pb.ioNamePtr = nil;    pb.ioVRefNum = drvQEl-&gt;dQDrive;    pb.ioCRefNum = drvQEl-&gt;dQRefNum;    pb.csCode = kReturnFormatList;    pb.csParam[0] = kFormatListEntryCount;    *((FormatListRec **) &amp;pb.csParam[1]) = formatList;    err = PBStatusSync( (ParmBlkPtr) &amp;pb);    if (err == noErr) {      foundFormat = false;      for (formatIndex = 0; formatIndex &lt; pb.csParam[0]; formatIndex++) {        if ((formatList[formatIndex].formatFlags &amp; diCIFmtFlagsCurrentMask) != 0) {          *sizeInBlocks = formatList[formatIndex].volSize;          foundFormat = true;        }      }      if ( ! foundFormat ) {        // Hmmm, this isn't good.  The disk driver returned a format        // list but none of the formats were marked as &quot;current&quot;.        // We handle this correctly but, in debug builds, we'll also        // drop into MacsBug, just to let you know this is happening.        MoreAssertQ(false);        err = paramErr;      }    } else {          // *** The logic here is slightly screwed up.  The problem is that      // I can't tell whether the kReturnFormatList call failed because      // the driver just doesn't support it, or because the driver failed      // to get the information for some other reason.  If that driver      // happens to be the &quot;.Sony&quot; driver, I'm going to take a wrong step      // next.      //      // For example, say that there's a 1.4MB disk in the floppy drive      // and I call kReturnFormatList and it fails with an error because      // of a cosmic ray.  I then test the driver name, find that it's      // &quot;.Sony&quot;, call DriveStatus, and then return noErr with a size      // of either 400KB or 800KB.  Not good.      //       // You might think this is an unlikely occurence, but it's exactly      // what happens when there's no disk in the floppy drive.  I've      // special-cased that away above, but the general problem still stands.      //       // What are the alternatives?  I could special case the error      // result from kReturnFormatList and only run this code if I get      // statusErr.  But can you guarantee that all &quot;.Sony&quot; drives      // return statusErr for an unrecognised status code?  I thought not.      // Beyond that, I can't think of any options.  So this code      // stands.  It's probably never going to bite anyone, but it's      // worth noting here, just in case.  Besides, this is what      // the equivalent routine in MoreFiles does (-:      //      // -- Quinn, 3 Mar 1999      // Step 2.  If that doesn't work, then look at the driver.  If it's      //        the &quot;.Sony&quot; driver (and this will be a really old &quot;.Sony&quot; driver      //        because new ones support kReturnFormatList), special case      //        the possible media types.      err = TradGetDriverInformation(drvQEl-&gt;dQRefNum, nil, nil, driverName, nil);      if (err == noErr) {        if ( EqualString(driverName, &quot;\p.Sony&quot;, false, true) ) {          err = DriveStatus(drvQEl-&gt;dQDrive, &amp;status);          if (err == noErr) {            if ( status.twoSideFmt == 0 ) {              *sizeInBlocks = 400 * 2;            } else {              *sizeInBlocks = 800 * 2;            }          }        } else {          // Step 3.  If it's not the &quot;.Sony&quot; driver, get the size out of the          //        drive queue element.          if (drvQEl-&gt;qType == 0) {            // Old style drive, with just 16 bits of size information            // in dQDrvSz.            *sizeInBlocks = drvQEl-&gt;dQDrvSz;          } else {                      // New style drive, with 32 bits of size information spread            // between dQDrvSz and dQDrvSz2.                        *sizeInBlocks = (((UInt32 ) drvQEl-&gt;dQDrvSz2) * 65536) + (UInt32 ) drvQEl-&gt;dQDrvSz;          }        }      }    }  }    return err;}extern pascal SInt16 MoreVolumeMountedOnDrive(SInt16 drive, Boolean ejectedIsMounted)  // See comment in interface part.{  SInt16 result;  VCBPtr thisVCB;    MoreAssertQ(drive &gt; 0);  // Get the VCB queue (in low memory) and walk it.  // We can't use UTLocateNextVCB because it will only  // iterate volumes by name, not return a complete list.    result = 0;  thisVCB  = (VCBPtr) GetVCBQHdr()-&gt;qHead;  while (thisVCB != nil &amp;&amp; result == 0) {    if (thisVCB-&gt;vcbDrvNum == drive ||        (ejectedIsMounted &amp;&amp;         thisVCB-&gt;vcbDrvNum == 0 &amp;&amp;         thisVCB-&gt;vcbDRefNum == drive        )       ) {      MoreAssertQ(thisVCB-&gt;vcbDrvNum == 0 || thisVCB-&gt;vcbDRefNum == MoreGetDriveRefNum(drive));      result = thisVCB-&gt;vcbVRefNum;    } else {      thisVCB = (VCBPtr) thisVCB-&gt;qLink;    }  }    return result;}extern pascal SInt16 MoreFirstDriveWithoutVolume(DriverRefNum refNum)  // See comment in interface part.{  Boolean found;  DrvQElPtr thisDrv;  found = false;  thisDrv = (DrvQElPtr) GetDrvQHdr()-&gt;qHead;  while (thisDrv != nil &amp;&amp; ! found) {    if (thisDrv-&gt;dQRefNum == refNum &amp;&amp; MoreVolumeMountedOnDrive(thisDrv-&gt;dQDrive, false) == 0) {      found = true;    } else {      thisDrv = (DrvQElPtr) thisDrv-&gt;qLink;    }  }  if (found) {    return thisDrv-&gt;dQDrive;  } else {    return 0;  }}extern pascal void MoreIsDriveCDROM(SInt16 drive, MoreDisksCDROMResponse *response)  // See comment in interface part.{  DriverRefNum refNum;  DriverFlags drvrFlags;  Str255 drvrName;    DriverGestaltParam pb;    MoreAssertQ(drive &gt; 0);  MoreAssertQ(response != nil);    *response = kMoreDriveUnableToDetermineCDROM;    refNum = MoreGetDriveRefNum(drive);  if (refNum != 0) {    if ( TradGetDriverInformation(refNum, nil, &amp;drvrFlags, drvrName, nil) == noErr ) {          // Step 1 -- if the driver supports driver gestalt, we      // exclusively rely on its response for the kdgDeviceType      // selector.            if ( TradDriverGestaltIsOn(drvrFlags) ) {            pb.ioVRefNum = drive;            pb.ioCRefNum = refNum;            pb.csCode = kDriverGestaltCode;            pb.driverGestaltSelector = kdgDeviceType;            if ( PBStatusSync((ParmBlkPtr) &amp;pb) == noErr ) {              if (GetDriverGestaltDevTResponse(&amp;pb)-&gt;deviceType == kdgCDType) {                  *response = kMoreDriveIsCDROM;              } else {                  *response = kMoreDriveIsNotCDROM;              }            }      }            // Step 2 -- if the above didn't work, we only say it's a CD-ROM      // if the driver is &quot;.AppleCD&quot;.      if (*response == kMoreDriveUnableToDetermineCDROM) {        if ( EqualString(drvrName, &quot;\p.AppleCD&quot;, false, true) ) {                 *response = kMoreDriveIsCDROM;        } else if ( EqualString(drvrName, &quot;\p.AFPTranslator&quot;, false, true) ) {          // &quot;.AFPTranslator&quot; does not respond to Driver Gestalt,          // which is pretty lame IMHO.  [Radar ID ]  Regardless,          // we know it's not a CD-ROM.                 *response = kMoreDriveIsNotCDROM;        } else if ( EqualString(drvrName, &quot;\p.Sony&quot;, false, true) ) {                 *response = kMoreDriveIsNotCDROM;        }      }    }  }}/////////////////////////////////////////////////////////////////#pragma mark ----- File Exchange Control Call Interface -----extern pascal OSErr MoreCreateNewDriveQueueElement(SInt16 driveToClone,            UInt32 firstBlock, UInt32 sizeInBlocks,            SInt16 *newDrive)  // See comment in interface part.{    OSErr err;    OSErr junk;    CntrlParam pb;    DrvQElPtr drvQEl;    MoreAssertQ(driveToClone &gt; 0);    MoreAssertQ(newDrive != nil);      // First check that the driver supports the File Exchange  // control call interface.          err = noErr;    if ( ! MoreDriveSupportFileExchange(driveToClone) ) {      err = controlErr;    }        // Find the drive queue element associated with    // driveToClone.  This is an input parameter to    // kGetADrive.      if (err == noErr) {          err = MoreUTFindDriveQ(driveToClone, &amp;drvQEl);  }    // Make the kGetADrive call to the driver.  Because  // we pass a pointer to memory outside of the parameter  // block (drvQEl) and the driver might be a paging device,  // we must hold drvQEl (and make sure to unhold it later!).      if (err == noErr) {    err = SafeHoldMemory(&amp;drvQEl, sizeof(drvQEl));    if (err == noErr) {          pb.ioVRefNum = driveToClone;          pb.ioCRefNum = MoreGetDriveRefNum(driveToClone);          pb.csCode = kGetADrive;          *((DrvQElPtr **) &amp;pb.csParam[0]) = &amp;drvQEl;          err = PBControlSync((ParmBlkPtr) &amp;pb);          if (err == noErr) {              *newDrive = drvQEl-&gt;dQDrive;          }          junk = SafeUnholdMemory(&amp;drvQEl, sizeof(drvQEl));          MoreAssertQ(junk == noErr);      }    }        // Now re-target the new drive to the partition on the    // disk specified by firstBlock and sizeInBlocks.  We do    // this in the create call because some disk drivers    // don't always inherit the partition information from    // the drive that was cloned.        if (err == noErr) {    err = MoreSetDrivePartition(*newDrive, firstBlock, sizeInBlocks);    }        return err;}extern pascal OSErr MoreSetDrivePartition(SInt16 drive, UInt32 firstBlock, UInt32 sizeInBlocks)  // See comment in interface part.{    OSErr err;    CntrlParam pb;    DrvQElPtr drvQEl;    MoreAssertQ(drive &gt; 0);      // First check that the driver supports the File Exchange  // control call interface.          err = noErr;    if ( ! MoreDriveSupportFileExchange(drive) ) {      err = controlErr;    }        // Find the drive queue element associated with    // drive.  This is an input parameter to    // kRegisterPartition.      if (err == noErr) {          err = MoreUTFindDriveQ(drive, &amp;drvQEl);  }    // Make the kRegisterPartition control call.  We  // don't need to hold any memory because all the  // parameters to this control call are entirely  // contained within the parameter block.    if (err == noErr) {        pb.ioVRefNum = drive;        pb.ioCRefNum = MoreGetDriveRefNum(drive);        pb.csCode = kRegisterPartition;        *((DrvQElPtr *) &amp;pb.csParam[0]) = drvQEl;        *((UInt32 *) &amp;pb.csParam[2]) = firstBlock;        *((UInt32 *) &amp;pb.csParam[4]) = sizeInBlocks;        err = PBControlSync((ParmBlkPtr) &amp;pb);    }        // In the debug build, check that our changes stuck.        #if MORE_DEBUG      if (err == noErr) {        OSErr debugErr;        UInt32 trueFirstBlock;        UInt32 trueSizeInBlocks;      debugErr = MoreGetDrivePartition(drive, &amp;trueFirstBlock, &amp;trueSizeInBlocks);      MoreAssertQ(debugErr == noErr &amp;&amp; trueSizeInBlocks == sizeInBlocks &amp;&amp; trueFirstBlock == firstBlock);      }    #endif        return err;}extern pascal OSErr MoreGetDrivePartition(SInt16 drive, UInt32 *firstBlock, UInt32 *sizeInBlocks)  // See comment in interface part.{  OSErr err;  partInfoRec partInfo;      MoreAssertQ(drive &gt; 0);    MoreAssertQ(firstBlock != nil);    MoreAssertQ(sizeInBlocks != nil);  err = MoreGetPartitionInfo(drive, &amp;partInfo);  if (err == noErr) {    *firstBlock = partInfo.physPartitionLoc;    err = MoreGetDriveSize(drive, sizeInBlocks);  }  return err;}extern pascal OSErr MoreGetPartitionInfo(SInt16 drive, partInfoRec *partInfo)  // See comment in interface part.{    OSErr err;    OSErr junk;    CntrlParam pb;        MoreAssertQ(drive &gt; 0);    MoreAssertQ(partInfo != nil);  // First check that the driver supports the File Exchange  // control call interface.          err = noErr;    if ( ! MoreDriveSupportFileExchange(drive) ) {      err = controlErr;    }  // Make the kGetADrive call to the driver.  Because  // we pass a pointer to memory outside of the parameter  // block (partInfo) and the driver might be a paging device,  // we must hold partInfo (and make sure to unhold it later!).  if (err == noErr) {        err = SafeHoldMemory(partInfo, sizeof(*partInfo));    if (err == noErr) {        pb.ioVRefNum = drive;        pb.ioCRefNum = MoreGetDriveRefNum(drive);        pb.csCode = kGetPartInfo;        *((partInfoRec **) &amp;pb.csParam[0]) = partInfo;        err = PBStatusSync((ParmBlkPtr) &amp;pb);                junk = SafeUnholdMemory(partInfo, sizeof(*partInfo));          MoreAssertQ(junk == noErr);    }  }        return err;}#if 0// ***// This code temporarily disable while I figure out what's going on.// -- Quinn, 3 Mar 1999extern pascal OSErr MoreGetPartitionVolume(DriverRefNum refNum, const partInfoRec *partInfo, SInt16 *vRefNum)  // See comment in interface part.{    OSErr err;    OSErr junk;    CntrlParam pb;        MoreAssertQ(refNum &lt; 0);    MoreAssertQ(partInfo != nil);    MoreAssertQ(vRefNum != nil);  // First check that the driver supports the File Exchange  // control call interface.          err = noErr;    if ( ! MoreDriveSupportFileExchangeInternal(refNum, 0) ) {      err = controlErr;    }  // Make the kGetPartitionStatus call to the driver.  Because  // we pass a pointer to memory outside of the parameter  // block (partInfo and vRefNum) and the driver might be a paging device,  // we must hold that memory (and make sure to unhold it later!).  if (err == noErr) {        err = SafeHoldMemory( (partInfoRec *) partInfo, sizeof(*partInfo));    if (err == noErr) {      err = SafeHoldMemory(vRefNum, sizeof(*vRefNum));      if (err == noErr) {          pb.ioVRefNum = 0;          pb.ioCRefNum = refNum;          pb.csCode = kGetPartitionStatus;          *((partInfoRec **) &amp;pb.csParam[0]) = (partInfoRec *) partInfo;          *((SInt16 **) &amp;pb.csParam[2]) = vRefNum;          err = PBStatusSync((ParmBlkPtr) &amp;pb);          junk = SafeUnholdMemory(vRefNum, sizeof(*vRefNum));            MoreAssertQ(junk == noErr);      }        junk = SafeUnholdMemory( (partInfoRec *) partInfo, sizeof(*partInfo));          MoreAssertQ(junk == noErr);      }    }    return err;}#endif</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/BasicDiskImage/listing2.html%3Fid%3DDTS10000425-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/BasicDiskImage/listing2.html%3Fid%3DDTS10000425-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/BasicDiskImage/listing2.html%3Fid%3DDTS10000425-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>