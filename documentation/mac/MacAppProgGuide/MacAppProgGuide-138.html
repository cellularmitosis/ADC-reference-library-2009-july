<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Recipes--Drag and Drop (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING138></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-137.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-139.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-136.html"><B>Chapter 28 - Working With Drag and Drop</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING138-0></A>
<H1><A NAME=MARKER-2-24></A>Recipes--Drag and Drop</H1>
 The recipes and sample code in this section demonstrate how to include and initialize MacApp's drag-and-drop support, how to enable dragging or dropping for a view, and how to add drag-and-drop support to a custom view class.<P>
 <A HREF=#MARKER-9-25>Figure 28-1</A> shows classes and methods used to provide drag-and-drop support in your application.<P>
<B>Figure 28-1  Drag-and-drop <A NAME=MARKER-9-25></A>classes and methods</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-087.gif"><P>
<A NAME=HEADING138-5></A>
<H2><A NAME=MARKER-2-26></A><A NAME=MARKER-9-27></A>Recipe--Including and Initializing MacApp's Drag-and-Drop Support</H2>
 To use MacApp's drag-and-drop support in your application, you perform these steps:<P>
<OL>
<LI>Include MacApp's drag-and-drop code in your application.
<LI>Call the InitUDragManager initialization routine.<P>
</OL>
<A NAME=HEADING138-9></A>
<H3><A NAME=MARKER-2-28></A>Include MacApp's Drag-and-Drop Code in Your Application</H3>
 MacApp uses the <CODE>qDrag</CODE> compiler flag to control compilation of drag-and-drop code. To include MacApp's drag-and-drop support, you need to set this flag to <CODE>TRUE</CODE> (or 1) while building your application. If you are using MPW and the MABuild system (described in <A HREF=MacAppProgGuide-148.html#MARKER-9-10>Appendix A</A>), you use a line like the following:<P>
<PRE>
MABuild &quot;{MASamples}DemoText:DemoText&quot; -Drag -AutoBuild
</PRE>
 This line builds the DemoText sample application and the MacApp class library, with MacApp's drag-and-drop support included.<P>
 If you are working with another development system, set the <CODE>qDrag</CODE> compiler flag to <CODE>TRUE</CODE> (or 1) before compiling MacApp and your application. You can do so by placing a line like the following in a header file that is included by all files (both yours and MacApp's) that contain drag-related code:<P>
<PRE>
#define qDrag 1
</PRE>
<A NAME=HEADING138-15></A>
<H3>Call the InitUDragManager Initialization Routine</H3>
 To initialize MacApp's drag-and-drop support, your application should call the <CODE>InitUDragManager</CODE> routine. You call this routine from your <CODE>main</CODE> routine, with code similar to the following:<P>
<PRE>
#if qDrag
   if (HasDragManager())
      InitUDragManager();
#endif
</PRE>
 MacApp supplies the HasDragManager routine to determine whether the Drag Manager is available on the current machine.<A NAME=MARKER-2-29></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Isolate any code that deals with drag-and-drop support, using conditional compilation (#if qDrag) or conditional testing (if (HasDragManager)). Otherwise, your application may try to call MacApp code or reference a MacApp variable that was not included in the current build, with unpleasant results.<EM></EM><A NAME=MARKER-2-30></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING138-20></A>
<H2><A NAME=MARKER-2-31></A><A NAME=MARKER-9-32></A>Recipe--Turning on Drag-and-Drop Support for a View</H2>
 To turn on drag-and-drop support for a view, you perform this step:<P>
<OL>
<LI>Set the view's drag-and-drop fields<P>
<UL>
<LI><CODE><A NAME=MARKER-2-33></A>fDraggable</CODE> (to indicate the view can initiate drags)
<LI><CODE><A NAME=MARKER-2-34></A>fDragMoveDeterminer</CODE>, <A NAME=MARKER-2-35></A><CODE>fDragMoveFamily</CODE> (to indicate how data is dragged)
<LI><CODE><A NAME=MARKER-2-36></A>fDroppable</CODE> (to indicate the view can accept drops)<P>
</UL>
</OL>
 This recipe shows how to set view fields directly with accessor methods supplied by MacApp, and how to set them by adding a <CODE>TDragDropBehavior </CODE>class to the view resource definition.<P>
 The sample code shown in this recipe is for an arbitrary view class.<P>
<A NAME=HEADING138-28></A>
<H3>Setting Drag-and-Drop Fields Directly</H3>
 You can set the drag-and-drop fields of a view class directly with code like the following:<P>
<PRE>
// Set fDraggable to TRUE, indicating the view can initiate drags.
fYourView-&gt;SetDraggable(TRUE);
// Set fDroppable to TRUE, indicating the view can accept drops.
fYourView-&gt;SetDroppable(TRUE);
// Set fDragMoveDeterminer to indicate that a drag between views within
// this window should be treated as a move, not a copy.
fYourView-&gt;SetDragMoveDeterminer(kMoveWithinWindow);
// Set fDragMoveFamily to an arbitray value; dragging between any views
// with this value is a move if the relationship specified by the
// fDragMoveDeterminer field is also met. Using kNoIdentifier just
// indicates that we don't want to define a special value.
fYourView-&gt;SetDragMoveFamily(kNoIdentifier);
</PRE>
 The code in this sample specifies that the view object f<I>Your</I>View can initiate drags and can accept drops. If data is dragged from the f<I>Your</I>View object to another view within the same window that has a drag move family of <CODE>kNoIdentifier</CODE>, the dragged data will be moved, not copied. (For more information on drag moves, see <A HREF=MacAppProgGuide-77.html#MARKER-9-122>"Drag Copy Versus Drag Move," beginning on page 268</A>.)<P>
 You can set drag-and-drop fields in the initialization method for your view (I<I>Your</I>View). For a view class instantiated from a view resource definition, you can override the view's <CODE>DoPostCreate</CODE> method and set the drag-and-drop fields there. Or you can use the approach shown in the next section.<P>
<A NAME=HEADING138-33></A>
<H3>Setting Drag-and-Drop Fields Using the TDragDropBehavior Class</H3>
 MacApp supplies the <CODE>TDragDropBehavior</CODE> class as a convenience for setting a view's drag-and-drop fields. The <CODE>TDragDropBehavior</CODE> class has four fields that duplicate the identically named view fields: <CODE>fDraggable</CODE>, <CODE>fDroppable</CODE>, <CODE>fDragMoveDeterminer</CODE>, and <CODE>fDragMoveFamily</CODE>.<P>
 When you call <CODE>AddBehavior</CODE> to add a behavior to a view, the <CODE>AddBehavior</CODE> method calls the behavior's <CODE>SetOwner</CODE> method. The <CODE>SetOwner</CODE> method for <CODE>TDragDropBehavior</CODE> calls the SetDraggable, SetDroppable, SetDragMoveDeterminer, and SetDragMoveFamily methods of its view to set the view's drag-and-drop fields to match those of the behavior.<P>
 The advantage of the <CODE>TDragDropBehavior</CODE> class is that you can use a view-editing application to add a <CODE>TDragDropBehavior</CODE> object to a view in a view resource definition. When your application uses <CODE>NewTemplateWindow</CODE> to create a view based on that definition, the <CODE>TEventHandler::ReadFrom</CODE> method creates any behavior objects attached to the view and calls <CODE>AddBehavior</CODE> for each behavior object. As a result, the <CODE>SetOwner</CODE> method sets the view's drag-and-drop fields to match those of the <CODE>TDragDropBehavior</CODE>, which you specified in the view resource.<A NAME=MARKER-2-37></A><P>
<A NAME=HEADING138-37></A>
<H2><A NAME=MARKER-2-38></A>Recipe--Adding Drag-and-Drop Support to a Custom <BR>View Class</H2>
 This recipe demonstrates how to add drag-and-drop support to a custom view class, using MacApp's <CODE>TPicture</CODE> class as an example. The <CODE>TPicture</CODE> class is a view class that displays a picture specified by its <CODE>fRsrcID</CODE> field and its <CODE>fDataHandle</CODE> field. The resource ID identifies a resource of type <CODE>'PICT'</CODE>, and the data handle field refers to a picture handle (type <CODE>PicHandle</CODE>). <CODE>TPicture</CODE> is a subclass of <CODE>TControl</CODE>, so the displayed picture can be used as a button, if desired.<P>
 To add drag-and-drop support to a custom view, you perform these steps:<P>
<OL>
<LI>Define a subclass of <CODE>TView</CODE> or of one of MacApp's other view classes.
<LI>If the view will initiate drags, override certain methods:<P>
<UL>
<LI>Override the <CODE>DoAddDragContent</CODE> method to supply the view's draggable content.
<LI>If the <CODE>DoAddDragContent</CODE> method promises any data, override the <CODE>DoFulfillPromise</CODE> method to supply the promised data.<P>
</UL>
<LI>If the view will accept drops, override the <CODE>WillAcceptDrop</CODE> method.
<LI>Override the <CODE>DoMakeDragDropCommand</CODE> method.
<LI>Include and initialize MacApp's drag-and-drop support.
<LI>Turn on dragging or dropping for the view.
<LI>If MacApp's default drag-and-drop behavior is not sufficient, you may have to override additional methods:<P>
<UL>
<LI>Override the <CODE>WillDrag</CODE> method.
<LI>Override <CODE>DoMakeDragCursorRegion</CODE> or <CODE>DoMakeDropHiliteRegion</CODE>.
<LI>Override <CODE>DoMakeDragOutlineRegion</CODE>.
<LI>Override methods to set the drag cursor.<P>
</UL>
</OL>
 The sample code shown in this recipe is based on MacApp's <CODE>TPicture</CODE> class.<P>
<A NAME=HEADING138-54></A>
<H3>Define a Subclass of TView or Another View Class</H3>
 This recipe assumes that you have defined a custom view class. For more information on defining a class, see <A HREF=MacAppProgGuide-135.html#MARKER-9-35>"Recipe--Defining a Class," beginning on page 277</A>, and <A HREF=MacAppProgGuide-111.html#MARKER-9-34>"Recipe--Defining a Subclass of TApplication," beginning on page 289</A>. MacApp's <CODE>TPicture</CODE> class is defined in the files <CODE>UDialog.h</CODE> and <CODE>UDialog.cp</CODE>.<P>
<A NAME=HEADING138-56></A>
<H3>For a View That Initiates Drags, Override Certain Methods</H3>
 This section describes two <CODE>TView</CODE> methods your custom view class is likely to override to provide drag support: <CODE>DoAddDragContent</CODE> and <CODE>DoFulfillPromise</CODE>.<P>
<A NAME=HEADING138-58></A>
<H4>DoAddDragContent</H4>
 The <CODE>TView::HandleDrag</CODE> method calls <CODE>DoAddDragContent</CODE> to add content for a drag operation. In <CODE>TView</CODE>, <CODE>DoAddDragContent</CODE> does nothing, so your custom view must override this method to supply its draggable content.<P>
 The <CODE>TPicture</CODE> class overrides DoAddDragContent to promise picture data for the drag operation (see <A HREF=MacAppProgGuide-77.html#MARKER-9-112>"Promising Data," beginning on page 267</A>):<P>
<PRE>
void TPicture::DoAddDragContent()
{
   TDragItem * dragItem =
               TDragDropSession::fgDragDropSession-&gt;AddDragItem(1);
   CFlavorFlags flags;
   
   dragItem-&gt;PromiseFlavor('PICT', flags);
}
</PRE>
 The DoAddDragContent method first calls a method of the global drag session object to add a drag item to the drag operation. The passed value (1) is an arbitrary value used as an item reference in subsequent calls to Drag Manager routines involving this item. DoAddDragContent then calls the drag item's <CODE>PromiseFlavor</CODE> method to make a promise to deliver <CODE>'PICT'</CODE> data on request.<P>
 When a drag operation is initiated by a user, the dragged data may eventually be dropped or the drag may be ended without delivering any data. The dragged data, such as a picture handle, may be large, so it is worthwhile to promise data for future delivery, rather than actually supply it. The next section describes how to deliver promised data when it is needed.<P>
<A NAME=HEADING138-64></A>
<H4>DoFulfillPromise</H4>
 If your custom view class promises data in its DoAddDragContent method, as <CODE>TPicture</CODE> does, it must override <CODE>DoFulfillPromise</CODE> to supply the promised data.<P>
<PRE>
void TPicture::DoFulfillPromise(TDragItem* promisedItem)
{
   switch(promisedItem-&gt;GetFlavorType())
   {
      case 'PICT':
         {
            if (IsAResource((Handle)fDataHandle))
               LoadResource((Handle)fDataHandle);
            FailNIL(fDataHandle);
            FailNIL(*fDataHandle);
            MAVolatileInit(SignedByte, savedState,
                              HGetState((Handle)fDataHandle));
            FailInfo fi;
            Try(fi)
            {
               HNoPurge((Handle)fDataHandle);
               promisedItem-&gt;SetDataFromHandle((Handle)fDataHandle);
               HSetState((Handle)fDataHandle, savedState);
               fi.Success();
            }
            else
            {
               HSetState((Handle)fDataHandle, savedState);
               fi.ReSignal();
            }
         }
         break;

      default:
         Inherited::DoFulfillPromise(promisedItem);
         break;
   }
}
</PRE>
 The TPicture::DoFulfillPromise method is passed a drag item that knows what type of information has been promised. If the promised flavor is <CODE>'PICT'</CODE>, DoFulfillPromise first makes sure the resource handle for the picture is loaded and, if so, marks it as not purgeable. It then calls a method of the drag item (SetDataFromHandle) to supply the promised data. DoFulfillPromise includes failure-handling code to restore the state of the picture handle if any error occurs. If the promised type is anything other than <CODE>'PICT'</CODE>, it calls Inherited to pass on the request.<P>
<A NAME=HEADING138-68></A>
<H3>For a View That Accepts Drops, Override the WillAcceptDrop Method</H3>
 When a user drags information over your custom view during a drag operation, the <CODE>TWindow::MouseToDropTarget</CODE> method calls your view's <CODE>WillAcceptDrop</CODE> method to determine whether the view can accept the dragged data. A view normally accepts a drop only if it can accept at least one flavor for each drag item in the drag operation. The <CODE>TPicture::WillAcceptDrop</CODE> method accepts the drop only if there is exactly one drag item and it contains the <CODE>'PICT'</CODE> flavor.<P>
<PRE>
Boolean TPicture::WillAcceptDrop(CDragItemIterator&amp; dragItemIterator)
{
   if (TDragDropSession::fgDragDropSession-&gt;GetItemCount() != 1)
      return FALSE;
      
   TDragItem *firstItem = dragItemIterator.FirstDragItem();
   return firstItem-&gt;FlavorExists('PICT');
}
</PRE>
 The WillAcceptDrop method calls on a method of the global drag session object to get the number of items in the current drag. If the number of items is not one, or if the first drag item does not contain (or promise for future delivery) the flavor <CODE>'PICT'</CODE>, WillAcceptDrop returns FALSE; otherwise, it returns <CODE>TRUE</CODE>.<P>
<A NAME=HEADING138-72></A>
<H3>Override the DoMakeDragDropCommand Method</H3>
 Two methods of the global drag session object, <CODE>DragReceiveHandler</CODE> and <CODE>HandleDragToTrash</CODE>, call the view's <CODE>DoMakeDragDropCommand</CODE> method. The <CODE>DoMakeDragDropCommand</CODE> method supplies a command object to perform the operation: drag, drop, or drag move (specified by the command constants <CODE>cDrag</CODE>, <CODE>cDrop</CODE>, and <CODE>cDragMove</CODE>). The <CODE>DoMakeDragDropCommand</CODE> method for the <CODE>TPicture</CODE> class is shown on the following page.<P>
<PRE>
TCommand* TPicture::DoMakeDragDropCommand(CommandNumber itsCommandNumber,
                              CDragItemIterator&amp;dragItemIterator)
{
   TCommand *returnCommand = NULL;
   TCommandHandler *itsContext = this-&gt;GetContext(itsCommandNumber);
   
   switch(itsCommandNumber)
   {
      case cDrag:
         {
            TPictureCommand *dragCommand = new TPictureCommand;
            dragCommand-&gt;IPictureCommand(kNoResource, NULL, this, itsCommandNumber, 
               itsContext, kCanUndo, kCausesChange, itsContext);
            returnCommand = dragCommand;
         }
         break;
      case cDrop:
         {
            HandlepictureHandle = NULL;
            TDragItem*firstItem = dragItemIterator.FirstDragItem();
            
            firstItem-&gt;FocusOnFlavor('PICT');
            pictureHandle = firstItem-&gt;GetDataAsHandle();
               
            TPictureCommand *dropCommand = new TPictureCommand;
            dropCommand-&gt;IPictureCommand(kNoResource,(PicHandle)pictureHandle,
               this, itsCommandNumber, itsContext, kCanUndo, kCausesChange,
               itsContext);
            returnCommand = dropCommand;
         }
         break;
      case cDragMove: // Does nothing--causes return value to be NULL.
         break;
      default:
         returnCommand = Inherited::DoMakeDragDropCommand(
                                    itsCommandNumber, dragItemIterator);
         break;
   }
   return returnCommand;
}
</PRE>
 The <CODE>TPicture::DoMakeDragDropCommand</CODE> method makes the same kind of command, a <CODE>TPictureCommand</CODE>, for a drag or a drop. For a drag move it does nothing.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>The <CODE>DoMakeDragDropCommand</CODE> method is the one and only opportunity for the target view to extract data from the drag session. Don't assume you can extract data at any later point.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 In the case of a drag, the <CODE>DoMakeDragDropCommand</CODE> method initializes a picture command object with the values <CODE>kNoResource</CODE> and <CODE>NULL</CODE> for the picture resource ID and <CODE>PicHandle</CODE>. The <CODE>DoIt</CODE> method for <CODE>TPictureCommand</CODE> sets the view's resource ID and <CODE>PicHandle</CODE> fields to the stored values, in effect zeroing out the picture. As a result, dragging from a <CODE>TPicture</CODE> view is always the equivalent of a cut operation.<P>
 In the case of a drop, the <CODE>DoMakeDragDropCommand</CODE> method initializes a picture command object in a slightly different way--instead of specifying <CODE>NULL</CODE> for the <CODE>PicHandle</CODE>, it passes the picture handle from the current view (the <CODE>TPicture</CODE> or other view from which the data for the drop is being dragged). The <CODE>DoIt</CODE> method for <CODE>TPictureCommand</CODE> sets the view's <CODE>PicHandle</CODE> field to the passed picture handle, in effect dropping in the picture data.<P>
 Since a drag from a <CODE>TPicture</CODE> view cannot be dropped in the same view, there is no need for <CODE>DoMakeDragDropCommand</CODE> to supply a special command for a drag move.<P>
<A NAME=HEADING138-80></A>
<H3>Include and Initialize MacApp's Drag-and-Drop Support</H3>
 To use MacApp's drag-and-drop support in your custom view, your application must build with drag-and-drop support and initialize it. Those tasks are described in <A HREF=#MARKER-9-27>"Recipe--Including and Initializing MacApp's Drag-and-Drop Support," beginning on page 608</A>.<P>
<A NAME=HEADING138-82></A>
<H3>Turn on Dragging or Dropping for the View</H3>
 For your custom view to initiate drags or accept drops, you must set the appropriate drag-and-drop fields. <A HREF=#MARKER-9-32>"Recipe--Turning on Drag-and-Drop Support for a View," beginning on page 610</A>, describes how to turn on dragging or dropping for a view.<P>
<A NAME=HEADING138-84></A>
<H3><A NAME=MARKER-9-39></A>Override Additional Methods</H3>
 For some custom views, including MacApp's <CODE>TPicture</CODE>, the previous steps are sufficient to provide drag-and-drop support. However, other views may find it necessary to override additional drag-and-drop methods of <CODE>TView</CODE>.<P>
<A NAME=HEADING138-86></A>
<H4><A NAME=MARKER-9-40></A>WillDrag</H4>
 The <CODE>TView::HandleMouseDown</CODE> method calls the <CODE>DoMakeDragCursorRegion</CODE> method (described in the next section) and the <CODE>WillDrag</CODE> method to determine whether a view can initiate a drag. In the <CODE>TView</CODE> class, <CODE>DoMakeDragCursorRegion</CODE> creates a region that is equal to the view's extent. <CODE>TView::WillDrag</CODE> returns <CODE>TRUE</CODE> if the current mouse location is within the drag region and the <CODE>fDraggable</CODE> field has the value <CODE>TRUE</CODE>.<P>
 If your view requires different or additional handling, it can override <CODE>WillDrag</CODE>. The <CODE>TPicture</CODE> class overrides <CODE>WillDrag</CODE> to ensure that the view has picture data to drag:<P>
<PRE>
Boolean TPicture::WillDrag(const VPoint&amp; localMouse,
                     const RgnHandledragCursorRegion)
{
   if (Inherited::WillDrag(localMouse, dragCursorRegion))
      return ((fDataHandle != NULL) || (fRsrcID != kNoResource));
   else
      return FALSE;
}
</PRE>
 This method first calls <CODE>Inherited</CODE> to determine whether the mouse location is in the drag region and whether the view supports dragging. If so, and if the picture view has either a <CODE>PicHandle</CODE> (<CODE>fDataHandle != NULL</CODE>) or a picture resource ID (fRsrcID != kNoResource), WillDrag returns <CODE>TRUE</CODE>; otherwise, it returns FALSE.<P>
<A NAME=HEADING138-91></A>
<H4><A NAME=MARKER-2-41></A><A NAME=MARKER-2-42></A><A NAME=MARKER-9-43></A>Override the DoMakeDragCursorRegion or DoMakeDropHiliteRegion Method</H4>
 The <CODE>TView::DoMakeDragCursorRegion</CODE> method creates a region to describe the specific portion of the view's content that is draggable. Draggable content is often the area within the view that the user perceives as selected, such as highlighted cells in a grid view or selected text in a text view. The <CODE>DoMakeDragCursorRegion</CODE> method is called by the <CODE>TView</CODE> methods <CODE>HandleMouseDown</CODE>, <CODE>DoSetDragCursor</CODE>, and <CODE>DoMakeDragOutlineRegion</CODE>.<P>
 In the <CODE>TView</CODE> class, <CODE>DoMakeDragCursorRegion</CODE> calls the <CODE>DoMakeDropHiliteRegion</CODE> method, which creates a region that matches the view's extent. The <CODE>DoMakeDropHiliteRegion</CODE> method is also called by the global drag session object's <CODE>ShowDropTargetHilite</CODE> method when setting a drop target.<P>
 As a result, your application has several options if it needs to modify any of the drag-and-drop regions supplied by the <CODE>TView</CODE> class:<P>
<UL>
<LI>Override <CODE>DoMakeDragCursorRegion</CODE>. Here the region you supply will be used to determine the area for which the drag cursor should be set, to determine when a drag should be initiated, and to supply a drag outline.
<LI>Override <CODE>DoMakeDropHiliteRegion</CODE>. Here the region you supply will be used in all the places a region supplied by <CODE>DoMakeDragCursorRegion</CODE> is used, and it will be used to highlight a region that is ready to accept a drop.<P>
</UL>
 The <CODE>TGridView</CODE> view class, for example, overrides <CODE>DoMakeDragCursorRegion</CODE> to create a drag region that includes all selected cells in the gridview.<P>
 The <CODE>TEditText</CODE> view class overrides <CODE>DoMakeDropHiliteRegion</CODE> to provide a region that is inset by 1 pixel to compensate for a border area.<P>
<A NAME=HEADING138-99></A>
<H4>Override the DoMakeDragOutlineRegion Method</H4>
 In the <CODE>TView</CODE> class, the <A NAME=MARKER-2-44></A><CODE>DoMakeDragOutlineRegion</CODE> method calls on the <CODE>DoMakeDragCursorRegion</CODE> method, so the drag outline region matches the drag cursor region, which matches the view's extent. If your custom view class needs a specialized drag region (for example, if the drag outline region, drag cursor region, and view's extent are not identical), it can override the <CODE>DoMakeDragOutlineRegion</CODE> method.<A NAME=MARKER-2-45></A><A NAME=MARKER-2-46></A><P>
<A NAME=HEADING138-101></A>
<H4>Setting the Drag Cursor</H4>
 The default behavior supplied by the <CODE>TView</CODE> class is to display an open-hand cursor when a drag can be initiated, and a closed-hand cursor when a drag is under way. This behavior is appropriate for dragging data such as a picture.<P>
 Classes such as <CODE>TTEView</CODE> and <CODE>TEditText</CODE> override the <CODE>GetWillDragCursorID</CODE> method to return the <CODE>kNoResource</CODE> ID constant. This results in the display of an arrow cursor--an image appropriate for dragging text--when a drag can be initiated. These classes also override the <CODE>GetIsDraggingCursorID</CODE> method to return <CODE>kNoResource</CODE>, so that the arrow cursor is also used during the actual drag operation.<P>
 Your view class can also override these methods to specify a particular cursor when a drag can be initiated or when a drag is actually in progress. For more information, see <A HREF=MacAppProgGuide-75.html#MARKER-9-42>"Setting the Drag Cursor," beginning on page 257</A>.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-137.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-139.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
