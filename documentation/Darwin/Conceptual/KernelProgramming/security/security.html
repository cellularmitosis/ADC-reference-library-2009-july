<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Kernel Programming Guide: Security Considerations</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Security Considerations"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000905-CH206" title="Security Considerations"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../Kernel-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000532" target="_top">Kernel</a> &gt; <a href="../About/About.html#//apple_ref/doc/uid/TP30000905-CH204-TPXREF101">Kernel Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Architecture/Architecture.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../performance/performance.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000905-CH206-BEHJDFCA" title="Security Considerations"></a><h1>Security Considerations</h1><p>Kernel-level security can mean many things, depending on what kind of kernel code you are writing. This chapter points out some common security issues at the kernel or near-kernel level and where applicable, describes ways to avoid them. These issues are covered in the following sections:</p>
<ul class="ul"><li class="li"><p><span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-TPXREF108">“Security Implications of Paging”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-TPXREF109">“Buffer Overflows and Invalid Input”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-TPXREF110">“User Credentials”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-CDDBJFHC">“Remote Authentication”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-TPXREF113">“Temporary Files”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-TPXREF114">“/dev/mem  and  /dev/kmem”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-CDDHHEFC">“Key-based Authentication and Encryption”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-TPXREF115">“Console Debugging”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-TPXREF116">“Code Passing”</a></span></p></li></ul>
<p>Many of these issues are also relevant for application programming, but are crucial for programmers working in the kernel. Others are special considerations that application programers might not expect or anticipate.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000905-CH206-SW1" title="Note"></a><p><strong>Note:</strong>&nbsp;The terms cleartext<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_681"></a> and plaintext<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_682"></a> both refer to unencrypted text. These terms can generally be used interchangeably, although in some circles, the term cleartext is restricted to unencrypted transmission across a network. However, in other circles, the term plaintext (or sometimes plain text) refers to plain ASCII text (as opposed to HTML or rich text. To avoid any potential confusion, this chapter will use the term cleartext to refer to unencrypted text.</p></div>
<p>In order to understand security in Mac OS X, it is important to understand that there are two security models at work. One of these is the kernel security model, which is based on users, groups, and very basic per-user and per-group rights, which are, in turn, coupled with access control lists for increased flexibility. The other is a user-level security model, which is based on keys, keychains, groups, users, password-based authentication, and a host of other details that are beyond the scope of this document.</p>
<p>The user level of security contains two basic features that you should be aware of as a kernel programmer: Security Server<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_683"></a> and Keychain Manager<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_684"></a>.</p>
<p>The Security Server consists of a daemon and various access libraries for caching permission to do certain tasks, based upon various means of authentication, including passwords and group membership. When a program requests permission to do something, the Security Server basically says “yes” or “no,” and caches that decision so that further requests from that user (for similar actions within a single context) do not require reauthentication for a period of time.</p>
<p>The Keychain Manager is a daemon that provides services related to the keychain, a central repository for a user’s encryption/authentication keys. For more high level information on keys, see <span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-CDDHHEFC">“Key-based Authentication and Encryption.”</a></span></p>
<p>The details of the user-level security model use are far beyond the scope of this document. However, if you are writing an application that requires services of this nature, you should consider taking advantage of the Security Server and Keychain Manager from the user-space portion of your application, rather than attempting equivalent services in the kernel. More information about these services can be found in Apple’s Developer Documentation website at <span class="content_text"><a href="http://developer.apple.com/documentation" target="_top">http://developer.apple.com/documentation</a></span>.</p>

<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF108" title="Security Implications of Paging"></a><h2>Security Implications of Paging</h2><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_685"></a>
<p>Paging<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_686"></a> has long been a major problem for security-conscious programmers. If you are writing a program that does encryption, the existence of even a small portion of the cleartext of a document in a backing store could be enough to reduce the complexity of breaking that encryption by orders of magnitude.</p>
<p>Indeed, many types of data, such as hashes, unencrypted versions of sensitive data, and authentication tokens, should generally not be written to disk due to the potential for abuse. This raises an interesting problem. There is no good way to deal with this in user space (unless a program is running as <code>root</code>). However, for kernel code, it is possible to prevent pages from being written out to a backing store. This process is referred to as “wiring down” memory, and is described further in <span class="content_text"><a href="../boundaries/boundaries.html#//apple_ref/doc/uid/TP30000905-CH217-BABEDGJJ">“Memory Mapping and Block Copying.”</a></span></p>
<p>The primary purpose of wired memory is to allow DMA<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_687"></a>-based I/O. Since hardware DMA controllers generally do not understand virtual addressing, information used in I/O must be physically in memory at a particular location and must not move until the I/O operation is complete. This mechanism can also be used to prevent sensitive data from being written to a backing store.</p>
<p>Because wired memory<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_688"></a> can never be paged out (until it is unwired), wiring large amounts of memory has drastic performance repercussions, particularly on systems with small amounts of memory. For this reason, you should take care not to wire down memory indiscriminately and only wire down memory if you have a very good reason to do so.</p>
<p>In Mac OS X, memory may be wired down at the time of allocation. In I/O Kit, you specify <code><a href="../../../Reference/KernelIOKitFramework/IOLib_h/index.html#//apple_ref/c/func/IOMalloc" target="_top">IOMalloc</a></code> and <code><a href="../../../Reference/KernelIOKitFramework/IOLib_h/index.html#//apple_ref/c/func/IOFree" target="_top">IOFree</a></code> to allocate wired memory. In Mach, <code><!--a-->kmem_alloc_wired<!--/a--></code> (and <code><!--a-->kmem_free<!--/a--></code>) can be used. It may also be wired down after allocation. For more information on wired memory, see <span class="content_text"><a href="../boundaries/boundaries.html#//apple_ref/doc/uid/TP30000905-CH217-BABEDGJJ">“Memory Mapping and Block Copying.”</a></span><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_689"></a></p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF109" title="Buffer Overflows and Invalid Input"></a><h2>Buffer Overflows and Invalid Input</h2><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_690"></a>
<p>Buffer overflows are one of the more common bugs in both application and kernel programming. The most common cause is failing to allocate space for the NULL character that terminates a string in C or C++. However, user input can also cause buffer overflows if fixed-size input buffers are used and appropriate care is not taken to prevent overflowing these buffers.</p>
<p>The most obvious protection, in this case, is the best one. Either don’t use fixed-length buffers or add code to reject or truncate input that overflows the buffer. The implementation details in either case depend on the type of code you are writing.</p><p>For example, if you are working with strings and truncation is acceptable, instead of using <code><a href="../../../Reference/ManPages/man3/strcpy.3.html#//apple_ref/doc/man/3/strcpy" target="_top">strcpy</a></code>, you should use <code><a href="../../../Reference/ManPages/man3/strlcpy.3.html#//apple_ref/doc/man/3/strlcpy" target="_top">strlcpy</a></code> to limit the amount of data to copy. Mac OS X provides length-limited versions of a number of string functions, including <code><a href="../../../Reference/ManPages/man3/strlcpy.3.html#//apple_ref/doc/man/3/strlcpy" target="_top">strlcpy</a></code>, <code><a href="../../../Reference/ManPages/man3/strlcat.3.html#//apple_ref/doc/man/3/strlcat" target="_top">strlcat</a></code>, <code><a href="../../../Reference/ManPages/man3/strncmp.3.html#//apple_ref/doc/man/3/strncmp" target="_top">strncmp</a></code>, <code><a href="../../../Reference/ManPages/man3/snprintf.3.html#//apple_ref/doc/man/3/snprintf" target="_top">snprintf</a></code>, and <code><a href="../../../Reference/ManPages/man3/vsnprintf.3.html#//apple_ref/doc/man/3/vsnprintf" target="_top">vsnprintf</a></code>.</p><p>If truncation of data is not acceptable, you must explicitly call <code><a href="../../../Reference/ManPages/man3/strlen.3.html#//apple_ref/doc/man/3/strlen" target="_top">strlen</a></code> to determine the length of the input string and return an error if it exceeds the maximum length (one less than the buffer size).</p>
<p>Other types of invalid input can be somewhat harder to handle, however. As a general rule, you should be certain that switch statements have a default case unless you have listed every legal value for the width of the type.</p>
<p>A common mistake is assuming that listing every possible value of an <code>enum</code><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_691"></a> type provides protection. An enum is generally implemented as either a <code>char</code> or an <code>int</code> internally. A careless or malicious programmer could easily pass any value to a kernel function, including those not explicitly listed in the type, simply by using a different prototype that defines the parameter as, for example, an <code>int</code>.</p>
<p>Another common mistake is to assume that you can dereference a pointer passed to your function by another function. You should always check for null pointers<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_692"></a> before dereferencing them. Starting a function with</p>
<div class="codesample"><table><tr><td scope="row"><pre>int do_something(bufptr *bp, int flags) {<span></span></pre></td></tr><tr><td scope="row"><pre>    char *token = bp->b_data;<span></span></pre></td></tr></table></div>
<p>is the surest way to guarantee that someone else will pass in a null buffer pointer, either maliciously or because of programmer error. In a user program, this is annoying. In a file system, it is devastating.</p>
<p>Security is particularly important for kernel code that draws input from a network. Assumptions about packet size are frequently the cause of security problems. Always watch for packets that are too big and handle them in a reasonable way. Likewise, always verify checksums<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_693"></a> on packets. This can help you determine if a packet was modified, damaged, or truncated in transit, though it is far from foolproof. If the validity of data from a network is of vital importance, you should use remote authentication, signing, and encryption mechanisms such as those described in <span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-CDDBJFHC">“Remote Authentication”</a></span> and <span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-CDDHHEFC">“Key-based Authentication and Encryption.”</a></span></p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF110" title="User Credentials"></a><h2>User Credentials</h2><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_694"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_695"></a>
<p>As described in the introduction to this chapter, Mac OS X has two different means of authenticating users. The user-level security model (including the Keychain Manager and the Security Server) is beyond the scope of this document. The kernel security model, however, is of greater interest to kernel developers, and is much more straightforward than the user-level model.</p>
<p>The kernel security model is based on two mechanisms: basic user credentials and ACL permissions. The first, basic user credentials <a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_696"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_697"></a>, are passed around within the kernel to identify the current user and group of the calling process. The second authentication mechanism, access control lists (ACLs), provides access control at a finer level of granularity.</p>
<p>One of the most important things to remember when working with credentials is that they are per process, not per context. This is important because a process may not be running as the console user<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_698"></a>. Two examples of this are processes started from an <code>ssh</code> session (since ssh runs in the startup context) and <code>setuid</code> programs (which run as a different user in the <em>same</em> login context).</p>
<p>It is crucial to be aware of these issues. If you are communicating with a <code>setuid<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_699"></a> root</code> GUI application in a user’s login context, and if you are executing another application or are reading sensitive data, you probably want to treat it as if it had the same authority as the console user, not the authority of the effective user ID caused by running <code>setuid</code>. This is particularly problematic when dealing with programs that run as <code>setuid root</code> if the console user is not in the admin group. Failure to perform reasonable checks can lead to major security holes down the road.</p>
<p>However, this is not a hard and fast rule. Sometimes it is not obvious whether to use the credentials<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_700"></a> of the running process or those of the console user. In such cases, it is often reasonable to have a helper application show a dialog box on the console to require interaction from the console user. If this is not possible, a good rule of thumb is to assume the lesser of the privileges of the current and console users, as it is almost always better to have kernel code occasionally fail to provide a needed service than to provide that service unintentionally to an unauthorized user or process.</p>
<p>It is generally easier to determine the console user<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_701"></a> from a user space application than from kernel space code. Thus, you should generally do such checks from user space. If that is not possible, however, the variable <code>console_user<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_702"></a></code> (maintained by the VFS subsystem) will give you the uid of the last owner of <code>/dev/console</code> (maintained by a bit of code in the <code><a href="../../../Reference/ManPages/man2/chown.2.html#//apple_ref/doc/man/2/chown" target="_top">chown</a></code> system call). This is certainly not an ideal solution, but it does provide the most likely identity of the console user. Since this is only a “best guess,” however, you should use this only if you cannot do appropriate checking in user space.</p><a name="//apple_ref/doc/uid/TP30000905-CH206-SW2" title="Basic User Credentials"></a><h3>Basic User Credentials</h3><p>Basic user credentials<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_703"></a> used in the kernel are stored in a variable of type <code>struct ucred</code>. These are mostly used in specialized parts of the kernel—generally in places where the determining factor in permissions is whether or not the caller is running as the root user.</p><p>This structure has four fields:</p><ul class="spaceabove"><li class="li"><p><code>cr_ref</code>—reference count (used internally)</p></li><li class="li"><p><code>cr_uid</code>—user ID</p></li><li class="li"><p><code>cr_ngroups</code>—number of groups in <code>cr_groups</code></p></li><li class="li"><p><code>cr_groups[NGROUPS]</code>—list of groups to which the user belongs</p></li></ul><p>This structure has an internal reference counter to prevent unintentionally freeing the memory associated with it while it is still in use. For this reason, you should not indiscriminately copy this object but should instead either use <code><!--a-->crdup<!--/a--></code> to duplicate it or use <code><!--a-->crcopy<!--/a--></code> to duplicate it and (potentially) free the original. You should be sure to <code><!--a-->crfree<!--/a--></code> any copies you might make. You can also create a new, empty <code>ucred</code> structure with <code><!--a-->crget<!--/a--></code>.</p><p>The prototypes for these functions follow:</p><ul class="spaceabove"><li class="li"><p><code>struct ucred *crdup(struct ucred *cr)</code></p></li><li class="li"><p><code>struct ucred *crcopy(struct ucred *cr)</code></p></li><li class="li"><p><code>struct ucred *crget(void)</code></p></li><li class="li"><p><code>void crfree(struct ucred *cr)</code></p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP30000905-CH206-SW3" title="Note"></a><p><strong>Note:</strong>&nbsp;Functions for working with basic user credential are not exported outside of the kernel, and thus are not generally available to kernel extensions.</p></div><a name="//apple_ref/doc/uid/TP30000905-CH206-SW4" title="Access Control Lists"></a><h3>Access Control Lists</h3><p>Access control lists are a new feature in Mac OS X 10.4. Access control lists are primarily used in the file system portion of the Mac OS X kernel, and are supported through the use of the <code>kauth</code> API.</p><p>The kauth API is described in the header file <code>/System/Library/Frameworks/Kernel.framework/Headers/sys/kauth.h</code>. Because this API is still evolving, detailed documentation is not yet available.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-CDDBJFHC" title="Remote Authentication"></a><h2>Remote Authentication</h2><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_704"></a>
<p>This is one of the more difficult problems in computer security: the ability to identify someone connecting to a computer remotely. One of the most secure methods is the use of public key cryptography, which is described in more detail in <span class="content_text"><a href="security.html#//apple_ref/doc/uid/TP30000905-CH206-CDDHHEFC">“Key-based Authentication and Encryption.”</a></span> However, many other means of authentication are possible, with varying degrees of security.</p>
<p>Some other authentication schemes include:</p>
<ul class="ul"><li class="li"><p>blind trust</p></li>
<li class="li"><p>IP-only authentication</p></li>
<li class="li"><p>password (shared secret<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_705"></a>) authentication</p></li>
<li class="li"><p>combination of IP and password authentication</p></li>
<li class="li"><p>one-time pad<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_706"></a>s (challenge-response<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_707"></a>)</p></li>
<li class="li"><p>time-based authentication<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_708"></a></p></li></ul>
<p>Most of these are obvious, and require no further explanation. However, one-time pads and time-based authentication may be unfamiliar to many people outside security circles, and are thus worth mentioning in more detail.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF111" title="One-Time Pads"></a><h3>One-Time Pads</h3><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_709"></a>
<p>Based on the concept of “challenge-response” pairs, one-time pad (OTP) authentication requires that both parties have an identical list of pairs of numbers, words, symbols, or whatever, sorted by the first item. When trying to access a remote system, the remote system prompts the user with a challenge. The user finds the challenge in the first column, then sends back the matching response. Alternatively, this could be an automated exchange between two pieces of software.</p>
<p>For maximum security, no challenge should ever be issued twice. For this reason, and because these systems were initially implemented with a paper pad containing challenge-response, or CR pairs, such systems are often called one-time pads.</p>
<p>The one-time nature of OTP authentication makes it impossible for someone to guess the appropriate response to any one particular challenge by a brute force attack (by responding to that challenge repeatedly with different answers). Basically, the only way to break such a system, short of a lucky guess, is to actually know some portion of the contents of the list of pairs.</p>
<p>For this reason, one-time pads can be used over insecure communication channels. If someone snoops the communication, they can obtain that challenge-response pair. However, that information is of no use to them, since that particular challenge will never be issued again. (It does not even reduce the potential sample space for responses, since only the challenges must be unique.)</p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF112" title="Time-based authentication"></a><h3>Time-based authentication</h3><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_710"></a>
<p>This is probably the least understood means of authentication, though it is commonly used by such technologies as SecurID. The concept is relatively straightforward. You begin with a mathematical function that takes a small number of parameters (two, for example) and returns a new parameter. A good example of such a function is the function that generates the set of Fibonacci numbers (possibly truncated after a certain number of bits, with arbitrary initial seed values).</p>
<p>Take this function, and add a third parameter, <code>t</code>, representing time in units of <code>k</code> seconds. Make the function be a generating function on <code>t</code>, with two seed values, a and b, where</p>
<br/><div><img src = "../art/securityformula3.gif" alt = "image: ../art/securityformula3.gif" width="186" height="101"></div><br/>
<p>In other words, every <code>k</code> seconds, you calculate a new value based on the previous two and some equation. Then discard the oldest value, replacing it with the second oldest value, and replace the second oldest value with the value that you just generated.</p>
<p>As long as both ends have the same notion of the current time and the original two numbers, they can then calculate the most recently generated number and use this as a shared secret. Of course, if you are writing code that does this, you should use a closed form of this equation, since calculating Fibonacci numbers recursively without additional storage grows at <code>O(2^(t/k))</code>, which is not practical when <code>t</code> is measured in years and <code>k</code> is a small constant measured in seconds.</p>
<p>The security of such a scheme depends on various properties of the generator function, and the details of such a function are beyond the scope of this document. For more information, you should obtain an introductory text on cryptography,. such as Bruce Schneier’s <em>Applied Cryptography</em>.<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_711"></a></p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF113" title="Temporary Files"></a><h2>Temporary Files</h2><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_712"></a>
<p><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_713"></a>Temporary files are a major source of security headaches. If a program does not set permissions correctly and in the right order, this can provide a means for an attacker to arbitrarily modify or read these files. The security impact of such modifications depends on the contents of the files.</p>
<p>Temporary files are of much less concern to kernel programmers, since most kernel code does not use temporary files. Indeed, kernel code should generally not use files at all. However, many people programming in the kernel are doing so to facilitate the use of applications that may use temporary files. As such, this issue is worth noting.</p>
<p>The most common problem with temporary files is that it is often possible for a malicious third party to delete the temporary file and substitute a different one with relaxed permissions in its place. Depending on the contents of the file, this could range from being a minor inconvenience to being a relatively large security hole, particularly if the file contains a shell script that is about to be executed with the permissions of the program’s user.<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_714"></a></p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF114" title="/dev/mem  and  /dev/kmem"></a><h2><code>/dev/mem</code>  and  <code>/dev/kmem<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_715"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_716"></a></code></h2><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_717"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_718"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_719"></a>
<p>One<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_720"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_721"></a> particularly painful surprise to people doing security programming in most UNIX or UNIX-like environments is the existence of <code>/dev/mem</code> and <code>/dev/kmem</code>. These device files allow the <code>root</code> user to arbitrarily access the contents of physical memory and kernel memory, respectively. There is absolutely nothing you can do to prevent this. From a kernel perspective, root is omnipresent and omniscient. If this is a security concern for your program, then you should consider whether your program should be used on a system controlled by someone else and take the necessary precautions.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000905-CH206-SW5" title="Note"></a><p><strong>Note:</strong>&nbsp;Support for <code>/dev/kmem</code> is being phased out. It is not available on Intel-based Macintosh computers in Mac OS X v10.4. In the future, it will be removed entirely.</p>It is not possible to write device drivers that access PCI device memory through <code>/dev/mem</code> in Mac OS X. If you need to support such a driver, you must write a kernel stub driver that matches against the device and maps its memory space into the address space of the user process. For more information, read about user clients in <em><a href="../../../../DeviceDrivers/Conceptual/IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>.</p></div>
<a name="//apple_ref/doc/uid/TP30000905-CH206-CDDHHEFC" title="Key-based Authentication and Encryption"></a><h2>Key-based Authentication and Encryption</h2>
<p><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_722"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_723"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_724"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_725"></a>Key-based authentication and encryption are ostensibly some of the more secure means of authentication and encryption, and can exist in many forms. The most common forms are based upon a shared secret<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_726"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_727"></a>. The DES<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_728"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_729"></a>, 3DES (triple-DES)<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_730"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_731"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_732"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_733"></a>, IDEA<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_734"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_735"></a>, twofish<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_736"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_737"></a>, and blowfish ciphers<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_738"></a> <a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_739"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_740"></a>are examples of encryption schemes based on a shared secret. Passwords are an example of an authentication scheme based on a shared secret.</p>
<p>The idea behind most key-based encryption is that you have an encryption key of some arbitrary length that is used to encode the data, and that same key is used in the opposite manner (or in some cases, in the same manner) to decode the data.</p>
<p>The problem with shared secret security is that the initial key exchange must occur in a secure fashion. If the integrity of the key is compromised during transmission, the data integrity is lost. This is not a concern if the key can be generated ahead of time and placed at both transport endpoints in a secure fashion. However, in many cases, this is not possible or practical because the two endpoints (be they physical devices or system tasks) are controlled by different people or entities. Fortunately, an alternative exists, known as zero-knowledge proofs.</p>
<p>The concept of a zero-knowledge proof<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_741"></a> is that two seemingly arbitrary key values, x and y, are created, and that these values are related by some mathematical function ƒ in such a way that</p>
<div class="codesample"><table><tr><td scope="row"><pre>ƒ(ƒ(a,k1),k2) = a<span></span></pre></td></tr></table></div>
<p>That is, applying a well-known function to the original cleartext using the first key results in ciphertext which, when that same function is applied to the ciphertext using the second key returns the original data. This is also reversible, meaning that</p>
<div class="codesample"><table><tr><td scope="row"><pre>ƒ(ƒ(a,k2),k1) = a<span></span></pre></td></tr></table></div>
<p>If the function <code>f</code> is chosen correctly, it is extremely difficult to derive x from y and vice-versa, which would mean that there is no function that can easily transform the ciphertext back into the cleartext based upon the key used to encode it.</p>
<p>An example of this is to choose the mathematical function to be</p>
<div class="codesample"><table><tr><td scope="row"><pre>f(a,k)=((a*k) MOD 256) + ((a*k)/256)<span></span></pre></td></tr></table></div>
<p>where <code>a</code> is a byte of cleartext, and <code>k</code> is some key 8 bits in length. This is an extraordinarily weak cipher, since the function <code>f</code> allows you to easily determine one key from the other, but it is illustrative of the basic concept.</p>
<p>Pick <code>k1</code> to be <code>8</code> and <code>k2</code> to be <code>32</code>. So for <code>a=73</code>, <code>(a * 8)=584</code>. This takes two bytes, so add the bits in the high byte to the bits of the low byte, and you get <code>74</code>. Repeat this process with <code>32</code>. This gives you <code>2368</code>. Again, add the bits from the high byte to the bits of the low byte, and you have <code>73</code> again.</p>
<p>This mathematical concept (with very different functions), when put to practical use, is known as public key (PK) cryptography<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_742"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_743"></a>, and forms the basis for RSA<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_744"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_745"></a> and DSA<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_746"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_747"></a> encryption.<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_748"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_749"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_750"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_751"></a></p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF121" title="Public Key Weaknesses"></a><h3>Public Key Weaknesses</h3>
<p>Public key encryption can be very powerful when used properly. However, it has a number of inherent weaknesses. A complete explanation of these weaknesses is beyond the scope of this document. However, it is important that you understand these weaknesses at a high level to avoid falling into some common traps. Some commonly mentioned weakness of public key cryptography include:</p>
<ul class="spaceabove"><li class="li"><p>Trust model<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_752"></a> for key exchange</p></li>
<li class="li"><p>Pattern sensitivity<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_753"></a></p></li>
<li class="li"><p>Short data weakness<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_754"></a></p></li></ul>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF122" title="Trust Models"></a><h4>Trust Models</h4>
<p>The most commonly discussed weakness of public key cryptography is the initial key exchange<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_755"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_756"></a> process itself. If someone manages to intercept a key during the initial exchange, he or she could instead give you his or her own public key and intercept messages going to the intended party. This is known as a man-in-the-middle attack<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_757"></a>.</p>
<p>For such services as <code>ssh</code>, most people either manually copy the keys from one server to another or simply assume that the initial key exchange was successful. For most purposes, this is sufficient.</p>
<p>In particularly sensitive situations, however, this is not good enough. For this reason, there is a procedure known as <strong>key signing</strong><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_758"></a>. There are two basic models for key signing: the central authority model and the web of trust model.</p>
<p>The central authority model<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_759"></a> is straightforward. A central certifying agency signs a given key, and says that they believe the owner of the key is who he or she claims to be. If you trust that authority, then by association, you trust keys that the authority claims are valid.</p>
<p>The web of trust model<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_760"></a> is somewhat different. Instead of a central authority, individuals sign keys belonging to other individuals. By signing someone’s key, you are saying that you trust that the person is really who he or she claims to be and that you believe that the key really belongs to him or her. The methods you use for determining that trust will ultimately impact whether others trust your signatures to be valid.</p>
<p>There are many different ways of determining trust, and thus many groups have their own rules for who should and should not sign someone else’s key. Those rules are intended to make the trust level of a key depend on the trust level of the keys that have signed it.</p>
<p>The line between central authorities and web of trust models is not quite as clear-cut as you might think, however. Many central authorities are hierarchies of authorities, and in some cases, they are actually webs of trust among multiple authorities. Likewise, many webs of trust may include centralized repositories for keys. While those repositories don’t provide any certification of the keys, they do provide centralized access. Finally, centralized authorities can easily sign keys as part of a web of trust.</p>
<p>There are many websites that describe webs of trust and centralized certification schemes. A good general description of several such models can be found at <span class="content_text"><a href="http://world.std.com/~cme/html/web.html" target="_blank">http://world.std.com/~cme/html/web.html</a></span>.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF123" title="Sensitivity to Patterns and Short Messages"></a><h4>Sensitivity to Patterns and Short Messages</h4>
<p>Existing public key encryption algorithms do a good job at encrypting semi-random data. They fall short when encrypting data with certain patterns, as these patterns can inadvertently reveal information about the keys. The particular patterns depend on the encryption scheme. Inadvertently hitting such a pattern does not allow you to determine the private key. However, they can reduce the search space needed to decode a given message.</p>
<p>Short data weakness<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_761"></a> is closely related to pattern sensitivity<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_762"></a>. If the information you are encrypting consists of a single number, for example the number 1, you basically get a value that is closely related mathematically to the public key. If the intent is to make sure that only someone with the private key can get the original value, you have a problem.</p>
<p>In other words, public key encryption schemes <a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_763"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_764"></a>generally do not encrypt all patterns equally well. For this reason (and because public key cryptography tends to be slower than single key cryptography), public keys are almost never used to encrypt end-user data. Instead, they are used to encrypt a <strong>session key</strong><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_765"></a>. This session key is then used to encrypt the actual data using a shared secret mechanism such as 3DES<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_766"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_767"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_768"></a>, AES<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_769"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_770"></a>, blowfish<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_771"></a><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_772"></a>, and so on.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF117" title="Using Public Keys for Message Exchange"></a><h3>Using Public Keys for Message Exchange</h3>
<p>Public key cryptography<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_773"></a> can be used in many ways. When both keys are private, it can be used to send data back and forth. However this use is no more useful than a shared secret mechanism. In fact, it is frequently weaker, for the reasons mentioned earlier in the chapter. Public key cryptography becomes powerful when one key is made public.</p>
<p>Assume that Ernie and Bert want to send coded messages. Ernie gives Bert his public key. Assuming that the key was not intercepted and replaced with someone else’s key, Bert can now send data to Ernie securely, because data encrypted with the public key can only be decrypted with the private key (which only Ernie has).</p>
<p>Bert uses this mechanism to send a shared secret. Bert and Ernie can now communicate with each other using a shared secret mechanism, confident in the knowledge that no third party has intercepted that secret. Alternately, Bert could give Ernie his public key, and they could both encrypt data using each other’s public keys, or more commonly by using those public keys to encrypt a session key and encrypting the data with that session key.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF118" title="Using Public Keys for Identity Verification"></a><h3>Using Public Keys for Identity Verification</h3>
<p>Public key cryptography can also be used for verification of identity. Kyle wants to know if someone on the Internet who claims to be Stan is really Stan. A few months earlier, Stan handed Kyle his public key on a floppy disk. Thus, since Kyle already has Stan’s public key (and trusts the source of that key), he can now easily verify Stan’s identity.</p>
<p>To achieve this, Kyle sends a cleartext message and asks Stan to encrypt it. Stan encrypts it with his private key. Kyle then uses Stan’s public key to decode the ciphertext. If the resulting cleartext matches, then the person on the other end must be Stan (unless someone else has Stan’s private key).</p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF119" title="Using Public Keys for Data Integrity Checking"></a><h3>Using Public Keys for Data Integrity Checking</h3>
<p>Finally, public key cryptography can be used for signing<a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_774"></a>. Ahmed is in charge of meetings of a secret society called the Stupid Acronym Preventionists club. Abraham is a member of the club and gets a TIFF file containing a notice of their next meeting, passed on by way of a fellow member of the science club, Albert. Abraham is concerned, however, that the notice might have come from Bubba, who is trying to infiltrate the SAPs.</p>
<p>Ahmed, however, was one step ahead, and took a checksum of the original message and encrypted the checksum with his private key, and sent the encrypted checksum as an attachment. Abraham used Ahmed’s public key to decrypt the checksum, and found that the checksum did not match that of the actual document. He wisely avoided the meeting. Isaac, however, was tricked into revealing himself as a SAP because he didn’t remember to check the signature on the message.</p>
<p>The moral of this story? One should always beware of geeks sharing TIFFs—that is, if the security of some piece of data is important and if you do not have a direct, secure means of communication between two applications, computers, people, and so on, you must verify the authenticity of any communication using signatures, keys, or some other similar method. This may save your data and also save face.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF120" title="Encryption Summary"></a><h3>Encryption Summary</h3>
<p>Encryption is a powerful technique for keeping data secure if the initial key exchange occurs in a secure fashion. One means for this is to have a public key, stored in a well-known (and trusted) location. This allows for one-way encrypted communication through which a shared secret can be transferred for later two-way encrypted communication.</p>
<p>You can use encryption not only for protecting data, but also for verifying the authenticity of data by encrypting a checksum. You can also use it to verify the identity of a client by requiring that the client encrypt some random piece of data as proof that the client holds the appropriate encryption key.</p>
<p>Encryption, however, is not the final word in computer security. Because it depends on having some form of trusted key exchange, additional infrastructure is needed in order to achieve total security in environments where communication can be intercepted and modified.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF115" title="Console Debugging"></a><h2>Console Debugging</h2>
<div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/TP30000905-CH206-DontLinkElementID_10" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;

Failure to follow this advice can unintentionally expose security-critical information.</p><p></p><div class="clear"></div></div>
<p>In traditional UNIX and UNIX-like systems, the console is owned by root. Only root sees console messages. For this reason, print statements in the kernel are relatively secure.</p>
<p>In Mac OS X, any user can run the Console application. This represents a major departure from other UNIX-like systems. While it is never a good idea to include sensitive information in kernel debugging statements, it is particularly important not to do so in Mac OS X. You must assume that any information displayed to the console could potentially be read by any user on the system (since the console is virtualized in the form of a user-viewable window).</p>
<p>Printing any information involving sensitive data, including its location on disk or in memory, represents a security hole, however slight, and you should write your code accordingly. Obviously this is of less concern if that information is only printed when the user sets a debugging flag somewhere, but for normal use, printing potentially private information to the console is strongly discouraged.</p>
<p>You must also be careful not to inadvertently print information that you use for generating password hashes or encryption keys, such as seed values passed to a random number generator.</p>
<p>This is, by necessity, not a complete list of information to avoid printing to the console. You must use your own judgement when deciding whether a piece of information could be valuable if seen by a third party, and then decide if it is appropriate to print it to the console.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH206-TPXREF116" title="Code Passing"></a><h2>Code Passing</h2>
<p>There are many ways of passing executable code into the kernel from user space. For the purposes of this section, executable code is not limited to compiled object code. It includes any instructions passed into the kernel that significantly affect control flow. Examples of passed-in executable code range from simple rules such as the filtering code uploaded in many firewall designs to bytecode uploads for a SCSI card.</p>
<p>If it is possible to execute your code in user space, you should not even contemplate pushing code into the kernel. For the rare occasion where no other reasonable solution exists, however, you may need to pass some form of executable code into the kernel. This section explains some of the security ramifications of pushing code into the kernel and the level of verification needed to ensure consistent operation.</p>
<p>Here are some guidelines to minimize the potential for security holes:</p>
<ol class="ol"><li class="li"><p>No raw object code.</p><p>Direct execution of code passed in from user space is <em>very</em> dangerous. Interpreted languages are the only reasonable solution for this sort of problem, and even this is fraught with difficulty. Traditional machine code can’t be checked sufficiently to ensure security compliance.</p></li>
<li class="li"><p>Bounds checking.</p><p>Since you are in the kernel, you are responsible for making sure that any uploaded code does not randomly access memory and does not attempt to do direct hardware access. You would normally make this a feature of the language itself, restricting access to the data element on which the bytecode is operating.</p></li>
<li class="li"><p>Termination checking.</p><p>With very, very few exceptions, the language chosen should be limited to code that can be verified to terminate, and you should verify accordingly. If your driver is stuck in a tightly rolled loop, it is probably unable to do its job, and may impact overall system performance in the process. A language that does not allow (unbounded) loops (for example, allowing <code>for</code> but not <code>while</code> or <code>goto</code> could be one way to ensure termination.</p></li>
<li class="li"><p>Validity checking.</p><p>Your bytecode interpreter would be responsible for checking ahead for any potentially invalid operations and taking appropriate punitive actions against the uploaded code. For example, if uploaded code is allowed to do math, then proper protection must be in place to handle divide by zero errors.</p></li>
<li class="li"><p>Sanity checking.</p><p>You should verify that the output is something remotely reasonable, if possible. It is not always possible to verify that the output is correct, but it is generally possible to create rules that prevent egregiously invalid output.</p><p>For example, a network filter rule should output something resembling packets. If the checksums are bad, or if other information is missing or corrupt, clearly the uploaded code is faulty, and appropriate actions should be taken. It would be highly inappropriate for Mac OS X to send out bad network traffic.</p></li></ol>
<p>In general, the more restrictive the language set, the lower the security risk. For example, interpreting simple network routing policies is less likely to be a security problem than interpreting packet rewriting rules, which is less likely to be an issue than running Java bytecode in the kernel. As with anything else, you must carefully weigh the potential benefits against the potential drawbacks and make the best decision given the information available.</p>
<p></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Architecture/Architecture.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../performance/performance.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-11-07<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Conceptual/KernelProgramming/security/security.html%3Fid%3DTP30000905-5.7&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Conceptual/KernelProgramming/security/security.html%3Fid%3DTP30000905-5.7&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Conceptual/KernelProgramming/security/security.html%3Fid%3DTP30000905-5.7&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>