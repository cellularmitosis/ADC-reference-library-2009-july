<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1179: PostScript Output Filters for LaserWriter 8.7</title>       <meta name="keywords" content="Printing PostScript output filters LaserWriter 8 Mac OS 9">    <meta name="Description" content="Technical Note TN1179: have creator write a brief descriptionhere."><meta name="categories" content="Printing"><meta name="week-posted" content="Sep 27, 1999 - Oct 1, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003018" title="PostScript Output Filters for LaserWriter 8.7"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1179</div>
<div id="pageheadsub">PostScript Output Filters for LaserWriter 8.7</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">   <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>            <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <span id="menutitle">CONTENTS   <br>  <br> </span>   </td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <!-- begin_toc -->         <P id = "menutext">         <A HREF = "#Organization">Organization</A><br><br>                  <A HREF = "#FilterBasics">Filter Basics</A><br><br>                  <A HREF = "#FilterOutput">Filter Output APIs</A><br><br>                  <A HREF = "#UserInterface">User Interface APIs</A><br><br>                  <A HREF = "#SampleCode">Sample Code</A><br><br>                  <A HREF = "#Summary">Summary</A><br><br>         <A HREF = "#References">References</A><br><br>         <A HREF = "#Downloads">Downloadables</A><BR><BR>         <A HREF = "#AppendixA">Appendix A</A></p> <!-- end_toc --></td>  </tr>  <tr>   <td width=300 align=left scope="row"> <img src="images/tnmenubottom.gif" alt="" width=300 height=16>   </td>  </tr>    </table></td>  <td width=300 valign="top" align=left>            <!-- begin_intro_text --><p id = "introtext">LaserWriter 8 version 8.7 introduces the concept of PostScript output filters and their use during printing. PostScript output filters are code fragments that live in the data fork of files that reside within the "Printing Plug-ins" folder contained in the Extensions folder. These code fragments can intercept the PostScript output data stream generated by LaserWriter 8 and add, remove, or modify the data before it is transmitted to the output device. Through this type of modification, a PostScript output filter can implement customized control of features for a specific printer model or can implement new user features across a range of PostScript printers without requiring changes to LaserWriter 8. The remainder of this document refers to PostScript output filters as "filters" or "plug-ins."</p><p id = "introtext">In addition to filtering the PostScript output data stream, a filter can also present a user interface in the LaserWriter 8 Print Dialog for configuring the filter's print job parameters. The filter's user interface can consist of one or more panels with functionality similar to the built-in panels already present, including the ability to save different settings for each printer.</p>      <!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Oct 5 1999]</h3><!-- end_date --></TD> </TR>    </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content -->         <A NAME="Organization"></A>                  <H2>Organization</H2><BR>         <P>This document is organized into several major sections. The section <A HREF = "#FilterBasics">Filter Basics</A> discusses how filters work with LaserWriter 8. This includes discussion of the user interface for enabling and manipulating filters, information about the operation of a filter when it filters the PostScript output data, and what the user interface for a specific filter might look like.</p><P>The section <A HREF = "#FilterOutput">Filter Output APIs</A> discusses the filter routines that are called by LaserWriter 8 and PrintingLib as part of the generation of the PostScript language output. All filters implement at least one required routine; otherwise, the filter serves no useful purpose and is not given an opportunity to filter output.</p><P>The section <A HREF = "#UserInterface">User Interface APIs</A> discusses the filter routines that LaserWriter 8 calls as the user interacts with the Print Dialog.</p><P>The section <A HREF = "#SampleCode">Sample Code</A> discusses the two sample filters provided as part of this technote.</p><P><A HREF = "#AppendixA">Appendix A: PSPosition Data Details</A> provides detailed information about how the PostScript output data that filters receive is tagged.</P>      <p><A HREF = "#top">Back to top</a></p><BR>         <A NAME="FilterBasics"></A>                  <H2>Filter Basics</H2>         <H3>Basic User Interaction</H3><P>Users install filters in MacOS 8.5 and later by dragging them onto the System Folder. The file is autorouted to the "Printing Plug-ins" folder in the "Extensions" folder. When one or more filters is installed, the LaserWriter 8.7 Print Dialog adds a new panel titled "Plug-In Preferences" which displays all of the PostScript output filters contained in the "Printing Plug-ins" folder (see Figure 1 for an example). As with all of the LaserWriter 8 settings in the Print Dialog, the settings in this panel are saved on a printer-by-printer basis.</p><A NAME="Figure1"></A><center><img src="images/tn1179_001.gif" alt="Preferences Panel" width=505 height=315 align=middle><p align="center"><b>Figure 1 - The Plug-In Preferences Panel</b></p></center><P>Users can enable or disable each filter using the checkbox associated with that filter. By default, all filters are disabled for each printer. In addition to enabling and disabling each filter individually, users can disable all filters by unchecking the top-most checkbox labeled <b>Print Time Filters</b>. When this box is unchecked, all filter controls become inactive. Checking this box enables the controls for the filters but does not alter their on/off state. Each filter also has an information button, which brings up a modal dialog displaying filter version information and a textual description of the filter. The order of the filters in this panel can be altered by dragging the "gripper" at the left of the filter name. Filters execute in the order they are listed in this panel. The meaning of this order is described in the next section.</p><P>The set of active filters and the ordering of the filters affect the current print job. The user can save this set and order using the <b>Save Settings</b> button on the dialog. Doing this saves the set and order for the currently chosen desktop printer.</p><H3>Filter UI Basics</H3><P>A filter can have a user interface in the Print Dialog for controlling its settings. Once the filter is enabled in the Plug-In Preferences panel, LaserWriter 8 calls the exported routines, which control the filter's user interface. The filter can examine the conditions it is running under and determine whether LaserWriter 8 should display its user interface. A given filter can specify that its user interface be displayed in one or more panels.</p><P>The names in the panels menu are listed in three sections. The first section lists those panels which are built into LaserWriter 8. This is followed by a section of panels which correspond to printer-specific features for the current printer as specified by the PostScript Printer Description (PPD) file. The last section of the menu consists of any panels added by PostScript output filters. A given filter can add zero or more panels.</p><P>Figure 2 is a screen shot of the LaserWriter 8.7 Print Dialog with an output filter enabled that has one custom panel whose menu is titled "Sample Filter Settings." The menu item "Imaging Options" corresponds to a panel generated for the PostScript Printer Description (PPD) file for the current printer.</p><center><img src="images/tn1179_002.gif" alt="Print Dialog" width=505 height=315 align=middle><P><b>Figure 2 - The Print Dialog Panels Menu</b></p></center><P>Selecting the menu item corresponding to a filter's panel displays that panel. A simple example of a filter's panel is shown in Figure 3. A filter has control over the layout and look of the contents of the panel within the area between the panel popup menu and the line above the buttons at the bottom of the dialog. The filter handles the user interaction with its controls and saves its configuration into the print job data that is passed to it when it is filtering PostScript data. If the user clicks on the <b>Save Settings</b> button at the bottom left of the dialog, the filter saves its current settings as part of the default settings for that printer.</p><P>Details of the User Interface portion of the API for filters can be found in the section <A HREF = "#UserInterface">User Interface APIs</A> below.</p><center><img src="images/tn1179_003.gif" alt="Sample Filter" width=505 height=315 align=middle><p><B>Figure 3 - A Sample Filter Panel</b></p></center><p><A HREF = "#top">Back to top</a></p><BR>         <P><A NAME="FilterOutput"></A></P>                  <H2>Filter Output APIs</H2>         <P>This section describes the filter APIs that are called at the time a communication channel with a PostScript output device is established and during the emission of the PostScript data into the communication channel. This is the point where a filter plug-in actually has the chance to filter the PostScript output data. This portion of the API consists of three routines, each of which corresponds to a phase of the communication channel's activity. The remainder of this document will use the phrase "filter output execution" to refer to these parts of a filter's execution. The phrase "filter output routines" refers to these routines.</p><P>The first phase occurs when the communication channel is being opened and the chain of output filters is being constructed. At this point, a filter's <CODE>psOutputFilterPreFlight</CODE> routine is called to allow a filter to initialize itself. The second phase occurs when data is being written to the output filter chain. Each write to a PostScript output filter generates a call to a filter's <CODE>psOutputFilterWrite</CODE> routine. The final phase occurs when the communication channel to the output device is closed and the filter chain is torn down. At this point, a filter's <CODE>psOutputFilterPostFlight</CODE> routine is called to allow the filter to dispose of any memory it allocated during its operation. A filter is only required to export the routine <CODE>psOutputFilterWrite</CODE> in order to be added to the filter chain as it is being created; the other two routines are optional.</p>                 <H3>psOutputFilterPreFlight</H3><p>If a filter exports a <CODE>psOutputFilterPreFlight</CODE> routine, it is called as the filter chain is created for a print job, allowing the filter to initialize itself. It is not a required routine, although it is likely that most filters will implement and export this routine. This routine is called only once per print job. The prototype for this routine is:</p>                                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psOutputFilterPreFlight(PSOutputFilterRef filter,                Collection jobInfo, Handle papaH, void **refconP);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>    <LI><CODE>filter</CODE> is the <CODE>PSOutputFilterRef</CODE> corresponding to this filter. A <CODE>PSOutputFilterRef</CODE> is an opaque structure used to reference a given PostScript output filter. This reference is a parameter to several routines that a filter calls as part of its operation. </LI>    <LI><CODE>jobInfo</CODE> is a Collection Manager collection containing information about the print job which is in progress. (See the section <A HREF = "#References">References</A> for more information on the Collection Manager.) The <CODE>jobInfo</CODE> collection contains collection items that are used to configure the settings of the current print job. The collection items LaserWriter 8 uses are described by the header file "Hints.h" which is provided as part of the sample code. In addition to the collection items used for configuring the usual print job parameters, the <CODE>jobInfo</CODE> collection also contains any data that a filter's user interface provides. This is described in the section <A HREF = "#FilterJob">Filter Job Collection</A> below.</LI>    <LI><CODE>papaH</CODE> is a Handle to the <CODE><code>'PAPA'</code></CODE> data corresponding to the target output device. The SettingsLib library built into PrintingLib contains routines for obtaining information about the <code>'PAPA'</code> data. See the section <A HREF = "#References">References</A> for more information on the <code>'PAPA'</code> data and <CODE>SettingsLib</CODE>.</LI>    <LI><CODE>refconP</CODE> is a pointer to a <CODE>(void *)</CODE> parameter. A preflight routine can allocate its private data and return a pointer to that data in <CODE>*refconP</CODE>. This data will be passed to other filter output routines as they are called. This allows a filter to avoid having global data related to a print job.</LI></UL><P>The call to <CODE>psOutputFilterPreFlight()</CODE> can be used for several purposes. The <CODE>jobInfo</CODE> collection and <CODE>papaH</CODE> handle can be examined to determine whether a filter actually wants to operate for this print job and to configure the filter if it should. <CODE>psOutputFilterPreFlight()</CODE> is also the place to allocate private data for this print job.</P><P>If a filter exports the <CODE>psOutputFilterPreFlight</CODE> routine, this routine must return <CODE>noErr</CODE>; otherwise, the filter is not added to the filter chain. Returning an error from <CODE>psOutputFilterPreFlight()</CODE> does not affect the print job or any other filters; it just ensures that a filter does not run. If <CODE>psOutputFilterPreFlight()</CODE> returns an error, neither <CODE>psOutputFilterPostFlight()</CODE> nor <CODE>psOutputFilterWrite()</CODE> is called for this print job.</P><P>The <CODE>psOutputFilterPreFlight</CODE> routine is called before the communication channel with the output device is fully established. This means that no data can be written during execution of <CODE>psOutputFilterPreFlight()</CODE>. Because the communication channel isn't established and no job queries have been generated, the communication channel characteristics aren't fully known. Specifically, it is not known at this point whether binary communication is supported for this job. </P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The knowledge as to whether the communication channel supports <CODE>Clean7Bit</CODE>, <CODE>Clean8Bit</CODE>, or <CODE>Binary</CODE> communication isn't available until after any query job completes.</P></TD></TR></TABLE></CENTER><BR><BR><H3>psOutputFilterPostFlight</H3><P>The <CODE>psOutputFilterPostFlight</CODE> routine, if it is exported by a filter, is called as the filter chain is torn down at the end of the print job, and it allows the filter to dispose of any memory allocated during its preflight and filter output execution. It is not a required routine, although most filters will implement and export this routine. Any filter that allocates memory during a preflight routine should export this routine. The <CODE>psOutputFilterPostFlight</CODE> routine is called only once per print job and is called only if the <CODE>psOutputFilterPreFlight</CODE> routine returned <CODE>noErr</CODE>. The prototype for this routine is:</p>       <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psOutputFilterPostFlight(PSOutputFilterRef filter,     void *refcon);</pre></TD></TR></TABLE></CENTER><BR><BR>            <UL>    <LI><CODE>filter</CODE> is the <CODE>PSOutputFilterRef</CODE> corresponding to this filter. A <CODE>PSOutputFilterRef</CODE> is an opaque structure used to reference a given PostScript output filter.</LI>    <LI><CODE>refcon</CODE> is the data that was returned by the filter's <CODE>psOutputFilterPreFlight</CODE> routine. This data should be disposed of appropriately.</LI></UL><H3>psOutputFilterWrite</H3><P>A PostScript output filter must export a <CODE>psOutputFilterWrite</CODE> routine in order to be inserted into the chain of output filters. Once a filter is successfully in the chain of output filters, the <CODE>psOutputFilterWrite</CODE> routine is called for every write of PostScript data to the output filter. The <CODE>psOutputFilterWrite</CODE> routine must write the appropriate data to the next filter in the chain using the routine <CODE>psWriteNextFilter</CODE> which is exported by the shared library <CODE>PSUtilsLib</CODE> built into PrintingLib. This process will be described shortly.</P><P>The prototype for the <CODE>psOutputFilterWrite</CODE> routine that must be exported by a filter is:</P>  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psOutputFilterWrite(PSOutputFilterRef filter, void *refcon,     const void *data, long nBytes, const struct PSPosition *posP);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>filter</CODE> is the <CODE>PSOutputFilterRef</CODE> corresponding to this filter. A <CODE>PSOutputFilterRef</CODE> is an opaque structure used to reference a given PostScript output filter.</LI>    <LI><CODE>refcon</CODE> is the data that was returned by a filter's <CODE>psOutputFilterPreFlight</CODE> routine. If a filter has no <CODE>psOutputFilterPreFlight</CODE> routine, <CODE>refcon</CODE> is NULL. </LI>    <LI><CODE>data</CODE> is a pointer to the data that is being written to the filter. <CODE>data</CODE> may be NULL in some cases.</LI>    <LI><CODE>nBytes</CODE> is the number of bytes pointed to by data being written to the filter. <CODE>nBytes</CODE> may be <CODE>FLUSHWRITE (-1)</CODE> in some cases. </LI>    <LI><CODE>posP</CODE> is a pointer to a <CODE>PSPosition</CODE> structure that describes or tags the data passed to this invocation of <CODE>psOutputFilterWrite()</CODE>. The tagging of data and the <CODE>PSPosition</CODE> structure are described below in the section <A HREF = "#TaggedData">Tagged Data</A>.</LI></UL><P>The simplest thing a filter can do is to forward all PostScript data to the next filter in the chain. Doing only that would pass the data unmodified to the next filter and would insert no additional data. If all filters in the filter chain behaved like this, the PostScript output data sent to the output device would be unmodified and would be exactly the same as if there were no filters. </P><P>Another simple thing that a filter could do is to not pass any data to the next filter in the chain. If any filter in the filter chain fails to write a piece of data to the next filter, that data is not sent to the PostScript output device. Clearly, filters must carefully handle the data written to them or else the print job will produce incorrect results.</P><H3>psWriteNextFilter</H3><P>A filter writes data to the next filter in the chain by calling the <CODE>psWriteNextFilter</CODE> routine. This routine should only be called from a filter's <CODE>psOutputFilterWrite</CODE> routine. Its prototype is:</P>  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psWriteNextFilter(PSOutputFilterRef filter,     const void *data, long nBytes,     const struct PSPosition *posP);</pre></TD></TR></TABLE></CENTER><BR><BR>     <UL>    <LI><CODE>filter</CODE> is the <CODE>PSOutputFilterRef</CODE> corresponding to the filter calling <CODE>psWriteNextFilter()</CODE>. A <CODE>PSOutputFilterRef</CODE> is an opaque structure used to reference a given PostScript output filter.</LI>    <LI><CODE>data</CODE> is a pointer to the data to write to the next filter in the chain.</LI>    <LI><CODE>nBytes</CODE> is the number of bytes pointed to by data to write to the next filter. <CODE>nBytes</CODE> may be <CODE>FLUSHWRITE (-1)</CODE> if the filter is forwarding data passed to it from the previous filter.</LI>    <LI><CODE>posP</CODE> is a pointer to a <CODE>PSPosition</CODE> structure that describes or tags the data being passed to this invocation of <CODE>psWriteNextFilter()</CODE>. The tagging of data and the <CODE>PSPosition</CODE> structure are described below in the section <A HREF = "#TaggedData">Tagged Data</A>.</LI></UL><H3>Filtering Data</H3><P>There are a number of operations that a filter's <CODE>psOutputFilterWrite</CODE> routine might perform on a given call:</P><UL>    <LI>Pass the data on unaltered, without adding additional PostScript data to the output stream.</LI>    <LI>Insert data into the output stream before writing the data passed to it.</LI>    <LI>Insert data into the output stream after writing the data passed to it.</LI>    <LI>Ignore the data passed and not forward it to the next filter. Any piece of data not forwarded to the next filter is not sent to the PostScript output device.</LI>    <LI>Modify the data passed it prior to writing it to the next filter in the chain. Note that any modifications made to the data passed to a filter must be made to a copy of that data.</LI></UL><P>If a filter wants to omit PostScript from the stream, it should not call <CODE>psWriteNextFilter()</CODE> with that data but should instead return <CODE>noErr</CODE>. To add data to the stream, a filter calls <CODE>psWriteNextFilter()</CODE> with the data to be added to the stream. All of the scenarios listed above are demonstrated in the sample code provided with this technote and are described in the <A HREF = "#SampleCode">Sample Code</A> section below.</P><P>The most likely action taken by a filter is to insert data into the PostScript output stream at a certain point in the job stream; however, the filter output API is powerful enough to allow significant changes to the output stream as it is being filtered.</P><A NAME="TaggedData"></A><H3>Tagged Data</H3><P>A filter receives PostScript output as the data parameter passed to its <CODE>psOutputFilterWrite</CODE> routine. Without any additional information, a filter would have to parse this data to determine its contents. To reduce or eliminate the need to parse data, the parameter <CODE>posP</CODE> is also passed in. This parameter is a pointer to a <CODE>PSPosition</CODE> structure containing tagging information that describes this data.</P><H3>PSPosition Structure</H3><P>A <CODE>PSPosition</CODE> structure allows generators of PostScript output to communicate structural information about the data they are writing. When PostScript generators properly use the <CODE>PSPosition</CODE> structure, it allows software clients to acquire knowledge of the data being written, without them having to parse the PostScript data. An example of this is the way the LaserWriter 8 driver reports status during printing by looking at the <CODE>PSPosition</CODE> data written to the output stream by the PrintingLib routines which convert QuickDraw drawing into PostScript data. Another example is the status that the Download Manager and its clients report as a low-level converter module generates its PostScript data. (The Download Manager is discussed further in the section <A HREF = "#PrintingWithout">Printing Without A Print Dialog</A> and in the section <A HREF = "#References">References</A>.) This tagging information is loosely designed around Adobe's PostScript Document Structuring Conventions (DSC) comments.</P><P>The PSPosition structure is defined as: </P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct PSPosition{    /// The section of the document the caller is currently emitting.    PSSection section;    /// The subsection of the document the caller is currently emitting.    PSSubsection subsection;    /// More information about the current section:subsection    void *info;    /// A numeric identifier for this PSPosition    SInt32 id;  }PSPosition;</pre></TD></TR></TABLE></CENTER><BR><BR> <P>The <B>section</B> field is of type <CODE>PSSection</CODE> and identifies what "major" part of the job is in progress. The values of this field can be <CODE>kSectAnon</CODE>, <CODE>kSectQueryJob</CODE>, <CODE>kSectCoverPage</CODE>, <CODE>kSectJob</CODE>, and <CODE>kSectPeek</CODE>. These sections correspond to the different parts of the job, as controlled by the PostScript generator, typically LaserWriter 8 PrintingLib. </P><P>The <B>subsection</B> field is of type <CODE>PSSubsection</CODE> and details the PostScript output corresponding to the data write call. <CODE>PSSubsection</CODE> values typically correspond to DSC data, but there are additional values which suit some specialized needs. </P><P>The <B>info</B> field is either a <CODE>NULL</CODE> pointer or a pointer to data whose type is specified for the <CODE>PSSubsection</CODE> value in the subsection field. The data (if any) pointed to by the info value coincides with the data being written to the output stream. </P><P>For example, when writing the data "%%Pages: 4" to the print stream, the writer puts the <CODE>PSSubsection</CODE> value <CODE>kSubPages</CODE> into the subsection field of the <CODE>PSPosition</CODE>, and the info field is either <CODE>NULL</CODE> or points to an <CODE>SInt32</CODE> with the value 4. <A HREF = "#AppendixA">Appendix A: PSPosition Data Details</A> discusses the possible <CODE>PSSubsection</CODE> values and their corresponding info fields in more detail. The header file "PSStreamInfo.h" contains the list of <CODE>PSSubsection</CODE> values and the proper data type of the info field for each <CODE>PSSubsection</CODE>.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The <CODE>SectionReport</CODE> filter provided in the Sample Code portion of this document generates a report of the <CODE>PSPosition</CODE> info data generated as part of each print job.</P></TD></TR></TABLE></CENTER><BR><BR><P>The <B>ID</B> field is an <CODE>SInt32</CODE>. This is used by PostScript generators to emit output for a given subsection over a series of writes, yet still identify the data as one conceptual block of data. This is done by performing the consecutive writes with the same subsection, info, and ID values. When the data being written corresponds to a new subsection, the ID value is then updated. Doing writes in this fashion allows software clients looking at the ID field to notice when the <CODE>PSPosition</CODE> data may have changed without having to look at any other fields in the structure. For example, a client (such as the LaserWriter 8 status code) monitoring the position information being written to the stream has a test similar to the following: </P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>if(jobstatus-&#62;lastPosId != positionP-&#62;id ){    ... process the new position we are now seeing    ...    // update the our notion of the last position we saw    jobstatus-&#62;lastPosId = positionP-&#62;id;   }</pre></TD></TR></TABLE></CENTER><BR><BR><P>The ID field of the <CODE>PSPosition</CODE> is of particular importance to filter writers. Frequently a filter wants to inject some data before or after a particular point in the PostScript output stream. Such data should never be injected into the middle of a sequence of data writes corresponding to the same <CODE>PSPosition</CODE>. For this reason, it is important to track the ID field appropriately. This issue is addressed in detail by the sample filters provided as part of this technote.</P><H3>psFilterSetPSPosition</H3><P>Filters frequently inject new data into the PostScript output stream and, when doing so, they call the <CODE>psWriteNextFilter</CODE> routine exported by the <CODE>PSUtilsLib</CODE> library in PrintingLib. Careful readers will note that the <CODE>psWriteNextFilter</CODE> routine also takes a pointer to a <CODE>PSPosition</CODE> structure. When forwarding existing data passed to a filter, the <CODE>PSPosition</CODE> structure should also be forwarded. However, if a filter is adding or modifying data, it needs to reflect the new data by properly providing a <CODE>PSPosition</CODE> structure that describes this new data. In almost all cases, the data has the same <CODE>PSSection</CODE> value as the original data write but it may correspond to a different PSSubsection value and therefore to different info data and ID values.</P><P>When inserting data into the PostScript output stream, it is important that the <CODE>PSPosition</CODE> used to tag the data be uniquely identified; otherwise, filters later in the chain and other portions of the output communication code can confuse newly inserted data with other data. To create unique PSPosition data, filters use the <CODE>PSUtilsLib</CODE> routine <CODE>psFilterSetPSPosition</CODE>. This routine is defined as:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psFilterSetPSPosition(PSOutputFilterRef filter,     PSPosition *posP,     PSSection section,     PSSubsection subsection,     void *info);</pre></TD></TR></TABLE></CENTER><BR><BR><P>This function is used by an output filter to prepare a <CODE>PSPosition</CODE> structure for writing a new piece of data corresponding to a new section, subsection, and/or info data. <CODE>psFilterSetPSPosition()</CODE> sets the <CODE>PSPosition</CODE> pointed to by <CODE>posP</CODE> to the section, subsection, and info data passed in, and sets the ID field in the <CODE>PSPosition</CODE> structure to a unique value in preparation for a filter write (or sequence of writes) corresponding to the new subsection/info value. Filters must use this routine to identify the data that they write as new and unique.</P><A NAME="FilterJob"></A><H3>Filter Job Collection</H3><P>It is likely that the features supported by a PostScript output filter will have a user interface associated with those features. The user interface programming interface for filters is described in detail in the section <A HREF = "#UserInterface">User Interface APIs</A>. The user interface code can store settings into the job collection which is passed as the <CODE>jobInfo</CODE> collection to <CODE>psOutputFilterPreFlight()</CODE>. This discussion does not apply to filters without any user interface or job specific settings.</p><P>To avoid conflicts between filters, the user interface code requires each filter to have a unique 4-byte signature. (This signature is not necessarily the same as the Finder creator for the plug-in, but it can be.) The user interface code uses this signature to ensure that a filter's UI settings are saved as a unique collection item in the <CODE>jobInfo</CODE> collection. Specifically, each filter has its own private Collection Manager collection in which to store the job settings from its UI code. The LaserWriter 8 Print Dialog code stores each filter's private collection as a flattened handle into the job collection with the collection tag value <CODE>kHintPlugInCollTag</CODE> and uses the filter's unique 4-byte signature as the collection ID.</P><P>To extract its settings at filter output execution time, the filter must obtain its flattened collection from the jobInfo collection passed to <CODE>psOutputFilterPreFlight()</CODE>, and then the collection must be unflattened. At that point, the filter can access any collection items it may have stored in its private collection. The sample code provided with this technote demonstrates the way to store settings in the user interface code and how to extract them at filter output execution time.</P><H3>General Considerations During Filtering</H3><P>Filters must always be careful to pass any errors returned from their filter writes back to their caller. By doing so, any errors generated during the filter operation bubble back up the filter chain and back to the software initiating the write of the PostScript output. If a filter fails to do so, errors will be lost; this can have many undesirable results.</P><P>A filter must be well behaved should any data that it is expecting in the output stream not be present. There are a number of reasons why the data passed to a filter might differ from what is normally expected. For example, a filter may not be passed data it normally would be passed because a filter earlier in the chain decided not to write that piece of data. A situation where a filter may see data that is unexpected is when the Download Manager is generating the PostScript output data. The PostScript data generated by the Download Manager and its plug-ins can differ significantly from that generated by LaserWriter 8 for standard print jobs. </P><P>It is most likely that a filter would use the <CODE>PSPosition</CODE> data passed to the <CODE>psOutputFilterWrite</CODE> routine to determine what the data is; however, a filter is free to parse the data passed in, should that be appropriate to a filter's function. Note, however, that for some writes to a filter, the data parameter passed to <CODE>psOutputFilterWrite()</CODE> may be <CODE>NULL</CODE>. Filters must be careful to skip parsing of the data in this situation.Similarly, there are cases where the <CODE>nBytes</CODE> parameter passed to <CODE>psOutputFilterWrite()</CODE> is negative. Not only must filters detect this and avoid parsing data in this case, but it is important to detect the case where the <CODE>nBytes</CODE> parameter is the constant <CODE>FLUSHWRITE (-1)</CODE>, since such writes must always be forwarded to the next filter and any errors returned appropriately.</P><P>During filter output execution, filters have no direct way to give up time to other processes on the system; their only way to give up time is to call <CODE>psWriteNextFilter()</CODE> which ultimately calls the printing application's idle procedure. Filters must limit the amount of time they spend inside a given call to <CODE>psOutputFilterWrite()</CODE> so that the user's interactivity with their computer during printing is maintained. Filters aren't appropriate for computationally intensive tasks or for tasks which require gathering large amounts of data over a network connection.</P><P>Some filters may want to modify the PostScript data passed to them. If a filter wants to modify the data before writing it to the next filter, it must first copy the data passed to it and modify its copy of the data. </P><a name="FilterPlugin"></a><H3>Filter Plug-In Requirements</H3><P>LaserWriter 8 uses the Printing Plug-ins Manager to manage PostScript output filters. In order to be used with the Printing Plug-ins Manager, a filter must have a resource of type <CODE>kPluginResourceInfoType</CODE> and ID <CODE>kPluginResourceInfoID</CODE>. If the filter does not contain this resource, it cannot be used and is ignored. Filters are also required to have a standard <CODE>'cfrg'</CODE> resource describing the code fragments in the data fork of the file.</P><P>The <CODE>kPluginResourceInfoType</CODE> resource contains information about how many shared libraries are contained in the file, and, for each shared library, the type of plug-in that it is, the subtype that the library handles and the library name. PostScript filters have the type field of this resource set to <CODE>kPSOutputFilterPlugInType</CODE> and the subtype set to <CODE>kPSOutputFilterSubtype</CODE>. Note that the type referred to here is not the Finder type but the field of the <CODE>kPluginResourceInfoType</CODE> resource. There are no constraints on the library name beyond those imposed by the Code Fragment Manager.</P><P>The <CODE>kPluginResourceInfoType</CODE> resource is defined as follows (using Rez syntax):</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>type 'PLGN' {   integer = $$Countof(PluginLibInfo);   array PluginLibInfo {    literal longint;   /* Type */    literal longint;   /* subtype */    pstring;           /* library name */    align word;   };  };</pre></TD></TR></TABLE></CENTER><BR><BR>          <P>A ResEdit Resourcerer&#174; template resource (<CODE>'tMPL'</CODE>) for the <CODE>kPluginResourceInfoType</CODE> resource is contained within PrintingLib versions 8.6 and later.</P><P>The <CODE>PluginLibInfo</CODE> structure in C syntax is:</P>  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>  typedef OSType SettingsDataType;  typedef OSType SettingsDataSubType;  short num; // the number of shared libraries this 'PLGN' describes  PluginLibInfo libInfo[num];  typedef struct PluginLibInfo{   SettingsDataType      type;   SettingsDataSubType   subtype;   unsigned char         libraryName[];  // pascal string                                         // word aligned  }PluginLibInfo;</pre></TD></TR></TABLE></CENTER><BR><BR>  <UL>    <LI><CODE>type</CODE> is the type of plug-in that is described by this <CODE>PluginLibInfo</CODE>.</LI>    <LI><CODE>subtype</CODE> is the subtype of data that can be handled by the plug-in described by this <CODE>PluginLibInfo</CODE>.</LI>    <LI><CODE>libraryName</CODE> is the library name of the code fragment in the plug-in file described by this <CODE>PluginLibInfo</CODE>.</LI></UL>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>A single file can contain multiple plug-in libraries. Because of this, the <CODE>libraryName</CODE> provided in the <CODE>kPluginResourceInfoType</CODE> resource is the name shown for a PostScript output filter in the Plug-In Preferences panel in the Print Dialog (<A HREF = "#Figure1">Figure 1</A>).              </P></TD></TR></TABLE></CENTER><BR><BR><H3>Printing Plug-ins Folder</H3><P>As described earlier, filter plug-ins for LaserWriter 8.7 reside in the "Printing Plug-ins" folder in the Extensions folder. It is recommended that these plug-ins have a Finder type of <CODE>'bird'</CODE> since files of this type are autorouted on most recent system configurations. The system configurations which support auto-routing for the <CODE>'bird'</CODE> file type are MacOS 8.5 and later with PrintingLib 8.6.5 or later installed and Desktop Printing enabled. For these systems, the "Printing Plug-ins" folder is known to the Folder Manager as type <CODE>'pplg'</CODE>.</P><P>For those systems where the Folder Manager does not recognize the "Printing Plug-ins" folder, the Printing Plug-ins Manager provides routines for obtaining the name and location of the folder. See the section <A HREF = "#References">References</A> for information on the Printing Plug-ins Manager.</P>      <p><A HREF = "#top">Back to top</a></p><BR><A NAME="UserInterface"></A><H2>User Interface APIs</H2><P>This section describes the User Interface portion of a filter's API and relates only to the filter's execution while the Print Dialog box is displayed to the user. This aspect of the filter's execution will be referred to here as the "filter UI execution." Some filters do not have a user interface in the Print Dialog, and this section does not apply to them.</p><P>The UI APIs break down into a few general categories:</p><P><B>Criteria routines</B>: <CODE>psPanelSetCriteria</CODE> and <CODE>psPanelPlugInLibKeepRunning</CODE>. <CODE>psPanelSetCriteria()</CODE> allows a filter to set criteria as to when to run. If a filter is enabled by the user but the <CODE>psPanelSetCriteria</CODE> routine indicates a filter should not run, the remaining routines listed here are not executed. The <CODE>psPanelPlugInLibKeepRunning</CODE> routine allows a running filter to determine whether to continue running if the user switches printers in the Print Dialog. </p><P><B>Plug-in initialization and finalization routines</B>: <CODE>psPanelPlugInLibInitData</CODE> and <CODE>psPanelPlugInLibCloseData</CODE>. The <CODE>psPanelPlugInLibInitData</CODE> routine allows a filter to register its unique signature with the LaserWriter 8 Print Dialog code and to initialize itself. The <CODE>psPanelPlugInLibCloseData</CODE> routine allows a filter to clean up before it is unloaded. </p><P><B>Panel registration routines</B>: <CODE>psPanelRegister</CODE> and <CODE>psPanelAddMenu</CODE>. <CODE>psPanelRegister()</CODE> allows a filter to register one or more panels to appear in the Print Dialog, and <CODE>psPanelAddMenu()</CODE> specifies a menu name for each panel that is registered.</p><P><B>Panel-specific routines that are called for each panel, independent of the panel's visibility</B>: <CODE>psPanelInitData</CODE>, <CODE>psPanelPrSpecificInitData</CODE>, <CODE>psPanelPrSpecificCloseData</CODE>, and <CODE>psPanelCloseData</CODE>. These routines allow a filter to properly initialize and dispose of its panel-specific data, some of which may be related to a given printer and some of which may not.</P><P>The routines containing "<CODE>PrSpecific</CODE>" in their name are called for the initially selected printer and again when the user changes from one printer to another in the Print Dialog.</p><P>Panel-specific routines that are called when a panel becomes visible or was visible and goes away: <CODE>psPanelInit</CODE>, <CODE>psPanelPrSpecificInit</CODE>, <CODE>psPanelPrSpecificClose</CODE>, and <CODE>psPanelClose</CODE>. These routines allow a filter to set the user interface items in a panel to reflect the underlying data settings. The routines containing "<CODE>PrSpecific</CODE>" in their name are called for the initially selected printer and again when the user changes from one printer to another while the panel is visible. </p><P>Routines called during user interaction with a given panel: <CODE>psPanelItem</CODE> and <CODE>psPanelFilter</CODE>. <CODE>psPanelItem()</CODE> is called when the user clicks on an item in a filter's panel. <CODE>psPanelFilter()</CODE> is called from LaserWriter 8's Print Dialog filter function when the user interacts with a filter's panel.</p><P>A routine that is called to check data ranges for a panel: <CODE>psPanelCheckRange</CODE>. <CODE>psPanelCheckRange()</CODE> is called when the panel is about to go away (e.g., the user switches between panels or the Print Dialog is about to go away) or the user clicks the <b>Save Settings</b> button. This routine allows a filter to verify its settings before they are saved or the panel UI is going to go away.</p><P>A routine that is called when the user wants to save defaults: <CODE>psPanelSaveButton</CODE>. When the user chooses "Save Settings", a filter's <CODE>psPanelSaveButton</CODE> procedure is called, regardless of whether or not the filter's panel is visible.</p>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  These routines are only called when the LaserWriter 8.7 Print Dialog is present. They are not called during filter output execution.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The UI API routines described here are not necessarily called for all print jobs. See the section <A HREF = "#PrintingWithout">Printing Without a Print Dialog</A> which describes how this can happen.</P></TD></TR></TABLE></CENTER><BR><BR><H3>psPanelSetCriteria</H3><P>Filters can set criteria that LaserWriter 8 uses to determine whether to run that filter's user interface by providing a <CODE>psPanelSetCriteria</CODE> routine. The prototype for the <CODE>psPanelSetCriteria</CODE> routine is:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelSetCriteria(LWRef lwRef, Collection col,short resFRef);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>col</CODE> is a collection that may be filled in with the filter's running criteria.</li>    <LI><CODE>resFRef</CODE> is the <CODE>fRef</CODE> corresponding to the filter's resource fork. </li></UL><P>A given filter can specify certain criteria to determine whether it should be run. </P><P>There currently are two criteria that can optionally be specified:</P><P>The <CODE>PCFileName</CODE> of a target PPD file that must be the current PPD file for the target printer. For example, if a filter requires that the <CODE>*PCFileName</CODE> main keyword in the PPD file must have the value "APLW320.PPD", the filter can specify this requirement by adding a collection item with tag value <CODE>kHintPanelPCFileNameTag</CODE> and ID <CODE>kHintPanelPCFileNameId</CODE> with the data "APLW320.PPD" and a data length of 11 bytes.</P><P>The minimum LaserWriter driver version that a filter requires. This criteria is really for future expandability since the only LaserWriter driver version as of this writing which supports PostScript output filter plug-ins is LaserWriter 8.7. This requirement is specified with the collection item tag, ID given by <CODE>kHintPanelDriverVersTag</CODE> and <CODE>kHintPanelDriverVersId</CODE>.</P><P>Failure to add either or both of these collection items is equivalent to saying that these criteria are not important for that filter. For example, the sample code does not specify the <CODE>kHintPanelPCFileNameTag</CODE> since it does not restrict itself to a specific PPD. This ability is intended to allow printer manufacturers to target a filter to a specific hardware product.</P><P>The <CODE>psPanelSetCriteria</CODE> routine is called before any other filter routine except for any CFM shared library initialization routine a plug-in has.</P><H3>psPanelPlugInLibKeepRunning</H3><P>If the user changes printers while a given filter is loaded and running and the defaults for the new printer indicate the filter is enabled, that filter's <CODE>psPanelPlugInLibKeepRunning</CODE> routine is called to allow it to determine whether to continue running. This routine allows the plug-in to look at the current execution environment to determine whether to continue to run.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelPlugInLibKeepRunning(LWRef lwRef,Collection col,Boolean *keepRunningP,void *libDataP);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>col</CODE> is a collection containing items specifying the PPD <CODE>*PCFileName</CODE> and driver version. The meaning of these collection items is identical to those discussed in the description of <CODE>psPanelSetCriteria()</CODE>.</li>    <LI><CODE>keepRunningP</CODE> is a pointer to a <CODE>Boolean</CODE>. The value returned in <CODE>*keepRunningP</CODE> determines whether a filter wishes to continue to run.</li>    <LI><CODE>libDataP</CODE> points to the library private data returned by the plug-in's <CODE>psPanelPlugInLibInitData</CODE> routine (discussed below). Note that <CODE>psPanelPlugInLibKeepRunning()</CODE> is only called when a filter is already loaded and running. Therefore its <CODE>psPanelPlugInLibInitData</CODE> routine has already been called and the <CODE>libDataP</CODE> data exists.</li></UL>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The <CODE>col</CODE> collection parameter may or may not contain any specific collection item. As with all collections provided to the any of the filter APIs, a filter must be prepared that a given collection item will not exist and <CODE>GetCollectionItem()</CODE> or <CODE>GetCollectionItemHdl()</CODE> will return <CODE>collectionItemNotFoundErr</CODE>.</P></TD></TR></TABLE></CENTER><BR><BR><H3>psPanelPlugInLibInitData</H3><P>The LaserWriter 8 Print Dialog code calls a filter's <CODE>psPanelPlugInLibInitData</CODE> routine once after a filter has been loaded for use in the Print Dialog. A filter returns its unique 4-byte signature and can initialize itself.</P>          <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelPlugInLibInitData(LWRef lwRef, void **libDataH,short resFRef, unsigned long *libSignatureP);</pre></TD></TR></TABLE></CENTER><BR><BR>                <UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>libDataH</CODE> is a pointer to a (void *) that can be filled in with any library specific data. The data returned in <CODE>*libDataH</CODE> will be passed to the <CODE>psPanelRegister</CODE>, <CODE>psPanelPlugInLibKeepRunning</CODE>, and <CODE>psPanelPlugInLibCloseData</CODE> procedures.</li>    <LI><CODE>resFRef</CODE> is the <CODE>fRef</CODE> of the library's open resource fork. </li></UL>   <P><CODE>libSignatureP</CODE> must be filled in with the filter's unique 4-byte signature. This signature must be unique to the plug-in to distinguish it from other plug-ins. It is used to store a filter's private hints collection into the job collection and printer defaults collection.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                 Filter signatures must be unique or else a filter may conflict with another filter with the same signature (as described in the section <A HREF = "#FilterPrivate">Filter Private Collection Issues</A>). To ensure that a filter has a unique signature, it is necessary that developers register the 4-byte signature using the standard method for registering Finder creator codes. See the section <A HREF = "#References">References</A> for Apple's Creator Code Registration web page.               </P></TD></TR></TABLE></CENTER><BR><BR><H3>psPanelPlugInLibCloseData</H3><P>The LaserWriter 8 Print Dialog code calls a filter's <CODE>psPanelPlugInLibCloseData</CODE> routine immediately before the plug-in is unloaded by the Print Dialog. The filter can be unloaded for several reasons: the Print Dialog is going away, the user has switched printers and this filter is not enabled for the new printer, or the filter's <CODE>psPanelPlugInLibKeepRunning</CODE> routine indicates it should no longer run.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>void psPanelPlugInLibCloseData(LWRef lwRef, void *libDataP,Collection jobInfo, Boolean *doItP);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>libDataP</CODE> is a pointer to the filter data returned by <CODE>psPanelPlugInLibInitData()</CODE> in its <CODE>*libDataH</CODE> parameter.</li>    <LI><CODE>jobInfo</CODE> is the fully formed job collection representing the user settings from the Print Dialog. This collection is not the private collection containing only the filter's collection items added during its execution, but is instead the full job collection containing all the job configuration data specified in the Print Dialog.</li>    <LI><CODE>doItP</CODE> is a pointer to a <CODE>Boolean</CODE> indicating the reason for unloading the filter. If <CODE>*doItP</CODE> is <CODE>true</CODE>, the library is being unloaded because the user clicked on the <b>Print</b> or <b>Save</b> button to dismiss the Print Dialog. If <CODE>*doItP</CODE> is <CODE>false</CODE>, the filter is being unloaded for other reasons. A filter can change the value in <CODE>*doItP</CODE> to <CODE>false</CODE> to cause the dialog to be canceled if that is appropriate. A filter might change the value in <CODE>*doItP</CODE> in response to an alert the filter presents while the dialog is going away. The sample code provided with this technote demonstrates this.</li></UL><H3>psPanelRegister</H3><P>Once a filter's criteria have been passed, the filter is loaded and has the opportunity to add one or more panels to the Print Dialog. To accomplish this, LaserWriter 8 calls the filter's <CODE>psPanelRegister</CODE> routine repeatedly until the filter indicates it wants to stop adding panels. This routine also requires a filter to specify the data needed for each panel.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelRegister(LWRef lwRef, PanelRef panelRef,Collection col, Boolean *addPanelP,const Rect *panelRectP, short *ditlIDP,Handle *ditlHP, void **dataH, void *libDataP);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is a unique <CODE>PanelRef</CODE> corresponding to this call of <CODE>psPanelRegister()</CODE>. This allows a plug-in with multiple panels to distinguish which panel is being referenced by a given routine call, such as <CODE>psPanelAddMenu()</CODE>. </li>    <LI><CODE>col</CODE> is a collection specifying the current PPD <CODE>*PCFileName</CODE> and driver version as described above for the routine <CODE>psPanelPlugInLibKeepRunning</CODE>.  </li>    <LI><CODE>addPanelP</CODE> points to a <CODE>Boolean</CODE>. A filter should set <CODE>*addPanelP</CODE> to <CODE>true</CODE> if it wishes to add this panel. If a filter sets <CODE>*addPanelP</CODE> to <CODE>true</CODE>, the panel is added and <CODE>psPanelRegister()</CODE> is called again to see whether to add additional panels. When the filter is done adding panels, it should set <CODE>*addPanelP</CODE> to <CODE>false</CODE>. </li>    <LI><CODE>panelRectP</CODE> points to a <CODE>Rect</CODE> that contains the bounds of the area that a panel has available for any dialog items that a filter may be adding dynamically. The panel's supplied <CODE>DITL</CODE> (0,0) coordinate is mapped by LaserWriter 8 to the left, top corner of this <CODE>Rect</CODE>.</li>    <LI><CODE>ditlIDP</CODE> is a pointer to a <CODE>DITL</CODE> ID corresponding to the <CODE>DITL</CODE> for the panel being added. If the <CODE>DITL</CODE> for the panel corresponding to <CODE>panelRef</CODE> is being specified by a <CODE>DITL</CODE> ID, <CODE>*ditlIDP</CODE> should be set to the <CODE>DITL</CODE> ID for this <CODE>panelRef</CODE>. If the <CODE>DITL</CODE> is being specified directly as an in memory handle instead, <CODE>*ditlIDP</CODE> should not be changed.</li>    <LI><CODE>ditlHP</CODE> is a pointer to a <CODE>Handle</CODE> corresponding to the <CODE>DITL</CODE> for the panel being added. If the <CODE>DITL</CODE> is being specified directly as an in memory handle, a filter should set <CODE>*ditlHP</CODE> to the handle corresponding to the <CODE>DITL</CODE> for this <CODE>panelRef</CODE>. If instead the filter is specifying a <CODE>DITL</CODE> ID in <CODE>*ditlIDP</CODE>, <CODE>*ditlHP</CODE> should not be changed.</li>    <LI><CODE>dataH</CODE> is a pointer to a (<CODE>void *</CODE>) that can be filled in with any panel-specific data appropriate for this <CODE>panelRef</CODE>. It is frequently convenient to allocate private data for each panel. A panel should return any private data it allocates for this <CODE>panelRef</CODE> in <CODE>*dataH</CODE>. This private panel data is passed to each of the routines that are specific to a given panel.</li>    <LI><CODE>libDataP</CODE> is the filter's private data as returned in <CODE>*libDataH</CODE> by <CODE>psPanelPlugInLibInitData()</CODE>.</li></UL><H3>psPanelAddMenu</H3><p align="center">The LaserWriter 8 Print Dialog code calls <CODE>psPanelAddMenu()</CODE> for each panel that a filter adds. It is called when the panel menu gets built the first time, and each time the printer is changed and the filter continues to run.</p>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelAddMenu(LWRef lwRef, PanelRef panelRef,void *dataP, StringPtr panelName,unsigned long bufSize, Boolean *addItP); </pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>.</li>    <LI><CODE>panelName</CODE> is a pointer to a buffer to receive the text specifying the name for the panel menu item. A filter should fill in <CODE>panelName</CODE> with a Pascal string corresponding to the menu name. It should store at most <CODE>bufSize</CODE> bytes in this buffer, including the length byte.</li>    <LI><CODE>bufSize</CODE> is the length of the <CODE>panelName</CODE> buffer. A filter should never store more than this number of bytes into the <CODE>panelName</CODE> buffer. </li>    <LI><CODE>addItP</CODE> is a pointer to a <CODE>Boolean</CODE> indicating whether to add a menu for this panel. Returning <CODE>true</CODE> in <CODE>*addItP</CODE> causes a menu item to be added. Returning <CODE>false</CODE> in <CODE>*addItP</CODE> removes any menu associated with this <CODE>panelRef</CODE>. Returning <CODE>false</CODE> may make sense if the user chooses a new printer and a filter continues to run but a particular panel should not appear for the new printer.</li></UL><H3>psPanelInitData</H3><P>The LaserWriter 8 Print Dialog code calls <CODE>psPanelInitData()</CODE> once for each panel that has been registered by <CODE>psPanelRegister()</CODE>. LaserWriter 8 calls this routine to allow the filter to configure itself for the print job dialog.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelInitData(LWRef lwRef, PanelRef panelRef,void *dataP, Collection plugInHints);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>.</li>    <LI><CODE>plugInHints</CODE> is a filter's private collection representing the current job. This collection potentially contains any job-specific hints that the filter has saved the last time this print job was generated, or may be empty indicating that the current print job has no saved initial job configuration. </li></UL>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  The <CODE>plugInHints</CODE> collection passed to <CODE>psPanelInitData()</CODE> does not contain the saved defaults for the current printer but may contain any saved defaults for the current print job.</P></TD></TR></TABLE></CENTER><BR><BR>               <H3>psPanelCloseData</H3><P>The LaserWriter 8 Print Dialog code calls <CODE>psPanelCloseData()</CODE> once for each panel as the filter is unloaded. This is the last panel-specific routine to be called before the filter is unloaded and is the last opportunity for a filter to dispose of any panel-specific private data.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelCloseData(LWRef lwRef, PanelRef panelRef,void *dataP, Boolean doIt);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>. This panel private data should be disposed of in <CODE>psPanelCloseData()</CODE>.</li>    <LI><CODE>doIt</CODE> is <CODE>true</CODE> if the user is dismissing the dialog with <B>Print</B> or <B>Save</B> button, and <CODE>false</CODE> if the filter is being unloaded for any other reason.</li></UL><H3>psPanelPrSpecificInitData</H3><P>The LaserWriter 8 Print Dialog code calls <CODE>psPanelPrSpecificInitData()</CODE> once initially for each panel after the filter is loaded, and again each time the user changes to a new printer and the filter continues to run.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelPrSpecificInitData(LWRef lwRef, PanelRef panelRef,void *dataP, Collection plugInPrInfo);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>.</li>    <LI><CODE>plugInPrInfo</CODE> is a collection that contains only hints that have been previously saved for this printer by this filter. This collection represents the settings previously saved by a plug-in when the user chose <b>Save Settings</b>. It should be used to initialize the panel settings for the current printer if there are no saved job defaults in the <CODE>plugInHints</CODE> collection passed to <CODE>psPanelInitData()</CODE>. </li></UL><H3>psPanelPrSpecificCloseData</H3><P>The LaserWriter 8 Print Dialog code calls <CODE>psPanelPrSpecificCloseData()</CODE> for each panel each time a printer is deselected (i.e., a new printer is selected) or the dialog is dismissed.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelPrSpecificCloseData(LWRef lwRef, PanelRef panelRef,void *dataP, Boolean doIt);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>.</li>    <LI><CODE>doIt</CODE> is <CODE>true</CODE> if the user is dismissing the dialog with the <B>Print</B> or <B>Save</B> button, and <CODE>false</CODE> if the user cancels the Print Dialog or switches to another printer.</li></UL><H3>psPanelInit</H3><P>When a given panel is selected in the LaserWriter 8 Print Dialog panel menu, it becomes visible. As part of making a panel visible in the Print Dialog, LaserWriter 8 appends that panel's <CODE>DITL</CODE> to the dialog. Before making the panel visible, LaserWriter 8 calls <CODE>psPanelInit()</CODE>, allowing the filter to initialize its user interface settings to match those reflected by the job and printer defaults.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelInit(LWRef lwRef, PanelRef panelRef, void *dataP,DialogPtr dp, short offset);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>.</li>    <LI><CODE>dp</CODE> is the dialog pointer for the Print Dialog.</li>    <LI><CODE>offset</CODE> is the value which must be added to the dialog item numbers in the <CODE>DITL</CODE> in order to access those items in the Print Dialog when the panel is visible. As part of adding a filter's dialog items to the Print Dialog, those items are renumbered. </li>    <LI>For example, if a filter has a <CODE>TextEdit</CODE> field as item number 1 in its <CODE>DITL</CODE>, when the panel appears visible, that item's dialog item number is (offset + 1).</li></UL><H3>psPanelClose</H3><P>The LaserWriter 8 Print Dialog code calls <CODE>psPanelClose()</CODE> each time this panel's <CODE>DITL</CODE> is about to be removed from the Print Dialog and the panel will no longer be visible.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelClose(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short offset);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>.</li>    <LI><CODE>dp</CODE> is the dialog pointer for the Print Dialog.</li>    <LI><CODE>offset</CODE> is the value which must be added to the dialog item numbers in the <CODE>DITL</CODE> in order to access those items in the Print Dialog when the panel is visible.</li></UL><H3>psPanelPrSpecificInit</H3><P>The LaserWriter 8 Print Dialog code calls <CODE>psPanelPrSpecificInit()</CODE> after <CODE>psPanelInit()</CODE> each time this panel's <CODE>DITL</CODE> has been appended to the Print Dialog, but before the panel is visible. It is also called each time a new printer is selected while the panel is visible.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelPrSpecificInit(LWRef lwRef, PanelRef panelRef,void *dataP, DialogPtr dp, short offset);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>.</li>    <LI><CODE>dp</CODE> is the dialog pointer for the Print Dialog.</li>    <LI><CODE>offset</CODE> is the value which must be added to the dialog item numbers in the <CODE>DITL</CODE> in order to access those items in the Print Dialog when the panel is visible.</li></UL><H3>psPanelPrSpecificClose</H3><P>The LaserWriter 8 Print Dialog code calls <CODE>psPanelPrSpecificClose()</CODE> before <CODE>psPanelClose()</CODE> each time this panel's <CODE>DITL</CODE> is about to be removed from the Print Dialog and will no longer be visible. It is also called each time a printer is deselected while the panel is visible.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelPrSpecificClose(LWRef lwRef, PanelRef panelRef,void *dataP, DialogPtr dp, short offset);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>.</li>    <LI><CODE>dp</CODE> is the dialog pointer for the Print Dialog.</li>    <LI><CODE>offset</CODE> is the value which must be added to dialog item numbers in the <CODE>DITL</CODE> in order to access those items in the Print Dialog when the panel is visible.</li></UL><H3>psPanelItem</H3><P><CODE>psPanelItem</CODE> gets called each time <CODE>ModalDialog()</CODE> reports an item hit in a filter's panel.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelItem(LWRef lwRef, PanelRef panelRef, void *dataP,DialogPtr dp, short item, short offset, short ctlVal); </pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>.</li>    <LI><CODE>dp</CODE> is the dialog pointer for the Print Dialog.</li>    <LI><CODE>item</CODE> is the dialog item number of the item hit.</li>    <LI><CODE>offset</CODE> is the value which must be added to dialog item numbers in the <CODE>DITL</CODE> in order to access those items in the Print Dialog. To compare item with the item numbers stored in the <CODE>DITL</CODE>, offset must first be subtracted from item. </li>    <LI><CODE>ctlVal</CODE> is the current value of the control, if the item hit is a control.</li></UL><H3>psPanelFilter</H3><P><CODE>psPanelFilter()</CODE> gets called from the Print Dialog's dialog filter function when this panel is visible.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelFilter(LWRef lwRef, PanelRef panelRef, void *dataP,DialogPtr dp, short offset, EventRecord *eventP,short *itemHitP, Boolean *weHandledItP);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>.</li>    <LI><CODE>dp</CODE> is the dialog pointer for the Print Dialog.</li>    <LI><CODE>offset</CODE> is the value which must be added to dialog item numbers in the <CODE>DITL</CODE> in order to access those items in the Print Dialog. To compare item with the values stored in the <CODE>DITL</CODE>, offset must first be subtracted from item.</li>    <LI><CODE>eventP</CODE> is a pointer to the <CODE>EventRecord</CODE> for the event passed to the LaserWriter 8 Print Dialog's dialog filter function.</li>    <LI><CODE>itemHitP</CODE> is a pointer to the dialog item number hit. Its meaning is the normal meaning for a dialog filter function passed to <CODE>ModalDialog()</CODE>.</li>    <LI><CODE>weHandledItP</CODE> is a pointer to a <CODE>Boolean</CODE> indicating whether this filter function handled the event. If the event is filtered by this call to <CODE>psPanelFilter</CODE>, <CODE>*weHandledItP</CODE> should be set to <CODE>true</CODE>; otherwise, it should be set to <CODE>false</CODE>.</li></UL><H3>psPanelCheckRange</H3><P>The LaserWriter 8 Print Dialog code calls <CODE>psPanelCheckRange()</CODE> when a filter's panel is visible and the user is changing to another panel, or if the panel is visible and the user presses the <B>Print</B> or <B>Save</B> button in the Print Dialog. It is also called when the panel is visible and the user selects the <B>Save Settings</B> button to save defaults for the current printer. A plug-in filter can inspect the current panel settings and alert the user if any settings are out of the acceptable range, then halt any of the events which caused <CODE>psPanelCheckRange()</CODE> to be called.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelCheckRange(LWRef lwRef, PanelRef panelRef,void *dataP, DialogPtr dp, short offset, Boolean *doitP);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>.</li>    <LI><CODE>dp</CODE> is the dialog pointer for the Print Dialog.</li>    <LI><CODE>offset</CODE> is the value which must be added to dialog item numbers in the <code>DITL</code> in order to access those items in the Print Dialog.</li>    <LI><CODE>doitP</CODE> is a pointer that indicates whether the data in the panel is within range. Returning <CODE>true</CODE> in <CODE>*doitP</CODE> indicates that the data is OK; returning <CODE>false</CODE> indicates that the data needs to be corrected before the panel is changed, the dialog is dismissed, or the settings can be saved. </li> </UL><H3>psPanelSaveButton</H3><p align="center">The LaserWriter 8 Print Dialog code calls <CODE>psPanelSaveButton()</CODE> when the user hits the <B>Save Settings</B> button in the Print Dialog to save the current settings as the new default settings for the current printer. <CODE>psPanelSaveButton()</CODE> is called for all panels regardless of whether the panel is visible at the time the user selects <B>Save Settings</B>.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psPanelSaveButton(LWRef lwRef, PanelRef panelRef,void *dataP, Collection plugInPrInfo);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter.</li>    <LI><CODE>panelRef</CODE> is the panel reference value for the panel to which this call corresponds.</li>    <LI><CODE>dataP</CODE> is the panel's private data, as returned by <CODE>psPanelRegister()</CODE> for this <CODE>panelRef</CODE>.</li>    <LI><CODE>plugInPrInfo</CODE> is the filter's private collection into which the filter should store its current settings. </li></UL><H3>A Bit More On the Filter Panel Routines</H3><P>The routines specific to a given panel provide a lot of flexibility and power in order to allow a filter to configure itself and manage its user interface. To allow this flexibility, there are a number of routines, and, at first glance, it isn't obvious when each routine is called. It may be helpful to clarify how some of the routines associated with individual panels are called and in what order. This discussion assumes that the example filter's criteria indicate that it should run and keep running when the user changes printers and that the user's configuration allows the filter to run with each printer.</P><P>Here's what happens when the dialog comes up. This occurs once, regardless of whether a filter's panel is visible:</P>     <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>psPanelInitDatapsPanelPrSpecificInitData (with the current printer's data)</pre></TD></TR></TABLE></CENTER><BR><BR><P>Here's what happens if the printer gets changed and the filter's panel is not visible:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>psPanelPrSpecificCloseDatapsPanelPrSpecificInitData (for the new printer's data)</pre></TD></TR></TABLE></CENTER><BR><BR><P>Here's what happens when the filter's panel becomes visible:</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>psPanelInitpsPanelPrSpecificInit</pre></TD></TR></TABLE></CENTER><BR><BR><P>Here's what happens if the printer gets changed and the filter's panel is visible:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>psPanelPrSpecificClosepsPanelPrSpecificCloseDatapsPanelPrSpecificInitData (for the new printer's data)psPanelPrSpecificInit</pre></TD></TR></TABLE></CENTER><BR><BR><P>Here's what happens when the panel was visible but is now about to go away: </P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>psPanelPrSpecificClosepsPanelClose</pre></TD></TR></TABLE></CENTER><BR><BR><P>Here's what happens when the dialog goes away and the filter's panel is not visible:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>psPanelPrSpecificCloseDatapsPanelCloseData</pre></TD></TR></TABLE></CENTER><BR><BR><P>Here's what happens when the dialog goes away and the filter's panel is visible:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>psPanelPrSpecificClosepsPanelClosepsPanelPrSpecificCloseDatapsPanelCloseData</pre></TD></TR></TABLE></CENTER><BR><BR><H3>LaserWriter 8 APIs Available To a Filter's UI Code</H3><P>While the LaserWriter 8 Print Dialog is present, a filter can use the <CODE>LWRef</CODE> passed to the UI routines described above to access various pieces of data that may aid in configuring the filter or determining whether to execute. These routines are described here and are collectively referred to as the <CODE>LW*</CODE> routines.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  The <CODE>LW*</CODE> routines described in this section are only for use during a filter's UI execution, not during a filter's output execution.               </P></TD></TR></TABLE></CENTER><BR><BR><H3>LWGetPrintRec</H3><P><CODE>LWGetPrintRec()</CODE> returns a handle to the print record the application passed to <CODE>PrJobDialog()</CODE>, bringing up the Print Dialog which is executing the filter. The handle returned is owned by LaserWriter 8 and should not be disposed of by the caller. The returned print record should be considered read-only. Modifying this print record will generate unpredictable results.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct TPrint **LWGetPrintRec(LWRef lwRef);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter. This is passed to each of the UI routines which can call <CODE>LWGetPrintRec()</CODE>. </li></UL><H3>LWGetBackground</H3><P><CODE>LWGetBackground()</CODE> returns a <CODE>Boolean</CODE> indicating whether the Print Dialog is currently configured for background printing. </P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>Boolean LWGetBackground(LWRef lwRef);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter. This is passed to each of the UI routines which can call <CODE>LWGetBackground()</CODE>. </li>    <LI>The <CODE>Boolean</CODE> returned is <CODE>true</CODE> if the Print Dialog is currently configured for background printing and <CODE>false</CODE> if the Print Dialog is currently configured for foreground printing.</li></UL><H3>LWGetPPDContext</H3><P>The LaserWriter 8 Print Dialog code uses the <CODE>PPDLib</CODE> library built into PrintingLib to access the PostScript Printer Description (PPD) data for the current printer. Filters may find it useful to have access to the PPD data for the current printer and can obtain a pointer to the <CODE>PPDContext</CODE> for the current printer by using the <CODE>LWGetPPDContext</CODE> routine.</P>    <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct PPDContextViel *LWGetPPDContext(LWRef lwRef);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter. This is passed to each of the UI routines which can call <CODE>LWGetPPDContext()</CODE>. </li>    <LI>The value returned from the <CODE>LWGetPPDContext</CODE> call is a pointer to an opaque structure. This pointer is appropriate for passing to the exported routines available in the <CODE>PPDLib</CODE> library built into PrintingLib. See <A HREF = "#References">References</A> for more information about <CODE>PPDLib</CODE>.</li></UL><H3>LWGetJobCollection</H3><P>The current print job collection is available to a filter through the <CODE>LWGetJobCollection</CODE> routine.</P>          <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>Collection LWGetJobCollection(LWRef lwRef);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter. This is passed to each of the UI routines which can call <CODE>LWGetJobCollection()</CODE>.</li>    <LI>The return result from <CODE>LWGetJobCollection()</CODE> is the current job collection as maintained by the Print Dialog code. This collection is owned by LaserWriter 8 and must not be disposed of by the caller.</li></UL>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                This job collection may not include all job settings since the Print Dialog code does not necessarily update the job collection to reflect the current settings in the user interface until the Print Dialog is dismissed.             </P></TD></TR></TABLE></CENTER><BR><BR><H3>LWGetPrInfoCollection</H3><P>The collection corresponding to the current printer's defaults is available to a filter through the <CODE>LWGetPrInfoCollection</CODE> routine. The values in this collection may change during execution of the Print Dialog since users can change the default settings. In addition, users can change printers in the Print Dialog, and doing so changes the collection returned by <CODE>LWGetPrInfoCollection()</CODE> and disposes of any collection returned by any previous calls to <CODE>LWGetPrInfoCollection()</CODE>. For these reasons, use of the collection returned by <CODE>LWGetPrInfoCollection()</CODE> should be limited to the panel routine making the call.</P>       <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>Collection LWGetPrInfoCollection(LWRef lwRef);</pre></TD></TR></TABLE></CENTER><BR><BR><UL>    <LI><CODE>lwRef</CODE> is an opaque reference to the LaserWriter driver that is currently executing the filter. This is passed to each of the UI routines which can call <CODE>LWGetPrInfoCollection()</CODE>.</li>    <LI>The return result from <CODE>LWGetPrInfoCollection()</CODE> is the current printer's default collection as maintained by the Print Dialog code. This collection is owned by LaserWriter 8 and must not be disposed of by the caller.</li></UL><a name="SpecialConsiderations"></a><H3>Special Considerations When Using the <code>LW*</code> Routines</H3><P>The <code>LW*</code> routines described in this section are available only to the filter routines described in the section <A HREF = "#UserInterface">User Interface APIs</A>. The filter UI routines are each passed a <CODE>LWRef</CODE> argument, and that parameter is an argument to each of the <code>LW*</code> routines. </P><P>The <code>LW*</code> routines are exported from the <CODE>LW8UILib</CODE> shared library contained in LaserWriter 8. This library is only available while the LaserWriter 8 Print Dialog is present. This means that the <code>LW*</code> routines and <CODE>LW8UILib</CODE> are not available during the filter's execution at PostScript output time. </P><P>There are two approaches to allow a filter's UI code to access the <code>LW*</code> routines. The simplest one is to weak link to the "LaserWriter8.Lib" file (provided with the sample code) as part of building the filter. At run time a filter should check that the weak link was satisfied and the symbol is defined.</P> <P>For example:</P>      <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>if(LWGetPrInfoCollection != (void *)kUnresolvedCFragSymbolAddress)prefs = LWGetPrInfoCollection(lwRef);</pre></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>It is crucial to make the link weak because <code>LW8UILib</code> is not available during the filter's execution at PostScript output time. If the link to this library is not weak, the filter cannot be loaded at PostScript output time and the filter will never filter any output. Debugging that situation will be difficult because the filter cannot be loaded at filter output execution time if it has hard links to <code>LW8UILib</code>, and therefore the filter output routines are not called.</P></TD></TR></TABLE></CENTER><BR><BR><P>A more complex approach to this issue is to satisfy the link to <code>LW8UILib</code> manually and do the symbol resolution for the needed routine or routines using <CODE>FindSymbol()</CODE>. The sample code also demonstrates this approach.</P><h3>UI-Specific Resources</h3><P>The LaserWriter 8 Print Dialog makes use of three optional filter plug-in resources during its execution. The first two are the <CODE>kPluginInfoType</CODE> resource and <CODE>vers</CODE> resource. LaserWriter 8 uses these resources to display information about a filter when the user clicks on the small button <img src="images/tn1179_004.gif" alt="button" width=13 height=11 align=middle> corresponding to the filter in the Plug-In Preferences panel. Figure 4 below shows the information dialog for one of the sample code filters.</p><br><center><img src="images/tn1179_005.gif" alt="Filter Information" width=256 height=286><BR><b>Figure 4 - The Filter Information Dialog</b></center><P>The filter information dialog contains the name of the filter as contained in the <CODE>kPluginResourceInfoType</CODE> resource described in the section <A HREF = "#FilterPlugin">Filter Plug-In Requirements</A> above. Since multiple filters may be contained in a single file and the filter name may have nothing to do with the name of the file containing the filter, the file name containing the filter is also displayed. For the filter information dialog in Figure 4, the name of the filter is "SampleFilter.debug," and the file name is "SampleFilter.debug.file".</P><P>The filter information dialog also displays the version of the filter and some informative text describing the filter. LaserWriter 8 obtains the displayed version information from the <CODE>'vers'</CODE> resource ID number 1. It obtains the text for the information portion from the <CODE>kPluginInfoType</CODE> resource, ID <CODE>kPluginInfoID</CODE> in the filter file. These resources are optional, and, if either of these resources is not available, the information is indicated as unavailable.</P><H3>kPanelDescriptionType Resource</H3><P>When displaying a panel for a given filter, LaserWriter 8 can handle some of the management of the user interface portion of the filter if it contains a <CODE>kPanelDescriptionType</CODE> resource describing the <code>DITL</code> ID. The ID for the <CODE>kPanelDescriptionType</CODE> resource must match the ID of the <code>DITL</code> that it describes.</P><P>The <CODE>kPanelDescriptionType</CODE> resource lists which dialog items in the <code>DITL</code> are checkboxes and lists each of the ranges of grouped radio buttons for that <code>DITL</code>. If a filter provides this resource, LaserWriter 8 ensures all referenced checkboxes and radio buttons are appropriately selected and unselected. This resource is not required so, if a developer prefers to manage these aspects of the user interface, this resource can be left out. The sample code provided with this technote supplies this resource.</P><A NAME="FilterPrivate"></A><H3>Filter Private Collection Issues</H3><P>Filters provide their settings for a given print job and their default settings for a given printer by providing "hints" in the form of Collection Manager collection items. To avoid collisions between the collection items used by different filters, the LaserWriter 8 Print Dialog code maintains a private collection for each filter as described earlier in the section <A HREF = "#FilterJob">Filter Job Collection</A>. LaserWriter 8 stores the private collection corresponding to a filter's job settings in the collection corresponding to the current job as a collection item with tag <CODE>kHintPlugInCollTag</CODE> and uses the filter's unique 4-byte signature as the collection ID. The filter provides its unique 4-byte signature in the parameter <CODE>*libSignatureP</CODE> returned from the routine <CODE>psPanelPlugInLibInitData</CODE>. Likewise, the filter's printer specific defaults are stored in a filter's private collection that LaserWriter 8 adds to its collection specifying printer defaults using the <CODE>kHintPlugInCollTag</CODE> tag and the filter's unique 4-byte signature as the collection ID.</P><P>During the execution of the filter's user interface code, LaserWriter 8 obtains the filter's signature and uses that signature to obtain the private job settings and printer default collections for that filter. When LaserWriter 8 calls a filter's <CODE>psPanelInitData</CODE> routine, the parameter <CODE>plugInHints</CODE> is the filter's private collection corresponding to the current job. A filter normally consults this collection for any print job-specific defaults and adds collection items to this collection in order to configure the current print job. Normally these collection items are added by a filter's <CODE>psPanelCloseData</CODE> routine when the doIt parameter passed to that routine is true, indicating that the user has clicked <B>Print</B> or <B>Save</B> in the Print Dialog.</P><P>When LaserWriter 8 calls a filter's <CODE>psPanelSaveButton</CODE> routine, the parameter <CODE>plugInPrInfo</CODE> passed is the filter's private collection corresponding to the current printer's previously saved defaults. A filter should add collection items to this collection in order to configure the current printer's defaults corresponding to the filter's current UI settings.</P><P>Similarly, when LaserWriter 8 calls a filter's <CODE>psPanelPrSpecificInitData</CODE> routine, the parameter <CODE>plugInPrInfo</CODE> is the filter's private collection corresponding to the current printer's saved defaults. A filter normally first consults the <CODE>plugInHints</CODE> collection (passed to <CODE>psPanelInitData()</CODE>) to determine if there are any job specific settings and if there are not, it extracts printer default hints from the <CODE>plugInPrInfo</CODE> collection and uses those defaults to configure its initial user interface.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> Readers should be clear that the LaserWriter 8 Print Dialog code passes a given filter its own private hints collection during UI execution time. However, it is up to the filter to obtain its own private collection at filter output execution time, as described earlier in the section <A HREF = "#FilterJob">Filter Job Collection</A>.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>LaserWriter 8.7 does not prevent installation and execution of two or more copies of the same plug-in; however, it does not properly manage separate collections for each instance since they share the same signature. This also applies to two different plug-ins that have the same signature. In each of these cases, LaserWriter 8 will store the filter's private collection into the full job and printer default collections using the collection tag value <CODE>kHintPlugInCollTag</CODE> and with the filter's unique 4-byte signature as the collection ID. In the case where two filters share the same 4-byte signature, when LaserWriter 8 stores the private collection for filter B, it overwrites any already stored private collection for filter A. A filter's signature must be registered using Apple's Creator Code Registration web page given in the section <A HREF = "#References">References</A>.</P></TD></TR></TABLE></CENTER><BR><BR><A NAME="PrintingWithout"></A><H3>Printing Without a Print Dialog</H3><P>A filter that has a user interface to allow a user to configure the printer for a given print job normally expects that its private job collection providing the print job configuration is available at filter output execution time. Since there are several ways a user can print without bringing up the Print Dialog, there are situations where its private job collection may not be available. One way this can happen is when the user selects the <B>Print One</B> menu item that many applications provide. This typically begins a print job without bringing up the Print Dialog. In this situation, LaserWriter 8 extracts the saved private default collection corresponding to a filter's saved defaults for the target printer and copies it to the job collection for this print job. If a filter has no saved defaults, there is no private collection for the filter's signature in the job collection for the print job. A filter should be prepared to handle this situation.</P><P>A similar situation exists when the user drags and drops a file onto a Desktop Printer and the Download Manager handles the print job directly rather than launching an application. The Download Manager is a new piece of the PostScript printing system added with MacOS 8.5 and LaserWriter/PrintingLib 8.6. The Download Manager can handle some documents directly rather than requiring an application to do the printing. When printing with the Download Manager, no Print Dialog is shown; instead, the print job is configured using the default settings for the target printer. Again, filters need to be prepared to execute when there is no saved private default collection corresponding to its filter signature. See the section <A HREF = "#References">References</A> for more information on the Download Manager.</P><H3>Additional Filter User Interface Code Issues</H3><P>A few additional issues involving the User Interface portion of the filter's execution are worth discussion.</P><H4>Appearance Manager and Appearance Controls</H4><P>LaserWriter 8.7 requires that the Appearance Manager is available in order to add the "Plug-In Preferences" panel to the Print Dialog and execute any filter's user interface code. This means that users will not have the ability to enable filter plug-ins unless the Appearance Manager is available on their System.</P><P>Apple has historically found that some applications use private control definitions that conflict with the Appearance control definitions. LaserWriter 8 takes special action to avoid these conflicts when displaying the Print Dialog. If the application or another open file above the application in the resource chain contains a <CODE>CDEF</CODE> resource with a resource ID in the range of 1-26 inclusive, LaserWriter 8 acts as if the Appearance Manager is not available and does not add the "Plug-In Preferences" panel to the Print Dialog. In this situation, a filter can be enabled based on printer defaults but its user interface is not available to the user. If a filter is enabled but its UI is not available in the Print Dialog for this reason, the filter executes as described in the section <A HREF = "#PrintingWithout">Printing Without a Print Dialog</A> above. Because filters only appear in the LaserWriter 8 Print Dialog when there are no <CODE>CDEF</CODE> conflicts, at filter UI execution time a filter can use Appearance controls and the Appearance API without concerns about these conflicts.</P><P>Note that for compatibility reasons, the LaserWriter 8 Print Dialog does not use the Appearance control hierarchy. Developers should be aware that some Appearance controls, such as the list control box, do not work properly without the Appearance control hierarchy.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>As of this writing, LaserWriter 8.7 has been qualified for MacOS 9.0 only and refuses to run on MacOS prior to MacOS 8.1. The requirement that the Appearance Manager exists limits the execution environment for filters further.</P></TD></TR></TABLE></CENTER><BR><BR><A NAME="ResourceID"></A><H4>Resource ID Ranges</H4><P>Filters execute as part of an application's invocation of the Printing Manager and the LaserWriter 8 print driver. Because of this, it is important that filters ensure that their resource IDs do not conflict with any application or system resource IDs. Accordingly, a filter's resource IDs must be in the range of driver-owned resources (that is <CODE>-8192</CODE> to <CODE>-4097</CODE>), but the resources provided as part of a filter should be in the ID range  <CODE>6500-6101</CODE> to avoid conflicts with future revisions of the LaserWriter driver.</P><H4>Resource Fork Issues</H4><P>During the execution of the filter's user interface code, there are potentially many other filters providing a user interface. There are no restrictions on the numbering of resources beyond those described in the section <A HREF = "#ResourceID">Resource ID Ranges</A> above. Because there are potentially many filters executing in the Print Dialog and each filter's resource fork is open simultaneously, LaserWriter 8 is careful when obtaining resources from each filter's resource fork. LaserWriter 8 does not manage the resource chain prior to calling a filter's UI routines so each filter must be careful to ensure that its resource fork is the current resource file any time that it accesses its resources. A filter should use <CODE>CurResFile()</CODE> and <CODE>UseResFile()</CODE> carefully to save and restore the resource chain around any filter's access to its resource fork. The sample code demonstrates how to do this properly.</P><H4>Filter Defined Criteria</H4><P>The <CODE>psPanelSetCriteria</CODE> routine allows a filter to provide some simple criteria for determining whether to present a user interface. These criteria, described in the section <CODE>psPanelSetCriteria</CODE>, are relatively limited, and some developers may have much more complex criteria. The routine <CODE>psPanelRegister</CODE> can be used by a developer to establish more complex criteria to determine whether to display a user interface. For example, the <CODE>SampleFilter</CODE> described in the <A HREF = "#SampleCode">Sample Code</A> section can be configured to display its user interface only if the PPD file for the current printer has a <CODE>*PCFileName</CODE> that starts with the letters "APL", i.e., only printers from Apple Computer.</P><p><A HREF = "#top">Back to top</a></p><BR><A NAME="SampleCode"></A><H3>Sample Code</H3><P>To aid developers, this technote supplies two sample filters as sample code, one called <CODE>SampleFilter</CODE> and the other called <CODE>SectionReport</CODE>. <CODE>SampleFilter</CODE> demonstrates how to generate a user interface and perform some typical filtering operations on the PostScript output data. <CODE>SectionReport</CODE> provides an introduction into the <CODE>PSPosition</CODE> data supplied to a filter at PostScript output time and can be used as a diagnostic aid as well.  </P><H4>SampleFilter</H4><P>The <CODE>SampleFilter</CODE> source code demonstrates how to generate a user interface in the LaserWriter 8 Print Dialog and how to manage that user interface. <CODE>SampleFilter</CODE> configures its initial user interface to reflect any saved printer defaults, allows the user to print using those settings, and saves its settings as the current printer defaults when the user clicks the <B>Save Settings</B> button in the Print Dialog. The filter's <CODE>psOutputFilterPreFlight</CODE> routine uses the settings in the filter's private job collection to configure the filter's output execution. </P><P>The filter operations demonstrated by the <CODE>SampleFilter</CODE> source include the following:</P><UL>    <LI>Inserting data into the output stream before a given <CODE>PSSubsection</CODE>.</li>    <LI>Inserting data into the output stream after a given <CODE>PSSubsection</CODE>.</li>    <LI>Removing data from the output stream corresponding to a given <CODE>PSSubsection</CODE>.</li>    <LI>Replacing data in the output stream corresponding to a given <CODE>PSSubsection</CODE>.</li>    <LI>Detecting a given page in the output stream.</li></UL><P><CODE>SampleFilter</CODE> does not generate a PostScript output stream that is likely to be considered noticeably different than that usually generated by a print job. It provides no particular feature or benefit to a user but is simply a demonstration of how to accomplish the typical functions an output filter might want to perform.</P><p>One feature of the <CODE>SampleFilter</CODE> source code worthy of discussion is that it demonstrates some use of the <CODE>PSUtilsLib</CODE> library built into PrintingLib to aid in generating PostScript output code. <CODE>PSUtilsLib</CODE> contains routines similar to <CODE>printf()</CODE> that are useful for performing formatted writes of PostScript output data. <A HREF = "tn1171.html#AppendixA">Appendix A of Technote 1171: LaserWriter 8.6: How to Write a Converter Plug-in for the Download Manager</a> documents the motivation behind and use of these routines.</p><H4>SectionReport</H4><P>The <CODE>SectionReport</CODE> sample filter demonstrates use of the <CODE>PSPosition</CODE> data passed to a filter's <CODE>psOutputFilterWrite</CODE> routine. (The <CODE>PSPosition</CODE> data is discussed in the section <A HREF = "#TaggedData">Tagged Data</A> above and also in <A HREF = "#AppendixA">Appendix A: PSPosition Data Details</A>.) For each print job for which it is enabled, the <CODE>SectionReport</CODE> filter generates an output log file containing the information passed to it in the <CODE>PSPosition</CODE> structure. The output file is placed in the user's preferred "Job Documentation Folder" as specified in the <B>Job Logging</B> panel of the Print Dialog. By default, this folder is called "Printing Logs Folder" and is placed on the root of the boot volume. The output file produced by the <CODE>SectionReport</CODE> filter is titled "jobname.dsc" where <CODE>jobname</CODE> is the name of the print job.</P><P>The <CODE>SectionReport</CODE> filter is useful in two ways. One use is to look at the source code to gather a better understanding of the section, subsection, and info fields of the <CODE>PSPosition</CODE> data structure. Of particular interest is the type of data in the info field of the <CODE>PSPosition</CODE> structure for various <CODE>PSSubsection</CODE> values. A second use of the filter is as a diagnostic tool to understand the filter chaining and output. This filter is frequently useful in debugging as well. The data seen by the <CODE>SectionReport</CODE> filter and therefore generated into its log file depends on its position in the output filter chain. For example, compare its output when it appears before <CODE>SampleFilter</CODE> as opposed to after. As a reminder, filters can be reordered in the <B>Plug-In Preferences</B> panel of the LaserWriter 8 Print Dialog by grabbing the "gripper" at the left of each filter name and dragging that filter to its new place in the order. See <A HREF = "#Figure1">Figure 1</A>.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  The <CODE>SectionReport</CODE> sample filter has no user interface and therefore no custom signature or private collection. Filters that have no user interface do not need a custom signature.  </P></TD></TR></TABLE></CENTER><BR><BR><H3>Issues Relevant to the Provided Sample Code</H3><P>The <CODE>SectionReport</CODE> filter is a CFM library that has its global data marked as shared. This means that the filter is loaded only once and all instances of the filter share the CFM table of contents and global data. This is a memory savings since only one instance of its globals need exist. </P><P>The <CODE>SampleFilter</CODE> filter is treated differently. <CODE>SampleFilter</CODE> is provided as a CodeWarrior project that is configured so that the data section of the library generated is not shared among all instances of the library. (This is set in the CodeWarrior project-specific <B>Settings</B> Menu: the <B>PPC PEF</B> panel; the checkbox labeled <B>Share Data Section</B>. Unchecking the check box ensures each instance has private global data.) This setting means that the library is loaded for each instance of the filter and the library's global data is not shared among instances. </P><P>This is important for the <CODE>SampleFilter</CODE> filter because it weak links to the LaserWriter8.Lib file as described in the section <A HREF = "#SpecialConsiderations">Special Considerations When Using the <code>LW*</code> Routines</A> above. If <CODE>SampleFilter</CODE> used shared global data, the resolution of symbols would only be done once, when the library first loads. If the library were to first load as part of a print job executing in background, any <CODE><code>LW*</code></CODE> routine links would not be resolved because <CODE><code>LW8UILib</code></CODE> is not available at filter output execution time. If the Print Dialog were then brought up for another print job at that point, the <CODE><code>LW*</code></CODE> routine links would remain unresolved. By marking the global data so that it is not shared, the symbol resolution occurs each time the library is loaded, and each instance of the library is independent.</P><p><A HREF = "#top">Back to top</a></p><BR>         <A NAME="Summary"></A>                  <H2>Summary</H2><P>PostScript output filter plug-ins offer the ability to insert into, modify, or replace the PostScript language output stream generated by LaserWriter and PrintingLib version 8.7. These filter plug-ins can present a user interface in the LaserWriter 8 Print Dialog, offering an integrated way for users to choose settings for each print job and to save defaults on a printer by printer basis. PostScript output filter plug-ins in LaserWriter 8.7 provide a powerful mechanism for printer manufacturers and Third Party developers to add support for printer specific features and add new functionality without any changes to LaserWriter 8 itself.</P><p><A HREF = "#top">Back to top</a></p><BR><a name="References"></a><H2>References</H2>    <p><A HREF = "tn1115.html">Technote 1115: The Extended 'PAPA' Resource</A></p>    <p><A HREF = "tn1129.html">Technote 1129: The Settings Library</A></p>    <p><A HREF = "tn1144.html">Technote 1144: Writing Custom Hoses For LaserWriter 8.6</A></p>    <p><A HREF = "tn1169.html">Technote 1169: The Download Manager</A></p>    <p><A HREF = "tn1170.html">Technote 1170: The Printing Plug-ins Manager</A></p>    <p><A HREF = "tn1171.html#AppendixA">Technote 1171: LaserWriter 8.6: How to Write a Converter Plug-in for the Download Manager</A></p>    <p><a href="http://developer.apple.com/documentation/macos8/Utilities/CollectionManager/collectionmanager.html">Inside Macintosh, The Collection Manager</A></p>    <p><A HREF = "http://partners.adobe.com/asn/developer/technotes.html#technotes">Adobe Technical Note #5001, PostScript Language Document Structuring Conventions Specification</A></p>    <p><A HREF = "http://developer.apple.com/dev/cftype/">Apple's Creator Code Registration web page</A></p><p><A HREF = "#top">Back to top</a> </p><A NAME="Downloads"></A> <h2>Downloadables</h2><center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600"> <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P></TD><td align="left">   <p>Acrobat version of this Note (460K).</P></TD><td width=60 align=left>   <p><A HREF="pdf/tn1179.pdf">Download</A></P></TD>  </TR>   <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/bluebook.gif" width=22 height=23 align=bottom alt="Bluebook"></P></TD><td align="left">   <p>PostScript Filter sample code.</P></TD><td width=60 align=left>   <p><a href="http://developer.apple.com/samplecode/Sample_Code/Printing.htm">Download</A></P></TD>  </TR>   </table></center><p><A HREF = "#top">Back to top</a></p><A NAME="AppendixA"></A><H2>Appendix A: PSPosition Data Details</H2><P>Filters receive data through their <CODE>psOutputFilterWrite</CODE> routine. The data written to the filter is tagged by a pointer to a <CODE>PSPosition</CODE> data structure. The <CODE>PSPosition</CODE> structure contains section, subsection, info, and ID fields. The <A HREF = "#TaggedData">Tagged Data</A> section above describes the <CODE>PSPosition</CODE> structure in some detail. This Appendix discusses the connection between the subsection and info field in more detail.</P><P>The subsection field of the <CODE>PSPosition</CODE> structure is of type <CODE>PSSubsection</CODE> and describes the details of the PostScript output corresponding to the data write call. <CODE>PSSubsection</CODE> values typically correspond to Document Structuring Conventions (DSC) data, but there are additional values which suit some specialized needs. The meaning of the <CODE>PSSubsection</CODE> values which correspond to DSC data will not be discussed in detail here; readers are directed to Adobe's Document Structuring Conventions document for information about the DSC.</P><P>The info field is either a <CODE>NULL</CODE> pointer or a pointer to data whose type is defined for the <CODE>PSSubsection</CODE> value in the subsection field. The data (if any) pointed to by the info field coincides with the data being written to the output stream. For example, when writing the data "%%Pages: 4" to the print stream, the writer puts the <CODE>PSSubsection</CODE> value <CODE>kSubPages</CODE> into the subsection field of the <CODE>PSPosition</CODE> and the info field is either <CODE>NULL</CODE> or points to an <CODE>SInt32</CODE> with the value 4. The header file "PSStreamInfo.h" contains the list of <CODE>PSSubsection</CODE> values and the proper data type for the info field for each <CODE>PSSubsection</CODE>.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Even for subsections for which there is an info data type defined, it is legal for the info field to be <CODE>NULL</CODE> for that subsection. Filters examining the info field should first check that the info field is not <CODE>NULL</CODE> before assuming that the info data points to a structure of the type listed.</P></TD></TR></TABLE></CENTER><BR><BR><P>Of particular importance is the subsection <CODE>kSubAnon</CODE>. <CODE>kSubAnon</CODE> tags PostScript code which is not one of the other subsections and whose structure is unspecified. The only way to acquire further knowledge of PostScript output tagged by this subsection is to parse the data. The bulk of a given print job consists of data tagged by the subsection <CODE>kSubAnon</CODE>.</P><P>Table 1 below presents the connection between a subsection value and the info data for that <CODE>PSSubsection</CODE> value. Table 1 presents this information for only those subsections that have a DSC equivalent.</P><TABLE>    <TR>        <td width=500 align=left><H2 ALIGN=CENTER>Table 1 </H2>        </TD>    </TR></table><br><TABLE border=1>    <TR>        <TH>Subsection</th><TH>DSC Comment</th> <TH>info data points to</TH>    </TR>    <TR>        <td align="left">kSubPSAdobe</td><td align="left">%!PS-Adobe-x.y</td><td align="left">Fixed</TD>    </TR>    <TR>        <td align="left">kSubPSAdobeEPS</td><td align="left">%!PS-Adobe-x.y EPSF-a.b</td><td align="left">EPSFVersion</TD>    </TR>    <TR>        <td align="left">kSubBoundingBox</td><td align="left">%%BoundingBox</td><td align="left">DSCBBox</TD>    </TR>    <TR>        <td align="left">kSubCopyright</td><td align="left">%%Copyright</td><td align="left">Str255</TD>    </TR>    <TR>        <td align="left">kSubCreator</td><td align="left">%%Creator</td><td align="left">Str255</TD>    </TR>    <TR>        <td align="left">kSubDate</td><td align="left">%%CreationDate</td><td align="left">Str255</TD>    </TR>    <TR>        <td align="left">kSubDocData</td><td align="left">%%DocumentData</td><td align="left">DSCDocumentData</td>        </tr>            <TR>    <td align="left">kSubEndComments</td><td align="left">%%EndComments</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubFor</td><td align="left">%%For</td><td align="left">Str255</TD>    </TR>    <TR>        <td align="left">kSubLangLevel</td><td align="left">%%LanguageLevel</td><td align="left">SInt32</TD>    </TR>    <TR>        <td align="left">kSubOrientation</td><td align="left">%%Orientation</td><td align="left">DSCOrientation</TD>    </TR>    <TR>        <td align="left">kSubPages</td><td align="left">%%Pages</td><td align="left">SInt32</TD>    </TR>    <TR>        <td align="left">kSubPageOrder</td><td align="left">%%PageOrder</td><td align="left">DSCPageOrder</TD>    </TR>    <TR>        <td align="left">kSubRouting</td><td align="left">%%Routing</td><td align="left">Str255 </TD>    </TR>    <TR>        <td align="left">kSubTitle</td><td align="left">%%Title</td><td align="left">Str255</td>        </tr>        <TR>        <td align="left">kSubContinue</td><td align="left">%%+</td><td align="left">DSCContinuationData</TD>    </TR>    <TR>        <td align="left">kSubBeginProlog</td><td align="left">%%BeginProlog</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubEndProlog</td><td align="left">%%EndProlog</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubBeginSetup</td><td align="left">%%BeginSetup</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubEndSetup</td><td align="left">%%EndSetup</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubBeginPageSetup</td><td align="left">%%BeginPageSetup</td><td align="left">SInt32 (page #)</TD>    </TR>    <TR>        <td align="left">kSubEndPageSetup</td><td align="left">%%EndPageSetup</td><td align="left">SInt32 (page #)</TD>    </TR>    <TR>        <td align="left">kSubPage</td><td align="left">%%Page</td><td align="left">DSCPage</TD>    </TR>    <TR>        <td align="left">kSubPageBoundingBox</td><td align="left">%%PageBoundingBox</td><td align="left">DSCBBox</TD>    </TR>    <TR>        <td align="left">kSubPageOrientation</td><td align="left">%%PageOrientation</td><td align="left">DSCOrientation</TD>    </TR>    <TR>        <td align="left">kSubPageTrailer</td><td align="left">%%PageTrailer</td><td align="left">SInt32 (page #)</TD>    </TR>    <TR>        <td align="left">kSubTrailer</td><td align="left">%%Trailer</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubEOF</td><td align="left">%%EOF</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubDocMedia</td><td align="left">%%DocumentMedia</td><td align="left">DSCData</TD>    </TR>    <TR>        <td align="left">kSubDocNeededRes</td><td align="left">%%DocumentNeededResources</td><td align="left">DSCData</TD>    </TR>    <TR>        <td align="left">kSubDocSuppliedRes</td><td align="left">%%DocumentSuppliedResources</td><td align="left">DSCData</TD>    </TR>    <TR>        <td align="left">kSubDocFonts</td><td align="left">%%DocumentFonts</td><td align="left">DSCData</TD>    </TR>    <TR>        <td align="left">kSubDocNeededFonts</td><td align="left">%%DocumentNeededFonts</td><td align="left">DSCData</TD>    </TR>    <TR>        <td align="left">kSubDocSuppliedFonts</td><td align="left">%%DocumentSuppliedFonts</td><td align="left">DSCData</TD>    </TR>    <TR>        <td align="left">kSubProofMode</td><td align="left">%%ProofMode</td><td align="left">DSCProofMode</TD>    </TR>    <TR>        <td align="left">kSubBeginDoc</td><td align="left">%%BeginDocument</td><td align="left">DSCData</TD>    </TR>    <TR>        <td align="left">kSubEndDoc</td><td align="left">%%EndDocument</td><td align="left">none defined </TD>    </TR>    <TR>        <td align="left">kSubIncludeDoc</td><td align="left">%%IncludeDocument</td><td align="left">DSCData</TD>    </TR>    <TR>        <td align="left">kSubBeginFeature</td><td align="left">%%BeginFeature</td><td align="left">DSCFeature</TD>    </TR>    <TR>        <td align="left">kSubEndFeature</td><td align="left">%%EndFeature</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubIncludeFeature</td><td align="left">%%IncludeFeature</td><td align="left">DSCFeature</TD>    </TR>    <TR>        <td align="left">kSubBeginFile</td><td align="left">%%BeginFile</td><td align="left">Str255</TD>    </TR>    <TR>        <td align="left">kSubEndFile</td><td align="left">%%EndFile</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubIncludeFile</td><td align="left">%%IncludeFile</td><td align="left">Str255</TD>    </TR>    <TR>        <td align="left">kSubBeginFont</td><td align="left">%%BeginFont</td><td align="left">DSCData </TD>    </TR>    <TR>        <td align="left">kSubEndFont</td><td align="left">%%EndFont</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubIncludeFont</td><td align="left">%%IncludeFont</td><td align="left">DSCData </TD>    </TR>    <TR>        <td align="left">kSubBeginResource</td><td align="left">%%BeginResource</td><td align="left">DSCData</TD>    </TR>    <TR>        <td align="left">kSubEndResource</td><td align="left">%%EndResource</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubIncludeResource</td><td align="left">%%IncludeResource</td><td align="left">DSCData</TD>    </TR>    <TR>        <td align="left">kSubBeginColorspace</td><td align="left">%%BeginResource: ColorSpace &lt;profilename&gt;</td><td align="left">Str255</TD>    </TR>    <TR>        <td align="left">kSubDocProcessColors</td><td align="left">%%DocumentProcessColors</td><td align="left">DSCProcessColors</TD>    </TR>    <TR>        <td align="left">kSubPSAdobeQuery</td><td align="left">%!PS-Adobe-3.0</td><td align="left">Query Fixed</TD>    </TR>    <TR>        <td align="left">kSubViewOrientation</td><td align="left">%%ViewingOrientation</td><td align="left">DSCViewingOrientation</td>        </tr>                <TR>        <td align="left">kSubDocFontsAtEnd</td><td align="left">%%DocumentFonts: (atend)</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubDocNeededFontsAtEnd</td><td align="left">%%DocumentNeededFonts: (atend)</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubDocNeededResAtEnd</td><td align="left">%%DocumentNeededResources: (atend)</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubDocSuppliedFontsAtEnd</td><td align="left">%%DocumentSuppliedFonts: (atend)</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left">kSubDocSuppliedResAtEnd</td><td align="left">%%DocumentSuppliedResources: (atend)</td><td align="left">none defined</TD>    </TR></table><BR><P>Table 2 presents the equivalent information for those subsections that have DSC comments that are defined as part of the Open Structuring Conventions portion of the DSC specification. The prefix <CODE>%ADO</CODE> is registered by Adobe Systems. The prefix <CODE>%RBI</CODE> is registered by RBI Software Systems. Apple has created and uses a number of Open Structuring Comments based on these prefixes. These subsections are fairly self-explanatory.</P><BR><TABLE>    <TR>        <td width=500 align=left><H2 ALIGN=CENTER>Table 2 </H2>        </TD>    </TR></table><br><TABLE border=1>    <TR>        <TH>Subsection</th><th>%RBI DSC Comment</th><th>info data points to</TH>    </TR>    <TR>    <td align="left">kSubBeginBitmapFont</td> <td align="left">%RBIBeginBitmapFont</td><td align="left">Str255</TD>    </TR>        <TR>        <td align="left">kSubEndBitmapFont</td><td align="left">%RBIEndBitmapFont</td><td align="left">none defined</TD>    </TR>        <TR>    <td align="left">kSubBeginTrueTypeFont</td><td align="left">%RBIBeginTrueTypeFont</td><td align="left">Str255</TD>    </TR>        <TR>        <td align="left">kSubEndTrueTypeFont</td><td align="left">%RBIEndTrueTypeFont</td><td align="left">none defined</TD>    </TR>            <TR>    <td align="left">kSubBeginTrueTypeScaler</td><td align="left">%RBIBeginFontRasterizer</td><td align="left">none defined</TD>    </TR>            <TR><td align="left">kSubEndTrueTypeScaler</td><td align="left">%RBIEndFontRasterizer</td><td align="left">none defined</TD>    </TR>        <TR>        <td align="left">kSubRBINumCopies</td><td align="left">%RBINumCopies:</td><td align="left">SInt32 (-1 =unknown)</TD>    </TR>            <TR>        <td align="left">kSubRBINupNess</td><td align="left">%RBINupNess</td><td align="left">DSCNupNess</TD>    </TR>            <TR>        <td align="left">kSubRBIPCFileName</td><td align="left">%RBIPCFileName</td><td align="left">Str255</TD>    </TR>            <TR>    <td align="left">kSubRBIProduct</td><td align="left">%RBIPPDFileVersion</td><td align="left">Str255</TD>    </TR>        <TR>    <td align="left">kSubBeginPageSlotInvocation</td><td align="left">%RBIBeginPageSlotInvocation</td><td align="left">none defined</TD>    </TR>    <TR><td align="left">kSubEndPageSlotInvocation</td><td align="left">%RBIEndPageSlotInvocation</td><td align="left">none defined</td></tr><TR><td align="left">kSubIncludePageSlotInvocation</td><td align="left">%RBIIncludePageSlotInvocation</td><td align="left">  none defined</td></tr><TR><td align="left">kSubRBIBeginNonPPDFeature</td><td align="left">%RBIBeginNonPPDFeature: main option</td><td align="left">DSCFeature</TD>    </TR>        <TR>    <td align="left">kSubRBIEndNonPPDFeature</td><td align="left">%RBIEndNonPPDFeature</td><td align="left">none defined</TD>    </TR>        <TR>    <td align="left">kSubRBIIncludeNonPPDFeature</td><td align="left">%RBIIncludeNonPPDFeature: mainoption</td><td align="left">DSCFeature</td></tr><TR><td align="left">kSubIncludeStartNup</td><td align="left">%RBIIncludeStartnup</td><td align="left">DSCNupData</TD>    </TR>        <TR>    <td align="left">kSubRBIDocSuppliedFonts</td><td align="left">%RBIDocumentSuppliedFonts:</td><td align="left">DSCData</td></tr><TR><td align="left">kSubRBIDocSuppliedFontsAtEnd</td><td align="left">%RBIDocumentSuppliedFonts: (atend)</td><td align="left">none defined</TD>    </TR>        <TR>        <td align="left">kSubADOImageableArea</td><td align="left">%ADO_ImageableArea: fixed fixed fixed fixed</td><td align="left">DSCFixedBBox</TD>    </TR>        <TR>        <td align="left">kSubAnnotateFontKey</td><td align="left">%RBIFontKey: (fontname) 10point bold</td><td align="left">DSCFontAnnotation </TD>    </TR></table><P>Table 3 lists a number of subsections that don't correspond to any DSC comment at all. Each listed subsection is discussed briefly after Table 3.</P><TABLE>    <TR>        <td width=500 align=left><H2 ALIGN=CENTER>Table 3 </H2>        </TD>    </TR></table><br><TABLE border=1>    <TR>        <TH>Subsection</TH> <TH>code emitted</TH> <TH>info data points to</TH>    </TR>        <TR>        <td align="left">kSubStartNup</td><td align="left">... startnup</td><td align="left">DSCNupData</TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubNupFinalPage</td><td align="left">finalpage</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubInfoTitle</td><td align="left">/Title(document name)def</td><td align="left">Str255</TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubInfoPages</td><td align="left">/Pages 22 def</td><td align="left">SInt32 (-1 = Unknown)</TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubInfoCreator</td><td align="left">/Creator(Finder: LaserWriter 8 8.7)def</td><td align="left">Str255 </TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubInfoDate</td><td align="left">/CreationDate(1:52 PM Thursday, March 11, 1999)def</td><td align="left">Str255</TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubInfoFor</td><td align="left">/For(John Doe)def</td><td align="left">Str255</TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubPageSaveLevelSetup</td><td align="left">pmSVsetup</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubPageSaveLevelRestore</td><td align="left">endp</td><td align="left">none defined </TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubPSBegin</td><td align="left">psb</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubPSEnd</td><td align="left">pse</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubPSBeginNoSave</td><td align="left">no code emitted</TD>    <td align="left">none defined</TD>    </TR>        <TR>        <td align="left">kSubPSEndNoSave</td><td align="left">no code emitted</TD>    <td align="left">none defined</TD>    </TR>        <TR>        <td align="left">kSubSetJobStatusStr</td><td align="left">(username; page: 1 of 4)setjob</td><td align="left">DSCJobStatus</TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubPageGStateSetup</td><td align="left">initializepage</td><td align="left">none defined</TD>    </TR>    <TR>        <td align="left"></TD>    </TR>    <TR>        <td align="left">kSubPageMTSMatrixSetup</td><td align="left">mTSsetup</td><td align="left">none defined</TD>    </TR></table><BR><P>The subsection <CODE>kSubStartNup</CODE> tags code emitted when printing with N-up layout printing or printing with 1-up layout with borders. The contents of any supplied <CODE>DSCNupData</CODE> data describe the layout specified. The contents of the PostScript invocation code vary depending on what is being invoked.</P><P>The subsection <CODE>kSubNupFinalPage</CODE> tags code near the end of an N-up layout print job. The purpose of this PostScript code is to ensure that any partially completed N-up page is ejected.</P><P>The subsections <CODE>kSubInfoTitle</CODE>, <CODE>kSubInfoPages</CODE>, <CODE>kSubInfoCreator</CODE>, <CODE>kSubInfoDate</CODE>, and <CODE>kSubInfoFor</CODE> tag code that LaserWriter 8/PrintingLib emits to fill in a dictionary called <CODE>dscInfo</CODE> that it creates after the header comments and before emitting its prolog code.</P><P>The subsection <CODE>kSubPageSaveLevelSetup</CODE> tags the code that creates the page save level.</P><P>The subsection <CODE>kSubPageSaveLevelRestore</CODE> tags the code that does the page-level restore.</P><P>The subsections <CODE>kSubPSBegin</CODE> and <CODE>kSubPSBeginNoSave</CODE> tag the execution of an application's invocation of the QuickDraw <CODE>PicComments</CODE> <CODE>PostScriptBegin</CODE> and <CODE>PostScriptBeginNoSave</CODE>, respectively. The data stream after <CODE>kSubPSBegin</CODE> (or <CODE>PostScriptBeginNoSave</CODE>) and before <CODE>kSubPSEnd</CODE> (or <CODE>kSubPSEndNoSave</CODE>) is application supplied PostScript language code, not code that is generated by LaserWriter 8/PrintingLib. The <CODE>kSubPSBegin</CODE> subsection differs from the <CODE>kSubPSBeginNoSave</CODE> subsection in that, with the former, the PostScript output contains code to create a PostScript-save level so that when the application emits the <CODE>PostScriptEnd</CODE> <CODE>PicComment</CODE> the state prior to the <CODE>PostScriptBegin</CODE> is restored.</P><P>The subsection <CODE>kSubSetJobStatusStr</CODE> tags code which defines the PostScript job name and other data which become part of the status string returned by a printer when executing a print job.</P><P>The subsection <CODE>kSubPageGStateSetup</CODE> tags code which sets up the page's QuickDraw coordinate system for a given print job.</P><P>The subsection <CODE>kSubPageMTSMatrixSetup</CODE> tags code which ensures that the <CODE>mTS</CODE> matrix matches the QuickDraw coordinate system for the page.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Apple reserves all section and subsection values not listed in the header file "PSSubsection.h" and may define new section and subsection values in the future. Filters writers should be prepared to encounter section or subsection values not defined to date and to act appropriately, typically by treating such data as the section <code>kSectAnon</code> or the subsection <CODE>kSubAnon</CODE>.</P></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1179.html%3Fid%3DDTS10003018-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1179.html%3Fid%3DDTS10003018-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1179.html%3Fid%3DDTS10003018-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>