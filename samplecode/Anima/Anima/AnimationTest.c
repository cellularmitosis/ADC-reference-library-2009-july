//// © Copyright 1991 Apple Computer, Inc.  By Ricardo Batista//// Sprite Manager test application//// 05/16/91//#include <Types.h>#include <QuickDraw.h>#include <QDOffscreen.h>#include <Memory.h>#include <OSUtils.h>#include <Windows.h>#include <Fonts.h>#include <Menus.h>#include <TextEdit.h>#include <Events.h>#include <Packages.h>#include <OSEvents.h>#include <Desk.h>#include <ToolUtils.h>#include <Scrap.h>#include <Resources.h>#include <Retrace.h>#include <SysEqu.h>#include "SpriteMgr.h"#define		appleMenu			128#define		fileMenu			129#define		editMenu			130#define		setupMenu			131#define		quitItem			1#define		undoItem			1#define		cutItem				3#define		copyItem			4#define		pasteItem			5#define		clearItem			6#define		kCopyGItem			1#define		kCatItem			2#define		kHoleItem			3#define		kSkyItem			4#define		kWindowItem			5#define		kClockItem			6#define		okItem				1#define		cancelItem			2short Initialize(void);void SetMenus(void);void AnalizeKeys(void);Boolean Working(void);Boolean DoCommand(long mResult);void DoAbout();Boolean HandleMouseDowns(void);void CloseUp(void);void UpdateDisplayWindow(void);void UpdateAnimation(void);EventRecord myEvent;MenuHandle myMenu[5];WindowPtr displayWindow;Boolean shiftK, commandK, optionK;Boolean inFront;Boolean activeMenus;Boolean cursorInvisible;short yBackID[4];short rBackID[5];short clockID;short windowID;short skyID;short catID;Point catPoint;short mouseHoleID;Point mouseHolePoint;Boolean doingCat, doingHole, hasWindow, hasSky, hasClock;main(){	if (Initialize())		return;	while (Working())		;	CloseUp();}void UpdateDisplayWindow(void){	GrafPtr savePort;		GetPort(&savePort);	SetPort(displayWindow);	BeginUpdate(displayWindow);	DoAnimation(true);	EndUpdate(displayWindow);	SetPort(savePort);}void CloseUp(void){	if (cursorInvisible)		ShowCursor();	CloseSpriteMgr();	displayWindow = 0L;}short Initialize(void){	register short counter;	Rect box;	short err;	PicHandle picH;	Rect bYellowRect;	Rect bRedBlueFloorRect;		for (counter = 0; counter < 10; counter++)		MoreMasters();	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	TEInit();	InitMenus();	InitDialogs(0L);	DrawMenuBar();	FlushEvents(everyEvent,0L);	InitCursor();	MaxApplZone();	InitAllPacks();	SetMenus();	activeMenus = true;	cursorInvisible = false;	box.top = box.left = box.right = box.bottom = 0;	picH = GetPicture(141);		// yellow background	if (picH) {		LoadResource((Handle) picH);		bYellowRect = (**picH).picFrame;	}	picH = GetPicture(143);		// red and blue tiles for floor	if (picH) {		LoadResource((Handle) picH);		bRedBlueFloorRect = (**picH).picFrame;	}	box.bottom = bYellowRect.bottom + bRedBlueFloorRect.bottom;	box.right = bYellowRect.right * 4;	err = InitSpriteMgr(0L);	if (err) {		CloseSpriteMgr();		return(err);	}	displayWindow = (WindowPtr) NewAnimation(&box, box.right, box.bottom, "SpriteMgr Test");	if (!displayWindow) {		CloseSpriteMgr();		return(1);	}	SetPort(displayWindow);	box = bYellowRect;	for (counter = 0; counter < 4; counter++) {		yBackID[counter] = NewBackground(141, counter + 1, srcCopy, &box, 141 - counter);		box.left += bYellowRect.right;		box.right += bYellowRect.right;	}	box = bRedBlueFloorRect;	box.top += bYellowRect.bottom;	box.bottom += bYellowRect.bottom;	for (counter = 0; counter < 5; counter++) {		rBackID[counter] = NewBackground(143, counter + 20, srcCopy, &box, 143 + counter);		box.left += bRedBlueFloorRect.right;		box.right += bRedBlueFloorRect.right;	}				catID = NewSprite(140, 1, transparent, 0L, 0L, 140, 0L, false, 140);	catPoint.h = 10;	catPoint.v = 200;	PutSprite(catID, catPoint.v, catPoint.h);		mouseHoleID = NewForegroundSprite(134, 1, transparent, 0L, 0L, 134, 0L, false, 134);	mouseHolePoint.v = 270;	mouseHolePoint.h = 5;	PutSprite(mouseHoleID, mouseHolePoint.v, mouseHolePoint.h);		ActivateAnimation();	DoAnimation(false);		// to show initial screen	doingCat = false;	doingHole = true;	CheckItem(myMenu[setupMenu - 128], kCatItem, doingCat);	CheckItem(myMenu[setupMenu - 128], kHoleItem, doingHole);	hasWindow = hasSky = hasClock = false;	return(0);}void SetMenus(){	char appleStr[2];		appleStr[0] = 1;	appleStr[1] = 0x14;	myMenu[appleMenu - 128] = NewMenu(appleMenu,appleStr);	myMenu[fileMenu - 128] = NewMenu(fileMenu,"\pFile");	myMenu[editMenu - 128] = NewMenu(editMenu,"\pEdit");	myMenu[setupMenu - 128] = NewMenu(setupMenu,"\pTest");		AppendMenu(myMenu[appleMenu - 128],"\pAbout Color Sprites...;(-");	AddResMenu(myMenu[appleMenu - 128],'DRVR');		AppendMenu(myMenu[fileMenu - 128],"\pQuit/Q");	AppendMenu(myMenu[editMenu - 128],"\pUndo;(-;Cut/X;Copy/C;Paste/V;Clear");	AppendMenu(myMenu[setupMenu - 128],"\pCopy a GWorld to screen, d6=id;Move Cat;Move MouseHole");	AppendMenu(myMenu[setupMenu - 128],"\pSky;Window;Clock;(-;optionKey = selective update;commandKey = suspend animation");	InsertMenu(myMenu[appleMenu - 128],0);	InsertMenu(myMenu[fileMenu - 128],0);	InsertMenu(myMenu[editMenu - 128],0);	InsertMenu(myMenu[setupMenu - 128],0);	DrawMenuBar();}void AnalizeKeys(){	if (myEvent.modifiers & cmdKey)		commandK = true;	else		commandK = false;	if (myEvent.modifiers & shiftKey)		shiftK = true;	else		shiftK = false;	if (myEvent.modifiers & optionKey)		optionK = true;	else		optionK = false;}Boolean Working(){	register char theChar;	register Boolean event;	WindowPtr w;	KeyMap keys;		GetKeys(&keys[0]);	if (keys[3] & 0x8) {		// left		if (doingCat) {			catPoint.h -= 8;			MoveSpriteTo(catID, catPoint.h, catPoint.v, 0);		}		if (doingHole) {			mouseHolePoint.h -= 4;			MoveSpriteTo(mouseHoleID, mouseHolePoint.h, mouseHolePoint.v, 0);		}	}	if (keys[3] & 0x20) {		// down		if (doingCat) {			catPoint.v += 8;			MoveSpriteTo(catID, catPoint.h, catPoint.v, 0);		}		if (doingHole) {			mouseHolePoint.v += 4;			MoveSpriteTo(mouseHoleID, mouseHolePoint.h, mouseHolePoint.v, 0);		}	}	if (keys[3] & 0x10) {		// right		if (doingCat) {			catPoint.h += 8;			MoveSpriteTo(catID, catPoint.h, catPoint.v, 0);		}		if (doingHole) {			mouseHolePoint.h += 4;			MoveSpriteTo(mouseHoleID, mouseHolePoint.h, mouseHolePoint.v, 0);		}	}	if (keys[3] & 0x40) {		// up		if (doingCat) {			catPoint.v -= 8;			MoveSpriteTo(catID, catPoint.h, catPoint.v, 0);		}		if (doingHole) {			mouseHolePoint.v -= 4;			MoveSpriteTo(mouseHoleID, mouseHolePoint.h, mouseHolePoint.v, 0);		}	}	if (activeMenus || (keys[1] & 0x8000)) {			// command key down, allow menus		if (!activeMenus) {			if (cursorInvisible) {				ShowCursor();				cursorInvisible = false;			}		}		event = WaitNextEvent(everyEvent, &myEvent, 0L, 0L);		AnalizeKeys();	}	else {		if (cursorInvisible == false) {			HideCursor();			cursorInvisible = true;		}		event = false;		DoAnimation(false);	}	if (event) {		switch (myEvent.what) {			case app4Evt:				if (myEvent.modifiers & 128)					inFront = true;				else {					inFront = false;					if (cursorInvisible) {						ShowCursor();						cursorInvisible = false;					}				}				break;			case activateEvt:				w = (WindowPtr) myEvent.message;				if (myEvent.modifiers & activeFlag) {				}				else {				}				break;			case keyDown:			case autoKey:				theChar =  myEvent.message & charCodeMask;				if (commandK) {					if (!DoCommand(MenuKey(theChar)))						return(false);				}				else {					w = FrontWindow();				}				break;			case updateEvt:				w = (WindowPtr) myEvent.message;				if (w == displayWindow) {					UpdateDisplayWindow();				}				break;			case mouseDown:				if (!HandleMouseDowns())					return(false);				break;			default:				break;		}	}	return(true);}void DoAbout(){	MoveTo(100,100);	DrawString("\p A color sprite test by Ricardo Batista");}Boolean DoCommand(long mResult){	register short theItem;	char st[250];	Rect box;	short h, v;	PicHandle picH;		theItem = LoWord(mResult);	switch (HiWord(mResult)) {		case appleMenu:				GetItem(myMenu[0],theItem,st);				if (theItem > 2)					OpenDeskAcc(st);				else					DoAbout();				break;		case fileMenu:				switch (theItem) {					case quitItem:						return(false);						break;					default:						break;				}				break;		case editMenu:				if (!SystemEdit(theItem -1)) {					switch (theItem) {						case undoItem:							break;						case cutItem:							ZeroScrap();							TEToScrap();							break;						case copyItem:							ZeroScrap();							TEToScrap();							break;						case pasteItem:							TEFromScrap();							break;						case clearItem:							break;						default:							break;					}				}				break;		case setupMenu:				if (theItem == kCopyGItem)					CopyGToScreen();				if (theItem == kCatItem) {					if (doingCat)						doingCat = false;					else						doingCat = true;					CheckItem(myMenu[setupMenu - 128], kCatItem, doingCat);				}				if (theItem == kHoleItem) {					if (doingHole)						doingHole = false;					else						doingHole = true;					CheckItem(myMenu[setupMenu - 128], kHoleItem, doingHole);				}				if (theItem == kClockItem) {					if (hasClock) {						hasClock = false;						KillSprite(clockID);					}					else {						hasClock = true;						clockID = NewBackgroundSprite(200, 4, transparent, 0L, 30L, 200, 0L,											false, 200);						PutSprite(clockID, 60, 100);					}					CheckItem(myMenu[setupMenu - 128], kClockItem, hasClock);				}				if (theItem == kWindowItem) {					if (hasWindow) {						hasWindow = false;						KillSprite(windowID);					}					else {						hasWindow = true;						windowID = NewBackgroundSprite(131, 1, transparent, 0L, 0L, 131, 0L, false, 131);						PutSprite(windowID, 80, 260);					}					CheckItem(myMenu[setupMenu - 128], kWindowItem, hasWindow);				}				if (theItem == kSkyItem) {					if (hasSky) {						hasSky = false;						KillBackground(skyID);					}					else {						hasSky = true;						picH = GetPicture(131);		// need window frame						if (picH) {							LoadResource((Handle) picH);							box = (**picH).picFrame;	// get window rectangle, but needs compensation						}						h = box.right - box.left;						v = box.bottom - box.top;						box.top = 80 + 4;						box.bottom = 80 + v - 4;						box.left = 260 + 6;	// compensate for edges of window						box.right = 260 + h - 8;						skyID = NewBackground(136, 200, srcCopy, &box, 200);						AutoScrollBackground(skyID, 0, 2, 20L);					}					CheckItem(myMenu[setupMenu - 128], kSkyItem, hasSky);				}				break;			default:				break;	}	HiliteMenu(0);	return(true);}Boolean HandleMouseDowns(void){	WindowPtr whichWindow;	Rect box;	long new;	short v, h;		switch (FindWindow(myEvent.where,&whichWindow)) {		case inSysWindow:			SystemClick(&myEvent,whichWindow);			break;		case inMenuBar:			return(DoCommand(MenuSelect(myEvent.where)));			break;		case inGrow:			SetRect(&box,160,100,600,600);			new = GrowWindow(whichWindow,myEvent.where,&box);			if (new) {				v = HiWord(new);				h = LoWord(new);				SetPort(whichWindow);				SizeWindow(whichWindow,h,v,true);				EraseRect(&(whichWindow->portRect));				InvalRect(&(whichWindow->portRect));			}			break;		case inGoAway:			if (TrackGoAway(whichWindow,myEvent.where))				return(false);			break;		case inDrag:			if (commandK || (FrontWindow() == whichWindow))				DragWindow(whichWindow,myEvent.where,&qd.screenBits.bounds);			else {				SelectWindow(whichWindow);				SetPort(whichWindow);			}			break;		case inContent:			 if (whichWindow != FrontWindow()) {				SelectWindow(whichWindow);				SetPort(whichWindow);			}			else {				if (whichWindow == displayWindow) {					if (activeMenus == false) {						DeactivateAnimation();						ShowCursor();						activeMenus = true;						cursorInvisible = false;					}					else {						ActivateAnimation();						HideCursor();						activeMenus = false;						cursorInvisible = true;					}				}			}			break;		default:			break;	}	return(true);}