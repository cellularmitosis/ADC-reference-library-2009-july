<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>URL Loading System: Using NSURLConnection</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Using NSURLConnection"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20001836" title="Using NSURLConnection"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../Networking-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000453" target="_top">Networking</a> &gt; <a href="../index.html" target="_top">URL Loading System</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Concepts/AsyncConnection.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="UsingNSURLDownload.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20001836-BAJEAIEE" title="Using NSURLConnection"></a><hr /><H1>Using NSURLConnection</H1><p>NSURLConnection provides the most flexible method of downloading the contents of a URL. It provides a simple interface for creating and cancelling a connection, and supports a collection of delegate methods that provide feedback and control of many aspects of the connection. These classes fall into five categories: URL loading, cache management, authentication and credentials, cookie storage, and protocol support.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="UsingNSURLConnection.html#//apple_ref/doc/uid/20001836-170129">Creating a Connection</a>
				
			<br/>
			
        
			
			
				<a href="UsingNSURLConnection.html#//apple_ref/doc/uid/20001836-160106">Handling Request Changes</a>
				
			<br/>
			
        
			
			
				<a href="UsingNSURLConnection.html#//apple_ref/doc/uid/20001836-160393">Handling Authentication Challenges</a>
				
			<br/>
			
        
			
			
				<a href="UsingNSURLConnection.html#//apple_ref/doc/uid/20001836-169425">Controlling Response Caching</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20001836-170129" title="Creating a Connection"></a><h2>Creating a Connection</h2><p>In order to download the contents of a URL, an application needs to provide a delegate object that, at a minimum, implements the following delegate methods: <code>connection:didReceiveResponse:</code>, <code>connection:didReceiveData:</code>, <code>connection:didFailWithError:</code> and <code>connectionDidFinishLoading:</code>.</p><p>The example in <span class="content_text">Listing 1</span> initiates a connection for a URL. It begins by creating an NSURLRequest instance for the URL, specifying the cache access policy and timeout interval for the connection. It then creates an NSURLConnection instance using the request and specifying the delegate. If NSURLConnection can’t create a connection for the request, <code>initWithRequest:delegate:</code> returns <code>nil</code>. If the connection is successful, an instance of NSMutableData is created to store the data that will be provided to the delegate incrementally.</p><a name="//apple_ref/doc/uid/20001836-161568-CJBJIIHH" title="Listing 1Creating a connection using NSURLConnection."></a><p class="codesample"><a name="//apple_ref/doc/uid/20001836-161568" title="Listing 1Creating a connection using NSURLConnection."></a><strong>Listing 1&nbsp;&nbsp;</strong>Creating a connection using NSURLConnection.</p><div class="codesample"><table><tr><td scope="row"><pre>// create the request<span></span></pre></td></tr><tr><td scope="row"><pre>NSURLRequest *theRequest=[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.apple.com/"]<span></span></pre></td></tr><tr><td scope="row"><pre>                        cachePolicy:NSURLRequestUseProtocolCachePolicy<span></span></pre></td></tr><tr><td scope="row"><pre>                    timeoutInterval:60.0];<span></span></pre></td></tr><tr><td scope="row"><pre>// create the connection with the request<span></span></pre></td></tr><tr><td scope="row"><pre>// and start loading the data<span></span></pre></td></tr><tr><td scope="row"><pre>NSURLConnection *theConnection=[[NSURLConnection alloc] initWithRequest:theRequest delegate:self];<span></span></pre></td></tr><tr><td scope="row"><pre>if (theConnection) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the NSMutableData that will hold<span></span></pre></td></tr><tr><td scope="row"><pre>    // the received data<span></span></pre></td></tr><tr><td scope="row"><pre>    // receivedData is declared as a method instance elsewhere<span></span></pre></td></tr><tr><td scope="row"><pre>    receivedData=[[NSMutableData data] retain];<span></span></pre></td></tr><tr><td scope="row"><pre>} else {<span></span></pre></td></tr><tr><td scope="row"><pre>    // inform the user that the download could not be made<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The download starts immediately upon receiving the <code>initWithRequest:delegate:</code> message. It can be canceled any time before the delegate receives a <code>connectionDidFinishLoading:</code> or <code>connection:didFailWithError:</code> message by sending the connection a <code>cancel</code> message.</p><p>When the server has provided sufficient data to create an NSURLResponse object, the delegate receives a <code>connection:didReceiveResponse:</code> message. The delegate method can examine the provided NSURLResponse and determine the expected content length of the data, MIME type, suggested filename and other metadata provided by the server.</p><p> It's important that the delegate be prepared to receive the <code>connection:didReceiveResponse:</code> message multiple times for a connection. This message can be sent due to server redirects, or in rare cases multi-part MIME documents. Each time the delegate receives the <code>connection:didReceiveResponse:</code> message, it should reset any progress indication and discard all previously received data. The example implementation in <span class="content_text">Listing 2</span> simply resets the length of the received data to 0 each time it is called.</p><a name="//apple_ref/doc/uid/20001836-161881-CJBGAECH" title="Listing 2Example connection:didReceiveResponse: implementation"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001836-161881" title="Listing 2Example connection:didReceiveResponse: implementation"></a><strong>Listing 2&nbsp;&nbsp;</strong>Example connection:didReceiveResponse: implementation</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // this method is called when the server has determined that it<span></span></pre></td></tr><tr><td scope="row"><pre>    // has enough information to create the NSURLResponse<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // it can be called multiple times, for example in the case of a<span></span></pre></td></tr><tr><td scope="row"><pre>    // redirect, so each time we reset the data.<span></span></pre></td></tr><tr><td scope="row"><pre>    // receivedData is declared as a method instance elsewhere<span></span></pre></td></tr><tr><td scope="row"><pre>    [receivedData setLength:0];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>As the connection progresses the delegate is sent <code>connection:didReceiveData:</code> messages as the data is received. The delegate implementation is responsible for storing the newly received data. In the example implementation in <span class="content_text">Listing 3</span>, the new data is appended to the NSMutableData object created in <span class="content_text">Listing 1</span>.</p><a name="//apple_ref/doc/uid/20001836-161937-CJBHEGJE" title="Listing 3Example connection:didReceiveData: implementation"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001836-161937" title="Listing 3Example connection:didReceiveData: implementation"></a><strong>Listing 3&nbsp;&nbsp;</strong>Example connection:didReceiveData: implementation</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // append the new data to the receivedData<span></span></pre></td></tr><tr><td scope="row"><pre>    // receivedData is declared as a method instance elsewhere<span></span></pre></td></tr><tr><td scope="row"><pre>    [receivedData appendData:data];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>You can also use the <code>connection:didReceiveData:</code> method to provide an indication of the connection’s progress to the user.</p><p>If an error is encountered during the download, the delegate receives a <code>connection:didFailWithError:</code> message. The NSError object passed as the parameter specifies the details of the error. It also provides the URL of the request that failed in the user info dictionary using the key <code><a href="../../../Reference/Foundation/Classes/NSError_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSErrorFailingURLStringKey" target="_top">NSErrorFailingURLStringKey</a></code>.</p><p>After the delegate receives a message <code>connection:didFailWithError:</code>, it receives no further delegate messages for the specified connection. </p><p>The example in <span class="content_text">Listing 4</span> releases the connection, as well as any received data, and logs the error.</p><a name="//apple_ref/doc/uid/20001836-161986-CJBEDGCB" title="Listing 4Example connectionDidFailWithError: implementation"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001836-161986" title="Listing 4Example connectionDidFailWithError: implementation"></a><strong>Listing 4&nbsp;&nbsp;</strong>Example connectionDidFailWithError: implementation</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)connection:(NSURLConnection *)connection<span></span></pre></td></tr><tr><td scope="row"><pre>  didFailWithError:(NSError *)error<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // release the connection, and the data object<span></span></pre></td></tr><tr><td scope="row"><pre>    [connection release];<span></span></pre></td></tr><tr><td scope="row"><pre>    // receivedData is declared as a method instance elsewhere<span></span></pre></td></tr><tr><td scope="row"><pre>    [receivedData release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // inform the user<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"Connection failed! Error - %@ %@",<span></span></pre></td></tr><tr><td scope="row"><pre>          [error localizedDescription],<span></span></pre></td></tr><tr><td scope="row"><pre>          [[error userInfo] objectForKey:NSErrorFailingURLStringKey]);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Finally, if the connection succeeds in downloading the request, the delegate receives the <code>connectionDidFinishLoading:</code> message. The delegate will receive no further messages for the connection and the NSURLConnection object can be released. </p><p>The example implementation in <span class="content_text">Listing 5</span> logs the length of the received data and releases both the connection object and the received data.</p><a name="//apple_ref/doc/uid/20001836-162021-CJBDFIAH" title="Listing 5Example connectionDidFinishLoading: implementation"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001836-162021" title="Listing 5Example connectionDidFinishLoading: implementation"></a><strong>Listing 5&nbsp;&nbsp;</strong>Example connectionDidFinishLoading: implementation</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)connectionDidFinishLoading:(NSURLConnection *)connection<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // do something with the data<span></span></pre></td></tr><tr><td scope="row"><pre>    // receivedData is declared as a method instance elsewhere<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"Succeeded! Received %d bytes of data",[receivedData length]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // release the connection, and the data object<span></span></pre></td></tr><tr><td scope="row"><pre>    [connection release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [receivedData release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This represents the simplest implementation of a client using NSURLConnection. Additional delegate methods provide the ability to customize the handling of server redirects, authorization requests and caching of the response.</p><a name="//apple_ref/doc/uid/20001836-160106" title="Handling Request Changes"></a><h2>Handling Request Changes</h2><p>It’s not uncommon for a server to redirect a request for one URL to another URL. The NSURLConnection delegate will receive a <code>connection:willSendRequest:redirectResponse:</code> when this occurs. </p><p>If the delegate implements this method it can examine the new NSURLRequest and the NSURLResponse that caused the redirect and allow the redirected NSURLRequest to be used for the connection, create a new NSURLRequest for the connection, reject the redirect and have the connection return any data received from the NSURLResponse that caused the redirect, or cancel the download entirely.</p><p>To allow the redirect, the delegate should return the provided NSURLRequest. The delegate could also create a new NSURLRequest, pointing to a new URL, and return that request.</p><p>If the delegate wishes to reject the redirect, but receive any existing data for the connection, the method should return <code>nil</code>. </p><p>Finally, the delegate can cancel the redirect and the connection, by sending the <code>cancel</code> message to <code>connection</code>.</p><p>The delegate will also receive this message if the NSURLProtocol subclass that handles the request has changed the NSURLRequest in order to standardize its format, for example, changing a request for “<code>http://www.apple.com</code>” to “<code>http://www.apple.com/</code>“. This is required because the standardized, or canonical, version of the request is used for cache management. In this special case, the response passed to the delegate is <code>nil</code> and the delegate should simply return the provided NSURLRequest.</p><p>The example implementation in <span class="content_text">Listing 6</span> allows canonical changes and denies all server redirects.</p><a name="//apple_ref/doc/uid/20001836-162065-CJBEGEGI" title="Listing 6Example connection:willSendRequest:redirectResponse: implementation."></a><p class="codesample"><a name="//apple_ref/doc/uid/20001836-162065" title="Listing 6Example connection:willSendRequest:redirectResponse: implementation."></a><strong>Listing 6&nbsp;&nbsp;</strong>Example connection:willSendRequest:redirectResponse: implementation.</p><div class="codesample"><table><tr><td scope="row"><pre>-(NSURLRequest *)connection:(NSURLConnection *)connection<span></span></pre></td></tr><tr><td scope="row"><pre>            willSendRequest:(NSURLRequest *)request<span></span></pre></td></tr><tr><td scope="row"><pre>           redirectResponse:(NSURLResponse *)redirectResponse<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSURLRequest *newRequest=request;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (redirectResponse) {<span></span></pre></td></tr><tr><td scope="row"><pre>        newRequest=nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return newRequest;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If the delegate doesn't implement <code>connection:willSendRequest:redirectResponse:</code>, all canonical changes and server redirects are allowed.</p><a name="//apple_ref/doc/uid/20001836-160393" title="Handling Authentication Challenges"></a><h2>Handling Authentication Challenges</h2><p>If a request requires authentication and there are no valid credentials available, either as part of the requested URL or in the shared NSURLCredentialStorage, the NSURLConnection delegate receives a <code>connection:didReceiveAuthenticationChallenge:</code> message. In order for the connection to continue, the delegate must provide credentials to attempt to use for authentication, attempt to continue without credentials, or cancel the authentication request.</p><p>The NSURLAuthenticationChallenge instance passed to the delegate contains information about what triggered the authentication challenge, the number of attempts that have been made for the challenge, any attempted credentials, the NSURLProtocolSpace that requires the credentials, and the sender of the challenge.</p><p>Often the delegate prompts the user to enter a valid user name and password. If the authentication challenge has tried to authenticate and failed, the attempted credentials are returned by sending <code>challenge</code> a <code>proposedCredential</code> message. The delegate can then use these credentials to populate a dialog that it presents to the user. </p><p>Invoking <code>previousFailureCount</code> on the challenge parameter returns the number of authentication attempts. The delegate can provide this information to the end user, to determine if the credentials it supplied previously are failing, or to limit the maximum number of authentication attempts.</p><p>To attempt to authenticate, the application should create an NSURLCredential object with the user name, password and the type of persistence to use for the credentials, and then send the <code>[challenge sender]</code> a <code>useCredential:forAuthenticationChallenge:</code> message. </p><p>If the delegate chooses not to provide a credential for the authentication challenge, it can attempt to continue without one by sending <code>[challenge sender]</code> a <code>continueWithoutCredentialsForAuthenticationChallenge:</code> message. Depending on the protocol implementation, this may return alternate URL contents that don’t require authentication or cause the connection to fail, receiving a <code>connectionDidFailWithError:</code> message. </p><p>The delegate may also choose to cancel the authentication challenge by sending <code>cancelAuthenticationChallenge:</code> to <code>[challenge sender]</code>. The delegate receives a <code>connection:didCancelAuthenticationChallenge:</code> message providing the opportunity to give the user feedback.</p><p>The example implementation in <span class="content_text">Listing 7</span> attempts to authenticate the challenge by creating an NSURLCredential instance using a user name and password supplied by the application’s preferences. If the authentication has failed previously, it cancels the authentication challenge and informs the user. </p><a name="//apple_ref/doc/uid/20001836-161563-CJBCHIGI" title="Listing 7Example of connection:didReceiveAuthenticationChallenge: delegate method"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001836-161563" title="Listing 7Example of connection:didReceiveAuthenticationChallenge: delegate method"></a><strong>Listing 7&nbsp;&nbsp;</strong>Example of connection:didReceiveAuthenticationChallenge: delegate method</p><div class="codesample"><table><tr><td scope="row"><pre>-(void)connection:(NSURLConnection *)connection<span></span></pre></td></tr><tr><td scope="row"><pre>        didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([challenge previousFailureCount] == 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSURLCredential *newCredential;<span></span></pre></td></tr><tr><td scope="row"><pre>        newCredential=[NSURLCredential credentialWithUser:[self preferencesName]<span></span></pre></td></tr><tr><td scope="row"><pre>                                                 password:[self preferencesPassword]<span></span></pre></td></tr><tr><td scope="row"><pre>                                              persistence:NSURLCredentialPersistenceNone];<span></span></pre></td></tr><tr><td scope="row"><pre>        [[challenge sender] useCredential:newCredential<span></span></pre></td></tr><tr><td scope="row"><pre>               forAuthenticationChallenge:challenge];<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        [[challenge sender] cancelAuthenticationChallenge:challenge];<span></span></pre></td></tr><tr><td scope="row"><pre>        // inform the user that the user name and password<span></span></pre></td></tr><tr><td scope="row"><pre>        // in the preferences are incorrect<span></span></pre></td></tr><tr><td scope="row"><pre>        [self showPreferencesCredentialsAreIncorrectPanel:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>If the delegate doesn’t implement <code>connection:didReceiveAuthenticationChallenge:</code> and the request requires authentication, valid credentials must already be available in the NSURLCredentialStorage or must be provided as part of the requested URL. If the credentials are not available or fail to authenticate, a <code>continueWithoutCredentialForAuthenticationChallenge:</code> message is sent by the underlying implementation.</p><a name="//apple_ref/doc/uid/20001836-169425" title="Controlling Response Caching"></a><h2>Controlling Response Caching</h2><p>By default the data for a connection is cached according to the support provided by the NSURLProtocol subclass that handles the request. An NSURLConnection delegate can further refine that behavior by implementing <code>connection:willCacheResponse:</code>. </p><p>This delegate method can examine the provided NSCachedURLResponse object and change how the response is cached, perhaps restricting its storage to memory only or preventing it from being cached altogether. It is also possible to insert objects in an NSCachedURLResponse’s user info dictionary, causing them to be stored in the cache as part of the response.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001836-DontLinkElementID_9" title="Note"></a><p><strong>Note:</strong>&nbsp;The delegate receives <code>connection:willCacheResponse:</code> messages only for protocols that support caching.</p></div><p>The example in <span class="content_text">Listing 8</span> prevents the caching of <code>https</code> responses. It also adds the current date to the user info dictionary for responses that are cached.</p><a name="//apple_ref/doc/uid/20001836-162142-CJBJJIHI" title="Listing 8Example connection:withCacheResponse: implementation"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001836-162142" title="Listing 8Example connection:withCacheResponse: implementation"></a><strong>Listing 8&nbsp;&nbsp;</strong>Example connection:withCacheResponse: implementation</p><div class="codesample"><table><tr><td scope="row"><pre>-(NSCachedURLResponse *)connection:(NSURLConnection *)connection<span></span></pre></td></tr><tr><td scope="row"><pre>                 willCacheResponse:(NSCachedURLResponse *)cachedResponse<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSCachedURLResponse *newCachedResponse=cachedResponse;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ([[[[cachedResponse response] URL] scheme] isEqual:@"https"]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        newCachedResponse=nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSDictionary *newUserInfo;<span></span></pre></td></tr><tr><td scope="row"><pre>        newUserInfo=[NSDictionary dictionaryWithObject:[NSCalendarDate date]<span></span></pre></td></tr><tr><td scope="row"><pre>                                                 forKey:@"Cached Date"];<span></span></pre></td></tr><tr><td scope="row"><pre>        newCachedResponse=[[[NSCachedURLResponse alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                            initWithResponse:[cachedResponse response]<span></span></pre></td></tr><tr><td scope="row"><pre>                    data:[cachedResponse data]<span></span></pre></td></tr><tr><td scope="row"><pre>                        userInfo:newUserInfo<span></span></pre></td></tr><tr><td scope="row"><pre>                               storagePolicy:[cachedResponse storagePolicy]]<span></span></pre></td></tr><tr><td scope="row"><pre>                           autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return newCachedResponse;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Concepts/AsyncConnection.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="UsingNSURLDownload.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/URLLoadingSystem/Tasks/UsingNSURLConnection.html%3Fid%3D10000165i-2.7&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/URLLoadingSystem/Tasks/UsingNSURLConnection.html%3Fid%3D10000165i-2.7&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/URLLoadingSystem/Tasks/UsingNSURLConnection.html%3Fid%3D10000165i-2.7&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
