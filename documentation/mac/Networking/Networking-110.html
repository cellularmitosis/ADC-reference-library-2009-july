<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Opening and Maintaining an ADSP Connection(IM:N)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING110></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Networking-109.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-111.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Networking-2.html"><B>Networking</B></A> / <BR><DD><A HREF="Networking-98.html"><B>Chapter 5 - AppleTalk Data Stream Protocol (ADSP) </B></A> / <A HREF="Networking-107.html"><B>Using ADSP</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING110-0></A>
<H2><A NAME=MARKER-9-150></A><A NAME=MARKER-21-151></A>Opening and Maintaining an ADSP Connection</H2>
 <A NAME=MARKER-2-35></A>To use ADSP to establish and maintain a connection between a socket on your local node and a remote socket, use the following procedure:<P>
<OL>
<LI>Use the Device Manager's <CODE>OpenDriver</CODE> function to open the .MPP driver, and then use it again to open the .DSP driver. The .MPP driver must be open before you open the .DSP driver. The <CODE>OpenDriver</CODE> function call for the .DSP driver returns the driver reference number. You must supply this reference number each time you call the Device Manager's <CODE>PBControl</CODE> function to execute an ADSP routine. 
<LI>Allocate nonrelocatable memory for a CCB, send and receive queues, and an attention-<BR>message buffer. If you need to allocate the memory dynamically while the program <BR>is running, use the <CODE>NewPtr</CODE> routine. Otherwise, the way in which you allocate the memory depends on the compiler you are using. (<A HREF=#MARKER-9-181>Listing 5-1 on page 5-17</A> shows how to do this in Pascal.) The memory that you allocate becomes the property of ADSP when you call the <CODE>dspInit</CODE> routine to establish a connection end. You cannot write any data to this memory except by calling ADSP, and you must ensure that the memory remains locked until you call the <CODE>dspRemove</CODE> routine to eliminate the connection end.<A NAME=MARKER-2-90></A><P>
<A NAME=MARKER-2-94></A><A NAME=MARKER-2-54></A><A NAME=MARKER-9-15></A>The CCB is 242 bytes. The attention-message buffer must be 570 bytes. When you send bytes to a remote connection end, ADSP stores the bytes in a buffer called the <B>send queue.</B> Until the remote connection end acknowledges their receipt, ADSP keeps the bytes you sent in the send queue so that they are available to be retransmitted if necessary. When the local connection end receives bytes, it stores them in a buffer, called the <B>receive queue,</B> until you read them. The sizes you need for the send and receive queues depend on the lengths of the messages being sent. <P>
ADSP does not transmit data from the remote connection end until there is room for <BR>it in your receive queue. If your send or receive queues are too small, they limit the speed with which you can transmit and receive data. A queue size of 600 bytes should work well for most applications. If you are using ADSP to send a continuous flow <BR>of data, a larger data buffer improves performance. If your application is sending or receiving the user's keystrokes, a smaller buffer should be adequate. The constant <CODE>minDSPQueueSize</CODE>, which is defined in the MPW interface file for ADSP, indicates the minimum queue size that you can use.<P>
If you are using a version of the<A NAME=MARKER-2-159></A> .DSP driver prior to version 1.5, you must allocate send and receive queues that are 12 percent larger than the actual buffer sizes you need. You must do this in order to provide some extra space for use by the .DSP driver. Version 1.5 and later versions of the .DSP driver use a much smaller, and variable, portion of buffer space for overhead. The .DSP driver version number is stored in the low byte of the <CODE>qFlags</CODE> field, which is the first field in the <CODE>dCtlQHdr</CODE> field in the driver's device control entry (DCE) data structure. Version 1.5 of the <BR>.DSP driver has a version number of 4 in the DCE. See the chapter "Device Manager" in <I><A HREF="../Devices/Devices-2.html">Inside Macintosh: Devices</A></I> for information on the DCE.
<LI>Use the <CODE>dspInit</CODE> routine to establish a connection end. You must provide pointers <BR>to the CCB, send queue, receive queue, and attention-message buffer. You may also provide a pointer to a user routine that ADSP calls when your connection end <BR>receives an unsolicited connection event. See the section<A HREF=Networking-112.html#MARKER-9-190>"Writing a User Routine for Connection Events" on page 5-26</A> for information on providing a user routine.<P>
If there is a specific socket that you want to use for the connection end, you can specify the socket number in the <A NAME=MARKER-2-68></A><CODE>localSocket</CODE> parameter. If you want ADSP to assign the socket for you, specify 0 for the <CODE>localSocket</CODE> parameter; in this case, ADSP returns the socket number when the <CODE>dspInit</CODE> routine completes execution.
<LI>If you wish, you can use the Name-Binding Protocol (NBP) routines to add the name and address of your connection end to the node's names table. See the chapter "Name-Binding Protocol (NBP)" in this book for information on NBP. 
<LI><A NAME=MARKER-2-82></A>You can use the <CODE>dspOptions</CODE> routine to set several parameters that control the behavior of the connection end. Because every parameter has a default value, the use of the <CODE>dspOptions</CODE> routine is optional. You can specify values for the following parameters:<A NAME=MARKER-2-152></A><P>
<UL>
<LI>The <CODE>sendBlocking</CODE> parameter, which sets the maximum number of bytes that may accumulate in the send queue before ADSP sends a packet to the remote connection end. You can experiment with different values of the <CODE>sendBlocking</CODE> parameter to determine which provides the best performance. Under most circumstances, the default value of 16 bytes gives good performance.
<LI>The <CODE>badSeqMax</CODE> parameter, which sets the maximum number of out-of-sequence data packets that the local connection end can receive before requesting the remote connection end to retransmit the missing data. Under most circumstances, the default value of 3 provides good performance. 
<LI>The <CODE>useCheckSum</CODE> parameter, which determines whether the Datagram Delivery Protocol (DDP) should compute a checksum and include it in each packet that it sends to the remote connection end. Using checksums slows communications slightly. Normally ADSP and DDP perform enough error checking to ensure safe delivery of all data. Set the <CODE>useCheckSum</CODE> parameter to 1 only if you feel that the network is highly unreliable.<P>
</UL>
<LI>Call <A NAME=MARKER-2-61></A>the <CODE>dspOpen</CODE> routine to open the connection. The <CODE>dspOpen</CODE> routine has four possible modes of operation: <CODE>ocAccept</CODE>, <CODE>ocEstablish</CODE>, <CODE>ocRequest</CODE>, and <CODE>ocPassive</CODE>. Normally you use either the <CODE>ocRequest</CODE> or <CODE>ocPassive</CODE> mode. You must specify one of these four modes for the <CODE>ocMode</CODE> parameter when you call <BR>the <CODE>dspOpen</CODE> routine. <P>
The <CODE>ocAccept</CODE> mode is used only by <A NAME=MARKER-2-164></A>connection servers. The <CODE>ocEstablish</CODE> mode <BR>is used by routines that determine their connection-opening parameters and establish a connection independently of ADSP, but use ADSP to transmit and receive data.<P>
Use the <CODE>ocRequest</CODE> mode when you want to establish communications with a specific socket on the AppleTalk internet. When you execute the <CODE>dspOpen</CODE> routine <BR>in the <CODE>ocRequest</CODE> mode, ADSP sends an open-connection request to the address <BR>you specify. <P>
If the socket to which you send the open-connection request is a connection listener, the connection server that operates that connection listener can select any socket <BR>on the internet to be the connection end that responds to the open-connection request. To restrict the socket from which you will accept a response to your open-connection request, specify a value for the <CODE>filterAddress</CODE> parameter to the <CODE>dspOpen</CODE> routine. When your connection end receives a response from a socket that meets the restrictions of the <CODE>filterAddress</CODE> parameter, it acknowledges the response and ADSP completes the connection. <P>
To use the <CODE>ocRequest</CODE> mode, you must know the complete internet address of the remote socket, and the ADSP client at that address must either be a connection listener or have executed the <CODE>dspOpen</CODE> routine in the <CODE>ocPassive</CODE> mode. You can use the NBP routines to obtain a list of names of objects on the internet and to determine the internet address of a socket when you know its name. See the chapter "Name-Binding Protocol (NBP)" in this book for information on the NBP routines.<P>
Use the <CODE>ocPassive</CODE> mode when you expect to receive an open-connection request from a remote socket. You can specify a value for the <CODE>filterAddress</CODE> parameter to restrict the network number, node ID, or socket number from which you will accept an open-connection request. When your connection end receives an open-connection <A NAME=MARKER-2-109></A>request that meets the restrictions of the <CODE>filterAddress</CODE> parameter, it acknowledges the request and ADSP completes the connection. <P>
You can poll the state field in the CCB to determine when the connection end is waiting to receive an open-connection request, when the connection end is waiting to receive an acknowledgment of an open-connection request, and when the connection is open. See the section <A HREF=Networking-117.html#MARKER-9-232>"The ADSP Connection Control Block Record" beginning on page 5-35</A> for a description of the CCB fields. Alternatively, you can check the result code for the <CODE>dspOpen</CODE> routine when the routine completes execution. If the routine returns the <CODE>noErr</CODE> result code, then the connection is ope<A NAME=MARKER-2-42></A>n.
<LI>Use the <A NAME=MARKER-2-91></A><CODE>dspRead</CODE> routine to read data that your connection end has received from <BR>the remote connection end. Use the <CODE>dspWrite</CODE> routine to send data to the remote connection end. Use the <A NAME=MARKER-2-122></A><CODE>dspAttention</CODE> routine to send attention messages to the remote connection end.<P>
<A NAME=MARKER-2-79></A>The <CODE>dspWrite</CODE> routine places data in the send queue. ADSP is a full-duplex, symmetric communications protocol: You can send data at any time, and your connection end can receive data at any time, even at the same time as you are sending data. ADSP transmits the data in the send queue when one of the following conditions occurs:<P>
<UL>
<LI>You call the <A NAME=MARKER-2-140></A><CODE>dspWrite</CODE> routine with the flush parameter set to a nonzero number.
<LI>The number of bytes in the send queue equals or exceeds the blocking factor that you set with the <CODE>dspOptions</CODE> routine.
<LI>The send timer expires. The send timer sets the maximum amount of time that can pass before ADSP sends all unsent data in the send queue to the remote connection end. ADSP calculates the best value to use for this timer and sets it automatically.
<LI>A connection event requires that the local connection end send an acknowledgment packet to the remote connection end.<P>
<A NAME=MARKER-2-80></A>If you send more data to the send queue than it can hold, the <CODE>dspWrite</CODE> routine does not complete execution until it has written all the data to the send queue. If you execute the <CODE>dspWrite</CODE> routine asynchronously, ADSP returns control to your program and writes the data to the send queue as quickly as it can. This technique provides the most efficient use of the send queue by your program and by ADSP. Because ADSP does not remove data from the send queue until that data has been not only sent but also acknowledged by the remote connection end, using the <CODE>flush</CODE> parameter to the <CODE>dspWrite</CODE> routine does not guarantee that the send queue is empty. You can use <BR>the <CODE>dspStatus</CODE> routine to determine how much free buffer space is available in the send queue.<P>
The <A NAME=MARKER-2-120></A><CODE>dspRead</CODE> routine reads data from the receive queue into your application's private data buffer. ADSP does not transmit data until there is space available in <BR>the other end's receive queue to accept it. Because a full receive queue slows the communications rate, you should read data from the receive queue as often as necessary to keep sufficient buffer space available for new data. You can use either <BR>of two techniques to do this:
<LI>Allocate a small receive queue (about 600 bytes) and call the <CODE>dspRead</CODE> routine asynchronously. Your completion routine for the <CODE>dspRead</CODE> routine should then <BR>call the <CODE>dspRead</CODE> routine again.
<LI>Allocate a large receive queue and call the <CODE>dspRead</CODE> routine less frequently. <P>
If there is less data in the receive queue than the amount you specify with the <CODE>reqCount</CODE> parameter to the <CODE>dspRead</CODE> command, the command does not complete execution until there is enough data available to satisfy the request. There are three exceptions to this rule: 
<LI>If the end-of-message bit in the ADSP packet header is set, the <CODE>dspRead</CODE> command reads the data in the receive queue, returns the actual amount of data read in the <CODE>actCount</CODE> parameter, and returns the <CODE>eom</CODE> parameter set to 1. 
<LI>If you have closed the connection end before calling the <CODE>dspRead</CODE> routine (that is, the connection is half open), the command reads whatever data is available and returns the actual amount of data read in the <CODE>actCount</CODE> parameter. 
<LI>If ADSP has closed the connection before you call the <CODE>dspRead</CODE> routine and there is no data in the receive queue, the routine returns the <CODE>noErr</CODE> result code with the <CODE>actCount</CODE> parameter set to 0 and the <CODE>eom</CODE> parameter set to 0.<P>
In addition to the byte-stream data format implemented by the <CODE>dspRead</CODE> and <CODE>dspWrite</CODE> routines, ADSP provides a mechanism for sending and receiving control signals or information separate from the byte stream. You use the <CODE>dspAttention</CODE> routine to send an attention code and an attention message to the remote connection end. When your connection end receives an attention message, ADSP's interrupt handler sets the <CODE>eAttention</CODE> flag in the <CODE>userFlags</CODE> field of the CCB and calls your user routine. Your user routine must first clear the <CODE>userFlags</CODE> field. Then your routine can read the attention code and attention message and take whatever action you deem appropriate. <A NAME=MARKER-2-28></A><P>
Because ADSP is often used by terminal emulation programs and other applications that pass the data they receive on to the user without processing it, attention messages provide a mechanism for the applications that are clients of the connection ends to communicate with each other. For example, you could use attention messages to implement a handshaking and data-checking protocol for a program that transfers disk files between two applications, neither one of which is a file server. Or a database server on a mainframe computer that uses ADSP to communicate with Macintosh computer workstations could use the attention mechanism to inform the workstations when the database is about to be closed down for<A NAME=MARKER-2-4></A> maintenan<A NAME=MARKER-2-76></A>ce.<A NAME=MARKER-2-93></A><P>
</UL>
<LI><A NAME=MARKER-2-145></A>When you are ready to close the ADSP connection, you can use the <CODE>dspClose</CODE> or <CODE>dspRemove</CODE> routine to close the connection end. Use the <CODE>dspClose</CODE> routine if you intend to use that connection end to open another connection and do not want <BR>to release the memory you allocated for the connection end. Use the <CODE>dspRemove</CODE> routine if you are completely finished with the connection end and want to release <BR>the memory.<P>
You can continue to read data from the receive queue after you have called the <CODE>dspClose</CODE> routine, but not after you have called the <CODE>dspRemove</CODE> routine. You can <BR>use the <CODE>dspStatus</CODE> routine to determine whether any data is remaining in the receive queue, or you can read data from the receive queue until both the <CODE>actCount</CODE> and <BR><CODE>eom</CODE> fields of the <CODE>dspRead</CODE> parameter block return 0.<P>
If you set the <CODE>abort</CODE> parameter for the <CODE>dspClose</CODE> or <CODE>dspRemove</CODE> routine to 0, then ADSP does not close the connection or the connection end until it has sent--and received acknowledgment for--all data in the send queue and any pending attention messages. If you set the <CODE>abort</CODE> parameter to 1, then ADSP discards any data in the send queue and any attention messages that have not already been sent.<P>
After you have executed the <CODE>dspRemove</CODE> routine, you can release the memory you allocated for the CCB and data buffers.<P>
</OL>
 <A HREF=#MARKER-9-181>Listing 5-1</A> illustrates the use of ADSP. This routine opens the .MPP and .DSP drivers and allocates memory for its internal data buffers, for the CCB, and for the send, receive, and attention-message buffers. Then the routine uses the <CODE>dspInit</CODE> routine to establish a connection end and uses NBP to register the name of the connection end on the internet. (The user routine specified by the <CODE>userRoutine</CODE> parameter to the <CODE>dspInit</CODE> function is shown in <A HREF=Networking-112.html#MARKER-9-198>Listing 5-3 on page 5-28</A>.) Next, <A HREF=#MARKER-9-181>Listing 5-1</A> uses the <CODE>dspOptions</CODE> routine to <BR>set the blocking factor to 24 bytes. This routine then uses NBP to determine the address of a socket whose name was selected by the user and sends an open-connection request (<CODE>dspOpen</CODE>) to that socket. When the <CODE>dspOpen</CODE> routine completes execution, it sends data and an attention message to the remote connection end and reads data from its receive queue. Finally, the routine closes the connection end with the <CODE>dspRemove</CODE> routine and releases the memory it allocated.<A NAME=MARKER-2-180></A><P>
<B>Listing 5-1  <A NAME=MARKER-9-181></A><A NAME=MARKER-21-182></A>U<A NAME=MARKER-2-174></A>sing ADSP to establish and use a connection</B><P>
<PRE>
PROCEDURE MyADSP;
CONST
   qSize =  600;                       {queue space}
   myDataSize =   128;                 {size of internal read/write buffers}
   blockFact = 24;                     {blocking factor}

TYPE
{Modify the connection control block to add storage for A5.}
myTRCCB = 
   RECORD
      myA5: LongInt;
      u: TRCCB;
   END;
VAR
   dspSendQPtr:      Ptr;
   dspRecvQPtr:      Ptr;
   dspAttnBufPtr:    Ptr;
   myData2ReadPtr:   Ptr;
   myData2WritePtr:  Ptr;
   myAttnMsgPtr:     Ptr;
   dspCCB:           myTRCCB;
   myDSPPBPtr:       DSPPBPtr;
   myMPPPBPtr:       MPPPBPtr;
   myNTEName:        NamesTableEntry;
   myAddrBlk:        AddrBlock;
   drvrRefNum:       Integer;
   mppRefNum:        Integer;
   connRefNum:       Integer;
   gReceivedAnEvent: Boolean;
   myAttnCode:       Integer;
   tempFlag:         Byte;
   tempCFlag:        Integer;
   myErr:            OSErr;
BEGIN 
   myErr := OpenDriver('.MPP', mppRefNum);   {open .MPP driver}
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);      {check and handle error}
   myErr := OpenDriver('.DSP', drvrRefNum);  {open .DSP driver}
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);      {check and handle error}
   
   {Allocate memory for data buffers.}
   dspSendQPtr := NewPtr(qSize);             {ADSP use only}
   dspRecvQPtr := NewPtr(qSize);             {ADSP use only}
   dspAttnBufPtr := NewPtr(attnBufSize);     {ADSP use only}
   myData2ReadPtr := NewPtr(myDataSize);
   myData2WritePtr := NewPtr(myDataSize);
   myAttnMsgPtr := NewPtr(myDataSize);
   myDSPPBPtr := DSPPBPtr(NewPtr(SizeOf(DSPParamBlock)));
   myMPPPBPtr := MPPPBPtr(NewPtr(SizeOf(MPPParamBlock)));
   WITH myDSPPBPtr^ DO                       {set up dspInit parameters}
   BEGIN
      ioCRefNum := drvrRefNum;               {ADSP driver ref num}
      csCode := dspInit;
      ccbPtr := @dspCCB;                     {pointer to CCB}
      userRoutine := @myConnectionEvtUserRoutine;
                                             {see Listing 5-3}
      sendQSize := qSize;                    {size of send queue}
      sendQueue := dspSendQPtr;              {send-queue buffer}
      recvQSize := qSize;                    {size of receive queue}
      recvQueue := dspRecvQPtr;              {receive-queue buffer}
      attnPtr := dspAttnBufPtr;              {receive-attention buffer}
      localSocket := 0;                      {let ADSP assign socket}
   END;

   gReceivedAnEvent := FALSE;
   dspCCB.myA5 := SetCurrentA5;              {save A5 for the user routine}
   {Establish a connection end.}
   myErr := PBControl(ParmBlkPtr(myDSPPBPtr), FALSE);
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);   
                                             {check and handle error}
   connRefNum := myDSPPBPtr^.ccbRefNum;   
                                             {save CCB ref num for later}
   NBPSetNTE(@myNTEName, 'The Object', 'The Type',
             '*', myDSPPBPtr^.localSocket);
                                             {set up NBP names table entry}
   WITH myMPPPBPtr^ DO                       {set up PRegisterName }
                                             { parameters}
   BEGIN
      interval := 7;                         {retransmit every 7*8=56 ticks}
      count := 3;                            {retry 3 times}
      entityPtr := @myNTEName;               {name to register}
      verifyFlag := 1;                       {verify this name}
   END;
   {Register this socket.}
   myErr := PRegisterName(myMPPPBPtr, FALSE);
                                             {register this socket}
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);
                                             {check and handle error}
   WITH myDSPPBPtr^ DO                       {set up dspOptions parameters}
   BEGIN
      ioCRefNum := drvrRefNum;               {ADSP driver ref num}
      csCode := dspOptions;
      ccbRefNum := connRefNum;               {connection ref num}
      sendBlocking := blockFact;             {quantum for data packet}
      badSeqMax := 0;                        {use default}
      useCheckSum := 0;                      {don't calculate checksum}
   END;
   myErr := PBControl(ParmBlkPtr(myDSPPBPtr), FALSE);
                                             {set options}
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);
                                             {check and handle error}
   PickASocket(myAddrBlk);                   {routine using the PLookupName }
                                             { function to pick a socket }
                                             { for the connection}
   {Open a connection with the selected socket.}
   WITH myDSPPBPtr^ DO                       {set up dspOpen parameters}
   BEGIN
      ioCRefNum := drvrRefNum;               {ADSP driver ref num}
      csCode := dspOpen;
      ccbRefNum := connRefNum;               {connection ref num}
      remoteAddress := myAddrBlk;            {address of remote socket }
                                             { from PLookupName function}
      filterAddress := myAddrBlk;            {address filter,specified }
                                             { socket address only}
      ocMode := ocRequest;                   {open connection mode}
      ocInterval := 0;                       {use default retry interval}
      ocMaximum := 0;                        {use default retry maximum}
   END;
   myErr := PBControl(ParmBlkPtr(myDSPPBPtr), FALSE);
                                             {open a connection}
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);      {check and handle error}
   {The connection with the selected socket is open, so now send }
   { to the send queue exactly myDataSize number of bytes.}
   WITH myDSPPBPtr^ DO                       {set up dspWrite parameters}
   BEGIN
      ioCRefNum := drvrRefNum;               {ADSP driver ref num}
      csCode := dspWrite;
      ccbRefNum := connRefNum;               {connection ref num}
      reqCount := myDataSize;                {write this number of bytes}

      dataPtr := myData2WritePtr;            {pointer to send queue}
      eom := 1;                              {1 means last byte is }
                                             { logical end-of-message}
      flush := 1;                            {1 means send data now}
   END;
   myErr := PBControl(ParmBlkPtr(myDSPPBPtr), FALSE);
                                             {send data to the remote }
                                             { connection}
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);
                                             {check and handle error}
   {Now send an attention message to the remote connection end.}
   WITH myDSPPBPtr^ DO                       {set up dspAttention parameters}
   BEGIN
      ioCRefNum := drvrRefNum;               {ADSP driver ref num}
      csCode := dspAttention;
      ccbRefNum := connRefNum;               {connection ref num}
      attnCode := 0;                         {user-defined attention code}
      attnSize := myDataSize;                {length of attention message}
      attnData := myAttnMsgPtr;              {attention message}
   END;
   myErr := PBControl(ParmBlkPtr(myDSPPBPtr), FALSE);
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);
                                             {check and handle error}
   {Now read from the receive queue exactly myDataSize number }
   { of bytes.}
   WITH myDSPPBPtr^ DO                       {set up dspRead parameters}
   BEGIN
      ioCRefNum := drvrRefNum;               {ADSP driver ref num}
      csCode := dspRead;
      ccbRefNum := connRefNum;               {connection ref num}
      reqCount := myDataSize;                {read this number of bytes}
      dataPtr := myData2ReadPtr;             {pointer to read buffer}
   END;
   myErr := PBControl(ParmBlkPtr(myDSPPBPtr), FALSE);
                                             {read data from the remote }
                                             { connection}
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);      {check and handle error}
   {We're finished with the connection, so remove it.}
   WITH myDSPPBPtr^ DO                       {set up dspRemove parameters}
   BEGIN
      ioCRefNum := drvrRefNum;               {ADSP driver ref num}
      csCode := dspRemove;
      ccbRefNum := connRefNum;               {connection ref num}
      abort := 0;                            {don't close until }
                                             { everything is sent and }
                                             { received}
   END;
   myErr := PBControl(ParmBlkPtr(myDSPPBPtr), FALSE);
                                             {close and remove the }
                                             { connection}
   IF myErr &lt;&gt; noErr THEN DOErr(myErr);   
                                             {check and handle error}
   {You're finished with this connection, so release the memory.}
   DisposPtr(dspSendQPtr);
   DisposPtr(dspRecvQPtr);
   DisposPtr(dspAttnBufPtr);
   DisposPtr(myData2ReadPtr);
   DisposPtr(myData2WritePtr);
   DisposPtr(myAttnMsgPtr);
   DisposPtr(Ptr(myDSPPBPtr));
   DisposPtr(Ptr(myMPPPBPtr));
END;        {MyADSP}
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Networking-109.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-111.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Networking-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
