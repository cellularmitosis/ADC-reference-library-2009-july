<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Failure Handling (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING28></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-27.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-29.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-21.html"><B>Part 1 - MacApp Theory and Architecture</B></A><BR><DD><A HREF="MacAppProgGuide-25.html"><B>Chapter 3 - Core Technologies</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING28-0></A>
<H1><A NAME=MARKER-9-77></A><A NAME=MARKER-2-78></A>Failure Handling</H1>
 MacApp provides a failure-handling mechanism that allows your application to clean up after errors. An application can install failure handlers at multiple points. Failure handlers are declared as local variables, and so are stored on the stack. MacApp connects them into a linked list, with each handler pointing to the next handler in the list, as shown in <A HREF=#MARKER-9-79>Figure 3-2</A>. A global variable, <CODE>gTopHandler</CODE>, points to the most recently stored failure handler.<P>
<B>Figure 3-2  <A NAME=MARKER-9-79></A>A linked list of failure handlers, stored on the stack</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-092.gif"><P>
 When an error occurs, the most recent failure handler is retrieved, the previous state of the machine is restored, and execution continues at the location specified by the handler. Optionally, the failure handler may call a specific cleanup routine. On completion, the failure-handling code may return to regular program execution or it may propagate the failure by calling the <CODE>ReSignal</CODE> method to retrieve the next failure handler from the list.<P>
 You install a failure handler by using the <CODE>Try</CODE> macro to bracket code where an error might occur. You follow the <CODE>Try</CODE> branch with code to handle the anticipated failure. For example, you can use a failure handler to bracket a memory allocation loop. If an allocation fails, the failure handler jumps to code that frees any memory that has already been allocated. If no error occurs, you call a method to remove the failure handler from the linked list of failure handlers.<P>
 Failure handling is described in greater detail in the following sections. For additional code samples and information on how to use failure handlers in your application, see <A HREF=MacAppProgGuide-122.html#MARKER-9-19>Chapter 24, "Working With Memory and Failure Handling."</A><P>
<A NAME=HEADING28-7></A>
<H2>The Failure Routine</H2>
 <A NAME=MARKER-2-80></A>References to failure handlers are kept in a linked list, pointed to by a global variable, <CODE>gTopHandler</CODE>, as shown in <A HREF=#MARKER-9-79>Figure 3-2</A>. Each item in the list is an object of type <CODE>FailInfo</CODE>, described in the next section. <CODE>FailInfo</CODE> objects are declared in the routines that use them, so they are stored on the stack.<P>
 When you call the <CODE>Failure</CODE> routine, it retrieves the most recent failure handler from the list, then calls the handler's cleanup routine, if it has one. If the failure handler doesn't have a cleanup routine (most don't), <CODE>Failure</CODE> calls <CODE>longjmp</CODE>, passing the saved state buffer, to restore the previous machine state.<P>
 MacApp supplies routines that check for specific types of errors and call <CODE>Failure</CODE> if they find one. The names of these routines reflect the kind of error they check for: <CODE>FailNIL</CODE>, <CODE>FailNILResource</CODE>, <CODE>FailMemError</CODE>, <CODE>FailOSErr</CODE>, <CODE>FailResError</CODE>, <CODE>FailNoReserve</CODE>, and <CODE>FailSpaceIsLow</CODE>. For more information, see <A HREF=MacAppProgGuide-125.html#MARKER-9-63>"MacApp Error-Checking Routines," beginning on page 562</A>.<P>
 An application can use these MacApp routines, or it can check for an error condition itself and call <CODE>Failure</CODE> directly when it detects an error.<P>
<A NAME=HEADING28-12></A>
<H2>The FailInfo Class</H2>
 MacApp defines the <CODE>FailInfo</CODE> class to implement failure handlers. <CODE><A NAME=MARKER-2-81></A>FailInfo</CODE> includes these features:<P>
<UL>
<LI>a pointer to the next failure handler
<LI>a buffer to save the current machine state
<LI>a reference to a cleanup procedure; if the reference is not <CODE>NULL</CODE>, the procedure is called to clean up after an error instead of using the machine state buffer to jump to the error-handling code
<LI>a <CODE>Success</CODE> method to remove the failure handler from the list when no error occurs
<LI>a <CODE>ReSignal</CODE> method to execute the next failure handler in the list<P>
</UL>
 <A NAME=MARKER-2-83></A>The following code fragment demonstrates how a failure handler is installed:<P>
<PRE>
// Declare a failure handler.
FailInfo theFailureHandler;
// Insert the failure handler in the global list.
Try(theFailureHandler)
{  // Code that may cause a failure.
   .
   .
   .
   // If no failure occurs, remove the failure handler.
   theFailureHandler.Success();
}
else
{  // Code to clean up if an error occurs.
   .
   .
   .
   // In this case, pass error on to next handler.
   theFailureHandler.ReSignal();
}
</PRE>
 The macro <CODE>Try</CODE>, described in the next section, is executed first. It inserts the failure handler in the list and calls <CODE>setjmp</CODE>. If no error occurs, the call to <CODE>Success</CODE> removes the failure handler from the list.<P>
 If an error <I>does</I> occur, the failure handler is processed and causes execution to continue with the <CODE>else</CODE> block of code. If no error occurs, the <CODE>else</CODE> block is never executed and the call to <CODE>Success</CODE> removes the error handler from the list.<P>
 Note that the call to <CODE>ReSignal</CODE>, which retrieves the next failure handler from the list and jumps to the location it specifies, is not always necessary--the local code may handle the error condition completely.<P>
<A NAME=HEADING28-24></A>
<H2>The Try Macro</H2>
 <CODE><A NAME=MARKER-2-84></A>Try</CODE> is implemented as a macro rather than as a method of the <CODE>FailInfo</CODE> class, because the failure-handling code <I>must</I> be inline to properly save the desired machine state. The decision whether or not to put code inline is handled differently by different compilers and can be affected by options such as symbol generation and optimization level. Implementing <CODE>Try</CODE> as a macro takes the decision away from the compiler.<P>
<A NAME=HEADING28-26></A>
<H2><A NAME=MARKER-2-324></A>Saving and Restoring the Machine State</H2>
 When a failure handler is initialized, MacApp inserts it in the linked list of failure handlers and calls the C library routine <CODE><A NAME=MARKER-2-327></A>setjmp</CODE> to save the current machine state in the failure handler's buffer. When a failure occurs, MacApp removes the most recent failure handler from the linked list and calls the <CODE><A NAME=MARKER-2-328></A>longjmp</CODE> routine to restore the saved state. The application resumes execution as if it had just returned from the <CODE>setjmp</CODE> call. The call chain also returns to its previous state, and return statements for any intervening calls are eliminated.<P>
<A NAME=HEADING28-28></A>
<H2>Calling Success to Remove a Failure Handler From the List</H2>
 Calling <CODE>Success</CODE> removes a failure handler when it is no longer needed. Failing to call <A NAME=MARKER-2-356></A><CODE>Success</CODE> the same number of times you call <CODE>Try</CODE> causes a failure handler to be left in the list. This can lead to a program crash for one of two reasons:<P>
<UL>
<LI>The failure handler's saved machine state is no longer valid. If the failure handler is invoked by a subsequent error, program execution will jump to an invalid location.
<LI>Failure handler variables are declared locally and so are stored on the stack. If a failure handler is not removed from the stack before the routine that created it goes out of scope, the failure handler may be overwritten. <P>
</UL>
 An application built with MacApp's debugging support issues a warning if <CODE>Success</CODE> is not called as often as <CODE>Try</CODE>.<P>
<A NAME=HEADING28-33></A>
<H2><A NAME=MARKER-2-89></A><A NAME=MARKER-2-90></A><A NAME=MARKER-9-91></A>The MAVolatile and MAVolatileInit Macros</H2>
 A C++ compiler can optimize code by storing local variables in registers. Doing so can cause problems during failure handling because <CODE>longjmp</CODE> restores registers to the values they had before the error occurred. Thus a variable you wish to use in your recovery code may be set to an incorrect value.<P>
 MacApp supplies the <CODE>MAVolatile</CODE> macro to ensure that a variable is kept out of a register.<CODE> MAVolatile</CODE> can be called on a variable of any type and is guaranteed to work on any compiler, even those that don't support the <CODE>volatile</CODE> keyword. You supply a variable and a type, as in the following line:<P>
<PRE>
MAVolatile(Boolean, pictureIsOpen);
</PRE>
 The <CODE>MAVolatileInit</CODE> macro is a variation on <CODE>MAVolatile</CODE> that both initializes a variable and ensures that it won't be stored in a register. Here you supply a type, a variable, and an initial value. For example, the code<P>
<PRE>
MAVolatileInit(THandleList*, aHandleList, NULL);
</PRE>
 initializes the variable <CODE>aHandleList</CODE> to <CODE>NULL</CODE> and guarantees that it won't be stored in a register.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Don't use the volatile macros with data that will be passed by address or by reference--it won't work without casting or changing the called function to expect a volatile parameter, and it isn't necessary.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING28-41></A>
<H2><A NAME=MARKER-9-92></A>Failure Handling Embedded in Objects</H2>
 MacApp provides a number of classes with embedded failure handling, including <CODE>CArrayIterator</CODE>, <CODE>CTemporaryRegion</CODE>, and <CODE>CTempDesc</CODE>.<P>
 Each of these classes has a <CODE>FailInfo</CODE> field, <CODE>fFailInfo</CODE>, which provides failure handling for the class. These classes provide an example of how to embed failure handling in an object and use a cleanup procedure to handle any failure.<P>
 When an array iterator is initialized, the <CODE>IArrayIterator</CODE> method sets up the iterator's <CODE>fFailInfo</CODE> field by making the following calls:<P>
<PRE>
fFailInfo.Reset();
fFailInfo-&gt;SetCleanupProc(CArrayIterator::CallCleanup, this);
</PRE>
 The <CODE>Reset</CODE> method sets the failure handler to a safe initial state. The <CODE>SetCleanupProc</CODE> method inserts the failure handler in the list and sets its cleanup procedure to the iterator's <CODE>CallCleanup</CODE> method.<P>
 When a failure occurs, MacApp's <CODE>Failure</CODE> routine retrieves the first failure handler from the list and calls its cleanup procedure, if it has one. In this case it calls the array iterator's <CODE>CallCleanup</CODE> method, which in turn calls the iterator's <CODE>Cleanup</CODE> method. <CODE>Cleanup</CODE> frees the iterator's dynamic storage, if necessary. If no failure occurs, the destructor method, <CODE>~CArrayIterator</CODE>, calls <CODE>Success</CODE> to remove the failure handler from the list. (Iterators are discussed in <A HREF=MacAppProgGuide-29.html#MARKER-9-94>"Lists and Iteration," beginning on page 61</A>.)<P>
 You may notice examples in the MacApp class library where an extra code block is inserted around the creation of an iterator object in a situation that requires failure handling. This is done to control the creation and destruction of the iterator's embedded failure handler. By specifically controlling the scope in which the iterator exists, there is no ambiguity about when the iterator is deleted and its failure handler is removed from the list. In addition, controlling the scope may be more efficient and require fewer failure handlers to exist at one time.<P>
 The following sample shows how to introduce an extra code block to control the scope of a failure handler embedded in an iterator.<P>
<PRE>
FailInfo firstFailureHandler;
Try(firstFailureHandler)
{
   // Code that fails here is caught by the first failure handler.

   // Add an extra block here to control destruction of iterator.
   {
      // Note: iterator's constructor installs a failure handler.
      CObjectIterator iter(aFileList);
      for (aFile = (TFile *)iter.FirstObject();
                        iter.More() &amp;&amp; !savedError;
                        aFile = (TFile *)iter.NextObject())
      {
         // Code to open a document for each file in the list.
         // Could run out of memory or experience a file error.
         // Code that fails here is caught by the "iter" object's
         // embedded failure handler.
      } // End for loop

   }  // End extra block. The iterator goes out of scope and 
      // its destructor removes its embedded failure handler
      // from the linked list of failure handlers.

   // Could have more code here.

}  // End Try for firstFailureHandler.
else
{
   // Error recovery code for firstFailureHandler block.
}
</PRE>
 When the code reaches the end of the extra block, the iterator goes out of scope and its destructor calls <CODE>Success</CODE> to remove the embedded failure handler from the list.<A NAME=MARKER-2-93></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-27.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-29.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
