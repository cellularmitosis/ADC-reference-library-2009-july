<!-- legacy work start -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- legacy work end -->


<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)

LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Managing Sound Channels (IM: S)  (deprecated)</Title>

<!-- legacy work start -->
        <META NAME="Generator" CONTENT="manual">
        <META http-equiv="content-type" CONTENT="text/html;charset=utf-8">
        <META NAME = "Copyright" CONTENT="Copyright 2007 Apple Inc. All Rights Reserved.">
        <META NAME="IndexTitle" CONTENT="Inside Macintosh: Sound (Not Recommended)">
        <meta name="xcode-display" content="render">

        <LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css"> <!-- before submitting, globally replace ".." with "developer.apple.com" -->
        <script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
<!-- legacy work end -->

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<A NAME=HEADING51></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Sound-50.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-52.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Sound-2.html"><B>Sound</B></A> / <BR><DD><A HREF="Sound-44.html"><B>Chapter 2 - Sound Manager</B></A> / <A HREF="Sound-50.html"><B>Using the Sound Manager</B></A></DL></FONT><P>
<HR>

<!-- legacy work start -->
<script type="text/javascript"> placeWatermark()</script>
<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
<i>Inside Macintosh: Sound</i> is deprecated as of Mac OS X v10.5. For new audio development in Mac OS X, use Core Audio. See the <a href="http://developer.apple.com/referencelibrary/MusicAudio/" target="_top">Audio</a> page in the ADC Reference Library.</p></div></div></div>
<!-- legacy work end -->


<BLOCKQUOTE>
<A NAME=HEADING51-0></A>
<H2><A NAME=MARKER-9-136></A>Managing Sound Channels</H2>
 To use most of the low-level Sound Manager routines, you must specify a sound channel that maintains a queue of commands. Also, to take advantage of the full capabilities of the high-level Sound Manager routines, including asynchronous sound play, you must allocate your own sound channels. This section explains how your application can allocate, dispose of, and use its own sound channels.<P>
 This section first describes how you can allocate and dispose of sound channels. Then it explains how you can manipulate sounds playing in sound channels, stop sounds playing in sound channels, and pause and restart the execution of sounds in sound channels.<P>
<A NAME=HEADING51-3></A>
<H3><A NAME=MARKER-9-135></A>Allocating Sound Channels<A NAME=MARKER-2-138></A></H3>
 Usually, you do not need to worry about allocating memory for sound channels because the <CODE>SndNewChannel</CODE> function automatically allocates a sound channel record in the application's heap if passed a pointer to a <CODE>NIL</CODE> sound channel. <CODE>SndNewChannel</CODE> also internally allocates memory for the sound channel's queue of sound commands. For example, the following lines of code request that the Sound Manager open a new sound channel for playing sampled sounds:<A NAME=MARKER-2-139></A><P>
<PRE>
mySndChan := NIL;
myErr := SndNewChannel(mySndChan, sampledSynth, 0, NIL);
</PRE>
 If you are concerned with managing memory yourself, you can allocate your own memory for a sound channel record and pass the address of that memory as the first parameter to <CODE>SndNewChannel</CODE>. By allocating a sound channel record manually, you not only obtain control over the allocation of the sound channel record, but you can specify the size of the queue of sound commands that the Sound Manager internally allocates. <A HREF=#MARKER-9-140>Listing 2-1</A> illustrates one way to do this.<P>
<B>Listing 2-1  <A NAME=MARKER-9-140></A>Creating a sound channel</B><P>
<PRE>
FUNCTION MyCreateSndChannel (synth: Integer; initOptions: LongInt;
                              userRoutine: ProcPtr; 
                              queueLength: Integer): SndChannelPtr;
VAR
   mySndChan:  SndChannelPtr;    {pointer to a sound channel}
   myErr:      OSErr;
BEGIN
   {Allocate memory for sound channel.}
   mySndChan := SndChannelPtr(NewPtr(Sizeof(SndChannel)));
   IF mySndChan &lt;&gt; NIL THEN
   BEGIN
      mySndChan^.qLength := queueLength;  {set number of commands in queue}
      {Create a new sound channel.}
      myErr := SndNewChannel(mySndChan, synth, initOptions, userRoutine);
      IF myErr &lt;&gt; noErr THEN
      BEGIN                               {couldn't allocate channel}
         DisposePtr(Ptr(mySndChan));      {free memory already allocated}
         mySndChan := NIL;                {return NIL}
      END
      ELSE
         mySndChan^.userInfo := 0;        {reset userInfo field}
   END;
   MyCreateSndChannel := mySndChan;       {return new sound channel}
END;
</PRE>
 The <CODE>MyCreateSndChannel</CODE> function defined in <A HREF=#MARKER-9-140>Listing 2-1</A> first allocates memory for a sound channel record and then calls the <CODE>SndNewChannel</CODE> function to attempt to allocate a channel. Note that <CODE>MyCreateSndChannel</CODE> checks the result code returned by <CODE>SndNewChannel</CODE> to determine whether the function was able to allocate a channel. The <CODE>SndNewChannel</CODE> function might not be able to allocate a channel if there are so many channels open that allocating another would put too much strain on the CPU. Also, <CODE>SndNewChannel</CODE> might fail if memory is low. (In addition to the memory for a sound channel record that is passed in the first parameter to <CODE>SndNewChannel</CODE>, the function must internally allocate memory in which to store sound commands.)<P>
 If you allocate memory for a sound channel record, you should specify the size of the queue of sound commands by assigning a value to the <CODE>qLength</CODE> field of the sound channel record you allocate. You can use the constant <CODE>stdQLength</CODE> to obtain a standard queue of 128 sound commands, or you can provide a value of your own. <A NAME=MARKER-2-141></A><P>
<PRE>
CONST
   stdQLength           = 128;   {default size of a sound channel}
</PRE>
 If you know that your application will play only resources containing sampled sound, you might set the <CODE>qLength</CODE> field to a considerably lower value, because resources created with the <CODE>SndRecord</CODE> function (described in the chapter <A HREF=Sound-13.html#MARKER-9-6>"Introduction to Sound on the Macintosh"</A> in this book) contain only one sound command, the <CODE>bufferCmd</CODE> command, which specifies that a buffer of sound should be played. For example, if your application uses a sound channel only to play a single sampled sound asynchronously, you can set <CODE>qLength</CODE> to 2, to allow for the <CODE>bufferCmd</CODE> command and a <CODE>callBackCmd</CODE> command that your application issues manually, as described in <A HREF=Sound-55.html#MARKER-9-292>"Playing Sounds Asynchronously" on page 2-46</A>. By using a smaller than standard queue length, your application can conserve memory.<A NAME=MARKER-2-63></A><A NAME=MARKER-2-64></A><A NAME=MARKER-2-543></A><P>
<DL>
<DT><B>Note</B>
<DD>The number of sound commands in a channel should be an integer greater than 0. If you open a channel with a 0-length queue, most of the Sound Manager routines will return a <CODE>badChannel</CODE> result code.<EM></EM> <A NAME=MARKER-2-145></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
<DT><B>IMPORTANT</B>
<DD>In general, however, you should let the Sound Manager allocate sound channel records for you. The amount of memory you might save by allocating your own is usually negligible.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The second parameter in the <CODE>SndNewChannel</CODE> function specifies the kind of data you want to play on that channel. You can specify one of the following constants:<P>
<PRE>
CONST
   squareWaveSynth   = 1;     {square-wave data}
   waveTableSynth    = 3;     {wave-table data}
   sampledSynth      = 5;     {sampled-sound data}
</PRE>
 In some versions of system software prior to system software version 7.0 (including system software version 6.0.7), high-level Sound Manager routines do not work properly with sound resources that specify the sound data type twice. This might happen if a resource specifies that a sound consists of sampled-sound data and an application does the same when creating a sound channel. This might also happen if an application uses the same sound channel to play several sound resources that contain different kinds of sound data. There are several solutions to this problem that you can use if you must maintain compatibility with old versions of system software:<P>
<UL>
<LI>If your application plays only sampled-sound resources, then you need only ensure that none of the sound resources specifies that it contains sampled-sound data. Then, when you create a sound channel, pass <CODE>sampledSynth</CODE> as the second parameter to <CODE>SndNewChannel</CODE> so that the Sound Manager interprets the data in the sound resources correctly. Do not use the <CODE>SndPlay</CODE> routine.
<LI>If your application must be able to play sampled-sound resources as well as resources that contain square-wave or wave-table data, ensure that all sound resources that your application uses specify their data type. (Sound resources created with the Sound Input Manager automatically specify that they contain sampled-sound data.) Then, when creating a channel in which you plan to play a sound resource, pass 0 as the second parameter to <CODE>SndNewChannel</CODE>, and then use the channel to play no more than one sound resource. 
<LI>If you do not wish to modify your application's sound resources, and your application plays only sampled-sound resources, then you can play sounds with low-level Sound Manager routines, a technique described in <A HREF=Sound-56.html#MARKER-9-350>"Playing Sounds Using Low-Level Routines" on page 2-61</A>. <P>
</UL>
 Note that this problem does not occur with sound files, because sound files always contain sampled-sound data and thus do not explicitly declare their data type. As a result, when creating a channel in which you plan to play a sound file, pass <CODE>sampledSynth</CODE> as the second parameter to <CODE>SndNewChannel</CODE>.<P>
 The third parameter in the <CODE>SndNewChannel</CODE> function specifies the initialization parameters to be associated with the new channel. These are discussed in the following section. The fourth parameter in the <CODE>SndNewChannel</CODE> function is a pointer to a callback procedure. If your application produces sounds asynchronously or needs to be alerted when a command has completed, you can specify a callback procedure by passing the address of that procedure in the fourth parameter and then by installing a callback procedure into the sound channel. If you pass <CODE>NIL</CODE> as the fourth parameter, then no callback procedure is associated with the channel. See <A HREF=Sound-55.html#MARKER-9-292>"Playing Sounds Asynchronously" on page 2-46</A> for more information on setting up and using callback procedures.<A NAME=MARKER-2-448></A><A NAME=MARKER-2-147></A><P>
<A NAME=HEADING51-23></A>
<H3><A NAME=MARKER-9-148></A>Initializing Sound Channels<A NAME=MARKER-2-450></A></H3>
 When you first create a sound channel with <CODE>SndNewChannel</CODE>, you can request that the channel have certain characteristics as specified by a sound channel initialization parameter. For example, to indicate that you want to allocate a channel capable of producing stereo sound, you might use the following code:<A NAME=MARKER-2-151></A><P>
<PRE>
myErr := SndNewChannel(mySndChan, sampledSynth, initStereo, NIL);
</PRE>
 These are the currently recognized constants for the sound channel initialization parameter.<P>
<PRE>
CONST
   initChanLeft      = $0002;    {left stereo channel}
   initChanRight     = $0003;    {right stereo channel}
   waveInitChannel0  = $0004;    {wave-table channel 0}
   waveInitChannel1  = $0005;    {wave-table channel 1}
   waveInitChanne12  = $0006;    {wave-table channel 2}
   waveInitChannel3  = $0007;    {wave-table channel 3}
   initMono          = $0080;    {monophonic channel}
   initStereo        = $00C0;    {stereo channel}
   initMACE3         = $0300;    {3:1 compression}
   initMACE6         = $0400;    {6:1 compression}
   initNoInterp      = $0004;    {no linear interpolation}
   initNoDrop        = $0008;    {no drop-sample conversion}
</PRE>
 See <A HREF=Sound-65.html#MARKER-9-500>"Channel Initialization Parameters" beginning on page 2-91</A> for a complete description of these constants.<P>
<DL>
<DT><B>Note</B>
<DD>Some Macintosh computers play <I>only</I> the left channel of stereo sounds out the internal speaker. Other machines (for example, the Macintosh SE/30 and Macintosh IIsi) mix both channels together before sending a signal to the internal speaker. You can use the <CODE>Gestalt</CODE> function to determine if a particular machine mixes both left and right channels to the internal speaker. All Macintosh computers except the Macintosh SE and the Macintosh Plus, however, play stereo signals out the headphone jack.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The initialization parameters are additive. To initialize a channel for stereo sound with no linear interpolation, simply pass an initialization parameter that is the sum of the desired characteristics, as follows:<P>
<PRE>
myErr := SndNewChannel(mySndChan, sampledSynth, 
                        initStereo+initNoInterp, NIL);
</PRE>
 A call to <CODE>SndNewChannel</CODE> is really only a request that the Sound Manager open a channel having the desired characteristics. It is possible that the parameters requested are not available. In that case, <CODE>SndNewChannel</CODE> returns a <CODE>notEnoughHardwareErr</CODE> error. In general, you should pass 0 as the third parameter to <CODE>SndNewChannel</CODE> unless you know exactly what kind of sound is to be played.<P>
 You can alter certain initialization parameters, even while a channel is actively playing a sound, by issuing the <CODE>reInitCmd</CODE> command. For example, you can change the output channel from left to right, as shown in <A HREF=#MARKER-9-154>Listing 2-2</A>.<P>
<B>Listing 2-2  <A NAME=MARKER-9-154></A>Reinitializing a sound channel</B><P>
<PRE>
VAR
   mySndCmd:         SndCommand;
   mySndChan:        SndChannelPtr;
   myErr:            OSErr;
.
.
.
mySndCmd.cmd := reInitCmd;
mySndCmd.param1 := 0;                        {unused}
mySndCmd.param2 := initChanRight;            {new init parameter}
myErr := SndDoImmediate(mySndChan, mySndCmd);
</PRE>
 The <CODE>reInitCmd</CODE> command accepts the <CODE>initNoInterp</CODE> constant to toggle <A NAME=MARKER-2-38></A><B>linear interpolation</B> on and off; it should be used with noncompressed sounds only. If an noncompressed sound is playing when you send a <CODE>reInitCmd</CODE> command with this constant, linear interpolation begins immediately. You can also pass <CODE>initMono</CODE>, <CODE>initChanLeft</CODE>, or <CODE>initChanRight</CODE> to pan to both channels, to the left channel, or to the right channel. This affects only monophonic sounds. The Sound Manager remembers the settings you pass and applies them to all further sounds played on that channel.<A NAME=MARKER-2-451></A><A NAME=MARKER-2-157></A><A NAME=MARKER-2-158></A><P>
<A NAME=HEADING51-37></A>
<H3>Releasing Sound Channels<A NAME=MARKER-2-453></A></H3>
 To dispose of a sound channel that you have allocated with <CODE>SndNewChannel</CODE>, use the <CODE>SndDisposeChannel</CODE> function. <CODE>SndDisposeChannel</CODE> requires two parameters, a pointer to the channel that is to be disposed and a Boolean value that indicates whether the channel should be flushed before disposal. Here's an example:<A NAME=MARKER-2-160></A><P>
<PRE>
myErr := SndDisposeChannel(mySndChan, TRUE);
</PRE>
 Because the second parameter is <CODE>TRUE</CODE>, the Sound Manager sends both a <CODE>flushCmd</CODE> command and a <CODE>quietCmd</CODE> command to the sound channel (using <CODE>SndDoImmediate</CODE>). This removes all commands from the sound channel and stops any sound already in progress. Then the Sound Manager disposes of the channel.<P>
 If the second parameter is <CODE>FALSE</CODE>, the Sound Manager simply queues a <CODE>quietCmd</CODE> command (using <CODE>SndDoCommand</CODE>) and waits until <CODE>quietCmd</CODE> is received by the channel before disposing of the channel. In this case, the <CODE>SndDisposeChannel</CODE> function does not return until the channel has finished processing commands and the queue is empty.<P>
<DL>
<DT><B>WARNING</B>
<DD><A NAME=MARKER-9-163></A>If you dispose of a channel currently playing from disk, then your completion routine will still execute, but will receive a pointer to a sound channel that no longer exists. Thus, you should stop a play from disk before disposing of a channel. See <A HREF=Sound-55.html#MARKER-9-313>"Managing an Asynchronous Play From Disk" on page 2-52</A> for more information on completion routines.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Although the <CODE>SndDisposeChannel</CODE> function always releases memory reserved for sound commands, <CODE>SndDisposeChannel</CODE> cannot release memory associated with a sound channel record if you have allocated that memory yourself. For example, if you use the <CODE>MyCreateSndChannel</CODE> function defined in <A HREF=#MARKER-9-140>Listing 2-1</A> to create a sound channel, you must dispose first of the sound channel and then of the memory occupied by the sound channel record, as illustrated in <A HREF=#MARKER-9-164>Listing 2-3</A>.<P>
<B>Listing 2-3  <A NAME=MARKER-9-164></A>Disposing of memory associated with a sound channel</B><P>
<PRE>
FUNCTION MyDisposeSndChannel (sndChan: SndChannelPtr; quietNow: Boolean): 
                                 OSErr;
VAR
   myErr:   OSErr;
BEGIN
   myErr := SndDisposeChannel(sndChan, quietNow);  {dispose of channel}
   DisposePtr(Ptr(sndChan));                       {dispose of channel ptr}
   MyDisposeSndChannel := myErr;
END;
</PRE>
 If you have played a sound resource through a channel, the <CODE>SndDisposeChannel</CODE> function does not free the memory taken by the resource. You must call the Resource Manager's <CODE>ReleaseResource</CODE> function to do so, or, if you have detached a resource from a resource file, you could free the memory by making the handle unlocked and purgeable. Note that if you play a sound resource asynchronously, you should not release the memory occupied by the resource until the sound finishes playing or the sound might not play properly. For information on releasing a sound resource after playing a sound asynchronously, see <A HREF=Sound-55.html#MARKER-9-292>"Playing Sounds Asynchronously" on page 2-46</A>.<A NAME=MARKER-2-165></A><A NAME=MARKER-9-505></A><A NAME=MARKER-2-211></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>In Sound Manager versions 3.0 and later, you can play sounds in any number of sound channels. In earlier Sound Manager versions, however, only one kind of sound can be played at one time. This results in several important restrictions on your application. In Sound Manager version 2 and earlier, you should create sound channels just before playing sounds. Once the sound is completed, you should dispose of the channel. If your application is switched out and does not release a sound channel, then other applications may be unable to open sound channels. In particular, the system alert sound might not be heard and the user might not be notified of important system occurrences. In general, while it is acceptable to issue a number of sound commands to the same sound channel, it's not a good idea to play more than one sampled sound on the same sound channel.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING51-48></A>
<H3><A NAME=MARKER-9-168></A>Manipulating a Sound That Is Playing<A NAME=MARKER-2-207></A></H3>
 The Sound Manager provides a number of sound commands that you can use to change some of the characteristics of sounds that are currently playing. For example, you can alter the rate at which a sampled sound is played back, thereby lowering or increasing the pitch of the sound. You can also pause or stop a sound that is currently in progress. See <A HREF=#MARKER-9-193>"Pausing and Restarting Sound Channels" on page 2-29</A> for information on how to pause the processing of a sound channel.<P>
 You can use the <CODE>getRateCmd</CODE> command to determine the rate at which a sampled sound is currently playing. If <CODE>SndDoImmediate</CODE> returns <CODE>noErr</CODE> when you pass <CODE>getRateCmd</CODE>, the current sample rate of the channel is returned as a <CODE>Fixed</CODE> value in the location that is pointed to by <CODE>param2</CODE> of the sound command. (As usual, the high bit of that value returned is not interpreted as a sign bit.) Values that specify sampling rates are always interpreted relative to the 22 kHz rate. That is, the <CODE>Fixed</CODE> value $00010000 indicates a rate of 22 kHz. The value $00020000 indicates a rate of 44 kHz. The value $00008000 indicates a rate of 11 kHz.<A NAME=MARKER-2-556></A><P>
 To modify the pitch of a sampled sound currently playing, use the <CODE>rateCmd</CODE> command. The current pitch is set to the rate specified in the <CODE>param2</CODE> field of the sound command. <A HREF=#MARKER-9-172>Listing 2-4</A> illustrates how to halve the frequency of a sampled sound that is already playing. Note that sending the <CODE>rateCmd</CODE> command before a sound plays has no effect.<A NAME=MARKER-2-168></A><P>
<B>Listing 2-4  <A NAME=MARKER-9-172></A>Halving the frequency of a sampled sound</B><P>
<PRE>
FUNCTION MyHalveFreq (mySndChan: SndChannelPtr): OSErr;
VAR
   myRate:     LongInt;          {rate of sound play}
   mySndCmd:   SndCommand;       {a sound command}
   myErr:      OSErr;
BEGIN
   {Get the rate of the sample currently playing.}
   mySndCmd.cmd := getRateCmd;   {the command is getRateCmd}
   mySndCmd.param1 := 0;         {unused}
   mySndCmd.param2 := LongInt(@myRate);
   myErr := SndDoImmediate(mySndChan, mySndCmd);

   IF myErr = noErr THEN
   BEGIN
      {Halve the sample rate.}
      mySndCmd.cmd := rateCmd;   {the command is rateCmd}
      mySndCmd.param1 := 0;      {unused}
      mySndCmd.param2 := FixDiv(myRate, $00020000);
      myErr := SndDoImmediate(mySndChan, mySndCmd);
   END;
   MyHalveFreq := myErr;
END;
</PRE>
 When you halve the frequency of a sampled sound using the technique in <A HREF=#MARKER-9-172>Listing 2-4</A>, the sound will play one octave lower than before. In addition, the sound will play twice as slowly as before. Likewise, if you use the <CODE>rateCmd</CODE> command to double the frequency of a sound, it plays one octave higher and twice as fast. Using <CODE>rateCmd</CODE> in this way is like pressing the fast forward button on a tape player while the play button remains depressed.<P>
 You can also use <CODE>rateCmd</CODE> and <CODE>getRateCmd</CODE> to pause a sampled sound that is currently playing. To do this, read the rate at which it is playing, issue a <CODE>rateCmd</CODE> command with a rate of 0, and then issue a <CODE>rateCmd</CODE> command with the previous rate when you want the sound to resume playing.<A NAME=MARKER-2-173></A><P>
 <A NAME=MARKER-2-174></A>To change the amplitude (or loudness) of the sound in progress, issue the <CODE>ampCmd</CODE> command. (See <A HREF=#MARKER-9-176>Listing 2-5</A> for an example.) If no sound is currently playing, <CODE>ampCmd</CODE> sets the amplitude of the next sound. Specify the desired new amplitude in the <CODE>param1</CODE> field of the sound command as a value in the range 0 to 255. <A NAME=MARKER-2-104></A><P>
<B>Listing 2-5  <A NAME=MARKER-9-176></A>Changing the amplitude of a sound channel</B><P>
<PRE>
PROCEDURE MySetAmplitude (chan: SndChannelPtr; myAmp: Integer);
VAR
   mySndCmd:   SndCommand;    {a sound command}
   myErr:      OSErr;
BEGIN
   IF chan &lt;&gt; NIL THEN
   BEGIN
      WITH mySndCmd DO
      BEGIN
         cmd := ampCmd;       {the command is ampCmd}
         param1 := myAmp;     {desired amplitude}
         param2 := 0;         {ignored}
      END;
      myErr := SndDoImmediate(chan, mySndCmd);
      IF myErr &lt;&gt; noErr THEN
         DoError(myErr);
   END;
END;
</PRE>
 If your application has an option that allows users to turn off sound output, you could call the <CODE>MySetAmplitude</CODE> procedure on all open channels to set the amplitude of all channels to 0. Note that the Sound control panel allows the user to adjust the sound from 0 (softest) to 7 (loudest). This value is independent of the values used for amplitudes of sounds playing in channels, and the Sound Manager uses the Sound control panel value jointly with the amplitude of a sound channel to determine how loudly to play a sound. Sounds with low frequencies sound softer than sounds with high frequencies even if the sounds play at the same amplitude. If the amplitude of a sound is 0, the sound hardware produces no sound; however, when the value set in the Sound control panel is 0, sound might still play, depending on the amplitude.<A NAME=MARKER-2-177></A><A NAME=MARKER-2-178></A><A NAME=MARKER-9-234></A><A NAME=MARKER-2-232></A><P>
 <A NAME=MARKER-2-181></A>You can use the <CODE>getAmpCmd</CODE> command to determine the current amplitude of a sound in progress. The <CODE>getAmpCmd</CODE> command is similar to <CODE>getRateCmd</CODE>, except that the value returned is an integer. The value returned in <CODE>param2</CODE> is in the range 0-255. <A HREF=#MARKER-9-182>Listing 2-6</A> shows an example:<P>
<B>Listing 2-6  <A NAME=MARKER-9-182></A>Getting the amplitude of a sound in progress</B><P>
<PRE>
VAR
   myAmp:   Integer;
BEGIN
   mySndCmd.cmd := getAmpCmd;
   mySndCmd.param1 := 0;                     {unused}
   mySndCmd.param2 := LongInt(@myAmp);
   myErr := SndDoImmediate(mySndChan, mySndCmd);
END;
</PRE>
 To modify the timbre of a sound defined using by square-wave data, use the <CODE>timbreCmd</CODE> command. A sine wave is specified as 0 in <CODE>param1</CODE> and produces a very clear sound. A value of 254 in <CODE>param1</CODE> represents a modified square wave and produces a buzzing sound. To avoid a bug in some versions of the Sound Manager, you should not use the value 255. You should change the timbre before playing the sound.<A NAME=MARKER-2-111></A><A NAME=MARKER-4-100></A><P>
<A NAME=HEADING51-64></A>
<H3><A NAME=MARKER-9-185></A>Stopping Sound Channels<A NAME=MARKER-2-35></A></H3>
 The Sound Manager allows you both to stop a sound currently in progress in a channel and to remove all pending sound commands from a channel. <P>
<DL>
<DT><B>Note</B>
<DD>If you have started a sound playing by using the <CODE>SndStartFilePlay</CODE> function, then you can stop play by using the <CODE>SndStopFilePlay</CODE> function. See <A HREF=Sound-55.html#MARKER-9-313>"Managing an Asynchronous Play From Disk" on page 2-52</A> for more details.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 To cause the Sound Manager to stop playing the sound in progress, send the <CODE>quietCmd</CODE> command. Here's an example:<P>
<PRE>
mySndCmd.cmd := quietCmd;              {the command is quietCmd}
mySndCmd.param1 := 0;                  {unused}
mySndCmd.param2 := 0;                  {unused}

{stop the sound now playing}
myErr := SndDoImmediate(mySndChan, mySndCmd, FALSE);
</PRE>
 To bypass the command queue, you should issue <CODE>quietCmd</CODE> by using <CODE>SndDoImmediate</CODE>. Any sound commands that are already in the sound channel remain there, however, and further sound commands can be queued in that channel.<A NAME=MARKER-9-180></A><A NAME=MARKER-2-91></A><P>
 If you wish to flush a sound channel without disturbing any sounds already in progress, issue the <CODE>flushCmd</CODE> command. Here's an example:<A NAME=MARKER-2-93></A><A NAME=MARKER-2-37></A><P>
<PRE>
mySndCmd.cmd := flushCmd;              {the command is flushCmd}
mySndCmd.param1 := 0;                  {unused}
mySndCmd.param2 := 0;                  {unused}

{flush the channel}
myErr := SndDoImmediate(mySndChan, mySndCmd, FALSE);
</PRE>
 If you want to stop all sound production by a particular sound channel immediately, you should issue a <CODE>flushCmd</CODE> command and then a <CODE>quietCmd</CODE> command. If you issue only a <CODE>flushCmd</CODE> command, the sound currently playing is not stopped. If you issue only a <CODE>quietCmd</CODE> command, the Sound Manager stops the current sound but continues with any other queued commands. (By calling <CODE>flushCmd</CODE> before <CODE>quietCmd</CODE>, you ensure that no other queued commands are processed.)<P>
<DL>
<DT><B>Note</B>
<DD>The Sound Manager sends a <CODE>quietCmd</CODE> command when your application calls the <CODE>SndDisposeChannel</CODE> function. The <CODE>quietCmd</CODE> command is preceded by a <CODE>flushCmd</CODE> command if the <CODE>quietNow</CODE> parameter is <CODE>TRUE</CODE>.<EM></EM><A NAME=MARKER-2-347></A> <A NAME=MARKER-2-351></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING51-74></A>
<H3><A NAME=MARKER-9-193></A>Pausing and Restarting Sound Channels<A NAME=MARKER-2-194></A></H3>
 If you want to pause command processing in a particular channel, you can use either of two sound commands, <CODE>waitCmd</CODE> or <CODE>pauseCmd</CODE>.<P>
<DL>
<DT><B>Note</B>
<DD>If you have started a sound playing by using the <CODE>SndStartFilePlay</CODE> function, then you can pause and resume play by using the <CODE>SndPauseFilePlay</CODE> function. See <A HREF=Sound-55.html#MARKER-9-313>"Managing an Asynchronous Play From Disk" on page 2-52</A> for more details.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The <CODE>waitCmd</CODE> command suspends all processing in a channel for a specified number of half-milliseconds. Here's an example:<A NAME=MARKER-2-195></A><P>
<PRE>
mySndCmd.cmd := waitCmd;               {the command is waitCmd}
mySndCmd.param1 := 2000;               {1-second wait duration}
mySndCmd.param2 := 0;                  {unused}

{pause the channel}
myErr := SndDoImmediate(mySndChan, mySndCmd, FALSE);
</PRE>
 To pause the processing of commands in a sound channel for an unspecified duration, use the <CODE>pauseCmd</CODE> command. Unlike <CODE>waitCmd</CODE>, <CODE>pauseCmd</CODE> suspends processing for an undetermined amount of time. Processing does not resume until the Sound Manager receives a <CODE>resumeCmd</CODE> command for the specified channel.<A NAME=MARKER-8-102></A><A NAME=MARKER-9-541></A><P>
 To issue <CODE>waitCmd</CODE> or <CODE>pauseCmd</CODE>, you can use either <CODE>SndDoImmediate</CODE> or <CODE>SndDoCommand</CODE>, depending on whether you want the suspension of sound channel processing to begin immediately or when the Sound Manager reaches that command in the normal course of reading commands from a sound channel. The <CODE>resumeCmd</CODE> command, which is simply the opposite of <CODE>pauseCmd</CODE>, should be issued by using <CODE>SndDoImmediate</CODE>. Neither <CODE>waitCmd</CODE> nor <CODE>pauseCmd</CODE> stops any sound that is currently playing; these commands simply stop further processing of commands queued in the sound channel.<P>
<DL>
<DT><B>Note</B>
<DD>If no other commands are pending in the sound channel after a <CODE>resumeCmd</CODE> command, the Sound Manager sends an <CODE>emptyCmd</CODE> command. The <CODE>emptyCmd</CODE> command is sent only by the Sound Manager and should not be issued by your application.<EM></EM><A NAME=MARKER-9-420></A> <A NAME=MARKER-2-199></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING51-82></A>
<H3>Synchronizing Sound Channels<A NAME=MARKER-2-200></A><A NAME=MARKER-2-201></A></H3>
 <A NAME=MARKER-2-202></A>You can synchronize several different sound channels by issuing <CODE>syncCmd</CODE> commands. The <CODE>param1</CODE> field of the sound command contains a count, and the <CODE>param2</CODE> field contains an arbitrary identifier. The Sound Manager keeps track of the count for each channel being synchronized. When the Sound Manager receives a <CODE>syncCmd</CODE> command for a certain channel, it decrements the count for each channel having the given identifier, including the newly synchronized channel. Command processing resumes on a channel when the count becomes 0. Thus, if you know how many channels you need to synchronize, you can synchronize them all by arranging for all of their counts to become zero simultaneously. <A HREF=#MARKER-9-203>Listing 2-7</A> illustrates the use of the <CODE>syncCmd</CODE> command.<P>
<B>Listing 2-7  <A NAME=MARKER-9-203></A>Adding a channel to a group of channels to be synchronized</B><P>
<PRE>
PROCEDURE MySync1Chan (chan: SndChannelPtr; count: Integer;
                        identifier: LongInt);
VAR
   mySndCmd:   SndCommand;       {a sound command}
   myErr:      OSErr;
BEGIN
   WITH mySndCmd DO
   BEGIN
      cmd := syncCmd;            {the command is syncCmd}
      param1 := count;
      param2 := identifier;      {ID of group to be synchronized}
   END;
   myErr := SndDoImmediate(chan, mySndCmd);
   IF myErr &lt;&gt; noErr THEN
      DoError(myErr);
END;
</PRE>
 For example, to synchronize three channels, first create the channels and then call the <CODE>MySync1Chan</CODE> procedure defined in <A HREF=#MARKER-9-203>Listing 2-7</A> for the first channel with a count equal to 4, for the second channel with a count equal to 3, and for the third channel with a count equal to 2, using the same arbitrary identifier for each call to <CODE>MySync1Chan</CODE>. Then fill all channels with appropriate sound commands. (For example, you might send commands that will cause the same sequence of notes to be produced on all three synchronized channels.) Finally, call the <CODE>MySync1Chan</CODE> procedure one final time, passing any of the three channels and a count of 1. By that time, all of the other channels will have counts of 1, and all counts will become 0 simultaneously, thus initiating synchronized play.<A NAME=MARKER-2-204></A><P>
<DL>
<DT><B>Note</B>
<DD>The <CODE>syncCmd</CODE> command is intended to make it easy to synchronize sound channels. You can use the <CODE>syncCmd</CODE> command to start multiple channels of sampled sound playing simultaneously, but if you require precise synchronization of sampled-sound channels, you might achieve better results with the Time Manager, which is described in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I>.<EM></EM><A NAME=MARKER-2-205></A> <A NAME=MARKER-2-206></A><A NAME=MARKER-2-207></A><A NAME=MARKER-2-208></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Sound-50.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-52.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Sound-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
