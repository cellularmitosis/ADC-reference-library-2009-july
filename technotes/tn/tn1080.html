<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"            "http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1080: Adding Items to the Printing Manager's Dialogs</title><meta name="keywords" content="Mac OS 8 printing manager adding items dialog TPrDlg PrStlDialog"><meta name="Description" content="Technical Note TN1080: This Technical Note discusses howto add items to the Printing                                        Manager's dialogs. Included is the Printing ManagerCompatibility Guidelines and sample code that illustratesthe process of adding items to the Printing Manager dialogs."><meta name="categories" content="Printing"><meta name="week-posted" content="Jun 26, 2000 - Jul 7, 2000"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002921" title="Adding Items to the Printing Manager's Dialogs"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1080</div>
<div id="pageheadsub">Adding Items to the Printing Manager's Dialogs</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --> <table width="600" cellpadding="0" cellspacing="0" border="0">	<tr>		<td width=300 valign="top" align=left scope="row">			<table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left>						<span id="menutitle">							CONTENTS                             <br>                            <br>						</span>					</td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><P id = "menutext"><A HREF="#C1">Printing Manager Compatibility Guidelines for theFuture</A><BR><BR><A HREF="#C2">The Heart ofthe Print Dialogs: The TPrDlgRecord</A><BR><BR><A HREF="#C3">How theDialogs Work</A><BR><BR><A HREF="#C4">Adding YourOwn Items</A><BR><BR><A HREF="#C5">The C ExampleProgram</A><BR><BR><A HREF="#Summary">Summary</A><BR><BR><A HREF="#Changes">ChangeHistory</A><BR><BR>    <A HREF = "#References">References</a><BR><BR><A HREF="#Downloads">Downloadables</A></p>                  <!-- end_toc --> 								</td>				</tr>				<tr>					<td width=300 align=left scope="row">						<img src="images/tnmenubottom.gif" alt="" width=300 height=16>					</td>				</tr>			</table>		</td>		<td width=300 valign="top" align=left>			<!-- begin_intro_text -->                              <P id = "introtext">This Technote, originally                  <CITE>Technote PR 09 - Print Dialogs: Adding                  Items</CITE>, discusses how to add items to the                  Printing Manager's dialogs.</P>                                    <P id = "introtext">When the Printing Manager was initially                  designed, great care was taken to make the                  interface to the printer drivers as generic as                  possible in order to allow applications to print                  without being device specific. There are times,                  however, when this type of non-specific interface                  interferes with the flexibility of an application.                  An application may require additional information                  before printing which is not part of the general                  Printing Manager interface. This Note describes a                  method that an application can use to add its own                  items to the existing style and job dialogs.</P>                                    <P id = "introtext">This revised Technote reflects the current                  Macintosh Printing Manager and uses C code instead                  of the original Pascal.</P>                                    <P id = "introtext">You can download a complete version of the code                  in this Technote, <B>PDlogExpand</B>, by clicking                  on the icon in the <A HREF="#Downloads">Downloadables</A>                  section at the end of this Note.</P><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Jul 12 2000]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_header_box --><BR><BR><hr width=500 align=center>          <BR><BR><!-- begin_content -->         <A NAME=C1></A>                  <H2>Printing Manager Compatibility Guidelines for the         Future</H2>                  <P>To begin with, you need to be aware of some guidelines         that will increase your chances of being compatible with         future revisions of Macintosh Printing Manager: </P>                  <UL>            <LI>Only add items to the dialogs as described in this            Technical Note. Any other method will decrease your            chances of compatibility in the future.<BR><BR></li>                        <LI>Do not change the position of any item in the current            dialogs. This means don't delete items from the existing            item list or add items in the middle. Add items only at            the end of the list.<BR><BR></li>                        <LI>Don't count on an item retaining its current position            in the list. If you depend on the Draft button being a            particular number in the ImageWriter's style dialog item            list, and we change the Draft button's item number for            some reason, your program may no longer function            correctly.<BR><BR></li>                        <LI>Don't use more than half the screen height for your            items. Apple reserves the right to expand the items in            the standard print dialogs to fill the top half of the            screen. Even though LaserWriter 8.4 changes the print            dialogs, in order to be compatible with older drivers,            you still need to maintain this half-screen rule.<BR><BR></li>                        <LI>Under LaserWriter 8.4.x the print dialogs have been            completely redesigned. If you add items to the print            dialog "legally," your items are added to a pane that has            the name of your application. If you don't add them as            recommended in this Note, there will be problems. Please            see <CITE>develop 27 - Print Hints: The All-New            LaserWriter Driver Version 8.4</CITE> for more            details.<BR><BR></li>         </UL>                  <P>Applications should not assume that the print dialog's         foreground color is black or that the background color is         white when they erase their controls. Furthermore,         applications should not change the foreground or background         colors because other items in the dialog rely on these         colors. If an application changes them, the print dialog may         end up with strange colors.</p>                  <P><A HREF="#top">Back to top</A></P>                  <A NAME=C2></A>                  <H2>The Heart of the Print Dialogs: The TPrDlg Record</H2>                  <P>Before discussing how the dialogs work, it is important         to know that at the heart of the print dialogs is a         little-known data structure partially documented in         Printing.h. It's a record called <CODE>TPrDlg</CODE> and it         looks like this: </P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>struct TPrDlg {    DialogRecord    Dlg;            /*The Dialog window*/    ModalFilterUPP  pFltrProc;      /*The Filter Proc.*/    PItemUPP    pItemProc;      /*The Item evaluating proc.*/    THPrint     hPrintUsr;      /*The user's print record.*/    Boolean     fDoIt;    Boolean     fDone;    long            lUser1;     /* Four longs reserved by Apple */                        /* to hang global data.*/    long            lUser2;     /* More stuff needed by the */                        /* printing dialog.*/    long            lUser3;    long            lUser4;};typedef struct TPrDlg TPrDlg;typedef TPrDlg *TPPrDlg;typedef TPrDlg *TPPrDlgRef;                  </pre>	</TD></TR></TABLE></CENTER>                  <P>All of the information pertaining to a print dialog is         kept in the <CODE>TPrDlg</CODE> record. This record will be         referred to frequently in the discussion below.<BR>         </P>                  <P><A HREF="#top">Back to top</A></p>          <A NAME=C3></A>                  <H2>How the Dialogs Work</H2>                  <P>When your application calls <CODE>PrStlDialog</CODE> and         <CODE>PrJobDialog</CODE>, the printer driver calls a routine         called <CODE>PrDlgMain</CODE>. This function is declared as         follows: </P>                           <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>extern pascal Boolean PrDlgMain(THPrint hPrint, PDlgInitUPP pDlgInit);                  </pre>	</TD></TR></TABLE></CENTER>                  <P><CODE>PrDlgMain</CODE> first calls the         <CODE>pDlgInit</CODE> routine to set up the appropriate         dialog (in <CODE>Dlg</CODE>), dialog hook         (<CODE>pItemProc</CODE>) and dialog event filter         (<CODE>pFilterProc</CODE>) in the <CODE>TPrDlg</CODE> record         (shown above). For the job dialog, the address of         <CODE>PrJobInit</CODE> is passed to <CODE>PrDlgMain</CODE>.         For the style dialog, the address of <CODE>PrStlInit</CODE>         is passed. These routines are declared as follows: </P>         <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>extern pascal TPPrDlgRef PrJobInit(THPrint hPrint);extern pascal TPPrDlgRef PrStlInit(THPrint hPrint);</pre>	</TD></TR></TABLE></CENTER>                  <P>After the initialization routine sets up the         <CODE>TPrDlg</CODE> record, <CODE>PrDlgMain</CODE> calls         <CODE>ShowWindow</CODE> (the window is initially invisible),         then it calls <CODE>ModalDialog</CODE>, using the dialog         event filter pointed to by the <CODE>pFltrProc</CODE> field.         When an item is hit, the routine pointed to by the         <CODE>pItemProc</CODE> field is called and the items are         handled appropriately. When the OK button is hit (this         includes pressing Return or Enter) the print record is         validated. The print record is not validated if the Cancel         button is hit.</p>        <p> <A HREF="#top">Back to top</A></p>                  <P><A NAME=C4></A></P>                  <H2>Adding Your Own Items</H2>                  <P>To modify the print dialogs, you need to change the         <CODE>TPrDlg</CODE> record before the dialog is drawn on the         screen. You can add your own items to the item list, replace         the addresses of the standard dialog hook and event filter         with the addresses of your own routines, and then let the         dialog code handle the necessary functions to make the items         visible in your print dialog.</P>                  <P>The example code's initialization function adds items to         the dialog item list, saves the address of the standard         dialog hook (in our global variable         <CODE>prPItemProc</CODE>) and puts the address of our dialog         hook into the <CODE>pItemProc</CODE> field of the         <CODE>TPrDlg</CODE> record. Please note that your dialog         hook must call the standard dialog hook to handle all of the         standard dialog's items.</P>         <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>If you wish to have an event filter, use the same                  method that you would for a dialog hook.</P></TD></TR></TABLE></CENTER><BR>         <P><A HREF="#top">Back to top</A></P>         <A NAME=C5></A>                  <H2>The C Example Program</H2>                  <P>Here is an example (written in C) that modifies the job         dialog.</P>         <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The same code works for the style dialog if you                  globally replace "Job" with "Stl".</P></TD></TR></TABLE></CENTER><BR>                <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#include &lt;Printing.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Gestalt.h&gt;#include &lt;MixedMode.h&gt;#include &lt;SegLoad.h&gt;#include &lt;Resources.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;Fonts.h&gt;#include &lt;Lists.h&gt;static TPPrDlg PrtJobDialog;    /* pointer to job dialog *//*This points to the following structure:struct TPrDlg {    DialogRecord Dlg; // The Dialog window    ModalFilterUPP pFltrProc; // The Filter Proc.    PItemUPP pItemProc; // The Item evaluating proc.    THPrint hPrintUsr; // The user's print record.    Boolean fDoIt;    Boolean fDone;    long lUser1; // Four longs for apps to hang global data.    long lUser2; // Plus more stuff needed by the particular    long lUser3; // printing dialog.    long lUser4;};typedef struct TPrDlg TPrDlg;typedef TPrDlg *TPPrDlg;typedef TPPrDlg TPPrDlgRef;*//* Declare 'pascal' functions and procedures */extern short Append_DITL(TPPrDlg, short);    /* Our AppendDITL function. */extern pascal TPPrDlg MyJobDlgInit(THPrint);    /* Our extension to PrJobInit.  */extern pascal void MyJobItems(TPPrDlg, short);    /* Our modal item handler.  */extern OSErr Print(void);pascal void MyListDraw(WindowPtr theWindow, short itemNo);    //mxm#define MyDITL 256  /* resource ID of my DITL to be                    spliced onto job dialog */#define kPanePopUp (6)              /* mxm */ListHandle gList = nil;             /* mxm */UserItemUPP myDrawListUPP = nil;    /* mxm */THPrint hPrintRec;  /* handle to print record */long prFirstItem;   /* save our first item here */PItemUPP prPItemProc;   /* we need to store the                        old itemProc here */WindowPtr MyWindow;OSErr err;Str255 myStr;#if PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endiftypedef struct dialog_item_struct {    Handle handle;   /* handle or procedure pointer                     for this item */    Rect bounds;     /* display rectangle for this item */    char type;       /* item type - 1 */    char data[1];    /* length byte of data */} DialogItem, *DialogItemPtr, **DialogItemHandle;typedef struct append_item_list_struct {    short max_index; /* number of items - 1 */    DialogItem items[1]; /* first item in the array */} ItemList, *ItemListPtr, **ItemListHandle;typedef union signed_byte_union {    short integer;    char bytes[2];} ByteAccess;static Boolean append_exits(void);static Boolean append_exits(void) {    long response;    if (Gestalt(gestaltDITLExtAttr,&amp;response) == noErr) {        return !!(response &amp; (1 &lt;&lt; gestaltDITLExtPresent));    } else {        return false;    }}    /* This routine appends all of the items of a specified DITL    onto the end of a specified DLOG -- We don't even need    to know the format of the DLOG    this will be done in 3 steps:     1. append the items of the specified DITL onto the        existing DLOG     2. expand the original dialog window as required     3. return the adjusted number of the first new user item */short Append_DITL(TPPrDlg dialog, short item_list_ID) {        /* handle to DITL being appended */    ItemListHandle append_item_list;    ItemListHandle dlg_item_list; /* handle to DLOG's item list */    short first_item;    dlg_item_list = (ItemListHandle)((DialogPeek)dialog)-&gt;items;    first_item = (**dlg_item_list).max_index + 2;    append_item_list =        (ItemListHandle)GetResource('DITL', item_list_ID);    if ( append_item_list == NULL ) {        DebugStr("\pError loading DITL resource");        return first_item;    }    if (append_exits()) {        AppendDITL((DialogPtr)dialog,        (Handle) append_item_list,        appendDITLBottom);            /* Make sure to release the DITL resource            before returning */        ReleaseResource( (Handle)append_item_list );        return first_item;    } else {        Point       offset;        Rect        max_rect;        DialogItemPtr   item;   /* pointer to item being appended */        short       new_items, data_size, i;        ByteAccess  usb;        OSErr       err;            /* Using the original DLOG            1. Remember the original window Size.            2. Set the offset Point to be the bottom of the original               window.            3. Subtract 5 pixels from bottom and right, to be added               back later after we have possibly expanded window.            4. Get working Handle to original item list.            5. Calculate our first item number to be returned to               caller.            6. Get locked Handle to DITL to be appended.            7. Calculate count of new items.            */        if (dialog == NULL) ExitToShell();        max_rect = ((DialogPeek)dialog)-&gt;window.port.portRect;        offset.v = max_rect.bottom;        offset.h = 0;        max_rect.bottom -= 5;        max_rect.right -= 5;        HLock((Handle)append_item_list);        new_items = (**append_item_list).max_index + 1;            /* For each item,            1. Offset the rectangle to follow the original window.            2. Make the original window larger if necessary.            3. fill in item handle according to type. */        item = (**append_item_list).items;        for ( i = 0; i &lt; new_items; i++ ) {            OffsetRect(&amp;item-&gt;bounds, offset.h, offset.v);            UnionRect(&amp;item-&gt;bounds, &amp;max_rect,                &amp;max_rect);            usb.integer = 0;            usb.bytes[1] = item-&gt;data[0];            switch ( item-&gt;type &amp; 0x7F ) {                case ctrlItem + btnCtrl :                case ctrlItem + chkCtrl :                case ctrlItem + radCtrl :                    item-&gt;handle =                        (Handle)NewControl((DialogPtr) dialog,                        &amp;item-&gt;bounds,                        (StringPtr)item-&gt;data,                        true, 0, 0, 1, item-&gt;type &amp;                        0x03, 0);                    break;                case ctrlItem + resCtrl :                    item-&gt;handle =                        (Handle)GetNewControl(                            *(short*)(item-&gt;data + 1),                            (DialogPtr) dialog);                    (**(ControlHandle)item-&gt;handle).contrlRect =                        item-&gt;bounds;                    break;                case statText :                case editText :                    err = PtrToHand(item-&gt;data + 1,                        &amp;item-&gt;handle, usb.integer);                        break;                case iconItem :                    item-&gt;handle =                    GetIcon(*(short*)(item-&gt;data + 1));                    break;                case picItem :                    item-&gt;handle =                        (Handle)GetPicture(*(short*)(item-&gt;data + 1));                    break;                default :                    item-&gt;handle = NULL;            }            data_size = (usb.integer + 1) &amp; 0xFFFE;            item = (DialogItemPtr)                ((char*)item + data_size + sizeof(DialogItem));        }            /* We need to subtract the short below because otherwise the            size of the DITL count gets factored in twice, and the            resulting DTIL has two bytes of garbage appended to it.            This is a problem with the original TN#95 code as well. */        err = PtrAndHand((**append_item_list).items,            (Handle)dlg_item_list,            GetHandleSize((Handle) append_item_list)            - sizeof(short));        (**dlg_item_list).max_index += new_items;        HUnlock((Handle) append_item_list);        ReleaseResource((Handle) append_item_list);        max_rect.bottom += 5;        max_rect.right += 5;        SizeWindow((WindowPtr) dialog, max_rect.right,            max_rect.bottom, true);        return first_item;    }}OSErr Print(void) {    TPPrPort    pPrPort;    Rect        aRect;    TPrStatus   theStatus;    Boolean     printingShouldNotProceed;    PDlgInitUPP theInitProcPtr;        /*  Allocate a print record */    hPrintRec = (THPrint)(NewHandle(sizeof(TPrint)));    if ( NULL == hPrintRec )    {        return iMemFullErr;    }        /*  Fill in the default values  */    PrintDefault(hPrintRec);        /*  Make sure the print record is valid and consistent  */    PrValidate(hPrintRec);    if (PrError() != noErr)    {        DisposeHandle( (Handle)hPrintRec );        return PrError();    }        /* call PrJobInit to get pointer to the invisible        job dialog */    PrtJobDialog = PrJobInit(hPrintRec);    if (PrError() != noErr)    {        DisposeHandle( (Handle)hPrintRec );        return PrError();    }        /*  Create a UPP for the dialog init proc   */    theInitProcPtr = NewPDlgInitProc(MyJobDlgInit);    if ( NULL == theInitProcPtr )    {        DisposeHandle( (Handle)hPrintRec );        return iMemFullErr;    }        /* this line does all the stuff */    printingShouldNotProceed =        !PrDlgMain(hPrintRec, theInitProcPtr);        /* Get rid of our user item draw proc mxm.  Allocated        within MyJobDlgInit() that was called by PrDlgMain() */    if (myDrawListUPP)    {        DisposeRoutineDescriptor(myDrawListUPP);    }        /*  Make sure to free the InitProc UPP  */    DisposeRoutineDescriptor(theInitProcPtr);    if (printingShouldNotProceed)    {        DisposeHandle( (Handle)hPrintRec );        return iPrAbort;    }    if (PrError() != noErr)    {        DisposeHandle( (Handle)hPrintRec );        return PrError();    }        /* Open the printing document and page to prepare        for drawing into the printing context */    pPrPort = PrOpenDoc(hPrintRec, NULL, NULL);    PrOpenPage(pPrPort, NULL);        /* Draw something on the page  */    aRect = (*hPrintRec)-&gt;prInfo.rPage;    InsetRect(&amp;aRect, 20, 20);    PenSize(4, 4);    FrameRect(&amp;aRect);        /*  We're done drawing so close up the page and        document    */    PrClosePage(pPrPort);    PrCloseDoc(pPrPort);        /*  Do we need to spool the job?    */    if (!PrError()    &amp;&amp; (*hPrintRec)-&gt;prJob.bJDocLoop == bSpoolLoop)        PrPicFile(hPrintRec, NULL, NULL, NULL, &amp;theStatus);        /*  Don't forget to release the print record memory */    DisposeHandle((Handle) hPrintRec);    return(noErr);} /* Print */pascal void MyListDraw(WindowPtr theWindow, short itemNo) {    #pragma unused (theWindow,itemNo)    short   itemType;    Handle  itemH;    Rect    itemBox,r;    Point   pt;    ControlRef cr;    RgnHandle clip = NewRgn();    if (itemNo == kPanePopUp) {        cr = gList[0]-&gt;vScroll;        HideControl(cr);        return;    }    GetDialogItem((DialogPtr) PrtJobDialog,        itemNo,&amp;itemType,&amp;itemH,&amp;itemBox);    r = theWindow-&gt;portRect;    pt.h = itemBox.left;    pt.v = itemBox.top;    cr = gList[0]-&gt;vScroll;    MoveControl(cr,itemBox.right-15,itemBox.top-1);    ShowControl(cr);    if (PtInRect(pt,&amp;r)) {        gList[0]-&gt;rView = itemBox;        gList[0]-&gt;rView.right -=15; /* inset for scroll bar */        ShowControl(cr);        LSetDrawingMode(true,gList);        if (clip) {            RectRgn(clip,&amp;itemBox);            LUpdate(clip,gList);            InsetRect(&amp;itemBox,-1,-1);            FrameRect(&amp;itemBox);        }    }    /*  Free up the region memory   */    DisposeRgn(clip);}    /* this routine appends items to the standard job    dialog and sets up the user fields of the    printing dialog record TPRDlg This routine    will be called by PrDlgMain */pascal TPPrDlg MyJobDlgInit(THPrint hPrint) {    #pragma unused(hPrint)    short   firstItem;  /* first new item number */    short   itemType, item;    Handle  itemH;    Rect    itemBox;        /* call routine to do this */    firstItem = Append_DITL(PrtJobDialog, MyDITL);        /* save this so MyJobItems can find it */    prFirstItem = firstItem;        /* now we'll set up our DITL items -        - The radio buttons */    for (item = 5; item &lt;= 7; item++)    {        GetDialogItem((DialogPtr) PrtJobDialog,            firstItem + item -1,&amp;itemType,            &amp;itemH,&amp;itemBox);        SetControlValue((ControlHandle) itemH, (item == 5));    }        /* now we'll set up the second of our DITL        items -- The checkbox */    GetDialogItem((DialogPtr) PrtJobDialog,        firstItem +2,&amp;itemType,&amp;itemH,&amp;itemBox);    SetControlValue((ControlHandle) itemH,1);    // here is the list stuff (mxm)    {        Rect bounds ;        Point theCell = {16,200};        GetDialogItem((DialogPtr) PrtJobDialog,            firstItem +8,&amp;itemType,&amp;itemH,&amp;itemBox);        SetRect(&amp;bounds,0,0,1,0);        itemBox.right -=15;        gList = LNew(&amp;itemBox,&amp;bounds,            theCell,0,(GrafPtr)PrtJobDialog,            false,false,false,true);        if (gList) {                /* this is how you need to do the scroll-bar so it'll                move off correctly with LaserWriter 8.4 and later                The theory is that we have another user item which                has the handle for the control item for the scrollbar                for the list. This way, the scroll bar gets redrawn                in the right order, so it realises it's off the panel                when it is. If you don't have this code, the scroller                gets drawn, then the list gets moved, so you get a                phantom scroller in the dialog. -DaveP 9/3/96 */            short scrollType;            Handle scrollHandle;            Rect scrollRect;            GetDialogItem((DialogPtr)PrtJobDialog,                firstItem + 9, &amp;scrollType,                &amp;scrollHandle, &amp;scrollRect);            SetDialogItem((DialogPtr)PrtJobDialog,                firstItem + 9, ctrlItem,                (Handle) (**gList).vScroll, &amp;scrollRect);        }        LAddRow(9,0,gList);        SetPt(&amp;theCell,0,0);            /* Lets add some data */        LSetCell("Testing 1",9,theCell,gList);        theCell.v ++;        LSetCell("Testing 2",9,theCell,gList);        theCell.v ++;        LSetCell("Testing 3",9,theCell,gList);        theCell.v ++;        LSetCell("Testing 4",9,theCell,gList);        theCell.v ++;        LSetCell("Testing 5",9,theCell,gList);        theCell.v ++;        LSetCell("Testing 6",9,theCell,gList);        theCell.v ++;        LSetCell("Testing 7",9,theCell,gList);        theCell.v ++;        LSetCell("Testing 8",9,theCell,gList);        theCell.v ++;        LSetCell("Testing 9",9,theCell,gList);        LActivate(true,gList);        myDrawListUPP =  NewUserItemProc(MyListDraw);        SetDialogItem((DialogPtr) PrtJobDialog,            firstItem + 8,itemType,            (Handle)myDrawListUPP,&amp;itemBox);    }        /* Now comes the part where we patch in our item handler.        We have to save the old item handler address, so we can        call it if one of the standard items is hit, and put our        item handler's address in pItemProc field of the        TPrDlg struct */    prPItemProc = PrtJobDialog-&gt;pItemProc;        /* Now we'll tell the modal item handler where our        routine is */    PrtJobDialog-&gt;pItemProc = NewPItemProc(MyJobItems);        /* PrDlgMain expects a pointer to the modified        dialog to be returned...*/    return PrtJobDialog;} /*myJobDlgInit*/ static pascal Boolean testFilter(DialogPtr theDialog    EventRecord *theEvent, short *itemHit){    #pragma unused(theDialog)    #pragma unused(theEvent)    #pragma unused(itemHit)        /* This gets called a lot if you uncomment it */    //  DebugStr("\pMy filter proc got called");    return false;}static pascal void testDialogUserItem(WindowPtr theWindow,        short itemNo);static pascal void testDialogUserItem(WindowPtr theWindow,        short itemNo) {    if (itemNo != 4)        return;    else {        short oldFont = ((GrafPtr)theWindow)-&gt;txFont;        short oldSize = ((GrafPtr)theWindow)-&gt;txSize;        short itemType;        Handle h;        Rect r;        SetPort(theWindow);        TextFont(GetAppFont());        TextSize(9);        GetDialogItem((DialogPtr)theWindow,            4,&amp;itemType,&amp;h,&amp;r);        MoveTo(r.left,r.bottom);        DrawString("\pThe Pooh-snif network.");        TextFont(oldFont);        TextSize(oldSize);    }}static void TestDialog(void);static void TestDialog(void){    DialogPtr theDialog = GetNewDialog(257,nil,(WindowPtr)-1L);    short itemHit = 0;            /* use NewModalFilterProc(testFilter); for testing */    ModalFilterUPP mySubDialogFilterProc = nil;    UserItemUPP mySubDialogUserProc =        NewUserItemProc(testDialogUserItem);    {       /* set up the user item to draw the outline            around the ok button */        short t;        Handle h;        Rect r;        GetDialogItem(theDialog,            4,&amp;t,&amp;h,&amp;r);        SetDialogItem(theDialog,            4,t,(Handle)mySubDialogUserProc,&amp;r);    }    SetDialogDefaultItem(theDialog,1);    while((itemHit != 1) &amp;&amp; (itemHit != 2)) {            /* a WAY bad way of seeing if we're            done, but I'm in a hurry */        ModalDialog(mySubDialogFilterProc, &amp;itemHit);    }    DisposeDialog(theDialog);    if (mySubDialogFilterProc != nil)        DisposeRoutineDescriptor(mySubDialogFilterProc);    if (mySubDialogUserProc != nil)        DisposeRoutineDescriptor(mySubDialogUserProc);}/* here's the analogue to the SF dialog hook */pascal void MyJobItems( TPPrDlg theDialog, short itemNo ){    short   myItem;    short   firstItem, item, itemType, theValue;    Handle  itemH;    Rect    itemBox;        /* remember, we saved this in myJobDlgInit */    firstItem = prFirstItem;    //  DebugStr("\p Looking at the item...");        /* "localize" current item No */    myItem = itemNo-firstItem+1;        /* if localized item &gt; 0, it's one of ours */    if (myItem &gt; 0) {            /* find out which of our items was hit */         switch (myItem)        {            case 1:        /*    Static text.   */                break;            case 2:        /*  Edit text.       */                break;            case 3:        /*  Check box.       */                GetDialogItem((DialogPtr) theDialog,                    firstItem +2,&amp;itemType,                    &amp;itemH,&amp;itemBox);                theValue = GetControlValue((ControlHandle) itemH);                SetControlValue((ControlHandle) itemH,                    theValue != 1);                break;            case 4:      /* Push button.    */                TestDialog();                break;            case 5:        /*   Radio buttons   */            case 6:            case 7:                for (item = 5; item &lt;= 7; item++) {                    GetDialogItem((DialogPtr) theDialog,                        firstItem +item -1,&amp;itemType,                        &amp;itemH,&amp;itemBox);                    SetControlValue((ControlHandle) itemH,                        item == myItem);                }                break;            case 8:         /*  Edit text.      */            case 9:         /*  Our List.       */                {   Point pt;                    GetMouse(&amp;pt);                    LClick(pt,0,gList);                }                break;            case 10:                    /* our list's scroll bar. We don't need                    to do anything, but we need to have some                    code here so we don't hit the default case */                break;            default:                Debugger(); /* OH OH */        }    } else {            /* chain to standard item handler, whose address            is saved in prPItemProc */        CallPItemProc(prPItemProc,(DialogPtr)theDialog, itemNo);        if (theDialog-&gt;fDone) {            /* we're going away, need to clean up our            scroll bar and list */            if (gList) {                (**gList).vScroll = 0L;                LDispose(gList);            }        }    }} /* MyJobItems */void main(void){    Rect    myWRect;    InitGraf(&amp;qd.thePort);    InitFonts();    InitWindows();    InitMenus();    InitDialogs((long)nil);    InitCursor();    SetRect(&amp;myWRect,50,260,350,340);    /* call the routine that does printing */    PrOpen();    err = Print();    PrClose();} /* main */</pre>	</TD></TR></TABLE></CENTER>                           <P><A HREF="#top">Back to top</A></P>                  <A NAME=Summary></A><H2>Summary</H2><P>That's all there is to it. Now you can add items to theprint dialogs.</P>         <P><A HREF="#top">Back to top</A></P>         <a name="References"></a><H2>References</H2>                                     <p><a href="http://developer.apple.com/documentation/mac/QuickDraw/QuickDraw-406.html">Inside                     Macintosh: Imaging With QuickDraw (Chapter                     9)</A></p>                                          <p><a href="http://developer.apple.com/documentation/mac/Toolbox/Toolbox-370.html">Inside                     Macintosh: Macintosh Toolbox Essentials (Chapter                     6)</A></p>                                          <p>PDlog Expand sample code, included with this                     Technote.</p>                                          <p>StdFileSaver sample code, available on the                     <CITE>Developer CD Series: Tool Chest                     Edition.</CITE></p>                                          <p><B><CITE>develop 27</CITE></B><CITE> - Print                     Hints: The All-New LaserWriter Driver Version                     8.4</CITE> by Dave Polaschek.</p>                  <P><A HREF="#top">Back to top</A></P>                  <H2><A NAME=Changes></A>Change History</H2>                                    <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-November-1996</P>               </TD>               <td align="left">                  <P>Originally written as <I>Technote            PR 09 - Print Dialogs: Adding Items.</I></P>               </TD>            </TR>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-February-2000</P>               </TD>               <td align="left">                  <P>Accompanying code revised.</P>               </TD>            </TR>            <TR>               <td width=100 align=left>                  <P ALIGN=center>12-July-2000</P>               </TD>               <td align="left">                  <P>Accompanying code revised from original Pascal.</P>               </TD>            </TR>         </table><BR>                               <P><A HREF="#top">Back to top</A></P>         <a name="Downloads"></a> <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="500">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (72K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1080.pdf">Download</A></P>               </TD>            </TR>             <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/redbook.gif" width=20 height=20 align=bottom alt="Redbook gif"></P>               </TD>               <td align="left">                  <P>Printing Sample Code</P>               </TD>               <td width=60 align=left>                  <P><a href="http://developer.apple.com/samplecode/Sample_Code/Printing.htm">Download</A></P>               </TD>            </TR>            </table>            <BR><P><A HREF="#top">Back to top</A></P></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1080.html%3Fid%3DDTS10002921-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1080.html%3Fid%3DDTS10002921-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1080.html%3Fid%3DDTS10002921-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>