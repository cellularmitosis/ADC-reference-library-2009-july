<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>HBA Device Driver Programming Guide: Developing an HBA Driver</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Developing an HBA Driver"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40003194-CH4" title="Developing an HBA Driver"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../SCSI-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30000567" target="_top">SCSI</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40003194-CH1-SW1">HBA Device Driver Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../HBAOverview/HBAOverview.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../HBATipsAndTricks/HBATipsAndTricks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40003194-CH4-SW6" title="Developing an HBA Driver"></a><h1>Developing an HBA Driver</h1><p>This chapter describes how to develop a custom HBA driver.</p><p>If you've never developed in-kernel device driver for Mac OS X, be sure to read the  documents listed in <span class="content_text"><a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40003194-CH1-SW1">“Introduction to HBA Device Driver Programming Guide”</a></span> to learn about the I/O Kit and how to use Xcode to create a device driver.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_1">Create a Matching Dictionary for Your Driver</a>
				
			<br/>
			
        
			
			
				<a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_2">Implement an IOSCSIParallelInterfaceController Subclass</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_1" title="Create a Matching Dictionary for Your Driver"></a><h2>Create a Matching Dictionary for Your Driver</h2><p>To ensure that your driver matches and loads for your device, you need to edit your driver's information property list (<code>Info.plist</code> file). The I/O Kit uses the information in this file to match a device with the driver best suited to drive it. Because HBA hardware is represented by one or more <code>IOPCIDevice</code> nubs, a custom HBA driver must include the following key-value pair in its <code>Info.plist</code> file:</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;string>IOPCIDevice&lt;/string><span></span></pre></td></tr></table></div><p>If you're developing an HBA driver to run in a PowerPC-based Macintosh computer, you can use Open Firmware matching to match on some combination of the Open Firmware device properties <code>name</code>, <code>compatible</code>, <code>device_type</code>, or <code>model</code>. To do this, use the <code>IONameMatch</code> key and supply the appropriate property or properties in a string (or array of strings) as the value, as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;key>IONameMatch&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;string>pci1000,626&lt;/string><span></span></pre></td></tr></table></div><p>If you're developing an HBA driver to run in an Intel-based Macintosh computer, use standard PCI matching (Open Firmware matching is not available in Intel-based Macintosh computers). PCI matching is based on the values in the PCI configuration space registers listed below (note that some registers, such as revision ID and header type, are not available for matching): </p><ul class="ul"><li class="li"><p>Vendor and device ID (offsets $00 and $02)</p></li><li class="li"><p>Subsystem vendor and device ID (offsets $2C and $2E)</p></li><li class="li"><p>Class code (offset $09)</p></li></ul><p>The PCI family defines four matching keys that you can use to specify combinations of values on which to match. The table below shows these keys and their associated behavior.</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Key</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Matching behavior</p></th></tr><tr><td  scope="row"><p><code>IOPCIMatch</code></p></td><td ><p>Matches against the primary vendor and device ID registers or the subsystem vendor and device ID registers. The values of the primary registers are checked first; if there is no match, then the values of the subsystem registers are checked.</p></td></tr><tr><td  scope="row"><p><code>IOPCIPrimaryMatch</code></p></td><td ><p>Matches against only the primary vendor and device ID registers.</p></td></tr><tr><td  scope="row"><p><code>IOPCISecondaryMatch</code></p></td><td ><p>Matches against only the subsystem vendor and device ID registers.</p></td></tr><tr><td  scope="row"><p><code>IOPCIClassMatch</code></p></td><td ><p>Matches against the class code register.</p></td></tr></table></div><p>For several examples of PCI matching, see the "PCI Matching" section in <span class="content_text"><a href="../../../../DeviceDrivers/Conceptual/WritingPCIDrivers/pci_device/pci_device.html#//apple_ref/doc/uid/TP30000347" target="_top">Writing a Driver for a PCI Device</a></span>. For information on other matching keys, such as <code>kIOPropertyPhysicalInterconnectLocationKey</code>, see the documentation for <code>IOStorageProtocolCharacteristics.h</code> in <em><a href="../../../../Darwin/Reference/KernelIOKitFramework/index.html#//apple_ref/doc/uid/TP30000816" target="_top">Kernel Framework Reference</a></em>.</p><p>After your driver is matched to your device and started, you have the opportunity to add to the property list other properties that contain information about the HBA device itself or about its target devices. These properties (like all properties in the <code>Info.plist</code> file) are stored in the I/O Registry during the driver's lifetime. This allows other I/O Kit entities to get information about the capabilities of your device. The <code>IOSCSIParallelInterfaceController</code> class provides methods your driver can call to add or remove properties (these methods are described in <span class="content_text"><a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-SW7">“Set and Remove HBA and Target Device Properties (Optional)”</a></span>). It's important to use only these methods to add or remove properties because they protect you from the synchronization issues that can arise when different entities attempt to make changes in the I/O Registry at the same time.</p><a name="//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_2" title="Implement an IOSCSIParallelInterfaceController Subclass"></a><h2>Implement an IOSCSIParallelInterfaceController Subclass</h2><p>The SCSI Parallel family's <code>IOSCSIParallelInterfaceController</code> class contains all the methods you need to develop a custom HBA driver. It's important to emphasize that the SCSI Parallel family handles a great many lower-level details for you, such as the creation of a work loop and various event sources, basic interrupt handling, and, if necessary, the creation and destruction of target device objects. </p><p>For the most part, your job consists of subclassing the <code>IOSCSIParallelInterfaceController</code> class and implementing its pure virtual methods to process I/O and report information specific to your hardware. The <code>IOSCSIParallelInterfaceController</code> class also contains methods you can implement to perform tasks, such as managing target devices and handling interrupts, and methods you can call to get information and set various properties. The following sections describe the required and optional tasks HBA drivers perform and the <code>IOSCSIParallelInterfaceController</code> methods associated with them.</p><p>After you've succeeded in developing a driver that communicates with your device, be sure to read <span class="content_text"><a href="../HBATipsAndTricks/HBATipsAndTricks.html#//apple_ref/doc/uid/TP40003194-CH5-SW1">“Improving Performance”</a></span> to learn about ways to improve your driver's performance in Mac OS X.</p><a name="//apple_ref/doc/uid/TP40003194-CH4-SW4" title="Initialize Your HBA Device Driver (Required)"></a><h3>Initialize Your HBA Device Driver (Required)</h3><p>Custom HBA drivers do not implement the I/O Kit <code>init</code> method. Instead, the <code>IOSCSIParallelInterfaceController</code> object does some initial setup work (such as getting a work loop and updating I/O Registry properties) and then it calls the <code>InitializeController</code> method on your subclass. In your implementation of this method, you should perform any required hardware initialization, resource allocation, and hardware interrogation.</p><p>As you design the implementation of the <code>InitializeController</code> method, be aware that you do not need to allocate memory in your subclass to hold per-command or per-target information. For example, some HBA devices keep track of the mapping between the worldwide node name and the target device or information about negotiation speeds. Instead of allocating memory to hold such information in your <code>InitializeController</code> method, you should use the report methods to tell the <code>IOSCSIParallelInterfaceController</code> superclass how much space you need. Then, when the <code>IOSCSIParallelInterfaceController</code> object creates target-device and task objects, it will also allocate enough memory to hold the information you need to keep. (For more information on the report methods, see <span class="content_text"><a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-SW5">“Report Device-Specific Information (Required).”</a></span>)</p><p>If there is information you need to store that is specific to the HBA device itself, however, you can allocate memory for it in the <code>InitializeController</code> method. Your driver might also need to allocate a small amount of memory to use for non-task communication with target devices. For example, some HBA drivers send to target devices auxiliary requests or negotiation requests that can't be encapsulated in I/O request objects.</p><p>In your implementation of the <code>InitializeController</code> method you should also query the hardware to get information you need, such as the highest supported device ID and the initiator ID. Your driver might need other data as well, but it will be required to report the initiator ID and the highest supported device ID and logical unit number (LUN) to its superclass (see <span class="content_text"><a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-SW5">“Report Device-Specific Information (Required)”</a></span> for the methods you use to supply this data). </p><a name="//apple_ref/doc/uid/TP40003194-CH4-SW5" title="Report Device-Specific Information (Required)"></a><h3>Report Device-Specific Information (Required)</h3><p>After you've initialized your HBA device, the <code>IOSCSIParallelInterfaceController</code> object requests some information from your driver. To provide this information, your driver must implement the following methods:</p><ul class="spaceabove"><li class="li"><p><code>ReportInitiatorIdentifier</code></p><p>The <code>IOSCSIParallelInterfaceController</code> object calls this method to get the SCSI identifier of the initiator (your HBA device). The initiator ID is considered reserved and no target devices can be created with that ID. </p></li><li class="li"><p><code>ReportHighestSupportedDeviceID</code></p><p>In this method, your HBA driver must return the highest device ID it supports. The <code>IOSCSIParallelInterfaceController</code> object uses the value you return to determine the last ID to process when, for example, it scans for target devices.</p></li><li class="li"><p><code>ReportMaximumTaskCount</code></p><p>In this method, return the maximum number of outstanding tasks your HBA device can process. The <code>IOSCSIParallelInterfaceController</code> object uses this value both to allocate the appropriate number of task objects and to avoid sending a new task when your driver is already processing the maximum number of tasks.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_13" title="Important:"></a><p><strong>Important:</strong>&nbsp;You must report a number greater than 0 in this method or your driver will not match and load. However, the number you report should balance your driver's performance with overall system performance. For some advice on how to arrive at a reasonable value for this quantity, see <span class="content_text"><a href="../HBATipsAndTricks/HBATipsAndTricks.html#//apple_ref/doc/uid/TP40003194-CH5-SW4">“Report Appropriate Maximum Task Count.”</a></span></p><p></p></div></li><li class="li"><p><code>ReportHBASpecificTaskDataSize</code></p><p>If your HBA driver needs to keep track of some data for each task it processes, it can tell its superclass to allocate space for that data in each task object. This relieves your driver of the responsibility of creating and maintaining the memory to hold per-task data, such as a scatter-gather list. </p></li><li class="li"><p><code>ReportHBASpecificDeviceDataSize</code></p><p>If your HBA driver needs to keep track of some data for each target device attached to it, it can tell its superclass to allocate space for that data in each <code>IOSCSIParallelInterfaceDevice</code> object. Your driver might want to store data such as negotiation speeds, the worldwide port name, or a destination ID.</p></li><li class="li"><p><code>DoesHBAPerformDeviceManagement</code></p><p>Many HBAs, typically Fibre Channel and SAS HBAs, are capable of discovering and managing the devices attached to them. Other HBAs, such as generic parallel SCSI HBAs, know how many devices they can support, but do not manage those devices in any way. All HBA drivers must implement the <code>DoesHBAPerformDeviceManagement</code> method to state whether they intend to manage the target devices attached to them.</p><p>If your HBA driver returns <code>true</code> in this method, it means that target device objects will be created (and destroyed) only by your HBA driver, not by the superclass. Your HBA driver must then call the <code>IOSCSIParallelInterfaceController</code> methods that create and destroy target device objects (described in <span class="content_text"><a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-SW2">“Create, Initialize, and Destroy Target Device Objects (Optional)”</a></span>).</p><p>If your HBA does <em>not</em> perform device management, you should return <code>false</code> in the <code>DoesHBAPerformDeviceManagement</code> method, and you do not have to call the methods described in <span class="content_text"><a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-SW2">“Create, Initialize, and Destroy Target Device Objects (Optional).”</a></span> For these HBAs, the <code>IOSCSIParallelInterfaceController</code> takes responsibility for discovering and probing attached devices at boot time. The superclass creates the target device objects and attaches them to the custom HBA driver object in the I/O Registry.</p></li><li class="li"><p><code>ReportHBAHighestLogicalUnitNumber</code></p><p>In this method, your driver should return the highest logical unit number your HBA device can address.</p></li><li class="li"><p><code>DoesHBASupportSCSIParallelFeature</code></p><p>The superclass calls this method to find out if your HBA device supports a specific SCSI Parallel Interface feature (as defined in the SPI-3 and SPI-4 specifications). Your implementation of this method should examine the specified feature and return <code>true</code> if you support it or <code>false</code> if you don't.</p></li></ul><a name="//apple_ref/doc/uid/TP40003194-CH4-SW2" title="Create, Initialize, and Destroy Target Device Objects (Optional)"></a><h3>Create, Initialize, and Destroy Target Device Objects (Optional)</h3><p>A driver for an HBA device that manages the target devices attached to it must create and destroy the I/O Kit objects that represent them in the mass storage driver stack. (If your driver manages target devices, be sure to return <code>true</code> in your implementation of the required <code>DoesHBAPerformDeviceManagement</code> method, described in <span class="content_text"><a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-SW5">“Report Device-Specific Information (Required).”</a></span>) If your driver does not manage target devices, you can skip the rest of this section and go on to the next section, <span class="content_text"><a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-SW7">“Set and Remove HBA and Target Device Properties (Optional).”</a></span></p><p>To create target device objects, your driver must call one of the variants of the <code>CreateTargetForID</code> method. You cannot override the <code>CreateTargetForID</code> methods because the <code>IOSCSIParallelInterfaceController</code> object uses them to perform many low-level tasks, such as updating internal states and structures.</p><p>The <code>IOSCSIParallelInterfaceController</code> class allows a custom HBA driver to create a target device object by passing either the device ID of the target device and a dictionary of its properties or just the device ID. In general, Fibre Channel HBA devices need to supply a dictionary of properties that describe the target device, but most other HBA devices do not. <span class="content_text"><a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-SW3">Table 2-1</a></span> lists the property keys and values that Fibre Channel HBA devices can provide in the <code>CreateTargetForID</code> method. For more information about these and other keys used to describe the characteristics of physical interconnect protocols, see the documentation for <code>IOStorageProtocolCharacteristics.h</code> in <em><a href="../../../../Darwin/Reference/KernelIOKitFramework/index.html#//apple_ref/doc/uid/TP30000816" target="_top">Kernel Framework Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP40003194-CH4-SW3" title="Table 2-1Property keys and values for Fibre Channel device objects"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>Property keys and values for Fibre Channel device objects</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Property key</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Required</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Value</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th></tr><tr><td  scope="row"><p><code>kIOPropertyFibreChannelNodeWorldWideNameKey</code></p></td><td ><p>Yes</p></td><td ><p>Unique 64-bit worldwide name for the device node</p></td><td ><p><code>OSData</code></p></td></tr><tr><td  scope="row"><p><code>kIOPropertyFibreChannelPortWorldWideNameKey</code></p></td><td ><p>No</p></td><td ><p>Unique 64-bit worldwide name for the port</p></td><td ><p><code>OSData</code></p></td></tr><tr><td  scope="row"><p><code>kIOPropertyFibreChannelAddressIdentifierKey</code></p></td><td ><p>No</p></td><td ><p>The 24-bit address identifier as defined in the Fibre Channel FS (FC-FS) specification</p></td><td ><p><code>OSData</code></p></td></tr><tr><td  scope="row"><p><code>kIOPropertyFibreChannelALPAKey</code></p></td><td ><p>No</p></td><td ><p>The 8-bit Arbitrated Loop Physical Address value</p></td><td ><p><code>OSData</code></p></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_14" title="Note"></a><p><strong>Note:</strong>&nbsp;You can also use the <code>SetTargetProperty</code> method (described in <span class="content_text"><a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-SW7">“Set and Remove HBA and Target Device Properties (Optional)”</a></span>) to add the optional key-value pairs to the device's property dictionary after it is created.</p></div><p>When you call the <code>CreateTargetForID</code> method, the <code>IOSCSIParallelInterfaceController</code> object creates a new <code>IOSCSIParallelInterfaceDevice</code> object to represent the device. This device object performs the I/O Kit <code>init</code>, <code>attach</code>, and <code>start</code> routines. In the mass storage driver stack, the <code>IOSCSIParallelInterfaceDevice</code> object transitions between objects in the SCSI Parallel family and objects in the SCSI Architecture Model family.</p><p>Because device-specific data is stored in the target device object, the memory for this data is not allocated until the target device object is created. If your HBA driver needs to access that memory to perform set-up tasks for a target object it creates, it should implement the <code>InitializeTargetForID</code> method. This method is called by the <code>IOSCSIParallelInterfaceDevice</code> object in its <code>start</code> method (before the object is registered for matching), when the target device–specific memory is available.</p><p>If your driver calls the <code>CreateTargetForID</code> method to create target device objects, it must also call the <code>DestroyTargetForID</code> method to destroy them. As with the <code>CreateTargetForID</code> method, you cannot override the <code>DestroyTargetForID</code> method; otherwise you might interfere with the tasks the <code>IOSCSIParallelInterfaceDevice</code> object performs in its implementation of the method. When you call the <code>DestroyTargetForID</code> method, the specified <code>IOSCSIParallelInterfaceDevice</code> object terminates.</p><a name="//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_3" title="Start Your HBA Driver (Required)"></a><h3>Start Your HBA Driver (Required)</h3><p>To ready your HBA device to accept I/O requests and SCSI commands, you must implement the <code>StartController</code> method. The superclass calls the <code>StartController</code> method in its own <code>start</code> method, after it has retrieved HBA-specific information from your driver and allocated a pool of SCSI parallel task objects.</p><p>In your <code>StartController</code> method, you might need to enable ports on your hardware, clear pending interrupts, and perform other tasks that put your device in a running state. If your HBA performs device management, you might also scan for target devices in the <code>StartController</code> method. If you do this, be aware that the superclass is holding a command gate while in its <code>start</code> method. You might find that this prevents you from receiving asynchronous, interrupt-based device-discovery notifications. If you experience this, you can create a separate thread on which to call <code>CreateTargetForID</code>.</p><p>The most important thing to remember about the <code>StartController</code> method is that your driver must be prepared to receive and process I/O requests and commands as soon as the method completes.</p><a name="//apple_ref/doc/uid/TP40003194-CH4-SW7" title="Set and Remove HBA and Target Device Properties (Optional)"></a><h3>Set and Remove HBA and Target Device Properties (Optional)</h3><p>During the initialization and starting phases of your driver, you might need to set or remove I/O Registry properties associated with target devices or with the HBA device itself. Instead of using <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IORegistryEntry_h/Classes/IORegistryEntry/index.html#//apple_ref/cpp/cl/IORegistryEntry" target="_top">IORegistryEntry</a></code> methods to do this directly, you should use the methods the <code>IOSCSIParallelInterfaceController</code> class provides. One advantage of using the family-specific methods is that they perform some data validation on the properties you pass in. A more important advantage is that these methods protect you from serialization problems that can occur when different entities attempt to manipulate properties in the I/O Registry at the same time.</p><p>Both the <code>SetTargetProperty</code> and <code>SetHBAProperty</code> methods expect a string containing the property key name and an <code>OSObject</code>-derived object containing the value. Some of the valid target property keys are listed in <span class="content_text"><a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-SW3">Table 2-1</a></span>; a list of valid HBA property keys is in <code><!--a target="_top" -->SetHBAProperty<!--/a--></code>. For more information about the values appropriate for these properties, see the header files <code><a href="../../../../Darwin/Reference/IOKit/IOStorageProtocolCharacteristics_h/index.html#//apple_ref/doc/header/IOStorageProtocolCharacteristics.h" target="_top">IOStorageProtocolCharacteristics.h</a></code> and <code><a href="../../../../Darwin/Reference/IOKit/IOStorageDeviceCharacteristics_h/index.html#//apple_ref/doc/header/IOStorageDeviceCharacteristics.h" target="_top">IOStorageDeviceCharacteristics.h</a></code>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_15" title="Note"></a><p><strong>Note:</strong>&nbsp;You can pass a property's value in the appropriate <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/OSString_h/Classes/OSString/index.html#//apple_ref/cpp/cl/OSString" target="_top">OSString</a></code>, <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/OSData_h/Classes/OSData/index.html#//apple_ref/cpp/cl/OSData" target="_top">OSData</a></code>, or <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/OSNumber_h/Classes/OSNumber/index.html#//apple_ref/cpp/cl/OSNumber" target="_top">OSNumber</a></code> container objects; <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top">OSDictionary</a></code> and <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/OSArray_h/Classes/OSArray/index.html#//apple_ref/cpp/cl/OSArray" target="_top">OSArray</a></code> objects are not allowed because they can cause serialization problems.</p></div><a name="//apple_ref/doc/uid/TP40003194-CH4-SW8" title="Process Parallel Tasks (Required)"></a><h3>Process Parallel Tasks (Required)</h3><p>The primary task of a custom HBA driver is to receive SCSI parallel tasks and pass them along to the target devices. To do this your HBA subclass must implement the <code>ProcessParallelTask</code> method.</p><p>In the <code>ProcessParallelTask</code> method, your HBA driver can call <code>IOSCSIParallelInterfaceController</code> accessor methods to extract information from the <code>SCSIParallelTask</code> object that represents the task. Some of these accessor methods are listed here:</p><ul class="simple"><li><p><code><!--a target="_top" -->GetCommandDescriptorBlock<!--/a--></code></p></li><li><p><code><a href="../../../../Darwin/Reference/IOKit/IOStreamLib_h/index.html#//apple_ref/c/func/GetDataBuffer" target="_top">GetDataBuffer</a></code></p></li><li><p><code><!--a target="_top" -->GetHBADataPointer<!--/a--></code></p></li><li><p><code><!--a target="_top" -->GetSCSIParallelFeatureNegotiationCount<!--/a--></code></p></li></ul><div class="importantbox"><a name="//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_16" title="Important:"></a><p><strong>Important:</strong>&nbsp;You should always use the <code>IOSCSIParallelInterfaceController</code> accessor methods to extract information from the SCSI task object (and all other objects in the stack). This preserves the opacity of these objects and protects you from any changes that might be made to their internal implementations.</p><p></p></div><p>After you've examined the information in the command and processed it as required, you need to send the command out on the bus. Some HBA devices require strict synchronization between sending commands out on the bus and processing the interrupts generated from completed commands; others do not. The <code>IOSCSIParallelInterfaceController</code> class supports both types of HBA device by providing mechanisms an HBA driver can use to ensure the level of synchronization its hardware needs. For more information on how to synchronize these events, see <span class="content_text"><a href="../HBATipsAndTricks/HBATipsAndTricks.html#//apple_ref/doc/uid/TP40003194-CH5-SW2">“Synchronize Hardware Access.”</a></span></p><p>You must return a valid SCSI service response value from your implementation of the <code>ProcessParallelTask</code> method. The following is a list of the SCSI service responses (defined in the header file <code>SCSITask.h</code> in the Kernel framework) you can return: </p><ul class="spaceabove"><li class="li"><p><code>kSCSIServiceResponse_Request_In_Process</code></p><p>Although this is not one of the standard service responses defined in the SCSI Architecture Model specification, it is the response you should return when an asynchronous command is not yet completed.</p></li><li class="li"><p><code>kSCSIServiceResponse_SERVICE_DELIVERY_OR_TARGET_FAILURE</code></p></li><li class="li"><p><code>kSCSIServiceResponse_TASK_COMPLETE</code></p></li><li class="li"><p><code>kSCSIServiceResponse_LINK_COMMAND_COMPLETE</code></p></li><li class="li"><p><code>kSCSIServiceResponse_FUNCTION_COMPLETE</code></p></li><li class="li"><p><code>kSCSIServiceResponse_FUNCTION_REJECTED</code></p></li></ul><p>To learn how to handle timeouts, see <span class="content_text"><a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-SW9">“Handle Timeouts (Optional).”</a></span></p><a name="//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_4" title="Perform SCSI Task Management (Required)"></a><h3>Perform SCSI Task Management (Required)</h3><p>Clients of your HBA driver use the SCSI task management functions (defined in the SCSI Architecture Model 2 specification) to request specific actions. The <code>IOSCSIParallelInterfaceController</code> class defines the following pure virtual methods your subclass must implement to perform these actions:</p><ul class="simple"><li><p><code>AbortTaskRequest</code></p></li><li><p><code>AbortTaskSetRequest</code></p></li><li><p><code>ClearACARequest</code></p></li><li><p><code>ClearTaskSetRequest</code></p></li><li><p><code>LogicalUnitResetRequest</code></p></li><li><p><code>TargetResetRequest</code></p></li></ul><p>In your implementation of these methods, you can complete them either synchronously or asynchronously. If you choose to complete them synchronously, your implementation should return the appropriate SCSI service response. You can return any of the service responses listed at the end of <span class="content_text"><a href="HBADriverDevelopment.html#//apple_ref/doc/uid/TP40003194-CH4-SW8">“Handle Parallel Tasks (Required)”</a></span> <em>except</em> <code>kSCSIServiceResponse_Request_In_Process</code>. </p><p>If you decide to complete these functions asynchronously, your implementation should return only the <code>kSCSIServiceResponse_Request_In_Process</code> service response and then call the appropriate completion method. The <code>IOSCSIParallelInterfaceController</code> class defines the following completion methods your driver should implement if it processes SCSI task management functions asynchronously:</p><ul class="simple"><li><p><code>CompleteAbortTask</code></p></li><li><p><code>CompleteAbortTaskSet</code></p></li><li><p><code>CompleteClearACA</code></p></li><li><p><code>CompleteClearTaskSet</code></p></li><li><p><code>CompleteLogicalUnitReset</code></p></li><li><p><code>CompleteTargetReset</code></p></li></ul><p>Because both command completion and timeout management are serialized on the work loop thread, you should serialize the task management your driver performs on the work loop, too. One way to do this is to use a command gate object associated with the work loop to take the work-loop lock before you send the task management request to the target device (you can accomplish this using the <code>IOCommandGate::runAction</code> function). In this way, you can avoid receiving a command or task management completion at the same time you send a task management request. The <code>IOSCSIParallelInterfaceController</code> class provides the convenient accessor method <code>GetCommandGate</code> to get the command gate object associated with the work loop.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_17" title="Note"></a><p><strong>Note:</strong>&nbsp;There are no timers enabled on task management requests. It is up to your HBA driver to deal with failed task management requests and notify the requesting client of the failure by returning <code>kSCSIServiceResponse_SERVICE_DELIVERY_OR_TARGET_FAILURE</code>.</p></div><a name="//apple_ref/doc/uid/TP40003194-CH4-SW9" title="Handle Timeouts (Recommended)"></a><h3>Handle Timeouts (Recommended)</h3><p>SCSI commands usually have a timeout value associated with them. Your driver does not set the command's timeout value (it is set by the object that sent you the command), but it can enable the timer by calling the <code>SetTimeoutForTask</code> method. (If you choose, you can also use the <code>SetTimeoutForTask</code> method to override the timeout value provided in the task.)</p><p>Although some HBA drivers may not need to do anything when a command times out, many drivers need to perform some cleanup and communicate with the hardware. If your driver needs to handle command timeouts in a hardware-specific way, you can implement the <code>HandleTimeout</code> method. </p><p>When a task times out, the SCSI Parallel family calls the <code>HandleTimeout</code> method. The <code>IOSCSIParallelInterfaceController</code> class's default implementation of this method merely completes the command with a SCSI task status of <code>kSCSITaskStatus_TaskTimeoutOccurred</code> and a SCSI service response of <code>kSCSIServiceResponse_SERVICE_DELIVERY_OR_TARGET_FAILURE</code>. If this does not meet your driver's needs, you can implement the <code>HandleTimeout</code> method to, for example, clean up HBA-specific data structures associated with the command and abort the command. If the command is already out on the bus, you may have to send an <code>AbortTaskRequest</code> command; if not, you may be able to simply remove it from the queue of commands waiting to be sent to the target device.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_18" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>HandleTimeout</code> method is called on the work loop with the lock already held, so you do not have to get the lock in this method.</p></div><a name="//apple_ref/doc/uid/TP40003194-CH4-SW1" title="Handle Interrupt Requests (Required)"></a><h3>Handle Interrupt Requests (Required)</h3><p>As described in <span class="content_text"><a href="../HBAOverview/HBAOverview.html#//apple_ref/doc/uid/TP40003194-CH3-SW1">“The Role of an HBA Device in the Journey of an I/O Request,”</a></span> the completion of an I/O request triggers an interrupt that an HBA driver must handle. When the <code>IOSCSIParallelInterfaceController</code> object is instantiated, it creates a work loop and registers with it a filter interrupt event source (among other event sources). The interrupt event source includes an action routine that runs on the work-loop thread to handle interrupts. When an interrupt occurs, the action routine calls your HBA driver's <code>HandleInterruptRequest</code> method while in the secondary interrupt context (on the work-loop thread with the lock held). Your driver must implement the <code>HandleInterruptRequest</code> method to service the interrupt.</p><p>Your implementation of the <code>HandleInterruptRequest</code> method should be as efficient as possible and never block indefinitely. In particular, this means that you must not allocate memory or create objects in your <code>HandleInterruptRequest</code> method (or any methods it calls), because allocation can block for unrestricted periods of time. Be sure to call the <code>CompleteParallelTask</code> method when your driver completes the processing of a parallel task.</p><a name="//apple_ref/doc/uid/TP40003194-CH4-DontLinkElementID_5" title="Stop and Terminate Your HBA Driver (Required)"></a><h3>Stop and Terminate Your HBA Driver (Required)</h3><p>In your implementation of this required method you should stop accepting commands, but you should not release any resources you may have acquired. This is because you may be called upon to resume accepting commands (with a call to your <code>StartController</code> method) at any time.</p><p>When the <code>IOSCSIParallelInterfaceController</code> object calls your <code>TerminateController</code> method, however, it means your subclass object will be destroyed. You must implement this method to shut down all hardware services and release all resources you've acquired.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../HBAOverview/HBAOverview.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../HBATipsAndTricks/HBATipsAndTricks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-05-23<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/HardwareDrivers/Conceptual/SCSIHBADrivers/HBADriverDevelopment/HBADriverDevelopment.html%3Fid%3DTP40003194-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/HardwareDrivers/Conceptual/SCSIHBADrivers/HBADriverDevelopment/HBADriverDevelopment.html%3Fid%3DTP40003194-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/HardwareDrivers/Conceptual/SCSIHBADrivers/HBADriverDevelopment/HBADriverDevelopment.html%3Fid%3DTP40003194-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>