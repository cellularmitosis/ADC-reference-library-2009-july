<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Summary of Text Utilities(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING353></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-352.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-354.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-279.html"><B>Chapter 5 - Text Utilities</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING353-0></A>
<H1>Summary of Text Utilities<A NAME=MARKER-2-302></A></H1>
<A NAME=HEADING353-1></A>
<H2>Pascal Summary</H2>
<A NAME=HEADING353-2></A>
<H3>Constants</H3>
<PRE>
CONST
         {StringToDate and StringToTime status values }
   longDateFound     = 1;     {mask to long date found}
   leftOverChars     = 2;     {mask to warn of left over chars}
   sepNotIntlSep     = 4;     {mask to warn of non-standard separators}
   fieldOrderNotIntl = 8;     {mask to warn of non-standard field order}
   extraneousStrings = 16;    {mask to warn of unparsable strings in text}
   tooManySeps       = 32;    {mask to warn of too many separators}
   sepNotConsistent  = 64;    {mask to warn of inconsistent separators}
   fatalDateTime     = $8000; {mask to a fatal error}
   tokenErr = $8100;          {mask for 'tokenizer err encountered'}
   cantReadUtilities = $8200; {mask for can't access needed resource}
   dateTimeNotFound = $8400;  {mask for date or time not found}
   dateTimeInvalid = $8800;   {mask for date/time format not valid}
         {Constants for truncWhere argument in TruncString and TruncText} 
   truncEnd       = 0;        {truncate at end}
   truncMiddle    = $4000;    {truncate in middle}
         {Constants for TruncString and TruncText results}
   NotTruncated   = 0;        {no truncation was necessary}
   Truncated      = 1;        {truncation performed}
   TruncErr       = -1;       {general error}
         {Special language code values for Language Order}
systemCurLang  = -2; { current language for system script (from 'itlb')}
systemDefLang  = -3; { default language for system script (from 'itlm')}
currentCurLang = -4; { current language for current script (from 'itlb')}
currentDefLang = -5; { default language for current script (from 'itlm')}
scriptCurLang  = -6; { current lang for specified script (from 'itlb')}
scriptDefLang  = -7; { default language for specified script (from 'itlm')}
</PRE>
<A NAME=HEADING353-7></A>
<H3>Data Types</H3>
<PRE>
TYPE

FormatStatus = Integer;

TruncCode = Integer;

DateForm = (shortDate,longDate,abbrevDate);
FormatResultType = 
(fFormatOK,fBestGuess,fOutOfSynch,fSpuriousChars,fMissingDelimiter,
   fExtraDecimal,fMissingLiteral,fExtraExp,fFormatOverflow,fFormStrIsNAN,
   fBadPartsTable,fExtraPercent,fExtraSeparator,fEmptyFormatString);
FormatClass = (fPositive,fNegative,fZero);
StyledLineBreakCode = {BreakWord, BreakChar, BreakOverflow};
DateCacheRecord =
PACKED RECORD
   hidden: ARRAY [0..255] OF Integer;{only for temporary use}
END;

DateCachePtr = ^DateCacheRecord;
NumFormatStringRec =
PACKED RECORD
   fLength: Byte;
   fVersion: Byte;
   data: PACKED ARRAY [0..253] OF SignedByte;   {private data}
END;
FVector = 
RECORD
   start: Integer;
   length: Integer
END;

TripleInt = ARRAY[0..2] OF FVector;          {index by [fPositive..fZero]}
OffPair =
RECORD
   offFirst: Integer;
   offSecond: Integer;
END;

OffsetTable = ARRAY[0..2] OF OffPair;
ScriptRunStatus =
RECORD
   script: SignedByte;
   variant: SignedByte;
END;
</PRE>
<A NAME=HEADING353-17></A>
<H3>Routines</H3>
<A NAME=HEADING353-18></A>
<H4>Defining and Specifying Strings</H4>
<PRE>
FUNCTION NewString         (theString: Str255): StringHandle;
PROCEDURE SetString        (theString: StringHandle; strNew: Str255);
FUNCTION GetString         (stringID: Integer): StringHandle;
PROCEDURE GetIndString     (VAR theString: Str255; strListID: Integer; 
                            index: Integer);
</PRE>
<A NAME=HEADING353-23></A>
<H4>Comparing Strings for Equality</H4>
<PRE>
FUNCTION EqualString       (aStr, bStr: Str255;
                            caseSens, diacSens: Boolean): Boolean;
FUNCTION IdenticalString   (aStr, bStr: Str255;
                            itl2Handle: Handle): Integer;
FUNCTION IdenticalText     (aPtr, bPtr: Ptr; aLen, bLen: Integer; 
                            itl2Handle: Handle): Integer;
</PRE>
<A NAME=HEADING353-27></A>
<H4>Determining Sorting Order for Strings in Different Languages</H4>
<PRE>
FUNCTION ScriptOrder       (script1, script2: ScriptCode): Integer;
FUNCTION LanguageOrder     (lang1, lang2: LangCode): Integer;
FUNCTION StringOrder       (aStr, bStr: Str255; aScript, bScript: 
                            ScriptCode; aLang, bLang: LangCode): Integer;
FUNCTION TextOrder         (aPtr, bPtr: Ptr; aLen, bLen: Integer;
                            aScript, bScript: ScriptCode;
                            aLang, bLang: LangCode): Integer;
</PRE>
<A NAME=HEADING353-32></A>
<H4>Determining Sorting Order for Strings in the Same Language</H4>
<PRE>
FUNCTION RelString         (aStr, bStr: Str255;
                            caseSens, diacSens: Boolean): Integer;
FUNCTION CompareString     (aStr, bStr: Str255;
                            itl2Handle: Handle): Integer;
FUNCTION CompareText       (aPtr, bPtr: Ptr; aLen, bLen: Integer): Integer;
</PRE>
<A NAME=HEADING353-36></A>
<H4>Modifying Characters and Diacritical Marks</H4>
<PRE>
PROCEDURE UpperString      (VAR theString: Str255; diacSens: Boolean);
PROCEDURE LowercaseText    (textPtr: Ptr; len: Integer;
                            script: ScriptCode);
PROCEDURE UppercaseText    (textPtr: Ptr; len: Integer;
                            script: ScriptCode);
PROCEDURE StripDiacritics  (textPtr: Ptr; len: Integer;
                            script: ScriptCode);
PROCEDURE UppercaseStripDiacritics
                           (textPtr: Ptr; len: Integer;
                            script: ScriptCode);
</PRE>
<A NAME=HEADING353-43></A>
<H4>Truncating Strings</H4>
<PRE>
FUNCTION TruncString       (width: Integer; VAR theString: Str255; 
                            truncWhere: TruncCode): Integer;
FUNCTION TruncText         (width: Integer; textPtr: Ptr;
                            VAR length: Integer;
                            truncWhere: TruncCode): Integer;
</PRE>
<A NAME=HEADING353-46></A>
<H4>Searching for and Replacing Strings</H4>
<PRE>
FUNCTION ReplaceText       (baseText, substitutionText: Handle;
                            key: Str15): Integer;
FUNCTION Munger            (h: Handle; offset: LongInt;
                            ptr1: Ptr; len1: LongInt;
                            ptr2: Ptr; len2: LongInt): LongInt;
</PRE>
<A NAME=HEADING353-49></A>
<H4>Working With Word, Subscript, and Line Boundaries</H4>
<PRE>
PROCEDURE FindWordBreaks   (textPtr: Ptr; textLength: Integer;
                            offset: Integer; leadingEdge: Boolean; 
                            nBreaks: NBreakTablePtr;
                            VAR offsets:OffsetTable );
FUNCTION StyledLineBreak   (textPtr: Ptr; textLen: LongInt;
                            textStart, textEnd, flags: LongInt;
                            VAR textWidth: Fixed;
                            VAR textOffset: LongInt): StyledLineBreakCode;
FUNCTION FindScriptRun     (textPtr: Ptr; textLen: LongInt;
                            VAR lenUsed: LongInt): ScriptRunStatus;
</PRE>
<A NAME=HEADING353-53></A>
<H4>Converting Date and Time Strings Into Numeric Representations</H4>
<PRE>
FUNCTION InitDateCache     (theCache: DateCachePtr): OSErr;
FUNCTION StringToDate      (textPtr: Ptr; textLen: LongInt;
                            theCache: DateCachePtr;
                            VAR lengthUsed: LongInt;
                            VAR dateTime: LongDateRec): StringToDateStatus;
FUNCTION StringToTime      (textPtr: Ptr; textLen: LongInt;
                            theCache: DateCachePtr;
                            VAR lengthUsed: LongInt;
                            VAR dateTime: LongDateRec): StringToDateStatus;
</PRE>
<A NAME=HEADING353-57></A>
<H4>Converting Numeric Representations Into Date and Time Strings</H4>
<PRE>
PROCEDURE DateString       (dateTime: LongInt; longFlag: DateForm;
                            VAR result: Str255; intlHandle: Handle);
PROCEDURE TimeString       (dateTime: LongInt; wantSeconds: Boolean;
                            VAR result: Str255; intlHandle: Handle);
</PRE>
<A NAME=HEADING353-60></A>
<H4>Converting Long Date and Time Values Into Strings</H4>
<PRE>
PROCEDURE LongDateString   (VAR dateTime: LongDateTime; longFlag: DateForm;
                            VAR result: Str255; intlHandle: Handle);
PROCEDURE LongTimeString   (VAR dateTime: LongDateTime; 
                            wantSeconds:Boolean; VAR result: Str255; 
                            intlHandle: Handle);
</PRE>
<A NAME=HEADING353-63></A>
<H4>Converting Between Integers and Strings</H4>
<PRE>
PROCEDURE NumToString      (theNum: LongInt; VAR theString: Str255);
PROCEDURE StringToNum      (theString: Str255; VAR theNum: LongInt);
</PRE>
<A NAME=HEADING353-66></A>
<H4>Using Number Format Specification Strings for International Number Formatting</H4>
<PRE>
FUNCTION StringToFormatRec (inString: Str255; partsTable: NumberParts;
                            VAR outString: NumFormatString): FormatStatus;
FUNCTION FormatRecToString (myFormatRec: NumFormatString;
                            partsTable: NumberParts;
                            VAR outString: Str255;
                            VAR positions: TripleInt): FormatStatus;
</PRE>
<A NAME=HEADING353-69></A>
<H4>Converting Between Strings and Floating-Point Numbers</H4>
<PRE>
FUNCTION StringToExtended  (source: Str255; myFormatRec: NumFormatString; 
                            partsTable: NumberParts;
                            VAR x: Extended80): FormatStatus;
FUNCTION ExtendedToString  (x: Extended80; myFormatRec: NumFormatString; 
                            partsTable: NumberParts;
                            VAR outString: Str255): FormatStatus;
</PRE>
<A NAME=HEADING353-72></A>
<H2>C Summary</H2>
<A NAME=HEADING353-73></A>
<H3>Constants</H3>
<PRE>
enum {      /*StringToDate and StringToTime status values*/
   longDateFound = 1;         /*mask to long date found*/
   leftOverChars = 2;         /*mask to warn of left over chars*/
   sepNotIntlSep = 4;         /*mask to warn of non-standard separators*/
   fieldOrderNotIntl = 8;     /*mask to warn of non-standard field order*/
   extraneousStrings = 16;    /*mask to warn of unparsable strings */
   tooManySeps = 32;          /*mask to warn of too many separators*/
   sepNotConsistent = 64;     /*mask to warn of inconsistent separators*/
   fatalDateTime = 0x8000;    /*mask to a fatal error*/
   tokenErr = 0x8100;         /*mask for 'tokenizer err encountered'*/
   cantReadUtilities = 0x8200;/*mask for can't access needed resource*/
   dateTimeNotFound = 0x8400; /*mask for date or time not found*/
   dateTimeInvalid = 0x8800;  /*mask for date/time format not valid*/
};
enum {   /*constants for truncWhere argument in TruncString and TruncText*/
   truncEnd = 0,              /*truncate at end*/
   truncMiddle = 0x4000,      /*truncate in middle*/
};
enum {   /*constants for TruncString and TruncText results*/
   notTruncated = 0,       /*no truncation was necessary*/
   truncated = 1,          /*truncation performed*/
   truncErr = -1,          /*general error*/
};
enum {   /*special language code values for Language Order*/
   systemCurLang = -2,  /*current lang for system script (from 'itlb')*/
   systemDefLang = -3,  /*default lang for system script (from 'itlm')*/
   currentCurLang = -4, /*current lang for current script (from 'itlb')*/
   currentDefLang = -5, /*default lang for current script (from 'itlm')*/
   scriptCurLang = -6,  /*current lang for specified script (from 'itlb')*/
   scriptDefLang = -7,  /*default lang for specified script (from 'itlm')*/
};
enum {
   BreakWord,
   BreakChar,
   BreakOverflow
};
enum {
   fPositive,
   fNegative,
   fZero
};
enum{
   fFormatOK,
   fBestGuess,
   fOutOfSynch,
   fSpuriousChars,
   fMissingDelimiter,
   fExtraDecimal,
   fMissingLiteral,
   fExtraExp,
   fFormatOverflow,
   fFormStrIsNAN,
   fBadPartsTable,
   fExtraPercent,
   fExtraSeparator,
   fEmptyFormatString
};
enum {
   shortDate,
   longDate,
   abbrevDate
};
</PRE>
<A NAME=HEADING353-82></A>
<H3>Types</H3>
<PRE>
typedef short StringToDateStatus;
typedef unsigned char StyledLineBreakCode;
typedef unsigned char FormatClass;
typedef short TruncCode;
typedef unsigned char FormatResultType;
typedef unsigned char DateForm;
struct DateCacheRecord {
   short hidden[256];            /*only for temporary use*/
};

typedef struct DateCacheRecord DateCacheRecord;
typedef DateCacheRecord *DateCachePtr;
struct NumFormatString {
   char fLength;
   char fVersion;
   char data[254];               /*private data*/
};

typedef struct NumFormatString NumFormatStringRec;
struct FVector {
   short start;
   short length;
};

typedef struct FVector FVector;
typedef FVector TripleInt[3];    /* index by [fPositive..fZero] */
struct ScriptRunStatus {
   char script;
   char variant;
};

typedef struct ScriptRunStatus ScriptRunStatus;
struct OffPair {
   short offFirst;
   short offSecond;
};

typedef struct OffPair OffPair;
typedef OffPair OffsetTable[3];
</PRE>
<A NAME=HEADING353-93></A>
<H3>Routines</H3>
<A NAME=HEADING353-94></A>
<H4>Defining and Specifying Strings</H4>
<PRE>
pascal StringHandle NewString
                              (ConstStr255Param theString);
pascal void SetString         (StringHandle theString,
                               ConstStr255Param strNew);
pascal StringHandle GetString
                              (short stringID);
pascal void GetIndString      (Str255 theString, short strListID,
                               short index);
</PRE>
<A NAME=HEADING353-101></A>
<H4>Comparing Strings for Equality</H4>
<PRE>
pascal Boolean EqualString    (ConstStr255Param aStr, ConstStr255Param bStr, 
                               Boolean caseSens, Boolean diacSens );
pascal short IdenticalString
                              (ConstStr255Param aStr, ConstStr255Param bStr, Handle itl2Handle);
pascal short IdenticallText   (const void *aPtr, const void *bPtr,
                               short aLen, short bLen, Handle itl2Handle);
</PRE>
<A NAME=HEADING353-106></A>
<H4>Determining Sorting Order for Strings in Different Languages</H4>
<PRE>
pascal short ScriptOrder      (ScriptCode script1, ScriptCode script2);
pascal short LanguageOrder    (LangCode language1, LangCode language2);
pascal short StringOrder      (ConstStr255Param aStr, ConstStr255Param bStr, 
                               ScriptCode aScript, ScriptCode bScript, 
                               LangCode aLang, LangCode bLang);
pascal short TextOrder        (const void *aPtr, const void *bPtr,
                               short aLen, short bLen,
                               ScriptCode aScript, ScriptCode bScript, 
                               LangCode aLang, LangCode bLang);
</PRE>
<A NAME=HEADING353-111></A>
<H4>Determining Sorting Order for Strings in the Same Language</H4>
<PRE>
pascal short RelString        (ConstStr255Param aStr, ConstStr255Param bStr, 
                               Boolean caseSens, Boolean diacSens);
pascal short CompareString    (ConstStr255Param aStr, ConstStr255Param bStr, 
                               Handle itl2Hande);
pascal short CompareText      (const void *aPtr, const void *bPtr,
                               short aLen, short bLen, Handle itl2Handle);
</PRE>
<A NAME=HEADING353-115></A>
<H4>Modifying Characters and Diacritical Marks</H4>
<PRE>
pascal void UpperString       (Str255 theString, Boolean diacSens);
pascal void LowercaseText     (Ptr textPtr, short len, ScriptCode script);
pascal void UppercaseText     (Ptr textPtr, short len, ScriptCode script);
pascal void StripDiacritics   (Ptr textPtr, short len, ScriptCode script);
pascal void UppercaseStripDiacritics
                              (Ptr textPtr, short len, ScriptCode script);
</PRE>
<A NAME=HEADING353-122></A>
<H4>Truncating Strings</H4>
<PRE>
pascal short TruncString      (short width, Str255 theString,
                               TruncCode truncWhere);
pascal short TruncText        (short width, Ptr textPtr, short *textLen, 
                               TruncCode truncWhere);
</PRE>
<A NAME=HEADING353-125></A>
<H4>Searching for and Replacing Strings</H4>
<PRE>
pascal short ReplaceText      (Handle baseText, Handle substitutionText, 
                               Str15 key);
pascal long Munger            (Handle h, long offset, const void *ptr1,
                               long len1, const void *ptr2, long len2);
</PRE>
<A NAME=HEADING353-128></A>
<H4>Working With Word, Subscript, and Line Boundaries</H4>
<PRE>
pascal void FindWordBreaks    (Ptr textPtr, short textLen, short offset, 
                               Boolean leadingEdge, NBreakTablePtr breaks, 
                               OffsetTable offsets);
pascal StyledLineBreakCode StyledLineBreak
                              (Ptr textPtr, long textLen, long textStart,
                               long textEnd, long flags, Fixed *textWidth, long *textOffset);
pascal ScriptRunStatus FindScriptRun
                              (Ptr textPtr, long textLen, long *lenUsed);
</PRE>
<A NAME=HEADING353-134></A>
<H4>Converting Date and Time Strings Into Numeric Representations</H4>
<PRE>
pascal OSErr InitDateCache    (DateCachePtr theCache);
pascal StringToDateStatus StringtoDate
                              (Ptr textPtr, long textLen,
                               DateCachePtr theCache, long *lengthUsed, LongDateRec *dateTime);
pascal StringToDateStatus StringToTime
                              (Ptr textPtr, long textLen,
                               DateCachePtr theCache, long *lengthUsed, LongDateRec *dateTime);
</PRE>
<A NAME=HEADING353-140></A>
<H4>Converting Numeric Representations Into Date and Time Strings</H4>
<PRE>
pascal void DateString        (long dateTime, DateForm longFlag,
                               Str255 result, Handle intlHandle);
pascal void TimeString        (long dateTime, Boolean wantSeconds,
                               Str255 result, Handle intlHandle);
</PRE>
<A NAME=HEADING353-143></A>
<H4>Converting Long Date and Time Values Into Strings</H4>
<PRE>
pascal void LongDateString    (LongDateTime *dateTime, DateForm longFlag, 
                               Str255 result, Handle intlHandle);
pascal void LongTimeString    (LongDateTime *dateTime, Boolean wantSeconds, 
                               Str255 result, Handle intlHandle);
</PRE>
<A NAME=HEADING353-146></A>
<H4>Converting Between Integers and Strings</H4>
<PRE>
pascal void NumToString       (long theNum, Str255 theString);
pascal void StringToNum       (ConstStr255Param theString, long *theNum);
</PRE>
<A NAME=HEADING353-149></A>
<H4>Using Number Format Specification Strings for International Number Formatting</H4>
<PRE>
pascal FormatStatus StringToFormatRec
                              (ConstStr255Param inString,
                               const NumberParts *partsTable,
                               NumFormatString *outString);
pascal FormatStatus FormatRecToStr
                              (const NumFormatString *<CODE>myFormatRec</CODE>,
                               const NumberParts *partsTable,
                               Str255 outString, TripleInt positions);
</PRE>
<A NAME=HEADING353-154></A>
<H4>Converting Between Strings and Floating-Point Numbers</H4>
<PRE>
pascal FormatStatus StringToExtended
                              (ConstStr255Param source,
                               const NumFormatString *<CODE>myFormatRec</CODE>,
                               const NumberParts *partsTable, extended80 *x);
pascal FormatStatus ExtendedToString
                              (extended80 x,
                               const NumFormatString *<CODE>myFormatRec</CODE>,
                               const NumberParts *partsTable,
                               Str255 outString);
</PRE>
<A NAME=HEADING353-159></A>
<H2>Assembly-Language Summary</H2>
<A NAME=HEADING353-160></A>
<H3>Trap Macros</H3>
<A NAME=HEADING353-161></A>
<H4>Trap Macro Names
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Pascal name<TH>Trap macro name<TR>
<TD>CompareText<TD>_CompareText<TR>
<TD><CODE>DateString</CODE><TD>_DateString<TR>
<TD>ExtendedToString<TD>_ExtendedToString<TR>
<TD>FindScriptRun<TD>_FindScriptRun<TR>
<TD>FindWordBreaks<TD>_FindWordBreaks<TR>
<TD>FormatRecToString<TD>_FormatRecToString<TR>
<TD>IdenticalText<TD>_IdenticalText<TR>
<TD>InitDateCache<TD>_InitDateCache<TR>
<TD>LanguageOrder<TD>_LanguageOrder<TR>
<TD>LongDateString<TD>_LongDateString<TR>
<TD>LongTimeString<TD>_LongTimeString<TR>
<TD><CODE>NumToString</CODE><TD>_NumToString<TR>
<TD>ReplaceText<TD>_ReplaceText<TR>
<TD>ScriptOrder<TD>_ScriptOrder<TR>
<TD>StringToDate<TD>_StringToDate<TR>
<TD>StringToExtended<TD>_StringToExtended<TR>
<TD>StringToFormatRec<TD>_StringToFormatRec<TR>
<TD>StringToNum<TD>_StringToNum<TR>
<TD>StringToTime<TD>_StringToTime<TR>
<TD>StyledLineBreak<TD>_StyledLineBreak<TR>
<TD>TextOrder<TD>_TextOrder<TR>
<TD>TimeString<TD>_TimeString<TR>
<TD>TruncString<TD>_TruncString<TR>
<TD>TruncText<TD>_TruncText</TABLE>
</H4>
<A NAME=HEADING353-162></A>

<A NAME=HEADING353-163></A>
<H4>Trap Macros With Trap Words
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Trap macro name<TH>Trap word<TR>
<TD>_CmpString<TD><CODE>$A03C</CODE><TR>
<TD>_GetString<TD><CODE>$A9BA</CODE><TR>
<TD>_LowerText<TD><CODE>$A056</CODE><TR>
<TD>_Munger<TD><CODE>$A9E0</CODE><TR>
<TD>_NewString<TD><CODE>$A906</CODE><TR>
<TD>_RelString<TD><CODE>$A050</CODE><TR>
<TD>_SetString<TD><CODE>$A907</CODE><TR>
<TD>_StripText<TD><CODE>$A256</CODE><TR>
<TD>_StripUpperText<TD><CODE>$A656</CODE><TR>
<TD>_UpperText<TD><CODE>$A456</CODE><TR>
<TD>_UprString<TD><CODE>$A054</CODE></TABLE>
</H4>
<A NAME=HEADING353-164></A>
<H4>Trap Macros Requiring Routine Selectors</H4>
<PRE>
_PACK6
</PRE>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Selector<TH>Routine<TR>
<TD>$000E<TD><CODE>DateString</CODE><TR>
<TD>$0010<CODE></CODE><TD>TimeString<TR>
<TD>$0014<CODE></CODE><TD>LongDateString<TR>
<TD>$0016<CODE></CODE><TD>LongTimeString<TR>
<TD>$001A<CODE></CODE><TD>CompareText<TR>
<TD>$001C<CODE></CODE><TD>IdenticalText<TR>
<TD>$001E<CODE></CODE><TD>ScriptOrder<TR>
<TD>$0020<CODE></CODE><TD>LanguageOrder<TR>
<TD>$0022<CODE></CODE><TD>TextOrder</TABLE>

<PRE>
_PACK7
</PRE>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Selector<TH>Routine<TR>
<TD>$0000<TD>NumToString<TR>
<TD>$0001<CODE></CODE><TD>StringToNum</TABLE>

<PRE>
_ScriptUtil
</PRE>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Selector<TH>Routine<TR>
<TD>$8204 FFF8<CODE></CODE><TD>InitDateCache<TR>
<TD>$8208 FFE0<CODE></CODE><TD>TruncString<TR>
<TD>$820C 0026<CODE></CODE><TD>FindScriptRun<TR>
<TD>$820C FFDC<CODE></CODE><TD>ReplaceText<TR>
<TD>$820C FFEC<CODE></CODE><TD>StringToFormatRec<TR>
<TD>$820C FFDE<CODE></CODE><TD>TruncText<TR>
<TD>$8210 FFE6<CODE></CODE><TD>StringToExtended<TR>
<TD>$8210 FFE8<CODE></CODE><TD>ExtendedToString<TR>
<TD>$8210 FFEA<CODE></CODE><TD>FormatRecToString<TR>
<TD>$8214 FFF6<CODE></CODE><TD>StringToDate<TR>
<TD>$8214 FFF4<CODE></CODE><TD>StringToTime<TR>
<TD>$821C FFFE<CODE></CODE><TD>StyledLineBreak<TR>
<TD>$C012 001A<CODE></CODE><TD>FindWordBreaks</TABLE>

 <A NAME=MARKER-2-301></A><A NAME=MARKER-2-764></A><P>
 <P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-352.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-354.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
