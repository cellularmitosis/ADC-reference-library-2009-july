{---------------------------------------------------------------------##	Apple Macintosh Developer Technical Support##	MultiFinder-Aware Simple TextEdit Sample Application##	OOPTESample##	UApplication.p		-	Pascal Source##	Copyright © 1988, 1989 Apple Computer, Inc.#	All rights reserved.##	Versions:		#					1.00					04/89#					1.10					02/90#					1.11					10/92##	Components:     #					BuildOOPTESample			February 1, 1990#					MTESample.p					February 1, 1990#					OOPTESample.make			February 1, 1990#					TECommon.h					February 1, 1990#					TESampleGlue.a				February 1, 1990#					TESample.r					February 1, 1990#					TMLRules.make				February 1, 1990#					UApplication.p				February 1, 1990#					UApplication.inc1.p			February 1, 1990#					UDocument.p					February 1, 1990#					UDocument.inc1.p			February 1, 1990#					UTEDocument.p				February 1, 1990#					UTEDocument.inc1.p			February 1, 1990#					UTESample.p					February 1, 1990#					UTESample.inc1.p			February 1, 1990#---------------------------------------------------------------------}UNIT UApplication;INTERFACEUSES	Types, QuickDraw, Events, OSUtils, ToolUtils, SegLoad, Fonts, Traps, Devices,	Menus, Memory, Controls, TextEdit, Windows, Dialogs,	ObjIntf, UDocument;PROCEDURE AlertUser(errResID:integer; errCode:integer);TYPE	TApplication = OBJECT(TObject)		fHaveWaitnextEvent: Boolean;		fDone: Boolean;		fTheEvent: EventRecord;		fWhichWindow: WindowPtr;		fInBackGround: Boolean;		fWantFrontClicks: Boolean;		fMouseRgn: RgnHandle;		fCurDoc: TDocument;		fDocList: TDocumentList;				{ Initialize our application and instance variables }		PROCEDURE TApplication.IApplication;				{ Call this routine to start event loop running }		PROCEDURE TApplication.EventLoop;				{ Loop control methods you may need to override }		PROCEDURE TApplication.Setup;		{ Run before event loop starts }		PROCEDURE TApplication.CleanUp;		{ Run at end of loop }		PROCEDURE TApplication.ExitLoop;	{ Call this to exit loop }		PROCEDURE TApplication.DoIdle;		{ Idle time handler (blink caret, background tasks) }		PROCEDURE TApplication.AdjustMenus;	{ Menu Updater routine }				{ Event Handlers you shouldn't need to override in a typical application }		PROCEDURE TApplication.HdlOSEvent;		{ Calls DoSuspend, DoResume and DoIdle as apropos }		PROCEDURE TApplication.HdlMouseDown;	{ Calls DoContent, DoGrow, DoZoom, etc }		PROCEDURE TApplication.HdlKeyDown;		{ also called for autokey events }		PROCEDURE TApplication.HdlActivateEvt;	{ handles setup, and calls DoActivate (below) }		PROCEDURE TApplication.HdlUpdateEvt;	{ handles setup, and calls DoUpdate (below) }		PROCEDURE TApplication.HdlMouseUp;		PROCEDURE TApplication.HdlDiskEvt;		PROCEDURE TApplication.MouseInSysWindow;		PROCEDURE TApplication.DoDrag;		PROCEDURE TApplication.DoGoAway;	{ handles setup, calls DoClose (below) }				{ Handlers you will need to override for functionality }					{ Called by EventLoop and its handlers }			PROCEDURE TApplication.AdjustCursor;	{ cursor adjust routine, should setup mouseRgn }			PROCEDURE TApplication.DoMenuCommand(menuID,menuItem: integer);						{ Called by OSEvent. Just calls DoActivate by default, so no clip conversion }			{ is done. If you want to convert the clipboard, override these routines. }			PROCEDURE TApplication.DoSuspend(VAR doClipConvert:Boolean);			PROCEDURE TApplication.DoResume(VAR doClipConvert:Boolean); 		{ Utility routines }			FUNCTION TApplication.TrapAvailable(tNumber:integer;tType:TrapType):Boolean;			FUNCTION TApplication.DocList:TDocumentList;						{ Return total stack and heap space required in bytes. Returns 0 by default. }			FUNCTION TApplication.StackNeeded: Longint;			FUNCTION TApplication.HeapNeeded: Longint;						{ Utility routines you will need ot provide to do MultiFinder stuff }			FUNCTION TApplication.SleepVal: LongInt;	END;	IMPLEMENTATION{$I UApplication.inc1.p}END.