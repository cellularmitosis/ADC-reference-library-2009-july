<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Receiving Packets Addressed to Your Multinode(IM:N)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING289></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Networking-288.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-290.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Networking-2.html"><B>Networking</B></A> / <BR><DD><A HREF="Networking-284.html"><B>Chapter 12 - Multinode Architecture</B></A> / <A HREF="Networking-286.html"><B>Using Multinode Architecture</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING289-0></A>
<H2><A NAME=MARKER-9-31></A>Receiving Packets Addressed to Your Multinode</H2>
 <A NAME=MARKER-2-32></A>Your application must provide a routine that receives packets addressed to the multinode and broadcast packets. Because the .MPP driver passes values to your multinode receive routine in registers when it calls the routine, you must code the receive routine in assembly language. <P>
 You pass the address of your receive routine to the .MPP driver when you call the <CODE>AddNode</CODE> routine to open a multinode. The .MPP driver internally associates your receive routine with the multinode address that it assigns, and it calls your receive routine to handle a packet addressed to the multinode or a broadcast packet. <P>
 If your application acquires more than one multinode, you can use the same receive routine for each of these multinodes. If you use the same receive routine to receive and process packets for more than one multinode, the .MPP driver will call that receive routine only once for each broadcast packet that it receives. <P>
 A multinode receive routine is similar in concept to a socket listener that receives packets addressed to a specific socket. The chapter "Datagram Delivery Protocol (DDP)" in <BR>this book includes a sample socket listener. To create a receive routine, perform the following steps: <P>
<OL>
<LI>Allocate a buffer to hold the data that you expect to receive. <P>
<UL>
<LI>The maximum amount of data in a DDP packet is 586 bytes. All packets addressed to multinodes use a long header, which is 13 bytes long. If your receive routine places the packet header as well as the data portion in the buffer, make the buffer large enough to hold both parts of the packet contents.
<LI>If you use the same receive routine to receive and process packets for more than one multinode, you should provide a separate buffer to store the data for each multinode. You can define a single buffer for each multinode to hold the contents of both the header and data portions of a packet, or you can define a pair of buffers for each multinode to separate the packet's contents. <P>
</UL>
<LI>Determine the number of bytes that have already been read into the .MPP driver's internal buffer, called the RHA. <P>
<UL>
<LI>To do this, subtract the beginning address of the <A NAME=MARKER-2-33></A><I>read-header area (RHA)</I> from the value in register A3, which points past the last byte read into the RHA. To locate the offset at the beginning of the RHA, you can use the <CODE>toRHA</CODE> equate. <P>
When a frame that contains either a DDP packet that is addressed to your multinode or a broadcast packet is delivered to the node that is running your multinode applica-<BR>tion, the node's CPU is interrupted and the .MPP driver's interrupt handler gets control to service the interrupt. As the frame's first 3 bytes are read into a FIFO buffer, the .MPP driver's interrupt handler moves these bytes into the RHA.<P>
</UL>
<LI>Use the <A NAME=MARKER-2-34></A><CODE>ReadPacket</CODE> and <A NAME=MARKER-2-35></A><CODE>ReadRest</CODE> routines to read the rest of the incoming data that constitutes the packet. <P>
How you handle a packet after you read it is particular to your application. For example, if your application implements NBP, you can check the packet's entity name object and type fields against entries in your names table to determine whether to process the packet and respond to the sender. If you respond, the packet you send must adhere to the structure of a standard AppleTalk packet. (See <I>Inside AppleTalk,</I> second edition, for the AppleTalk packet structure.) For a brief description of how ARA uses multinode, see the discussion on <A HREF=Networking-285.html#MARKER-9-15>page 12-5</A>.<P>
<UL>
<LI>You can call the <CODE>ReadPacket</CODE> routine as many times as you like to read the data piece by piece into one or more data buffers that you have defined, but you must always use the <CODE>ReadRest</CODE> routine to read the final piece of the data packet. The <CODE>ReadRest</CODE> routine restores the machine state (the stack pointers, status register, and so forth) and checks for error conditions. 
<LI>Before you call the <CODE>ReadPacket</CODE> routine, you must place a pointer to the data buffer for which you allocated memory in the A3 register. You must also place the number of bytes you want to read in the D3 register. You must not request more bytes than remain in the data packet. 
<LI>After you have called the <CODE>ReadRest</CODE> routine, you can use registers A0 through A3 and D0 through D3 for your own use, but you must preserve all other registers. You cannot depend on having access to your application's global variables.<P>
</UL>
</OL>
<DL>
<DT><B>Calling <CODE>ReadPacket</CODE> and <CODE>ReadRest</CODE> when LocalTalk is the data link</B>
<DD>If <A NAME=MARKER-2-36></A>LocalTalk is the data link that is being used, your receive routine <BR>has less than 95 microseconds (best case) to read more data with a <CODE>ReadPacket</CODE> or <CODE>ReadRest</CODE> routine. If you need more time, you <BR>can read another 3 bytes into the RHA, which will allow you an <BR>additional 95 microseconds. Note that the RHA may only have 8 bytes still available.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<OL>
<LI>If the packet header contains a checksum, you can calculate a <A NAME=MARKER-2-37></A>checksum for both the header and data portions of the packet and then verify the sum of these two values against the value in the <CODE>checksum</CODE> field of the packet header. If the checksum you calculate does not match the one in the header, the data has been corrupted in <BR>some way. (<A HREF=Networking-285.html#MARKER-9-11>Figure 12-1 on page 12-5</A> shows the DDP packet header, including the checksum field.) <P>
The chapter "Datagram Delivery Protocol (DDP)" in this book contains a sample checksum routine to be used for a socket listener; this routine is equally applicable to a multinode receive routine<A NAME=MARKER-2-38></A>. <P>
</OL>
<A NAME=HEADING289-20></A>
<H3>Calling ReadPacket to Read in the Packet Contents</H3>
 To call the <CODE>ReadPacket</CODE> routine, execute a JSR instruction to the address in the A4 register. The <CODE>ReadPacket</CODE> routine uses the registers as follows:
<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on entry to the <CODE>ReadPacket</CODE> routine<TR>
<TD>A3<TD>Pointer to a buffer to hold the data you want to read<TR>
<TD>D3<TD>Size in of bytes to be read; must be nonzero</TABLE>

<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on exit from the <CODE>ReadPacket</CODE> routine<TR>
<TD>A0<TD>Unchanged<TR>
<TD>A1<TD>Unchanged<TR>
<TD>A2<TD>Unchanged<TR>
<TD>A3<TD>Pointer to the first byte after the last byte read into buffer<TR>
<TD>A4<TD>Unchanged<TR>
<TD>D0<TD>Changed <TR>
<TD>D1<TD>Number of bytes left to be read<TR>
<TD>D2<TD>Unchanged<TR>
<TD>D3<TD>Equals 0 if the requested number of bytes were read, nonzero if error</TABLE>
<P>
 After every time that you call <CODE>ReadPacket</CODE>, you must check the zero (<CODE>z</CODE>) flag in the status register for errors because the <CODE>ReadPacket</CODE> routine indicates an error by clearing it to 0. If the <CODE>ReadPacket</CODE> routine returns an error, you must terminate execution of your receive routine with an RTS instruction without calling <CODE>ReadPacket</CODE> again or calling <CODE>ReadRest</CODE> at all. <P>
<A NAME=HEADING289-23></A>
<H3>Calling ReadRest to Complete Reading in the Packet Contents</H3>
 Call the <CODE>ReadRest</CODE> routine to read the last portion of the data packet, or call it after <BR>you have read all the data with <CODE>ReadPacket</CODE> routines and before you do any other processing or terminate execution. After you call <A NAME=MARKER-2-39></A><CODE>ReadRest</CODE>, you must check the zero (<CODE>z</CODE>) flag in the status register for errors.<P>
 After you call the <CODE>ReadRest</CODE> routine, you must terminate execution of your receive routine with an RTS instruction whether or not the <CODE>ReadRest</CODE> routine returns an error. <P>
 When you call the <CODE>ReadRest</CODE> routine, you must provide in the A3 register a pointer to <BR>a data buffer and you must indicate in the D3 register the size of the data buffer. If <BR>you have already read all of the data using the <CODE>ReadPacket</CODE> routine, specify a buffer <BR>of size 0.<P>
<DL>
<DT><B>WARNING</B>
<DD>If you do not call the <CODE>ReadRest</CODE> routine after the last time you call the <CODE>ReadPacket</CODE> routine successfully, the system will crash.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To call the <CODE>ReadRest</CODE> routine, execute a JSR instruction to an address 2 bytes past the address in the A4 register:<P>
<PRE>
JSR 2(A4)
</PRE>
 The <CODE>ReadRest</CODE> routine uses the registers as follows:
<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on entry to the <CODE>ReadRest</CODE> routine<TR>
<TD>A3<TD>Pointer to a buffer to hold the data you want to read<TR>
<TD>D3<TD>Size of the buffer (word length); may be 0 </TABLE>

<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on exit from the <CODE>ReadRest</CODE> routine<TR>
<TD>A0<TD>Unchanged<TR>
<TD>A1<TD>Unchanged<TR>
<TD>A2<TD>Unchanged<TR>
<TD>A3<TD>Pointer to first byte after the last byte read into buffer<TR>
<TD>D0<TD>Changed<TR>
<TD>D1<TD>Changed: number of bytes left to be read<TR>
<TD>D2<TD>Unchanged<TR>
<TD>D3<TD>Equals 0 if the requested number of bytes were read, is less than 0 if the <BR>packet data was too large to fit in the buffer and the data was truncated, and <BR>is greater than 0 to indicate the number of bytes that were not read </TABLE>
<P>
 For more information on how your receive routine can use the registers, see the discussion of the socket listener routine in the chapter "Datagram Delivery Protocol (DDP)" in this book. <A NAME=MARKER-2-40></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Networking-288.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-290.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Networking-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
