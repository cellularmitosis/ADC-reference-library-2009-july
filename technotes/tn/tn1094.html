<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"        "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd"><HTML><!-- Template 03-24-01 --><!--Includes revisions to code listings--><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1094: Virtual Memory Application Compatibility</title>       <meta name="keywords" content="Mac OS 7 Virtual Memory implementation theory VM page faults">    <meta name="Description" content="Technical Note TN1094: This Technical Note provides an introductionto how VM works, both in theory and its specific implementationunder System          7. This Note also gives a detailedexplanation of the steps you need to follow in order to ensurethat your software          executes successfully under VM.This includes ways to improve VM performance and a discussionof certain strange conditions which may arise while usingVM."> <meta name="categories" content="Memory and System Releases"><meta name="week-posted" content="Mar 30, 1998 - Apr 3, 1998"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002934" title="Virtual Memory Application Compatibility"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxRuntimeArchitecture-date.html">Runtime Architecture</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxRuntimeArchitecture-date.html" target="_blank">Carbon > Runtime Architecture</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1094</div>
<div id="pageheadsub">Virtual Memory Application Compatibility</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><center><table width="600" cellpadding="0" cellspacing="0" border="0"> <tr> <td align="left" scope="row"><!-- begin_header_box --> <A HREF="#top"></a><hr width=500 align=center><BR><BR><table border="0" width="600" cellpadding="0" cellspacing="0">	<tr>		<td width=600 align=left> <img src="images/mtop600.gif" alt="Technote menu" align="bottom" width=600 height=7></td>	</tr>		<tr bgcolor="#e6e6e6">	<td background="images/mbody600.gif" width=600 align=left>		<span id="menutitle">CONTENTS   <br>  <br>		</span>	</td>	</tr>	<tr bgcolor="#e6e6e6">	<td background="images/mbody600.gif" width=600 align=left>							<table border="0" width="590" cellpadding="0" cellspacing="0"><tr> <td width=295 align=left scope="row"><!-- begin_toc -->	<a name="contents"></a><p id="menutext"><A HREF = "#Checklist">VM Compatibility Checklist</A><BR><BR><A HREF = "tn1094b.html#Works">How VM Works</A><BR><BR>                                       <A HREF = "tn1094b.html#Works1">Theoretical               Background</A><BR><BR>                              <A HREF = "tn1094b.html#Works2">System 7-Style               Virtual Memory</A><BR><BR>                              <A HREF = "tn1094b.html#Works3">Address Ranges               Controlled by VM</A><BR><BR>                              <A HREF = "tn1094b.html#Works4">Creating an Address               Range</A><BR><BR>                              <A HREF = "tn1094b.html#Works5">Holding and               Locking</A><BR><BR>                              <A HREF = "tn1094b.html#Works6">User vs Supervisor               Mode</A><BR><BR>                              <A HREF = "tn1094b.html#Works7">Privileged               Instruction Emulation</A><BR><BR>                                    <A HREF = "tn1094b.html#Implementation">VM            Implementation Details</A><BR><BR>                                       <A HREF = "tn1094b.html#Implementation1">Preventing               Fatal Page Faults</A><BR><BR>                              <A HREF = "tn1094b.html#Implementation2">Running Old               Drivers</A><BR><BR>                              <A HREF = "tn1094b.html#Implementation3">Synchronous               SCSI Manager</A><BR><BR>                              <A HREF = "tn1094b.html#Implementation4">Asynchronous               SCSI Manager</A><BR><BR>                              <A HREF = "tn1094b.html#Implementation5">ATA               Manager</A><BR><BR>                                    <A HREF = "tn1094b.html#UserCode">Disabling User            Code</A><BR><BR>                                       <A HREF = "tn1094b.html#User1">What is User               Code?</A><BR><BR>                              <A HREF = "tn1094b.html#User1a">What Isn't User               Code?</A><BR><BR>                              <A HREF = "tn1094b.html#User2">DeferUserFn -- The               Guts of the Solution</A><BR><BR>                              <A HREF = "tn1094b.html#UserCorrectDefer">Correct               Way To Defer</A><BR><BR>                              <A HREF = "tn1094b.html#User3">How User Code is               Disabled</A><BR><BR>                                    <A HREF = "#Programming">Programming Implications</A><BR><BR>                                       <A HREF = "#Programming1">Direct SCSI or ATA Manager               Calls</A><BR><BR>                              <A HREF = "#Programming2">Hardware Interrupt               Handlers &amp; Physical Addressing</A><BR><BR>                              <A HREF = "#Programming3">AppleTalk Socket               Listeners</A><BR><BR>                              <A HREF = "#Programming4">Calling Non-Interrupt Safe               Routines</A><BR><BR>                              <A HREF = "#Programming5">Switching Stacks at               Interrupt Time</A></p></td> <td width=295 align=left><P id = "menutext"><A HREF = "#Performance">Ways to Improve            Performance</A><BR><BR>                                       <A HREF = "#Performance1">Grouping Commonly Used               Code and Data</A><BR><BR>                              <A HREF = "#Performance2">Sensible Memory               Management</A><BR><BR>                              <A HREF = "#Performance3a">Paging Control API</A><BR><BR>                              <A HREF = "#Performance3">Judicious Use of               HoldMemory</A><BR><BR>                              <A HREF = "#Performance4">Emulated Instructions</A><BR><BR>                              <A HREF = "#Performance5">VM and Interrupt               Latency</A><BR><BR>                                    <A HREF = "#Weirdnesses">VM Weirdnesses</A><BR><BR>                                       <A HREF = "#WeirdnessesSysHeap">System Heap is               Held</A><BR><BR>                              <A HREF = "#WeirdnessA">Holding Memory at Interrupt               Time</A><BR><BR>                              <A HREF = "#WeirdnessB">Holding Memory with               Interrupts Disabled</A><BR><BR>                              <A HREF = "#Weirdnesses1">Open and Close               Asynchronous</A><BR><BR>                              <A HREF = "#Weirdnesses2">What Form of Address to               Pass?</A><BR><BR>                              <A HREF = "#Weirdnesses3">Allocating Memory Above               BufPtr at INIT time</A><BR><BR>                              <A HREF = "#Weirdnesses4">Compatibility with               Accelerator Upgrades</A><BR><BR>                              <A HREF = "#Weirdnesses5">VM and Passwords</A><BR><BR>                                    <A HREF = "#Macsbug">Things to Do in MacsBug When            You're Dead</A><BR><BR>                                       <A HREF = "#Macsbug1">Recognizing a Fatal Page               Fault</A><BR><BR>                              <A HREF = "#Macsbug2">Is This a Double Page               Fault?</A><BR><BR>                              <A HREF = "#Macsbug3">What Was the First Page               Fault?</A><BR><BR>                              <A HREF = "#Macsbug4">New System Errors</A><BR><BR>                              <A HREF = "#Macsbug5">MacsBug               <CODE>'dcmd'</CODE>s</A><BR><BR>                                    <A HREF = "#Summary">Summary</A><BR><BR>            <A HREF = "#References">References</A><BR><BR>            <A HREF = "#Changes">Change History</A><BR><BR><A HREF = "tn1094gloss.html">Glossary</A><BR><BR><A HREF="#Downloads">Downloadables</A></p><!-- end_toc --></td></tr></table>						</td>	</tr>	<tr>		<td width=600 align=left scope="row"><img src="images/mbot600.gif" alt="menubot600" width=600 height=16>		</td>	</tr></table>            <BR><!-- begin_intro_text --> <P id = "introtext">Although Virtual         Memory (VM) has been available on the Mac OS since the         release of System 7, its use has become more widespread in         recent years. This is because of a combination of factors,         including</P>                  <UL>            <LI><P id = "introtext">the introduction of the Power Macintosh, on which VM            radically reduces application memory usage</p></li>                        <LI><P id = "introtext">the popularity of third-party products, such as RAM            Doubler, which behave in a manner similar to that of            standard virtual memory</p></li>                        <LI><P id = "introtext">the release of System 7.5.5, which significantly            improved the performance and reliability of the VM            implementation</p></li>                        <LI><P id = "introtext">the release of Mac OS 7.6, which file maps CFM-68K            <A HREF = "tn1094gloss.html#PEF">PEF containers</A> to reduce memory usage just like a Power            Macintosh.</p></li>                              </UL>                  <P id = "introtext">Because VM is so widely used, it's critically important         to make sure that your software is compatible with it. This         Technote, which is divided into two parts, provides you with         </P>                  <OL>            <LI><P id = "introtext">an introduction to how VM works, both in theory and its specific implementation under System 7</p></li>                        <LI><P id = "introtext">a detailed explanation of the steps you need to follow in order to ensure that your software executes successfully under VM.</p></li>         </OL>                 <P id = "introtext">All Mac OS programmers should read this Note. For         application developers, this Note supplants and extends the         information presented in <A HREF = "../me/me_09.html">Technote         ME 09, "Coping With VM and Memory Mappings"</A>. Device         driver writers should continue to refer to Technote ME 09.         </P>                  <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P id = introtext><B>Note:</B><BR>This note uses the term <B>application</B> to denote both</p><UL>	<LI><P id = introtext>standard Mac OS applications</p></li>	<LI><P id = introtext>other code resources that run in the application environment, e.g., <CODE>'CDEF'</CODE>s, <CODE>'WDEF'</CODE>s, control panels, and so on.</p></li></ul></TD></TR></TABLE></CENTER><BR>            <P id = "introtext">As far as VM is concerned, the importantdistinction is between application code and devicedrivers.</p><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Apr 02 1998]</h3><!-- end_date --> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content -->         <P><A NAME="Checklist"></A></P>                  <H2>VM Compatibility Checklist</H2>                  <P>In general, programs should be able to ignore VM and         operate successfully. Specific problems may occur under the         following conditions: </P>                  <UL>            <LI>Does your program call SCSI or ATA Managers directly?</li>                        <LI>Does it use hardware interrupt handlers?</li>                        <LI>Does it use physical (as opposed to logical)            addresses?</li>                        <LI>Does it contain an AppleTalk socket listener?</li>                        <LI>Does it call system services that are not            interrupt-safe while paging is not safe?</li>                        <LI>Does it switch stacks at interrupt time?</li>         </UL>                  <P>If your program does none of the operations listed, it         should already be VM-compatible. If you want to improve your         code's performance under VM, you should read the section         <A HREF = "#Performance">Ways to Improve Performance</A> in         this Note.</P>                  <P>On the other hand, if your program does any of these         operations, you'll want to read the next section,         <A HREF = "#Programming">Programming Implications</A>, which         explains how to make your program VM-compatible. That         section is also a good place to start if your program is         incompatible with VM and all you want to do is fix it as         quickly as possible.</P>                  <P>For an overview of VM theory, terminology, and         implementation under System 7, you'll want to go to the         <A HREF = "tn1094b.html#Works">How VM Works</A> section.</p><P><A HREF="#top">Back to top</A></P>         <P><A NAME="Programming"></A></P>                  <H2>Programming Implications</H2>                  <P>If your program does any of the things listed above, you         should read the next few sections for information on how to         execute safely under VM.</p>      <A NAME="Programming1"></A>               <H3>Direct SCSI Manager or ATA Manager         Calls</H3>                  <P>Some applications, such as scanning programs or hard disk         formatters, need to call the SCSI or ATA Managers directly.         These applications must take special care when VM is         enabled. For example, if such an application was to grab         exclusive access to the SCSI bus and then take a page fault,         VM would be unable to swap in the new page, making the page         fault fatal.</P>                  <P>The solution is simple: if your program calls the SCSI or         ATA Manager directly, you must make sure that any code         executed or data accessed while paging is unsafe is held in         memory.</P>                  <P>If you're writing an application, meeting that         requirement can be tricky because it's hard to hold just         part of an application's code in memory. For this reason,         your application might want to implement this functionality         as a bundled device driver or other code resource. This         separation makes it easy for the application to ensure that         the code running while paging is unsafe is held.</p>      <A NAME="Programming2"></A>               <H3>Hardware Interrupt Handlers and Physical Addressing</H3>                  <P>Some applications need to drive hardware devices         directly; for example, a data capture program that talks to         a dedicated PCI card. Such applications typically install         hardware interrupt handlers (either using         <CODE>SIntInstall</CODE>, the native Interrupt Manager on         PCI machines, or the low memory interrupt dispatch tables)         and program a         <A HREF = "tn1094gloss.html#directmemoryaccess">DMA</A>         controller using physical addresses. Because this sort of         operation is typically the realm of device drivers, the         steps you take to operate under VM are specified in device         driver documentation. The following references are useful:          </P>                  <OL>            <LI><a href="http://developer.apple.com/documentation/mac/Memory/Memory-151.html">IM: Memory, Virtual Memory Manager chapter</A></li>                                    <LI><A HREF = "../me/me_09.html">Technote ME 09 - "Coping            With VM and Memory Mappings"</A></li>                         <LI>Designing            PCI Cards and Drivers for Power Macintosh Computers</li>         </OL>                  <P>The basic rules for device driver writers are: </P>                  <OL>            <LI>If you install a hardware interrupt handler, you must            ensure that all code and data it accesses is held            resident in memory.</li>                        <LI>If you have a hardware device that uses physical            addressing (typically a DMA peripheral), you must            translate the logical addresses you are accessing into            physical addresses before passing them to the hardware.</li>         </OL>                  <P>For further explanation, see the above references.</P>                  <P>As an aside, in future versions of the Mac OS it is         likely that these functions will be privileged and         inaccessible from applications. If your application does         this sort of thing, it is most probably a good idea to         prepare for the future by factoring your code into an         application and a bundled device driver.</p>      <A NAME="Programming3"></A>               <H3>AppleTalk Socket Listeners</H3>                  <P>AppleTalk socket listeners are also not VM-safe. An         AppleTalk socket listener on a slow computer using LocalTalk         networking has very difficult real-time goals. Deferring         this while waiting for a page fault would cause serious         packet loss. So, for performance reasons, VM does not defer         socket listeners until paging is safe. Socket listeners must         be written so that they don't cause a page fault.</P>                  <P>The way to make your socket listener VM-safe is to ensure         that all code that can be called by the socket listener, and         the data it accesses, is either held in memory or deferred         using <CODE>DeferUserFn</CODE>. This can be tricky to do         from an application. <A HREF = "../nw/nw_13.html">Technote NW         13 "AppleTalk: The Rest of the Story"</A> demonstrates a         technique that you can use.</p>      <A NAME="Programming4"></A>               <H3>Calling Non-Interrupt-Safe         Routines</H3>                  <P>If your code calls routines that are not interrupt-safe         while handling a non-deferred hardware interrupt (or, for         that matter, any time paging is unsafe), you may encounter a         problem running on Mac OS 7.6 and future releases of the Mac         OS that use System 7-style VM.</P>                  <P>In older Mac OS implementations, large parts of system         software were in the system heap simply so that they could         be shared between applications. These parts caused the         system heap to grow in size. Because the system heap is         always held, these parts were resident, even though they         didn't need to be. This reduced the number of physical pages         of RAM that VM had available to use as a cache for its         various logical address ranges. This reduction made the         system slower.</P>                  <P>Under versions of the Mac OS that use System 7-style VM,         these system parts are being moved out of the system heap         and into file-mapped CFM containers. This makes them         available for paging, and increases the number of physical         pages available to VM. In general, this helps system         performance.</P>                  <P>Such parts of the system are only made pageable if none         of their routines can be called at interrupt time.         Otherwise, a non-deferred hardware interrupt might call         these routines and cause a fatal page fault.</P>                  <P>However, some programs call non-interrupt-safe routines         when paging isn't safe. This works under earlier versions of         Mac OS because the code for these routines was in the system         heap, and hence resident. Such software has problems under         newer versions of Mac OS when VM is turned on because these         routines are no longer held. If your software was previously         compatible with VM and broke under Mac OS 7.6, you should         check to be sure that you are not calling non-interrupt-safe         routines when paging is unsafe.</p><A NAME="Programming5"></A>         <H3>Switching Stacks at Interrupt         Time</H3>                  <P>If your code switches stacks at interrupt time (usually         this is done to guarantee a minimum amount of available         stack space), it must ensure that the stack is held. This is         true even if your code runs at times when paging is         normally safe, such as deferred task time.</P>                  <P>For a detailed explanation of why this is necessary, see         <A HREF = "tn1094b.html#Works6">User vs Supervisor Mode</A>.</p>      <P><A HREF="#top">Back to top</A></P>      <A NAME="Performance"></A>               <H2>Ways to Improve Performance         </H2>                  <P>This section describes a number of things that you can do         to make your application work better under VM.</P>                  <P><A NAME="Performance1"></A></P>                  <H3>Grouping Commonly Used Code and         Data</H3>                  <P>Perhaps the best thing you can do to make your         application work better under VM is to analyze its working         set. The <A HREF = "tn1094gloss.html#workingset">working set</A>         of a program is the set of memory pages that the program         accesses most often. The smaller you make your working set,         the better your program will run under VM. If the working         set of all the active processes exceeds the amount of         physical memory available for paging, the system begins to         take an excessive number of page faults. This state is known         as <A HREF = "tn1094gloss.html#thrashing">thrashing</A>.</P>                  <P>Under System 7 there are no good tools for analyzing your         application's working set automatically. However, you can do         some things to empirically adjust your working set. One good         thing is to 'segment' your CFM-based applications sensibly.         </P>                  <P>Most development environments provide a mechanism for         CFM-based applications to sort routines in their PEF         container according to a "group" that is set using compiler         directives. This is analogous to the classic runtime         segmentation model. You can use these directives to group         rarely used functions together and away from the commonly         used functions. This helps keep rarely used code paged out,         which reduces your working set.</p>            <A NAME="Performance2"></A>               <H3>Sensible Memory Management         </H3>                  <P>Another good place to look when analyzing your working         set is your memory management system. Some memory management         systems are VM-friendly, and some are not. For example, if         your memory management system looks at every block in the         heap when a block is freed, it has pathologically bad VM         performance.</P>                  <P>On PowerPC machines, the system Memory Manager (also         known as the Modern Memory Manager) has been optimized to be         as VM-friendly as possible. It's important that you be         compatible with the Modern Memory Manager, for this and         other reasons.</P>                  <P>On 680x0 machines, the Memory Manager has some behaviors         that cause excessive page faults under VM. Unfortunately,         there's not a lot you can do about the system Memory Manager         on these machines other than avoid using it.</P>                  <P>If you're using your own memory management scheme (for         C++ objects, for example), you should look at its         implementation to determine whether it's VM-friendly. A         VM-friendly memory manager attempts to reduce the number of         times it looks at bytes located in different pages, and thus         minimizes the program's working set. You may be able to         switch memory managers and get VM performance benefits.</P>                  <P>Another way to avoid thrashing is to minimize your use of         Process Manager         <A HREF = "tn1094gloss.html#temporarymemory">temporary         memory</A>. While it may appear that this memory is free for         application use, under VM this memory has often been paged         out, and therefore is not 'real'. So if you look at         temporary memory and see that there's a huge amount of free         space, do not allocate and use it all. This will likely         cause the system to thrash. Only allocate as much temporary         memory as you actually need.</p><A NAME="Performance3a"></A>         <H3>Paging Control API</H3>                  <P>Mac OS 8.1 introduced a new API for the Virtual Memory         Manager, the VM paging control API. Your application can use         this API to advise VM on how it is using memory. This allows         VM to optimize its paging behavior to improve application,         and overall system, performance.</P>                  <P>You can read more about the VM paging control API in the         <A HREF = "tn1121.html#VirtualMemoryPaging">Mac OS 8.1         Technote</A>.</p>            <A NAME="Performance3"></A>               <H3><EM>Judicious</EM> Use of <CODE>         HoldMemory</CODE></H3>                  <P>The <CODE>HoldMemory</CODE> call causes a certain range         of logical memory to be marked as ineligible for paging. The         call was designed to allow system and user programs to avoid         fatal page faults by forcing critical chunks of code and         data to be held in real memory.</P>                  <P>However, sometimes the <CODE>HoldMemory</CODE> call is         useful for applications to allow them to meet real-time         goals. For example, it's possible for high quality sound         playback to break up when playing on a machine running VM.         One way to avoid this is to hold the buffer that contains         the sound, to avoid it being paged out to disk.</P>                  <P>Application programs should not make arbitrary decisions         to hold large chunks of memory. You should only resort to         holding memory if you have an identifiable problem under VM.         Remember that the Virtual Memory Manager acts like a cache.         Every time you hold a chunk of memory, that memory becomes         unavailable for paging for the rest of the system,         effectively decreasing the size of the cache. If you do this         without due care and attention, you cause the system to         thrash.</p>         <A NAME="Performance4"></A>         <H3>Emulated Instructions</H3>                  <P>When you execute a privileged 680x0 instruction, the         Virtual Memory Manager emulates that instruction to prevent         a privilege violation exception. This emulation takes time.         You should avoid executing privileged 680x0 instructions         where possible. This list of these instructions is given in         the section <A HREF = "tn1094b.html#Works7">Privileged         Instruction Emulation</A>.</P>                  <P>One common use of emulated instructions is disabling         interrupts to ensure atomicity. In a lot of cases, you can         avoid this by using the processor's built-in synchronization         primitives. This includes the <CODE>CAS</CODE> instruction         on the 68020 and higher, and the <CODE>lwarx</CODE> and         <CODE>stwcx</CODE> instructions on the PowerPC. Some system         services, specifically Open Transport's <CODE>OTLIFO</CODE>         lists and <CODE>OTGate</CODE>, are based on top of these         instructions and provide for fast atomic operations without         using any privileged instructions or Mixed Mode switches.         </P>                                    <P><B>Note</B></P>                                    <P>The <CODE>CAS</CODE> instruction is not                  available on the 68000 processor. However, as VM                  does not work on computers with that processor,                  this should not be a problem: you can just use                  privileged instructions without any speed penalty.                  </P>                                    <P><B>Important</B>                  </P>                                    <P>You should not use the <CODE>TAS</CODE>                  instruction as a replacement for <CODE>CAS</CODE>                  because it is not supported on certain Mac OS                  computers.</p><A NAME="Performance5"></A>         <H3>VM and Interrupt Latency</H3>                  <P>If interrupt latency is important to you, VM presents         further challenges. Because VM defers user code until page         faults are no longer fatal, it can increase the latency         between when the interrupt is signalled and when the user         code executes.</P>                  <P>There are some things you can do to reduce specific         interrupt latency problems when running under VM: </P>                  <UL>            <LI>The Time Manager has a special "back door" that            allows you to install Time Manager tasks that bypass the            safety net provided by VM. <A HREF = "tn1063.html">Technote            1063 "Inside Macintosh: Processes: Time Manager            Addenda"</A> documents this technique.</li>                        <LI>Device Drivers that are marked as            <A HREF = "tn1094gloss.html#VMimmune">VM-immune</A> are            ignored by the Virtual Memory Manager. As such, the            Virtual Memory Manager does not defer the completion            routines issued by these device drivers. If you have your            own private device driver, and you can guarantee that all            the driver's clients are prepared to be called at times            when paging is not safe, you can set this bit in your            device driver and decrease the interrupt latency to your            clients. <A HREF = "../nw/nw_13.html">Technote NW 13            "AppleTalk: The Rest of the Story"</A> describes this            technique.</li>         </UL>                  <P>Both techniques employ the same basic idea, which is that         you deliberately take some of your user code and turn it         into non-user code to avoid VM's latency.</p><P><A HREF="#top">Back to top</A></P>         <P><A NAME="Weirdnesses"></A></P>                  <H2>Some VM Weirdnesses</H2>                  <P>This section describes a few little things about VM --         its weirdnesses -- that you should know about.</P>                  <P><A NAME="WeirdnessesSysHeap"></A></P>                  <H3>System Heap is Held</H3>                  <P>Under Apple's current VM implementation, the entire         system heap is automatically held resident in physical         memory. This is done to provide compatibility with old         device drivers that would not otherwise be compatible with         VM. There may be future Apple VM implementations (or current         non-Apple VM implementations) that do not hold the entire         system heap. Thus, you should not rely on this safety net.         If you want something to be held, you should explicitly hold         it.</P>                  <P><A NAME="WeirdnessA"></A></P>                  <H3>Holding Memory at Interrupt         Time</H3>                  <P>The VM API routines for holding memory resident         (<CODE>HoldMemory</CODE>, <CODE>LockMemory</CODE>,         <CODE>LockMemoryForOutput</CODE>) are safe to call at         interrupt time if one of the following conditions is met:          </P>                  <UL>            <LI>paging is safe, or</li>                        <LI>paging is unsafe but the range of pages passed to            <CODE>HoldMemory </CODE>is already held, or</li>                        <LI>paging is unsafe but the range of pages passed to            <CODE>LockMemory </CODE>is already locked.</li>         </UL>                  <P>These routines can cause paging activity as VM swaps in         the memory that is to be held. Obviously, this is bad when         paging is unsafe. So you must either ensure that paging is         safe or that the call won't cause any paging activity.</P>                  <P><A NAME="WeirdnessB"></A></P>                  <H3>Holding Memory with Interrupts Disabled</H3>                  <P>On computers running system software prior to System         7.1.2, VM specifically prohibited all routines based on the         <CODE>_MemoryDispatch</CODE> trap (the most important being         <CODE>HoldMemory</CODE>) from being called at interrupt         time. This restriction has now been lifted.</P>                  <P>The typical reason for calling <CODE>HoldMemory</CODE>         with interrupts disabled is that you are calling it at         interrupt time. If so, you must make sure you follow the         rules in the previous section.</P>                  <P><A NAME="Weirdnesses1"></A></P>                  <H3>Open and Close Asynchronous</H3>                  <P><A HREF = "../me/me_09.html">Technote ME 09,"Coping With VM         and Memory Mappings"</A> says: </P>                  <P>As it turns out, when you make an         asynchronous <CODE>_Open</CODE> or <CODE>_Close</CODE> call         to a device driver, any completion routine you supply is         never called. Since Virtual Memory patches         <CODE>_Open</CODE> and <CODE>_Close</CODE>, and generates an         entry for the completion routine in the user function queue,         the implication is that the user functions are never         executed and the queue may simply fill up.</P>                  <P>This statement is erroneous in one respect. VM does not         patch <CODE>_Open</CODE> or <CODE>_Close</CODE>, so calling         these routines asynchronously will not mess up the VM         patches. However, for other reasons, you should not open or         close drivers using asynchronous calls. If you are acting on         a device driver, you should always use the high-level glue         routines <CODE>OpenDriver</CODE> and         <CODE>CloseDriver</CODE>.</P>                  <P><A NAME="Weirdnesses2"></A></P>                  <H3>What Form of Address to         Pass?</H3>                  <P>All of the VM API routines (<CODE>HoldMemory</CODE>,         <CODE>LockMemory</CODE>, etc) work as expected in either         24-bit mode or 32-bit mode. In 24-bit mode, for instance,         master pointer flags or other garbage in the high-order         eight bits are ignored and assumed to be zero. When         switching between 24-bit and 32-bit modes, remember to use         <CODE>_StripAddress</CODE> as outlined in         <A HREF = "../me/me_06.html"> Technote ME 06 "_StripAddress:          The Untold Story"</A>.</P>                                    <P><B>Note</B></P>                                    <P>Mac OS 7.6 and beyond do not support 24-bit                  mode. PowerPC-based Mac OS computers do not support                  24-bit mode.               </p>                           <P><A NAME="Weirdnesses3"></A></P>                  <H3>Allocating Memory Above <CODE>BufPtr</CODE> at         Startup Time</H3>                  <P><CITE>Inside Macintosh, Volume IV</CITE> describes, on         page 257, a method of static allocation for drivers or other         data structures that has been popular with a number of         developers: </P>                  <P>Static allocation off the address contained         in the global variable <CODE>BufPtr</CODE> is useful when a         large amount of space is needed which will never be         deallocated (once space is allocated, it may not be         deallocated unless no one has allocated space below). An         'INIT' resource may obtain permanent space by moving         <CODE>BufPtr</CODE> down, but no further than the location         of the boot blocks (<CODE>MemTop</CODE>/2 + 1KB).</P>                           <P>The main thing to remember about         <A HREF = "tn1094gloss.html#memoryaboveBufPtr"> allocating         memory above <CODE>BufPtr</CODE></A> is that memory         allocated in this way is not held in physical memory by         default. If you require that this memory be resident, you         must be explicitly hold it yourself. This is in contrast         with memory in the system heap, which is automatically held         in the current VM implementation.</P>                  <P>In addition, when allocating memory above         <CODE>BufPtr</CODE>, always use the equation given above.         The actual configuration of memory at boot time is much more         complicated than the illustration in <CITE>Inside Macintosh         IV</CITE> indicates, especially with System 7 and VM. The         System 7 boot code passes a specially-conditioned version of         <CODE>MemTop</CODE> to system extensions, which guarantees         that the equation has valid results.</P>                  <P>Due to the way memory is organized with VM in 24-bit         addressing, you may not be able to achieve nearly as much         memory above <CODE>BufPtr</CODE> as you would think possible         for a given virtual memory size. This is due to the         possibility of VM fragmentation. Without VM, the available         space above <CODE>BufPtr</CODE> is generally somewhat less         than half the amount of memory installed in the machine.         With 24-bit VM, the available space may be significantly         less, and is probably far less than one half of the virtual         memory size. The conditioning of the <CODE>MemTop</CODE>         variable takes this into account.</P>                  <P><A NAME="Weirdnesses4"></A></P>                  <H3>Compatibility with Accelerator         Upgrades</H3>                  <P>The burden of compatibility has long been on the         shoulders of accelerator manufacturers. VM may present some         additional compatibility challenges for these manufacturers.         </P>                  <P>Virtual Memory requires services which are not present in         the ROMs of 68000-based machines, so VM is not supported on         the Macintosh SE, even one with a 68030 accelerator. The         same is true of the Macintosh Plus, the Macintosh Classic,         Macintosh Portable and PowerBook 100. Apple's VM only works         on machines which Apple intended to include MMUs.</P>                  <P>Virtual Memory depends on low-memory globals to indicate         the presence of a memory management unit at a very early         stage of the boot process. If the hardware features of an         accelerator are significantly different from those of the         stock Macintosh computer, the low-memory globals are not         properly set by the boot code in ROM. The most likely         problems are exhibited by 68000 Macintosh computers, 68020         Macintosh computers with 68030 accelerators, and Macintosh         computers with 68040 accelerators.</P>                  <P>It's not that VM does not work with any accelerators, but         rather that System 7-style VM is not guaranteed to support         third-party accelerators.</P>                  <P><A NAME="Weirdnesses5"></A></P>                  <H3>VM and Passwords</H3>                  <P>Some developers have expressed concern about the safety         of passwords under VM. For secure environments, any         possibility of a password being copied to disk is         unacceptable. Under VM there is such a possibility. For         example, imagine the following sequence: </P>                  <OL>            <LI>program asks for password</li>                        <LI>program does authentication</li>                        <LI>program clears out password in memory</li>         </OL>                  <P>If VM pages out the password buffer during step 2 and the         system crashes sometime after step 3 but before VM manages         to page out the (now cleared) password buffer, a copy of the         password will remain on disk in the backing store.</P>                  <P>The solution is simple: the program should hold the         password buffer before step 1 and unhold it after step 3.         Holding the password buffer ensures that VM never pages it         out while it contains the password.</p>         <P><A HREF="#top">Back to top</A></P>         <P><A NAME="Macsbug"></A></P>                  <H2>Things to Do in MacsBug When         You're Dead</H2>                  <P>When, after reading through this Note and checking that         you follow all the rules given here, you still find that         your software crashes when VM is enabled, there are things         you can do to determine what went wrong.</P>                  <P>The most common symptom of failure under VM is that you         drop into MacsBug with a bus error because VM was unable to         satisfy a page fault request.         <A HREF = "tn1094b.html#Works2">Remember</A> that VM is hooked         into the bus error handler and propagates any bus errors         that it's unable to handle -- either because it's not in a         section of memory that's under VM control, or because it's         already handling a page fault, or for any other reason -- to         the bus error handler pointed to by the low memory         pseudo-vector.</P>                  <P>There are a number of things you can do to recognize and         analyze this situation listed in the following sections.         </P>                  <P><A NAME="Macsbug1"></A></P>                  <H3>Recognizing a Fatal Page         Fault</H3>                  <P>The most obvious symptom of a fatal page fault is that         you end up in MacsBug with a bus error. Unfortunately bus         errors have more than one cause. You can a bus error because         of a fatal page fault, but the most common cause for bus         errors is dereferencing a bogus pointer.</P>                  <P>You can quickly see whether this bus error is a possible         fatal page fault by checking whether paging is safe. If you         look on the left side of the MacsBug display, you will see a         two character code that describes the state of VM. If this         code is "RM" (Real Memory), VM is not running. If this state         is "VM", VM is running but paging is safe. If the state is         "vM", VM is running and paging is not safe. If paging is         safe, the bus error is not a fatal page fault, and you         should look elsewhere for the cause.</P>                  <P>Of course, not all bus errors that happen when paging is         unsafe are fatal page faults. It takes a bit more work to         determine this. For example, imagine dropping into MacsBug         with the following message: </P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    Bus Error accessing 00123456 at PC 4080BB8C    4080BB8C     MOVE.W     $0010(A0),D0&nbsp;</pre>	</TD></TR></TABLE></CENTER>                  <P>MacsBug reports that the instruction that caused the bus         error is at address $4080BB8C, but this report is not always         correct. The dynamic recompiling (DR) emulator found on         recent PowerPC computers can cause an imprecise PC address         to be reported by MacsBug. However, one piece of information         that you can rely on is the address that was being accessed         and caused the page fault. In the above example, this is         address $00123456. You can find out information about this         address using the following MacsBug command: </P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    dm $00123456    wh $00123456&nbsp;</pre>	</TD></TR></TABLE></CENTER>                  <P>If this command indicates that the address is in valid         memory (i.e., either the primary address range or one of the         file mapped address ranges), the access should have         succeeded. The only reason for this bus error is a fatal         page fault.</P>                  <P>If the <CODE>wh</CODE> command reports that the address is "not in         RAM or ROM", chances are that this bus error is just a         normal bus error, ie one caused by dereferencing a bogus         pointer.</P>                  <P>Another common form of fatal page fault is reported as:          </P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    Bus Error at 4080BB8C    while writing long work (data = 0000009B) to 00123456    4080BB8C     LINK     A6,#$FFCC&nbsp;</pre>	</TD></TR></TABLE></CENTER>                  <P>The <CODE>LINK</CODE> instruction is touching the stack, which may         have been paged out. You can check this by looking at the         value of <CODE>SP</CODE>, which has most probably just crossed a page         (4KB) boundary. You can confirm that this is a fatal page         fault by looking to see whether paging is safe and by         checking the target address 00123456 using <CODE>wh</CODE> and <CODE>dm</CODE>.         </P>                  <P>A third form of fatal page fault is reported as: </P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    Bus Error accessing 00123456 at PC 00123456    Unable to access that address&nbsp;</pre>	</TD></TR></TABLE></CENTER>                  <P>In this case, the actual instruction fetch has caused a         bus error. You can confirm that this is a fatal page fault         by looking to see whether paging is safe and by checking the         target address using <CODE>wh</CODE>.</P>                                    <P><B>Note</B></P>                                    <P>These last two examples may also be complicated                  by the DR emulator. Remember that you can trust the                  "accessing" address reported but not the PC.               </p>                  <P><A NAME="Macsbug2"></A></P>                  <H3>Is This a Double Page Fault?</H3>                  <P>Not all fatal page faults are double page faults. For         example, if you take a page fault while the device driver         that's controlled the backing store is busy, the page fault         is fatal, even though it isn't a double page fault. See the         "<A HREF = "tn1094b.html#Implementation1">Preventing Fatal         Page Faults</A>" section for a description of the various         reasons why a page fault might be fatal.</P>                  <P>Determining whether a fatal page fault is a double page         fault is reasonably tricky. One good indicator is whether         you're in user or supervisor mode. You can tell this by         looking at the S bit in the         <A HREF = "tn1094gloss.html#StatusRegister">SR</A> display in         MacsBug. If this is a capital "S", you are in supervisor         mode; if this is a lower case "s" you are in user mode.</P>                  <P>You can't get double page faults from user mode. If you         get a fatal page fault and you're in user mode, you know         there was some other cause. One good place to start         debugging this is to use MacsBug's <CODE>drvr</CODE> command to see if         any of the paging device drivers are busy. Remember that you         will suffer a         <A HREF = "tn1094gloss.html#resourceconstraintfatalpage">         resource constraint fatal page fault</A> if you take a page         fault while the paging device driver is busy.</P>                  <P>Unfortunately, taking a fatal page fault in supervisor         mode still isn't a guarantee that it was a double page fault.         The only certain way to determine whether it was a double         page fault is to dump memory starting at the         <A HREF = "tn1094gloss.html#interruptstackpointer">ISP</A> and         look for a         <A HREF = "tn1094gloss.html#buserrorexceptionstackframe">bus         error exception stack frame</A> on the interrupt stack. Bus         error exception stack frames are relatively easy to         recognize because they contain a special word that denotes         the frame type. For a bus errror on a 68040, this value is         <CODE>$7008</CODE>. For a bus error on the 68020, 68030, and the emulated         680x0 processor of a PowerPC-based computer, this value is         <CODE>$B008</CODE>.</P>                                    <P><B>Note</B></P>                                    <P>Under rare circumstances is is possible for the                  68020 and 68030 processors to generate a frame type                  of <CODE>$A008</CODE> in response to a bus error.               </p>                  <P>You can also use other fields in the exception frame to         confirm that you have found the correct frame. All of the         exception stack frames we're interested in share a common         format, as shown below: </P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    SP + $00 - Status Register    SP + $02 - High Word of PC    SP + $04 - Low Word of PC    SP + $06 - Frame Format, Vector Offset (eg $B008)    ... and so on&nbsp;</pre>	</TD></TR></TABLE></CENTER>                                 <P>Once you have found the frame type word on the stack, you         can look back six bytes to find the value of the Status         Register (SR) immediately prior to the bus error. Common         values for SR are <CODE>$0Ixx</CODE> or <CODE>$2ixx</CODE>, where <CODE>I</CODE> is the interrupt         level (0 to 7) and <CODE>xx</CODE> is "don't care". You can look at this         saved SR, see whether its value is sensible, and use that to         confirm whether you have found the bus error exception         frame.</P>                  <P>Once you find the bus error exception stack frame, you         can use the information in         <A HREF = "http://www.mot.com/SPS/HPESD/aesop/68k/68kprm.pdf">         M68000 Family Programmer's Reference Manual</A> to examine         the frame and find more clues about the cause.</P>                                    <P><B>Important</B></P>                                    <P>On PowerPC-based Mac OS computers, the value for                  the PC stored in the bus error exception frame is                  always incorrect. The interaction between the                  PowerPC processor and the Virtual Memory Manager                  causes this PC address to always point to an                  address within VM itself.               </p>                  <P><A NAME="Macsbug3"></A></P>                  <H3>What Was the First Page         Fault?</H3>                  <P>Once you know you've taken a double page fault, you can         find out information about the first page fault by looking         at the         <A HREF = "tn1094gloss.html#buserrorexceptionstackframe">bus         error exception stack frame</A>. The format of this frame is         described in the         <A HREF = "http://www.mot.com/SPS/HPESD/aesop/68k/68kprm.pdf">M68000         Family Programmer's Reference Manual</A>. For example, a bus         error exception stack frame on a 68040 looks like: </P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    SP + $00 - Status Register    SP + $02 - High Word of PC    SP + $04 - Low Word of PC    SP + $06 - Frame Format, Vector Offset (contains $7008)    SP + $08 - High Word of Effective Address    SP + $0A - Low Word of Effective Address    ... and so on&nbsp;</pre>	</TD></TR></TABLE></CENTER>                                 <P>Once you find the start of the frame, you can dump the         long at offset <CODE>$02</CODE> from the start of the frame to determine,         subject to the restrictions described in the previous         section, the address of the instruction that took the         original bus error.</P>                  <P>You can also dump the long at offset <CODE>$08</CODE> from the start         of the frame to determine the address that the code was         trying to access when it bus errored.</P>                  <P>Finally, you can dump the word at offset <CODE>$00</CODE> from the         start of the frame to determine the value of the SR when the         bus error occurred. This can be useful to determine the type         of code that was running at the time. For example, interrupt         level 4 is used by the Macintosh Serial Communications         Controller (SCC) and it's likely that a fatal page fault         that happens when the processor is at interrupt level 4 is         somehow related to serial code.</P>                  <H3>Read-Only Memory Exceptions</H3>                  <P>When VM is enabled, it maps CFM containers into         <A HREF = "tn1094gloss.html#filemappingspace">file mapping         space</A>. These file-mapped address ranges are read-only.         Any attempt to write to your own code will cause you to drop         into MacsBug with the message: </P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>PowerPC read-only memory exception at 02314BB8 main+00018&nbsp;</pre>	</TD></TR></TABLE></CENTER>                  <P>For example, the following snippet of PowerPC code runs         just fine when VM is disabled, but dies under VM: </P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static void Wibble(void){}void main(void){    char x;    x = **((char **) Wibble);    **((char **) Wibble) = x;}</pre>	</TD></TR></TABLE></CENTER>                                    <P><B>Note</B></P>                                    <P>The extra dereference in the above snippet is                  required because procedure pointers on a CFM                  architecture are actually pointers to transition                  vectors.               </p>                  <P><A NAME="Macsbug4"></A></P>                  <H3>New System Errors</H3>                  <P>System 7.5.5 introduced two new system errors related to         virtual memory. Both errors are completely fatal for the         system, but if you encounter one while debugging, it is         useful to know their cause.</P>                     <P><CODE>dsVMDeferredFuncTableFull</CODE> (112)</p>                        <P>This error is generated when the deferred            user function table is full. A common way of getting this            error is to defer an operation that has already been            deferred. Another possibility is to install a Time            Manager task which has already been installed.</p>                        <P>If you get this error, you can use the "UsersFns"            <CODE>'dcmd'</CODE> (part of MacsBug 6.5.4a1 and later)            to dump out the list of deferred user functions. If you            see one entry repeated many times, you should start            looking for problems in how you use the system service            corresponding to that entry.</p>                        <P>Specifically, if you find that there the list of            deferred user functions is full of Time Manager user            functions, check that you are calling            <CODE>RmvTime</CODE> for each time you call            <CODE>InsTime</CODE> (or <CODE>InsXTime</CODE>). While            imbalanced calls to the Time Manager work when VM is            disabled, they are not correct and they will cause this            system error when VM is enabled.</p>                        <P><CODE>dsVMBadBackingStore</CODE> (113)</p>                        <P>This error is generated when VM gets an error while            reading or writing a backing store. Typically, this            indicates a genuine hardware problem. It could be a            useful debugging aid if you are developing a paging            device driver.</p>                    <P>See <A HREF = "tn1069.html">Technote 1069 - "System         7.5.5"</A> for more details on all of the changes that         occurred in the System 7.5.5 release of VM.</P>                  <P><A NAME="Macsbug5"></A></P>                  <H3>MacsBug <CODE>'dcmd'</CODE>s</H3>                  <P><a href="http://developer.apple.com/cgi-bin/ftpchooser.pl?partialURL=Tool_Chest/Testing_-_Debugging/Debuggers_-_dcmds/">MacsBug</A>         contains two <CODE>'dcmd'</CODE>s that can be useful when         debugging VM problems. The first, <CODE>VMDump</CODE>, dumps the         current state of VM on a page-by-page basis. The second,         <CODE>UserFns</CODE>, displays a the current list of deferred user         functions.</P>                  <P>For information about these <CODE>'dcmd'</CODE>s, type         the following commands in MacsBug: </P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    help vmdump    help userfns    </pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P>         <P><A NAME="Summary"></A></P>                  <H2>Summary</H2>                  <P>Virtual memory is not rocket science. While its         implementation on the Mac OS is complicated by the         constraints of the original design, it's not         incomprehensible. Understanding how VM works will help you         know why the rules are important, recognize when you need to         apply them, and debug problems when they arise.</P><P><A HREF="#top">Back to top</A></P><a name="References"></a><H2>References</H2>            <p><CITE><a href="http://developer.apple.com/documentation/mac/Memory/Memory-2.html">Inside            Macintosh: Memory</A></CITE> provides a description of            the VM API calls.</p>                        <p><A HREF = "../me/me_09.html">Technote ME 09 - "Coping            With VM and Memory Mappings"</A> Although the information            in ME 09 is supplanted by this Technote for application            code, ME 09 still contains useful information for            traditional device driver (DRVR) writers.</p>                        <p><CITE>Designing            PCI Cards and Drivers for Power Macintosh            Computers</CITE> describes the VM rules that apply to            native drivers ('ndrv's)</p>                        <p><CITE><A HREF = "http://www.mot.com/SPS/HPESD/aesop/68k/68kprm.pdf">M68000            Family Programmer's Reference Manual</A></CITE> gives            detailed information about the 680x0 exception            architecture, including the exception vector table and            the bus error exception frame.</p>                        <p><CITE><a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-2.html">Inside            Macintosh: PowerPC System Software</A></CITE> gives a            description of the differences between an emulated 680x0            processor and a real one, including the bus error            exception frame format of the emulated variety.</p>                        <p><A HREF = "tn1063.html">Technote 1063 - <CITE>"Inside            Macintosh: Processes</CITE>: Time Manager Addenda"</A>            describes how to mark your Time Manager task "VM immune".</p>                        <p><A HREF = "tn1069.html">Technote 1069 - "System            7.5.5"</A> describes how to mark your Time Manager task            "VM immune".</p>                        <p><A HREF = "../nw/nw_13.html">Technote NW 13 -            "AppleTalk: The Rest of the Story"</A> describes how to            mark your device "VM immune".</p>                        <p><A HREF = "../me/me_09.html">Technote ME 06 -            "_StripAddress: The Untold Story"</A></p>                        <p><CITE>Modern Operating Systems</CITE>, by Andrew S.            Tanenbaum, Prentice-Hall, 1992, ISBN 0-13-588187-0 gives            a good introduction to virtual memory in general.         </p>  <P><A HREF="#top">Back to top</A></P>                  <a name="Changes"></a>         <h2>Change history:</h2><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5>   <TR>      <td align="left">         <P ALIGN=CENTER>1.0</p>      </TD><td align="left">         <P ALIGN=CENTER>03/97</p>      </TD><td align="left">         <P ALIGN=CENTER>initial version</p>      </TD></TR>   <TR>      <td align="left">         <P ALIGN=CENTER>1.1</p>      </TD><td align="left">         <P ALIGN=CENTER>3/98</p>      </TD><td align="left">         <P ALIGN=CENTER>updated to reference the Mac OS 8.1 VM paging control         APIs, and to describe the requirement that          private interrupt-time stacks must be held resident.</p>      </TD></TR></TABLE>                   <P><A HREF="#top">Back to top</A></P>         <P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" alt="Acrobat gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (84K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1094.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR>                  <P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1094.html%3Fid%3DDTS10002934-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1094.html%3Fid%3DDTS10002934-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1094.html%3Fid%3DDTS10002934-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML> 