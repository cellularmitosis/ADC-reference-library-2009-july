<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>BSDLLCTest - /BSDLLCTest.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Networking/index.html">Networking</a> &gt; <a href="../../samplecode/Networking/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">BSDLLCTest</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">BSDLLCTest</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/BSDLLCTest.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BSDLLCTest.c</option>
<option value="listing2.html">/BSDLLCTest.h</option>
<option value="listing3.html">/BSDLLCTestCommon.h</option>
<option value="listing4.html">/EthernetSocketStuff.c</option>
<option value="listing5.html">/EthernetSocketStuff.h</option>
<option value="listing6.html">/EthernetSocketTool.c</option>
<option value="listing7.html">/GetEthernetAddrSample.c</option>
<option value="listing8.html">/GetEthernetAddrSample.h</option>
<option value="listing9.html">/MoreAuthSample/MoreCFQ/MoreCFQ.c</option>
<option value="listing10.html">/MoreAuthSample/MoreCFQ/MoreCFQ.h</option>
<option value="listing11.html">/MoreAuthSample/MoreSecurity/MoreSecurity.c</option>
<option value="listing12.html">/MoreAuthSample/MoreSecurity/MoreSecurity.h</option>
<option value="listing13.html">/MoreAuthSample/MoreSecurity/MoreSecurityTest/MoreSecurityTest.c</option>
<option value="listing14.html">/MoreAuthSample/MoreSecurity/MoreSecurityTest/MoreSecurityTestCommon.h</option>
<option value="listing15.html">/MoreAuthSample/MoreSecurity/MoreSecurityTest/MoreSecurityTestTool.c</option>
<option value="listing16.html">/MoreAuthSample/MoreSecurity/ReadMeAboutMoreAuthSample.html</option>
<option value="listing17.html">/MoreAuthSample/MoreSetup.h</option>
<option value="listing18.html">/MoreAuthSample/MoreUNIX/MoreUNIX.c</option>
<option value="listing19.html">/MoreAuthSample/MoreUNIX/MoreUNIX.h</option>
<option value="listing20.html">/ReadMe-BSDLLCTest.html</option></select>
				</p>
				</form>
				<p><strong><a href="BSDLLCTest.zip">Download Sample</a></strong> (&#147;BSDLLCTest.zip&#148;, 442.6K)<BR>
<strong><a href="BSDLLCTest.dmg">Download Sample</a></strong> (&#147;BSDLLCTest.dmg&#148;, 760.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    BSDLLCTest.c  Contains:  Simple app write or receive 8022 Ethernet packets using a raw mode socket  Copyright:  Copyright (c) 1998-2003 by Apple Computer, Inc., All Rights Reserved.  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc. (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your use, installation, modification or redistribution of this Apple software constitutes acceptance of these terms.  If you do not agree with these terms, please do not use, install, modify or redistribute this Apple software. In consideration of your agreement to abide by the following terms, and subject to these terms, Apple grants you a personal, non-exclusive license, under Apple's copyrights in this original Apple software (the &quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple Software, with or without modifications, in source and/or binary forms; provided that if you redistribute the Apple Software in its entirety and without modifications, you must retain this notice and the following text and disclaimers in all such redistributions of the Apple Software.  Neither the name, trademarks, service marks or logos of Apple Computer, Inc. may be used to endorse or promote products derived from the Apple Software without specific prior written permission from Apple.  Except as expressly stated in this notice, no other rights or licenses, express or implied, are granted by Apple herein, including but not limited to any patent rights that may be infringed by your derivative works or by other works in which the Apple Software may be incorporated. The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS. IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. **/#include &quot;BSDLLCTest.h&quot;#include &quot;GetEthernetAddrSample.h&quot;#include &quot;EthernetSocketStuff.h&quot;#include &quot;MoreUNIX.h&quot;enum {    kDestAddressField = 1,    kDSAPField = 2,    kSNAPField = 3,    kNumPacketsField = 4,    kSendTimeField = 5,    kTransferRateField = 6,    kNumPacketsReceivedField = 7,    kNumPacketsInOrderField = 8,    kNumPacketsOutOfOrderField = 9,    kLastPacketReceivedField = 10,    kDoTestButton = 11,    kSendReceiveButton = 12,    kSNAPLabel = 13,    kSourceAddressField = 14,    kDestAddressIsMCast = 15,    kEnetPopupButton = 16,    kCancelTestButton = 17,    kAboutAppNameText = 18,    kAboutVersionText = 19,    kQuitButton = 20,    kLastItem};#define kMaxInputSize  32//-----------------------------------------------------------------------------------------// Globals//-----------------------------------------------------------------------------------------IBNibRef       gNibRef;WindowRef       gMainWindow;WindowRef       gAboutWindow;EventLoopRef    gMainLoop;EventLoopTimerUPP  gTimerUPP;EventLoopTimerRef  gTimerRef;EventHandlerUPP   gMyDoTestButtonInterceptorUPP;EventHandlerUPP   gMyDoCancelTestButtonInterceptorUPP;EventHandlerUPP   gMySendRcvButtonInterceptorUPP;EventHandlerUPP    gMyAppCommandInterceptorUPP;EventHandlerUPP   gMyEnetPopupCommandInterceptorUPP;EventHandlerUPP   gMyDestAddrIsMCastInterceptorUPP;EnetData      gedata[kMaxEnetEntries];EnetTestData    gTestData;EnetTestData    *gEnetTestData = &amp;gTestData;UInt32        gNumEnetEntries = kMaxEnetEntries;UInt32        gCurrPopupEntry = 1;UInt32        gVerMacOS;MACAddress      gDestAddr = {MCASTADDR0, MCASTADDR1, MCASTADDR2, MCASTADDR3, MCASTADDR4, MCASTADDR5};MACAddress      gBroadcastAddr = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};UInt16        gSAPAddr = DEFAULTSAP;UInt8        gSNAPAddr[5] = {MYSNAP0, MYSNAP1, MYSNAP2, MYSNAP3, MYSNAP4};UInt32        gSendRcvState = kSendTest;  // indicates the current state of the testUInt32        gNumPacketsToHandle = DEFAULT_NUM_PACKETS_TO_SEND;UInt32        gFlags;int          gshmid;Boolean        gDestAddrIsMCast;Boolean        gDone;Boolean        gAbort = FALSE;//-----------------------------------------------------------------------------------------// Prototypes//-----------------------------------------------------------------------------------------pascal void TimerAction(EventLoopTimerRef theTimer, void *userData);UInt32   MyNumToHexString(UInt32 num, char *str);OSStatus MyHexStringToNum(char *str, UInt32 *num);OSStatus MyStringToNum(char *str, SInt32 *num);UInt32    MyNumToString(UInt32 num, char *str, Boolean negative);OSStatus GetSAPFieldValue(UInt16 *sap);OSStatus SetSAPFieldValue(UInt16 sap);OSStatus GetSNAPFieldValue(UInt8 *snap);OSStatus SetSNAPFieldValue(UInt8 *sap);OSStatus GetNumPacketsField(UInt32 *numPackets);OSStatus SetSendStatistics(UInt32 numPackets, UInt32 sendTime);OSStatus SetReceiveStatistics(UInt32 packetsReceived, UInt32 PacketsInOrder,                                 UInt32 PacketsOutOfOrder, UInt32 lastPacketReceived);OSStatus LoadMainWindowFromNibFile(IBNibRef gNibRef);OSStatus LoadAboutWindowFromNibFile(IBNibRef gNibRef);OSStatus EnetStrToAddr(char *str, MACAddress *eaddr);int    EnetAddrToString(MACAddress *eaddr, char *str);OSStatus SetEthernetAddressField(SInt32 id, MACAddress *eaddr);OSStatus SetResults(EnetTestData *enetTestData);OSStatus MyDoCancelTestButtonInterceptor(EventHandlerCallRef inCallRef, EventRef inEvent, void* inUserData);OSStatus MyDestAddrIsMCastInterceptor(EventHandlerCallRef inCallRef, EventRef inEvent, void* inUserData);OSStatus MyDoTestButtonInterceptor(EventHandlerCallRef inCallRef, EventRef inEvent, void* inUserData);void    AddEnetServicesToPopupMenu(EnetData *enetdata);void    SetActiveEnetPopupMenu(UInt16 menuItem);OSStatus MyEnetPopupButtonInterceptor(EventHandlerCallRef inCallRef, EventRef inEvent, void* inUserData);OSStatus MySendRcvButtonInterceptor(EventHandlerCallRef inCallRef, EventRef inEvent, void* inUserData);OSStatus MyAppCommandInterceptor(EventHandlerCallRef inCallRef, EventRef inEvent, void* inUserData);void    Initialize(void);  /* function prototypes */void    DisposeUPPs();/********************************************************************************* Initialize** Do stuff like InitCursor********************************************************************************/void Initialize()  /* Initialize some managers */{    OSErr  err;            InitCursor();        err = Gestalt(gestaltSystemVersion, &amp;gVerMacOS);  if (err != noErr)        ExitToShell();  else  {    fprintf(stderr, &quot;Version of Mac OS is %X\n&quot;, (int)gVerMacOS);    if (gVerMacOS &lt;= 0x1015)    {      fprintf(stderr, &quot;The MultiCast option for a receive socket is not supported in this release\n&quot;);      fprintf(stderr, &quot;This release of the OS support a max packet size of 1499 bytes only\n&quot;);    }  }    // init the gedata array    memset(gedata, 0, sizeof(gedata));    // SIGPIPE bad.  // refer to the MoreAuthSample code for the use of MoreUNIXIgnoreSIGPIPE    err = EXXXToOSStatus( MoreUNIXIgnoreSIGPIPE() );}pascal void TimerAction(EventLoopTimerRef theTimer, void *userData){    if (gSendRcvState == kCancelTest)  {    SetResults(gEnetTestData);  }}/*    MyNumToHexString takes a UInt32 value and creates a hex string with the     &quot;0x&quot; prefix*/UInt32 MyNumToHexString(UInt32 num, char *str){    UInt32  n, i, j, digit;    char  tmp[16];    n = num;    i = j = 0;        while (n)    {         // create an inverted string        digit = n % 0x10;        if (digit &lt; 10)            tmp[j++] = '0' + digit;        else            tmp[j++] = 'A' + digit - 10;        n /= 0x10;    }        // insert the string prefix    str[i++] = '0';    str[i++] = 'x';    // inssert the string    while (j != 0)    {        str[i++] = tmp[--j];    }    // set null termination of the string    str[i] = 0;    return i;}/*    MyHexStringToNum converts a str - a &quot;C&quot; style string which can be prefixed with &quot;0x&quot;    or 'x' and returns the value in num*/OSStatus MyHexStringToNum(char *str, UInt32 *num){    UInt32  i, len;    UInt32  digit;        // intialize the *num to 0    *num = 0;        len = strlen(str);        if (str[0] == 'x' || str[0] == 'X')    {        if (len &gt; 9)            return -1;  // string to long to fit into a UInt32 result        else            i = 1;    }    else if (str[0] == '0' &amp;&amp; (str[1] == 'x' || str[1] == 'X'))    {        if (len &gt; 10)            return -1;  // string to long to fit into a UInt32 result        else            i = 2;    }    else    {        if (len &gt; 8)            return -1;  // string to long to fit into a UInt32 result        else            i = 0;    }        while (i &lt; len)    {        digit = str[i++];        if (digit &gt;= '0' &amp;&amp; digit &lt;= '9')            digit -= '0';        else if (digit &gt;= 'A' &amp;&amp; digit &lt;= 'F')    {      digit += 10;            digit -= 'A';    }        else if (digit &gt;= 'a' &amp;&amp; digit &lt;= 'f')    {      digit += 10;            digit -= 'a';    }        else  // an illegal character is in the string            return -1;        *num = *num * 0x10 + digit;    }    return noErr;}OSStatus MyStringToNum(char *str, SInt32 *num){    UInt32  i, len;    UInt32  digit;    Boolean  isNegative = false;        i = 0;    *num = 0;    len = strlen(str);        if (str[i] == '-')    {        isNegative = true;        i++;    }    while (i &lt; len)    {        if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')            digit = str[i] - '0';        else            return -1;        *num = *num * 10 + digit;        i++;    }    if (isNegative)        *num *= -1;            return noErr;}UInt32 MyNumToString(UInt32 num, char *str, Boolean negative){    UInt32  n, i, j;    char  tmp[16];        n = num;    i = j = 0;        if (negative)        str[i] = '-';    if (n != 0)  {    while (n)    {      // create an inverted string      tmp[j++] = '0' + (n % 10);      n /= 10;    }  }  else    tmp[j++] = '0';        // now move the inverted string into the str    while (j != 0)    {        str[i++] = tmp[--j];    }    // set null termination of the string    str[i] = 0;    return i;}OSStatus GetSAPFieldValue(UInt16 *sap){    ControlID  controlID = { kTestSignature, kDSAPField };    ControlRef  control;    UInt32  len;    OSStatus  err = noErr;    UInt32  value;    char  str[16];    err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);        err = GetControlData(control, kControlNoPart, kControlEditTextTextTag,                        sizeof(str), str, &amp;len);    require_noerr(err, CantGetControlData);    str[len] = 0;        err = MyHexStringToNum(str, &amp;value);    require_noerr(err, InvalidData);    *sap = value;    return noErr;     InvalidData:    fprintf(stderr, &quot;Invalid hx data in control %ld\n&quot;, controlID.id);    return err;    CantGetControlData:    fprintf(stderr, &quot;Unable to find control data - control %ld, error was %d\n&quot;, controlID.id, (int)err);    return err;    CantGetControlByID:    fprintf(stderr, &quot;Unable to find control ID %ld, error was %d\n&quot;, controlID.id, (int)err);    return err;    }OSStatus SetSAPFieldValue(UInt16 sap){    ControlID  controlID = { kTestSignature, kDSAPField };    ControlRef  control;    OSStatus  err = noErr;    UInt32  len;    char  str[16];    err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);        len = MyNumToHexString(gSAPAddr, str);        if (len &gt; 0)    {        err = SetControlData(control, kControlNoPart, kControlStaticTextTextTag, len, &amp;str);        require_noerr(err, CantSetControlData);    }    return noErr;CantSetControlData:    fprintf(stderr, &quot;Unable to set control data %ld, error was %d\n&quot;, controlID.id, (int)err);    return err;    CantGetControlByID:    fprintf(stderr, &quot;Unable to find control ID %ld, error was %d\n&quot;, controlID.id, (int)err);    return err;}OSStatus GetSNAPFieldValue(UInt8 *snap){    ControlID  controlID = { kTestSignature, kSNAPField };    ControlRef  control;    UInt32  len;    OSStatus  err = noErr;    UInt32  value;  UInt32  offset;  UInt32  i;    char  str[16];  char  temp1[2], temp2[2];    err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    err = GetControlData(control, kControlNoPart, kControlEditTextTextTag, sizeof(str), str, &amp;len);    require_noerr(err, CantGetControlData);    str[len] = 0;  offset = 0;  if((str[0] == 'x') || (str[0] == 'X'))    offset = 1;  else if((str[1] == 'x') || (str[1] == 'X'))    offset = 2;    // create a 1 char string to pass to the MyHexStringToNum function  temp1[1] = temp2[1] = 0;  for (i = 0; i &lt; 5; i++)  {      // get the upper byte character    temp1[0] = str[offset + 2 * i];      // get the lower byte character    temp2[0] = str[offset + 2 * i + 1];      // convert the upper byte    err = MyHexStringToNum(temp1, &amp;value);    if (err)      break;      // set the upper byte of the snapAddr    snap[i] = value &lt;&lt; 4;      // convert the lower byte character    err = MyHexStringToNum(temp2, &amp;value);    if (err)      break;      // set the lower byte of the snapAddr    snap[i] += value;      }        require_noerr(err, InvalidData);    return noErr;                        InvalidData:    fprintf(stderr, &quot;Invalid hx data in control %ld\n&quot;, controlID.id);  memset(snap, 0, 5);  // zero out the  snap address    return err;CantGetControlData:    fprintf(stderr, &quot;Unable to find control data - control %ld, error was %d\n&quot;, controlID.id, (int)err);    return err;CantGetControlByID:    fprintf(stderr, &quot;Unable to find control ID %ld, error was %d\n&quot;, controlID.id, (int)err);    return err;}OSStatus SetSNAPFieldValue(UInt8 *snap){    ControlID  controlID = { kTestSignature, kSNAPField };    ControlRef  control;    OSStatus  err = noErr;    UInt32    len;  UInt32    i, val;    char    str[16];    err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    // the snap address is a 5 byte value, which we will prefix with &quot;0x&quot;    str[0] = '0';  str[1] = 'x';    for (i = 0; i &lt; 5; i++)  {    // set the higher digit    val = snap[i] / 16;    if ((val &gt;= 0) &amp;&amp; (val &lt;= 9))      str[2 * i + 2] = '0' + val;    else if ((val &gt;= 10) &amp;&amp; (val &lt;= 15))      str[2 * i + 2] = 'A' + val - 10;    else      return -1;    // set the lower digit    val = snap[i] % 16;    if ((val &gt;= 0) &amp;&amp; (val &lt;= 9))      str[2 * i + 3] = '0' + val;    else if ((val &gt;= 10) &amp;&amp; (val &lt;= 15))      str[2 * i + 3] = 'A' + val - 10;    else      return -1;  }  str[12] = 0;  len = 12;  err = SetControlData(control, kControlNoPart, kControlStaticTextTextTag, len, &amp;str);  require_noerr(err, CantSetControlData);  return noErr;    CantGetControlByID:    fprintf(stderr, &quot;Unable to find control ID %ld, error was %d\n&quot;, controlID.id, (int)err);    return err;CantSetControlData:    fprintf(stderr, &quot;Unable to set control ID %ld, error was %d\n&quot;, controlID.id, (int)err);    return err;}OSStatus SetControlState(WindowRef window, OSType type, SInt32 id, Boolean enable){    OSStatus  err;    ControlID  controlID;    ControlRef  control;      controlID.signature = type;    controlID.id = id;        err = GetControlByID(window, &amp;controlID, &amp;control);      require_noerr(err, CantGetControlByID);      if (enable)    {        err = ActivateControl(control);        require_noerr(err, CantEnableControl);    }    else    {        err = DeactivateControl(control);        require_noerr(err, CantDisableControl);    }    return noErr;CantGetControlByID:    fprintf(stderr, &quot;Unable to find control ID %ld, error was %d\n&quot;, id, (int)err);    return err;CantEnableControl:    fprintf(stderr, &quot;Unable to enable control %ld, error was %d\n&quot;, id, (int)err);    return err;CantDisableControl:    fprintf(stderr, &quot;Unable to disable control %ld, error was %d\n&quot;, id, (int)err);    return err;}OSStatus SetStateOfSendReceiveFields(void){    ControlID  controlID = { kTestSignature, kSendReceiveButton };    ControlRef  control;    OSStatus  err = noErr;    Boolean  sendState, recvState;  if (gSendRcvState != kCancelTest)  {            err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);            require_noerr(err, CantGetControlByID);            // get the state of the Send Receive buttons            gSendRcvState = GetControlValue(control);            if (gSendRcvState == kSendTest)            {                                    SetEthernetAddressField(kSourceAddressField, &amp;gedata[gCurrPopupEntry-1].macAddress);                SetEthernetAddressField(kDestAddressField, &amp;gDestAddr);                // enable the send fields                // disable the receive fields                sendState = kEnable;                recvState = kDisable;            }            else            {                // set the source address as a generic broadcast address and                // the destination address as the                SetEthernetAddressField(kSourceAddressField, &amp;gBroadcastAddr);                SetEthernetAddressField(kDestAddressField, &amp;gedata[gCurrPopupEntry-1].macAddress);                // enable the receive fields                // disable the send fields                sendState = kDisable;                recvState = kEnable;            }            // these fields are always enabled for send and received            SetControlState(gMainWindow, kTestSignature, kSendReceiveButton, kEnable);            SetControlState(gMainWindow, kTestSignature, kDSAPField, kEnable);            SetControlState(gMainWindow, kTestSignature, kSNAPField, kEnable);            SetControlState(gMainWindow, kTestSignature, kSourceAddressField, kEnable);            SetControlState(gMainWindow, kTestSignature, kDestAddressField, kEnable);            SetControlState(gMainWindow, kTestSignature, kDoTestButton, kEnable);            // the test button is always disabled when not running a test            SetControlState(gMainWindow, kTestSignature, kCancelTestButton, kDisable);  }  else  {            // in the CancelTest state, all fields and buttons are disabled except the            // CancelTest button and the quit button            SetControlState(gMainWindow, kTestSignature, kDoTestButton, kDisable);            SetControlState(gMainWindow, kTestSignature, kSendReceiveButton, kDisable);            // the test button is always disabled when not running a test            SetControlState(gMainWindow, kTestSignature, kCancelTestButton, kEnable);            sendState = kDisable;            recvState = kDisable;            SetControlState(gMainWindow, kTestSignature, kDSAPField, kDisable);            SetControlState(gMainWindow, kTestSignature, kSNAPField, kDisable);            SetControlState(gMainWindow, kTestSignature, kSourceAddressField, kEnable);  }  // set the stat of the send fields    SetControlState(gMainWindow, kTestSignature, kNumPacketsField, sendState);    // set the state of the receive fields    SetControlState(gMainWindow, kTestSignature, kDestAddressIsMCast, recvState);    SetControlState(gMainWindow, kTestSignature, kNumPacketsReceivedField, kDisable);    SetControlState(gMainWindow, kTestSignature, kNumPacketsInOrderField, kDisable);    SetControlState(gMainWindow, kTestSignature, kNumPacketsOutOfOrderField, kDisable);    SetControlState(gMainWindow, kTestSignature, kLastPacketReceivedField, kDisable);    // leave the kDestAddressIsMCast radio button disabled if the current MacOS is 10.1.5 or    // earlier since the SetMulticast feature does not work    if (gVerMacOS &lt;= 0x1015)        SetControlState(gMainWindow, kTestSignature, kDestAddressIsMCast, kDisable);    else        SetControlState(gMainWindow, kTestSignature, kDestAddressIsMCast, recvState);        return noErr;        CantGetControlByID:    fprintf(stderr, &quot;Error in setting data for Send Statistics - %ld\n&quot;, err);    return err;}OSStatus GetNumPacketsField(UInt32 *numPackets){    ControlID  controlID = { kTestSignature, kNumPacketsField };    ControlRef  control;    UInt32  len;    char  str[16];    OSStatus  err;    err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    // get the control text    err = GetControlData(control, kControlNoPart, kControlEditTextTextTag,                         sizeof(str), str, &amp;len);    require_noerr(err, CantGetControlData);   // force string to be a &quot;C&quot; style string    str[len] = 0;    // convert the string    err = MyStringToNum(str, numPackets);    require_noerr(err, InvalidStringData);    return noErr;    InvalidStringData:CantGetControlByID:CantGetControlData:    return err;}OSStatus SetSendStatistics(UInt32 numPackets, UInt32 sendTime){    ControlID  controlID = { kTestSignature, kNumPacketsField };    ControlRef  control;    UInt32  len, rate;    char  str[16];    OSStatus  err;        err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    len = MyNumToString(numPackets, str, kPositive);    // set the control text    err = SetControlData(control, kControlNoPart, kControlStaticTextTextTag, len, str);    require_noerr(err, CantSetControlData);//    fprintf(stderr, &quot;set num packets sent field to %s\n&quot;, str);    controlID.id = kSendTimeField;    err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    len = MyNumToString(sendTime, str, kPositive);    err = SetControlData(control, kControlNoPart, kControlStaticTextTextTag, len, &amp;str);    require_noerr(err, CantSetControlData);//    fprintf(stderr, &quot;set time field to %s\n&quot;, str);        if (sendTime &gt; 0)        rate = numPackets / sendTime;    else        rate = 0;    controlID.id = kTransferRateField;    err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    len = MyNumToString(rate, str, kPositive);    // set the control data    err = SetControlData(control, kControlNoPart, kControlStaticTextTextTag, len, str);    require_noerr(err, CantSetControlData);//    fprintf(stderr, &quot;set rate field to %s\n&quot;, str);    SetControlState(gMainWindow, kTestSignature, kSendTimeField, FALSE);    SetControlState(gMainWindow, kTestSignature, kTransferRateField, FALSE);    return noErr;CantGetControlByID:CantSetControlData:    fprintf(stderr, &quot;Error in setting data for Send Statistics - %d\n&quot;, (int)err);    return err;}OSStatus SetReceiveStatistics(UInt32 packetsReceived, UInt32 PacketsInOrder,                                 UInt32 PacketsOutOfOrder, UInt32 lastPacketReceived){    ControlID  controlID = { kTestSignature, kNumPacketsReceivedField };    ControlRef  control;    UInt32  len;    char  str[16];    OSStatus  err;        err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    len = MyNumToString(packetsReceived, str, kPositive);    // set the control data    err = SetControlData(control, kControlNoPart, kControlStaticTextTextTag, len, str);    require_noerr(err, CantSetControlData);//    fprintf(stderr, &quot;Num Packets received - %d\n&quot;, (int)packetsReceived);    controlID.id = kNumPacketsInOrderField;    err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    len = MyNumToString(PacketsInOrder, str, kPositive);    // set the control data    err = SetControlData(control, kControlNoPart, kControlStaticTextTextTag, len, str);    require_noerr(err, CantSetControlData);//    fprintf(stderr, &quot;Packets in order - %d\n&quot;, (int)PacketsInOrder);    controlID.id = kNumPacketsOutOfOrderField;    err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    len = MyNumToString(PacketsOutOfOrder, str, kPositive);    // set the control data    err = SetControlData(control, kControlNoPart, kControlStaticTextTextTag, len, str);    require_noerr(err, CantSetControlData);//    fprintf(stderr, &quot;Packets out of order - %d\n&quot;, (int)PacketsOutOfOrder);    controlID.id = kLastPacketReceivedField;    err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    len = MyNumToString(lastPacketReceived, str, kPositive);    // set the control data    err = SetControlData(control, kControlNoPart, kControlStaticTextTextTag, len, str);    require_noerr(err, CantSetControlData);//    fprintf(stderr, &quot;Last packet received - %d\n&quot;, (int)lastPacketReceived);    SetControlState(gMainWindow, kTestSignature, kNumPacketsReceivedField, FALSE);    SetControlState(gMainWindow, kTestSignature, kNumPacketsInOrderField, FALSE);    SetControlState(gMainWindow, kTestSignature, kNumPacketsOutOfOrderField, FALSE);    SetControlState(gMainWindow, kTestSignature, kLastPacketReceivedField, FALSE);      return noErr;CantGetControlByID:CantSetControlData:    fprintf(stderr, &quot;Error in setting data for Receive Statistics - %d\n&quot;, (int)err);    return err;}OSStatus SetEnetPopupButton(EnetData *enet, UInt32 itemno){    OSStatus    err;    ControlID    controlID = { kTestSignature, kEnetPopupButton };    ControlRef    control;        err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    CantGetControlByID:    fprintf(stderr, &quot;SetEnetPopupButton: Unable to get a control for the main window - control number %ld.\n&quot;, controlID.id);    return err;}OSStatus LoadMainWindowFromNibFile(IBNibRef gNibRef){    ControlID     controlID = { kTestSignature, kDoTestButton };    EventTypeSpec   connectEvents = { kEventClassControl, kEventControlHit };    EventTypeSpec  popConnectEvents[] = { { kEventClassMenu, kEventMenuTargetItem }, { kEventClassMenu, kEventMenuEndTracking } };    OSStatus    err;    ControlRef    control;  MenuRef      menuRef;        // Create a window. &quot;MainWindow&quot; is the name of the window object. This name is set in     // InterfaceBuilder when the nib is created.    err = CreateWindowFromNib(gNibRef, CFSTR(&quot;MainWindow&quot;), &amp;gMainWindow);    require_noerr(err, CantCreateWindow);    // set up the UPP's for &quot;Do Test&quot; button proc handler    if (gMyDoTestButtonInterceptorUPP == NULL)    {        gMyDoTestButtonInterceptorUPP = NewEventHandlerUPP(MyDoTestButtonInterceptor);    }        // set the &quot;Do Test&quot; button as the default button    controlID.id = kDoTestButton;            err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    SetWindowDefaultButton(gMainWindow, control);    if (gMyDoTestButtonInterceptorUPP != NULL)    {        InstallControlEventHandler(control, gMyDoTestButtonInterceptorUPP, 1, &amp;connectEvents, NULL, NULL);    }  // set up the UPP's for &quot;Cancel Test&quot; button proc handler    if (gMyDoCancelTestButtonInterceptorUPP == NULL)    {        gMyDoCancelTestButtonInterceptorUPP = NewEventHandlerUPP(MyDoCancelTestButtonInterceptor);    }      // set the &quot;Do Test&quot; button as the default button    controlID.id = kCancelTestButton;    err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);  if (gMyDoCancelTestButtonInterceptorUPP != NULL)  {    InstallControlEventHandler(control, gMyDoCancelTestButtonInterceptorUPP, 1, &amp;connectEvents, NULL, NULL);  }      // set up the UPP's for &quot;Send/Receive&quot; button proc handler  if (gMySendRcvButtonInterceptorUPP == NULL)  {  gMySendRcvButtonInterceptorUPP = NewEventHandlerUPP(MySendRcvButtonInterceptor);  }        // set the interceptor for the Send/Receive radio button  controlID.id = kSendReceiveButton;            err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    if (gMySendRcvButtonInterceptorUPP != NULL)    {        InstallControlEventHandler(control, gMySendRcvButtonInterceptorUPP, 1, &amp;connectEvents, NULL, NULL);    }     // set up the UPP's for &quot;Dest Addr is Multicast&quot; radio button  if (gMyDestAddrIsMCastInterceptorUPP == NULL)    {        gMyDestAddrIsMCastInterceptorUPP = NewEventHandlerUPP(MyDestAddrIsMCastInterceptor);    }      // set the interceptor for the &quot;Dest Addr is Multicast&quot; radio button  controlID.id = kDestAddressIsMCast;            err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    if (gMyDestAddrIsMCastInterceptorUPP != NULL)    {        InstallControlEventHandler(control, gMyDestAddrIsMCastInterceptorUPP, 1, &amp;connectEvents, NULL, NULL);    }     // set up the UPP's for &quot;enet popup&quot; button    if (gMyEnetPopupCommandInterceptorUPP == NULL)    {        gMyEnetPopupCommandInterceptorUPP = NewEventHandlerUPP(MyEnetPopupButtonInterceptor);    }        // set the &quot;enet popup&quot; button control handler function    controlID.id = kEnetPopupButton;            err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    if (gMyEnetPopupCommandInterceptorUPP != NULL)    {    menuRef = GetControlPopupMenuHandle(control);        InstallMenuEventHandler(menuRef, gMyEnetPopupCommandInterceptorUPP, 2, (EventTypeSpec*) &amp;popConnectEvents, NULL, NULL);    }        // get the ethernet address data, as well as the bsd name, and an indication whether the item is    // built in.  On return gNumEnetEntries is the number of ethernet entries which were found.    err = GetEthernetAddressInfo((EnetData*)&amp;gedata, &amp;gNumEnetEntries);    if (err != noErr)    {        fprintf(stderr, &quot;an error occured in trying to find ethernet interfaces %ld\n&quot;, err);    }    else if (gNumEnetEntries == 0)    {        fprintf(stderr, &quot;no ethernet interfaces were found.\n&quot;);        err = -1;    }  else  {    AddEnetServicesToPopupMenu((EnetData*) &amp;gedata);  }          SetSAPFieldValue(gSAPAddr);  SetSNAPFieldValue((UInt8*)&amp;gSNAPAddr);    SetStateOfSendReceiveFields();    SetSendStatistics(gNumPacketsToHandle, 0);    // set up the timer proc  gMainLoop = GetMainEventLoop();  gTimerUPP = NewEventLoopTimerUPP(TimerAction);    err = InstallEventLoopTimer(gMainLoop, 1, 1, gTimerUPP, NULL, &amp;gTimerRef);    require_noerr(err, CantInstallTimer);    return err;        CantCreateWindow:    fprintf(stderr, &quot;Unable to create the main.\n&quot;);    return err;CantGetControlByID:    fprintf(stderr, &quot;Unable to get a control for the main window - control number %ld.\n&quot;, controlID.id);    return err;  CantInstallTimer:    fprintf(stderr, &quot;Unable to install timer %ld.\n&quot;, err);    return err;}OSStatusLoadAboutWindowFromNibFile(IBNibRef gNibRef){    OSStatus    err;    ControlID     controlID = { kTestSignature, kAboutAppNameText };    ControlRef    control;    ControlFontStyleRec fontRec;    CFBundleRef    myBundle;    CFDictionaryRef  myDictionary;    CFStringRef   appNameCFString;    CFStringRef   versionCFString;    char      appName[kMaxInputSize];    char      version[kMaxInputSize];        // Then create a window. &quot;gAboutWindow&quot; is the name of the window object. This name is set in     // InterfaceBuilder when the nib is created.    err = CreateWindowFromNib(gNibRef, CFSTR(&quot;AboutWindow&quot;), &amp;gAboutWindow);    require_noerr(err, CantCreateWindow);    myBundle = CFBundleGetMainBundle();    myDictionary = CFBundleGetInfoDictionary(myBundle);    appNameCFString = CFDictionaryGetValue(myDictionary, CFSTR(&quot;CFBundleExecutable&quot;));    versionCFString = CFDictionaryGetValue(myDictionary, CFSTR(&quot;CFBundleVersion&quot;));    CFStringGetCString(appNameCFString, appName, kMaxInputSize, CFStringGetSystemEncoding());    CFStringGetCString(versionCFString, version, kMaxInputSize, CFStringGetSystemEncoding());        GetControlByID(gAboutWindow, &amp;controlID, &amp;control);    fontRec.flags = kControlUseFontMask | kControlUseFaceMask | kControlAddToMetaFontMask | kControlUseJustMask;    fontRec.style = bold;    fontRec.just = teCenter;    fontRec.font = kControlFontBigSystemFont;    SetControlFontStyle(control, &amp;fontRec);    SetControlData(control, kControlNoPart, kControlEditTextTextTag, strlen(appName), appName);        controlID.id = kAboutVersionText;    GetControlByID(gAboutWindow, &amp;controlID, &amp;control);    fontRec.flags = kControlUseFontMask | kControlAddToMetaFontMask | kControlUseJustMask;    fontRec.just = teCenter;    fontRec.font = kControlFontSmallSystemFont;    SetControlFontStyle(control, &amp;fontRec);    SetControlData(control, kControlNoPart, kControlEditTextTextTag, strlen(version), version);CantCreateWindow:    return err;}int EnetAddrToString(MACAddress *eaddr, char *str){    UInt32  i;    UInt32  digit1, digit2, len;    UInt8  *addr = (UInt8*)eaddr;        len = 0;    for (i = 0; i &lt; kIOEthernetAddressSize; i++)    {                digit1 = addr[i];        digit1 = addr[i] / 0x10;        digit2 = addr[i] % 0x10;        if (digit1 &lt; 10)            str[len++] = '0' + digit1;        else            str[len++] = 'A' + (digit1 - 10);        if (digit2 &lt; 10)            str[len++] = '0' + digit2;        else            str[len++] = 'A' + (digit2 - 10);                    if (i + 1 &lt; kIOEthernetAddressSize)            str[len++] = ':';    }    str[len] = 0;    return len;}OSStatus EnetStrToAddr(char *str, MACAddress *eaddr){    UInt32  i;    UInt32  digit1, j;    UInt8  *addr = (UInt8*)eaddr;        i = 0;    memset(eaddr, 0, sizeof(MACAddress));    for (j = 0; j &lt; (3 * kIOEthernetAddressSize - 1); j++)    {        if (((j + 1) % 3) != 0) // do not look at the separator character        {            if (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')                digit1 = str[j] - '0';            else if (str[j] &gt;= 'A' &amp;&amp; str[j] &lt;= 'F')                digit1 = 10 + str[j] - 'A';            else if (str[j] &gt;= 'a' &amp;&amp; str[j] &lt;= 'f')                digit1 = 10 + str[j] - 'a';            else            {                return -1;  // invalid character detected            }            addr[i] = addr[i] * 0x10 + digit1;        }        else // increment the eaddr field assignment character when j equates to the field position            // for the separator character.            i++;    }    return noErr;}OSStatus SetEthernetAddressField(SInt32 id, MACAddress *eaddr){    OSStatus    err;    ControlID    controlID;    ControlRef    control;    char    enetstr[32];    UInt32    len;        controlID.signature = kTestSignature;    controlID.id = id;        err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    len = EnetAddrToString(eaddr, enetstr);    // set the control data    err = SetControlData(control, kControlNoPart, kControlStaticTextTextTag, len, enetstr);    require_noerr(err, CantSetControlData);    return noErr;    CantSetControlData:CantGetControlByID:    fprintf(stderr, &quot;SetEthernetAddressField: error occured in get/set control data\n&quot;);  return err;}OSStatus GetEthernetAddressField(SInt32 id, MACAddress *eaddr){    OSStatus    err;    ControlID    controlID;    ControlRef    control;    char    enetstr[32];    UInt32    len;        controlID.signature = kTestSignature;    controlID.id = id;        err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    require_noerr(err, CantGetControlByID);    err = GetControlData(control, kControlNoPart, kControlEditTextTextTag,                        sizeof(enetstr), enetstr, &amp;len);    require_noerr(err, CantGetControlData);    // force the string to be a &quot;C&quot; style string    enetstr[len] = 0;                            err = EnetStrToAddr(enetstr, eaddr);    require_noerr(err, CantConvertData);    return noErr;CantConvertData:CantGetControlData:CantGetControlByID:    fprintf(stderr, &quot;GetEthernetAddressField: error occured in get/set control data\n&quot;);  return err;}void AddEnetServicesToPopupMenu(EnetData *enetdata){    ControlID     controlID = { kTestSignature, kEnetPopupButton };    ControlRef    control;    CFStringRef    tempEnet = NULL;    char      tempEnetString[256];    MenuRef      menu;    OSStatus    err = noErr;    UInt16      i, enetItem, enetStrLen;      err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);  if (err == noErr)  {    for (enetItem = 0; enetItem &lt; gNumEnetEntries; enetItem++)    {      strcpy(tempEnetString, enetdata[enetItem].bsdName);      enetStrLen = strlen(tempEnetString);                        for (i = 0; i &lt; enetStrLen; i++) tempEnetString[i] = toupper(tempEnetString[i]);      if (enetdata[enetItem].isBuiltIn)        strcat(tempEnetString, &quot; Built-in\0&quot;);                        tempEnet = CFStringCreateWithCString(NULL, tempEnetString, CFStringGetSystemEncoding());            if (tempEnet)            {        menu = GetControlPopupMenuHandle(control);        if (enetItem == 0)        {          // replace the first item          err = SetMenuItemTextWithCFString(menu, 1, tempEnet);                    if (err != noErr)                    {            fprintf(stderr, &quot;Failed to set menu item %d\n&quot;, enetItem);                    }                  }        else        {          // append the menu item                    err = AppendMenuItemTextWithCFString(menu, tempEnet, 0, 0, NULL);                    if (err != noErr)                    {            fprintf(stderr, &quot;Failed to append menu item %d\n&quot;, enetItem);                    }        }        CFRelease(tempEnet);            }        }    SetControlMaximum(control, gNumEnetEntries);    }  else    fprintf(stderr, &quot;Enable to get main window control\n&quot;);}void SetActiveEnetPopupMenu(UInt16 menuItem){    ControlID   controlID = { kTestSignature, kEnetPopupButton };    ControlRef  control;    OSStatus  err;                            err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);    if (err == noErr)    {                SetControlValue(control, menuItem);            }}OSStatus MyEnetPopupButtonInterceptor(EventHandlerCallRef inCallRef, EventRef inEvent, void* inUserData){    OSStatus    err = noErr;    static SInt16   menuItem = 0;  // static item to keep track of recently selected item                  // across calls to this interceptor        switch ( GetEventKind(inEvent) )    {        case kEventMenuTargetItem:            GetEventParameter(inEvent, kEventParamMenuItemIndex, typeMenuItemIndex, NULL, sizeof(typeMenuItemIndex), NULL, &amp;menuItem);            break;        case kEventMenuEndTracking:            if ((menuItem != gCurrPopupEntry) &amp;&amp; (menuItem != 0))            {        if (menuItem &lt;= gNumEnetEntries)        {          gCurrPopupEntry = menuItem;          SetActiveEnetPopupMenu(menuItem);          err = SetStateOfSendReceiveFields();        }            }            break;    }        return err;}/*  SetResults is called after a successful test to put the results into the dialog.  The results are stored in the EnetTestData structure.*/OSStatus SetResults(EnetTestData *testData){    OSStatus  status = noErr;    if (testData-&gt;sendRcvState == kSendTest)    {    // enter send test fields    status = SetSendStatistics(testData-&gt;numPacketsSent, testData-&gt;tdiff);    }    else    {    // enter receive test fields    status = SetReceiveStatistics(testData-&gt;packetsRead, testData-&gt;packetsInOrder,                  testData-&gt;packetsOutOfOrder, testData-&gt;lastPacketNum);                }  return status;}OSStatus MyDoCancelTestButtonInterceptor(EventHandlerCallRef inCallRef, EventRef inEvent, void* inUserData){  OSStatus    err = noErr;    fprintf(stderr, &quot;entered MyDoCancelTestButtonInterceptor\n&quot;);  gEnetTestData-&gt;sendRcvState = kCancelTest;  err = DoEnetTest(gEnetTestData);  // test was for receive test, so set the fields back to the receive state  SetResults(gEnetTestData);  gSendRcvState = kReceiveTest;  SetStateOfSendReceiveFields();    return err;}OSStatus MyDestAddrIsMCastInterceptor(EventHandlerCallRef inCallRef, EventRef inEvent, void* inUserData){    OSStatus    err = noErr;    ControlID    controlID = { kTestSignature, kDestAddressIsMCast };    ControlRef    control;  err = GetControlByID(gMainWindow, &amp;controlID, &amp;control);  require_noerr(err, CantGetControlByID);  // get the state of the Send Receive buttons  gDestAddrIsMCast = GetControlValue(control);  return noErr;  CantGetControlByID:    return err;}OSStatus MyDoTestButtonInterceptor(EventHandlerCallRef inCallRef, EventRef inEvent, void* inUserData){    OSStatus    err = noErr;  // zero out the test memory structure  memset(gEnetTestData, 0, sizeof(*gEnetTestData));  // get the current SAP value setting  err = GetSAPFieldValue(&amp;(gEnetTestData-&gt;sap));    require_noerr(err, CantGetSAPData);    fprintf(stderr, &quot;DSAP value is 0x%X\n&quot;, gEnetTestData-&gt;sap);  // save the current version of the OS  gEnetTestData-&gt;verMacOS = gVerMacOS;    gEnetTestData-&gt;destAddrIsMCast = gDestAddrIsMCast;  // read the current SNAP value if the SAP is 0xAA  if (gEnetTestData-&gt;sap == 0xAA)  {    err = GetSNAPFieldValue((UInt8*)&amp;(gEnetTestData-&gt;snap));    require_noerr(err, CantGetSNAPData);  }    // get the source address to be used    err = GetEthernetAddressField(kSourceAddressField, &amp;(gEnetTestData-&gt;srcaddr));    require_noerr(err, CantGetSourceEthernetAddress);    // get the destination address to be used    err = GetEthernetAddressField(kDestAddressField, &amp;(gEnetTestData-&gt;destaddr));    require_noerr(err, CantGetDestEthernetAddress);    err = GetNumPacketsField(&amp;(gEnetTestData-&gt;numPacketsToSend));    require_noerr(err, CantGetNumPackets);      gEnetTestData-&gt;sendRcvState = gSendRcvState;  // copy the name of the selected enet hw based on the selected popup item    // so that we can do a bind    strcpy(gEnetTestData-&gt;saddr.sa_data, gedata[gCurrPopupEntry-1].bsdName);    fprintf(stderr, &quot;Processing packets on ethernet port %s\n&quot;, gEnetTestData-&gt;saddr.sa_data);    // determine if this is the first time we are using this ethernet device.    // if the device is inactive and is not the built in device, then the first time    // the socket is used, the driver will outbound packets until the link has    // been established.    gEnetTestData-&gt;isFirstTime = FALSE;    if ((gedata[gCurrPopupEntry-1].isBuiltIn == FALSE) &amp;&amp; (gedata[gCurrPopupEntry-1].usedPreviously == FALSE))    {        gedata[gCurrPopupEntry-1].usedPreviously = TRUE;        gEnetTestData-&gt;isFirstTime = TRUE;    }    err = DoEnetTest(gEnetTestData);    if (err)        fprintf (stderr, &quot;error occurred on processing DoEnetTest %ld\n&quot;, err);    else    {    switch (gSendRcvState)    {      case kReceiveTest:        gSendRcvState = kCancelTest;        // by setting the SendRcvState to kCancelTest, the DoTest button is inactivated        // and the Cancel Test button is activated.        SetStateOfSendReceiveFields();        break;              case kSendTest:        gEnetTestData-&gt;tdiff = gEnetTestData-&gt;tend - gEnetTestData-&gt;tbegin;        fprintf(stderr, &quot;sent %ld packets in %ld seconds\n&quot;, gEnetTestData-&gt;numPacketsSent, gEnetTestData-&gt;tdiff);        SetResults(gEnetTestData);        break;          }  }  return noErr;CantGetNumPackets:CantGetDestEthernetAddress:CantGetSourceEthernetAddress:CantGetSAPData:CantGetSNAPData:    return noErr;}OSStatus MySendRcvButtonInterceptor(EventHandlerCallRef inCallRef, EventRef inEvent, void* inUserData){    OSStatus    err = noErr;        err = SetStateOfSendReceiveFields();    return err;}OSStatus MyAppCommandInterceptor(EventHandlerCallRef inCallRef, EventRef inEvent, void* inUserData){    HICommand   theCommand;    OSStatus   status = noErr;        status = GetEventParameter(inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof(HICommand), NULL, &amp;theCommand);  if (status)    return status;    switch (theCommand.commandID)    {        case kHICommandAbout:            if ( MacIsWindowVisible(gAboutWindow) == false )            {                if ( LoadAboutWindowFromNibFile(gNibRef) == noErr)                {                    RepositionWindow(gAboutWindow, NULL, kWindowCenterOnMainScreen);                    BringToFront(gAboutWindow);                    ShowWindow(gAboutWindow);                }            }            else            {                ActivateWindow(gAboutWindow, true);                BringToFront(gAboutWindow);            }            break;                    default:            status = CallNextEventHandler(inCallRef, inEvent);            break;    }    return status;}void DisposeUPPs(){  if (gMyDestAddrIsMCastInterceptorUPP)  {    DisposeEventHandlerUPP(gMyDestAddrIsMCastInterceptorUPP);    gMyDestAddrIsMCastInterceptorUPP = NULL;  }  if (gMyDoTestButtonInterceptorUPP)    {      DisposeEventHandlerUPP(gMyDoTestButtonInterceptorUPP);    gMyDoTestButtonInterceptorUPP = NULL;  }  if (gMyEnetPopupCommandInterceptorUPP)  {        DisposeEventHandlerUPP(gMyEnetPopupCommandInterceptorUPP);    gMyEnetPopupCommandInterceptorUPP = NULL;  }  if (gMyDoCancelTestButtonInterceptorUPP)  {        DisposeEventHandlerUPP(gMyDoCancelTestButtonInterceptorUPP);    gMyDoCancelTestButtonInterceptorUPP = NULL;  }  if (gMySendRcvButtonInterceptorUPP)      {    DisposeEventHandlerUPP(gMySendRcvButtonInterceptorUPP);    gMySendRcvButtonInterceptorUPP = NULL;  }  if (gMyAppCommandInterceptorUPP)  {    DisposeEventHandlerUPP(gMyAppCommandInterceptorUPP);    gMyAppCommandInterceptorUPP = NULL;  }}int main (void){    OSStatus    err;    EventTypeSpec   commandEvents = { kEventClassCommand, kEventProcessCommand };    // This simply launches the 'Console.app' to show the output from this program.  LSOpenCFURLRef(CFURLCreateWithString(NULL, CFSTR(&quot;/var/tmp/console.log&quot;), NULL), NULL);  Initialize();                             // Create a Nib reference passing the name of the nib file (without the .nib extension)    // CreateNibReference only searches into the application bundle.    err = CreateNibReference(CFSTR(&quot;BSDLLCTest&quot;), &amp;gNibRef);    require_noerr(err, CantGetNibRef);    // Once the nib reference is created, set the menu bar. &quot;MainMenu&quot; is the name of the menu bar    // object. This name is set in InterfaceBuilder when the nib is created.    err = SetMenuBarFromNib(gNibRef, CFSTR(&quot;MainMenu&quot;));    require_noerr(err, CantSetMenuBar);    if (gMyAppCommandInterceptorUPP == NULL)    {        gMyAppCommandInterceptorUPP = NewEventHandlerUPP(MyAppCommandInterceptor);    }        if (gMyAppCommandInterceptorUPP != NULL)    {        // I'm only using this for the About Box.        InstallApplicationEventHandler(gMyAppCommandInterceptorUPP, 1, &amp;commandEvents, NULL, NULL);    }    err = LoadMainWindowFromNibFile(gNibRef);    require_noerr(err, CantCreateWindow);        InitCursor();        // The window was created hidden so show it.    RepositionWindow(gMainWindow, NULL, kWindowCenterOnMainScreen);    ShowWindow(gMainWindow);        // Call the event loop    RunApplicationEventLoop();    // stop the event timer  RemoveEventLoopTimer(gTimerRef);        // We don't need the nib reference anymore.    DisposeNibReference(gNibRef);    DisposeUPPs();            fprintf(stderr, &quot;\nProgram ended\n&quot;);    return 0;CantCreateWindow:CantSetMenuBar:CantGetNibRef:    fprintf(stderr, &quot;\nProgram ended\n&quot;);    return err;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/BSDLLCTest/listing1.html%3Fid%3DDTS10000692-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/BSDLLCTest/listing1.html%3Fid%3DDTS10000692-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/BSDLLCTest/listing1.html%3Fid%3DDTS10000692-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>