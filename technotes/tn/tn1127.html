<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1127: In Search of Missing Links</title>    <meta name="keywords" content="Mac OS 8 InterfaceLib glue code missing API links A-traps">    <meta name="Description" content="Technical Note TN1127: This Technical Note demonstrates howto write CFM glue code, which can      call classic 68K A-Traproutines. Which would allow application developers to callAPIs not implemented in InterfaceLib. Numerous examples ofglue code which replaces the missing APIs are provided. Adiscussion on register based, register dispatched, and stackdispatched A-traps is also provided.">    <meta name="categories" content="Runtime Architecture"><meta name="week-posted" content="Apr 27, 1998 - May 1, 1998"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002967" title="In Search of Missing Links"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxRuntimeArchitecture-date.html">Runtime Architecture</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1127</div>
<div id="pageheadsub">In Search of Missing Links</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><center><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">          <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><P id = "menutext"><A HREF = "#Problem">The Problem: Missing routines</A><br><br>        <A HREF = "#Solution">The Solution: Glue them in.</A><br><br>        <A HREF = "#Simple_Examples">Simple Examples</A><br><br>        <A HREF = "#Regisiter_Based_ATraps">Register-Based A-Traps</A><br><br>        <A HREF = "#Register_Dispatched_ATraps">Register-Dispatched A-Traps</A><br><br>        <A HREF = "#Stack_Dispatched_ATraps">Stack-Dispatched A-Traps</A><br><br>        <A HREF = "#Real_Examples">Some Real Examples</A><br><br>        <A HREF = "#HFSPlus">Full Example: HFS+</A><br><br>        <A HREF = "#ControlStrip">Full Example: ControlStrip</A><br><br>        <A HREF = "#Power_Manager">Full Example: Power Manager</A><br><br>        <A HREF = "#Summary">Summary</A><BR><BR><A HREF = "#References">References</a><BR><BR><A HREF="#Downloads">Downloadables</A></p>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left>            			<!-- begin_intro_text --><p  id = "introtext">They're everywhere: Missing Links! If you are writing a CFM  application and want to call <CODE>FlushCodeCacheRange</CODE>, show and hide the control strip, or use the Cursor Device Manager,  you will run into the same problem: missing links. These Application Programming Interfaces (API's) haven't been  implemented in <CODE>InterfaceLib</CODE>. So what do you do? Well that's what this Technote is about--fixing missing links. It's  the sequel to <A HREF = "tn1077.html">Technote 1077</A> on calling CFM routines from classic 68K applications. This Technote demonstrates how  to write CFM glue code, which can call classic 68K A-Trap routines.</P> <p  id = "introtext">This Technote is of interest to developers attempting  to use the classic 68K API's currently missing from <CODE>InterfaceLib</CODE>.</P><CENTER><TABLE BORDER=0 WIDTH=300><TR><td bgcolor="#E6E6E6" align=left><p  id = "introtext"><B>IMPORTANT:</B><BR>WARNING: This is an advanced topic for use by developers  who can't continue development because of these missing API's. Even as this Technote is being published, efforts are being made  to identify the missing links and get them added to <CODE>InterfaceLib</CODE>.</P></TD></TR></TABLE></CENTER> <!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [May 4 1998]</h3><!-- end_date -->        </td>    </tr></table> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><A NAME="Problem"></A>        <h2>The Problem: Missing routines</H2>  <P>Some classic 68K API's are missing from PowerPC &amp; CFM-68K <CODE>InterfaceLib</CODE>. Calling these routines from CFM code will generate "Unresolved Symbol" errors when you link your program.</p><BR><P><A HREF="#top">Back to top</A></P>     <A NAME="Solution"></A><H2>The Solution: Glue Them In</h2>  <P>This Technote provides a temporary solution by showing how to create glue code which you can include with your program. You need to write one glue routine for each missing API. Each of these routines determines the address of the 68K A-Trap and then calls it via <CODE>CallUniversalProc</CODE> or <CODE>CallOSTrapUniversalProc</CODE> with the appropriate parameters. If in the future a new <CODE>InterfaceLib</CODE> file is released that includes the missing API's, your project can be rebuilt without the glue file.</p><BR><P><A HREF="#top">Back to top</A></P>    <A NAME="Simple_Examples"></A><H2>Some (Very) Simple Examples</h2> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The following four API's are not missing from <CODE>InterfaceLib</CODE>. They were selected in order to provide simple examples.</P></TD></TR></TABLE></CENTER><BR><BR> <P>Here is <CODE>InitWindows</CODE>, <CODE>SelectWindow</CODE>, <CODE>FrontWindow</CODE> &amp; <CODE>CheckUpdate</CODE> from &lt;MacWindows.h&gt;.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern pascal void InitWindows(void)    ONEWORDINLINE(0xA912);&nbsp;extern pascal void SelectWindow(WindowPtr's theWindow)    ONEWORDINLINE(0xA91F);&nbsp;extern pascal WindowPtr FrontWindow(void)    ONEWORDINLINE(0xA924);&nbsp;extern pascal Boolean CheckUpdate(EventRecord *theEvent)    ONEWORDINLINE(0xA911);</pre></TD></TR></TABLE></CENTER><BR><BR> <P>For <CODE>InitWindows</CODE>, all you only need to <CODE>CallUniversalProc</CODE> with the address of the A-Trap and the Pascal <CODE>ProcInfo</CODE>, like this:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal void InitWindows(void)// ONEWORDINLINE(0xA912);{    CallUniversalProc(GetToolboxTrapAddress(0xA912),        kPascalStackBased);}</pre></TD></TR></TABLE></CENTER><BR><BR><P>That was not too hard. Just in case you don't know where the value <CODE>0xA912</CODE> came from for the <CODE>GetToolboxTrapAddress</CODE> call, it's in the <CODE>ONEWORDINLINE</CODE> macro. You could also have looked it up in &lt;Traps.h&gt;. OK? This time we will pass in a parameter:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern pascal void SelectWindow(WindowPtr theWindow)// ONEWORDINLINE(0xA91F);{    CallUniversalProc(GetToolboxTrapAddress(0xA91F),        kPascalStackBased |            STACK_ROUTINE_PARAMETER(1,SIZE_CODE(sizeof(WindowPtr))),        theWindow    // the parameter    );}</pre></TD></TR></TABLE></CENTER><BR><BR><P>Nothing complicated here--we added the<CODE>STACK_ROUTINE_PARAMETER</CODE> macro to the <CODE>procinfo</CODE> and theparameter.  Let's try returning a value:</p> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern pascal WindowPtr FrontWindow(void)// ONEWORDINLINE(0xA924);{    return (WindowPtr) CallUniversalProc(        GetToolboxTrapAddress(0xA924),        kPascalStackBased |            RESULT_SIZE(SIZE_CODE(sizeof(WindowPtr)))    );}</pre></TD></TR></TABLE></CENTER><BR><BR> <P>This one uses the <CODE>RESULT_SIZE</CODE> macro to define the size of the result on the stack. Notice that we had to typecast the long returned by <CODE>CallUniversalProc</CODE> to a <CODE>WindowPtr</CODE>. Now, we can combine what we have learned. Here is an API that has single parameter and returns a result:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern pascal Boolean CheckUpdate(EventRecord *theEvent)// ONEWORDINLINE(0xA911);{    return (Boolean) CallUniversalProc(        GetToolboxTrapAddress(0xA911),        kPascalStackBased |            RESULT_SIZE(SIZE_CODE(sizeof(Boolean))) |            STACK_ROUTINE_PARAMETER(1,SIZE_CODE(sizeof(EventRecord*)))    );}</pre></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P><A NAME="Regisiter_Based_ATraps"></A><h2>Register-Based A-Traps:</h2>        <P>Operating system A-Traps pass their parameters in         registers. Apple recently introduced the <CODE>PBXGetVolInfo</CODE> (note         the <I>X</I> in <I>PBX</I>) A-Trap, which acts like <CODE>PBGetVolInfo</CODE>, but         supports returning information about the new large volumes.         Here's how you can call it from CFM:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// WARNING: Don't use this code - read rest of section!//#pragma parameter __D0 PBXGetVolInfoSync(__A0)pascal OSErr PBXGetVolInfoSync(XVolumeParamPtr paramBlock)// TWOWORDINLINE(0x7012, 0xA060);{    return (OSErr) CallOSTrapUniversalProc(        (UniversalProcPtr) GetOSTrapAddress(0xA060),        kRegisterBased |            RESULT_SIZE(SIZE_CODE(sizeof(OSErr))) |            REGISTER_RESULT_LOCATION(kRegisterD0) |            REGISTER_ROUTINE_PARAMETER(1, kRegisterD0,                kTwoByteCode) |    // selector            REGISTER_ROUTINE_PARAMETER(2, kRegisterA0,                SIZE_CODE(sizeof(XVolumeParamPtr*))),        0x0012,    // selector        paramBlock);    // parameter(s)}// WARNING: Don't use this code - read rest of section!</pre></TD></TR></TABLE></CENTER><BR><BR> <P>The first thing to notice is that we're using <code>CallOSTrapUniversalProc</code> instead of <code>CallUniversalProc</code>. The <CODE>CallOSTrapUniversalProc</CODE> function executes the routine associated with the specified universal procedure pointer, following standard conventions for executing OS A-Traps. Registers A1, A2, D1, and D2 are saved before the routine is executed and restored after its completion; in addition, register A0 is saved and restored, depending on the setting of the appropriate flag bit in the trap word.</P>  <P>How did we determine the selector (<CODE>0x0012</CODE>)? If you disassemble the <CODE>TWOWORDINLINE</CODE> hexcodes in MacsBug, you should get this:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>MacsBug&gt; dh 7012 A060    MOVEQ    #$12,D0    _FSDispatch</pre></TD></TR></TABLE></CENTER><BR><BR> <P>Just in case you're confused, we are copying the API and the <CODE>xWORDINLINE</CODE> information directly out of Universal Interfaces. In this case the <CODE>pragma</CODE> parameter tells what registers are used where (<CODE>OSErr</CODE> result in D0 and <CODE>XVolumeParamPtr</CODE> parameter in A0). Just like in the previous cases, disassembling the <CODE>xWORDINLINE</CODE> macro gives the selector information and the A-Trap. There isn't a <CODE>kD0DispatchedRegisterBased</CODE> <CODE>ProcInfo</CODE>-calling convention so we have to treat the D0 selector like another register-based parameter.</P>  <P>Notice that I'm using <CODE>GetOSTrapAddress</CODE> instead of <CODE>GetToolboxTrapAddress</CODE>. This brings up another issue. Some of the OS A-Traps pass flags in bits 9 &amp; 10 of the A-Trap. For example look at <CODE>NewPtr</CODE>:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    _NewPtr = 0xA11E    _NewPtrSys  = 0xA51E    _NewPtrClear= 0xA31E    _NewPtrSysClear = 0xA71E</pre></TD></TR></TABLE></CENTER><BR><BR><P>You can tell that bit 9 is the 'Sys' bit and bit 10 is the 'Clear' bit. These four A-Traps are dispatched through a single dispatcher that uses these flag bits to determine which routine to call. Guess what? The A-Trap for <CODE>PBXGetVolInfoSync</CODE> (<CODE>0xA060</CODE>) is one of these:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    _FSDispatch      = 0xA060    _HFSDispatch     = 0xA260    _FSDispatchAsync  = 0xA460    _HFSDispatchAsync = 0xA660</pre></TD></TR></TABLE></CENTER><BR><BR><P> See <a href="../../documentation/mac/OSUtilities/OSUtilities-170.html">Inside Macintosh: Operating Systems Utilities </A>for more information on the Trap Manager.</p><P>So how does the A-Trap dispatcher know what A-Trap invoked it? It's passed to the dispatcher in register D1. So to fix out <CODE>PBXGetVolInfoSync</CODE> glue above we need to add another parameter to tell the Mixed Mode Manager to pass the A-Trap in register D1.</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The order here is critical! If CFM glue is calling a trap that has been patched with CFM code and the <CODE>ProcInfo</CODE> parameter order isn't the same, then the patch will be called with the original order of parameters. The canonical ordering is selector (if required), then D1 (the A-Trap), then the parameters in the order that they appear in the high-level language prototype.</P></TD></TR></TABLE></CENTER><BR><BR> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal OSErr PBXGetVolInfoSync(XVolumeParamPtr paramBlock)// TWOWORDINLINE(0x7012, 0xA060);{    return (OSErr) CallOSTrapUniversalProc (        (UniversalProcPtr) GetOSTrapAddress(0xA060),        kRegisterBased |            RESULT_SIZE(SIZE_CODE(sizeof(OSErr))) |            REGISTER_RESULT_LOCATION(kRegisterD0) |            REGISTER_ROUTINE_PARAMETER(1, kRegisterD0,                kTwoByteCode) |    // selector            REGISTER_ROUTINE_PARAMETER(2, kRegisterD1,                kTwoByteCode) |    // A-Trap            REGISTER_ROUTINE_PARAMETER(3, kRegisterA0,                SIZE_CODE(sizeof(XVolumeParamPtr*))),        0x0012,        // selector        0xA060,        // A-Trap        paramBlock);    // parameter(s)}</pre></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P><A NAME="Register_Dispatched_ATraps"></A><h2>Register-Dispatched A-Traps:</h2><P>Register-dispatched A-Traps require a selector passedether register D0 or D1. Here's an AppleGuide API that untilrecently was missing from the CFM-68K <CODE>InterfaceLib</CODE>:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal AGErr AGGeneral(AGRefNum refNum, AGEvent theEvent)// TWOWORDINLINE(0x700D, 0xAA6E);{    return (AGErr) CallUniversalProc(GetToolboxTrapAddress(0xAA6E),        kD0DispatchedPascalStackBased |            RESULT_SIZE(SIZE_CODE(sizeof(AGErr))) |            DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode) |            DISPATCHED_STACK_ROUTINE_PARAMETER(1,                SIZE_CODE(sizeof(refNum))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(2,                SIZE_CODE(sizeof(theEvent))),        0x000D,        // selector -&gt; D0        refNum,theEvent    // the parameters    );}</pre></TD></TR></TABLE></CENTER><BR><BR><P>The first thing to notice about this code is the selector (<CODE>0x0012</CODE>). You should remember how to get its value from MacsBug using the values from the <CODE>TWOWORDINLINE</CODE> macro:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>MacsBug&gt; dh 700D AA6E    MOVEQ    #$0D,D0    _AGGeneral</pre></TD></TR></TABLE></CENTER><BR><BR><P>This gives us a clue to determine that this API is D0-dispatched. Now, how do we determine the correct value touse for the <CODE>DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE</CODE>? Anotherquick trip back to MacsBug can give us a list of the API'sdispatched through the <CODE>_AppleGuideDispatch</CODE> A-Trap:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>MacsBug&gt; api AA6E&nbsp;    &#176; AA6E _AppleGuideDispatch        DO.W=0001        AGOpen        DO.W=0002        AGOpenWithSearch        DO.W=0003        AGOpenWithSequence        &lt;...&gt;</pre></TD></TR></TABLE></CENTER><BR><BR><P>From this we can determine that the selector is in factword-based; therefore, we know to use the <CODE>kTwoByteCode</CODE> valuefor the <code>DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE</code>.</p><BR><P><A HREF="#top">Back to top</A></P><A NAME="Stack_Dispatched_ATraps"></A><h2>Stack-Dispatched A-Traps:</h2><P>Stack-dispatched A-Traps require a selector passed in onthe stack. While <CODE>TEGetPoint</CODE> isn't missing from <CODE>InterfaceLib</CODE>,we are going to borrow it to show one of those pitfalls.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// WARNING: Don't use this code - read paragraph belowstatic Point TEGetPoint(short offset,TEHandle hTE){// THREEWORDINLINE(0x3F3C, 0x0008, 0xA83D);// MOVE.W    #$0008,-(A7)//        _TEDispatch// _TEGetPoint is A83D (_TEDispatch) when A7^.W=0008    return (Point) CallUniversalProc(        GetToolboxTrapAddress(_TEDispatch),    // address of dispatcher        kStackDispatchedPascalStackBased |        // proc info            RESULT_SIZE(SIZE_CODE(sizeof(Point))) |            DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode) |            DISPATCHED_STACK_ROUTINE_PARAMETER(1,                SIZE_CODE(sizeof(short))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(2,                SIZE_CODE(sizeof(TEHandle))),        0x0008,    // selector -&gt; stack        offset, hTE    // parameter(s)    );}// WARNING: Don't use this code - read paragraph below</pre></TD></TR></TABLE></CENTER><BR><BR><P>This time the selector was passed in as a word on thestack. Does everything make sense? Almost. This was a trickquestion to catch anyone thinking they just could skip aheadto the tough ones. In this case, the <CODE>TEGetPoint</CODE> returns aPoint. No problem--we'll just typecast it, right? Try it.Oops, Houston, we have a problem. The compiler complains:"Error: illegal explicit conversion from 'long' to 'structPoint'." To avoid this, we have to store the results in a localvariable and typecast its address as a pointer to a Point.We then de-reference this to get the correct results, likethis:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static Point TEGetPoint(short offset,TEHandle hTE){// THREEWORDINLINE(0x3F3C, 0x0008, 0xA83D);// MOVE.W    #$0008,-(A7)//        _TEDispatch// _TEGetPoint is A83D (_TEDispatch) when A7^.W=0008    long private_results = CallUniversalProc(        GetToolboxTrapAddress(_TEDispatch),    // address of dispatcher        kStackDispatchedPascalStackBased |    // proc info            RESULT_SIZE(SIZE_CODE(sizeof(Point))) |            DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode) |            DISPATCHED_STACK_ROUTINE_PARAMETER(1,                SIZE_CODE(sizeof(short))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(2,                SIZE_CODE(sizeof(TEHandle))),        0x0008,        // selector        offset, hTE    // parameter(s)    );    return *(Point*) &amp;private_results;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>This is all well and good if the structure is four bytes insize. What would happen if it were smaller? Try thisexample:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct CryptoCharsRecord {    char    findChar;    char    replaceChar;} CryptoCharsRec, *CryptoCharsPtr, **CryptoCharsHdl;</pre></TD></TR></TABLE></CENTER><BR><BR><P>If this structure was to be returned from <CODE>CallUniversalProc</CODE>and stored into our long result, it would look like this(remember that the Mac OS stores the high bytes first and the low bytes last):</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>+---------------------------+Low Mem | 0 | &lt;-- Address of private_result+---------------------------+| 1 |+---------------------------+| 2 |    findChar+---------------------------+High Mem| 3 |    replaceChar+---------------------------+</pre></TD></TR></TABLE></CENTER><BR><BR><P>In this case, neither the simple typecast nor thedereferenced-pointer typecast will work. What we have to dois dereference the address of our result, plus an offset tothe high word.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal CryptoCharsRec GetEncodeKey(char* pThePassword){    long private_results = CallUniversalProc(        GetToolboxTrapAddress(0xAxxx),        kPascalStackBased |            RESULT_SIZE(SIZE_CODE(sizeof(Boolean))) |            STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(EventRecord*)))        theEvent    // the parameter    );    return *(((CryptoCharsRec*)&amp;private_result) + 1);}</pre></TD></TR></TABLE></CENTER><BR><BR> <P>At first glance, you might think that the offset should be two, but remember that in this case it's not a byte offset, it is an offset for a two-byte structure. C knows this and internally adds two instead of one. It's really easy to miscompute this offset, so here's a macro that will compute it for you given a variable or variable type:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#define RESULT_OFFSET(type) \    ((sizeof(type) == 1) ? 3 : ((sizeof(type) == 2) ? 1 : 0))</pre></TD></TR></TABLE></CENTER><BR><BR><P>There's nothing complicated here. If the size of the structure isone then the offset to the high byte is three (bytes). Ifthe size of the structure is two, then the offset to the highword is one (word); otherwise, the offset is zero. It's usedlike this:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal CryptoCharsRec Get_Encode_Key(char* pThePassword){    long private_results = CallUniversalProc(        GetToolboxTrapAddress(0xA911),        kPascalStackBased |            RESULT_SIZE(SIZE_CODE(sizeof(Boolean))) |            STACK_ROUTINE_PARAMETER(1,                SIZE_CODE(sizeof(EventRecord*)))        theEvent    // the parameter    );    return *(((CryptoCharsRec*)&amp;private_result) +        RESULT_OFFSET(CryptoCharsRec));}</pre></TD></TR></TABLE></CENTER><BR><BR><P>Is this clear? So what happens if our result is larger than fourbytes? If this is the case then <CODE>CallUniversalProc</CODE> can't beused to call the routine. Some of the (machine-generated)glue code I've seen includes this code to test for resultsizes larger than what can be handled by <CODE>CallUniversalProc</CODE>:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#ifdef applec    #if sizeof(OSErr) &gt; 4        #error "Result types larger than 4 bytes are not supported."    #endif#endif</pre></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P><A NAME="Real_Examples"></A><h2>Some Real Examples:</h2> <P>Let's take a look at some API's actually missing from<CODE>InterfaceLib</CODE>. Here's one from the cursor device manager:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal OSErr CursorDeviceMoveTo(CursorDevicePtr ourDevice, long absX, long absY){//    TWOWORDINLINE(0x7001, 0xAADB);//    MOVEQ    #$01,D0        | 7001//    _CursorDeviceDispatch    | AADB    return (OSErr) CallUniversalProc(        (UniversalProcPtr)GetToolboxTrapAddress(0xAADB),        kD0DispatchedPascalStackBased |        RESULT_SIZE(SIZE_CODE(sizeof(OSErr))) |        DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kFourByteCode) |        DISPATCHED_STACK_ROUTINE_PARAMETER(1,            SIZE_CODE(sizeof(ourDevice))) |        DISPATCHED_STACK_ROUTINE_PARAMETER(2,            SIZE_CODE(sizeof(absX))) |        DISPATCHED_STACK_ROUTINE_PARAMETER(3,            SIZE_CODE(sizeof(absY))),    0x00000001,                // selector    ourDevice, absX, absY);    // parameter(s)}</pre></TD></TR></TABLE></CENTER><BR><BR> <P>Now one missing from the <CODE>OSUtils.h</CODE>:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static pascal OSErr FlushCodeCacheRange(void *address, unsigned long count){//  TWOWORDINLINE(0x7009, 0xA098);//  MOVEQ  #$09,D0| 7009//  _HWPriv  | A098    return (OSErr) CallOSTrapUniversalProc(        GetOSTrapAddress(_HWPriv),        kRegisterBased            | RESULT_SIZE (SIZE_CODE (sizeof (OSErr)))            | REGISTER_RESULT_LOCATION (kRegisterD0)            | REGISTER_ROUTINE_PARAMETER(1,kRegisterA0,                SIZE_CODE(sizeof(address)))            | REGISTER_ROUTINE_PARAMETER(2,kRegisterA1,                SIZE_CODE(sizeof(count)))        address,count);    // parameter(s)}</pre></TD></TR></TABLE></CENTER><BR><BR> <P>The following API is missing from both <CODE>InterfaceLib</CODE> &amp; the headers! (Bonus for reading this far!)</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResult TVSetFrequency(TVTunerComponent ci, long frequency)//FIVEWORDINLINE(0x2F3C, 0x04, kSelectTVSetFrequency, 0x7000, 0xA82A);//        MOVE.L    #$00040001,-(A7)//        MOVEQ    #$00,D0//        _ComponentDispatch{    return (ComponentResult) CallUniversalProc(        (UniversalProcPtr) GetToolboxTrapAddress(0xA82A),        kD0DispatchedPascalStackBased |            RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult))) |            DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode) |            DISPATCHED_STACK_ROUTINE_PARAMETER( 1,                SIZE_CODE(sizeof(TVTunerComponent))) |            DISPATCHED_STACK_ROUTINE_PARAMETER( 2,                SIZE_CODE(sizeof(long))) |            DISPATCHED_STACK_ROUTINE_PARAMETER( 3,                SIZE_CODE(sizeof(long))),        0x0000,        // D0 selector        ci, frequency,    // parameter(s)        0x00040001);    // Stack dispatched selector}</pre></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P><A NAME="HFSPlus"></A><H2>Full Example: HFS+</H2><P>Here I present a complete glue file for the eXtended <CODE>DiskInit</CODE> routines for HFS+:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/*    File:        DiskInit.Glue.c&nbsp;    Copyright:    &copy; 1984-1997 by Apple Computer, Inc.                All rights reserved.*/&nbsp;#include &lt;DiskInit.h&gt;#include &lt;MixedMode.h&gt;&nbsp;static UniversalProcPtr gPack2TrapUPP = kUnresolvedCFragSymbolAddress;static UniversalProcPtr gUnimplementedUPP = kUnresolvedCFragSymbolAddress;&nbsp;pascal OSErr DIXFormat(short drvNum, Boolean fmtFlag,                unsigned long fmtArg, unsigned long *actSize)// THREEWORDINLINE(0x700C, 0x3F00, 0xA9E9);//        MOVEQ    #$0C,D0    | 700C//        MOVE.W    D0,-(A7)    | 3F00//        _Pack2            | A9E9{    long    private_result = unimpErr;    // assume unimplemented A-Trap&nbsp;    if ((Ptr) gUnimplementedUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gUnimplementedUPP = GetToolboxTrapAddress(_Unimplemented);&nbsp;    if ((Ptr) gPack2TrapUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gPack2TrapUPP = GetToolboxTrapAddress(0xA9E9);&nbsp;    if ((Ptr) gPack2TrapUPP != (Ptr) gUnimplementedUPP)    {    private_result = CallUniversalProc(gPack2TrapUPP,        kStackDispatchedPascalStackBased |            RESULT_SIZE(SIZE_CODE(sizeof(OSErr))) |            DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode) |            DISPATCHED_STACK_ROUTINE_PARAMETER(1,                SIZE_CODE(sizeof(short))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(2,                SIZE_CODE(sizeof(Boolean))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(3,                SIZE_CODE(sizeof(unsigned long))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(4,                SIZE_CODE(sizeof(unsigned long))),        0x000C,                // selector        drvNum, fmtFlag, fmtArg, actSize);    // parameter(s)    }    return (OSErr) private_result;}&nbsp;pascal OSErr DIXZero(short drvNum, ConstStr255Param volName,    short fsid, short mediaStatus, short volTypeSelector,    unsigned long volSize, void *extendedInfoPtr)// THREEWORDINLINE(0x700E, 0x3F00, 0xA9E9);//        MOVEQ    #$0E,D0        | 700E//        MOVE.W    D0,-(A7)    | 3F00//        _Pack2                | A9E9{    long    private_result = unimpErr;    // assume unimplemented A-Trap&nbsp;    if ((Ptr) gUnimplementedUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gUnimplementedUPP = GetToolboxTrapAddress(_Unimplemented);&nbsp;    if ((Ptr) gPack2TrapUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gPack2TrapUPP = GetToolboxTrapAddress(0xA9E9);&nbsp;    if ((Ptr) gPack2TrapUPP != (Ptr) gUnimplementedUPP)    {    private_result = CallUniversalProc(gPack2TrapUPP,        kStackDispatchedPascalStackBased |            RESULT_SIZE(SIZE_CODE(sizeof(OSErr))) |            DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode) |            DISPATCHED_STACK_ROUTINE_PARAMETER(1,                SIZE_CODE(sizeof(short))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(2,                SIZE_CODE(sizeof(ConstStr255Param))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(3,                SIZE_CODE(sizeof(short))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(4,                SIZE_CODE(sizeof(short))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(5,                SIZE_CODE(sizeof(short))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(6,                SIZE_CODE(sizeof(unsigned long))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(7,                SIZE_CODE(sizeof(void *))),        0x000E,                        // selector        drvNum, volName, fsid, mediaStatus,        // parameter(s)        volTypeSelector, volSize, extendedInfoPtr);    }    return (OSErr) private_result;}&nbsp;pascal OSErr DIReformat(short drvNum, short fsid,                ConstStr255Param volName, ConstStr255Param msgText)// THREEWORDINLINE(0x7010, 0x3F00, 0xA9E9);//        MOVEQ    #$10,D0        | 7010//        MOVE.W    D0,-(A7)    | 3F00//        _Pack2                | A9E9{    long    private_result = unimpErr;    // assume unimplemented A-Trap&nbsp;    if ((Ptr) gUnimplementedUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gUnimplementedUPP = GetToolboxTrapAddress(_Unimplemented);&nbsp;    if ((Ptr) gPack2TrapUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gPack2TrapUPP = GetToolboxTrapAddress(0xA9E9);&nbsp;    if ((Ptr) gPack2TrapUPP != (Ptr) gUnimplementedUPP)    {    private_result = CallUniversalProc(gPack2TrapUPP,        kStackDispatchedPascalStackBased |            RESULT_SIZE(SIZE_CODE(sizeof(OSErr))) |            DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode) |            DISPATCHED_STACK_ROUTINE_PARAMETER(1,                SIZE_CODE(sizeof(short))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(2,                SIZE_CODE(sizeof(short))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(3,                SIZE_CODE(sizeof(ConstStr255Param))) |            DISPATCHED_STACK_ROUTINE_PARAMETER(4,                SIZE_CODE(sizeof(ConstStr255Param))),        0x0010,                // selector        drvNum, fsid, volName, msgText);    // parameter(s)    }    return (OSErr) private_result;}</pre></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P><A NAME="ControlStrip"></A><H2>Full Example: ControlStrip</H2><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/*     File:        ControlStrip.Glue.c     Copyright:    &copy; 1984-1997 by Apple Computer, Inc.                 All rights reserved.*/&nbsp;#include &lt;MixedMode.h&gt;#include &lt;ControlStrip.h&gt;&nbsp;static UniversalProcPtr gControlStripTrapUPP = kUnresolvedCFragSymbolAddress;static UniversalProcPtr gUnimplementedUPP = kUnresolvedCFragSymbolAddress;&nbsp;#define _ControlStripDispatch 0xAAF2&nbsp;pascal Boolean SBIsControlStripVisible(void)// TWOWORDINLINE(0x7000, 0xAAF2);//    MOVEQ    #$00,D0//    _ControlStripDispatch{    long    private_result = 0L;&nbsp;    if ((Ptr) gUnimplementedUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gUnimplementedUPP =            GetToolboxTrapAddress(_Unimplemented);&nbsp;    if ((Ptr) gControlStripTrapUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gControlStripTrapUPP =            GetToolboxTrapAddress(_ControlStripDispatch);&nbsp;    if ((Ptr) gControlStripTrapUPP != (Ptr) gUnimplementedUPP)    {        private_result = CallUniversalProc(gControlStripTrapUPP,            kD0DispatchedPascalStackBased |                DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode) |                RESULT_SIZE(SIZE_CODE(sizeof(Boolean))),            0x0000);    // selector    }    return (Boolean) private_result;}&nbsp;pascal void SBShowHideControlStrip(Boolean showIt)// THREEWORDINLINE(0x303C, 0x0101, 0xAAF2);//    MOVE.W    #$0101,D0//    _ControlStripDispatch{    if ((Ptr) gUnimplementedUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gUnimplementedUPP = GetToolboxTrapAddress(_Unimplemented);&nbsp;    if ((Ptr) gControlStripTrapUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gControlStripTrapUPP = GetToolboxTrapAddress(_ControlStripDispatch);&nbsp;    if ((Ptr) gControlStripTrapUPP != (Ptr) gUnimplementedUPP)    {        CallUniversalProc(gControlStripTrapUPP,            kD0DispatchedPascalStackBased |            DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode) |            DISPATCHED_STACK_ROUTINE_PARAMETER(1,                SIZE_CODE(sizeof(Boolean))),            0x0101,    // selector            showIt);    // parameter(s)    }}&nbsp;</pre></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P><A NAME="Power_Manager"></A><H2>Full Example: Power Manager</H2><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/*     File:        Power.Glue.c     Copyright:    &copy; 1984-1997 by Apple Computer, Inc.                 All rights reserved.*/&nbsp;#include &lt;MixedMode.h&gt;#include &lt;Power.h&gt;&nbsp;static UniversalProcPtr gPowerTrapUPP = kUnresolvedCFragSymbolAddress;static UniversalProcPtr gUnimplementedUPP = kUnresolvedCFragSymbolAddress;&nbsp;pascal Boolean HardDiskPowered(void)// TWOWORDINLINE(0x7006, 0xA09E);//    MOVEQ    #$06,D0        | 7006    ; Move selector//    _PowerMgr            | A09E    ; for _HardDiskPowered{    long    private_result = 0L;&nbsp;    if ((Ptr) gUnimplementedUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gUnimplementedUPP = GetToolboxTrapAddress(_Unimplemented);&nbsp;    if ((Ptr) gPowerTrapUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gPowerTrapUPP = GetToolboxTrapAddress(0xA09E);&nbsp;    if ((Ptr) gPowerTrapUPP != (Ptr) gUnimplementedUPP)    {        private_result = CallUniversalProc(gPowerTrapUPP,            kD0DispatchedPascalStackBased |                DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode) |                RESULT_SIZE(SIZE_CODE(sizeof(Boolean))),            0x0006);    // selector    }    return (OSErr) private_result;}&nbsp;pascal void SpinDownHardDisk(void)// TWOWORDINLINE(0x7007, 0xA09E);//    MOVEQ    #$07,D0        | 7006    ; Move selector//    _PowerMgr            | A09E    ; for _SpinDownHardDisk{    if ((Ptr) gUnimplementedUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gUnimplementedUPP = GetToolboxTrapAddress(_Unimplemented);&nbsp;    if ((Ptr) gPowerTrapUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gPowerTrapUPP = GetToolboxTrapAddress(0xA09E);&nbsp;    if ((Ptr) gPowerTrapUPP != (Ptr) gUnimplementedUPP)    {        CallUniversalProc(gPowerTrapUPP,            kD0DispatchedPascalStackBased |                DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode),            0x0007);    // selector    }}&nbsp;pascal Boolean IsSpindownDisabled(void)// TWOWORDINLINE(0x7008, 0xA09E);//    MOVEQ    #$08,D0        ; Move selector//    _PowerMgr            ; for _IsSpindownDisabled{    long    private_result = 0L;&nbsp;    if ((Ptr) gUnimplementedUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gUnimplementedUPP = GetToolboxTrapAddress(_Unimplemented);&nbsp;    if ((Ptr) gPowerTrapUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gPowerTrapUPP = GetToolboxTrapAddress(0xA09E);&nbsp;    if ((Ptr) gPowerTrapUPP != (Ptr) gUnimplementedUPP)    {        private_result = CallUniversalProc(gPowerTrapUPP,            kD0DispatchedPascalStackBased |            DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode) |            RESULT_SIZE(SIZE_CODE(sizeof(Boolean))),            0x0008);    // selector    }    return (OSErr) private_result;}&nbsp;// These two API's are strange in that they pass the boolean to the//A-Trap via the high-word of D0. The low-word holds the selector.//(Is this weird or what?)&nbsp;pascal void SetSpindownDisable(Boolean setDisable)// FOURWORDINLINE(0x4840, 0x303C, 0x0009, 0xA09E);//    SWAP    D0        ; Move setDisable to high-Word of D0//    MOVE.W    #$0009,D0    ; Move selector to low-Word of D0//    _PowerMgr        ; for _SetSpindownDisable{    if ((Ptr) gUnimplementedUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gUnimplementedUPP = GetToolboxTrapAddress(_Unimplemented);&nbsp;    if ((Ptr) gPowerTrapUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gPowerTrapUPP = GetToolboxTrapAddress(0xA09E);&nbsp;    if ((Ptr) gPowerTrapUPP != (Ptr) gUnimplementedUPP)        CallUniversalProc(gPowerTrapUPP,            kD0DispatchedPascalStackBased |                DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode),            (setDisable &lt;&lt; 16) | 0x0009);    // selector}&nbsp;pascal void AutoSleepControl(Boolean enableSleep)// FOURWORDINLINE(0x4840, 0x303C, 0x000D, 0xA09E);//    SWAP    D0        ; Move setDisable to high-Word of D0//    MOVE.W    #$000D,D0    ; Move selector to low-Word of D0//    _PowerMgr        ; for _AutoSleepControl{    if ((Ptr) gUnimplementedUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gUnimplementedUPP = GetToolboxTrapAddress(_Unimplemented);&nbsp;    if ((Ptr) gPowerTrapUPP == (Ptr) kUnresolvedCFragSymbolAddress)        gPowerTrapUPP = GetToolboxTrapAddress(0xA09E);&nbsp;    if ((Ptr) gPowerTrapUPP != (Ptr) gUnimplementedUPP)        CallUniversalProc(gPowerTrapUPP,            kD0DispatchedPascalStackBased |                DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode),            (enableSleep &lt;&lt; 16) | 0x000D);    // selector}</pre></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P><H2><A NAME="Summary"></A>Summary</H2><P>Now that you know how to glue in all those routinesmissing from <CODE>InterfaceLib</CODE>, you are now officially out ofexcuses. Time to write the next killer CFM application!</p><BR><P><A HREF="#top">Back to top</A></P><A NAME="References"></A> <H2>References</H2><P><a href="../../documentation/mac/MoreToolbox/MoreToolbox-2.html"> Inside Macintosh: PowerPC System Software</A>, Chapter 2<a href="../../documentation/mac/MoreToolbox/MoreToolbox-9.html">Mixed Mode Manager</A></p><p>"A Fragment of Your Imagination", Joe Zobkiw, ISBN:0-201-48358.</p><BR><P><A HREF="#top">Back to top</A></P>        <A NAME="Downloads"></A>         <h2>Downloadables</h2>        <center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600">          <TR>             <td width=50 align=left>               <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P>            </TD>            <td align="left">               <p>Acrobat version of this Note (84K).</P>            </TD>            <td width=60 align=left>               <p><A HREF="pdf/tn1127.pdf">Download</A></P>            </TD>          </TR>        </TABLE></center><BR><BR>                  <BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1127.html%3Fid%3DDTS10002967-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1127.html%3Fid%3DDTS10002967-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1127.html%3Fid%3DDTS10002967-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>