<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Tumbler and Podium - /TumblerSource/Tumbler_document.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Tumbler and Podium</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Tumbler and Podium</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/TumblerSource/Tumbler_document.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/TumblerSource/Tumbler_AEVT.c</option>
<option value="listing2.html">/TumblerSource/Tumbler_AEVT.h</option>
<option value="listing3.html">/TumblerSource/Tumbler_camera.c</option>
<option value="listing4.html">/TumblerSource/Tumbler_camera.h</option>
<option value="listing5.html">/TumblerSource/Tumbler_cursor.c</option>
<option value="listing6.html">/TumblerSource/Tumbler_cursor.h</option>
<option value="listing7.html">/TumblerSource/Tumbler_document.c</option>
<option value="listing8.html">/TumblerSource/Tumbler_document.h</option>
<option value="listing9.html">/TumblerSource/Tumbler_drag.c</option>
<option value="listing10.html">/TumblerSource/Tumbler_drag.h</option>
<option value="listing11.html">/TumblerSource/Tumbler_ErrorHandler.c</option>
<option value="listing12.html">/TumblerSource/Tumbler_ErrorHandler.h</option>
<option value="listing13.html">/TumblerSource/Tumbler_event.c</option>
<option value="listing14.html">/TumblerSource/Tumbler_event.h</option>
<option value="listing15.html">/TumblerSource/Tumbler_file.c</option>
<option value="listing16.html">/TumblerSource/Tumbler_file.h</option>
<option value="listing17.html">/TumblerSource/Tumbler_globals.h</option>
<option value="listing18.html">/TumblerSource/Tumbler_HideMenuBar.c</option>
<option value="listing19.html">/TumblerSource/Tumbler_HideMenuBar.h</option>
<option value="listing20.html">/TumblerSource/Tumbler_initialize.c</option>
<option value="listing21.html">/TumblerSource/Tumbler_initialize.h</option>
<option value="listing22.html">/TumblerSource/Tumbler_main.c</option>
<option value="listing23.html">/TumblerSource/Tumbler_main.h</option>
<option value="listing24.html">/TumblerSource/Tumbler_menus.c</option>
<option value="listing25.html">/TumblerSource/Tumbler_menus.h</option>
<option value="listing26.html">/TumblerSource/Tumbler_offscreen.c</option>
<option value="listing27.html">/TumblerSource/Tumbler_offscreen.h</option>
<option value="listing28.html">/TumblerSource/Tumbler_PICTImport.c</option>
<option value="listing29.html">/TumblerSource/Tumbler_PICTImport.h</option>
<option value="listing30.html">/TumblerSource/Tumbler_podium.c</option>
<option value="listing31.html">/TumblerSource/Tumbler_podium.h</option>
<option value="listing32.html">/TumblerSource/Tumbler_prototypes.h</option>
<option value="listing33.html">/TumblerSource/Tumbler_resources.h</option>
<option value="listing34.html">/TumblerSource/Tumbler_teutilities.c</option>
<option value="listing35.html">/TumblerSource/Tumbler_teutilities.h</option>
<option value="listing36.html">/TumblerSource/Tumbler_traps.c</option>
<option value="listing37.html">/TumblerSource/Tumbler_traps.h</option>
<option value="listing38.html">/TumblerSource/Tumbler_utility.c</option>
<option value="listing39.html">/TumblerSource/Tumbler_utility.h</option>
<option value="listing40.html">/TumblerSource/Tumbler_windows.c</option>
<option value="listing41.html">/TumblerSource/Tumbler_windows.h</option></select>
				</p>
				</form>
				<p><strong><a href="Tumbler_and_Podium.zip">Download Sample</a></strong> (&#147;Tumbler_and_Podium.zip&#148;, 1.07M)<BR>
<strong><a href="Tumbler_and_Podium.dmg">Download Sample</a></strong> (&#147;Tumbler_and_Podium.dmg&#148;, 1.15M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//  Tumbler_document.c////  Document handling routines.//    //  Author:    Nick Thompson &amp; Pablo Fernicola, with thanks to the QuickDraw 3D team////  Copyright &copy; 1992-95 Apple Computer, Inc., All Rights Reserved////  Modification History:////  11/26/94  nick  clean up, remove old TE references from dragtext, remove//            all other dead code.//            Modify CloseDocument &amp; CloseAllDocuments to return a Boolean.//  01/26/95  nick  parameterized NewDocument to take a (possibly null) group//            and viewhints.  Factored this routine as it was way too long//// to do: store the document reference as a handle in the window's refcon//#include &lt;Drag.h&gt;#include &lt;QuickDraw.h&gt;#include &quot;Tumbler_globals.h&quot;#include &quot;Tumbler_prototypes.h&quot;#include &quot;Tumbler_resources.h&quot;#include &quot;QD3DDrawContext.h&quot;#include &quot;QD3DCamera.h&quot;#include &quot;QD3DView.h&quot;#include &quot;QD3DLight.h&quot;#include &quot;QD3DGeometry.h&quot;#include &quot;QD3DSet.h&quot;#include &quot;QD3DTransform.h&quot;#include &quot;QD3DShader.h&quot;#include &quot;QD3DShader.h&quot;#include &quot;QD3DMath.h&quot;#include &quot;QD3DIO.h&quot;#include &quot;Tumbler_camera.h&quot;#include &quot;Tumbler_document.h&quot;#include &quot;Tumbler_file.h&quot;#include &quot;Tumbler_utility.h&quot;extern pascal OSErr MyTrackingHandler(short message, WindowPtr theWindow,                       void *handlerRefCon, DragReference theDrag);extern pascal OSErr MyReceiveDropHandler(WindowPtr theWindow, void *handlerRefCon,                     DragReference theDrag);//----------------------------------------------------------------------TQ3Status TumblerDocument_NewLights( DocumentPtr theDocument ) {  TQ3GroupObject      lightGroup;  TQ3LightObject      light;  TQ3PointLightData    pointData;  TQ3LightData        ambientData;    lightGroup = Q3LightGroup_New();  pointData.lightData.isOn    = kQ3True;  pointData.lightData.brightness  = 0.950;  pointData.lightData.color.r   = 1.0;  pointData.lightData.color.g   = 1.0;  pointData.lightData.color.b   = 1.0;  pointData.location.x      = -10.0;  pointData.location.y      = 10.0;  pointData.location.z      = 30.0;  pointData.castsShadows      = kQ3False;  pointData.attenuation      = kQ3AttenuationTypeNone;    light = Q3PointLight_New(&amp;pointData);  Q3Group_AddObject(lightGroup, light);  Q3Object_Dispose(light);  ambientData.isOn    = kQ3True;  ambientData.brightness  = 0.70;  ambientData.color.r   = 0.4;  ambientData.color.g   = 0.4;  ambientData.color.b   = 0.4;    light = Q3AmbientLight_New(&amp;ambientData);  Q3Group_AddObject(lightGroup, light);  Q3Object_Dispose(light);  pointData.lightData.isOn    = kQ3False;  pointData.lightData.brightness  = 0.80;  pointData.lightData.color.r   = 1.0;  pointData.lightData.color.g   = 0.0;  pointData.lightData.color.b   = 0.0;  pointData.location.x      = -10.0;  pointData.location.y      = 0.0;  pointData.location.z      = 5.0;  pointData.castsShadows      = kQ3False;  pointData.attenuation      = kQ3AttenuationTypeInverseDistance;    light = Q3PointLight_New(&amp;pointData);  Q3Group_AddObject(lightGroup, light);  Q3Object_Dispose(light);  pointData.lightData.isOn    = kQ3False;  pointData.lightData.brightness  = 0.80;  pointData.lightData.color.r   = 0.0;  pointData.lightData.color.g   = 1.0;  pointData.lightData.color.b   = 0.0;  pointData.location.x      = 10.0;  pointData.location.y      = 0.0;  pointData.location.z      = 5.0;  pointData.castsShadows      = kQ3False;  pointData.attenuation      = kQ3AttenuationTypeInverseDistance;    light = Q3PointLight_New(&amp;pointData);  Q3Group_AddObject(lightGroup, light);  Q3Object_Dispose(light);  pointData.lightData.isOn    = kQ3False;  pointData.lightData.brightness  = 0.80;  pointData.lightData.color.r   = 0.0;  pointData.lightData.color.g   = 0.0;  pointData.lightData.color.b   = 1.0;  pointData.location.x      = 10.0;  pointData.location.y      = 0.0;  pointData.location.z      = 5.0;  pointData.castsShadows      = kQ3False;  pointData.attenuation      = kQ3AttenuationTypeInverseDistance;    light = Q3PointLight_New(&amp;pointData);  Q3Group_AddObject(lightGroup, light);  Q3Object_Dispose(light);  Q3View_SetLightGroup(theDocument-&gt;theView, lightGroup);  Q3Object_Dispose(lightGroup);//      {#if defined(ESCHER_VER_15) &amp;&amp; ESCHER_VER_15    TQ3ColorRGB            ellipsoidColor;    TQ3EllipsoidData          ellipsoidData;    TQ3GeometryObject        ellipsoid;    TQ3RotateTransformData      rotateData;        theDocument-&gt;dynamicLights = Q3DisplayGroup_New();        ellipsoidData.origin.x = -10.0;    ellipsoidData.origin.y = 0.0;    ellipsoidData.origin.z = 5.0;        ellipsoidData.orientation.x = 0.0;    ellipsoidData.orientation.y = 1.0;    ellipsoidData.orientation.z = 0.0;        ellipsoidData.majorRadius.x = 0.0;    ellipsoidData.majorRadius.y = 0.0;    ellipsoidData.majorRadius.z = 1.0;        ellipsoidData.minorRadius.x = 1.0;    ellipsoidData.minorRadius.y = 0.0;    ellipsoidData.minorRadius.z = 0.0;    ellipsoidData.ellipsoidAttributeSet = Q3AttributeSet_New();        /* Red light ball */    ellipsoidColor.r = 1.0;    ellipsoidColor.g = 0.0;    ellipsoidColor.b = 0.0;        Q3AttributeSet_Add( ellipsoidData.ellipsoidAttributeSet,     kQ3AttributeTypeDiffuseColor, &amp;ellipsoidColor);    Q3AttributeSet_Add(ellipsoidData.ellipsoidAttributeSet,     kQ3AttributeTypeSpecularColor, &amp;ellipsoidColor);      ellipsoid = Q3Ellipsoid_New(&amp;ellipsoidData);    Q3Object_Dispose(ellipsoidData.ellipsoidAttributeSet);    theDocument-&gt;light1 = Q3OrderedDisplayGroup_New();    Q3Group_AddObject(theDocument-&gt;light1, ellipsoid);    Q3Object_Dispose(ellipsoid);    rotateData.axis = kQ3AxisY;    rotateData.radians = 0.0;        theDocument-&gt;lightXform1 = Q3RotateTransform_New(&amp;rotateData);    Q3Group_AddObject(theDocument-&gt;light1, theDocument-&gt;lightXform1);        Q3Group_AddObject(theDocument-&gt;dynamicLights, theDocument-&gt;light1);        /* Green light ball */    ellipsoidData.origin.x = 10.0;    ellipsoidData.origin.y = 0.0;    ellipsoidData.origin.z = 5.0;    ellipsoidData.ellipsoidAttributeSet = Q3AttributeSet_New();        ellipsoidColor.r = 0.0;    ellipsoidColor.g = 1.0;    ellipsoidColor.b = 0.0;    Q3AttributeSet_Add( ellipsoidData.ellipsoidAttributeSet,     kQ3AttributeTypeDiffuseColor, (const void *) &amp;ellipsoidColor);    Q3AttributeSet_Add(ellipsoidData.ellipsoidAttributeSet,     kQ3AttributeTypeSpecularColor, &amp;ellipsoidColor);      ellipsoid = Q3Ellipsoid_New(&amp;ellipsoidData);    Q3Object_Dispose(ellipsoidData.ellipsoidAttributeSet);    theDocument-&gt;light2 = Q3OrderedDisplayGroup_New();    Q3Group_AddObject(theDocument-&gt;light2, ellipsoid);    Q3Object_Dispose(ellipsoid);                  theDocument-&gt;lightXform2 = Q3RotateTransform_New(&amp;rotateData);    Q3Group_AddObject(theDocument-&gt;light2, theDocument-&gt;lightXform2);    Q3Group_AddObject(theDocument-&gt;dynamicLights, theDocument-&gt;light2);        /* Blue light ball */    ellipsoidData.origin.x = 5.0;    ellipsoidData.origin.y = 0.0;    ellipsoidData.origin.z = 10.0;    ellipsoidData.ellipsoidAttributeSet = Q3AttributeSet_New();        ellipsoidColor.r = 0.0;    ellipsoidColor.g = 0.0;    ellipsoidColor.b = 1.0;    Q3AttributeSet_Add( ellipsoidData.ellipsoidAttributeSet,     kQ3AttributeTypeDiffuseColor, (const void *) &amp;ellipsoidColor);    Q3AttributeSet_Add(ellipsoidData.ellipsoidAttributeSet,     kQ3AttributeTypeSpecularColor, &amp;ellipsoidColor);      ellipsoid = Q3Ellipsoid_New(&amp;ellipsoidData);    Q3Object_Dispose(ellipsoidData.ellipsoidAttributeSet);    theDocument-&gt;light3 = Q3OrderedDisplayGroup_New();    Q3Group_AddObject(theDocument-&gt;light3, ellipsoid);    Q3Object_Dispose(ellipsoid);                  rotateData.axis = kQ3AxisX;    theDocument-&gt;lightXform3 = Q3RotateTransform_New(&amp;rotateData);    Q3Group_AddObject(theDocument-&gt;light3, theDocument-&gt;lightXform3);    Q3Group_AddObject(theDocument-&gt;dynamicLights, theDocument-&gt;light3);#endif      }    theDocument-&gt;animateLights = kQ3False;  return(kQ3Success);}//-----------------------------------------------------------------------------------TQ3CameraObject TumblerDocument_NewCamera(WindowPtr theWindow){  TQ3ViewAngleAspectCameraData  perspectiveData;  TQ3CameraObject        camera;    TQ3Point3D           from   = { 0.0, 0.0, 30.0 };  TQ3Point3D           to     = { 0.0, 0.0, 0.0 };  TQ3Vector3D           up     = { 0.0, 1.0, 0.0 };  float             fieldOfView = .52359333333;  float             hither     =  0.001;  float             yon     =  1000;    TQ3Status          returnVal = kQ3Failure ;  perspectiveData.cameraData.placement.cameraLocation   = from;  perspectiveData.cameraData.placement.pointOfInterest   = to;  perspectiveData.cameraData.placement.upVector       = up;  perspectiveData.cameraData.range.hither  = hither;  perspectiveData.cameraData.range.yon   = yon;  perspectiveData.cameraData.viewPort.origin.x = -1.0;  perspectiveData.cameraData.viewPort.origin.y = 1.0;  perspectiveData.cameraData.viewPort.width = 2.0;  perspectiveData.cameraData.viewPort.height = 2.0;    perspectiveData.fov        = fieldOfView;  perspectiveData.aspectRatioXToY  =    (float) (theWindow-&gt;portRect.right - theWindow-&gt;portRect.left) /     (float) (theWindow-&gt;portRect.bottom - theWindow-&gt;portRect.top);      camera = Q3ViewAngleAspectCamera_New(&amp;perspectiveData);  return camera ;}//--------------------------------------------------------------------------------#ifdef PODIUM_APPTQ3DrawContextObject TumblerDocument_NewPixmapDrawContext( DocumentPtr theDocument ){  TQ3PixmapDrawContextData   myDrawContextData;  TQ3ColorARGB        clearColor = {1.0, 1.0, 1.0, 1.0} ;  TQ3DrawContextObject    myDrawContext ;  GWorldPtr           theGWorld ;  PixMapHandle        hPixMap ;  Rect            srcRect ;    theGWorld = theDocument-&gt;geometriesOffscreen ;    //  Fill in draw context data.  myDrawContextData.drawContextData.clearImageMethod = kQ3ClearMethodWithColor;  myDrawContextData.drawContextData.clearImageColor  = clearColor;  myDrawContextData.drawContextData.paneState = kQ3False;  myDrawContextData.drawContextData.maskState = kQ3False;    myDrawContextData.drawContextData.doubleBufferState = kQ3False;    hPixMap = GetGWorldPixMap(theGWorld);  LockPixels(hPixMap);  srcRect = theGWorld-&gt;portRect;  myDrawContextData.pixmap.width = srcRect.right  - srcRect.left;  myDrawContextData.pixmap.height= srcRect.bottom - srcRect.top;    myDrawContextData.pixmap.rowBytes = (**hPixMap).rowBytes &amp; 0x7FFF;  myDrawContextData.pixmap.pixelType = kQ3PixelTypeRGB32;  myDrawContextData.pixmap.pixelSize = 32;  myDrawContextData.pixmap.bitOrder  = kQ3EndianBig;  myDrawContextData.pixmap.byteOrder = kQ3EndianBig;    myDrawContextData.pixmap.image    = (**hPixMap).baseAddr;    return Q3PixmapDrawContext_New(&amp;myDrawContextData);}#endif//--------------------------------------------------------------------------------TQ3DrawContextObject TumblerDocument_NewDrawContext( WindowPtr theWindow ){  TQ3DrawContextData    myDrawContextData;  TQ3MacDrawContextData  myMacDrawContextData;  TQ3DrawContextObject  myDrawContext ;  TQ3ColorARGB      clearColor = {1.0, kTumblerDefaultClearColor, kTumblerDefaultClearColor, kTumblerDefaultClearColor};  // lt gray  //  Fill in draw context data.  myDrawContextData.clearImageMethod = kQ3ClearMethodWithColor;  myDrawContextData.clearImageColor = clearColor;  myDrawContextData.pane.min.x = (theWindow-&gt;portRect).left;  myDrawContextData.pane.max.x = (theWindow-&gt;portRect).right;   myDrawContextData.pane.min.y = (theWindow-&gt;portRect).top;  myDrawContextData.pane.max.y = (theWindow-&gt;portRect).bottom;  myDrawContextData.paneState = kQ3False;  myDrawContextData.maskState = kQ3False;  myDrawContextData.doubleBufferState = kQ3True;  myMacDrawContextData.drawContextData = myDrawContextData;    myMacDrawContextData.library = kQ3Mac2DLibraryNone;  myMacDrawContextData.window = (CWindowPtr) theWindow;  myMacDrawContextData.grafPort = nil;  myMacDrawContextData.viewPort = nil;    //  Create draw context and return it, if it's nil the caller must handle  myDrawContext = Q3MacDrawContext_New(&amp;myMacDrawContextData) ;  return myDrawContext ;}//--------------------------------------------------------------------------------TQ3Status  TumblerDocument_UpdateView( DocumentPtr theDocument, TQ3SharedObject viewHints ){  TQ3Object        tempObject;  TQ3CameraObject      camera ;    if( theDocument-&gt;theView == NULL)    return kQ3Failure ;      TumblerDocument_NewLights( theDocument ) ;  if( viewHints == NULL ) {        // if we were called with null viewhints, then just set up    // sensible defaults for the current document    camera = TumblerDocument_NewCamera( theDocument-&gt;theWindow ) ;    if( camera != NULL ) {      Q3View_SetCamera(theDocument-&gt;theView, camera );      Q3Object_Dispose(camera);    }    else       return kQ3Failure ;        Q3View_SetRendererByType(theDocument-&gt;theView, kQ3RendererTypeInteractive);  }  else {      // we think we have valid viewhints, so attempt to     // get the information we need from the viewhints     // passed in, where we dont have an item, then make    // a sensible default.        // renderer information    Q3ViewHints_GetRenderer(viewHints, &amp;tempObject);#ifndef PODIUM_APP    if (tempObject != NULL)    {      Q3View_SetRenderer(theDocument-&gt;theView, tempObject);      Q3Object_Dispose(tempObject);    }    else      Q3View_SetRendererByType(theDocument-&gt;theView, kQ3RendererTypeWireFrame);#else      Q3View_SetRendererByType(theDocument-&gt;theView, kQ3RendererTypeInteractive);#endif      // camera information    tempObject = NULL ;//    Q3ViewHints_GetCamera(viewHints, &amp;tempObject);    if (tempObject != NULL) {      Q3View_SetCamera(theDocument-&gt;theView, tempObject);      Q3Object_Dispose(tempObject);    }      else {      camera = TumblerDocument_NewCamera( theDocument-&gt;theWindow ) ;      if( camera != NULL ) {        Q3View_SetCamera(theDocument-&gt;theView, camera );        Q3Object_Dispose(camera);      }      else         return kQ3Failure ;#ifndef PODIUM_APP                AdjustCamera(theDocument,                theDocument-&gt;theWindow-&gt;portRect.right - theDocument-&gt;theWindow-&gt;portRect.left,                theDocument-&gt;theWindow-&gt;portRect.bottom - theDocument-&gt;theWindow-&gt;portRect.top);  #else      AdjustCamera(theDocument,                theDocument-&gt;geometriesOffscreen-&gt;portRect.right - theDocument-&gt;geometriesOffscreen-&gt;portRect.left,                theDocument-&gt;geometriesOffscreen-&gt;portRect.bottom - theDocument-&gt;geometriesOffscreen-&gt;portRect.top);  #endif    }            // light information    Q3ViewHints_GetLightGroup(viewHints, &amp;tempObject);    if (tempObject != NULL) {      Q3View_SetLightGroup(theDocument-&gt;theView, tempObject);      Q3Object_Dispose(tempObject);    }          else {      TumblerDocument_NewLights( theDocument ) ;    }    }    // replace the existing view hints  if( theDocument-&gt;viewHints ) {    Q3Object_Dispose(theDocument-&gt;viewHints);  }  theDocument-&gt;viewHints = Q3ViewHints_New(theDocument-&gt;theView);    SetPort( (GrafPtr)theDocument-&gt;theWindow) ;  InvalRect( &amp;theDocument-&gt;theWindow-&gt;portRect ) ;    return kQ3Success ;}//--------------------------------------------------------------------------------//  NewDocument is called when a new document window is needed. Creation of//  document data structures is handled here.//DocumentPtr NewDocument( TQ3SharedObject viewHints, TQ3GroupObject group ){  DocumentPtr theDocument;  WindowPtr    theWindow;  Rect      theRect = { 0, 0, 16, 16 };  Point      thePoint;  TQ3Param2D    uvValues = {-1.0, -1.0};    TQ3DrawContextObject    theDrawContext ;  TQ3CameraObject      camera ;  TQ3AttributeSet      viewSet;    if (gDocumentCount == MaxDocumentCount)    return( (DocumentPtr )nil );          // make sure the pointer is initialised to nil, because we rely on  // the fields being non nil in order to dispose of the correctly.  theDocument = gDocumentList[gDocumentCount++] =              (DocumentPtr )NewPtrClear(sizeof(DocumentRecord));#ifdef PODIUM_APP  {    // for podium set up two GWorlds, on for the bg picture, one for the     // pixmap draw context that we'll draw the geomentries into        Rect    defaultGeometryRect = { 0, 0, 200, 200 } ;    GWorldPtr  savedGWorld ;    GDHandle  savedGDH ;        GetGWorld( &amp;savedGWorld, &amp;savedGDH ) ;        if( NewGWorld(&amp;theDocument-&gt;bgOffscreen, 16, &amp;defaultGeometryRect, nil, nil, 0L ) != noErr ) {      CloseDocument( theDocument ) ;      return NULL ;    }    SetGWorld( theDocument-&gt;bgOffscreen, nil ) ;    EraseRect( &amp;theDocument-&gt;bgOffscreen-&gt;portRect ) ;        if( NewGWorld(&amp;theDocument-&gt;screenBuffer, 16, &amp;defaultGeometryRect, nil, nil, 0L ) != noErr ) {      CloseDocument( theDocument ) ;      return NULL ;    }    SetGWorld( theDocument-&gt;screenBuffer, nil ) ;    EraseRect( &amp;theDocument-&gt;screenBuffer-&gt;portRect ) ;        if( NewGWorld(&amp;theDocument-&gt;geometriesOffscreen, 32, &amp;defaultGeometryRect, nil, nil, 0L ) != noErr ) {      CloseDocument( theDocument ) ;      return NULL ;    }    SetGWorld( theDocument-&gt;geometriesOffscreen, nil ) ;    EraseRect( &amp;theDocument-&gt;geometriesOffscreen-&gt;portRect ) ;    theDocument-&gt;dropArea = defaultGeometryRect ;        // create a 1-bit GW for the mask//    if( NewGWorld( &amp;theDocument-&gt;maskOffscreen, 1, &amp;theDocument-&gt;geometriesOffscreen-&gt;portRect, nil, nil, 0L)  != noErr ) {//      CloseDocument( theDocument ) ;//      return NULL ;//    }//    SetGWorld( theDocument-&gt;maskOffscreen, nil ) ;//    EraseRect( &amp;theDocument-&gt;maskOffscreen-&gt;portRect ) ;        SetGWorld( savedGWorld, savedGDH ) ;        theDocument-&gt;currentInterpolation = kQ3InterpolationStyleVertex;  }#endif  theWindow = GetNewCWindow(WindowTemplateID, 0L, (WindowPtr) -1L);  if (theWindow == nil)    return( (DocumentPtr )nil );    theDocument-&gt;theWindow = theWindow ;            SetWRefCon(theWindow, (long)theDocument ) ;  SetPort(theWindow);#ifndef PODIUM_APP  // only want to set the bg color up for Tumbler  {    RGBColor color = { 0xFFFF, 0xFFFF, 0xFFFF};    theDocument-&gt;clearColor.r = kTumblerDefaultClearColor ;    theDocument-&gt;clearColor.g = kTumblerDefaultClearColor ;    theDocument-&gt;clearColor.b = kTumblerDefaultClearColor ;        color.red *= theDocument-&gt;clearColor.r;    color.green *= theDocument-&gt;clearColor.r;    color.blue *= theDocument-&gt;clearColor.r;        RGBBackColor(&amp;color);    EraseRect(&amp;theWindow-&gt;portRect);        color.blue = color.green = color.red  =  0xFFFF;    RGBBackColor(&amp;color);  }#endif  thePoint = *((Point *) (&amp;theWindow-&gt;portRect.top));  LocalToGlobal(&amp;thePoint);  if (thePoint.h &lt; 10) {    MoveWindow(theWindow, InitialH, InitialV, false);  }  theDocument-&gt;fRefNum = 0;  // zero out the file spec  theDocument-&gt;theFileSpec.vRefNum = 0 ;  theDocument-&gt;theFileSpec.parID = 0 ;  theDocument-&gt;theFileSpec.name[0] = '\0' ;    theDocument-&gt;dirty = false;    // set up the draw context, camera and lights#ifndef PODIUM_APP  theDrawContext = TumblerDocument_NewDrawContext( theWindow ) ;#else  theDrawContext = TumblerDocument_NewPixmapDrawContext( theDocument ) ;#endif  if( theDrawContext != NULL ) {    TQ3ColorRGB      clearColor = {1.0, 1.0, 1.0};    theDocument-&gt;theView = Q3View_New();      Q3View_GetDefaultAttributeSet(theDocument-&gt;theView, &amp;viewSet);    Q3AttributeSet_Add(viewSet,       kQ3AttributeTypeSpecularColor, &amp;clearColor);    Q3AttributeSet_Add(viewSet,       kQ3AttributeTypeSurfaceUV, &amp;clearColor);    Q3AttributeSet_Add(viewSet,       kQ3AttributeTypeShadingUV, &amp;clearColor);    Q3Object_Dispose(viewSet);        Q3View_SetDrawContext(theDocument-&gt;theView, theDrawContext);    Q3Object_Dispose(theDrawContext);  }  else    return NULL ;                InstallTrackingHandler(NewDragTrackingHandlerProc(MyTrackingHandler), theWindow, (void *) theDocument);  InstallReceiveHandler(NewDragReceiveHandlerProc(MyReceiveDropHandler), theWindow, (void *) theDocument);  Q3Matrix4x4_SetIdentity(&amp;theDocument-&gt;modelRotation);    theDocument-&gt;animateModel = kQ3False;  theDocument-&gt;light = kQ3False;  theDocument-&gt;shaded = kQ3False;  theDocument-&gt;documentGroup = nil;  #ifndef PODIUM_APP  theDocument-&gt;currentInterpolation = kQ3InterpolationStyleNone;#endif  theDocument-&gt;backfacingStyle = Q3BackfacingStyle_New(kQ3BackfacingStyleRemove ) ;  theDocument-&gt;viewHints = Q3ViewHints_New(theDocument-&gt;theView);\  theDocument-&gt;illuminationShader = Q3PhongIllumination_New();  return(theDocument);}//----------------------------------------------------------------------------------//  CloseDocument is called when a document window is being closed. Storage//  of the document file and disposal of document data structures is handled//  here.Boolean CloseDocument( DocumentPtr theDocument ){  short      index, response;  Str255      theName, theVerb;  Boolean      couldCloseIt = false ;  index = 0;    while ((gDocumentList[index] != theDocument) &amp;&amp; (index &lt; MaxDocumentCount))    index++;  if (gDocumentList[index] == theDocument) {    if (theDocument-&gt;dirty) {      GetWTitle(theDocument-&gt;theWindow, theName);      GetIndString(theVerb, FileStringsID, (gQuitting) ? slQuittingIndex : slClosingIndex);      ParamText( (ConstStr255Param)&amp;theName, (ConstStr255Param) &amp;theVerb, (ConstStr255Param) &quot;&quot;, (ConstStr255Param) &quot;&quot;);      SetCursor(&amp;qd.arrow);            // check with the user - do they want to save this thing      response = Alert(idSaveChangesALRT, 0L);      if (response == 1) {      // Save              // check to see that we were able to save the         // document as requested to by the user                if (!DidSaveDocument(theDocument)) {                  // signal that we are not quitting (if we were actually trying)          gQuitting = false;                    // signal that we couldn't save this document          couldCloseIt = false ;                    return couldCloseIt;        }              } else if (response == 3) {    /* Don't Save */        ;      } else {            /* Cancel */        gQuitting = false ;                // signal that we didn't actually want to close this document        couldCloseIt = false ;                return couldCloseIt;      }    }        // if we are here we can assume the document has been saved (if required) and     // that we can junk all of the data structures associated with the document    // if it has a file associated, close it    if (theDocument-&gt;fRefNum) {      FSClose(theDocument-&gt;fRefNum);    }    // remove our drag manager handlers    RemoveTrackingHandler(NewDragTrackingHandlerProc(MyTrackingHandler), theDocument-&gt;theWindow);    RemoveReceiveHandler(NewDragReceiveHandlerProc(MyReceiveDropHandler), theDocument-&gt;theWindow);    // and we can dispose of the window    if(theDocument-&gt;theWindow)      DisposeWindow(theDocument-&gt;theWindow);    // close any holes left in the array we     // have for storing our document objects    while (index &lt; MaxDocumentCount) {      gDocumentList[index] = gDocumentList[index + 1];      index++;    }    // dispose of our QuickDraw 3d view object    if(theDocument-&gt;theView)      Q3Object_Dispose(theDocument-&gt;theView);    if(theDocument-&gt;viewHints)      Q3Object_Dispose(theDocument-&gt;viewHints);    // if we have a group associated with the document, then delete that    if(theDocument-&gt;documentGroup)      Q3Object_Dispose(theDocument-&gt;documentGroup);    // dispose of the lights we set up for this document    if(theDocument-&gt;dynamicLights)      Q3Object_Dispose(theDocument-&gt;dynamicLights);    if(theDocument-&gt;light1) {      Q3Object_Dispose(theDocument-&gt;light1);      Q3Object_Dispose(theDocument-&gt;lightXform1);    }        if(theDocument-&gt;light2) {      Q3Object_Dispose(theDocument-&gt;light2);      Q3Object_Dispose(theDocument-&gt;lightXform2);    }        if(theDocument-&gt;light3) {      Q3Object_Dispose(theDocument-&gt;light3);      Q3Object_Dispose(theDocument-&gt;lightXform3);    }    if(theDocument-&gt;backfacingStyle) {      Q3Object_Dispose(theDocument-&gt;backfacingStyle);    }     if(theDocument-&gt;illuminationShader) {      Q3Object_Dispose(theDocument-&gt;illuminationShader);    }#ifdef PODIUM_APP    if(theDocument-&gt;bgOffscreen != nil ) {      DisposeGWorld(theDocument-&gt;bgOffscreen) ;    }        if(theDocument-&gt;screenBuffer != nil ) {      DisposeGWorld(theDocument-&gt;screenBuffer) ;    }        if(theDocument-&gt;geometriesOffscreen != nil ) {      DisposeGWorld(theDocument-&gt;geometriesOffscreen) ;    }    //    if(theDocument-&gt;maskOffscreen != nil ) {//      DisposeGWorld(theDocument-&gt;maskOffscreen) ;//    }    #endif    // finally dispose of the storage used for the document and     // decrement the document count    if( theDocument != nil )      DisposePtr((Ptr) theDocument);    gDocumentCount--;        // signal that we closed this document    couldCloseIt = true ;    return couldCloseIt;      }  // signal that we could't actually close this document  couldCloseIt = false ;  return couldCloseIt;}//----------------------------------------------------------------------------------//  Closes all document windows.//Boolean CloseAllDocuments( void ){  short  index ;    for( index = gDocumentCount - 1; index &gt;= 0; index-- ) {    if(CloseDocument(gDocumentList[ index ]) == false)      return false;  }  return true ;}//----------------------------------------------------------------------------------//  DoActivateDocument is called when an event is received that reports that//  a document window is being either activated or deactivated.void DoActivateDocument(DocumentPtr theDocument, short activate){  if (theDocument) {    if (activate) {          // do whatever you'd like to do for a activate event#ifdef PODIUM_APP            void FixGrayRgnAfterContextSwitch( void ) ;      FixGrayRgnAfterContextSwitch();#endif                  LoadScrap() ;    } else {          // do whatever you'd like to do for a deactivate event      UnloadScrap() ;    }  }}//----------------------------------------------------------------------------------//  If the given WindowPtr is a pointer to a document window, this function//  returns a pointer to a document data structure. If the window is not//  a document window, the function returns nil.DocumentPtr GetDocumentFromWindow(WindowPtr theWindow){  short    index = 0;  DocumentPtr theDocument;  if( theWindow == nil )    return((DocumentPtr ) 0L);  theDocument = (DocumentPtr ) (((WindowPeek) theWindow)-&gt;refCon);  while ((gDocumentList[index] != theDocument) &amp;&amp; (index &lt; gDocumentCount))    index++;  if (gDocumentList[index] == theDocument)    return(theDocument);  else    return((DocumentPtr ) 0L);}TQ3Status InitializeGroup(TQ3GroupObject group){  TQ3ShaderObject  illuminationShader = Q3PhongIllumination_New();  Q3Group_AddObject(group, illuminationShader);  Q3Object_Dispose(illuminationShader);  return(kQ3Success);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Tumbler_and_Podium/listing7.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Tumbler_and_Podium/listing7.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Tumbler_and_Podium/listing7.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>