<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>iso9660 - /BuildISO.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">iso9660</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/idxMassStorageDevices-date.html" target="_blank">Hardware & Drivers > Storage</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">iso9660</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/BuildISO.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BuildISO.c</option>
<option value="listing2.html">/BuildISO.h</option>
<option value="listing3.html">/DialogUtils.c</option>
<option value="listing4.html">/DialogUtils.h</option>
<option value="listing5.html">/ErrorMsg.c</option>
<option value="listing6.html">/ErrorMsg.h</option>
<option value="listing7.html">/HighSierra.h</option>
<option value="listing8.html">/i_o.c</option>
<option value="listing9.html">/i_o.h</option>
<option value="listing10.html">/main.c</option>
<option value="listing11.html">/main.h</option>
<option value="listing12.html">/mydialog.c</option>
<option value="listing13.html">/mydialog.h</option>
<option value="listing14.html">/support.c</option>
<option value="listing15.html">/support.h</option></select>
				</p>
				</form>
				<p><strong><a href="iso9660.zip">Download Sample</a></strong> (&#147;iso9660.zip&#148;, 57.3K)<BR>
<strong><a href="iso9660.dmg">Download Sample</a></strong> (&#147;iso9660.dmg&#148;, 116.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    BuildISO.c    Description:Try to build a ISO 9660 floppy disc, interactively.         Currently only builds the Primary Volume Descriptor        and puts files at the root level.  Does not do        subdirectories.  Author:    BB  Copyright:   Copyright: &copy; 1988-1999 by Apple Computer, Inc.        all rights reserved.    Disclaimer:  You may incorporate this sample code into your applications without        restriction, though the sample code has been provided &quot;AS IS&quot; and the        responsibility for its operation is 100% yours.  However, what you are        not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;        after having made changes. If you're going to re-distribute the source,        we require that you make it clear in the source that the code was        descended from Apple Sample Code, but that you've made changes.    Change History (most recent first):        6/24/99  Updated for Metrowerks Codewarror Pro 2.1(KG)        1/94  Converted to Universal Headers.  Fixed a bug which prevented              Apple extensions from working correctly.        5/90  Modified for d e v e l o p and Think C 4.0        7/1/88  Original Version for the Macintosh(BB)*/#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#include &lt;Files.h&gt;#include &lt;OSUtils.h&gt;#include &lt;Memory.h&gt;#include &lt;Errors.h&gt;#include &lt;strings.h&gt;#include &lt;Devices.h&gt;#include &lt;MacMemory.h&gt;#include &quot;HighSierra.h&quot;#include &quot;BuildISO.h&quot;#define  FLOPPY_SIZE  0x186    /* size in 2k blocks of a 800k floppy */#include &quot;ErrorMsg.h&quot;#include &quot;i_o.h&quot;#include &quot;Support.h&quot;#include &quot;MyDialog.h&quot;Str255      nullStr = &quot;\p&quot;;Str255      rootName = &quot;\p\000&quot;;Str255      parentName = &quot;\p\001&quot;;/************************************************************************ * *  Function:    CreatePVD * *  Purpose:    create the contents of the Primary Volume Descriptor. * *  Returns:    void * *  Side Effects:  adds to the output file. * *  Description:  go through all the primary volume descriptor, showing *          each field in all it's glory.  We don't bother showing *          the extra blanks at the end of each string field. * * ************************************************************************/OSErrCreatePVD(short referenceNumber){  PVD    p;  OSErr  result;  long  offset;  char  volID[33];  Boolean  goOn;    ClearOut((char *)&amp;p, sizeof(p));  p.VDType = 1;  p.VSStdId[0] = 'C';  p.VSStdId[1] = 'D';  p.VSStdId[2] = '0';  p.VSStdId[3] = '0';  p.VSStdId[4] = '1';  p.VSStdVersion = 1;  CharCopy(p.systemIdentifier, &quot;Apple Computer, Inc., Type:0001&quot;, sizeof(p.systemIdentifier));  goOn = AskForString((char *)&quot;\pWhat do you want to call this volume? (32 characters or less)&quot;, volID);  if (goOn == false)    return -1;  NormalizeVolumeName(volID);  CharCopy(p.volumeIdentifier, volID, sizeof(p.volumeIdentifier));  p.lsbVolumeSpaceSize = NormalizeLong((long)FLOPPY_SIZE);  p.msbVolumeSpaceSize = (long)FLOPPY_SIZE;  p.lsbVolumeSetSize = NormalizeWord(FLOPPY_SIZE);  p.msbVolumeSetSize = FLOPPY_SIZE;  p.lsbVolumeSetSequenceNumber = NormalizeWord(1);  p.msbVolumeSetSequenceNumber = 1;    p.lsbLogicalBlockSize = NormalizeWord(CDBLKSIZE);  p.msbLogicalBlockSize = CDBLKSIZE;          p.lsbPathTableSize = NormalizeLong(PATHTBLSIZE);  p.msbPathTableSize = PATHTBLSIZE;  p.lsbPathTable1 = NormalizeLong(LSBPATH);  p.msbPathTable1 = MSBPATH;    p.lsbPathTable2 = 0L;  p.msbPathTable2 = 0L;    /* Exercise for reader: get the time via GetTime() and convert  ** to string of the format shown below for these strange dates.  ** Use that date and time to fill the various volume date fields.  ** The date shown is my daughter's birth date and time...  */  CharCopy(p.volumeCreation, &quot;19870914060100000&quot;, sizeof(p.volumeCreation));  CharCopy(p.volumeModification, &quot;19870914060100000&quot;, sizeof(p.volumeModification));  CharCopy(p.volumeExpiration, &quot;00000000000000000&quot;, sizeof(p.volumeExpiration));  CharCopy(p.volumeEffective, &quot;19870914060100000&quot;, sizeof(p.volumeEffective));  p.FileStructureStandardVersion = 1;    SpaceOut(p.volumeSetIdentifier, sizeof(p.volumeSetIdentifier));  SpaceOut(p.publisherIdentifier, sizeof(p.publisherIdentifier));  SpaceOut(p.dataPreparerIdentifier, sizeof(p.dataPreparerIdentifier));  SpaceOut(p.applicationIdentifier, sizeof(p.applicationIdentifier));  SpaceOut(p.copyrightFileIdentifier, sizeof(p.copyrightFileIdentifier));  SpaceOut(p.abstractFileIdentifier, sizeof(p.abstractFileIdentifier));  SpaceOut(p.bibliographicFileIdentifier, sizeof(p.bibliographicFileIdentifier));  CreateDirRcd((DirRcd *)&amp;p.rootDirectoryRecord, rootName,     DIRECTORY, CDBLKSIZE, (short) directoryBit, 0L, 0L, 0);    p.Reserved1 = 0;  ClearOut(p.Reserved2, sizeof(p.Reserved2));  ClearOut(p.Reserved3, sizeof(p.Reserved3));  p.Reserved4 = 0;#ifdef VERBOSE  /* if I want to verify what I've done */  DumpPVD(&amp;p);#endif  offset = (long) HSVOLSTART * (long) CDBLKSIZE;  result = isoWrite(referenceNumber, (Ptr)&amp;p, (long) sizeof(p), (long)offset);  if (result != noErr)    ErrorMsg(&quot;CreatePVD: isoWrite() returned %d&quot;, result);  else    ErrorMsg(&quot;volume descriptors successfully created.&quot;);  return result;}/************************************************************************ * *  Function:    CreateVDT * *  Purpose:    create the contents of the Volume Descriptor Terminator * *  Returns:    void * *  Side Effects:  adds to the output file. * *  Description:  Build a simple VDT, fill it in, and write it out to *          a famous place. * * ************************************************************************/OSErrCreateVDT(short referenceNumber){  PVD    p;  OSErr  result;  long  offset;    ClearOut((char *)&amp;p, sizeof(p));  p.VDType = 255;  p.VSStdId[0] = 'C';  p.VSStdId[1] = 'D';  p.VSStdId[2] = '0';  p.VSStdId[3] = '0';  p.VSStdId[4] = '1';  p.VSStdVersion = 1;  offset = (long) HSTERMSTART * (long) CDBLKSIZE;  result = isoWrite(referenceNumber, (Ptr)&amp;p, (long) sizeof(p), (long)offset);  if (result != noErr)    ErrorMsg(&quot;CreateVDT: isoWrite() returned %d&quot;, result);  return result;}/************************************************************************ * *  Function:    CreatePathTable * *  Purpose:    create path tables * *  Returns:    nothing * *  Side Effects:  writes lsb path table and msb path table * *  Description:  We'll assume just the root.  Dump out the path *          path table in both formats.  We'll put the *          path table in famous spots. * ************************************************************************/OSErrCreatePathTable(short referenceNumber){  char  buffer[CDBLKSIZE];  PathTableRecordPtr  d;  long  offset;  OSErr  result;    ClearOut(buffer, sizeof(buffer));  d = (PathTableRecordPtr) &amp;buffer[0];    d-&gt;len_di = 1;  d-&gt;XARlength = 0;  d-&gt;dirLocation = NormalizeLong(DIRECTORY);  d-&gt;parentDN = 0;    offset = LSBPATH * (long) CDBLKSIZE;  result = isoWrite(referenceNumber, buffer, (long) CDBLKSIZE, offset);  if (result != noErr)    ErrorMsg(&quot;CreatePathTable: isoWrite() returned %d&quot;, result);    d-&gt;len_di = 1;  d-&gt;dirLocation = DIRECTORY;  d-&gt;parentDN = 0;    offset = MSBPATH * (long) CDBLKSIZE;  result = isoWrite(referenceNumber, buffer, (long) CDBLKSIZE, offset);  if (result != noErr)    ErrorMsg(&quot;CreatePathTable: isoWrite() returned %d&quot;, result);  return result;}/************************************************************************ * *  Function:  CreateDirRcd * *  Purpose:  Create a directory record for a file * *  Returns:  none * *  Side Effects:  fills *d with directory information.  We assume *          caller has allocated space for d. * *  Description: * ************************************************************************/voidCreateDirRcd(DirRcd *d, StringPtr name, long start, long length, short flags, OSType fType, OSType fCreator, short finderFlags){  Ptr    dPtr;  DateTimeRec  today;  d-&gt;XARlength = 0;  d-&gt;lsbStart = NormalizeLong(start);  d-&gt;msbStart = start;  d-&gt;lsbDataLength = NormalizeLong(length);  d-&gt;msbDataLength = length;  d-&gt;fileFlags = flags;  if (finderFlags &amp; fInvisible)    d-&gt;fileFlags |= existenceBit;  GetTime(&amp;today);  d-&gt;year = today.year-1900;  d-&gt;month = today.month;  d-&gt;day = today.day;  d-&gt;hour = today.hour;  d-&gt;minute = today.minute;  d-&gt;second = today.second;  d-&gt;gmtOffset = 0;  d-&gt;interleaveSize = 0;  d-&gt;interleaveSkip = 0;  d-&gt;lsbVolSetSeqNum = NormalizeWord(1);  d-&gt;msbVolSetSeqNum = 1;    d-&gt;len_fi = CreateISOName((char *)d-&gt;fi, name);  d-&gt;len_dr = 32 + d-&gt;len_fi;    AddAppleExtensions(d, fType, fCreator, finderFlags);    if (d-&gt;len_dr &amp; 1)  /* odd dirRcds need pad byte */  {    dPtr = (char *)d;    dPtr[d-&gt;len_dr] = '\000';    d-&gt;len_dr++;  }}/************************************************************************ * *  Function:    AddOldAppleExtensions * *  Purpose:    optionally add apple extensions to ISO 9660 * *  Returns:    void * *  Side Effects:  directory record may get extended.  Must have enough *          room in area pointed to by dirRcd for this to happen. * *  Description:  Check the fType.  If it's non-zero, add the information *          necessary for the Apple Extensions to ISO 9660.  Note *          that we can't just assign fType and fCreator, since *          longs are aligned within structures. * *          This procedure adds the old, &quot;BA&quot; Apple extensions. * ************************************************************************/voidAddOldAppleExtensions(DirRcd *dirRcd, OSType fType, OSType fCreator, short flags){  OldAppleExtension  apple;  short      i;  short      j;  short      limit;  char      *aPtr;  Ptr        fPtr;    if (fType != 0L)  {    apple.macFlag[0] = 'B';    apple.macFlag[1] = 'A';    apple.systemUseID = 06;    fPtr = (char *)&amp;fType;        for (i = 0; i &lt; 4; i++)      apple.fileType[i] = fPtr[i];    fPtr = (char *)&amp;fCreator;        for (i = 0; i &lt; 4; i++)      apple.fileCreator[i] = fPtr[i];        apple.finderFlags[0] = (flags &gt;&gt; 8) &amp; 0xFF;    apple.finderFlags[1] = flags &amp; 0xFF;        limit = sizeof(apple);        aPtr = (char *)&amp;apple;    j = dirRcd-&gt;len_fi;        if (!(j &amp; 1))    /* 9401 bug fix BL&iexcl;B */    {      dirRcd-&gt;fi[j] = 0;      j++;  /* there is a pad byte after odd length file names */    }        for (i = 0; i &lt;= limit; i++)      dirRcd-&gt;fi[i + j] = aPtr[i];        dirRcd-&gt;len_dr += limit;  }}  /************************************************************************ * *  Function:    AddAppleExtensions * *  Purpose:    optionally add apple extensions to ISO 9660 * *  Returns:    void * *  Side Effects:  directory record may get extended.  Must have enough *          room in area pointed to by dirRcd for this to happen. * *  Description:  Check the fType.  If it's non-zero, add the information *          necessary for the Apple Extensions to ISO 9660.  Note *          that we can't just assign fType and fCreator, since *          longs are aligned within structures. * ************************************************************************/voidAddAppleExtensions(DirRcd *dirRcd, OSType fType, OSType fCreator, short flags){  AppleExtension  apple;  short      i;  short      j;  short      limit;  char      *aPtr;  Ptr        fPtr;    if (fType != 0L)  {    apple.signature[0] = 'A';    apple.signature[1] = 'A';    apple.extensionLength = 0x0E;    apple.systemUseID = 02;    fPtr = (char *)&amp;fType;        for (i = 0; i &lt; 4; i++)      apple.fileType[i] = fPtr[i];    fPtr = (char *)&amp;fCreator;        for (i = 0; i &lt; 4; i++)      apple.fileCreator[i] = fPtr[i];        apple.finderFlags[0] = (flags &gt;&gt; 8) &amp; 0xFF;    apple.finderFlags[1] = flags &amp; 0xFF;        limit = sizeof(apple);        aPtr = (char *)&amp;apple;    j = dirRcd-&gt;len_fi;        if (!(j &amp; 1))    /* 9401 bug fix BL&iexcl;B */    {      dirRcd-&gt;fi[j] = 0;      j++;  /* there is a pad byte after odd length file names */    }        for (i = 0; i &lt;= limit; i++)      dirRcd-&gt;fi[i + j] = aPtr[i];        dirRcd-&gt;len_dr += limit;  }}  /************************************************************************ * *  Function:    CopyDirRcdToBuffer * *  Purpose:    copy directory record to buffer * *  Returns:    nothing * *  Side Effects:  buffer is filled a little bit more * *  Description:  copy a directory record to the buffer. * ************************************************************************/voidCopyDirRcdToBuffer(DirRcd *d, char *b){  char  *dPrime;  short  i;    dPrime = (char *)d;  for (i = 0; i &lt; d-&gt;len_dr; i++)    *b++ = *dPrime++;}/************************************************************************ * *  Function:    CopyRsrcFork * *  Purpose:    copy the resource fork of a file * *  Returns:    OSErr *            mostly noErr, but could be *            ioErr and the like if isoWrite complains. * *  Side Effects:  floppy gets new data written on it. * *  Description:  we have a starting location, &quot;start&quot;, and a length. *          Allocate an appropriate buffer and read from the file *          specified by &quot;name&quot; and &quot;vRefNum&quot;.  Write that information *          out to the floppy using our isoWrite call. * ************************************************************************/OSErrCopyRsrcFork(short referenceNumber, StringPtr name, short vRefNum, long start, long length)    /* how much to write */{  Ptr  rsrcBuf;  ParamBlockRec  pb;  Boolean    goOn;  OSErr    result;  long    physicalLength;  short    myRefNum;    ClearOut((Ptr)&amp;pb, sizeof(pb));  goOn = true;  physicalLength = ROUND_UP(length);    rsrcBuf = NewPtrClear(physicalLength);  if (rsrcBuf == NULL)  {    ErrorMsg(&quot;Can't allocate %ld bytes for CopyRsrcFork()&quot;, length);    return mFulErr;  /* nothing to clean up */  }  pb.ioParam.ioCompletion = NULL;  pb.ioParam.ioNamePtr = name;  pb.ioParam.ioVRefNum = vRefNum;  pb.ioParam.ioVersNum = 0;  pb.ioParam.ioPermssn = fsCurPerm;  pb.ioParam.ioMisc = NULL;  result = PBOpenRF(&amp;pb, false);  if (result != noErr)  {    ErrorMsg(&quot;CopyRsrcFork: PBOpenRF returned %d&quot;, result);    ErrorMsg(&quot;vRefNum %d, name %P&quot;, vRefNum, name);    C2PStr((char *)name);    goOn = false;  }    if (goOn)  {    myRefNum = pb.ioParam.ioRefNum;    result = FSRead(myRefNum, &amp;length, rsrcBuf);    if (result != noErr)    {      ErrorMsg(&quot;CopyRsrcFork: FSRead returned %d&quot;, result);      goOn = false;    }  }    if (goOn)  {    result = isoWrite(referenceNumber, rsrcBuf, physicalLength, start);    if (result != noErr)    {      ErrorMsg(&quot;CopyRsrcFork: isoWrite returned %d&quot;, result);      goOn = false;    }  }      PBClose(&amp;pb, false);  DisposePtr(rsrcBuf);  return result;}/************************************************************************ * *  Function:    CopyDataFork * *  Purpose:    copy the resource fork of a file * *  Returns:    OSErr *            mostly noErr, but could be *            ioErr and the like if isoWrite complains. * *  Side Effects:  floppy gets new data written on it. * *  Description:  we have a starting location, &quot;start&quot;, and a length. *          Allocate an appropriate buffer and read from the file *          specified by &quot;name&quot; and &quot;vRefNum&quot;.  Write that information *          out to the floppy using our isoWrite call. * ************************************************************************/OSErrCopyDataFork(short referenceNumber, StringPtr name, short vRefNum, long start, long length)    /* how much to write */{  Ptr  dataBuf;  ParamBlockRec  pb;  Boolean    goOn;  OSErr    result;  long    physicalLength;  short    myRefNum;    ClearOut((Ptr)&amp;pb, sizeof(pb));  goOn = true;  physicalLength = ROUND_UP(length);    dataBuf = NewPtrClear(physicalLength);  if (dataBuf == NULL)  {    ErrorMsg(&quot;Can't allocate %ld bytes for CopyDataFork()&quot;, length);    return mFulErr;  /* nothing to clean up */  }    pb.ioParam.ioCompletion = NULL;  pb.ioParam.ioNamePtr = name;  pb.ioParam.ioVRefNum = vRefNum;  pb.ioParam.ioVersNum = 0;  pb.ioParam.ioPermssn = fsCurPerm;  pb.ioParam.ioMisc = NULL;  result = PBOpen(&amp;pb, false);  if (result != noErr)  {    ErrorMsg(&quot;CopyDataFork: PBOpen returned %d&quot;, result);    ErrorMsg(&quot;vRefNum %d, name %P&quot;, vRefNum, name);    C2PStr((char *)name);    goOn = false;  }    if (goOn)  {    myRefNum = pb.ioParam.ioRefNum;    result = FSRead(myRefNum, &amp;length, dataBuf);    if (result != noErr)    {      ErrorMsg(&quot;CopyDataFork: FSRead returned %d&quot;, result);      goOn = false;    }  }    if (goOn)  {    result = isoWrite(referenceNumber, dataBuf, physicalLength, start);    if (result != noErr)    {      ErrorMsg(&quot;CopyDataFork: isoWrite returned %d&quot;, result);      goOn = false;    }  }    PBClose(&amp;pb, false);  DisposePtr(dataBuf);  return result;}/************************************************************************ * *  Function:    CreateFiles * *  Purpose:    create files in the root of a ISO floppy. *   *  Returns:    nothing * *  Side Effects:  floppy gets new data in famous root area * *  Description:  For each file, find the size of the two forks. *          Copy the resource fork first, then the data fork *          (associated files come before data files in ISO) * ************************************************************************/voidCreateFiles(short referenceNumber){  StringPtr  name;  short  vRefNum;  DirRcd  dirRcd;  long  start;    /* where we start putting data on the CD */  long  rsrcLength;  long  dataLength;  char  *b;  OSErr  result;  OSType  fType;  OSType  fCreator;  short  flags;  short  ISOFlags;  char  buffer[CDBLKSIZE];      ClearOut(buffer, sizeof(buffer));  b = &amp;buffer[0];  name = (StringPtr)NewPtr(255);  if (name == NULL)  {    ErrorMsg(&quot;Can't allocate 255 bytes for a string.&quot;);    return;  }  CreateDirRcd(&amp;dirRcd, rootName, DIRECTORY, CDBLKSIZE, (short) directoryBit, 0L, 0L, 0);  CopyDirRcdToBuffer(&amp;dirRcd, b);  b += dirRcd.len_dr;  CreateDirRcd(&amp;dirRcd, parentName, DIRECTORY, CDBLKSIZE, (short) directoryBit, 0L, 0L, 0);  CopyDirRcdToBuffer(&amp;dirRcd, b);  b += dirRcd.len_dr;  start = DATASTART * CDBLKSIZE;  /* Keep asking for names, even if errors occur.  Most errors will be because   * The user tried to copy too big of a file to the floppy.    */  while (HFSFile(name, &amp;vRefNum) == true)  {    result = GetFileInfo(name, vRefNum, &amp;rsrcLength, &amp;dataLength, &amp;fType, &amp;fCreator, &amp;flags);    if (result != noErr)      ErrorMsg(&quot;Can't get file information for %s&quot;, name);    else    {      ISOFlags = (flags &amp; fInvisible) ? existenceBit : 0;        if (rsrcLength != 0L)      {        CreateDirRcd(&amp;dirRcd, name, start/CDBLKSIZE, rsrcLength, ISOFlags | associatedBit,          fType, fCreator, flags);          result = CopyRsrcFork(referenceNumber, name, vRefNum, start, rsrcLength);        if (result == noErr)        {          CopyDirRcdToBuffer(&amp;dirRcd, b);          b += dirRcd.len_dr;          start = ROUND_UP(start+rsrcLength);        }        else          ErrorMsg(&quot;Failed to copy resource fork.&quot;);          }        if (result == noErr)      {        CreateDirRcd(&amp;dirRcd, name, start/CDBLKSIZE, dataLength, ISOFlags,           fType, fCreator, flags);            result = CopyDataFork(referenceNumber, name, vRefNum, start, dataLength);        if (result == noErr)        {          CopyDirRcdToBuffer(&amp;dirRcd, b);          b += dirRcd.len_dr;          start = ROUND_UP(start+dataLength);        }        else          ErrorMsg(&quot;Failed to copy data fork.&quot;);            ClearOut((Ptr)name, 255);      }    }  }  result = isoWrite(referenceNumber, (Ptr)buffer, (long)sizeof(buffer), (long) (DIRECTORY*CDBLKSIZE));  if (result != noErr)    ErrorMsg(&quot;CreateDataFiles: isoWrite of directory records returned %d&quot;, result);  DisposePtr((Ptr)name);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/iso9660/listing1.html%3Fid%3DDTS10000429-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/iso9660/listing1.html%3Fid%3DDTS10000429-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/iso9660/listing1.html%3Fid%3DDTS10000429-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>