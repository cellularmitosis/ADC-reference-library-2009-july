<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>RecentItems - /main.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxHumanInterfaceToolbox-date.html">Human Interface Toolbox</a> &gt; <A HREF="javascript:location.replace('index.html');">RecentItems</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">RecentItems</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/main.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/main.c</option>
<option value="listing2.html">/RecentItems.c</option>
<option value="listing3.html">/RecentItems.h</option></select>
				</p>
				</form>
				<p><strong><a href="RecentItems.zip">Download Sample</a></strong> (&#147;RecentItems.zip&#148;, 68.9K)<BR>
<strong><a href="RecentItems.dmg">Download Sample</a></strong> (&#147;RecentItems.dmg&#148;, 133.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//
//  File:    main.c of RecentItems
// 
//  Contains:  A skeleton of modern nib-based and Carbon Events-based Carbon application.
//  
//  Version:  1.0
// 
//  Created:  5 / 15 / 06
//  
//  Copyright:  Copyright 2006 Apple Computer, Inc., All Rights Reserved
// 
//  Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc. ( &quot;Apple&quot; ) in 
//        consideration of your agreement to the following terms, and your use, installation, modification 
//        or redistribution of this Apple software constitutes acceptance of these terms.   If you do 
//        not agree with these terms, please do not use, install, modify or redistribute this Apple 
//        software.
//
//        In consideration of your agreement to abide by the following terms, and subject to these terms,
//        Apple grants you a personal, non-exclusive license, under Apple's copyrights in this 
//        original Apple software ( the &quot;Apple Software&quot; ), to use, reproduce, modify and redistribute the 
//        Apple Software, with or without modifications, in source and / or binary forms; provided that if you 
//        redistribute the Apple Software in its entirety and without modifications, you must retain this 
//        notice and the following text and disclaimers in all such redistributions of the Apple Software. 
//        Neither the name, trademarks, service marks or logos of Apple Computer, Inc. may be used to 
//        endorse or promote products derived from the Apple Software without specific prior written 
//        permission from Apple.  Except as expressly stated in this notice, no other rights or 
//        licenses, express or implied, are granted by Apple herein, including but not limited to any 
//        patent rights that may be infringed by your derivative works or by other works in which the 
//        Apple Software may be incorporated.
//
//        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis. APPLE MAKES NO WARRANTIES, EXPRESS OR 
//        IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY 
//        AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE 
//        OR IN COMBINATION WITH YOUR PRODUCTS.
//
//        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR CONSEQUENTIAL 
//        DAMAGES ( INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
//        OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION ) ARISING IN ANY WAY OUT OF THE USE,
//        REPRODUCTION, MODIFICATION AND / OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER 
//        UNDER THEORY OF CONTRACT, TORT ( INCLUDING NEGLIGENCE ), STRICT LIABILITY OR OTHERWISE, EVEN 
//        IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//****************************************************
#pragma mark * complation directives * 
#define USE_DRAG_N_DROP  TRUE

//****************************************************
#pragma mark -
#pragma mark * includes &amp; imports * 
//----------------------------------------------------

#include &lt;Carbon/Carbon.h&gt; 
#include &quot;RecentItems.h&quot;

//****************************************************
#pragma mark -
#pragma mark * typedef's, struct's, enums, defines, etc. *
//----------------------------------------------------

#if DEBUG_ASSERT_PRODUCTION_CODE
#define require_orelse_continue( assertion )            \
{                                  \
  if ( !( assertion ) )                      \
    continue;                          \
}
#else
#define require_orelse_continue( assertion ) {            \
  if ( !( assertion ) ) {                      \
    DEBUG_ASSERT_MESSAGE( DEBUG_ASSERT_COMPONENT_NAME_STRING,  \
                #assertion,              \
                0,                  \
                0,                  \
                __FILE__,              \
                __LINE__,              \
                0 );                \
                continue;              \
                }                  \
}
#endif

#define require_orelse_continue_quiet( assertion )          \
{                                  \
  if ( !( assertion ) )                      \
    continue;                          \
}

#if USE_DRAG_N_DROP
typedef struct dnd_data_struct {
  HIViewRef  fHIViewRef;
  HIPoint    fHIPoint;
  Boolean    fDragging;
} dnd_data_rec, *dnd_data_ptr;
#endif USE_DRAG_N_DROP

// Application preference keys

#define kOpenFolderContentsPrefKey      CFSTR( &quot;Open Folders?&quot; )
#define kOpenFolderRecursivePrefKey      CFSTR( &quot;Open Folders Recursive?&quot; )

#define kResolveAliasesContentsPrefKey    CFSTR( &quot;Resolve Aliases?&quot; )
#define kResolveAliasesChainsPrefKey    CFSTR( &quot;Resolve Aliases Chains?&quot; )

#define kRecentAppsPrefKey          CFSTR( &quot;Recent Apps&quot; )
#define kRecentFoldersPrefKey        CFSTR( &quot;Recent Folders&quot; )
#define kRecentDocsPrefKey          CFSTR( &quot;Recent Docs&quot; )

// Preferences window's command ID's

#define kOpenFoldersHICommand        'OFld'
#define kOpenFoldersRecursiveHICommand    'OFRc'

#define kResolveAliasesHICommand      'RAls'
#define kResolveAliasesChainsHICommand    'RARc'

// The commands send by our recent menu items
#define  kRecentAppsMenuCMD    'RecA'
#define  kRecentFoldersMenuCMD  'RecF'
#define  kRecentDocsMenuCMD    'RecD'
#define  kRecentClearMenuCMD    'RecC'

//****************************************************
#pragma mark -
#pragma mark * local ( static ) function prototypes *
//----------------------------------------------------

static pascal  OSErr    Handle_OpenApplicationAE( const AppleEvent * inAppleEvent, AppleEvent * outAppleEvent, long inHandlerRefcon );
static pascal  OSErr    Handle_ReopenApplicationAE( const AppleEvent * inAppleEvent, AppleEvent * outAppleEvent, long inHandlerRefcon );
static pascal  OSErr    Handle_OpenDocumentsAE( const AppleEvent * inAppleEvent, AppleEvent * outAppleEvent, long inHandlerRefcon );
static pascal  OSErr    Handle_PrintDocumentsAE( const AppleEvent * inAppleEvent, AppleEvent * outAppleEvent, long inHandlerRefcon );
static      OSErr    Install_AppleEventHandlers( void );

static      OSStatus  Handle_AppEvents( EventHandlerCallRef inCaller, EventRef inEvent, void * inRefcon );
static      OSStatus  Handle_NewWindow( void );
static      OSStatus  Handle_WindowEvents( EventHandlerCallRef inCaller, EventRef inEvent, void * inRefcon );
#if USE_DRAG_N_DROP
static      OSStatus  Handle_DragEvents( EventHandlerCallRef inCaller, EventRef inEvent, void * inRefcon );
#endif USE_DRAG_N_DROP

static      void    Handle_NewPrefWindow( void );
static pascal  OSStatus  Handle_PrefCommandProcess( EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void * inUserData );
static pascal  OSStatus  Handle_PrefWindowIsAboutToClose( EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void * inUserData );
static      void    Get_Preferences( void );
static      OSStatus  Set_Preferences( void );

static      OSStatus  Do_OpenDocs( AEDescList inDocumentsList );
static      void    Append_ContainerItemsToAEDescList( const FSRef * inFSRef, AEDescList inDocumentsList );
static      OSErr    Get_ContainerItems( const FSRef * inContainerFSRef, FSRef * **outFSRefHandle, ItemCount * outNumRefs, Boolean * outContainerChanged );

//****************************************************
#pragma mark -
#pragma mark * exported globals *
//----------------------------------------------------

//****************************************************
#pragma mark -
#pragma mark * local ( static ) globals *
//----------------------------------------------------

static FSRef    gApplicationBundleFSRef;
static IBNibRef    gMainIBNibRef = NULL;
static Boolean    gAutoQuit = FALSE;    // if this is TRUE we auto-quit after a drag-n-drop ( 'odoc' ) launch

// our preferences
static WindowRef gPreferencesWindow = NULL;
static Boolean gOpenFolderContents = TRUE;
static Boolean gOpenFolderRecursive = TRUE;
static Boolean gResolveAliases = TRUE;
static Boolean gResolveAliasesChains = TRUE;

// Preferences window's checkboxes' IDs
static const HIViewID kOpenFoldersHID = { kOpenFoldersHICommand, 100 };
static const HIViewID kOpenFoldersRecursiveHID = { kOpenFoldersRecursiveHICommand, 100 };
static const HIViewID kResolveAliasesHID = { kResolveAliasesHICommand, 100 };
static const HIViewID kResolveAliasesChainsHID = { kResolveAliasesChainsHICommand, 100 };

#if USE_DRAG_N_DROP
// Our Drag-N-Drop HIView ( user pane )
static const HIViewID kDragNDropHID = { 'DnDv', 0 };
#endif USE_DRAG_N_DROP

static MenuRef  gRecentAppsMenuRef = NULL;
static MenuRef  gRecentFoldersMenuRef = NULL;
static MenuRef  gRecentDocsMenuRef = NULL;

//****************************************************
#pragma mark -
#pragma mark * exported function implementations *
//----------------------------------------------------

/*****************************************************
*
* Routine:  main ( argc, argv ) 
*
* Purpose:  main program entry point
*
* Inputs:  argc - the number of elements in the argv array
*      argv - an array of pointers to the parameters to this application
*
* Returns:  int - error code ( 0 == no error ) 
*
*/
int main( int argc, char * argv[] )
{
    OSStatus result;
  
  Get_Preferences( );  // load user preferences
  
  ProcessSerialNumber psn = { 0, kCurrentProcess };
  result = GetProcessBundleLocation( &amp;psn, &amp;gApplicationBundleFSRef );
  require_noerr( result, Oops );
  
    // Create a Nib reference, passing the name of the nib file ( without the .nib extension ).
    // CreateNibReference only searches into the application bundle.
    result = CreateNibReference( CFSTR( &quot;main&quot; ), &amp;gMainIBNibRef );
    require_noerr( result, Oops );
    
    // Once the nib reference is created, set the menu bar. &quot;MainMenu&quot; is the name of the menu bar
    // object. This name is set in InterfaceBuilder when the nib is created.
    result = SetMenuBarFromNib( gMainIBNibRef, CFSTR( &quot;MenuBar&quot; ) );
    require_noerr( result, Oops );
  
  // Install the Apple Event handlers
  Install_AppleEventHandlers( );
    
    // Install our handler for common commands on the application target
    const EventTypeSpec    kAppEvents[] = {
  { kEventClassCommand, kEventCommandProcess },   { kEventClassCommand, kEventCommandUpdateStatus },     };
    InstallApplicationEventHandler( NewEventHandlerUPP( Handle_AppEvents ), GetEventTypeCount( kAppEvents ), kAppEvents, 0, NULL );

  // setup the recent menus
  MenuRef tMenuRef;
  MenuItemIndex tMenuItemIndex;
  // Applications
  do {
    result = GetIndMenuItemWithCommandID( NULL, kRecentAppsMenuCMD, 1, &amp;tMenuRef, &amp;tMenuItemIndex );
    if ( noErr != result ) break;

    result = GetMenuItemHierarchicalMenu( tMenuRef, tMenuItemIndex, &amp;gRecentAppsMenuRef );
    if ( noErr != result ) break;

    result = RecentItems_SetMaxItems( gRecentAppsMenuRef, 10 );
    if ( noErr != result ) break;

    result = RecentItems_PopulateMenu( gRecentAppsMenuRef, kRecentAppsPrefKey, kRecentAppsMenuCMD );
    if ( noErr != result ) break;
  } while ( FALSE );

  // Folders
  do {
    result = GetIndMenuItemWithCommandID( NULL, kRecentFoldersMenuCMD, 1, &amp;tMenuRef, &amp;tMenuItemIndex );
    if ( noErr != result ) break;
    
    result = GetMenuItemHierarchicalMenu( tMenuRef, tMenuItemIndex, &amp;gRecentFoldersMenuRef );
    if ( noErr != result ) break;
    
    result = RecentItems_SetMaxItems( gRecentFoldersMenuRef, 20 );
    if ( noErr != result ) break;
    
    result = RecentItems_PopulateMenu( gRecentFoldersMenuRef, kRecentFoldersPrefKey, kRecentFoldersMenuCMD );
    if ( noErr != result ) break;
  } while ( FALSE );

  // Documents
  do {
    result = GetIndMenuItemWithCommandID( NULL, kRecentDocsMenuCMD, 1, &amp;tMenuRef, &amp;tMenuItemIndex );
    if ( noErr != result ) break;
    
    result = GetMenuItemHierarchicalMenu( tMenuRef, tMenuItemIndex, &amp;gRecentDocsMenuRef );
    if ( noErr != result ) break;
    
    result = RecentItems_SetMaxItems( gRecentDocsMenuRef, 30 );
    if ( noErr != result ) break;
    
    result = RecentItems_PopulateMenu( gRecentDocsMenuRef, kRecentDocsPrefKey, kRecentDocsMenuCMD );
    if ( noErr != result ) break;

    // result = RecentItems_DisableOpenItems( gRecentDocsMenuRef );
  } while ( FALSE );

  result = noErr;
  
    // Run the event loop
    RunApplicationEventLoop( );
  
Oops:  ;
  return result;
}  // main

/*****************************************************/
#pragma mark -
#pragma mark * local ( static ) function implementations *
//----------------------------------------------------

#pragma mark * AppleEvent Handlers * 
/*****************************************************
*
* Routine:  Handle_OpenApplicationAE( inAppleEvent, reply, inHandlerRefcon ) 
*
* Purpose:  AppleEvent handler for the kAEOpenApplication event
*
* Inputs:  inAppleEvent - the Apple event
*      reply - our reply to the Apple event
*      inHandlerRefcon - refcon passed to AEInstallEventHandler when this hander was installed
*
* Returns:  OSErr - error code ( 0 == no error ) 
*
*/
static pascal OSErr Handle_OpenApplicationAE( const AppleEvent * inAppleEvent, AppleEvent * outAppleEvent, long inHandlerRefcon )
{
  gAutoQuit = FALSE;  // this is NOT a drag-n-drop launch; disable auto-quit
  
  // if no windows are open then...
  WindowRef tWindowRef = GetFrontWindowOfClass( kDocumentWindowClass, TRUE );
  if ( !tWindowRef )
    Handle_NewWindow( ); // create an empty window
  return noErr;
}  // Handle_OpenApplicationAE

/*****************************************************
*
* Routine:  Handle_ReopenApplicationAE( inAppleEvent, reply, inHandlerRefcon ) 
*
* Purpose:  AppleEvent handler for the kAEReopenApplication event
*
* Inputs:  inAppleEvent - the Apple event
*      reply - our reply to the Apple event
*      inHandlerRefcon - refcon passed to AEInstallEventHandler when this hander was installed
*
* Returns:  OSErr - error code ( 0 == no error ) 
*
*/
static pascal OSErr Handle_ReopenApplicationAE( const AppleEvent * inAppleEvent, AppleEvent * outAppleEvent, long inHandlerRefcon )
{
  // We were already running but with no windows so we create an empty one.
  WindowRef tWindowRef = GetFrontWindowOfClass( kDocumentWindowClass, TRUE );
  if ( !tWindowRef )
    Handle_NewWindow( );
  return noErr;
}  // Handle_ReopenApplicationAE

/*****************************************************
*
* Routine:  Handle_OpenDocumentsAE( inAppleEvent, reply, inHandlerRefcon ) 
*
* Purpose:  AppleEvent handler for the kAEOpenDocuments event
*
* Inputs:  inAppleEvent - the Apple event
*      reply - our reply to the Apple event
*      inHandlerRefcon - refcon passed to AEInstallEventHandler when this hander was installed
*
* Returns:  OSErr - error code ( 0 == no error ) 
*
*/
static pascal OSErr Handle_OpenDocumentsAE( const AppleEvent * inAppleEvent, AppleEvent * outAppleEvent, long inHandlerRefcon )
{
  AEDescList documentsList;
  OSErr err = AEGetParamDesc( inAppleEvent, keyDirectObject, typeAEList, &amp;documentsList );
  require_noerr( err, Oops );
  
  err = Do_OpenDocs( documentsList );
  
  AEDisposeDesc( &amp;documentsList );
  
Oops:  ;
  
  if ( gAutoQuit ) {
    printf( &quot;Handle_OpenDocumentsAE, gAutoQuit.\n&quot; );
    QuitApplicationEventLoop( );
  }
  
  return err;
}  // Handle_OpenDocumentsAE

/*****************************************************
*
* Routine:  Handle_PrintDocumentsAE( inAppleEvent, reply, inHandlerRefcon ) 
*
* Purpose:  AppleEvent handler for the kAEPrintDocuments event
*
* Inputs:  inAppleEvent - the Apple event
*      reply - our reply to the Apple event
*      inHandlerRefcon - refcon passed to AEInstallEventHandler when this hander was installed
*
* Returns:  OSErr - error code ( 0 == no error ) 
*
*/
static pascal OSErr Handle_PrintDocumentsAE( const AppleEvent * inAppleEvent, AppleEvent * outAppleEvent, long inHandlerRefcon )
{
  return errAEEventNotHandled;
}  // Handle_PrintDocumentsAE

/*****************************************************
*
* Routine:  Install_AppleEventHandlers( void ) 
*
* Purpose:  installs the AppleEvent handlers
*
* Inputs:  none
*
* Returns:  OSErr - error code ( 0 == no error ) 
*
*/
static OSErr Install_AppleEventHandlers( void )
{
  OSErr  result;
  
  result = AEInstallEventHandler( kCoreEventClass, kAEOpenApplication, Handle_OpenApplicationAE, 0, FALSE );
  require_noerr( result, Oops );
  
  result = AEInstallEventHandler( kCoreEventClass, kAEReopenApplication, Handle_ReopenApplicationAE, 0, FALSE );
  require_noerr( result, Oops );
  
  result = AEInstallEventHandler( kCoreEventClass, kAEOpenDocuments, Handle_OpenDocumentsAE, 0, FALSE );
  require_noerr( result, Oops );
  
  result = AEInstallEventHandler( kCoreEventClass, kAEPrintDocuments, Handle_PrintDocumentsAE, 0, FALSE );
  require_noerr( result, Oops );
  
  // Note: Since RunApplicationEventLoop installs a Quit AE Handler, there is no need to do it here.
  
Oops:  ;
  
  return result;
}  // Install_AppleEventHandlers

#pragma mark -
#pragma mark * CarbonEvent Handlers *
//----------------------------------------------------


/*****************************************************
*
* Routine:  Handle_AppEvents( inCaller, inEvent, inRefcon ) 
*
* Purpose:  called to process commands from Carbon events
*
* Inputs:  inCaller - reference to the current handler call chain
*      inEvent - the event
*      inRefcon - app - specified data you passed in the call to InstallApplicationEventHandler ( NULL )
*
* Returns:  OSStatus - noErr indicates the event was handled
*                 eventNotHandledErr indicates the event was not handled and the Toolbox should take over
*
*/
static OSStatus Handle_AppEvents( EventHandlerCallRef inCaller, EventRef inEvent, void * inRefcon )
{
    OSStatus    result = eventNotHandledErr;

    UInt32 eventClass = GetEventClass( inEvent );
    UInt32 eventKind = GetEventKind( inEvent );
    
    switch ( eventClass ) {
        case kEventClassCommand: {
            HICommand tHICommand;
            verify_noerr( GetEventParameter( inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof( tHICommand ), NULL, &amp;tHICommand ) );
      
            switch ( eventKind ) {
                case kEventCommandProcess: {
                    switch ( tHICommand.commandID ) {
            case kHICommandPreferences:
              Handle_NewPrefWindow( );
              break;
                        case kHICommandNew: {
                            result = Handle_NewWindow( );
                            break;
            }
            case kRecentAppsMenuCMD:
            case kRecentFoldersMenuCMD:
            case kRecentDocsMenuCMD: {
              if ( kHICommandFromMenu &amp; tHICommand.attributes ) {
                FSRef tFSRef;
                OSStatus status = RecentItems_GetMenuItemFile( tHICommand.menu.menuRef, tHICommand.menu.menuItemIndex, &amp;tFSRef );
                if ( noErr == status ) {
                  HFSUniStr255 tHFSUniStr255;
                  FSGetCatalogInfo( &amp;tFSRef, kFSCatInfoNone, NULL, &amp;tHFSUniStr255, NULL, NULL );
                  
                  CFStringRef tCFStringRef = CFStringCreateWithCharacters( kCFAllocatorDefault, tHFSUniStr255.unicode, tHFSUniStr255.length );
                  if ( tCFStringRef ) {
                    char buffer[256];
                    CFStringGetCString( tCFStringRef, buffer, 256, kCFStringEncodingMacRoman );
                    
                    switch ( tHICommand.commandID ) {
                      case kRecentAppsMenuCMD: {
                        printf( &quot;Recent app menu item #%d: &lt;%s &gt; .\n&quot;, tHICommand.menu.menuItemIndex, buffer );
                        break;
                      }
                      case kRecentFoldersMenuCMD: {
                        printf( &quot;Recent folder menu item #%d: &lt;%s &gt; .\n&quot;, tHICommand.menu.menuItemIndex, buffer );
                        break;
                      }
                      case kRecentDocsMenuCMD: {
                        printf( &quot;Recent file menu item #%d: &lt;%s &gt; .\n&quot;, tHICommand.menu.menuItemIndex, buffer );
                        break;
                      }
                    }
                    CFRelease( tCFStringRef );
                    result = noErr;
                  }
                }
              }
                            break;
            }
#if TRUE
            case kRecentClearMenuCMD: {
              // clear all our recent items ( ignoring errors )
              ( void ) RecentItems_Clear( kRecentAppsPrefKey );
              ( void ) RecentItems_Clear( kRecentFoldersPrefKey );
              ( void ) RecentItems_Clear( kRecentDocsPrefKey );
              // after we've cleared all our prefs we repopulate our menus ( ignoring errors )
              ( void ) RecentItems_PopulateMenu( gRecentAppsMenuRef, kRecentAppsPrefKey, kRecentAppsMenuCMD );
              ( void ) RecentItems_PopulateMenu( gRecentFoldersMenuRef, kRecentFoldersPrefKey, kRecentFoldersMenuCMD );
              ( void ) RecentItems_PopulateMenu( gRecentDocsMenuRef, kRecentDocsPrefKey, kRecentDocsMenuCMD );
              break;
            }
#endif
            case kHICommandAbout:
            case kHICommandOpen:
            case kHICommandQuit:
            {
              // these are just here to prevent them from logging the &quot;unhandled commandID&quot; error below
              break;
            }
            // Add your own command handling cases here
              
            default: {
              if ( tHICommand.commandID &lt; '    ' ) {
                fprintf( stderr, &quot;%s: Unhandled commandID: %ld ( 0x % 08lX ).\n&quot;, __PRETTY_FUNCTION__, tHICommand.commandID, tHICommand.commandID );
              } else {
                fprintf( stderr, &quot;%s: Unhandled commandID: '%.4s'.\n&quot;, __PRETTY_FUNCTION__, &amp;tHICommand.commandID );
              }
              break;
            }
                    }
                    break;
        }
        case kEventCommandUpdateStatus: {
          // Note: You'll only get here if there aren't any windows open OR 
          // if Handle_WindowEvents returns eventNotHandledErr.
          switch ( tHICommand.commandID ) {
            case kHICommandAbout:
            case kHICommandPreferences:
            {
              EnableMenuItem( tHICommand.menu.menuRef, tHICommand.menu.menuItemIndex );
              break;
            }
            case kHICommandClose:
            case kHICommandSave:
            case kHICommandSaveAs:
            case kHICommandRevert:
            case kHICommandPageSetup:
            case kHICommandPrint:
            case kHICommandUndo:
            case kHICommandRedo:
            case kHICommandCut:
            case kHICommandCopy:
            case kHICommandPaste:
            case kHICommandClear:
            case kHICommandSelectAll:
            {
              DisableMenuItem( tHICommand.menu.menuRef, tHICommand.menu.menuItemIndex );
              break;
            }
          }
          break;
        }
        default: {
          fprintf( stderr, &quot;%s: Unhandled event { class: '%.4s', kind: '%.4s' }.\n&quot;, __PRETTY_FUNCTION__, &amp;eventClass, &amp;eventKind );
          break;
        }
            }
            break;
        }
        default: {
      fprintf( stderr, &quot;%s: Unhandled event { class: '%.4s', kind: '%.4s' }.\n&quot;, __PRETTY_FUNCTION__, &amp;eventClass, &amp;eventKind );
            break;
    }
    }
    return result;
}  // Handle_AppEvents

#pragma mark -
#pragma mark * Windows *
//----------------------------------------------------

/*****************************************************
*
* Routine:  Handle_NewWindow( ) 
*
* Purpose:  called create a new window
*
* Inputs:  none
*
* Returns:  OSErr - error code ( 0 == no error ) 
*
*/
static OSStatus Handle_NewWindow( void )
{
    OSStatus result;

    const EventTypeSpec    kWindowEvents[] = {
    { kEventClassCommand, kEventCommandProcess },     { kEventClassCommand, kEventCommandUpdateStatus },     };
  static EventHandlerUPP sWindowEventHandlerUPP = NULL;
  if ( !sWindowEventHandlerUPP ) {
    sWindowEventHandlerUPP = NewEventHandlerUPP( Handle_WindowEvents );
    assert( sWindowEventHandlerUPP );
  }
    
    // Create a window. &quot;MainWindow&quot; is the name of the window object. This name is set in 
    // InterfaceBuilder when the nib is created.
    WindowRef tWindowRef;
    result = CreateWindowFromNib( gMainIBNibRef, CFSTR( &quot;MainWindow&quot; ), &amp;tWindowRef );
    require_noerr( result, Oops );
  
    // Install a command handler on the window. We don't use this handler yet, but nearly all
    // Carbon apps will need to handle commands, so this saves everyone a little typing.
    result = InstallWindowEventHandler( tWindowRef, sWindowEventHandlerUPP,                       GetEventTypeCount( kWindowEvents ), kWindowEvents,                       tWindowRef, NULL );
    require_noerr( result, Oops );

#if USE_DRAG_N_DROP
  OSStatus status = noErr;

  do {  // basicly a TRY block
    HIViewRef tHIViewRef;
    status = HIViewFindByID( HIViewGetRoot( tWindowRef ), kDragNDropHID, &amp;tHIViewRef );
    if ( noErr != status ) break;

    dnd_data_ptr dnd_ptr = ( dnd_data_ptr ) malloc( sizeof( dnd_data_rec ) );
    if ( !dnd_ptr ) break;

    SetControlReference( tHIViewRef, ( SInt32 ) dnd_ptr );
    
    EventTypeSpec tDragEvents[] = {
    { kEventClassControl, kEventControlDraw },     { kEventClassControl, kEventControlDragEnter },       // { kEventClassControl, kEventControlDragWithin },     { kEventClassControl, kEventControlDragLeave },     { kEventClassControl, kEventControlDragReceive }
    };
    status = HIViewInstallEventHandler( tHIViewRef, Handle_DragEvents, GetEventTypeCount( tDragEvents ), tDragEvents, tHIViewRef, NULL );
    if ( noErr != status ) break;

    status = SetControlDragTrackingEnabled( tHIViewRef, TRUE );
    if ( noErr != status ) break;

  } while ( FALSE );

  // We want window and thus our custom view to be able to respond to drops
  status = SetAutomaticControlDragTrackingEnabledForWindow( tWindowRef, TRUE );
  require_noerr( status, Oops );
#endif USE_DRAG_N_DROP
  
    // Position new windows in a staggered arrangement on the main screen
    RepositionWindow( tWindowRef, NULL, kWindowCascadeOnMainScreen );

  // mark window as not modified
  SetWindowModified( tWindowRef, FALSE );

    // The window was created hidden, so show it
    ShowWindow( tWindowRef );
    
Oops:  ;
  return result;
}

/*****************************************************
*
* Routine:  Handle_WindowEvents( inCaller, inEvent, inRefcon ) 
*
* Purpose:  called to process our window events
*
* Inputs:  inCaller - reference to the current handler call chain
*      inEvent - the event
*      inRefcon - app - specified data you passed in the call to InstallApplicationEventHandler ( NULL )
*
* Returns:  OSStatus - noErr indicates the event was handled
*              eventNotHandledErr indicates the event was not handled and the Toolbox should take over
*
*/
static OSStatus Handle_WindowEvents( EventHandlerCallRef inCaller, EventRef inEvent, void * inRefcon )
{
  WindowRef  tWindowRef = ( WindowRef ) inRefcon;
    OSStatus    result = eventNotHandledErr;

    UInt32 eventClass = GetEventClass( inEvent );
    UInt32 eventKind = GetEventKind( inEvent );
  
    switch ( eventClass ) {
        case kEventClassCommand: {
            HICommand tHICommand;
            verify_noerr( GetEventParameter( inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof( tHICommand ), NULL, &amp;tHICommand ) );

      // Note: any command class events that return eventNotHandledErr here will be proprogated to Handle_AppEvents

      switch ( eventKind ) {
                case kEventCommandProcess: {
                    switch ( tHICommand.commandID ) {
                        // Add your own command handling cases here
            case kHICommandAbout:
            case kHICommandPreferences:
                        case kHICommandSelectWindow:
            case kHICommandOpen:
            case kHICommandClose:
            case kHICommandQuit:
            {
              // these are just here to prevent them from logging the &quot;unhandled commandID&quot; error below
              break;
            }
            default: {
              if ( tHICommand.commandID &lt; '    ' ) {
                fprintf( stderr, &quot;%s: Unhandled commandID: %ld ( 0x % 08lX ).\n&quot;, __PRETTY_FUNCTION__, tHICommand.commandID, tHICommand.commandID );
              } else {
                fprintf( stderr, &quot;%s: Unhandled commandID: '%.4s'.\n&quot;, __PRETTY_FUNCTION__, &amp;tHICommand.commandID );
              }
              break;
            }
                    }
                    break;
        }
        case kEventCommandUpdateStatus: {
          switch ( tHICommand.commandID )  {
            case kHICommandClose:
            case kHICommandSaveAs:
            case kHICommandPageSetup:
            case kHICommandPrint:
            {
              EnableMenuItem( tHICommand.menu.menuRef, tHICommand.menu.menuItemIndex );
              result = noErr;
              break;
            }
            case kHICommandSave:
            case kHICommandRevert:
            {
              if ( IsWindowModified( tWindowRef ) ) {
                EnableMenuItem( tHICommand.menu.menuRef, tHICommand.menu.menuItemIndex );
              } else {
                DisableMenuItem( tHICommand.menu.menuRef, tHICommand.menu.menuItemIndex );
              }
              result = noErr;
              break;
            }
            case kHICommandUndo:
            case kHICommandRedo:
            {
              if ( FALSE ) {
                EnableMenuItem( tHICommand.menu.menuRef, tHICommand.menu.menuItemIndex );
              } else {
                DisableMenuItem( tHICommand.menu.menuRef, tHICommand.menu.menuItemIndex );
              }
              result = noErr;
              break;
            }
          }    
          // FYI: the Edit menu is handled automatically by MLTE
          break;
        }
        default: {
          fprintf( stderr, &quot;%s: Unhandled event { class: '%.4s', kind: '%.4s' }.\n&quot;, __PRETTY_FUNCTION__, &amp;eventClass, &amp;eventKind );
          break;
        }
            }
            break;
        }
        default: {
      fprintf( stderr, &quot;%s: Unhandled event { class: '%.4s', kind: '%.4s' }.\n&quot;, __PRETTY_FUNCTION__, &amp;eventClass, &amp;eventKind );
            break;
    }
    }
    return result;
}  // Handle_WindowEvents

#if USE_DRAG_N_DROP
/*****************************************************
*
* Routine:  Handle_DragEvents( inCaller, inEvent, inRefcon ) 
*
* Purpose:  called to process commands from Carbon events
*
* Inputs:  inCaller - reference to the current handler call chain
*      inEvent - the event
*      inRefcon - data you passed in the call to InstallApplicationEventHandler ( our HIViewRef )
*
* Returns:  OSStatus - noErr indicates the event was handled
*              eventNotHandledErr indicates the event was not handled and the Toolbox should take over
*
*/
static OSStatus Handle_DragEvents( EventHandlerCallRef inCaller, EventRef inEvent, void * inRefcon )
{
  HIViewRef  tHIViewRef = ( HIViewRef ) inRefcon;
  
    OSStatus    result = eventNotHandledErr, status;
  
  dnd_data_ptr dnd_ptr = ( dnd_data_ptr ) GetControlReference( tHIViewRef );
  
  HIRect bounds;
  HIViewGetBounds( tHIViewRef, &amp;bounds );
  
    UInt32 eventClass = GetEventClass( inEvent );
    UInt32 eventKind = GetEventKind( inEvent );
  
    switch ( eventClass ) {
        case kEventClassControl: {
      switch ( eventKind ) {
        case kEventControlDraw: {
          CGContextRef tCGContextRef;
          status = GetEventParameter( inEvent, kEventParamCGContextRef, typeCGContextRef, NULL, sizeof( tCGContextRef ), NULL, &amp;tCGContextRef );
          require_noerr( status, Oops );
          
          if ( dnd_ptr-&gt;fDragging ) {
            CGContextSetRGBFillColor( tCGContextRef, 0.875f, 1.0f, 0.875f, 1.0f );
            CGContextFillRect( tCGContextRef, bounds );

            HIRect focusHIRect = CGRectInset( bounds, 2, 2 );
            HIThemeDrawFocusRect( &amp;focusHIRect, TRUE, tCGContextRef, kHIThemeOrientationNormal );
          } else {
            CGContextSetRGBFillColor( tCGContextRef, 1.0f, 1.0f, 0.875f, 1.0f );
            CGContextFillRect( tCGContextRef, bounds );
          }
          result = noErr;
          break;
        }  // case kEventControlDraw:
        case kEventControlDragEnter: {
          printf( &quot;kEventControlDragEnter\n&quot; );
          
          Boolean accept = TRUE;
          status = SetEventParameter( inEvent, kEventParamControlWouldAcceptDrop, typeBoolean, sizeof( accept ), &amp;accept );
          require_noerr( status, Oops );
          
          HIViewSetNeedsDisplay( tHIViewRef, TRUE );
          
          dnd_ptr-&gt;fDragging = TRUE;
          result = noErr;
          break;
        }  // case kEventControlDragEnter:
        case kEventControlDragWithin: {
          printf( &quot;kEventControlDragWithin\n&quot; );
          
          // the drag is being moved around within our custom view bounds
          // we determine the location in the view's local coordinate system and
          // ask for a refresh
          DragRef dragRef;
          status = GetEventParameter( inEvent, kEventParamDragRef, typeDragRef, NULL, sizeof( dragRef ), NULL, &amp;dragRef );
          require_noerr( status, Oops );
          
          Point mouse, globalMouse;
          status = GetDragMouse( dragRef, &amp;mouse, &amp;globalMouse );
          require_noerr( status, Oops );

          dnd_ptr-&gt;fHIPoint = CGPointMake( globalMouse.h, globalMouse.v );
          HIPointConvert( &amp;dnd_ptr-&gt;fHIPoint, kHICoordSpace72DPIGlobal, NULL, kHICoordSpaceView, tHIViewRef );

          if ( CGRectContainsPoint( bounds, dnd_ptr-&gt;fHIPoint ) ) {
            // myData-&gt;dragSpot = hiPoint;
            HIViewSetNeedsDisplay( tHIViewRef, true );
          }
          result = noErr;
          break;
        }  // case kEventControlDragWithin:
        case kEventControlDragLeave: {
          printf( &quot;kEventControlDragLeave\n&quot; );
          dnd_ptr-&gt;fDragging = FALSE;
          HIViewSetNeedsDisplay( tHIViewRef, TRUE );
          result = noErr;
          break;
        }  // case kEventControlDragLeave:
        case kEventControlDragReceive: {
          printf( &quot;kEventControlDragReceive\n&quot; );
          HIViewSetNeedsDisplay( tHIViewRef, TRUE );
          
          DragRef dragRef;
          status = GetEventParameter( inEvent, kEventParamDragRef, typeDragRef, NULL, sizeof( dragRef ), NULL, &amp;dragRef );
          require_noerr( status, Oops );
          
          PasteboardRef pasteBoard;
          status = GetDragPasteboard( dragRef, &amp;pasteBoard );
          require_noerr( status, Oops );
          
          // how many items in the pasteboard?
          ItemCount i, itemCount;
          status = PasteboardGetItemCount( pasteBoard, &amp;itemCount );
          require_noerr( status, Oops );
          
          // create an empty list
          AEDescList itemAEDescList;
          status = AECreateList( NULL, 0, FALSE, &amp;itemAEDescList );
          require_noerr( status, Oops );

          // let's loop on the items...
          for ( i = 1 ; i &lt;= itemCount ; i++ ) {
            PasteboardItemID itemID;
            CFArrayRef flavorTypeArray = NULL;
            CFIndex j, flavorCount = 0;
            
            status = PasteboardGetItemIdentifier( pasteBoard, i, &amp;itemID );
            require_noerr( status, Oops );
            
            // how many flavors in this item?
            status = PasteboardCopyItemFlavors( pasteBoard, itemID, &amp;flavorTypeArray );
            require_noerr( status, Oops );
            
            if ( flavorTypeArray ) {
              flavorCount = CFArrayGetCount( flavorTypeArray );
              
              // let's loop on the flavors
              for( j = 0;  j &lt; flavorCount ; j++ ) {
                CFDataRef flavorData;
                CFStringRef flavorType = ( CFStringRef )CFArrayGetValueAtIndex( flavorTypeArray, j );
                require_orelse_continue( flavorType );
                
                // CFShow( flavorType );
                require_orelse_continue(  UTTypeConformsTo( flavorType, kUTTypeFileURL )  ); // this is a file
                require_orelse_continue( PasteboardCopyItemFlavorData( pasteBoard, itemID, flavorType, &amp;flavorData ) == noErr );
                
                CFIndex flavorDataSize = CFDataGetLength( flavorData );
                // CFShow( flavorData );
                CFURLRef tCFURLRef = CFURLCreateWithBytes( kCFAllocatorDefault, CFDataGetBytePtr( flavorData ), flavorDataSize, kCFStringEncodingMacRoman, NULL );
                CFRelease( flavorData );
                if ( tCFURLRef ) {
                  FSRef tFSRef;
                  if ( CFURLGetFSRef( tCFURLRef, &amp;tFSRef ) ) {
                    // Add this FSRef to the end of our list
                    status = AEPutPtr( &amp;itemAEDescList, 0, typeFSRef, &amp;tFSRef, sizeof( FSRef ) );
                  }
                  CFRelease( tCFURLRef );
                }
              }
              CFRelease( flavorTypeArray );
            }
          }
          status = Do_OpenDocs( itemAEDescList );
          AEDisposeDesc( &amp;itemAEDescList );

          result = noErr;
          break;
        }  // case kEventControlDragReceive:
          
        default: {
          fprintf( stderr, &quot;%s: Unhandled event { class: '%.4s', kind: '%.4s' }.\n&quot;, __PRETTY_FUNCTION__, &amp;eventClass, &amp;eventKind );
          break;
        }
      }
      break;
        }  // case kEventClassControl:
    default: {
      fprintf( stderr, &quot;%s: Unhandled event { class: '%.4s', kind: '%.4s' }.\n&quot;, __PRETTY_FUNCTION__, &amp;eventClass, &amp;eventKind );
      break;
    }  // default:
    }  // switch ( eventClass )
Oops:  ;
  return result;
}  // Handle_DragEvents
#endif USE_DRAG_N_DROP

/*****************************************************/
#pragma mark -
#pragma mark * Preferences *
//----------------------------------------------------

/*****************************************************
*
* Routine:  Handle_NewPrefWindow( void ) 
*
* Purpose:  routine to display dialog to set our applications preferences
*
* Inputs:  none
*
* Returns:  none
*
*/
static void Handle_NewPrefWindow( void )
{
  // If the Preferences window is already open then just select it to make it front else
  // create a window. &quot;PrefWindow&quot; is the name of the window object. This name is set in 
  // InterfaceBuilder when the nib is created.
  if ( gPreferencesWindow ) {
    SelectWindow( gPreferencesWindow );
    return;
  }
  
  OSStatus status = CreateWindowFromNib( gMainIBNibRef, CFSTR( &quot;PrefWindow&quot; ), &amp;gPreferencesWindow );
  require_noerr( status, Oops );
  
  EventTypeSpec eventType1[] = {{kEventClassWindow, kEventWindowClose}};
  status = InstallWindowEventHandler( gPreferencesWindow, Handle_PrefWindowIsAboutToClose, GetEventTypeCount( eventType1 ), eventType1, NULL, NULL );
  require_noerr( status, Oops );
  
  EventTypeSpec eventType2[] = {{kEventClassCommand, kEventCommandProcess}};
  status = InstallWindowEventHandler( gPreferencesWindow, Handle_PrefCommandProcess, GetEventTypeCount( eventType2 ), eventType2, NULL, NULL );
  require_noerr( status, Oops );
  
  HIViewRef tHIViewRef;

  status = HIViewFindByID( HIViewGetRoot( gPreferencesWindow ), kOpenFoldersHID, &amp;tHIViewRef );
  require_noerr( status, Oops );
  SetControl32BitValue( tHIViewRef, gOpenFolderContents ? 1 : 0 );
  
  status = HIViewFindByID( HIViewGetRoot( gPreferencesWindow ), kOpenFoldersRecursiveHID, &amp;tHIViewRef );
  require_noerr( status, Oops );
  SetControl32BitValue( tHIViewRef, gOpenFolderRecursive ? 1 : 0 );
  if ( gOpenFolderContents ) EnableControl( tHIViewRef ); else DisableControl( tHIViewRef );
  
  status = HIViewFindByID( HIViewGetRoot( gPreferencesWindow ), kResolveAliasesHID, &amp;tHIViewRef );
  require_noerr( status, Oops );
  SetControl32BitValue( tHIViewRef, gResolveAliases ? 1 : 0 );
  
  status = HIViewFindByID( HIViewGetRoot( gPreferencesWindow ), kResolveAliasesChainsHID, &amp;tHIViewRef );
  require_noerr( status, Oops );
  SetControl32BitValue( tHIViewRef, gResolveAliasesChains ? 1 : 0 );
  if ( gResolveAliases ) EnableControl( tHIViewRef ); else DisableControl( tHIViewRef );
  
  ShowWindow( gPreferencesWindow );
  
Oops:  ;
}  // Handle_NewPrefWindow

/*****************************************************
*
* Routine:  Handle_PrefCommandProcess( inHandlerCallRef, inEvent, inUserData ) 
*
* Purpose:  called to process commands from the preferences window check boxes
*
* Inputs:  inHandlerCallRef - reference to the current handler call chain
*      inEvent - the event
*      inUserData - app - specified data you passed in the call to InstallWindowEventHandler ( NULL )
*
* Returns:  OSStatus - noErr indicates the event was handled
*                 eventNotHandledErr indicates the event was not handled and the Toolbox should take over
*
*/
static pascal OSStatus Handle_PrefCommandProcess( EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void * inUserData )
{
  OSStatus result = noErr;
  HIViewRef tHIViewRef;
  HICommand aCommand; 
  GetEventParameter( inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof( HICommand ), NULL, &amp;aCommand );
  
  switch ( aCommand.commandID ) {
    case kOpenFoldersHICommand:
      gOpenFolderContents = !gOpenFolderContents;
      result = HIViewFindByID( HIViewGetRoot( gPreferencesWindow ), kOpenFoldersRecursiveHID, &amp;tHIViewRef );
      if ( noErr != result ) break;
        if ( gOpenFolderContents ) EnableControl( tHIViewRef ); else DisableControl( tHIViewRef );
      break;
    case kOpenFoldersRecursiveHICommand:
      gOpenFolderRecursive = !gOpenFolderRecursive;
      break;
    case kResolveAliasesHICommand:
      gResolveAliases = !gResolveAliases;
      result = HIViewFindByID( HIViewGetRoot( gPreferencesWindow ), kResolveAliasesChainsHID, &amp;tHIViewRef );
      if ( noErr != result ) break;
        if ( gResolveAliases ) EnableControl( tHIViewRef ); else DisableControl( tHIViewRef );
      break;
    case kResolveAliasesChainsHICommand:
      gResolveAliasesChains = !gResolveAliasesChains;
      break;
    default:
      result = eventNotHandledErr;
      break;
  }
  if ( noErr == result ) {
    ( void ) Set_Preferences( );
  }
  
  return result;
}  // Handle_PrefCommandProcess

/*****************************************************
*
* Routine:  Handle_PrefWindowIsAboutToClose( inHandlerCallRef, inEvent, inUserData ) 
*
* Purpose:  called as notification that the preferences window is going to close
*
* Inputs:  inHandlerCallRef - reference to the current handler call chain
*      inEvent - the event
*      inUserData - app - specified data you passed in the call to InstallWindowEventHandler ( NULL )
*
* Returns:  OSStatus - noErr indicates the event was handled
*                 eventNotHandledErr indicates the event was not handled and the Toolbox should take over
*
*/
static pascal OSStatus Handle_PrefWindowIsAboutToClose( EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void * inUserData )
{
  gPreferencesWindow = NULL;
  
  // by returning eventNotHandledErr, we continue with the normal closing of the window
  return eventNotHandledErr;
}  // Handle_PrefWindowIsAboutToClose
/*****************************************************
*
* Routine:  Get_Preferences( ) 
*
* Purpose:  get's the users preferences
*
* Inputs:  none
*
* Returns:  none
*
*/
static void Get_Preferences( void )
{
  Boolean keyExistsAndHasValidFormat, tBoolean;
  
  tBoolean = CFPreferencesGetAppBooleanValue( kOpenFolderContentsPrefKey, kCFPreferencesCurrentApplication, &amp;keyExistsAndHasValidFormat );
  if ( keyExistsAndHasValidFormat ) {
    gOpenFolderContents = tBoolean;
  }
  
  tBoolean = CFPreferencesGetAppBooleanValue( kOpenFolderRecursivePrefKey, kCFPreferencesCurrentApplication, &amp;keyExistsAndHasValidFormat );
  if ( keyExistsAndHasValidFormat ) {
    gOpenFolderRecursive = tBoolean;
  }
  
  tBoolean = CFPreferencesGetAppBooleanValue( kResolveAliasesContentsPrefKey, kCFPreferencesCurrentApplication, &amp;keyExistsAndHasValidFormat );
  if ( keyExistsAndHasValidFormat ) {
    gResolveAliases = tBoolean;
  }
  
  tBoolean = CFPreferencesGetAppBooleanValue( kResolveAliasesChainsPrefKey, kCFPreferencesCurrentApplication, &amp;keyExistsAndHasValidFormat );
  if ( keyExistsAndHasValidFormat ) {
    gResolveAliasesChains = tBoolean;
  }
} // Get_Preferences
/*****************************************************
*
* Routine:  Set_Preferences( ) 
*
* Purpose:  Set's the users preferences
*
* Inputs:  none
*
* Returns:  OSErr - error code ( 0 == no error ) 
*
*/
static OSStatus Set_Preferences( void )
{
  OSStatus result = coreFoundationUnknownErr;
  CFPreferencesSetAppValue( kOpenFolderContentsPrefKey, gOpenFolderContents ? kCFBooleanTrue : kCFBooleanFalse, kCFPreferencesCurrentApplication );
  CFPreferencesSetAppValue( kOpenFolderRecursivePrefKey, gOpenFolderRecursive ? kCFBooleanTrue : kCFBooleanFalse, kCFPreferencesCurrentApplication );
  CFPreferencesSetAppValue( kResolveAliasesContentsPrefKey, gResolveAliases ? kCFBooleanTrue : kCFBooleanFalse, kCFPreferencesCurrentApplication );
  CFPreferencesSetAppValue( kResolveAliasesChainsPrefKey, gResolveAliasesChains ? kCFBooleanTrue : kCFBooleanFalse, kCFPreferencesCurrentApplication );

  // sync to disk
  if ( CFPreferencesAppSynchronize( kCFPreferencesCurrentApplication ) ) {
    result = noErr;
  }
  return result;
}

//****************************************************
#pragma mark -
#pragma mark * open document routines *
//----------------------------------------------------

/*****************************************************
*
* Routine:  Do_OpenDocs( inDocumentsList ) 
*
* Purpose:  open docs in inDocumentsList
*
* Notes:  called by Do_OpenWindows( ) ( &quot;File / Open&quot; menu item ) &amp; Handle_OpenDocuments( ) ( 'odoc' AppleEvent ) 
*
* Inputs:  inDocumentsList - list of AEObjects ( files ) 
*
* Returns:  OSStatus - error code ( 0 == no error ) 
*
*/
static OSStatus Do_OpenDocs( AEDescList inDocumentsList )
{
  long  firstCount;
  OSStatus result = AECountItems( &amp;inDocumentsList, &amp;firstCount );
  require_noerr( result, Oops );
  
  long idx, cnt = firstCount;
  for ( idx = 1; idx &lt;= cnt; idx++ ) {
    FSRef tFSRef;
    
    result = AEGetNthPtr( &amp;inDocumentsList, idx, typeFSRef, NULL, NULL, &amp;tFSRef, sizeof( FSRef ), NULL );
    require_orelse_continue( noErr == result );

    Boolean aliasFlag = FALSE;
    Boolean appFlag = FALSE;
    Boolean containerFlag = FALSE;

    do {
      LSItemInfoRecord tLSItemInfoRecord;
      result = LSCopyItemInfoForRef( &amp;tFSRef, kLSRequestAllFlags, &amp;tLSItemInfoRecord );
      require_orelse_continue( noErr == result );

      aliasFlag = appFlag = containerFlag = FALSE;

      if ( 0 == ( kLSItemInfoIsInvisible &amp; tLSItemInfoRecord.flags ) ) {  // not invisible
        if ( kLSItemInfoIsAliasFile &amp; tLSItemInfoRecord.flags ) {  // is an alias file
          if ( gResolveAliases ) {
            result = FSResolveAliasFileWithMountFlags( &amp;tFSRef, gResolveAliasesChains, &amp;containerFlag, &amp;aliasFlag, kResolveAliasFileNoUI );
            if ( noErr != result ) break;
            // TO-DO: test if tFSRef is container above the orginal alias file? ( to prevent infinite recurision )
            aliasFlag = TRUE;
          }
        } else if ( kLSItemInfoIsApplication &amp; tLSItemInfoRecord.flags ) {  // is an application
          appFlag = TRUE;
        } else if ( kLSItemInfoIsContainer &amp; tLSItemInfoRecord.flags ) {  // is a container
          containerFlag = TRUE;
        }
      }
    } while ( gResolveAliases &amp;&amp; aliasFlag );

#if TRUE // set true to printf items as we iterate over them
    HFSUniStr255 tHFSUniStr255;
    FSGetCatalogInfo( &amp;tFSRef, kFSCatInfoNone, NULL, &amp;tHFSUniStr255, NULL, NULL );

    CFStringRef tCFStringRef = CFStringCreateWithCharacters( kCFAllocatorDefault, tHFSUniStr255.unicode, tHFSUniStr255.length );
    if ( tCFStringRef ) {
      char buffer[256];
      CFStringGetCString( tCFStringRef, buffer, 256, kCFStringEncodingMacRoman );

      if ( appFlag ) {
        printf( &quot;#%6d of #%6d, App: &lt;%s&gt; .\n&quot;, idx, cnt, buffer );
      } else if ( containerFlag ) {
        printf( &quot;#%6d of #%6d, Folder: &lt;%s&gt; .\n&quot;, idx, cnt, buffer );
      } else {
        printf( &quot;#%6d of #%6d, File: &lt;%s&gt; .\n&quot;, idx, cnt, buffer );
      }
      CFRelease( tCFStringRef );
    }
#endif    
    
    if ( appFlag ) {
      result = RecentItems_Update( kRecentAppsPrefKey, &amp;tFSRef, idx == cnt );
      require_orelse_continue( noErr == result );
    } else if ( containerFlag ) {
      result = RecentItems_Update( kRecentFoldersPrefKey, &amp;tFSRef, idx == cnt );
      require_orelse_continue( noErr == result );
      
      if ( gOpenFolderContents ) {
        if ( gOpenFolderRecursive || ( idx &lt;= firstCount ) ) {
          Append_ContainerItemsToAEDescList( &amp;tFSRef, inDocumentsList );
          result = AECountItems( &amp;inDocumentsList, &amp;cnt );
          require_orelse_continue( noErr == result );
        }
      }
    } else {
      result = RecentItems_Update( kRecentDocsPrefKey, &amp;tFSRef, idx == cnt );
      require_orelse_continue( noErr == result );
    }
  }

  // after we've updated all our prefs we repopulate our menus ( Ignore errors )
  ( void ) RecentItems_PopulateMenu( gRecentAppsMenuRef, kRecentAppsPrefKey, kRecentAppsMenuCMD );
  ( void ) RecentItems_PopulateMenu( gRecentFoldersMenuRef, kRecentFoldersPrefKey, kRecentFoldersMenuCMD );
  ( void ) RecentItems_PopulateMenu( gRecentDocsMenuRef, kRecentDocsPrefKey, kRecentDocsMenuCMD );
  
Oops:  ;
  return result;
}  // Do_OpenDocs

/*****************************************************
*
* Routine:  Append_ContainerItemsToAEDescList( inFSRef, inDocumentsList ) 
*
* Purpose:  append all container items to AE desciptor list
*
* Inputs:  inFSRef - FSRef to container
*      inDocumentsList - AEDescList to append container items to
*
* Returns:  none
*
*/
static void Append_ContainerItemsToAEDescList( const FSRef * inFSRef, AEDescList inDocumentsList )
{
  long listCount;
  OSStatus status = AECountItems( &amp;inDocumentsList, &amp;listCount );
  require_noerr( status, Oops );
  
  FSRef * * tFSRefHdl;
  ItemCount idx, cnt;
  Boolean containerChanged;
  status = Get_ContainerItems( inFSRef, &amp;tFSRefHdl, &amp;cnt, &amp;containerChanged );
  require_noerr( status, Oops );

  for ( idx = 0; idx &lt; cnt; idx++ ) {
    FSRef tFSRef = ( *tFSRefHdl )[idx];
    ( void ) AEPutPtr( &amp;inDocumentsList, ++listCount, typeFSRef, &amp;tFSRef, sizeof( FSRef ) );
  }
Oops:  ;
  return;
}  // Append_ContainerItemsToAEDescList

/*****************************************************
*
* Routine:  Get_ContainerItems( inContainerFSRef, outFSRefHandle, outNumRefs, outContainerChanged ) 
*
* Purpose:  create a handle of FSRef's for all the items in the provided container FSRef
*
* Inputs:  inContainerFSRef - FSRef for the container
*      outFSRefHandle - address of handle of array of FSRef's
*      outNumRefs - number of FSRef's in output array ( handle )
*      outContainerChanged - Boolean, TRUE if container changes while being iterated
*
* Returns:  OSErr - error code ( 0 == no error ) 
*
*/
static OSErr Get_ContainerItems( const FSRef * inContainerFSRef, FSRef * **outFSRefHandle, ItemCount * outNumRefs, Boolean * outContainerChanged )
{
  // Grab items 16 at a time.
  enum { kMaxItemsPerBulkCall = 16 };
  
  OSErr    result;
  OSErr    memResult;
  FSIterator  iterator;
  FSRef    refs[kMaxItemsPerBulkCall];
  ItemCount  actualObjects;
  Boolean    changed;
  
  // check parameters
  require_action( ( outFSRefHandle ) &amp;&amp; ( outNumRefs ) &amp;&amp; ( outContainerChanged ), Oops, result = paramErr );
  
  *outNumRefs = 0;
  *outContainerChanged = FALSE;
  *outFSRefHandle = ( FSRef * * ) NewHandle( 0 );
  require_action( *outFSRefHandle, Oops, result = memFullErr );
  
  // open an FSIterator
  result = FSOpenIterator( inContainerFSRef, kFSIterateFlat, &amp;iterator );
  require_noerr( result, Oops );
  
  // Call FSGetCatalogInfoBulk in loop to get all items in the container
  do {
    result = FSGetCatalogInfoBulk( iterator, kMaxItemsPerBulkCall, &amp;actualObjects,                      &amp;changed, kFSCatInfoNone, NULL, refs, NULL, NULL );
    
    // if the container changed, set outContainerChanged for output, but keep going
    if ( changed ) {
      *outContainerChanged = changed;
    }
    
    // any result other than noErr and errFSNoMoreItems is serious
    require( ( noErr == result ) || ( errFSNoMoreItems == result ), Oops );
    
    // add objects to output array and count
    if ( actualObjects ) {
      // concatenate the FSRefs to the end of the   handle
      PtrAndHand( refs, ( Handle )*outFSRefHandle, actualObjects * sizeof( FSRef ) );
      memResult = MemError( );
      require_noerr_action( memResult, Oops, result = memResult );
      
      *outNumRefs += actualObjects;
    }
  } while ( noErr == result );
  
  verify_noerr( FSCloseIterator( iterator ) ); // closing an open iterator should never fail, but...
  
  return ( noErr );
  
  //===============================================
  
Oops:  ;
  
  // close the iterator
  verify_noerr( FSCloseIterator( iterator ) );
  
  // dispose of handle if already allocated and clear the outputs
  if ( *outFSRefHandle ) {
    DisposeHandle( ( Handle )*outFSRefHandle );
    *outFSRefHandle = NULL;
  }
  *outNumRefs = 0;
  
  return result;
}  // Get_ContainerItems
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/RecentItems/listing1.html%3Fid%3DDTS10003944-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/RecentItems/listing1.html%3Fid%3DDTS10003944-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/RecentItems/listing1.html%3Fid%3DDTS10003944-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>