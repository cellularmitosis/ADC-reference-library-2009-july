<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>CFPrefTopScores - /main.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxCoreFoundation-date.html">Core Foundation</a> &gt; <A HREF="javascript:location.replace('index.html');">CFPrefTopScores</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">CFPrefTopScores</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/main.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CFPreferences_SharedAppValue.c</option>
<option value="listing2.html">/CFPreferences_SharedAppValue.h</option>
<option value="listing3.html">/main.c</option></select>
				</p>
				</form>
				<p><strong><a href="CFPrefTopScores.zip">Download Sample</a></strong> (&#147;CFPrefTopScores.zip&#148;, 24.4K)<BR>
<strong><a href="CFPrefTopScores.dmg">Download Sample</a></strong> (&#147;CFPrefTopScores.dmg&#148;, 82.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//
//  File:       main.c
// 
//  Contains:   CFPreferences by design only allows write access to the kCFPreferencesAnyUser domain by a user
//        with admin privileges. But occasionally developers have had the need to store user preferences
//        that are both readable and writable by all users (without authorization). Currently the only 
//        location that meets this requirement is the &lt;/Users/Shared&gt; directory. This sample demonstrates
//        how this may be achieved utilizing Core Foundation API's.
//
//  Version:    1.0
// 
//  Created:    6/27/2006
//
//  Copyright:  Copyright  2006 Apple Computer, Inc., All Rights Reserved
// 
//  Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc. ( &quot;Apple&quot; ) in 
//              consideration of your agreement to the following terms, and your use, installation, modification 
//              or redistribution of this Apple software constitutes acceptance of these terms.  If you do 
//              not agree with these terms, please do not use, install, modify or redistribute this Apple 
//              software.
//
//              In consideration of your agreement to abide by the following terms, and subject to these terms,
//              Apple grants you a personal, non - exclusive license, under Apple's copyrights in this 
//              original Apple software ( the &quot;Apple Software&quot; ), to use, reproduce, modify and redistribute the 
//              Apple Software, with or without modifications, in source and / or binary forms; provided that if you 
//              redistribute the Apple Software in its entirety and without modifications, you must retain this 
//              notice and the following text and disclaimers in all such redistributions of the Apple Software. 
//              Neither the name, trademarks, service marks or logos of Apple Computer, Inc. may be used to 
//              endorse or promote products derived from the Apple Software without specific prior written 
//              permission from Apple.  Except as expressly stated in this notice, no other rights or 
//              licenses, express or implied, are granted by Apple herein, including but not limited to any 
//              patent rights that may be infringed by your derivative works or by other works in which the 
//              Apple Software may be incorporated.
//
//              The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO WARRANTIES, EXPRESS OR 
//              IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES OF NON - INFRINGEMENT, MERCHANTABILITY 
//              AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE 
//              OR IN COMBINATION WITH YOUR PRODUCTS.
//
//              IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR CONSEQUENTIAL 
//              DAMAGES ( INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
//              OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION ) ARISING IN ANY WAY OUT OF THE USE,
//              REPRODUCTION, MODIFICATION AND / OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER 
//              UNDER THEORY OF CONTRACT, TORT ( INCLUDING NEGLIGENCE ), STRICT LIABILITY OR OTHERWISE, EVEN 
//              IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// ****************************************************
#pragma mark -
#pragma mark * complation directives * 
// ----------------------------------------------------

#define kMaxNumHighScores 10

// ****************************************************
#pragma mark -
#pragma mark * includes &amp; imports * 
// ----------------------------------------------------

#include &lt;Carbon/Carbon.h&gt;
#include &lt;CoreFoundation/CFPreferences.h&gt;
#include &lt;stdio.h&gt; 

#include &quot;CFPreferences_SharedAppValue.h&quot;

// ****************************************************
#pragma mark -
#pragma mark * typedef's, struct's, enums, defines, etc. *
// ----------------------------------------------------

static const CFStringRef gCurrentApplicationID = CFSTR(&quot;com.apple.dts.sample.CFPrefTopScores&quot;);

#define kHighScoresKeyCFStr CFSTR( &quot;High Scores&quot; )

// ****************************************************
#pragma mark -
#pragma mark * local ( static ) function prototypes * 
// ----------------------------------------------------

static char * Copy_CFStringRefToCString( CFStringRef inCFStringRef );
static void HighScores_Dump( void );
static __inline__ int random_UInt32_between( UInt32 inStart, UInt32 inStop );
static Boolean HighScores_Update( const char * inPlayer, SInt32 inScore );
static Boolean HighScores_Reset( void );

// ****************************************************
#pragma mark -
#pragma mark * exported globals * 
// ----------------------------------------------------

// ****************************************************
#pragma mark -
#pragma mark * local ( static ) globals * 
// ----------------------------------------------------

// ****************************************************
#pragma mark -
#pragma mark * exported function implementations * 
// ----------------------------------------------------

// *****************************************************
//
//  Routine:    main ( )
//
//  Purpose:  Generates 100 random scores and attempts to add them to the high score preference
//
//  Inputs:     none
//
//  Returns:    int - error code ( 0 == no error )
//

int main( void )
{
    SInt32 idx;
    UInt32 score;
    Boolean again = TRUE;

    printf(&quot;Before: &quot;);
    HighScores_Dump( );
    
    while ( again ) {
        // generate one hundred random scores...
        for ( idx = 0; idx &lt; 100; idx++ ) {
            Str255  playerString;
            
            sprintf( ( Ptr ) playerString, &quot;Player #%.3ld&quot;, idx );
            
            score = random_UInt32_between( 0, 100000 );
      
            // update the high scores...
            // ... if our socre is a high score...
            if ( HighScores_Update( ( Ptr ) playerString, score ) ) {
                again = FALSE; // terminate outer loop
            }
        }
    
        // if we didn't generate any new high scores...
        if ( again ) {
            // ... reset the high scores list (pref)
      SysBeep( -1 );
            printf( &quot;Resetting the high scores list...\n&quot; );
            again = HighScores_Reset( );
        }
    }

    printf(&quot;After: &quot;);
    HighScores_Dump( );
    
    return 0;
}  // main

// ****************************************************
#pragma mark -
#pragma mark * local ( static ) function implementations * 
// ----------------------------------------------------

// *****************************************************
//
//  Routine:    Copy_CFStringRefToCString ( inCFStringRef )
//
//  Purpose:    return a C string from a CFString
//
//  Note:       If not NULL the result has to be free'd.
//
//  Inputs:     inCFStringRef - the CFString to extract the C string from
//
//  Returns:    char * - pointer to C string buffer or NULL on error
//

static char * Copy_CFStringRefToCString( CFStringRef inCFStringRef )
{
    char * result = NULL;
    
    if ( inCFStringRef ) {
        CFIndex length = sizeof( UniChar ) * CFStringGetLength( inCFStringRef ) + 1;
        
        result = ( char * ) calloc( 1, length );
        if ( result ) {
            if ( !CFStringGetCString( inCFStringRef, result, length, kCFStringEncodingASCII ) ) {
                if ( !CFStringGetCString( inCFStringRef, result, length, kCFStringEncodingUTF8 ) ) {
                    free( result );
                    result = NULL;
                }
            }
        }
    }
    return result;
}   // Copy_CFStringRefToCString

// *****************************************************
//
//  Routine:    random_UInt32_between ( inStart, inStop )
//
//  Purpose:    generate a random UInt32 between start &amp; stop ( inclusive )
//
//  Inputs:     inStart - UInt32 bottom of range
//              inStop  - UInt32 top of range
//
//  Returns:    UInt32  - the random number
//

static __inline__ int random_UInt32_between( UInt32 inStart, UInt32 inStop )
{
    UInt32 range = ( ( inStart &lt; inStop ) ? ( inStop - inStart ) : ( inStart - inStop ) ) + 1;
    static UInt32 seed = 0;
    
    if ( !seed ) {  // if the seed is zero...
        seed = CFAbsoluteTimeGetCurrent( );
        srandom( seed );
    }
    seed = range * ( ( float ) random( ) / ( float ) RAND_MAX );

    return ( ( inStart &lt; inStop ) ? inStart : inStop ) + seed;
}   // random_UInt32_between

// *****************************************************
//
//  Routine:    HighScores_Dump ( )
//
//  Purpose:    dump the high scores (duh!)
//
//  Inputs:     none
//
//  Returns:    none
//

static void HighScores_Dump( void )
{
  // get the current high scores
  CFArrayRef  prefCFArrayRef = CFPreferences_CopySharedAppValue( kHighScoresKeyCFStr, gCurrentApplicationID );
  
  if ( !prefCFArrayRef )
    return;
  
  // how many did we get?
  CFIndex countHighScores, idx;
  countHighScores = CFArrayGetCount( prefCFArrayRef );
  
  // print them out
  printf( &quot;The high scores are:\n&quot; );
  for ( idx = 0;idx &lt; countHighScores;idx++ ) {
    
    // get one of the high score elements
    CFArrayRef  dataCFArrayRef;
    dataCFArrayRef = CFArrayGetValueAtIndex( prefCFArrayRef, idx );
    if ( !dataCFArrayRef ) continue;
    
    // extract the players name...
        CFStringRef playerCFStringRef;
    playerCFStringRef = CFArrayGetValueAtIndex( dataCFArrayRef, 0 );
        if ( !playerCFStringRef ) continue;
        char *  playerStrPtr = Copy_CFStringRefToCString( playerCFStringRef );
        if ( !playerStrPtr ) continue;
        
    // and their score
    SInt32      score = 0;
        CFNumberRef scoreCFNumberRef = CFArrayGetValueAtIndex( dataCFArrayRef, 1 );
        if ( scoreCFNumberRef ) {
      if ( !CFNumberGetValue( scoreCFNumberRef, kCFNumberSInt32Type, &amp;score ) ) {
        score = 0;
      }
    }

    // ... and the date of their hi score.
    CFDateRef tCFDateRef = NULL;
    if ( CFArrayGetCount( dataCFArrayRef ) &gt;= 3 ) {
      tCFDateRef = CFArrayGetValueAtIndex( dataCFArrayRef, 2 );
    }
    
    // if we got a date
    char * dateStrPtr = nil;
    if ( tCFDateRef ) {
      // make sure it's the write type...
      assert( CFGetTypeID( tCFDateRef ) == CFDateGetTypeID( ) );
      
      // use this to convert to local date / time / format
      CFLocaleRef tCFLocaleRef = CFLocaleCopyCurrent( );
      assert( tCFLocaleRef );
      
      // create a local formatter
      CFDateFormatterRef tCFDateFormatterRef = CFDateFormatterCreate( kCFAllocatorDefault, tCFLocaleRef, kCFDateFormatterMediumStyle, kCFDateFormatterMediumStyle );
      assert( tCFDateFormatterRef );
      CFRelease( tCFLocaleRef );
      
      // now convert our CFDate( /time ) to a CFString ( using the formatter )
      CFStringRef dateCFStringRef = CFDateFormatterCreateStringWithDate( kCFAllocatorDefault, tCFDateFormatterRef, tCFDateRef );
      assert( dateCFStringRef );
      CFRelease( tCFDateFormatterRef );
      
      // and extract our C string from that
      dateStrPtr = Copy_CFStringRefToCString( dateCFStringRef );
      CFRelease( dateCFStringRef );
    }
    
    // if the player string is valid...
    if ( playerStrPtr ) {
      // ... and the date string is valid...
      if ( dateStrPtr ) {
        // ... print out the player, score and date
        printf( &quot;\t%ld\t\&quot;%s\&quot;\t%ld\t%s\n&quot;, idx, playerStrPtr, score, dateStrPtr );
        // and free our date string memory
        free( dateStrPtr );
      } else {    // ... otherwise ...
            // print out our player and score ( no date )
        printf( &quot;\t%ld\t\&quot;%s\&quot;\t%ld\n&quot;, idx, playerStrPtr, score );
      }
      // free the player's string
      free( playerStrPtr );
    }
  }
  CFRelease( prefCFArrayRef );
}  // HighScores_Dump

// *****************************************************
//
//  Routine:    HighScores_Update ( inPlayer, inScore )
//
//  Purpose:    update the saved high scores
//
//  Inputs:     inPlayer - char * pointer to players name
//              inScore - SInt32 score
//
//  Returns:    TRUE if it's a new high score
//

static Boolean HighScores_Update( const char * inPlayer, SInt32 inScore )
{
    // get the high scores
  CFArrayRef  prefCFArrayRef = CFPreferences_CopySharedAppValue( kHighScoresKeyCFStr, gCurrentApplicationID );
  Boolean     dirty = FALSE;
  
   // If prefs don't exist or aren't of the correct type...
  if ( !prefCFArrayRef || ( CFArrayGetTypeID() != CFGetTypeID( prefCFArrayRef ) ) ) {
    //  ...create a new empty array for high scores
    prefCFArrayRef = CFArrayCreate( kCFAllocatorDefault, NULL, 0, &amp;kCFTypeArrayCallBacks );
    dirty = TRUE;
  }
  
  // how many high scores are there?
  CFIndex     countHighScores;
  countHighScores = CFArrayGetCount( prefCFArrayRef );
  if ( countHighScores &gt; kMaxNumHighScores ) {
    countHighScores = kMaxNumHighScores;
  } else if ( countHighScores &lt; kMaxNumHighScores ) {
    dirty = TRUE;
  }
  
  CFArrayRef  dataCFArrayRef = NULL;
  CFStringRef playerCFStringRef;  // the player's name 
  CFNumberRef scoreCFNumberRef;   // the player's score

  // for each of the existing high scores
  UInt32      idx;
    for ( idx = 0; idx &lt; countHighScores; idx++ ) {
    SInt32      score;
    
    // extract the high score data
    dataCFArrayRef = CFArrayGetValueAtIndex( prefCFArrayRef, idx );
    if ( !dataCFArrayRef ) break;
    
    // extract the score
    scoreCFNumberRef = CFArrayGetValueAtIndex( dataCFArrayRef, 1 );
    if ( !CFNumberGetValue( scoreCFNumberRef, kCFNumberSInt32Type, &amp;score ) )
      score = 0;
    
    if ( score &lt; inScore )    // if our score is higher than this score...
      break;
  }
  
  // if dirty ( new array or count &lt; max ) or our score is higher than a score in the list
  if ( dirty || ( idx &lt; countHighScores ) ) {
    void *   data[3];
    
    // create player name &amp; score CF types
        playerCFStringRef = CFStringCreateWithCString( kCFAllocatorDefault, inPlayer, kCFStringEncodingASCII );
    scoreCFNumberRef = CFNumberCreate( kCFAllocatorDefault, kCFNumberSInt32Type, &amp;inScore );
    
    // create current date / time
    CFAbsoluteTime tCFAbsoluteTime = CFAbsoluteTimeGetCurrent( );
    CFDateRef tCFDateRef = CFDateCreate( kCFAllocatorDefault, tCFAbsoluteTime );
    
    data[0] = ( void * ) playerCFStringRef;
    data[1] = ( void * ) scoreCFNumberRef;
    data[2] = ( void * ) tCFDateRef;
    
    // create an array of the name / score pair
    dataCFArrayRef = CFArrayCreate( kCFAllocatorDefault, ( void * ) data, 3, &amp;kCFTypeArrayCallBacks );

    CFRelease( playerCFStringRef );
    CFRelease( scoreCFNumberRef );
    CFRelease( tCFDateRef );
    
    // create a mutable copy of our high score array
    CFMutableArrayRef tCFMutableArrayRef;
    tCFMutableArrayRef = CFArrayCreateMutableCopy( kCFAllocatorDefault, kMaxNumHighScores, prefCFArrayRef );
    
    // If we're replacing the last entry delete it first
    if ( countHighScores == kMaxNumHighScores ) {
      CFArrayRemoveValueAtIndex( tCFMutableArrayRef, kMaxNumHighScores - 1 );
    }
    
    // insert our new name / score / date pair into the prefs array
    CFArrayInsertValueAtIndex( tCFMutableArrayRef, idx, dataCFArrayRef );
    CFRelease( dataCFArrayRef );
    
    // now save it back into our prefs file
    dirty = CFPreferences_SetSharedAppValue( kHighScoresKeyCFStr, tCFMutableArrayRef, gCurrentApplicationID );
    if ( !dirty ) {
      fprintf( stderr, &quot;HighScores_Update: Preferences NOT saved.\n&quot; );  fflush( stderr );
    }
#if FALSE
    // this is what doesn't work unless you have write priv's (admin?) to &quot;/Library/Preferences&quot;
    CFPreferencesSetValue( kHighScoresKeyCFStr, tCFMutableArrayRef, gCurrentApplicationID, kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
    if ( !CFPreferencesSynchronize( gCurrentApplicationID, kCFPreferencesAnyUser, kCFPreferencesCurrentHost) ) {
      fprintf( stderr, &quot;\nHighScores_Update: Global CF Preferences NOT saved.&quot; );  fflush( stderr );
    }
#endif
    CFRelease( tCFMutableArrayRef );
  }
  CFRelease( prefCFArrayRef );

  return dirty;
}  // HighScores_Update

// *****************************************************
//
//  Routine:    HighScores_Reset ( )
//
//  Purpose:    reset the saved high scores
//
//  Inputs:     none
//
//  Returns:    TRUE if successful
//

static Boolean HighScores_Reset( void )
{
    // NULL is passed to delete this preference
  Boolean result =  CFPreferences_SetSharedAppValue( kHighScoresKeyCFStr, NULL, gCurrentApplicationID );
#if FALSE
  CFPreferencesSetValue( kHighScoresKeyCFStr, NULL, gCurrentApplicationID, kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
  if ( !CFPreferencesSynchronize( gCurrentApplicationID, kCFPreferencesAnyUser, kCFPreferencesCurrentHost ) ) {
    fprintf( stderr, &quot;HighScores_Reset: Global CF Preferences NOT saved.\n&quot; ); fflush( stderr );
  }
#endif FALSE
  return result;
}   // HighScores_Reset
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/CFPrefTopScores/listing3.html%3Fid%3DDTS10003414-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/CFPrefTopScores/listing3.html%3Fid%3DDTS10003414-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/CFPrefTopScores/listing3.html%3Fid%3DDTS10003414-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>