<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MovieAssembler - /MyDocument.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/AppleApplications/index.html">Apple Applications</a> &gt; <a href="../../samplecode/AppleApplications/idxFinalCutProFinalCutExpress-date.html">Final Cut Pro/Final Cut Express</a> &gt; <A HREF="javascript:location.replace('index.html');">MovieAssembler</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MovieAssembler</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MyDocument.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/apple_event.h</option>
<option value="listing2.html">/apple_event.m</option>
<option value="listing3.html">/AssemblerAppDelegate.h</option>
<option value="listing4.html">/AssemblerAppDelegate.m</option>
<option value="listing5.html">/FCP_AppleEvents.h</option>
<option value="listing6.html">/main.m</option>
<option value="listing7.html">/MyDocument.h</option>
<option value="listing8.html">/MyDocument.m</option>
<option value="listing9.html">/Readme-MovieAssembler.txt</option></select>
				</p>
				</form>
				<p><strong><a href="MovieAssembler.zip">Download Sample</a></strong> (&#147;MovieAssembler.zip&#148;, 573.6K)<BR>
<strong><a href="MovieAssembler.dmg">Download Sample</a></strong> (&#147;MovieAssembler.dmg&#148;, 996.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*

File: MyDocument.m

Abstract:   Document delegate class implementation for example
      application (MovieAssembler).  This class manages
      the the document UI, drives the watchfolder handling
      and initiates communication with the target instance
      of Final Cut Pro.

Version: 1.0

Disclaimer: IMPORTANT:  This Apple software is supplied to you by
Apple, Inc. (&quot;Apple&quot;) in consideration of your agreement to the
following terms, and your use, installation, modification or
redistribution of this Apple software constitutes acceptance of these
terms.  If you do not agree with these terms, please do not use,
install, modify or redistribute this Apple software.

In consideration of your agreement to abide by the following terms, and
subject to these terms, Apple grants you a personal, non-exclusive
license, under Apple's copyrights in this original Apple software (the
&quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
Software, with or without modifications, in source and/or binary forms;
provided that if you redistribute the Apple Software in its entirety and
without modifications, you must retain this notice and the following
text and disclaimers in all such redistributions of the Apple Software. 
Neither the name, trademarks, service marks or logos of Apple, Inc. 
may be used to endorse or promote products derived from the Apple
Software without specific prior written permission from Apple.  Except
as expressly stated in this notice, no other rights or licenses, express
or implied, are granted by Apple herein, including but not limited to
any patent rights that may be infringed by your derivative works or by
other works in which the Apple Software may be incorporated.

The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.

IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

Copyright &copy; 2007 Apple, Inc., All Rights Reserved

*/ 

#import &quot;MyDocument.h&quot;
#import &quot;FCP_AppleEvents.h&quot;
#import &quot;apple_event.h&quot;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#import &lt;Cocoa/Cocoa.h&gt;
#import &lt;QTKit/QTKit.h&gt;


@implementation MyDocument

//----------------------------------------
- (id)init
{
    self = [super init];
    if (self) {
    
    // init member variables
    processingFiles = NO;
    theWatchTimer = NULL;
    workingProjectURL = NULL;
    activelyWatching = NO;
    }
    return self;
}

//----------------------------------------
- (void)dealloc
{
  // stop the watch folder timer if it's still running
  if (theWatchTimer)
  {
    [theWatchTimer invalidate];
    theWatchTimer = NULL;
  }
  
  // free saved project URL
  if (workingProjectURL)
    [workingProjectURL release];
  
  // call superclass
  [super dealloc];
}

//----------------------------------------
- (NSString *)windowNibName
{
    return @&quot;MyDocument&quot;;  // Override returning the nib file name of the document
}

//----------------------------------------
- (void)windowControllerDidLoadNib:(NSWindowController *) aController
{
    [super windowControllerDidLoadNib:aController];
  [self refreshCachedProjectData:YES];  // attempt to refresh the UI
}

//----------------------------------------
// write changes to the document file
- (BOOL)writeToURL:(NSURL *)absoluteURL ofType:(NSString *)typeName error:(NSError **)outError
{
  return (NO);  // we only support reading/opening of projects
}

//----------------------------------------
// read a movie file from the URL, creating a metadata cache
- (BOOL)readFromURL:(NSURL *)absoluteURL ofType:(NSString *)typeName error:(NSError **)outError
{
  // shared locals
  BOOL    success = YES;
  
  // is this a native project, or an XML file?
  if ([typeName isEqualToString:@&quot;fcpProjectType&quot;] == YES)
  {
    // mark as native and save URL
    workingProjectURL = [absoluteURL retain];

    // open project in FCP
    success = [self openProjectInFinalCutPro];
  }
  else
  {
    success = NO;  // unsupported type
  }

  // return results
    return (success);
}


//----------------------------------------
// browse for a new media folder path
- (IBAction)browseMediaFolder:(id)sender
{
  // bring up an open panel, filling the media field once it's done
  NSOpenPanel  *openPanel = [NSOpenPanel openPanel];
  [openPanel setTitle:@&quot;Select Media Folder&quot;];
  [openPanel setCanChooseDirectories:YES];
  [openPanel setCanChooseFiles:NO];
  if ([openPanel runModalForTypes:NULL] == NSOKButton)
    [mediaPathEdit setStringValue:[[openPanel filenames] objectAtIndex:0]];
}

//----------------------------------------
// browse for a new watch folder path
- (IBAction)browseWatchFolder:(id)sender
{
  // bring up an open panel, filling the media field once it's done
  NSOpenPanel  *openPanel = [NSOpenPanel openPanel];
  [openPanel setTitle:@&quot;Select Watch Folder&quot;];
  [openPanel setCanChooseDirectories:YES];
  [openPanel setCanChooseFiles:NO];
  if ([openPanel runModalForTypes:NULL] == NSOKButton)
    [watchPathEdit setStringValue:[[openPanel filenames] objectAtIndex:0]];
}


//----------------------------------------
// change the current target sequence
- (IBAction)selectTargetSequence:(id)sender
{
  // if the user selected the &quot;new sequence&quot; option, then make one
  if ([sender indexOfSelectedItem] == 0)
  {
    // bring up new sequence name panel
    [NSApp beginSheet: newSequenceNamePanel
        modalForWindow: [self windowForSheet]
        modalDelegate: nil
        didEndSelector: nil
        contextInfo: nil];
    [NSApp runModalForWindow: newSequenceNamePanel];
    // (dialog is running here)
    [NSApp endSheet: newSequenceNamePanel];
    [newSequenceNamePanel orderOut: self];
    
    // get string from dialog
    NSString *newSeqName = [newSequenceNameEdit stringValue];
    if ([newSeqName length] &lt;= 0)
      newSeqName = NULL;

    // only continue if we received a string
    if (newSeqName)
    {
      // read base file from bundle
      NSString * sourceSnippetPath = [NSString stringWithFormat:@&quot;%@/EmptySequence.xml&quot;, [[NSBundle mainBundle] resourcePath]];
      NSString * rawXMLString = [NSString stringWithContentsOfFile:sourceSnippetPath encoding:NSUTF8StringEncoding error:NULL];
      
      // only continue if we read the base xml file
      if (rawXMLString)
      {
        // construct XML snippet for the sequence
        NSMutableString *xmlSnippet = [[NSMutableString alloc] initWithCapacity:2048];
        [xmlSnippet appendString:rawXMLString];
        NSRange stringRange = {0, [xmlSnippet length]};
        [xmlSnippet replaceOccurrencesOfString:@&quot;NewEmptySequence&quot; withString:newSeqName options:NSCaseInsensitiveSearch range:stringRange];
        
        // send the sequence to Final Cut Pro
        apple_event *theEvent =  [[apple_event alloc] init];
        NSData  *finalData =  [NSData  dataWithBytes:[xmlSnippet UTF8String] 
                        length:[xmlSnippet lengthOfBytesUsingEncoding:NSUTF8StringEncoding]];

        [theEvent  create:kAEImportXMLToDocument  // Event: open a project file
              class:kFCPEventClass      // Class: FCP Events
              dest:kFCPEventClass];      // Destination: FCP Events

        [theEvent  projectfile:NULL        // no path (using URL)
              url:workingProjectURL      // project file (specified by URL)
              as:sendAsURL];          // send type (URL)

        [theEvent  sendXML:finalData];        // attach the XML Data
        
        // send the event
        [theEvent send];
      
        // add the new sequence to the end of the popup and select it
        [sequencePopup addItemWithTitle:newSeqName];
        [sequencePopup selectItemAtIndex:([sequencePopup numberOfItems]-1)];

        // log success
        [self recordLogText:@&quot;Succesfully created new sequence.&quot;];
      }
    }
  }
}

//----------------------------------------
// finish name panel
- (IBAction)closeSequenceNamePanel:(id)sender
{
    [NSApp stopModal];
}

//----------------------------------------
// start or stop monitoring of the watch folder, and the processing of events
- (IBAction)startStopMonitoring:(id)sender
{
  // locals
  BOOL  success = YES;

  // are we watching or not?
  if (activelyWatching == NO)
  {
    // validate paths
    NSFileManager *theFileManager = [NSFileManager defaultManager];
    NSString * curMediaPath = [mediaPathEdit stringValue];
    NSString * curWatchPath = [watchPathEdit stringValue];
    BOOL  pathIsFolder = NO;
    
    // does the media path exist, and is it a folder?
    if (curMediaPath == NULL || [curMediaPath length] &lt; 1)
    {
      [self recordLogText:@&quot;ERROR: Specified media path does not exist, aborting monitoring startup.&quot;];
      success = NO;
    }
    else if ([theFileManager fileExistsAtPath:curMediaPath isDirectory:&amp;pathIsFolder] == NO || pathIsFolder == NO)
    {
      [self recordLogText:@&quot;ERROR: Specified media path is not a folder, aborting monitoring startup.&quot;];
      success = NO;
    }
    
    // does the watch path exist?
    if (curWatchPath == NULL || [curWatchPath length] &lt; 1)
    {
      [self recordLogText:@&quot;ERROR: Specified watch path does not exist, aborting monitoring startup.&quot;];
      success = NO;
    }
    else if ([theFileManager fileExistsAtPath:curWatchPath isDirectory:&amp;pathIsFolder] == NO || pathIsFolder == NO)
    {
      [self recordLogText:@&quot;ERROR: Specified watch path is not a folder, aborting monitoring startup.&quot;];
      success = NO;
    }
    
    // attempt conversation with Final Cut Pro
    if (success == YES)
      success = [self openProjectInFinalCutPro];
        
    // start watch timer
    if (success == YES)
      if ((theWatchTimer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(watchFolderTimerMethod:) userInfo:NULL repeats:YES]) == NULL)
        success = NO;

    // reset state
    if (success == YES)
    {
      [mediaPathEdit setEnabled:NO];
      [mediaPathButton setEnabled:NO];
      [watchPathEdit setEnabled:NO];
      [watchPathButton setEnabled:NO];
    
      if (startStopButton)
        [startStopButton setTitle:@&quot;STOP&quot;];
      activelyWatching = YES;
      [self recordLogText:@&quot;Initiated watch folder monitoring.&quot;];
    }
    else
    {
      [self recordLogText:@&quot;ERROR: Failed to START monitoring watch folder.&quot;];
    }
  }
  else
  {
    // stop watch timer
    if (theWatchTimer)
    {
      [theWatchTimer invalidate];
      theWatchTimer = NULL;
    }

    // reset state
    if (success == YES)
    {
      [mediaPathEdit setEnabled:YES];
      [mediaPathButton setEnabled:YES];
      [watchPathEdit setEnabled:YES];
      [watchPathButton setEnabled:YES];

      if (startStopButton)
        [startStopButton setTitle:@&quot;START&quot;];
      activelyWatching = NO;
      [self recordLogText:@&quot;Ended watch folder monitoring.&quot;];
    }
    else
    {
      [self recordLogText:@&quot;ERROR: Failed to STOP monitoring watch folder.&quot;];
    }
  }
}

//----------------------------------------
// change the current target sequence
- (IBAction)refreshSequenceList:(id)sender
{
  [self refreshCachedProjectData:NO];  // refresh the sequence popup
}

//----------------------------------------
// add text to the log window
- (void)recordLogText:(NSString*)newLogText
{
  NSString * finalString = [[NSString alloc] initWithFormat:@&quot;%@ : %@\n&quot;, [[NSDate date] description], newLogText];

  if (actionLogEdit)
  {
     NSTextStorage *textStorage = [actionLogEdit textStorage];
     NSAttributedString *attribText = [[NSAttributedString alloc] initWithString:finalString];
     [textStorage insertAttributedString:attribText atIndex:0];
  }
}

//----------------------------------------
// open the current project in final cut pro - done when monitoring begins
- (BOOL)openProjectInFinalCutPro
{
  // allocate an apple event transmitter object
  apple_event *theEvent = [[apple_event alloc] init];

  [theEvent  create:kAEFCPOpenProjectFile  // Event: open a project file
        class:kFCPEventClass      // Class: FCP Events
        dest:kFCPEventClass];      // Destination: FCP Events

  [theEvent  projectfile:NULL        // no path (using URL)
        url:workingProjectURL      // project file (specified by URL)
        as:sendAsURL];          // send type (URL)
  
  // send the event
  [theEvent send];

  // return success
  return (YES);
}

//----------------------------------------
// get the xml from FCP for the project and scrape it for useful information
- (BOOL)refreshCachedProjectData:(BOOL)retrievePaths
{
  // locals
  BOOL      success = YES;
  NSData      *resultXMLData = NULL;
  NSMutableArray  *localSequenceInfoArray = NULL;
  
  // get XML data for the current project from FCP
  if (success == YES)
  {
    // allocate an apple event transmitter object
    apple_event *theEvent = [[apple_event alloc] init];

    [theEvent  create:kKGAEGetDocumentXML  // Event: get the xml for the project
          class:kFCPEventClass    // Class: FCP Events
          dest:kFCPEventClass];    // Destination: FCP Events

    [theEvent  projectfile:NULL      // no path (using URL)
          url:workingProjectURL    // project file (specified by URL)
          as:sendAsURL];        // send type (URL)
          
    [theEvent  version:@&quot;3.0&quot;];        // set desired XML version
    
    // send the event
    [theEvent send];
    
    // get the XML data
    resultXMLData = [theEvent getXMLResultTextData];
    if (resultXMLData == NULL)
      success = NO;
  }
  
  // scrape the XML data for sequence information
  if (success == YES) {
  
    NSError  *localError = NULL;
    NSXMLDocument *localXMLTreeRoot = [[NSXMLDocument alloc] initWithData:resultXMLData options:0 error:&amp;localError];
    
    if (localXMLTreeRoot == NULL)
    {
      success = NO;
    }
    else
    {
      NSEnumerator * seqEnumerator = NULL, *pathEnumerator = NULL;
      NSXMLNode * curElement = NULL, *nameElement = NULL;
      NSArray * foundSequences = NULL, *foundFiles = NULL, *foundNames = NULL;
      NSString *theSeqName = NULL;
      
      // find each sequence, storing it's name in our list
      if ((foundSequences = [localXMLTreeRoot objectsForXQuery:@&quot;.//sequence&quot; error:&amp;localError]) != NULL)
        if ((seqEnumerator = [foundSequences objectEnumerator]) != NULL)
        {
          localSequenceInfoArray = [NSMutableArray arrayWithCapacity:[foundSequences count]];
          while ((curElement = (NSXMLNode*) [seqEnumerator nextObject]))
            if ((foundNames = [curElement objectsForXQuery:@&quot;./name&quot; error:&amp;localError]))
              if ((nameElement = [foundNames objectAtIndex:0]) != NULL)
              {
                theSeqName = [nameElement stringValue];
                [localSequenceInfoArray addObject:theSeqName];
              }
        }
        
      // rebuild the sequence popup and set the selection
      [sequencePopup removeAllItems];
      [sequencePopup addItemWithTitle:@&quot;(create new sequence)&quot;];
      if ([localSequenceInfoArray count])
      {
        [sequencePopup addItemsWithTitles:localSequenceInfoArray];
        [sequencePopup selectItemAtIndex:1];
      }
      [self recordLogText:@&quot;Successfully rebuilt sequence list.&quot;];

      // deal with monitoring paths
      if (retrievePaths == YES)
      {
        NSString *foundMediaPath = NULL, *foundWatchPath = NULL;
        
        // scan the project for a media path, using the first movie file we find
        if ((foundFiles = [localXMLTreeRoot objectsForXQuery:@&quot;.//pathurl&quot; error:&amp;localError]) != NULL)
          if ((pathEnumerator = [foundFiles objectEnumerator]) != NULL)
            while ((curElement = (NSXMLNode*) [pathEnumerator nextObject]) &amp;&amp; foundMediaPath == NULL)
            {
              NSURL * candidateURL = [NSURL URLWithString:[curElement stringValue]];
              NSString * candidatePath = [candidateURL path];
              if ([[candidatePath pathExtension] caseInsensitiveCompare:@&quot;mov&quot;] == NSOrderedSame)
              {
                [self recordLogText:@&quot;Found media storage path in project.&quot;];
                foundMediaPath = [candidatePath stringByDeletingLastPathComponent];
              }
            }

        // infer media path
        if (foundMediaPath == NULL)
        {
          foundMediaPath = [[[workingProjectURL path] stringByDeletingLastPathComponent] stringByAppendingString:@&quot;/Media&quot;];
          [self recordLogText:@&quot;Inferred media storage path.&quot;];
        }
        
        // infer watch path
        if (foundWatchPath == NULL)
        {
          foundWatchPath = [[[workingProjectURL path] stringByDeletingLastPathComponent] stringByAppendingString:@&quot;/Incoming&quot;];
          [self recordLogText:@&quot;Inferred watch folder path.&quot;];
        }
        
        // update UI with paths
        if (foundMediaPath)  [mediaPathEdit setStringValue:foundMediaPath];
        if (foundWatchPath)  [watchPathEdit setStringValue:foundWatchPath];
      }
    }
  }
  
  // return results
  return (success);
}

//----------------------------------------
// timer callback method: check the watchfolder for files we haven't processed
- (void)watchFolderTimerMethod:(NSTimer*)theTimer
{
  // make sure we don't enter this twice
  if (processingFiles == NO)
  {
    // set timer semaphore
    processingFiles = YES;
  
    // look for files in the watch folder
    NSFileManager *theFileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *watchFolderEnumerator = [theFileManager enumeratorAtPath:[watchPathEdit stringValue]];
    NSString *curFilename = NULL;
    BOOL isFolder = NO;
    
    // walk the files, processing movie files
    while ((curFilename = [watchFolderEnumerator nextObject]))
    {
      NSString *sourcePath = [[watchPathEdit stringValue] stringByAppendingPathComponent:curFilename];
      [theFileManager fileExistsAtPath:sourcePath isDirectory:&amp;isFolder];
      if (isFolder == YES)
      {
        [watchFolderEnumerator skipDescendents];
      }
      else
      {
        // add to set to record as being tracked
        NSString  *cachedFilename = [NSString stringWithString:curFilename];

        // construct destination path, and check for existance
        NSString *destPath = [[mediaPathEdit stringValue] stringByAppendingPathComponent:cachedFilename];
        
        if ([theFileManager fileExistsAtPath:destPath] == NO)
        {
          NSWorkspace *theWorkspace = [NSWorkspace sharedWorkspace];
          int operationTag = -1;
          NSArray * theFileArray = [NSArray arrayWithObject:cachedFilename];
          struct stat  fileStats[2];
          
          // get the initial file modification stats
          memset(fileStats, 0, (sizeof(stat)*2));
          stat([sourcePath UTF8String], &amp;fileStats[0]);

          // while the time is changing, keep on waiting
          do
          {
            // log a message?
            if (fileStats[1].st_mtimespec.tv_sec != 0)
              NSLog(@&quot;new file in watchfolder is busy, retrying&quot;);

            // sleep for a second
            sleep(1);
            
            // get the new stats so we can compare to the old ones
            fileStats[0] = fileStats[1];
            stat([sourcePath UTF8String], &amp;fileStats[1]);
          }
          while (fileStats[0].st_mtimespec.tv_sec != fileStats[1].st_mtimespec.tv_sec);
          
          // perform the actual move operation
          if ([theWorkspace  performFileOperation:NSWorkspaceMoveOperation 
                      source:[watchPathEdit stringValue]
                      destination:[mediaPathEdit stringValue]
                      files:theFileArray
                      tag:&amp;operationTag] == YES &amp;&amp; operationTag &gt;= 0)
          {
            // log this file as being moved
            [self recordLogText:[NSString stringWithFormat:@&quot;Successfully moved %@ into media folder.&quot;, cachedFilename]];
            
            // attempt to add this file to the sequence/project we're monitoring
            [self processFileForProject:destPath];
          }
        }
      }
    }
    
    // reset timer semaphore
    processingFiles = NO;
  }
}

//----------------------------------------
// process file for project
- (BOOL)processFileForProject:(NSString *)newFilePath
{
  // locals
  BOOL      success = YES;
  NSData      *resultXMLData = NULL;
  NSString    *newClipID = NULL, *finalFilePathURL = NULL;
  
  
  // get the clip ID from the file
  if ((newClipID = [self readClipIDFromFile:newFilePath]) == NULL)
  {
    NSLog(@&quot;Unable to get ID for new file&quot;);
    return (NO);
  }
  else
  {
    NSURL * tempURL = [NSURL fileURLWithPath:newFilePath];
    finalFilePathURL = [tempURL absoluteString];
  }
  
  // get XML data for the current project from FCP
  if (success == YES)
  {
    // allocate an apple event transmitter object
    apple_event *theEvent = [[apple_event alloc] init];

    [theEvent  create:kKGAEGetDocumentXML  // Event: get the xml for the project
          class:kFCPEventClass    // Class: FCP Events
          dest:kFCPEventClass];    // Destination: FCP Events

    [theEvent  projectfile:NULL      // no path (using URL)
          url:workingProjectURL    // project file (specified by URL)
          as:sendAsURL];        // send type (URL)
          
    [theEvent  version:@&quot;3.0&quot;];        // set desired XML version
    
    // send the event
    [theEvent send];
    
    // get the XML data
    resultXMLData = [theEvent getXMLResultTextData];
    if (resultXMLData == NULL)
      success = NO;
  }
  
  // scrape the XML data for sequence information
  if (success == YES) {
  
    NSError  *localError = NULL;
    NSXMLDocument *localXMLTreeRoot = [[NSXMLDocument alloc] initWithData:resultXMLData options:0 error:&amp;localError];
    NSString * selSequenceTitle = [sequencePopup titleOfSelectedItem];
    NSXMLNode * workingSequence = NULL;
    
    if (localXMLTreeRoot == NULL)
    {
      success = NO;
    }
    else
    {
      NSEnumerator * seqEnumerator = NULL;
      NSXMLNode * curElement = NULL;
      NSArray * foundSequences = NULL;
      
      // find the sequence we need
      if ((foundSequences = [localXMLTreeRoot objectsForXQuery:@&quot;.//sequence&quot; error:&amp;localError]) != NULL)
        if ((seqEnumerator = [foundSequences objectEnumerator]) != NULL)
          while ((curElement = (NSXMLNode*) [seqEnumerator nextObject]) &amp;&amp; workingSequence == NULL)
            if ([[[[curElement objectsForXQuery:@&quot;./name&quot; error:&amp;localError] objectAtIndex:0] stringValue] compare:selSequenceTitle] == NSOrderedSame)
              workingSequence = curElement;
              
      // assuming we found the sequence, query the sequence for clipitems with the same name
      if (workingSequence != NULL)
      {
        NSMutableArray * sharedFileDefinitions = NULL;
        NSEnumerator * itemEnumerator = NULL;
        NSXMLElement * curClipItem = NULL;
        NSArray * foundClipItems = NULL;
        
        // walk clipitems with the specified clip ID for it's name
        NSString * clipItemSearchString = [NSString stringWithFormat:@&quot;.//clipitem[name=\&quot;%@\&quot;]&quot;, newClipID];
        if ((foundClipItems = [workingSequence objectsForXQuery:clipItemSearchString error:&amp;localError]) != NULL)
          if ((itemEnumerator = [foundClipItems objectEnumerator]) != NULL)
            while ((curClipItem = (NSXMLElement*) [itemEnumerator nextObject]))
            {
              // replace file definition
              NSXMLNode * nameElement = [NSXMLNode elementWithName:@&quot;name&quot; stringValue:newClipID];
              NSXMLNode * pathElement = [NSXMLNode elementWithName:@&quot;pathurl&quot; stringValue:finalFilePathURL];
              
              NSXMLElement * newFileElement = [[NSXMLElement alloc] initWithName:@&quot;file&quot;];
              [newFileElement addChild:nameElement];
              [newFileElement addChild:pathElement];
              
              // find the file definition for this item
              NSXMLElement * oldFile = [[curClipItem objectsForXQuery:@&quot;./file&quot; error:&amp;localError] objectAtIndex:0];
              unsigned int oldFileIndex = [oldFile index];

              // FIXUP! Deal with shared file definitions going away...
              if ([oldFile childCount] &gt; 0)
              {
                // alloc a mutable array if we don't have one...
                if (sharedFileDefinitions == NULL)
                  sharedFileDefinitions = [NSMutableArray arrayWithCapacity:4];
                  
                // add this file to the tracking array
                [sharedFileDefinitions addObject:oldFile];
              }
              
              // detach the old file definition and add a new file definition to this clipitem
              [oldFile detach];
              [curClipItem insertChild:newFileElement atIndex:oldFileIndex];
            }
        
        // deal with shared file definitions...
        if (sharedFileDefinitions)
        {
          NSEnumerator *oldFileEnumerator = NULL;
          NSXMLElement *curOldFileElement = NULL;
          NSXMLNode *fileIDAttribute = NULL;
          
          // for each &quot;old&quot; file, look for the first sparse usage of it (if any) and replace it with the full definition
          if ((oldFileEnumerator = [sharedFileDefinitions objectEnumerator]) != NULL)
            while ((curOldFileElement = (NSXMLElement*) [oldFileEnumerator nextObject]) != NULL)
              if ((fileIDAttribute = [curOldFileElement attributeForName:@&quot;id&quot;]) != NULL)
              {
                NSString * oldFileID = [fileIDAttribute stringValue];
                NSString * oldFileSearchString = [NSString stringWithFormat:@&quot;.//file[@id=\&quot;%@\&quot;]&quot;, oldFileID];
                NSArray * foundSeqFiles = [workingSequence objectsForXQuery:oldFileSearchString error:&amp;localError];
                
                // if we found at least one file, replace it
                if ([foundSeqFiles count] &gt; 0)
                {
                  NSXMLElement *replaceFileElement = [foundSeqFiles objectAtIndex:0];
                  NSXMLElement *replaceFileParent = (NSXMLElement*) [replaceFileElement parent];
                  unsigned int replaceFileIndex = [replaceFileElement index];
                  
                  // detach the old file and insert the new/old full file definition at it's location.
                  [replaceFileElement detach];
                  [replaceFileParent insertChild:curOldFileElement atIndex:replaceFileIndex];
                }
              }
        }

        // change updatebehavior in sequence
        [[[workingSequence objectsForXQuery:@&quot;./updatebehavior&quot; error:&amp;localError] objectAtIndex:0] setStringValue:@&quot;replaceiffound&quot;];
              
        // create new xml document
        NSXMLDocument *newTreeRoot = [[NSXMLDocument alloc] 
          initWithXMLString:@&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;&lt;!DOCTYPE xmeml&gt;&lt;xmeml version=\&quot;3\&quot;&gt;&lt;/xmeml&gt;&quot;
          options:0 error:&amp;localError];

        // add sequence to new document
        [workingSequence detach];
        NSXMLElement * newRootElement = [[newTreeRoot objectsForXQuery:@&quot;./xmeml&quot; error:&amp;localError] objectAtIndex:0];
        [newRootElement addChild:workingSequence];
        
        // send XML to final cut pro
        // send the sequence to Final Cut Pro
        apple_event *sendEvent =  [[apple_event alloc] init];
        NSData  *finalData =  [newTreeRoot XMLData];

        [sendEvent  create:kAEImportXMLToDocument  // Event: open a project file
              class:kFCPEventClass      // Class: FCP Events
              dest:kFCPEventClass];      // Destination: FCP Events

        [sendEvent  projectfile:NULL        // no path (using URL)
              url:workingProjectURL      // project file (specified by URL)
              as:sendAsURL];          // send type (URL)

        [sendEvent  sendXML:finalData];        // attach the XML Data
        
        // send the event
        [sendEvent send];
      }
      else
      {
        success = NO;
      }
    }
  }

  return (success);
}

//----------------------------------------
// read clip ID from media file
- (NSString*)readClipIDFromFile:(NSString *)filePath
{
  // locals
  NSString *  resultString = NULL;
  NSURL *    fileURL = NULL;
  QTMovie *  theMovie = NULL;
  NSError  *  theError = NULL;
  
  // open the movie from the path
  if ((fileURL = [NSURL fileURLWithPath:filePath]) != NULL)
    if ((theMovie = [QTMovie movieWithURL:fileURL error:&amp;theError]) != NULL)
    {
      QTMetaDataRef    curMetadataContainer = NULL;
      QTMetaDataItem    curMetadataItem = kQTMetaDataItemUninitialized;
      char        *keyName = CLIP_ID_METADATA_KEY;
      ByteCount      propValueSize = 0, propValueSizeUsed = 0;
      QTPropertyValueType  propType = kQTMetaDataTypeBinary;
      QTPropertyValuePtr  propValuePtr = NULL;

      QTCopyMovieMetaData([theMovie quickTimeMovie], &amp;curMetadataContainer);
      if (curMetadataContainer != NULL)
      {
        if (QTMetaDataGetNextItem(curMetadataContainer, kQTMetaDataStorageFormatQuickTime, 
          curMetadataItem, kQTMetaDataKeyFormatQuickTime, (UInt8*)keyName, (ByteCount)strlen(keyName), &amp;curMetadataItem) == noErr)
          if (QTMetaDataGetItemPropertyInfo(curMetadataContainer, curMetadataItem, kPropertyClass_MetaDataItem, 
            kQTMetaDataItemPropertyID_Value, &amp;propType, &amp;propValueSize, NULL) == noErr)
          {
            // alloc a buffer
            if ((propValuePtr = malloc(propValueSize+4)) != NULL)
            {
              // clear the pointer (just to be safe)
              memset(propValuePtr, 0, (propValueSize+4));

              // retrieve the value
              if (QTMetaDataGetItemProperty(curMetadataContainer, curMetadataItem, kPropertyClass_MetaDataItem, 
                kQTMetaDataItemPropertyID_Value, propValueSize, propValuePtr, &amp;propValueSizeUsed) == noErr)
                  resultString = [NSString stringWithCString:propValuePtr encoding:NSUTF8StringEncoding];

              // cleanup
              free(propValuePtr);
              propValuePtr = NULL;
            }
          }

        QTMetaDataRelease(curMetadataContainer);
        curMetadataContainer = NULL;
      }
    }

  // return results
  return (resultString);
}

@end
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MovieAssembler/listing8.html%3Fid%3DDTS10004133-1.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MovieAssembler/listing8.html%3Fid%3DDTS10004133-1.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MovieAssembler/listing8.html%3Fid%3DDTS10004133-1.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>