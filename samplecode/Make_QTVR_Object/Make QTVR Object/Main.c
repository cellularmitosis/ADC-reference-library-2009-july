//// 		This is sample code which will make QTVR object movies from Linear QuickTime movies.////		© 1991-1996 Apple Computer, Inc.  All rights reserved.//#include	"MakeQTVRObject.h"Boolean							gDone;AEAddressDesc					pSelfAddress;			// A self-addressed address descriptor recordProcessSerialNumber				pSelfPSN;				// This application's psnAEDesc							pnilDesc;	PrefInfo						gPrefInf;FSSpec 							gPrefSpec;void	main(){	gDone = false;	ToolBoxInit();	Splash();	MainLoop();	Cleanup();	ExitToShell();}/***** Show splash Dialog *****/void	Splash(){	DialogPtr	myDlg;	unsigned long	startSecs,currentSecs;		myDlg = GetNewDialog( kSplashDLOG, 0, (WindowPtr) -1);	DrawDialog (myDlg);	GetDateTime (&startSecs);	GetDateTime (&currentSecs);		while (currentSecs - startSecs < 2)			GetDateTime (&currentSecs);			DisposDialog( myDlg);}/*********Toolbox init*************/void	ToolBoxInit(){		InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	InitDialogs(nil);	InitCursor();	TEInit();	MaxApplZone();	AEInit();		MenuBarInit();		if(RetrievePrefs())		{		gDone = true;		return;		}	if(EnterMovies())		{		UserMessage("\pCould not initialize QuickTime.");		gDone = true;		return;		}		if(!RegisterComponentResourceFile(CurResFile(), 0))		{		UserMessage("\pCould not find the QuickTime VR components.");		gDone = true;		return;		}}/*********Initialize AppleEvents*************/void	AEInit(){	OSErr  err;		// Set up the self-addressed descriptor record.	pSelfPSN.highLongOfPSN = 0;	pSelfPSN.lowLongOfPSN = kCurrentProcess;		// Use this instead of GetCurrentProcess	err = AECreateDesc(typeProcessSerialNumber,(Ptr)&pSelfPSN,sizeof(ProcessSerialNumber),&pSelfAddress);		pnilDesc.descriptorType = typeNull;			// Initialize the global nil descriptor record.	pnilDesc.dataHandle = nil;		RegisterMyEvents() ;							// and finally register appleEvent handlers	}Boolean SupportsAEVT(void){	OSErr err;	long response;			err = Gestalt(gestaltAppleEventsAttr,&response);	if (err!=noErr)		{		UserMessage("\pDrag and drop will not work because I cannot find the AppleEvent manager.");		return false;		}			return (response && (response << gestaltAppleEventsPresent));}void RegisterMyEvents(void){	OSErr err;		if (!SupportsAEVT())		return;		err = AEInstallEventHandler(kCoreEventClass,kAEOpenApplication,NewAEEventHandlerProc(DoOpenApp),0L,false);	if (err!=noErr)		return;					err = AEInstallEventHandler(kCoreEventClass,kAEOpenDocuments,NewAEEventHandlerProc(DoOpenDoc),0L,false);	if (err!=noErr)		return;					err = AEInstallEventHandler(kCoreEventClass,kAEPrintDocuments,NewAEEventHandlerProc(DoPrintDoc),0L,false);	if (err!=noErr)		return;					err = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,NewAEEventHandlerProc(DoQuitApp),0L,false);	if (err!=noErr)		return;				}pascal	OSErr	DoOpenApp(AppleEvent	*theAppleEvent,AppleEvent *reply,long	RefCon){		return noErr;}pascal	OSErr	DoQuitApp(AppleEvent	*theAppleEvent,AppleEvent *reply,long	RefCon){	gDone = true;	return noErr;}pascal	OSErr	DoOpenDoc(AppleEvent	*theAppleEvent,AppleEvent *reply,long	RefCon){	FSSpec 		myFSS;	AEDescList	docList;	OSErr		err,				ignoreErr;	long		index,				itemsInList;	Size 		actualSize;	AEKeyword	keywd;	DescType	returnedType;		 *reply = *reply;	 RefCon = RefCon;	err = AEGetParamDesc(theAppleEvent,keyDirectObject,typeAEList,&docList);	if (err == noErr) {				// see how many descriptor items are in the list		// this is the number of documents we want to open		err = AECountItems(&docList,&itemsInList);		// now get each descriptor record from the list		// coerce the returned data to an FSSpec record, and		// open the asoociated file				for (index=1; index <= itemsInList && err == noErr; index++) {						err = AEGetNthPtr(	&docList, 								index,								typeFSS,								&keywd,								&returnedType,								(Ptr)&myFSS,								sizeof(myFSS),								&actualSize);				if (err == noErr)	{							FInfo		fndrInfo ;								// we now have a valid FSSpec to reference the file, we need to know 				// what type the file is to determine which file open function to call				// we can determine this from the finder info for the file								err = FSpGetFInfo( &myFSS, &fndrInfo );									// if we got that ok, then we switch on the file  				// type (we don't care about the creator type)											if (err == noErr)	{										switch( fndrInfo.fdType ) {						case 'MooV':							{							if(!OpenMovie(&myFSS) && gPrefInf.dropMode)								{								TimeValue	posterViewTime,frameDur;								MovieInstance	*theInstance;								FInfo			finderInfo;																err = HGetFInfo (myFSS.vRefNum, myFSS.parID, myFSS.name, &finderInfo);								if (err != noErr) break;								if(finderInfo.fdCreator == kQTVRPlayerCreatorType) break;																	theInstance = GetMovieInstanceFromWindow(FrontWindow());								GetMovieNextInterestingTime (theInstance->movie, nextTimeMediaSample, 0, nil, 0, 1, nil, &frameDur);								posterViewTime = MCGetCurrentTime (theInstance->movieController, nil);								gPrefInf.objectInfo.frameDuration = (short)frameDur;								ConvertTimeToPanUtil (posterViewTime, 														gPrefInf.objectInfo.frameDuration,														gPrefInf.objectInfo.numberOfColumns,														gPrefInf.objectInfo.numberOfRows,														gPrefInf.objectInfo.loopSize,														gPrefInf.objectInfo.startHPan,														gPrefInf.objectInfo.endHPan,														gPrefInf.objectInfo.startVPan,														gPrefInf.objectInfo.endVPan,														&gPrefInf.objectInfo.initialHPan, 														&gPrefInf.objectInfo.initialVPan);								SetQTVRObjectFileFormat1x0 (														theInstance->movie,														theInstance->movieResFile,														theInstance->movieResID,														theInstance->spec,														posterViewTime,														&gPrefInf.objectInfo);								CloseMovie(FrontWindow());								}							}							break ;						default:							gDone = true;							break ;					}				}			}		}				ignoreErr = AEDisposeDesc(&docList);	}	if(gPrefInf.dropMode) gDone = true;	return err ;}pascal	OSErr	DoPrintDoc(AppleEvent	*theAppleEvent,AppleEvent *reply,long	RefCon){	return noErr;}/***********MenuBarInit*********/void	MenuBarInit(){	SetMenuBar (GetNewMBar (128));	AddResMenu (GetMHandle (appleID), 'DRVR');	DrawMenuBar();	SetupMenus();}void SetupMenus (){	MenuHandle		mh;	WindowPtr		whichWindow;	MovieInstance	*theInstance;		whichWindow = FrontWindow();	theInstance = GetMovieInstanceFromWindow(whichWindow);		// Default File menu setup	mh = GetMHandle (fileID);	EnableItem (mh, iOpen);	EnDisItem  (mh, iClose, (whichWindow != nil));	EnableItem (mh, iDrop);	if(gPrefInf.dropMode) 	SetItemMark (mh, iDrop, checkMark);	else					SetItemMark (mh, iDrop, noMark);	EnableItem (mh, iSetPrefs);	EnableItem (mh, iQuit);		// Default Edit menu setup	mh = GetMHandle (editID);	DisableItem (mh, iCopy);	// Don't allow editing of Nav Movie.	DisableItem (mh, iUndo);	DisableItem (mh, iCut);	DisableItem (mh, iPaste);	DisableItem (mh, iClear);	EnDisItem (mh, iMakeObject,  (whichWindow != 0)  && theInstance);	EnDisItem (mh, iDeleteObject, (whichWindow != 0) && theInstance && theInstance->isObjectMovie);	EnDisItem (mh, iSetPoster,	 (whichWindow != 0) && theInstance && theInstance->isObjectMovie);	EnDisItem (mh, iShowPoster,   (whichWindow != 0) && theInstance && theInstance->isObjectMovie);}/***** Cleanup *****/void	Cleanup(){	WindowPtr	currWindow;		ExitMovies();		currWindow = FrontWindow();	while(currWindow)		{		CloseMovie(currWindow);		currWindow = FrontWindow();		}}