<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>PGPuam - /sources/PGPServerMemory.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxNetworking-date.html">Networking</a> &gt; <A HREF="javascript:location.replace('index.html');">PGPuam</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Networking/index.html" target="_blank">Reference Library > Networking</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">PGPuam</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/sources/PGPServerMemory.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/headers/AFPPackets.h</option>
<option value="listing2.html">/headers/AppleShare.h</option>
<option value="listing3.html">/headers/AppleShareFileServerRegistry.h</option>
<option value="listing4.html">/headers/AppleShareRegistry.h</option>
<option value="listing5.html">/headers/ClientUAM.h</option>
<option value="listing6.html">/headers/ICAPI.h</option>
<option value="listing7.html">/headers/ICCAPI.h</option>
<option value="listing8.html">/headers/ICComponentSelectors.h</option>
<option value="listing9.html">/headers/ICKeys.h</option>
<option value="listing10.html">/headers/ICTypes.h</option>
<option value="listing11.html">/headers/LibraryManager.h</option>
<option value="listing12.html">/headers/OAM.h</option>
<option value="listing13.html">/headers/OAMTypes.h</option>
<option value="listing14.html">/headers/RegisterFileLibs.h</option>
<option value="listing15.html">/headers/UAM.h</option>
<option value="listing16.html">/In process/dumpuserInfo.c</option>
<option value="listing17.html">/sources/ASIPChallenge.cp</option>
<option value="listing18.html">/sources/ASIPChallenge.h</option>
<option value="listing19.html">/sources/clientUAMGlue.c</option>
<option value="listing20.html">/sources/FatCR PPC.r</option>
<option value="listing21.html">/sources/LaunchApplication.c</option>
<option value="listing22.html">/sources/LaunchApplication.h</option>
<option value="listing23.html">/sources/machdepnetmacros.h</option>
<option value="listing24.html">/sources/PassphraseCache.c</option>
<option value="listing25.html">/sources/PassphraseCache.h</option>
<option value="listing26.html">/sources/PGPServerMemory.cp</option>
<option value="listing27.html">/sources/PGPServerMemory.h</option>
<option value="listing28.html">/sources/PGPserverUAM.c</option>
<option value="listing29.html">/sources/PGPUAM Client resources.r</option>
<option value="listing30.html">/sources/PGPuam Server Resources.r</option>
<option value="listing31.html">/sources/PGPUAMclient.c</option>
<option value="listing32.html">/sources/PGPUAMclient.h</option>
<option value="listing33.html">/sources/PGPUAMclientLoginDialog.c</option>
<option value="listing34.html">/sources/PGPUAMclientLoginDialog.h</option>
<option value="listing35.html">/sources/PGPUAMclientProtocol.c</option>
<option value="listing36.html">/sources/PGPUAMclientProtocol.h</option>
<option value="listing37.html">/sources/PGPUAMdefines.h</option>
<option value="listing38.html">/sources/PGPUAMDialogTest.c</option>
<option value="listing39.html">/sources/PGPUAMmsgFormat.c</option>
<option value="listing40.html">/sources/PGPUAMmsgFormat.h</option>
<option value="listing41.html">/sources/PPCGlue.c</option>
<option value="listing42.html">/sources/RemoveServerKey.c</option>
<option value="listing43.html">/sources/TAboutBoxPane.cp</option>
<option value="listing44.html">/sources/TAboutBoxPane.h</option>
<option value="listing45.html">/sources/TASIPKeyPane.cp</option>
<option value="listing46.html">/sources/TASIPKeyPane.h</option>
<option value="listing47.html">/sources/TASIPPGPkey.cp</option>
<option value="listing48.html">/sources/TASIPPGPkey.h</option>
<option value="listing49.html">/sources/TMacException.h</option>
<option value="listing50.html">/sources/TMemPGPkey.cp</option>
<option value="listing51.html">/sources/TMemPGPkey.h</option>
<option value="listing52.html">/sources/TPane.h</option>
<option value="listing53.html">/sources/TPGPException.h</option>
<option value="listing54.html">/sources/TPGPkey.cp</option>
<option value="listing55.html">/sources/TPGPkey.h</option>
<option value="listing56.html">/sources/TPGPUAMPrefs.cp</option>
<option value="listing57.html">/sources/TPGPUAMPrefs.h</option>
<option value="listing58.html">/sources/TPrefs.cp</option>
<option value="listing59.html">/sources/TPrefs.h</option>
<option value="listing60.html">/sources/TSetupPane.cp</option>
<option value="listing61.html">/sources/TSetupPane.h</option></select>
				</p>
				</form>
				<p><strong><a href="PGPuam.zip">Download Sample</a></strong> (&#147;PGPuam.zip&#148;, 803.2K)<BR>
<strong><a href="PGPuam.dmg">Download Sample</a></strong> (&#147;PGPuam.dmg&#148;, 1.12M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//  PGPServerMemory.cp -  AppleShare IP memory management// // Apple Macintosh Developer Technical Support// Written by:  Vinne Moscaritolo////  Copyright (work in progress)  Apple Computer, Inc All rights reserved.//// You may incorporate this sample code into your applications without// restriction, though the sample code has been provided &quot;AS IS&quot; and the// responsibility for its operation is 100% yours.  However, what you are// not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;// after having made changes. If you're going to re-distribute the source,// we require that you make it clear in the source that the code was// descended from Apple Sample Code, but that you've made changes.// #include &lt;OpenTransport.h&gt;  #define FIX_ASLM#include &lt;LibraryManager.h&gt;  #define PGP_MACINTOSH 1#include &quot;pgpErrors.h&quot;#include &quot;pgpKeys.h&quot;#include &quot;pgpMemoryMgr.h&quot;#include &quot;pgpUtilities.h&quot;#include &quot;pgpFeatures.h&quot;#include &quot;pgpHash.h&quot;#include &quot;pgpPublicKey.h&quot;#include &quot;TPGPException.h&quot;#include &quot;TMacException.h&quot;#include &quot;PGPServerMemory.h&quot;#define  OTAssert( _Msg_, _cond_)   ThrowMsgIfNot( _cond_, _Msg_)  // ---------------------------------------------------------------------------#pragma mark Local Globals?// ---------------------------------------------------------------------------static   Boolean           gVirtualMemoryisEnabled = false;static  PGPNewContextStruct     gContextInfo;static  PGPNewMemoryMgrStruct    gMemMgrInfo;static   unsigned long        gMemBytesUsed = 0;static   unsigned long        gMemSecureBytesUsed = 0;// ---------------------------------------------------------------------------#pragma mark Local Prototypes// ---------------------------------------------------------------------------static void *  MemoryAllocationProc ( PGPMemoryMgrRef mgr,                    PGPUserValue userValue,                    PGPSize requestSize,                     PGPMemoryMgrFlags flags );static  PGPError MemoryReallocationProc ( PGPMemoryMgrRef mgr,                      PGPUserValue userValue,                      void **allocation,                       PGPSize newAllocationSize,                      PGPMemoryMgrFlags flags,                       PGPSize existingSize );static  PGPError MemoryDeallocationProc ( PGPMemoryMgrRef mgr,                      PGPUserValue userValue,                      void *allocation,                       PGPSize allocationSize ); static   void*    MemorySecureAllocationProc ( PGPMemoryMgrRef mgr,                        PGPUserValue userValue,                        PGPSize requestSize,                         PGPMemoryMgrFlags flags,                             PGPBoolean *isNonPageable );            static PGPError   MemorySecureDeallocationProc ( PGPMemoryMgrRef mgr,                        PGPUserValue userValue,                        void *allocation,                         PGPSize allocationSize,                          PGPBoolean  wasLocked );                          static OSStatus InitOpenTransportWithMemoryLimit(void);#pragma mark -// ---------------------------------------------------------------------------static void *  MemoryAllocationProc ( PGPMemoryMgrRef mgr,                    PGPUserValue userValue,                    PGPSize requestSize,                     PGPMemoryMgrFlags flags )// ---------------------------------------------------------------------------//{//  DebugStr(&quot;\p Allocation&quot;);    void* p =  OTAllocMem(requestSize) ;    if(p) gMemBytesUsed+= requestSize;     if(!p) DebugStr(&quot;\p Allocation Failed&quot;);     return p;    }// ---------------------------------------------------------------------------static  PGPError MemoryReallocationProc ( PGPMemoryMgrRef mgr,                      PGPUserValue userValue,                      void **allocation,                       PGPSize newAllocationSize,                      PGPMemoryMgrFlags flags,                       PGPSize existingSize )// ---------------------------------------------------------------------------//{  void* p;//  DebugStr(&quot;\p Reallocation&quot;);    p =  OTAllocMem(newAllocationSize);   if(!p) DebugStr(&quot;\p Reallocation Failed&quot;);    if(!p)   {      OTFreeMem(p);    return(kPGPError_OutOfMemory);  }  else  {     gMemBytesUsed+= (newAllocationSize - existingSize);        OTMemcpy(p,  *allocation, existingSize);      OTFreeMem( *allocation );    *allocation = p;  }      return noErr;}                                    // ---------------------------------------------------------------------------static  PGPError MemoryDeallocationProc ( PGPMemoryMgrRef mgr,                      PGPUserValue userValue,                      void *allocation,                       PGPSize allocationSize )// ---------------------------------------------------------------------------//{//  DebugStr(&quot;\p Deallocation&quot;);    gMemBytesUsed-=allocationSize;     OTFreeMem( allocation );  return noErr;} // ---------------------------------------------------------------------------static   void*    MemorySecureAllocationProc ( PGPMemoryMgrRef mgr,                        PGPUserValue userValue,                        PGPSize requestSize,                         PGPMemoryMgrFlags flags,                             PGPBoolean *isNonPageable )// ---------------------------------------------------------------------------//{  void* p;   //  DebugStr(&quot;\p  Secure Allocation&quot;);    p =  OTAllocMem(requestSize);    if(!p) DebugStr(&quot;\p Secure Allocation Failed&quot;);      if(p)  {     if(gVirtualMemoryisEnabled)  HoldMemory(p, requestSize);     gMemSecureBytesUsed+=requestSize;  }   return(p);}            // ---------------------------------------------------------------------------static PGPError   MemorySecureDeallocationProc ( PGPMemoryMgrRef mgr,                        PGPUserValue userValue,                        void *allocation,                         PGPSize allocationSize,                          PGPBoolean  wasLocked )// ---------------------------------------------------------------------------//{//   DebugStr(&quot;\p  Secure Deallocation&quot;);      OTMemzero(allocation, allocationSize);   if(gVirtualMemoryisEnabled) UnholdMemory(allocation, allocationSize);   OTFreeMem( allocation );  gMemSecureBytesUsed-=allocationSize;    return noErr;}#pragma mark -// ---------------------------------------------------------------------------OSStatus InitializeServerMemory(  PGPMemoryMgrRef *memMgr )// ---------------------------------------------------------------------------//{  OSStatus err;    long response = 0;// Is virtual memory enabled?  Gestalt(gestaltVMAttr, &amp;response);  gVirtualMemoryisEnabled = (response &amp; (1UL &lt;&lt; gestaltVMPresent)) != 0;    // Setup opentransport for memory usage  err = InitOpenTransportWithMemoryLimit();  if(err != noErr) return err; // preallocate memory into heap.   OTFreeMem(OTAllocMem( 64 * 1024)); // setup custom PGP memory manager structure    gMemMgrInfo.sizeofStruct =   sizeof( PGPNewMemoryMgrStruct );  gMemMgrInfo.allocProc        =   MemoryAllocationProc;  gMemMgrInfo.reallocProc      =   MemoryReallocationProc;  gMemMgrInfo.deallocProc      =   MemoryDeallocationProc;  gMemMgrInfo.secureAllocProc    =   MemorySecureAllocationProc;  gMemMgrInfo.secureDeallocProc    =   MemorySecureDeallocationProc;  gMemMgrInfo.customValue      =   nil;  gMemMgrInfo.reserved  =   nil;  gMemMgrInfo.pad[0]  =   nil;  gMemMgrInfo.pad[1]  =   nil;  gMemMgrInfo.pad[2]  =   nil;  gMemMgrInfo.pad[3]  =   nil;  gMemMgrInfo.pad[4]  =   nil;  gMemMgrInfo.pad[5]  =   nil;  gMemMgrInfo.pad[6]  =   nil;  gMemMgrInfo.pad[7]  =   nil;   err = PGPNewMemoryMgrCustom( &amp;gMemMgrInfo, memMgr);    return err;}// ---------------------------------------------------------------------------void FinalizeServerMemory( PGPMemoryMgrRef memMgr )// ---------------------------------------------------------------------------//{  PGPFreeMemoryMgr(memMgr);  CloseOpenTransport();  CleanupLibraryManager();}#pragma mark -// from Quinn's StreamLogWatcher.c// // InitOpenTransportWithMemoryLimit Big Picture// --------------------------------------------//// The LogEngine uses the OT memory allocation routines// (OTAllocMem, OTFreeMem) to allocate space for log entries in// the notifier.  This memory comes from an ASLM memory pool// that OT creates for us when we call InitOpenTransport.  However,// this pool has some bad characteristics:////   1.  The pool starts off very small, and only grows when we allocate//     memory from it.  As we do all our allocation from our notifier//    (which is interrupt time with respect to the system Memory Manager)//    the pool can't grow immediately.  So the pool will often run//    be full (ie OTAllocMem will return nil) even though the application//    has plenty of memory.  The pool will later grow, but we've already//    dropped the log entry on the floor.////  2.  Because the pool starts off small and grows by pieces, we get//    an extremely fragmented pool.  While this works, its definitely//    sub-optimal.////  3.  If we're being hammered by strlog (ie people are calling strlog a//    lot), the pool will keep growing and there's nothing to stop//    the pool consuming our entire application heap.  When it does so,//    various toolbox routines (eg QuickDraw) fail ungracefully, ie//    SysError(25).//// There are a number of steps in my solution to this.  The first step// is to call InitLibraryManager myself.  This allows me to specify// the size of the pool. InitOpenTransport notices that I have inited ASLM// myself and doesn't do it itself.  Thus OTAllocMem gets its memory from// whatever pool ASLM created.  This gets around problems 1 and 2.//// The second step is to create a subsidiary zone within my application heap// and specify that ASLM should create its pool in that zone (by supplying// kCurrentZone to InitLibraryManager).  Thus the pool can grow up to the// point where the memory in the subsidiary zone is exhausted.  At that point,// the pool will no longer grow.  So the pool will not steal memory from// the main application heap.  This gets around problem 3.//// There are a number of other ways I could have achieved the same results.// The ASLM memory manager is very flexible.  For example, I could have removed// OT's TPoolNotifier from the pool, which would prevent the pool from growing.// However, this solution does not require me to use any ASLM C++ stuff,// which makes the code more compiler independent.enum {  kBytesReservedForToolboxInApplicationZone = 100L * 1024L,    // This value represents the minimum number of contiguous    // bytes that should remain in the application heap after    // we've created the subsidiary zone.      kBytesReservedForASLMInSubsidaryzone = 2048,    // This value represents the number of bytes in the subsidiary    // zone we should leave lying around for general purpose ASLM    // use.  The remaining bytes in the subsidiary zone are    // dedicated to the ASLM memory pool, ie are passed as the pool    // size to InitLibraryManager.      kMinimumBytesForUsInSubsidiaryZone = 10 * 1024    // This value represents the minimum pool size we pass to    // InitLibraryManager.  If we can't create a pool of at least    // this size, the application doesn't start up.};static OSStatus InitOpenTransportWithMemoryLimit(void)  // See above for an explanation of the big picture here.{  OSStatus err;  SInt32 junkTotalFree;  SInt32 contigFree;  SInt32 zoneSize;  Ptr gSubsidiaryZone;  THz oldZone;  // Debugger();    // First call the system Memory Manager to determine the largest  // contiguous block in the heap.    PurgeSpace(&amp;junkTotalFree, &amp;contigFree);    // If it's too small for our toolbox needs, bail out.    err = noErr;  if (contigFree &lt; kBytesReservedForToolboxInApplicationZone) {    err = memFullErr;  }    // Now calculate the size of the zone we're going to create.  // It's the size of the largest contiguous block, minus  // the size of we reserve for toolbox needs, rounded to the nearest KB.  // If the zone size isn't big enough enough to hold our minimum  // pool size and the amount we reserve for ASLM, bail out.    if (err == noErr) {    zoneSize = contigFree - kBytesReservedForToolboxInApplicationZone;    zoneSize = zoneSize &amp; ~0x003FF;    if (zoneSize &lt; (kBytesReservedForASLMInSubsidaryzone + kMinimumBytesForUsInSubsidiaryZone)) {      err = memFullErr;    }  }    // Allocate the memory for our zone and create a zone in that  // block.  Then init ASLM, telling it to create a pool that  // takes up the entire zone (minus the ASLM overhead factor)  // in the current zone, ie the zone we just created.  Finally,  // initialise OT.  OT will see that we've inited ASLM and use  // the pool that ASLM created (in the zone we created) for  // satisfying OTAllocMem requests.    if (err == noErr) {    gSubsidiaryZone = NewPtr(zoneSize);    OTAssert(&quot;InitOpenTransportWithMemoryLimit: Couldn't get the memory but preflight says its there&quot;, gSubsidiaryZone != nil);    OTAssert(&quot;InitOpenTransportWithMemoryLimit: Just being paranoid&quot;, MemError() == noErr);    oldZone = GetZone();    InitZone(nil, 16, gSubsidiaryZone + zoneSize, gSubsidiaryZone);    OTAssert(&quot;InitOpenTransportWithMemoryLimit: InitZone failed&quot;, MemError() == noErr);    // InitZone sets the current zone to the newly created zone,    // so I don't have to do it myself.            err = InitLibraryManager(zoneSize - kBytesReservedForASLMInSubsidaryzone, kCurrentZone, kNormalMemory);    if (err == noErr) {      err = InitOpenTransport();      if (err != noErr) {        CleanupLibraryManager();      }    }        SetZone(oldZone);  }    return err;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/PGPuam/listing26.html%3Fid%3DDTS10000259-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/PGPuam/listing26.html%3Fid%3DDTS10000259-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/PGPuam/listing26.html%3Fid%3DDTS10000259-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>