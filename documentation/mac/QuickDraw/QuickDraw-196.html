<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Summary of QuickDraw Drawing (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING196></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-195.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-197.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-58.html"><B>Chapter 3 - QuickDraw Drawing</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING196-0></A>
<H1>Summary of QuickDraw Drawing</H1>
<A NAME=HEADING196-1></A>
<H2>Pascal Summary</H2>
<A NAME=HEADING196-2></A>
<H3>Constants</H3>
<PRE>
CONST
   {basic QuickDraw colors}
   whiteColor     = 30;
   blackColor     = 33;
   yellowColor    = 69;
   magentaColor   = 137;
   redColor       = 205;
   cyanColor      = 273;
   greenColor     = 341;
   blueColor      = 409;

   {source modes for basic graphics ports}
   srcCopy        = 0;  {where source pixel is black, force destination }
                        { pixel black; where source pixel is white, force }
                        { destination pixel white}
   srcOr          = 1;  {where source pixel is black, force destination }
                        { pixel black; where source pixel is white, leave }
                        { destination pixel unaltered}
   srcXor         = 2;  {where source pixel is black, invert destination }
                        { pixel; where source pixel is white, leave }
                        { destination pixel unaltered}
   srcBic         = 3;  {where source pixel is black, force destination }
                        { pixel white; where source pixel is white, leave }
                        { destination pixel unaltered}
   notSrcCopy     = 4;  {where source pixel is black, force destination }
                        { pixel white; where source pixel is white, force }
                        { destination pixel black}
   notSrcOr       = 5;  {where source pixel is black, leave destination }
                        { pixel unaltered; where source pixel is white, }
                        { force destination pixel black}
notSrcXor      = 6;  {where source pixel is black, leave destination }
                        { pixel unaltered; where source pixel is white, }
                        { invert destination pixel}
   notSrcBic      = 7;  {where source pixel is black, leave destination }
                        { pixel unaltered; where source pixel is white, }
                        { force destination pixel white}

   {pattern modes}
   patCopy        = 8;  {where pattern pixel is black, apply foreground }
                        { color to destination pixel; where pattern pixel }
                        { is white, apply background color to destination }
                        { pixel}
   patOr          = 9;  {where pattern pixel is black, invert destination }
                        { pixel; where pattern pixel is white, leave }
                        { destination pixel unaltered}
   patXor         = 10; {where pattern pixel is black, invert destination }
                        { pixel; where pattern pixel is white, leave }
                        { destination pixel unaltered}
   patBic         = 11; {where pattern pixel is black, apply background }
                        { color to destination pixel; where pattern pixel }
                        { is white, leave destination pixel unaltered}
   notPatCopy     = 12; {where pattern pixel is black, apply background }
                        { color to destination pixel; where pattern pixel }
                        { is white, apply foreground color to destination }
                        { pixel}
   notPatOr       = 13; {where pattern pixel is black, leave destination }
                        { pixel unaltered; where pattern pixel is white, }
                        { apply foreground color to destination pixel}
   notPatXor      = 14; {where pattern pixel is black, leave destination }
                        { pixel unaltered; where pattern pixel is white, }
                        { invert destination pixel}
   notPatBic      = 15; {where pattern pixel is black, leave destination }
                        { pixel unaltered; where pattern pixel is white, }
                        { apply background color to destination pixel}
ditherCopy     = 64; {add to source mode for dithering}
{pattern list resource ID for patterns in the System file}
   sysPatListID = 0;
</PRE>
<A NAME=HEADING196-7></A>
<H3>Data Types</H3>
<PRE>
TYPE PolyPtr   = ^Polygon;
PolyHandle     = ^PolyPtr;
Polygon        =  
RECORD
   polySize:   Integer;                {size in bytes}
   polyBBox:   Rect;                   {bounding rectangle}
   polyPoints: ARRAY[0..0] OF Point;   {vertices for polygon}
END;
PenState =
RECORD
   pnLoc:   Point;      {pen location}
   pnSize:  Point;      {pen size}
   pnMode:  Integer;    {pen's pattern mode}
   pnPat:   Pattern;    {pen pattern}
END;
QDProcsPtr     = ^QDProcs;
QDProcs        =
RECORD
   textProc:      Ptr;  {text drawing}
   lineProc:      Ptr;  {line drawing}
   rectProc:      Ptr;  {rectangle drawing}
   rRectProc:     Ptr;  {roundRect drawing}
   ovalProc:      Ptr;  {oval drawing}
   arcProc:       Ptr;  {arc/wedge drawing}
   rgnProc:       Ptr;  {region drawing}
   bitsProc:      Ptr;  {bit transfer}
   commentProc:   Ptr;  {picture comment processing}
   txMeasProc:    Ptr;  {text width measurement}
   getPicProc:    Ptr;  {picture retrieval}
   putPicProc:    Ptr;  {picture saving}
END;
GrafVerb = (frame,paint,erase,invert,fill);
PatPtr            = ^Pattern;
PatHandle         = ^PatPtr;
Pattern           = PACKED ARRAY[0..7] OF 0..255;
</PRE>
<A NAME=HEADING196-13></A>
<H3>Routines</H3>
<A NAME=HEADING196-14></A>
<H4>Managing the Graphics Pen</H4>
<PRE>
PROCEDURE HidePen;
PROCEDURE ShowPen;
PROCEDURE GetPen        (VAR pt: Point);
PROCEDURE GetPenState   (VAR pnState: PenState);
PROCEDURE SetPenState   (pnState: PenState);
PROCEDURE PenSize       (width,height: Integer);
PROCEDURE PenMode       (mode: Integer);
PROCEDURE PenPat        (pat: Pattern);
PROCEDURE PenNormal;
</PRE>
<A NAME=HEADING196-24></A>
<H4>Changing the Background Bit Pattern</H4>
<PRE>
PROCEDURE BackPat       (pat: Pattern); 
</PRE>
<A NAME=HEADING196-26></A>
<H4>Drawing Lines</H4>
<PRE>
PROCEDURE MoveTo        (h,v: Integer);
PROCEDURE Move          (dh,dv: Integer);
PROCEDURE LineTo        (h,v: Integer);
PROCEDURE Line          (dh,dv: Integer);
</PRE>
<A NAME=HEADING196-31></A>
<H4>Creating and Managing Rectangles</H4>
<PRE>
PROCEDURE SetRect       (VAR r: Rect; left,top,right,bottom: Integer);
PROCEDURE OffsetRect    (VAR r: Rect; dh,dv: Integer);
PROCEDURE InsetRect     (VAR r: Rect; dh,dv: Integer);
FUNCTION SectRect       (src1,src2: Rect; VAR dstRect: Rect): Boolean;
PROCEDURE UnionRect     (src1,src2: Rect; VAR dstRect: Rect);
FUNCTION PtInRect       (pt: Point; r: Rect): Boolean;
PROCEDURE Pt2Rect       (pt1,pt2: Point; VAR dstRect: Rect);
PROCEDURE PtToAngle     (r: Rect; pt: Point; VAR angle: Integer);
FUNCTION EqualRect      (rect1,rect2: Rect): Boolean;
FUNCTION EmptyRect      (r:  Rect): Boolean;
</PRE>
<A NAME=HEADING196-42></A>
<H4>Drawing Rectangles</H4>
<PRE>
PROCEDURE FrameRect     (r: Rect);
PROCEDURE PaintRect     (r: Rect);
PROCEDURE FillRect      (r: Rect; pat: Pattern);
PROCEDURE EraseRect     (r: Rect);
PROCEDURE InvertRect    (r: Rect);
</PRE>
<A NAME=HEADING196-48></A>
<H4>Drawing Rounded Rectangles</H4>
<PRE>
PROCEDURE FrameRoundRect  (r: Rect; ovalWidth,ovalHeight: Integer);
PROCEDURE PaintRoundRect  (r: Rect; ovalWidth,ovalHeight: Integer);
PROCEDURE FillRoundRect   (r: Rect; ovalWidth,ovalHeight: Integer; 
                           pat: Pattern);
PROCEDURE EraseRoundRect  (r: Rect; ovalWidth,ovalHeight: Integer);
PROCEDURE InvertRoundRect (r: Rect; ovalWidth,ovalHeight: Integer);
</PRE>
<A NAME=HEADING196-54></A>
<H4>Drawing Ovals</H4>
<PRE>
PROCEDURE FrameOval     (r: Rect);
PROCEDURE PaintOval     (r: Rect);
PROCEDURE FillOval      (r: Rect; pat: Pattern);
PROCEDURE EraseOval     (r: Rect);
PROCEDURE InvertOval    (r: Rect);
</PRE>
<A NAME=HEADING196-60></A>
<H4>Drawing Arcs and Wedges</H4>
<PRE>
PROCEDURE FrameArc      (r: Rect; startAngle,arcAngle: Integer);
PROCEDURE PaintArc      (r: Rect; startAngle,arcAngle: Integer);
PROCEDURE FillArc       (r: Rect; startAngle,arcAngle: Integer; 
                         pat: Pattern);
PROCEDURE EraseArc      (r: Rect; startAngle,arcAngle: Integer);
PROCEDURE InvertArc     (r: Rect; startAngle,arcAngle: Integer);
</PRE>
<A NAME=HEADING196-66></A>
<H4>Creating and Managing Polygons</H4>
<PRE>
FUNCTION OpenPoly  : PolyHandle;
PROCEDURE ClosePoly;
PROCEDURE OffsetPoly    (poly: PolyHandle; dh,dv: Integer);
PROCEDURE KillPoly      (poly: PolyHandle);
</PRE>
<A NAME=HEADING196-71></A>
<H4>Drawing Polygons</H4>
<PRE>
PROCEDURE FramePoly     (poly: PolyHandle);
PROCEDURE PaintPoly     (poly: PolyHandle);
PROCEDURE FillPoly      (poly: PolyHandle; pat: Pattern);
PROCEDURE ErasePoly     (poly: PolyHandle);
PROCEDURE InvertPoly    (poly: PolyHandle);
</PRE>
<A NAME=HEADING196-77></A>
<H4>Creating and Managing Regions</H4>
<PRE>
FUNCTION NewRgn : RgnHandle;
PROCEDURE OpenRgn;
PROCEDURE CloseRgn      (dstRgn: rgnHandle);
PROCEDURE DisposeRgn    (rgn: RgnHandle);
PROCEDURE CopyRgn       (srcRgn,dstRgn: RgnHandle);
PROCEDURE SetEmptyRgn   (rgn: RgnHandle);
PROCEDURE SetRectRgn    (rgn: RgnHandle; 
                         left,top,right,bottom: Integer);
PROCEDURE RectRgn       (rgn: RgnHandle; r: Rect);
PROCEDURE OffsetRgn     (rgn: RgnHandle; dh,dv: Integer);
PROCEDURE InsetRgn      (rgn: RgnHandle; dh,dv: Integer);
PROCEDURE SectRgn       (srcRgnA,srcRgnB,dstRgn: RgnHandle);
PROCEDURE UnionRgn      (srcRgnA,srcRgnB,dstRgn: RgnHandle);
PROCEDURE DiffRgn       (srcRgnA,srcRgnB,dstRgn: RgnHandle);
PROCEDURE XorRgn        (srcRgnA,srcRgnB,dstRgn: RgnHandle);
FUNCTION PtInRgn        (pt: Point; rgn: RgnHandle): Boolean;
FUNCTION RectInRgn      (r: Rect; rgn: RgnHandle): Boolean;
FUNCTION EqualRgn       (rgnA,rgnB: RgnHandle): Boolean;
FUNCTION EmptyRgn       (rgn: RgnHandle): Boolean;
</PRE>
<A NAME=HEADING196-96></A>
<H4>Drawing Regions</H4>
<PRE>
PROCEDURE FrameRgn      (rgn: RgnHandle);
PROCEDURE PaintRgn      (rgn: RgnHandle);
PROCEDURE FillRgn       (rgn: RgnHandle; pat: Pattern);
PROCEDURE EraseRgn      (rgn: RgnHandle);
PROCEDURE InvertRgn     (rgn: RgnHandle);
</PRE>
<A NAME=HEADING196-102></A>
<H4>Scaling and Mapping Points, Rectangles, Polygons, and Regions</H4>
<PRE>
PROCEDURE ScalePt       (VAR pt: Point; srcRect,dstRect: Rect);
PROCEDURE MapPt         (VAR pt: Point; srcRect,dstRect: Rect);
PROCEDURE MapRect       (VAR r: Rect; srcRect,dstRect: Rect);
PROCEDURE MapRgn        (rgn: RgnHandle; srcRect,dstRect: Rect);
PROCEDURE MapPoly       (poly: PolyHandle; srcRect,dstRect: Rect);
</PRE>
<A NAME=HEADING196-108></A>
<H4>Calculating Black-and-White Fills</H4>
<PRE>
PROCEDURE SeedFill      (srcPtr,dstPtr: Ptr; 
                         srcRow,dstRow,height,words,
                         seedH,seedV: Integer);
PROCEDURE CalcMask      (srcPtr,dstPtr: Ptr; 
                         srcRow,dstRow,height,words: Integer);
</PRE>
<A NAME=HEADING196-111></A>
<H4>Copying Images</H4>
<PRE>
PROCEDURE CopyBits      (srcBits,dstBits: BitMap; 
                         srcRect,dstRect: Rect; mode: Integer; 
                         maskRgn: RgnHandle);
PROCEDURE CopyMask      (srcBits,maskBits,dstBits: BitMap; 
                         srcRect,maskRect,dstRect: Rect);
PROCEDURE CopyDeepMask  (srcBits: BitMap; maskBits: BitMap; 
                         dstBits: BitMap; srcRect: Rect; 
                         maskRect: Rect; dstRect: Rect; 
                         mode: Integer; maskRgn: RgnHandle);
</PRE>
<A NAME=HEADING196-115></A>
<H4>Drawing With the Eight-Color System</H4>
<PRE>
PROCEDURE ForeColor     (color: LongInt);
PROCEDURE BackColor     (color: LongInt);
PROCEDURE ColorBit      (whichBit: Integer);
</PRE>
<A NAME=HEADING196-119></A>
<H4>Determining Whether QuickDraw Has Finished Drawing</H4>
<PRE>
FUNCTION QDDone         (port: GrafPtr): Boolean;
</PRE>
<A NAME=HEADING196-121></A>
<H4>Getting Pattern Resources</H4>
<PRE>
FUNCTION GetPattern     (patID: Integer): PatHandle;
PROCEDURE GetIndPattern (VAR thePattern: Pattern; patListID: Integer; 
                         index: Integer);
</PRE>
<A NAME=HEADING196-124></A>
<H4>Customizing QuickDraw Operations</H4>
<PRE>
PROCEDURE SetStdProcs   (VAR procs: QDProcs);
PROCEDURE StdText       (byteCount: Integer; textBuf: Ptr; 
                         numer,denom: Point);
PROCEDURE StdLine       (newPt: Point);
PROCEDURE StdRect       (verb: GrafVerb; r: Rect);
PROCEDURE StdRRect      (verb: GrafVerb; r: Rect; 
                         ovalwidth,ovalHeight: Integer);
PROCEDURE StdOval       (verb: GrafVerb; r: Rect);
PROCEDURE StdArc        (verb: GrafVerb; r: Rect; 
                         startAngle,arcAngle: Integer);
PROCEDURE StdPoly       (verb: GrafVerb; poly: PolyHandle);
PROCEDURE StdRgn        (verb: GrafVerb; rgn: RgnHandle);
PROCEDURE StdBits       (VAR srcBits: BitMap; 
                         VAR srcRect,dstRect: Rect; mode: Integer; 
                         maskRgn: RgnHandle);
PROCEDURE StdComment    (kind,dataSize: Integer; dataHandle: Handle);
FUNCTION StdTxtMeas     (byteCount: Integer; textAddr: Ptr; 
                         VAR numer, denom: Point; 
                         VAR info: FontInfo): Integer;
PROCEDURE StdGetPic     (dataPtr: Ptr; byteCount: Integer);
PROCEDURE StdPutPic     (dataPtr: Ptr; byteCount: Integer);
</PRE>
<A NAME=HEADING196-139></A>
<H2>C Summary</H2>
<A NAME=HEADING196-140></A>
<H3>Constants</H3>
<PRE>
enum {
   /* basic QuickDraw colors */
   whiteColor     = 30;
   blackColor     = 33;
   yellowColor    = 69;
   magentaColor   = 137;
   redColor       = 205;
   cyanColor      = 273;
   greenColor     = 341;
   blueColor      = 409;

/* source modes */
   srcCopy        = 0,  /* where source pixel is black, force destination 
                        pixel black; where source pixel is white, force
                        destination pixel white */
   srcOr          = 1,  /* where source pixel is black, force destination 
                        pixel black; where source pixel is white, leave 
                        destination pixel unaltered */
   srcXor         = 2,  /* where source pixel is black, invert destination
                        pixel; where source pixel is white, leave 
                        destination pixel unaltered */
   srcBic         = 3,  /* where source pixel is black, force destination 
                        pixel white; where source pixel is white, leave
                        destination pixel unaltered */
   notSrcCopy     = 4,  /* where source pixel is black, force destination
                        pixel white; where source pixel is white, force
                        destination pixel black */
   notSrcOr       = 5,  /* where source pixel is black, leave destination
                        pixel unaltered; where source pixel is white,
                        force destination pixel black */
   notSrcXor      = 6,  /* where source pixel is black, leave destination 
                        pixel unaltered; where source pixel is white, 
                        invert destination pixel*/
   notSrcBic      = 7,  /* where source pixel is black, leave destination
                        pixel unaltered; where source pixel is white,
                        force destination pixel white */

   /* pattern modes */
   patCopy        = 8,  /* where pattern pixel is black, apply foreground
                        color to destination pixel; where pattern pixel 
                        is white, apply background color to destination 
                        pixel */
   patOr          = 9,  /* where pattern pixel is black, invert destination 
                        pixel; where pattern pixel is white, leave
                        destination pixel unaltered */
   patXor         = 10; /* where pattern pixel is black, invert destination
                        pixel; where pattern pixel is white, leave
                        destination pixel unaltered */
   patBic         = 11; /* where pattern pixel is black, apply background
                        color to destination pixel; where pattern pixel
                        is white, leave destination pixel unaltered */
notPatCopy     = 12; /* where pattern pixel is black, apply background 
                        color to destination pixel; where pattern pixel 
                        is white, apply foreground color to destination 
                        pixel */
   notPatOr       = 13; /* where pattern pixel is black, leave destination
                        pixel unaltered; where pattern pixel is white,
                        apply foreground color to destination pixel */
   notPatXor      = 14; /* where pattern pixel is black, leave destination 
                        pixel unaltered; where pattern pixel is white,
                        invert destination pixel */
   notPatBic      = 15; /* where pattern pixel is black, leave destination 
                        pixel unaltered; where pattern pixel is white,
                        apply background color to destination pixel */
ditherCopy     = 64, /* add to source mode for dithering */
/* pattern list resource ID for patterns in the System file */
   sysPatListID = 0
};
</PRE>
<A NAME=HEADING196-146></A>
<H3>Data Types</H3>
<PRE>
struct Polygon {
   short polySize;      /* size in bytes */
   Rect  polyBBox;      /* bounding rectangle */
   Point polyPoints[1]; /* vertices for polygon */
};
typedef struct Polygon Polygon;
typedef Polygon *PolyPtr, **PolyHandle;
struct PenState {
   Point    pnLoc;      /* pen location */
   Point    pnSize;     /* pen size */
   short    pnMode;     /* pen's pattern mode */
   Pattern  pnPat;      /* pen pattern */
};
typedef struct PenState PenState;
struct QDProcs {
   Ptr textProc;        /* text drawing */
   Ptr lineProc;        /* line drawing */
   Ptr rectProc;        /* rectangle drawing */
   Ptr rRectProc;       /* roundRect drawing */
   Ptr ovalProc;        /* oval drawing */
   Ptr arcProc;         /* arc and wedge drawing */
   Ptr polyProc;        /* region drawing */
   Ptr rgnProc;         /* region drawing */
   Ptr bitsProc;        /* bit transfer */
   Ptr commentProc;     /* picture comment processing */
   Ptr txMeasProc;      /* text width measurement */
   Ptr getPicProc;      /* picture retrieval */
   Ptr putPicProc;      /* picture saving */
};
typedef struct QDProcs QDProcs;
typedef QDProcs *QDProcsPtr;
enum {frame,paint,erase,invert,fill};
typedef unsigned char GrafVerb;
struct Pattern{
   unsigned char pat[8];
};
typedef struct Pattern Pattern;
typedef Pattern *PatPtr;
typedef const unsigned char *ConstPatternParam;
typedef PatPtr *PatHandle;
</PRE>
<A NAME=HEADING196-152></A>
<H3>Functions</H3>
<A NAME=HEADING196-153></A>
<H4>Managing the Graphics Pen</H4>
<PRE>
pascal void HidePen         (void);
pascal void ShowPen         (void);
pascal void GetPen          (Point *pt);
pascal void GetPenState     (PenState *pnState);
pascal void SetPenState     (const PenState *pnState);
pascal void PenSize         (short width, short height);
pascal void PenMode         (short mode);
pascal void PenPat          (ConstPatternParam pat);
pascal void PenNormal       (void);
</PRE>
<A NAME=HEADING196-163></A>
<H4>Changing the Background Bit Pattern</H4>
<PRE>
pascal void BackPat         (ConstPatternParam pat); 
</PRE>
<A NAME=HEADING196-165></A>
<H4>Drawing Lines</H4>
<PRE>
pascal void MoveTo          (short h, short v);
pascal void Move            (short dh, short dv);
pascal void LineTo          (short h, short v);
pascal void Line            (short dh, short dv);
</PRE>
<A NAME=HEADING196-170></A>
<H4>Creating and Managing Rectangles</H4>
<PRE>
pascal void SetRect         (Rect *r, short left, short top, short right, 
                             short bottom);
pascal void OffsetRect      (Rect *r, short dh, short dv);
pascal void InsetRect       (Rect *r, short dh, short dv);
pascal Boolean SectRect     (const Rect *src1, const Rect *src2, 
                             Rect *dstRect);
pascal void UnionRect       (const Rect *src1, const Rect *src2, 
                             Rect *dstRect);
pascal Boolean PtInRect     (Point pt, const Rect *r);
pascal void Pt2Rect         (Point pt1, Point pt2, Rect *dstRect);
pascal void PtToAngle       (const Rect *r, Point pt, short *angle);
pascal Boolean EqualRect    (const Rect *rect1, const Rect *rect2);
pascal Boolean EmptyRect    (const Rect *r);
</PRE>
<A NAME=HEADING196-181></A>
<H4>Drawing Rectangles</H4>
<PRE>
pascal void FrameRect       (const Rect *r);
pascal void PaintRect       (const Rect *r);
pascal void FillRect        (const Rect *r, ConstPatternParam pat);
pascal void EraseRect       (const Rect *r);
pascal void InvertRect      (const Rect *r);
</PRE>
<A NAME=HEADING196-187></A>
<H4>Drawing Rounded Rectangles</H4>
<PRE>
pascal void FrameRoundRect  (const Rect *r, short ovalWidth, 
                             short ovalHeight);
pascal void PaintRoundRect  (const Rect *r, short ovalWidth,
                             short ovalHeight);
pascal void FillRoundRect   (const Rect *r, short ovalWidth,
                             short ovalHeight, ConstPatternParam pat);
pascal void EraseRoundRect  (const Rect *r, short ovalWidth, 
                             short ovalHeight);
pascal void InvertRoundRect
                            (const Rect *r, short ovalWidth,
                             short ovalHeight);
</PRE>
<A NAME=HEADING196-194></A>
<H4>Drawing Ovals</H4>
<PRE>
pascal void FrameOval       (const Rect *r);
pascal void PaintOval       (const Rect *r);
pascal void FillOval        (const Rect *r, ConstPatternParam pat);
pascal void EraseOval       (const Rect *r);
pascal void InvertOval      (const Rect *r);
</PRE>
<A NAME=HEADING196-200></A>
<H4>Drawing Arcs and Wedges</H4>
<PRE>
pascal void FrameArc        (const Rect *r, short startAngle,
                             short arcAngle);
pascal void PaintArc        (const Rect *r, short startAngle,
                             short arcAngle);
pascal void FillArc         (const Rect *r, short startAngle, 
                             short arcAngle, ConstPatternParam pat);
pascal void EraseArc        (const Rect *r, short startAngle,
                             short arcAngle);
pascal void InvertArc       (const Rect *r, short startAngle,
                             short arcAngle);
</PRE>
<A NAME=HEADING196-206></A>
<H4>Creating and Managing Polygons</H4>
<PRE>
pascal PolyHandle OpenPoly  (void);
pascal void ClosePoly       (void);
pascal void OffsetPoly      (PolyHandle poly, short dh, short dv);
pascal void KillPoly        (PolyHandle poly);
</PRE>
<A NAME=HEADING196-211></A>
<H4>Drawing and Painting Polygons</H4>
<PRE>
pascal void FramePoly       (PolyHandle poly);
pascal void PaintPoly       (PolyHandle poly);
pascal void FillPoly        (PolyHandle poly, ConstPatternParam pat);
pascal void ErasePoly       (PolyHandle poly);
pascal void InvertPoly      (PolyHandle poly);
</PRE>
<A NAME=HEADING196-217></A>
<H4>Creating and Managing Regions</H4>
<PRE>
pascal RgnHandle NewRgn     (void);
pascal void OpenRgn         (void);
pascal void CloseRgn        (RgnHandle dstRgn);
pascal void DisposeRgn      (RgnHandle rgn);
pascal void CopyRgn         (RgnHandle srcRgn, RgnHandle dstRgn);
pascal void SetEmptyRgn     (RgnHandle rgn);
pascal void SetRectRgn      (RgnHandle rgn, short left, short top, 
                             short right, short bottom);
pascal void RectRgn         (RgnHandle rgn, const Rect *r);
pascal void OffsetRgn       (RgnHandle rgn, short dh, short dv);
pascal void InsetRgn        (RgnHandle rgn, short dh, short dv);
pascal void SectRgn         (RgnHandle srcRgnA, RgnHandle srcRgnB,
                             RgnHandle dstRgn);
pascal void UnionRgn        (RgnHandle srcRgnA, RgnHandle srcRgnB,
                             RgnHandle dstRgn);
pascal void DiffRgn         (RgnHandle srcRgnA, RgnHandle srcRgnB,
                             RgnHandle dstRgn);
pascal void XorRgn          (RgnHandle srcRgnA, RgnHandle srcRgnB, 
                             RgnHandle dstRgn);
pascal Boolean PtInRgn      (Point pt, RgnHandle rgn);
pascal Boolean RectInRgn    (const Rect *r, RgnHandle rgn);
pascal Boolean EqualRgn     (RgnHandle rgnA, RgnHandle rgnB);
pascal Boolean EmptyRgn     (RgnHandle rgn);
</PRE>
<A NAME=HEADING196-236></A>
<H4>Drawing Regions</H4>
<PRE>
pascal void FrameRgn        (RgnHandle rgn);
pascal void PaintRgn        (RgnHandle rgn);
pascal void FillRgn         (RgnHandle rgn, ConstPatternParam pat);
pascal void EraseRgn        (RgnHandle rgn);
pascal void InvertRgn       (RgnHandle rgn);
</PRE>
<A NAME=HEADING196-242></A>
<H4>Scaling and Mapping Points, Rectangles, Polygons, and Regions</H4>
<PRE>
pascal void ScalePt         (Point *pt, const Rect *srcRect,
                             const Rect *dstRect);
pascal void MapPt           (Point *pt, const Rect *srcRect,
                             const Rect *dstRect);
pascal void MapRect         (Rect *r, const Rect *srcRect,
                             const Rect *dstRect);
pascal void MapRgn          (RgnHandle rgn, const Rect *srcRect,
                             const Rect *dstRect);
pascal void MapPoly         (PolyHandle poly, const Rect *srcRect,
                             const Rect *dstRect);
</PRE>
<A NAME=HEADING196-248></A>
<H4>Calculating Black-and-White Fills</H4>
<PRE>
pascal void SeedFill        (const void *srcPtr, void *dstPtr, 
                             short srcRow, short dstRow, short height,
                             short words, short seedH, short seedV);
pascal void CalcMask        (const void *srcPtr, void *dstPtr, 
                             short srcRow, short dstRow, short height,
                             short words);
</PRE>
<A NAME=HEADING196-251></A>
<H4>Copying Images</H4>
<PRE>
pascal void CopyBits        (const BitMap *srcBits, 
                             const BitMap *dstBits, const Rect *srcRect, 
                             const Rect *dstRect, short mode, 
                             RgnHandle maskRgn);
pascal void CopyMask        (const BitMap *srcBits, 
                             const BitMap *maskBits, const BitMap *dstBits, 
                             const Rect *srcRect, const Rect *maskRect, 
                             const Rect *dstRect);
pascal void CopyDeepMask    (const BitMap *srcBits, const BitMap *maskBits, 
                             const BitMap *dstBits, const Rect *srcRect, 
                             const Rect *maskRect, const Rect *dstRect, 
                             short mode, RgnHandle maskRgn);
</PRE>
<A NAME=HEADING196-255></A>
<H4>Drawing With the Eight-Color System</H4>
<PRE>
pascal void ForeColor       (long color);
pascal void BackColor       (long color);
pascal void ColorBit        (short whichBit);
</PRE>
<A NAME=HEADING196-259></A>
<H4>Determining Whether QuickDraw Has Finished Drawing</H4>
<PRE>
pascal Boolean QDDone       (GrafPtr port);
</PRE>
<A NAME=HEADING196-261></A>
<H4>Getting Pattern Resources</H4>
<PRE>
pascal PatHandle GetPattern
                            (short patternID);
pascal void GetIndPattern   (Pattern thePat, short patternListID, 
                             short index);
</PRE>
<A NAME=HEADING196-265></A>
<H4>Customizing QuickDraw Operations</H4>
<PRE>
pascal void SetStdProcs     (QDProcs *procs);
pascal void StdText         (short count, const void *textAddr, 
                             Point numer, Point denom);
pascal void StdLine         (Point newPt);
pascal void StdRect         (GrafVerb verb, const Rect *r);
pascal void StdRRect        (GrafVerb verb, const Rect *r, 
                             short ovalWidth, short ovalHeight);
pascal void StdOval         (GrafVerb verb, const Rect *r);
pascal void StdArc          (GrafVerb verb, const Rect *r, 
                             short startAngle, short arcAngle);
pascal void StdPoly         (GrafVerb verb, PolyHandle poly);
pascal void StdRgn          (GrafVerb verb, RgnHandle rgn);
pascal void StdBits         (const BitMap *srcBits, 
                             const Rect *srcRect, const Rect *dstRect,
                             short mode, RgnHandle maskRgn);
pascal void StdComment      (short kind, short dataSize, Handle dataHandle);
pascal short StdTxtMeas     (short byteCount, const void *textAddr, 
                             Point *numer, Point *denom, FontInfo *info);
pascal void StdGetPic       (void *dataPtr, short byteCount);
pascal void StdPutPic       (const void *dataPtr, short byteCount);
</PRE>
<A NAME=HEADING196-280></A>
<H2>Assembly-Language Summary</H2>
<A NAME=HEADING196-281></A>
<H3>Data Structures</H3>
<A NAME=HEADING196-282></A>
<H4>Polygon Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>polySize<TD>word<TD>total bytes in this structure<TR>
<TD>2<TD>polyBBox<TD>8 bytes<TD>bounding rectangle<TR>
<TD>10<TD>polyPoints<TD>variable<TD>vertices, each consisting of a long (point)</TABLE>
</H4>
<A NAME=HEADING196-283></A>
<H4>PenState Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>psLoc<TD>long<TD>pen location<TR>
<TD>4<TD>psSize<TD>long<TD>pen size<TR>
<TD>8<TD>psMode<TD>word<TD>pattern mode<TR>
<TD>10<TD>psPat<TD>8 bytes<TD>pattern</TABLE>
</H4>
<A NAME=HEADING196-284></A>
<H4>QDProcs Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>textProc<TD>long<TD>pointer to text-drawing routine<TR>
<TD>4<TD>lineProc<TD>long<TD>pointer to line-drawing routine<TR>
<TD>8<TD>rectProc<TD>long<TD>pointer to rectangle-drawing routine<TR>
<TD>12<TD>rRectProc<TD>long<TD>pointer to rounded rectangle-drawing routine<TR>
<TD>16<TD>ovalProc<TD>long<TD>pointer to oval-drawing routine<TR>
<TD>20<TD>arcProc<TD>long<TD>pointer to arc/wedge-drawing routine<TR>
<TD>24<TD>polyProc<TD>long<TD>pointer to polygon-drawing routine<TR>
<TD>28<TD>rgnProc<TD>long<TD>pointer to region-drawing routine<TR>
<TD>32<TD>bitsProc<TD>long<TD>pointer to bit transfer routine<TR>
<TD>36<TD>commentProc<TD>long<TD>pointer to picture comment-processing routine<TR>
<TD>40<TD>txMeasProc<TD>long<TD>pointer to text-width measurement routine<TR>
<TD>44<TD>getPicProc<TD>long<TD>pointer to picture retrieval routine<TR>
<TD>48<TD>putPicProc<TD>long<TD>pointer to picture-saving routine</TABLE>
</H4>
<A NAME=HEADING196-285></A>
<H4>Trap Macro Requiring Routine Selector</H4>
<PRE>
_QDExtensions<CODE>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Selector<TH>Routine<TR>
<TD>$00040013<TD>QDDone</TABLE>
</CODE>
</PRE>
<A NAME=HEADING196-287></A>
<H3>Global Variables
<TABLE BORDER="0" CELLPADDING=3><TD>black<TD>All-black pattern.<TR>
<TD>dkGray<TD>75% gray pattern.<TR>
<TD>gray<TD>50% gray pattern.<TR>
<TD>ltGray<TD>25% gray pattern.<TR>
<TD>white<TD>All-white pattern.</TABLE>
</H3>
</BLOCKQUOTE><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-195.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-197.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
