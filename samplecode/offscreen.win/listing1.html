<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>offscreen.win - /Application.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMovieBasics-date.html">Movie Basics</a> &gt; <A HREF="javascript:location.replace('index.html');">offscreen.win</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">offscreen.win</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Application.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Application.c</option>
<option value="listing2.html">/Application.h</option>
<option value="listing3.html">/ApplicationPrivate.h</option>
<option value="listing4.html">/QTCode.c</option>
<option value="listing5.html">/QTCode.h</option>
<option value="listing6.html">/README.txt</option>
<option value="listing7.html">/resource.h</option>
<option value="listing8.html">/WinPrefix.h</option></select>
				</p>
				</form>
				<p><strong><a href="offscreen.win.zip">Download Sample</a></strong> (&#147;offscreen.win.zip&#148;, 180.2K)<BR>
<strong><a href="offscreen.win.dmg">Download Sample</a></strong> (&#147;offscreen.win.dmg&#148;, 244.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    Offscreen.c

  Contains:  QuickTime 3.0 Offscreen sample application.

  Written by:  Scott Kuechle
        based on MDIPlayer code by Brian S. Friedkin

  Copyright:  &copy; 1998 by Apple Computer, Inc., all rights reserved.

  Change History (most recent first):

     &lt;2&gt;     5/18/98    rtm    minor tweaks to GetBitDepthOfBitmap and DrawBackgroundBitmap to get this code
                     working with the Metrowerks compiler
     &lt;1&gt;     4/24/98    srk    first file; revised to personal coding style
      
 
 NOTES:

 
 TO DO:

*/


#include &quot;Application.h&quot;
#include &quot;QTCode.h&quot;


long FAR PASCAL FrameWndProc  (HWND, UINT, UINT, LONG) ;
long FAR PASCAL MovieWndProc  (HWND, UINT, UINT, LONG) ;
BOOL      DoOpenMovie();
int        DoIdleMenus(HWND hWnd, HMENU hMenu);
static void    DoCut(HWND);
static void    DoCopy(HWND);
static void    DoPaste(HWND);
static void    DoClear(HWND);
static void    DoUndo(HWND);
static void    DoAbout(void);
HPALETTE    DoCreatePaletteFromBitMap(HMODULE appInstance, WORD bitMapID);
void      SetMovieFrameTimeValue(Movie theMovie, TimeValue thisPoint);
WORD      GetBitDepthOfBitmap(HMODULE appInstance, WORD bitMapID);
void      GetRBGColorsFromBitmap(HDC  hDC, HANDLE  hInst, WORD  bitMapID, LPRGBQUAD  *srcRgbQuadArray, HPALETTE  *hPalette);
void      DoEraseRect(HDC  hDC, RECT *theRect);
int        GetLineHeight(HDC hDC);
void      DrawMovieAndBackground(HGLOBAL hWinStorage, HDC hDC, HWND hwnd);


  /* globals for this module */
HANDLE    ghInst          = NULL;
HWND    ghWndFrame        = NULL;
HWND    ghWndMDIClient      = NULL;
BOOL    gWeAreSizingWindow    = 0;
BOOL    gWeAreCreatingWindow  = 0;
int      gOpenMovieCount      = 0;
char    gAppName[20];
char    gChildName[20];
LPRGBQUAD  gSrcRgbQuadArray    = NULL;    /* rbg color values for our window background bitmap */
HPALETTE  gHBackgroundPalette    = NULL;    /* color palette for our window background */
HANDLE    ghBkgrndBitMap      = NULL;    /* bitmap we paint on the background of our client windows */

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    WinMain()                                                     */
/*                                                                  */
/*                                                                  */
/*    The main function for this application                        */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
          LPSTR lpszCmdLine, int nCmdShow)
    {
  HANDLE    hAccel ;
  HWND    hwndFrame;
  MSG      msg ;
    WNDCLASSEX  wc;
  BOOL    success;

    ghInst = hInstance ;

    if (!hPrevInstance) 
    {
      LoadString(hInstance, IDS_APPNAME, gAppName, sizeof(gAppName));
      
      // Register the frame window class
      wc.cbSize        = sizeof(WNDCLASSEX);
      wc.style         = CS_HREDRAW | CS_VREDRAW;
      wc.lpfnWndProc   = (WNDPROC)FrameWndProc;
      wc.cbClsExtra    = 0;
      wc.cbWndExtra    = 0;
      wc.hInstance     = hInstance;
      wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APPICON));
      wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
      wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
      wc.lpszMenuName  = gAppName;
      wc.lpszClassName = gAppName;
      wc.hIconSm       = LoadImage(hInstance,
                     MAKEINTRESOURCE(IDI_APPICON),
                     IMAGE_ICON,
                     16, 16,
                     0);
      if (!RegisterClassEx(&amp;wc))
      {
        if (!RegisterClass((LPWNDCLASS)&amp;wc.style))
              return FALSE;
      }

      LoadString(hInstance, IDS_MDICHILD, gChildName, sizeof(gChildName));

      // Register the Movie child window class
      wc.cbSize        = sizeof(WNDCLASSEX);
      wc.style         = CS_HREDRAW | CS_VREDRAW;
      wc.lpfnWndProc   = (WNDPROC)MovieWndProc;
      wc.cbClsExtra    = 0;
      wc.cbWndExtra    = 0;
      wc.hInstance     = hInstance;
      wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_CHILDICON));
      wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
      wc.hbrBackground = NULL  /* we want to handle erasing of the background ourselves */;
      wc.lpszMenuName  = NULL;
      wc.lpszClassName = gChildName;
      wc.hIconSm       = LoadImage(hInstance,
                     MAKEINTRESOURCE(IDI_CHILDICON),
                     IMAGE_ICON,
                     16, 16,
                     0);
      if (!RegisterClassEx(&amp;wc))
      {
        if (!RegisterClass((LPWNDCLASS)&amp;wc.style))
              return FALSE;
      }
    }

    // Load accelerators
    hAccel = LoadAccelerators (hInstance, gAppName);

    // Create the main frame window
    ghWndFrame = hwndFrame = CreateWindow (gAppName, gAppName,
                         WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                         CW_USEDEFAULT, CW_USEDEFAULT,
                         CW_USEDEFAULT, CW_USEDEFAULT,
                         NULL, NULL, hInstance, NULL) ;

      /* get background bitmap for use with our client windows */
    ghBkgrndBitMap = LoadResource(ghInst, FindResource(ghInst, MAKEINTRESOURCE(IDB_BITMAP2), RT_BITMAP) );
 
      /* Show the window */
    ShowWindow(hwndFrame, nCmdShow);
    UpdateWindow(hwndFrame);

      /* Initialize QuickTime */
    success = QTCode_DoQTInit();
    if (success)
    {
        /* Process messages */
      while (GetMessage(&amp;msg, NULL, 0, 0))
      {
        if (!TranslateMDISysAccel(ghWndMDIClient, &amp;msg))
          if (!TranslateAccelerator(hwndFrame, hAccel, &amp;msg))
          {
            TranslateMessage(&amp;msg);
            DispatchMessage(&amp;msg);
          }
      }
    }
    else
    {
      MessageBox(hwndFrame, &quot;Quicktime 3.0 not available&quot;, &quot;&quot;, MB_OK);
    }

      /* QuickTime clean up */
    QTCode_QTCleanUp();

    return msg.wParam;
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    FrameWndProc()                                                */
/*                                                                  */
/*                                                                  */
/*    The window procedure for the MDI frame window                 */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

long FAR PASCAL FrameWndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam)
{
  HWND               hwndChild ;

  switch (message)
  {
    case WM_CREATE:          // Create the client window
    {
      CLIENTCREATESTRUCT ccs = {0};

      ccs.hWindowMenu  = GetSubMenu(GetMenu(hwnd), WINDOWMENU);
      ccs.idFirstChild = IDM_WINDOWCHILD;

      // Create the MDI client filling the client area
      ghWndMDIClient = CreateWindow(&quot;mdiclient&quot;,
                     NULL,
                     WS_CHILD | WS_CLIPCHILDREN | WS_VSCROLL |
                     WS_HSCROLL,
                     0, 0, 0, 0,
                     hwnd,
                     (HMENU)0xCAC,
                     ghInst,
                     (LPVOID)&amp;ccs);

      ShowWindow(ghWndMDIClient, SW_SHOW);
    }
    return 0 ;

    case WM_COMMAND:
      switch (LOWORD(wParam))
      {
        case IDM_FILEOPEN:
          DoOpenMovie();
          return 0 ;

        case IDM_FILECLOSE:
          hwndChild = (HWND)SendMessage(ghWndMDIClient, WM_MDIGETACTIVE, 0, 0L) ;
          if (SendMessage (hwndChild, WM_QUERYENDSESSION, 0, 0L))
          {
            SendMessage (ghWndMDIClient, WM_MDIDESTROY, (WPARAM)hwndChild, 0L) ;
          }
          return 0 ;

        case IDM_EXIT:
          SendMessage (hwnd, WM_CLOSE, 0, 0L) ;
          return 0 ;

        case IDM_WINDOWTILE:
          SendMessage (ghWndMDIClient, WM_MDITILE, 0, 0L) ;
          return 0 ;

        case IDM_WINDOWCASCADE:
          SendMessage (ghWndMDIClient, WM_MDICASCADE, 0, 0L) ;
          return 0 ;

        case IDM_WINDOWICONS:
          SendMessage (ghWndMDIClient, WM_MDIICONARRANGE, 0, 0L) ;
          return 0 ;

        case IDM_WINDOWCLOSEALL:
          {
            HWND  hwndT;
      
            while (hwndT = GetWindow(ghWndMDIClient, GW_CHILD))
            {
              // Skip the icon and title windows
              while (hwndT &amp;&amp; GetWindow(hwndT, GW_OWNER))
                hwndT = GetWindow(hwndT, GW_HWNDNEXT);

              if (!hwndT) break;

              SendMessage(ghWndMDIClient, WM_MDIDESTROY, (WPARAM)hwndT, 0L);
            }
          }
          return 0;

        case IDM_ABOUT:
          DoAbout();
          return 0;

        default:            // Pass to active child
          hwndChild = (HWND)SendMessage (ghWndMDIClient, WM_MDIGETACTIVE, 0, 0L) ;
          if (IsWindow (ghWndMDIClient))
            SendMessage (hwndChild, WM_COMMAND, wParam, lParam) ;

          break ;        // and then to DefFrameProc
      }
      break ;

    case WM_INITMENU:
      if (GetMenu(hwnd) == (HMENU)wParam)
        return DoIdleMenus((HWND)SendMessage(ghWndMDIClient, WM_MDIGETACTIVE, 0, 0), (HMENU)wParam);
      return 1;

    case WM_DESTROY :
      PostQuitMessage (0) ;
      return 0 ;
  }

  return DefFrameProc (hwnd, ghWndMDIClient, message, wParam, lParam) ;
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    MovieWndProc()                                                */
/*                                                                  */
/*                                                                  */
/*    The window procedure for our movie window                     */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

long FAR PASCAL MovieWndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam)
{
  HGLOBAL      hWinStorage = NULL;
  ChildWindowPtr  childWinPtr = NULL;
  MSG        msg = {0};


  hWinStorage = (HGLOBAL)GetWindowLong(hwnd, GWL_USERDATA);

  switch (message)
  {
    case WM_CREATE:
      {
        GrafPtr gp;

            /* Tuck away some private storage */
          hWinStorage = GlobalAlloc(GMEM_MOVEABLE + GMEM_ZEROINIT, sizeof(ChildWindowRecord));
          SetWindowLong(hwnd, GWL_USERDATA, (LPARAM)hWinStorage);

            /* Associate a GrafPort with this window */
          gp = QTCode_DoCreatePortAssociation(hwnd, NULL, 0);

      }
      return 0;

    case WM_GETMINMAXINFO:
      {        
        if (hWinStorage != NULL)
        {
          childWinPtr = (ChildWindowPtr)GlobalLock(hWinStorage);
          if (childWinPtr != NULL)
          {
            LPMINMAXINFO lpmmi;

              lpmmi = (LPMINMAXINFO) lParam;
                /* we restrict the grow size of our window */
              lpmmi-&gt;ptMaxSize.x = childWinPtr-&gt;maxWindowWidth;
              lpmmi-&gt;ptMaxSize.y = childWinPtr-&gt;maxWindowHeight;
              lpmmi-&gt;ptMaxTrackSize.x = childWinPtr-&gt;maxWindowWidth;
              lpmmi-&gt;ptMaxTrackSize.y = childWinPtr-&gt;maxWindowHeight;

              GlobalUnlock(hWinStorage);
          }
        }
      }
      return 0;

    case WM_PAINT:
      {
        PAINTSTRUCT  lPaint;
        HDC      hDC;

          hDC = BeginPaint(hwnd, &amp;lPaint);
          if (hDC != NULL)
          {
            DrawMovieAndBackground(hWinStorage, hDC, hwnd);
          }
          EndPaint(hwnd, &amp;lPaint);
      }
      return 0;

    case WM_WINDOWPOSCHANGING:
      // Don't show the window until we have created a movie and therefore
      // can properly size the window to contain the movie.
      if (gWeAreCreatingWindow)
      {
        WINDOWPOS  *lpWindowPos = (WINDOWPOS*)lParam;
        lpWindowPos-&gt;flags &amp;= ~SWP_SHOWWINDOW;
        return 0;
      }


      return 0;
  
    case WM_KEYDOWN:
      if (wParam == VK_RETURN)  /* return key was pressed */
      {
        HDC    hDC      = NULL;
        OSType  mediaType  = VideoMediaType;

          if (hWinStorage != NULL)
          {
            childWinPtr = (ChildWindowPtr)GlobalLock(hWinStorage);
            if (childWinPtr != NULL)
            {
                /* move to next interesting movie time to display */
              childWinPtr-&gt;currentTime = 
                QTCode_DoGetMovieNextInterestingTime(childWinPtr-&gt;currentTime, childWinPtr-&gt;movie,
                                    VideoMediaType);
              GlobalUnlock(hWinStorage);

              hDC = GetDC(hwnd);
              if (hDC != NULL)
              {
                DrawMovieAndBackground(hWinStorage, hDC, hwnd);
                ReleaseDC(hwnd, hDC);
              }
            }
          }
      }

      return 0;

    case WM_SIZE:
      {        
        if (hWinStorage != NULL)
        {
          childWinPtr = (ChildWindowPtr)GlobalLock(hWinStorage);
          if (childWinPtr != NULL)
          {
            if (childWinPtr-&gt;movie)
            {
              QTCode_PositionMovieRectInClientWindow(childWinPtr-&gt;movie, hwnd);
            }
            GlobalUnlock(hWinStorage);
          }
        }
      }
      return 0;

    case WM_ERASEBKGND:
      {
        /* we don't want the background erased when the window is
          re-sized, so we'll trap calls here for the WM_ERASEBKGND
          event */
      }
      return (1);  /* tell GDI we've handled erasing ourselves */

    case WM_COMMAND:
      {
        switch(LOWORD(wParam))    // Undo, Cut, Copy, Paste and Clear
        {
          case IDM_EDITUNDO:
            DoUndo(hwnd);
            break;

          case IDM_EDITCUT:
            DoCut(hwnd);
            break;

          case IDM_EDITCOPY:
            DoCopy(hwnd);
            break;

          case IDM_EDITPASTE:
            DoPaste(hwnd);
            break;

          case IDM_EDITCLEAR:
            DoClear(hwnd);
            break;
        }
      }
      break;

    case WM_DESTROY:
      {    
        if (hWinStorage != NULL)
        {
          childWinPtr = (ChildWindowPtr)GlobalLock(hWinStorage);
          if (childWinPtr != NULL)
          {
              /* One less movie open */
            --gOpenMovieCount;

            QTCode_DisposeMovieAndController(childWinPtr-&gt;movie, childWinPtr-&gt;refNum);
              /* Destroy the port association */
            QTCode_DoDestroyPortAssociation(hwnd);
              /* clean up offscreen GWorld */
            QTCode_DoDestroyOffscreen(childWinPtr-&gt;offscreenGWorld, childWinPtr-&gt;hBitmap);

            SetWindowLong(hwnd, GWL_USERDATA, 0);
            GlobalUnlock(hWinStorage);
            GlobalFree((HGLOBAL)GetWindowLong(hwnd, GWL_USERDATA));
          }
        }
      }
      return 0;
  }

  return DefMDIChildProc (hwnd, message, wParam, lParam);
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoOpenMovie()                                                 */
/*                                                                  */
/*                                                                  */
/*    Code to open a given movie and prepare it for display in a    */
/*    window                                                        */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

BOOL DoOpenMovie()
{
    DWORD      dwVersion;
  short      len;
    char            szPathName[256], szFileName[256];
    HWND      hwndChild = 0;
    OPENFILENAME    ofn = {0};
  HDC        hDC;
  HGLOBAL      hWinStorage = NULL;
  OSErr      err;
  Movie      movie = NULL;
  short      movieRefNum;
  short      movieResId;
  int        movWidth, movHeight;

    // Present the dialog...
    *szPathName = 0;
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = ghWndFrame;
    ofn.lpstrFile = (LPSTR)szPathName;
    ofn.nMaxFile  = sizeof(szPathName);
    ofn.lpstrFilter  = &quot;QuickTime Movies (*.mov) \0 *.mov\0All Files (*.*) \0 *.*\0&quot;;
    ofn.nFilterIndex = 1;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags        = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
    if (!GetOpenFileName(&amp;ofn)) goto bail;

    err = QTCode_NewMovieFromWinPathname(szPathName,  /* c-string path to movie */
                      &amp;movie,      /* Movie returned here */
                      &amp;movieRefNum,  /* Movie RefNum returned here */
                      &amp;movieResId);  /* Movie Resource ID returned here */
    if (err == noErr)
    {
      Rect  movieBounds;

        GetMovieBox(movie, &amp;movieBounds);
        movWidth = RECT_WIDTH(movieBounds);
        movHeight = RECT_HEIGHT(movieBounds);
    }
    // Create the child movie window
    dwVersion = GetVersion();
    gWeAreCreatingWindow = TRUE;
    if ((dwVersion &lt; 0x80000000) || (LOBYTE(LOWORD(dwVersion)) &lt; 4))
    {
      // This is Windows NT or Win32s, so use the WM_MDICREATE message
      MDICREATESTRUCT mcs;

      mcs.szClass = gChildName;
      mcs.szTitle = szFileName; 
      mcs.hOwner  = ghInst;
      mcs.x       = CW_USEDEFAULT;
      mcs.y       = CW_USEDEFAULT;
      mcs.cx      = movWidth + kWinSpacer;  /* set an appropriate width for our movie window */
      mcs.cy      = movHeight + kWinSpacer;  /* set an appropriate height for our movie window */
      mcs.style   = 0;
      mcs.lParam  = 0;

      hwndChild = (HWND) SendMessage(ghWndMDIClient,
                       WM_MDICREATE,
                       0,
                       (LPARAM)(LPMDICREATESTRUCT) &amp;mcs);
    }
    else
    {
      // This method will only work with Windows 95, not Windows NT or Win32s
      hwndChild = CreateWindowEx(WS_EX_MDICHILD,
                     gChildName,
                     szFileName,
                     0,
                     CW_USEDEFAULT,
                     CW_USEDEFAULT,
                     movWidth + kWinSpacer,  /* set an appropriate width for our movie window */
                     movHeight + kWinSpacer,  /* set an appropriate height for our movie window */
                     ghWndMDIClient, 
                     NULL,
                     ghInst,
                     0);
    }
    gWeAreCreatingWindow = FALSE;
    if (!hwndChild) goto bail;

    // Set the window title to the movie filename
    len = strlen(szPathName);
    while (len--)
    {
      char c = szPathName[len];
      if (c == 0x5c || c == '/')
      {
        strcpy(szFileName, &amp;szPathName[len+1]);
        break;
      }
    }
    SetWindowText(hwndChild, szFileName);

      // Store movie info in private window record
    hWinStorage = (HGLOBAL)GetWindowLong(hwndChild, GWL_USERDATA);
    if (hWinStorage != NULL)
    {
      ChildWindowPtr  childWinPtr = NULL;

      childWinPtr = (ChildWindowPtr)GlobalLock(hWinStorage);
      if (childWinPtr != NULL)
      {

        childWinPtr-&gt;ghInst  = ghInst;

        if (movie != NULL)
        {
          childWinPtr-&gt;movie = movie;
          childWinPtr-&gt;refNum = movieRefNum;
          childWinPtr-&gt;hBkgrndBitmap = ghBkgrndBitMap;
          childWinPtr-&gt;maxWindowWidth = movWidth + kWinSpacer;
          childWinPtr-&gt;maxWindowHeight = movHeight + kWinSpacer;


          QTCode_PositionMovieRectInClientWindow(childWinPtr-&gt;movie, hwndChild);
          err = QTCode_GetStartPointOfFirstVideoSample(childWinPtr-&gt;movie, &amp;childWinPtr-&gt;currentTime);
        }


        hDC = GetDC(hwndChild);
        if (hDC != NULL)
        {
          WORD bitDepthDC;
          RECT windowRect;
          QDErr err;

            GetRBGColorsFromBitmap(  hDC,
                        ghInst,
                        IDB_BITMAP2,    /* ID of background bitmap we want to use */
                        &amp;childWinPtr-&gt;srcRgbQuadArray,  /* on return, a pointer to a rgbquad
                                        structure for this bitmap */
                        &amp;childWinPtr-&gt;hBackgroundPalette);  /* if bitmap bit depth &lt;= 8, a custom palette */
            bitDepthDC = GetDCBitDepth(hDC);
            GetWindowRect(hwndChild, &amp;windowRect);
            childWinPtr-&gt;hBitmap = DoCreateDIBSection(hDC,        /* the device context for this HWND */
                                  childWinPtr-&gt;srcRgbQuadArray,    /* pointer to RGBQUAD array to use when creating
                                                      DIB - NULL if bit depth &gt; 8 */
                                  bitDepthDC,        /* screen depth setting */
                                  RECT_WIDTH(windowRect),  /* window width */
                                  RECT_HEIGHT(windowRect)  /* window height */
                                  );
            childWinPtr-&gt;hMemDC = DoCreateMemoryDC(hwndChild);
            SelectObject(childWinPtr-&gt;hMemDC, childWinPtr-&gt;hBitmap);
            err = QTCode_CreateOffscreen(&amp;childWinPtr-&gt;offscreenGWorld,
                          NULL,
                          NULL,
                          0,
                          childWinPtr-&gt;hBitmap,/* a pointer to a valid bitmap or NULL */
                          childWinPtr-&gt;hMemDC);  /* a pointer to a valid device context or NULL */
            QTCode_SetMovieGWorld(childWinPtr-&gt;movie, childWinPtr-&gt;offscreenGWorld);

            ReleaseDC(hwndChild, hDC);
        }

        GlobalUnlock(hWinStorage);
      }
    }
    SetWindowLong(hwndChild, GWL_USERDATA, (LPARAM)hWinStorage);

    // Show the window
    ShowWindow(hwndChild, SW_SHOW);
    UpdateWindow(hwndChild);
    SetFocus(hwndChild);

    // One more window has been opened
    gOpenMovieCount += 1;

    return TRUE;

    bail:
      if (hwndChild) SendMessage(ghWndMDIClient, WM_MDIDESTROY, (WPARAM)hwndChild, 0L);

    return FALSE;
}


/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DrawMovieAndBackground()                                      */
/*                                                                  */
/*                                                                  */
/*    Code to display a movie and background image in a given       */
/*    window                                                        */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

void DrawMovieAndBackground(HGLOBAL hWinStorage, HDC hDC, HWND hwnd)
{
  HPALETTE    previousPalette  = NULL;
  ChildWindowPtr  childWinPtr;

    if ((childWinPtr = (ChildWindowPtr)GlobalLock(hWinStorage)) != NULL)
      {
        RECT  clientRect, windowRect;
        Rect  movieBounds;
        
          previousPalette = UseCustomPalette(hDC, childWinPtr-&gt;hBackgroundPalette);

          GetClientRect(hwnd, &amp;clientRect);
          GetWindowRect(hwnd, &amp;windowRect);

          DrawBackgroundBitmap(childWinPtr-&gt;hMemDC, hwnd, childWinPtr-&gt;hBkgrndBitmap, &amp;clientRect);
          DrawHelpMessage(childWinPtr-&gt;hMemDC, hwnd);

          GetMovieBox(childWinPtr-&gt;movie, &amp;movieBounds);
          DoDrawFrameInfo(childWinPtr-&gt;hMemDC, hwnd, &amp;movieBounds, childWinPtr-&gt;currentTime);

          SetMovieTimeValue(childWinPtr-&gt;movie, childWinPtr-&gt;currentTime);
          QTCode_ForceMovieRedraw(childWinPtr-&gt;movie);

            /* copy our memory DC image to the display DC */
          BitBlt(hDC, 0, 0, RECT_WIDTH(windowRect), RECT_HEIGHT(windowRect), childWinPtr-&gt;hMemDC,
              0, 0, SRCCOPY);

          GlobalUnlock(hWinStorage);
      }

}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoCut()                                                       */
/*                                                                  */
/*                                                                  */
/*    Handles clipboard &quot;cut&quot; operations                            */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

static void DoCut(HWND hwnd)
{
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoCopy()                                                      */
/*                                                                  */
/*                                                                  */
/*    Handles clipboard &quot;copy&quot; operations                           */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

static void DoCopy(HWND hwnd)
{
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoPaste()                                                     */
/*                                                                  */
/*                                                                  */
/*    Handles clipboard &quot;paste&quot; operations                          */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

static void DoPaste(HWND hwnd)
{
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoClear()                                                     */
/*                                                                  */
/*                                                                  */
/*    Handles clipboard &quot;clear&quot; operations                          */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

static void DoClear(HWND hwnd)
{
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoUndo()                                                      */
/*                                                                  */
/*                                                                  */
/*    Handles clipboard &quot;undo&quot; operations                           */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

static void DoUndo(HWND hwnd)
{
}


/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoIdleMenus()                                                 */
/*                                                                  */
/*                                                                  */
/*    Enable the close item if there are any movie windows opened   */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

int DoIdleMenus(HWND hWnd, HMENU hMenu)
{
    /* Enable the close item if there are any movie windows opened */
  EnableMenuItem(hMenu, IDM_FILECLOSE, (gOpenMovieCount) ? MF_ENABLED : MF_GRAYED);

  return 0;
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DialogProc()                                                  */
/*                                                                  */
/*                                                                  */
/*    Callback for our dialog box                                   */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

static LRESULT CALLBACK DialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
  switch (message)
  {
    case WM_COMMAND:
      switch (LOWORD(wParam))
      {
        case IDOK:
          EndDialog(hDlg, IDOK);
          break;
      }
      break;
  }

    return 0;
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoAbout()                                                     */
/*                                                                  */
/*                                                                  */
/*    Displays a dialog box with information about our program      */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

static void DoAbout()
{
  DialogBox(ghInst, MAKEINTRESOURCE(IDD_ABOUT), ghWndFrame, (DLGPROC)DialogProc);
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DrawBackgroundBitmap()                                        */
/*                                                                  */
/*                                                                  */
/*    Sets the pixels in the target device context to those from    */
/*    a given DIB                                                   */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

void DrawBackgroundBitmap(  HDC    hDC,
              HWND  hwnd,
              HANDLE  hBitMap,
              RECT  *updateRect)
{
  if ((hBitMap != NULL) &amp;&amp; (hDC != NULL) &amp;&amp; (hwnd != NULL))
  {
    LPBITMAPINFO  lpBi;
    LPTSTR      lpBits;
    int       x, y, width, height;
    int        success = FALSE;
    RECT      clientRect;
    int        childHeight, childWidth;

      GetClientRect(hwnd, &amp;clientRect);
      childWidth = RECT_WIDTH(clientRect);
      childHeight = RECT_HEIGHT(clientRect);

      lpBi = (LPBITMAPINFO)LockResource(hBitMap);

      lpBits = (LPSTR)lpBi;
      lpBits += lpBi-&gt;bmiHeader.biSize + ((1 &lt;&lt; lpBi-&gt;bmiHeader.biBitCount) * sizeof(RGBQUAD));
      width = lpBi-&gt;bmiHeader.biWidth;
      height = lpBi-&gt;bmiHeader.biHeight;

      for (y = 0; y &lt;= childHeight; y += lpBi-&gt;bmiHeader.biHeight)
      {
        for (x = 0; x &lt;= childWidth; x += lpBi-&gt;bmiHeader.biWidth)
        {
          BOOL  intersectRect = FALSE;
          RECT  bitMapRect;
          RECT  destRect;
          
          SetRect(&amp;bitMapRect, x, y, x+lpBi-&gt;bmiHeader.biWidth, y+lpBi-&gt;bmiHeader.biHeight);
          
            intersectRect = IntersectRect( &amp;destRect, // address of structure for intersection 
                            updateRect, // address of structure with first rectangle 
                            &amp;bitMapRect // address of structure with second rectangle 
                          ); 
              /* does the current rectangle intersect with the update
                rectangle? If so, draw it, otherwise, don't */
            if (intersectRect)
            {
              success = SetDIBitsToDevice(hDC, x, y,
                            lpBi-&gt;bmiHeader.biWidth,
                            lpBi-&gt;bmiHeader.biHeight,
                            0,0,
                            0, lpBi-&gt;bmiHeader.biHeight,
                            lpBits, lpBi,
                            DIB_RGB_COLORS);
            }
        }
      }
  }

}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoCreatePaletteFromBitMap()                                   */
/*                                                                  */
/*                                                                  */
/*    Builds a palette from a given bitmap                          */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

HPALETTE DoCreatePaletteFromBitMap(  HMODULE    appInstance,
                  WORD    bitMapID)
{
  HANDLE hBitMap;
  HPALETTE hPalette = NULL;


    hBitMap = LoadResource(appInstance,
                FindResource(appInstance, MAKEINTRESOURCE(bitMapID), RT_BITMAP) );
    if (hBitMap != NULL)
    {
      LPBITMAPINFO  lpBi;
      HANDLE      hPal;
      LPLOGPALETTE  lpPal;
      int        i, nColorData;

        lpBi = (LPBITMAPINFO)LockResource(hBitMap);

        if (lpBi-&gt;bmiHeader.biClrUsed != 0)
        {
          nColorData = lpBi-&gt;bmiHeader.biClrUsed;
        }
        else
        {
          switch( lpBi-&gt;bmiHeader.biBitCount)
          {
            case 1 :
              nColorData = 2;
            break;
          
            case 4 :
              nColorData = 16;
            break;
          
            case 8 :
              nColorData = 256;
            break;
          
            case 24 :
            case 32 : 
              nColorData = 0;
            break;
          }
        }

        hPal = GlobalAlloc( GHND, sizeof (LOGPALETTE) + (nColorData * sizeof (PALETTEENTRY)) );
        lpPal = (LPLOGPALETTE)GlobalLock(hPal);

        lpPal-&gt;palVersion = 0x300;
        lpPal-&gt;palNumEntries = nColorData;

        for (i = 0; i &lt; nColorData; i++)
        {
          lpPal-&gt;palPalEntry[i].peRed    = lpBi-&gt;bmiColors[i].rgbRed;
          lpPal-&gt;palPalEntry[i].peGreen  = lpBi-&gt;bmiColors[i].rgbGreen;
          lpPal-&gt;palPalEntry[i].peBlue  = lpBi-&gt;bmiColors[i].rgbBlue;

        }

        hPalette = CreatePalette( lpPal );

        GlobalUnlock(hPal);
        GlobalFree(hPal);

    }

    return hPalette;
}


/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoEraseRect()                                                 */
/*                                                                  */
/*                                                                  */
/*    Code to erase a given windows rectangle                       */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

void DoEraseRect(HDC  hDC,
        RECT  *theRect)
{
  if (hDC != NULL)
  {
    HBRUSH    aBrush;
      
        /* erase rect. for string before redraw */
      aBrush = CreateSolidBrush(RGB(255,255,255));
      if (aBrush != NULL)
      {
        FillRect(hDC, theRect, aBrush);
        DeleteObject(aBrush);
      }

  }
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    GetLineHeight()                                               */
/*                                                                  */
/*                                                                  */
/*    Returns the line height for a given device context            */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

int GetLineHeight(HDC  hDC)
{
  TEXTMETRIC  tm;

    GetTextMetrics(hDC, &amp;tm);
    return(tm.tmExternalLeading + tm.tmHeight);
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DrawHelpMessage()                                             */
/*                                                                  */
/*                                                                  */
/*    Draws our help text in a window                               */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

void DrawHelpMessage(  HDC    hDC,
            HWND  hwnd)
{

  if (hDC != NULL)
  {
    RECT    clientRect, targetRect;
    char    helpText[100] = &quot;Press &lt;enter&gt; to advance to next movie frame&quot;;
    TEXTMETRIC  tm;
    int      nLineHeight, strWidth;

      GetClientRect(hwnd, &amp;clientRect);
      GetTextMetrics(hDC, &amp;tm);
      nLineHeight = tm.tmExternalLeading + tm.tmHeight;

      strWidth =  strlen( (LPCTSTR)&amp;helpText ) * tm.tmAveCharWidth;
      SetRect(&amp;targetRect,  clientRect.left + ((RECT_WIDTH(clientRect) - strWidth)/2),
                  clientRect.bottom - nLineHeight,
                  clientRect.left + ((RECT_WIDTH(clientRect) - strWidth)/2) + strWidth,
                  clientRect.bottom);
      DoEraseRect(hDC, &amp;targetRect);

        /* draw help message */
      DrawText(hDC, (LPCTSTR)&amp;helpText, -1, &amp;targetRect, DT_CENTER);
  }
}


/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoCreateDIBSection()                                          */
/*                                                                  */
/*                                                                  */
/*    Creates a device independent bitmap using CreateDIBSection    */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

HBITMAP DoCreateDIBSection(  HDC        dc,
              LPRGBQUAD    srcRgbQuadArray,  /* if (depth &gt; 8), this param ignored */
              WORD      depth,
              LONG      width,
              LONG      height
              )
{
  UINT  usage;
  LPTSTR  bits = NULL;
     
    // a struct large enough to hold the largest bitmapinfo ...
  struct BITMAPINFO_256
    {   
        BITMAPINFOHEADER bmiHeader;
        long bmiColors[256];
    };
  typedef struct BITMAPINFO_256 BITMAPINFO_256;

    BITMAPINFO_256 bmi;


    memset(&amp;bmi, 0, sizeof(bmi));

    bmi.bmiHeader.biSize      = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth      = width;
      /* important!!! - we specify a top-down DIB (by passing a negative height value)
        with origin in the upper left, otherwise our movie image will show up as inverted */
    bmi.bmiHeader.biHeight      = -1 * height;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = depth;
    bmi.bmiHeader.biSizeImage    = 0;
    bmi.bmiHeader.biClrUsed      = 0;
    bmi.bmiHeader.biClrImportant  = 0;


    switch ( depth )
    {
      case 4:
      case 8:
        {
          long    num_colors = (1 &lt;&lt; depth),
                i;
          LPRGBQUAD  lpQuadDest, lpQuadSource;


            bmi.bmiHeader.biCompression = BI_RGB;
            usage = DIB_RGB_COLORS;

            lpQuadSource = srcRgbQuadArray;
            
            for (i=0; i&lt;num_colors; i++)
            {
              lpQuadDest = (LPRGBQUAD)&amp;bmi.bmiColors[i];

              lpQuadDest-&gt;rgbBlue    = lpQuadSource-&gt;rgbBlue;
              lpQuadDest-&gt;rgbRed    = lpQuadSource-&gt;rgbRed;
              lpQuadDest-&gt;rgbGreen  = lpQuadSource-&gt;rgbGreen;
              lpQuadDest-&gt;rgbReserved  = lpQuadSource-&gt;rgbReserved;

              ++lpQuadSource;
            }
        }
        break;

      case 16:
      case 24:
      case 32:
        {          
          bmi.bmiHeader.biCompression = BI_RGB;
          usage = DIB_RGB_COLORS;
        
          bmi.bmiColors[0] = 0;
          bmi.bmiColors[1] = 0;
          bmi.bmiColors[2] = 0;
        }
        break;
   
      default:
        break;
    }

    return CreateDIBSection(dc, (BITMAPINFO *) &amp;bmi, usage, &amp;bits, NULL, 0);
}


/* ---------------------------------------------------------------- */
/*                                                                  */
/*    GetDCBitDepth()                                               */
/*                                                                  */
/*                                                                  */
/*    Returns the bit depth of a device context                     */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

WORD  GetDCBitDepth(HDC  hDC)
{
  return(GetDeviceCaps( hDC, BITSPIXEL)); 
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    GetBitDepthOfBitmap()                                         */
/*                                                                  */
/*                                                                  */
/*    Returns the bit depth of a bitmap                             */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

WORD  GetBitDepthOfBitmap(HMODULE appInstance,  /* application instance */
              WORD bitMapID      /* resource ID of bit map */
              )
{
  HBITMAP hBitMap;

    hBitMap = LoadResource(appInstance, FindResource(appInstance, MAKEINTRESOURCE(bitMapID), RT_BITMAP) );
    if (hBitMap != NULL)
    {
      LPBITMAPINFO  lpBi;

        lpBi = (LPBITMAPINFO)LockResource(hBitMap);

        return (lpBi-&gt;bmiHeader.biBitCount);
    }
    else
    {
      return 0;
    }

}


/* ---------------------------------------------------------------- */
/*                                                                  */
/*    GetRBGColorsFromBitmap()                                      */
/*                                                                  */
/*                                                                  */
/*    Returns the RGBQUAD array for a bitmap                        */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

void GetRBGColorsFromBitmap(HDC      hDC,
              HANDLE    hInst,
              WORD    bitMapID,
              LPRGBQUAD  *srcRgbQuadArray,  /* on return, a pointer to a rgbquad
                              structure for this bitmap */
              HPALETTE  *hPalette)  /* if bitmap bit depth &lt;= 8, a custom palette
                          for the bitmap will be returned here */
{
  WORD      bitDepthDC, bitDepthBITMAP;
  LPBITMAPINFO  srcBITMAPINFO;
  HANDLE      hBitMapTemp;

    bitDepthDC    =  GetDCBitDepth(hDC);
    bitDepthBITMAP  =  GetBitDepthOfBitmap(hInst,    /* application instance */
                        bitMapID  /* resource ID of bit map */
                        );
    srcBITMAPINFO = NULL;
    *srcRgbQuadArray = NULL;
    *hPalette = NULL;

      /* does the device context have a bit depth &lt;= 8? */
    if (bitDepthDC &lt;= 8)
    {
        /* does our bitmap have a depth &lt;= 8? */
      if (bitDepthBITMAP &lt;= 8)
      {
          /* create custom palette for use with this bitmap */
        *hPalette = DoCreatePaletteFromBitMap(hInst, bitMapID);

          /* get color data to use when calling CreateDIBSection */
        hBitMapTemp  = LoadResource(hInst,
                      FindResource(hInst, MAKEINTRESOURCE(bitMapID),
                      RT_BITMAP) );
        if (hBitMapTemp != NULL)
        {
            /* get bitmapinfo data */
          srcBITMAPINFO = (LPBITMAPINFO)LockResource(hBitMapTemp);
            /* get pointer to rgbquad array for this bitmap */
          *srcRgbQuadArray = &amp;srcBITMAPINFO-&gt;bmiColors[0];
        }
      }
    }

}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoCreateMemoryDC()                                            */
/*                                                                  */
/*                                                                  */
/*    Creates a memory device context                               */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

HDC  DoCreateMemoryDC(HWND  hwnd)
{
  HDC  hMemDC, hDC;

    hDC = GetDC(hwnd);
    if (hDC)
    {
      hMemDC = CreateCompatibleDC(hDC);
      SetMapMode(hMemDC, GetMapMode(hDC));
      ReleaseDC(hwnd, hDC);

      return hMemDC;
    }

    return NULL;
}



/* ---------------------------------------------------------------- */
/*                                                                  */
/*    UseCustomPalette()                                            */
/*                                                                  */
/*                                                                  */
/*    Selects/Realizes a logical palette                            */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

HPALETTE UseCustomPalette(HDC  hDC, HPALETTE  newPalette)
{
  HPALETTE  previousPalette;
  UINT    nEntries;

      /* use a custom palette if need be */
    if (newPalette)
    {
      previousPalette = SelectPalette(hDC, newPalette, FALSE);
      nEntries = RealizePalette(hDC);
    }

    return previousPalette;
}

/* ---------------------------------------------------------------- */
/*                                                                  */
/*    DoDrawFrameInfo()                                             */
/*                                                                  */
/*                                                                  */
/*    Draws our help text messages into a window                    */
/*                                                                  */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

void DoDrawFrameInfo(HDC    hMemDC,
           HWND    hwnd,
           Rect    *movieBounds,
           TimeValue  theTime)
{
  RECT    destRect;
  int      nLineHeight;
  Str255     theString;
  char    frameText[25] = &quot;Frame &quot;;
  Rect    centeredRect;


    nLineHeight = GetLineHeight(hMemDC);

    CenterMovieRectInWindow(hwnd,          /* window where we are placing the image */
                (movieBounds-&gt;right - movieBounds-&gt;left),
                (movieBounds-&gt;bottom - movieBounds-&gt;top),  /* width, height, of the movie */
                &amp;centeredRect      /* on output, a Mac Rect centered in the window */
                );
    SetRect(&amp;destRect,  (int)centeredRect.left - nLineHeight,
              (int)centeredRect.top - nLineHeight /*- menuSize*/,
              (int)centeredRect.right + nLineHeight,
              (int)centeredRect.bottom + nLineHeight /*- menuSize*/);
    DoEraseRect(hMemDC, &amp;destRect);

    SetRect(&amp;destRect,  (int)centeredRect.left,
              (int)centeredRect.bottom /*- menuSize*/,
              (int)centeredRect.right,
              (int)centeredRect.bottom + nLineHeight /*- menuSize*/);
    DoEraseRect(hMemDC, &amp;destRect);

      /* draw new frame # */
    NumToString((long)theTime, theString);
    p2cstr(theString);
    lstrcat((LPSTR)frameText, (LPCSTR)&amp;theString);
    DrawText(hMemDC, (LPCTSTR)&amp;frameText, -1, &amp;destRect, DT_CENTER);

}


/* ---------------------------------------------------------------- */
/*                                                                  */
/*    CenterMovieRectInWindow()                                     */
/*                                                                  */
/*                                                                  */
/*    Given height/width values for a movie, returns a Mac rect     */
/*    for the movie centered in a window                            */
/*                                                                  */
/*                                                                  */
/* ---------------------------------------------------------------- */

void CenterMovieRectInWindow(HWND  hwnd,          /* window where we are placing the image */
                int  movWidth, int movHeight,  /* width, height, of the movie */
                Rect  *centeredRect      /* on output, a Mac Rect centered in the window */
                )
{
  RECT  clientRect;
  int    availSpace;
  BOOL  success;

    success = GetClientRect(hwnd, // handle of window 
                &amp;clientRect// address of structure for client coordinates 
                );  

    availSpace = RECT_WIDTH(clientRect) - movWidth;
    if (availSpace &lt; 0)
    {
      /* movie is bigger than client space? */
    }
    centeredRect-&gt;left = clientRect.left + availSpace/2;

    availSpace = RECT_HEIGHT(clientRect) - movHeight;
    if (availSpace &lt; 0)
    {
      /* movie is bigger than client space? */
    }
    centeredRect-&gt;top = clientRect.top + availSpace/2;
    centeredRect-&gt;right = centeredRect-&gt;left + movWidth;
    centeredRect-&gt;bottom = centeredRect-&gt;top + movHeight;

}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/offscreen.win/listing1.html%3Fid%3DDTS10000772-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/offscreen.win/listing1.html%3Fid%3DDTS10000772-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/offscreen.win/listing1.html%3Fid%3DDTS10000772-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>