<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>MyControl(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING361></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-360.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-362.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-297.html"><B>Chapter 5 - Control Manager</B></A> / <A HREF="Toolbox-315.html"><B>Control Manager Reference</B></A><BR><DL><DD><A HREF="Toolbox-359.html"><B>Application-Defined Routines</B></A> / <A HREF="Toolbox-360.html"><B>Defining Your Own Control Definition Function</B></A></DL></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING361-0></A>
<H3>MyControl</H3>
 <A NAME=MARKER-2-558></A>If you wish to define new, nonstandard controls for your application, you must write a control definition function and store it in a resource file as a resource of type <CODE>'CDEF'</CODE>. Here's how you would declare a procedure named <CODE>MyControl</CODE>:<P>
<PRE>
FUNCTION MyControl (varCode: Integer; theControl: ControlHandle;
                     message: Integer; param: LongInt): LongInt;
</PRE>
<DL>
<DT><CODE>varCode</CODE>
<DD> The variation code for this control. To derive the control definition ID for the control, add this value to the result of 16 multiplied by the resource ID of the <CODE>'CDEF'</CODE> resource containing this function. The variation code allows you to specify several control definition IDs within one <CODE>'CDEF'</CODE> resource, thereby defining several variations of the same basic control.
<DT><CODE>theControl</CODE>
<DD> A handle to the control that the operation will affect.
<DT><CODE>message</CODE>
<DD> A value (from the following list) that specifies which operation your function must undertake.
</DL>
<PRE>
         CONST drawCntl       = 0;  {draw the control or its part}
               testCntl       = 1;  {test where mouse button }
                                    { is pressed}
               calcCRgns      = 2;  {calculate region for }
                                    { control or indicator in }
                                    { 24-bit systems}
               initCntl       = 3;  {peform any additional }
                                    { control initialization}

               dispCntl       = 4;  {perform any additional }
                                    { disposal actions}
               posCntl        = 5;  {move indicator and }
                                    { update its setting}
               thumbCntl      = 6;  {calculate parameters for }
                                    { dragging indicator}
               dragCntl       = 7;  {perform any custom dragging }
                                    { of control or its indicator}
               autoTrack      = 8;  {execute action procedure }
                                    { specified by your function}
               calcCntlRgn    = 10; {calculate region for control}
               calcThumbRgn   = 11; {calculate region for }
                                    { indicator}
</PRE>
<DL>
<DT><CODE>param</CODE>
<DD> A value whose meaning depends on the operation specified in the <CODE>message</CODE> parameter.
</DL>
<A NAME=HEADING361-8></A>
<H5>DESCRIPTION</H5>
 The Control Manager calls your control definition function under various circumstances; the Control Manager uses the <CODE>message</CODE> parameter to inform your control definition function what action it must perform. The data that the Control Manager passes in the <CODE>param</CODE> parameter, the action that your control definition function must undertake, and the function result that your control definition function returns all depend on the value that the Control Manager passes in the <CODE>message</CODE> parameter. The rest of this section describes how to respond to the various values that the Control Manager passes in the <CODE>message</CODE> parameter.<P>
<A NAME=HEADING361-10></A>
<H4>Drawing the Control or Its Part</H4>
 <A NAME=MARKER-13-559></A><A NAME=MARKER-2-560></A>When the Control Manager passes the value for the <CODE>drawCntl</CODE> constant in the <CODE>message</CODE> parameter, the low word in the <CODE>param</CODE> parameter has one of the following values:<P>
<UL>
<LI>the value 0, indicating the entire control
<LI>the value 129, signifying an indicator that must be moved
<LI>any other value, indicating a part code for the control (Don't use part code 128, which is reserved for future use, or part code 129, which the Control Manager uses to signify an indicator that must be moved.)<P>
</UL>
<DL>
<DT><B>Note</B>
<DD>For the <CODE>drawCntl</CODE> message, the high-order word of the <CODE>param</CODE> parameter may contain undefined data; therefore, evaluate only <BR>the low-order word of this parameter.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 If the specified control is visible, your control definition function should draw the control (or the part specified in the <CODE>param</CODE> parameter) within the control's rectangle. If the control is invisible (that is, if its <CODE>contrlVis</CODE> field is set to 0), your control definition function does nothing. <P>
 When drawing the control or its part, take into account the current values of its <CODE>contrlHilite</CODE> and <CODE>contrlValue</CODE> fields of the control's control record.<P>
 If the part code for your control's indicator is passed in <CODE>param</CODE>, assume that the indicator hasn't moved; the Control Manager, for example, may be calling your control definition function so that you may simply highlight the indicator. However, when your application calls the <CODE>SetControlValue</CODE>, <CODE>SetControlMinimum</CODE>, and <CODE>SetControlMaximum</CODE> procedures, they in turn may call your control definition function to redraw the <BR>indicator. Since these routines have no way of determining what part code you chose <BR>for your indicator, they all pass 129 in <CODE>param</CODE>, meaning that you should move your <BR>indicator. Your control definition function must detect this part code as a special case and remove the indicator from its former location before drawing it. If your control has more than one indicator, you should interpret 129 to mean all indicators.<P>
 When passed the value for the <CODE>drawCntl</CODE> constant in the <CODE>message</CODE> parameter, your control definition function should always return 0 as its function result.<A NAME=MARKER-2-561></A><P>
<A NAME=HEADING361-20></A>
<H4>Testing Where the Mouse-Down Event Occurs</H4>
 <A NAME=MARKER-13-562></A><A NAME=MARKER-2-563></A>To request your control definition function to determine whether a specified point is <BR>in a visible control, the <CODE>FindControl</CODE> function sends the value for the <CODE>testCntl</CODE> constant in the <CODE>message</CODE> parameter. In this case, the <CODE>param</CODE> parameter specifies a point (in coordinates local to the control's window) as follows:<P>
<UL>
<LI>The point's vertical coordinate is contained in the high-order word of the long integer.
<LI> The point's horizontal coordinate is contained in the low-order word.<P>
</UL>
 When passed the value for the <CODE>testCntl</CODE> constant in the <CODE>message</CODE> parameter, your control definition function should return the part code of the part that contains the specified point; it should return 0 if the point is outside the control or if the control <BR>is inactive.<A NAME=MARKER-2-564></A><P>
<A NAME=HEADING361-25></A>
<H4>Calculating the Control and Indicator Regions</H4>
 <A NAME=MARKER-13-565></A><A NAME=MARKER-2-566></A>When the Control Manager passes the value for the <CODE>calcCRgns</CODE> constant in the <CODE>message</CODE> parameter, your control definition function should calculate the region occupied by either the control or its indicator. The Control Manager passes a QuickDraw region handle in the <CODE>param</CODE> parameter; it is this region that you calculate. If the high-order bit of <CODE>param</CODE> is set, the region requested is that of the control's indicator; otherwise, the region requested is that of the entire control. Your control definition function should clear the high bit of the region handle before calculating the region.<P>
 <A NAME=MARKER-13-567></A><A NAME=MARKER-13-568></A><A NAME=MARKER-2-569></A>When the Control Manager passes the value for the <CODE>calcCntlRgn</CODE> constant in the <CODE>message</CODE> parameter, your control definition function should calculate the region passed in the <CODE>param</CODE> parameter for the specified control. When the Control Manager passes the value for the <CODE>calcThumbRgn</CODE> constant, calculate the region occupied by the indicator.<P>
 When passed the values for the <CODE>calcCRgns</CODE>, <CODE>calcCntlRgn</CODE>, and <CODE>calcThumbRgn</CODE> constants, your control definition function should always return 0, and it should express the region in the local coordinate system of the control's window.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>The Control Manager passes the <CODE>calcCRgns</CODE> constant when the 24-bit Memory Manager is in operation. When the 32-bit Memory Manager is in operation, the Control Manager instead passes the <CODE>calcCntlRgn</CODE> constant or the <CODE>calcThumbRgn</CODE> constant. Your control definition function should respond to all three constants.<EM></EM> <A NAME=MARKER-2-442></A><A NAME=MARKER-9-443></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING361-30></A>
<H4>Performing Any Additional Initialization</H4>
 <A NAME=MARKER-13-572></A><A NAME=MARKER-2-445></A>After initializing fields of a control record as appropriate when creating a new control, the Control Manager passes <CODE>initCntl</CODE> in the <CODE>message</CODE> parameter to give your control definition function the opportunity to perform any type-specific initialization you may require. For example, if you implement the control's action procedure in its control definition function, you'll need to store <CODE>Pointer(-1)</CODE> in the <CODE>contrlAction</CODE> field of the control's control record. Then, in a call to <CODE>TrackControl</CODE> for this control, you would pass <CODE>Pointer(-1)</CODE> in the <CODE>actionProc</CODE> parameter of <CODE>TrackControl</CODE>.<P>
 The standard control definition function for scroll bars allocates space for a region to hold the scroll box and stores the region handle in the <CODE>contrlData</CODE> field of the new control record.<P>
 When passed the value for the <CODE>initCntl</CODE> constant in the <CODE>message</CODE> parameter, your control definition function should ignore the <CODE>param</CODE> parameter and return 0 as a <BR>function result.<A NAME=MARKER-2-574></A><P>
<A NAME=HEADING361-34></A>
<H4>Performing Any Additional Disposal Actions</H4>
 <A NAME=MARKER-13-575></A><A NAME=MARKER-2-576></A>The <CODE>DisposeControl</CODE> procedure passes <CODE>dispCntl</CODE> in the <CODE>message</CODE> parameter to give your control definition function the opportunity to carry out any additional actions when disposing of a control. For example, the standard definition function for scroll bars releases the memory occupied by the scroll box region, whose handle is kept in the <CODE>contrlData</CODE> field of the control's control record.<P>
 When passed the value for the <CODE>dispCntl</CODE> constant in the <CODE>message</CODE> parameter, your control definition function should ignore the <CODE>param</CODE> parameter and return 0 as a <BR>function result.<A NAME=MARKER-2-577></A><P>
<A NAME=HEADING361-37></A>
<H4>Moving the Indicator</H4>
 <A NAME=MARKER-13-578></A><A NAME=MARKER-2-579></A>When a mouse-up event occurs in the indicator of a control, the <CODE>TrackControl</CODE> function calls your control definition function and passes <CODE>posCntl</CODE> in the <CODE>message</CODE> parameter. In this case, the <CODE>param</CODE> parameter contains a point (in coordinates local to the control's window) that specifies the vertical and horizontal offset, in pixels, by which your control definition function should move the indicator from its current position. Typically, this is the offset between the points where the cursor was when the user pressed and released the mouse button while dragging the indicator. The offset point is specified as follows:<P>
<UL>
<LI>The point's vertical offset is contained in the high-order word of the <CODE>param</CODE> parameter.
<LI> The point's horizontal offset is contained in the low-order word.<P>
</UL>
 Your definition function should calculate the control's new setting based on the <BR>given offset and then, to reflect the new setting, redraw the control and update the <CODE>contrlValue</CODE> field in the control's control record. Your control definition function should ignore the <CODE>param</CODE> parameter and return 0 as a function result.<P>
 Note that the <CODE>SetControlValue</CODE>, <CODE>SetControlMinimum</CODE>, and <CODE>SetControlMaximum</CODE> procedures do not call your control definition function with the <CODE>posCntl</CODE> message; instead, they pass the <CODE>drawCntl</CODE> message.<A NAME=MARKER-2-580></A><P>
<A NAME=HEADING361-43></A>
<H4>Calculating Parameters for Dragging the Indicator</H4>
 <A NAME=MARKER-13-581></A><A NAME=MARKER-2-582></A>When the Control Manager passes the value for <CODE>thumbCntl</CODE> in the <CODE>message</CODE> parameter, your control definition function should respond by calculating values (analogous to <BR>the <CODE>limitRect</CODE>, <CODE>slopRect</CODE>, and <CODE>axis</CODE> parameters of <CODE>DragControl</CODE>) that constrain <BR>how the indicator is dragged. The <CODE>param</CODE> parameter contains a pointer to the following data structure:<P>
<PRE>
RECORD
   limitRect,slopRect:  Rect;
   axis:                Integer;
END;
</PRE>
 On entry, the field <CODE>param^.limitRect.topLeft</CODE> contains the point where the mouse-down event first occurred. Your definition function should store the appropriate values into the fields of the record pointed to by <CODE>param</CODE>; they're analogous to the similarly named parameters to the Window Manager function <CODE>DragGrayRgn</CODE>.<A NAME=MARKER-2-583></A><P>
<A NAME=HEADING361-47></A>
<H4>Performing Custom Dragging</H4>
 <A NAME=MARKER-13-584></A><A NAME=MARKER-2-585></A><A NAME=MARKER-2-586></A>The Control Manager passes <CODE>dragCntl</CODE> in the <CODE>message</CODE> parameter to give your control definition function the opportunity to specify its own method for dragging a control (or its indicator).<P>
 The <CODE>param</CODE> parameter specifies whether the user is dragging an indicator or the <BR>whole control: <P>
<UL>
<LI>A value of 0 means the user is dragging the entire control.
<LI>Any nonzero value means the user is dragging only the indicator.<P>
</UL>
 If you want to use the Control Manager's default method of dragging (which is to call <CODE>DragControl</CODE> to drag the control or the Window Manager function <CODE>DragGrayRgn</CODE> to drag its indicator), return 0 as the function result for your control definition function.<P>
 If your control definition function returns any nonzero result, the Control Manager does not drag your control, and instead your control definition function must drag the specified control (or its indicator) to follow the cursor until the user releases the mouse button, as follows:<P>
<UL>
<LI>If the user drags the entire control, your definition function should use the <CODE>MoveControl</CODE> procedure to reposition the control to its new location after the user releases the mouse button.
<LI>If the user drags the indicator, your definition function must calculate the control's new setting (based on the pixel offset between the points where the cursor was when the user pressed and released the mouse button while dragging the indicator) and then, to reflect the new setting, redraw the control and update the <CODE>contrlValue</CODE> field in the control's control record. Note that, in this case, the <CODE>TrackControl</CODE> function returns 0 whether or not the user changes the indicator's position. Thus, you must determine whether the user has changed the control's setting, for instance, by comparing the control's value before and after the call to <CODE>TrackControl</CODE>.<A NAME=MARKER-2-587></A><A NAME=MARKER-2-450></A><A NAME=MARKER-9-451></A><P>
</UL>
<A NAME=HEADING361-56></A>
<H4>Executing an Action Procedure</H4>
 <A NAME=MARKER-13-590></A><A NAME=MARKER-2-453></A>You can design a control whose action procedure is specified by your control definition function. When you create the control, your control definition function must first respond to the <CODE>initCntl</CODE> message by storing <CODE>Pointer(-1)</CODE> in the <CODE>contrlAction</CODE> field of the control's control record. (As previously explained, the Control Manager sends the <CODE>initCntl</CODE> message to your control definition function after initializing <BR>the fields of a new control record.) Then, when your application passes <CODE>Pointer(-1)</CODE> <BR>in the <CODE>actionProc</CODE> parameter to the <CODE>TrackControl</CODE> function, <CODE>TrackControl</CODE> <BR>calls your control definition function with the <CODE>autoTrack</CODE> message. The <CODE>param</CODE> parameter specifies the part code of the part where the mouse-down event occurs. <BR>Your control definition function should then use this information to respond as an action procedure would.<P>
<DL>
<DT><B>Note</B>
<DD>For the <CODE>autoTrack</CODE> message, the high-order word of the <CODE>param</CODE> parameter may contain undefined data; therefore, evaluate only <BR>the low-order word of this parameter.<EM></EM><A NAME=MARKER-2-592></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING361-59></A>
<H5>ASSEMBLY-LANGUAGE INFORMATION</H5>
 The function's entry point must be at the beginning.<P>
<A NAME=HEADING361-61></A>
<H5>SEE ALSO</H5>
 The <CODE>TrackControl</CODE> function is described on <A HREF=Toolbox-332.html#MARKER-9-419>page 5-84</A>; creating an action procedure is described in the next section.<A NAME=MARKER-2-593></A><A NAME=MARKER-2-454></A><A NAME=MARKER-2-455></A><A NAME=MARKER-2-456></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-360.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-362.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
