<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Drawing With QuickDraw (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING60></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-59.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-61.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-58.html"><B>Chapter 3 - QuickDraw Drawing</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING60-0></A>
<H1><A NAME=MARKER-9-72></A>Drawing With QuickDraw</H1>
 You can use QuickDraw's basic drawing routines to<P>
<UL>
<LI>draw lines of various thicknesses and in various patterns
<LI>draw rectangles, rounded rectangles, ovals, arcs, wedges, polygons, and regions in various patterns
<LI>draw lines and shapes in any of eight predefined colors, against a background of any of these eight predefined colors
<LI>perform calculations on and manipulate rectangles and regions
<LI>copy bits from the bit image in the bitmap of one graphics port into the bitmap of another graphics port
<LI>customize QuickDraw's drawing behavior<P>
</UL>
 System software uses QuickDraw's drawing routines to implement the Macintosh user interface. The next several sections provide an introduction to these routines, which your application can use to create complex onscreen images.<P>
 To draw lines, your application<P>
<UL>
<LI>moves the graphics pen to a location within its graphics port
<LI>draws a line to a different coordinate<P>
</UL>
 To draw rectangles, rounded rectangles, ovals, arcs, and wedges, your application generally<P>
<UL>
<LI>defines the outline of the shape in the local coordinates of the graphics port
<LI>frames the shape's outline to draw it
<LI>transfers patterns to the outline and interior of the shape to paint or fill it<P>
</UL>
 To draw regions and polygons, your application<P>
<UL>
<LI>uses an open routine to start building the shape
<LI>calls drawing routines to build the shape
<LI>uses a close routine to stop collecting drawing routines for the shape
<LI>frames the shape's outline to draw it
<LI>transfers patterns to the outline and interior of the shape to paint or fill it<P>
</UL>
 These tasks are explained in greater detail in the rest of this chapter.<P>
 Before using QuickDraw's drawing routines, you must initialize QuickDraw with the <CODE>InitGraf</CODE> procedure, as explained in the chapter "Basic QuickDraw."<P>
 The routines described in this chapter are available on all models of Macintosh computers. However, all nonwhite colors that you specify with the <CODE>ForeColor</CODE> and <CODE>BackColor</CODE> procedures are displayed as black on a black-and-white screen. Before using the <CODE>ForeColor</CODE> and <CODE>BackColor</CODE> procedures to display colors in a basic graphics port, you can use the <CODE>DeviceLoop</CODE> procedure, which is described in the chapter "Graphics Device," to determine the color characteristics of the current screen.<P>
<A NAME=HEADING60-25></A>
<H2>Drawing Lines</H2>
 A line is defined by two points: the current location of the graphics pen and its destination. The graphics pen draws below and to the right of the defining points. As described in <A HREF=QuickDraw-59.html#MARKER-9-14>"The Graphics Pen" on page 3-4</A>, the pen draws the line between its defining points with the size, pattern, and pattern mode stored in the current graphics port.<P>
 You specify where to begin drawing a line by using the <CODE>MoveTo</CODE> or <CODE>Move</CODE> procedure to place the graphics pen at some point in the window's local coordinate system. Then you call the <CODE>LineTo</CODE> or <CODE>Line</CODE> procedure to draw a line from there to another point. Take, for example, the following lines of code:<P>
<PRE>
MoveTo(20,20);
LineTo(70,20);
LineTo(70,70);
</PRE>
 The <CODE>MoveTo</CODE> procedure moves the graphics pen to a point with a horizontal coordinate of 20 and a vertical coordinate of 20 (in the local coordinate system of the graphics port). The first call to the <CODE>LineTo</CODE> procedure draws a line from that position to the point with a horizontal coordinate of 70 and a vertical coordinate of 20. The second call to the <CODE>LineTo</CODE> procedure draws a line from the pen's new position to the point with a horizontal coordinate of 70 and a vertical coordinate of 70, as shown in <A HREF=#MARKER-9-78>Figure 3-5</A>. <P>
<B>Figure 3-5  <A NAME=MARKER-9-78></A>Using the <CODE>LineTo</CODE> procedure</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-L-14.jpg"><BR>
 <A HREF=#MARKER-9-79>Listing 3-1</A> illustrates how to use the <CODE>LineTo</CODE> procedure to draw the four sides of a square, which is shown on the left side of <A HREF=#MARKER-9-80>Figure 3-6</A>. In <A HREF=#MARKER-9-80>Figure 3-6</A>, the current graphics port is the window "untitled."<P>
<B>Listing 3-1  <A NAME=MARKER-9-79></A>Drawing lines with the <CODE>LineTo</CODE> and <CODE>Line</CODE> procedures</B><P>
<PRE>
PROCEDURE MyDrawLines;
BEGIN
   MoveTo(20,20);
   LineTo(70,20);
   LineTo(70,70);
   LineTo(20,70);
   LineTo(20,20);

   Move(70,0);
   Line(50,0);
   Line(0,50);
   Line(-50,0);
   Line(0,-50);
END;
</PRE>
<B>Figure 3-6  <A NAME=MARKER-9-80></A>Drawing lines</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-S-13.jpg"><BR>
 The <CODE>MoveTo</CODE> and <CODE>LineTo</CODE> procedures require you to specify a point in the local coordinate system of the current graphics port. These procedures then transfer the graphics pen to that specific location. As alternatives to using the <CODE>MoveTo</CODE> and <CODE>LineTo</CODE> procedures, you can use the <CODE>Move</CODE> and <CODE>Line</CODE> procedures, which require you to pass relative horizontal and vertical distances to move the pen from its current location. The square on the right side of <A HREF=#MARKER-9-80>Figure 3-6</A> is drawn using the <CODE>Move</CODE> and <CODE>Line</CODE> procedures.<P>
 <A NAME=MARKER-2-84></A>The final call to <CODE>LineTo</CODE> in <A HREF=#MARKER-9-79>Listing 3-1</A> moves the graphics pen to the point with a horizontal coordinate of 20 and a vertical coordinate of 20. <A HREF=#MARKER-9-79>Listing 3-1</A> then uses the <CODE>Move</CODE> procedure to move the graphics pen a horizontal distance of 70 points--that is, to the point with a horizontal coordinate of 90. The first call to the <CODE>Line</CODE> procedure draws a horizontal line 50 pixels long--that is, to the point with a horizontal coordinate of 140 and a vertical coordinate of 20. Starting from there, the second call to <CODE>Line</CODE> draws a vertical line 50 pixels long--that is, to the point with a horizontal coordinate of 140 and a vertical coordinate of 70, as shown in <A HREF=#MARKER-9-86>Figure 3-7</A>.<A NAME=MARKER-11-104></A><P>
<B>Figure 3-7  <A NAME=MARKER-9-86></A>Using the <CODE>LineTo</CODE> and <CODE>Line</CODE> procedures</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-L-15.jpg"><BR>
 <A NAME=MARKER-11-110></A>In <A HREF=#MARKER-9-80>Figure 3-6</A>, the lines are drawn using the default pen size (1,1), giving the line a vertical depth of one pixel and a horizontal width of one pixel. You can use the <CODE>PenSize</CODE> procedure to change the width and height of the graphics pen so that it draws thicker lines, as shown in <A HREF=#MARKER-9-89>Figure 3-8</A>.<A NAME=MARKER-2-88></A><P>
<B>Figure 3-8  <A NAME=MARKER-9-89></A>Resizing the pen</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-S-16.jpg"><BR>
 The square on the left side of <A HREF=#MARKER-9-89>Figure 3-8</A> is drawn with a pen that has a width of two pixels and a height of eight pixels. The square on the right side of this figure is drawn with a pen that has a width of eight pixels and a height of two pixels. <A HREF=#MARKER-9-90>Listing 3-2</A> shows the code that draws these squares.<P>
<B>Listing 3-2  <A NAME=MARKER-9-90></A>Using the <CODE>PenSize</CODE> procedure</B><P>
<PRE>
PROCEDURE MyResizePens;
BEGIN
   PenSize(2,8);
   MoveTo(20,20);
   LineTo(70,20); LineTo(70,70); LineTo(20,70); LineTo(20,20);
   PenSize(8,2);
   Move(70,0);
   Line(50,0); Line(0,50); Line(-50,0); Line(0,-50);
   PenNormal;
END;
</PRE>
 At the end of <A HREF=#MARKER-9-90>Listing 3-2</A>, the <CODE>PenNormal</CODE> procedure is used to restore the graphics pen to its default size, pattern, and pattern mode.<A NAME=MARKER-2-91></A><P>
 <A NAME=MARKER-9-226></A>The default pattern for the graphics pen consists of all black pixels. However, you can use the <CODE>PenPat</CODE> procedure to change the pen's pattern. When you use the <CODE>PenPat</CODE> procedure, you can pass it any one of the predefined global variables listed in <A HREF=#MARKER-9-93></A> to specify the bit pattern for the graphics pen.<A NAME=MARKER-9-93></A>
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-93></A><B>Table 3-2 The global variables for five predefined bit patterns</B></CAPTION>
<TH>Global variable<TH>Result<TR>
<TD>black<TD>All-black pattern<TR>
<TD>dkGray<TD>75% gray pattern<TR>
<TD>gray<TD>50% gray pattern<TR>
<TD>ltGray<TD>25% gray pattern<TR>
<TD>white<TD>All-white pattern</TABLE>
<P>
 In <A HREF=#MARKER-9-94>Figure 3-9</A>, the pen pattern for the square on the left has changed to <CODE>ltGray</CODE>; the pen pattern for the square on the right has changed to <CODE>dkGray</CODE>.<P>
<B>Figure 3-9  <A NAME=MARKER-9-94></A>Changing the pen pattern</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-S-17.jpg"><BR>
 <A HREF=#MARKER-9-95>Listing 3-3</A> shows the code that produces these squares.<P>
<B>Listing 3-3  <A NAME=MARKER-9-95></A>Using the <CODE>PenPat</CODE> procedure to change the pattern of the graphics pen</B><P>
<PRE>
PROCEDURE MyRepatternPens;
BEGIN
   PenSize(2,8);
   PenPat(ltGray);
   MoveTo(20,20);
   LineTo(70,20); LineTo(70,70); LineTo(20,70); LineTo(20,20);

   PenSize(8,2);
   PenPat(dkGray);
   Move(70,0);
   Line(50,0); Line(0,50); Line(-50,0); Line(0,-50);
   PenNormal; 
END;
</PRE>
 QuickDraw provides methods for drawing squares and rectangles that are easier than drawing each side individually as a line. The next section describes how to draw rectangles.<P>
<A NAME=HEADING60-56></A>
<H2>Drawing Rectangles</H2>
 <A NAME=MARKER-2-97></A>As explained in the chapter "Basic QuickDraw," rectangles are mathematical entities. There are two ways to specify a rectangle: by its four boundary coordinates, as shown in the left rectangle in <A HREF=#MARKER-9-99>Figure 3-10</A>, or by its upper-left and lower-right points, as shown in the right rectangle.<P>
<B>Figure 3-10  <A NAME=MARKER-9-99></A>Two ways to specify a rectangle</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-L-12.jpg"><BR>
 However, specifying a rectangle does not draw one. Because the border of a rectangle is infinitely thin, it can have no direct representation on the screen until you use the <CODE>FrameRect</CODE> procedure to draw its outline, or you can use the <CODE>PaintRect</CODE> or <CODE>FillRect</CODE> procedure to draw its outline and its interior with a pattern. <A HREF=#MARKER-9-100>Figure 3-11</A> illustrates two rectangles that are drawn with the <CODE>FrameRect</CODE> procedure.<P>
<B>Figure 3-11  <A NAME=MARKER-9-100></A>Drawing rectangles</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Draw-S-18.jpg"><BR>
 <A HREF=#MARKER-9-102>Listing 3-4</A> shows the code that draws the rectangles in <A HREF=#MARKER-9-100>Figure 3-11</A>. This listing uses the <CODE>PenSize</CODE> procedure to assign a size of (2,2) to the graphics pen. Then the code assigns four boundary coordinates to the rectangle on the left side of this figure, and it calls <CODE>FrameRect</CODE> to use the graphics pen to draw the rectangle's outline. <A NAME=MARKER-2-101></A><P>
<B>Listing 3-4  <A NAME=MARKER-9-102></A>Using the <CODE>FrameRect</CODE> procedure to draw rectangles</B><P>
<PRE>
PROCEDURE MyDrawRects;
   VAR
      firstRect, secondRect: Rect;
BEGIN
   PenSize(2,2);

   firstRect.top := 20;
   firstRect.left := 20;
   firstRect.bottom := 70;
   firstRect.right := 70;
   FrameRect(firstRect);

   SetRect(secondRect,90,20,140,70);
   FrameRect(secondRect);

   PenNormal;
END;
</PRE>
 To shorten code text, <A HREF=#MARKER-9-102>Listing 3-4</A> uses the <CODE>SetRect</CODE> procedure to define the rectangle on the right side of <A HREF=#MARKER-9-100>Figure 3-11</A>. Again, <CODE>FrameRect</CODE> is used to draw an outline around the rectangle. Notice that while a <CODE>Rect</CODE> record lists the fields for a rectangle's boundaries in the order <CODE>top</CODE>, <CODE>left</CODE>, <CODE>bottom</CODE>, and <CODE>right</CODE>, you pass these boundaries as parameters to the <CODE>SetRect</CODE> procedure in the order <CODE>left</CODE>, <CODE>top</CODE>, <CODE>right</CODE>, and <CODE>bottom</CODE>. <A NAME=MARKER-2-104></A><A NAME=MARKER-2-105></A><P>
 Remember that the graphics pen hangs to the right of and below its location point; therefore, the lower-right corner of the two-pixel outline around the rectangle on the right side of <A HREF=#MARKER-9-100>Figure 3-11</A> lies at the point with a horizontal coordinate of 142 and a vertical coordinate of 72.<P>
 <A NAME=MARKER-2-106></A><A HREF=#MARKER-9-252>Figure 3-12</A> illustrates painted and filled rectangles. <A HREF=#MARKER-9-108>Listing 3-5</A> shows the code that creates these images.<P>
<A NAME=MARKER-9-252><B>Figure 3-12  </A>Painting and filling rectangles</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-S-19.jpg"><BR>
 <A HREF=#MARKER-9-108>Listing 3-5</A> uses the <CODE>PaintRect</CODE> procedure to draw the outline and the interior of the rectangle on the left side of <A HREF=#MARKER-9-252>Figure 3-12</A> with the pattern of the graphics pen, according to the pattern mode of the graphics pen. Because <A HREF=#MARKER-9-108>Listing 3-5</A> calls the <CODE>PenNormal</CODE> procedure immediately before calling <CODE>PaintRect</CODE>, the graphics pen has its default characteristics: a pattern of all-black pixels and the <CODE>patCopy</CODE> pattern mode, which changes all of the pixels in the destination to the pen's pattern.<P>
<B>Listing 3-5  <A NAME=MARKER-9-108></A>Using the <CODE>PaintRect</CODE> and <CODE>FillRect</CODE> procedures</B><P>
<PRE>
PROCEDURE MyPaintAndFillRects;
   VAR
   firstRect, secondRect: Rect;
BEGIN
   PenNormal;
   SetRect(firstRect,20,20,70,70);
   PaintRect(firstRect);
   SetRect(secondRect,20,90,70,140);
   FillRect(secondRect,ltGray);
END;
</PRE>
 The <CODE>PaintRect</CODE> procedure always uses the pattern and pattern mode of the graphics pen when drawing a rectangle. If you want to use a pattern other than that of the graphics pen, you can use the <CODE>FillRect</CODE> procedure. The <CODE>FillRect</CODE> procedure, however, <I>always</I> uses the <CODE>patCopy</CODE> pattern mode. <A HREF=#MARKER-9-108>Listing 3-5</A> uses the <CODE>FillRect</CODE> procedure to draw the outline and the interior of the rectangle on the right side of <BR><A HREF=#MARKER-9-252>Figure 3-12</A> with a light gray pattern.<P>
<DL>
<DT><B>Note</B>
<DD>Neither the <CODE>PaintRect</CODE> nor <CODE>FillRect</CODE> procedure changes the location of the graphics pen.<EM></EM><A NAME=MARKER-2-109></A><A NAME=MARKER-11-116></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 If the application that draws the rectangles in <A HREF=#MARKER-9-252>Figure 3-12</A> uses the <CODE>EraseRect</CODE> procedure to erase them both, then they would be filled with the background pattern specified by the <CODE>bkPat</CODE> field of the current graphics port. If the application uses the <CODE>InvertRect</CODE> procedure to invert the rectangles, then the black pixels in each would become white and the white pixels would become black. <P>
 QuickDraw provides a similar set of routines for drawing rounded rectangles, which are defined by their rectangles and the widths and heights of the ovals forming their corners. See <A HREF=QuickDraw-102.html#MARKER-9-372>"Drawing Rounded Rectangles" beginning on page 3-59</A> for detailed information about these routines.<P>
<A NAME=HEADING60-78></A>
<H2>Drawing Ovals, Arcs, and Wedges</H2>
 <A NAME=MARKER-2-112></A>An oval is a circular or elliptical shape defined by the bounding rectangle that encloses it. After specifying the bounding rectangle for an oval, you use the <CODE>FrameOval</CODE> procedure to draw its outline, or the <CODE>PaintOval</CODE> or <CODE>FillOval</CODE> procedure to draw its outline and its interior with a pattern. <A HREF=#MARKER-9-113>Figure 3-13</A> illustrates two ovals drawn with the <CODE>FrameOval</CODE> procedure.<P>
<B>Figure 3-13  <A NAME=MARKER-9-113></A>Drawing ovals</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-S-20.jpg"><BR>
 <A NAME=MARKER-11-129></A><A HREF=#MARKER-9-115>Listing 3-6</A> shows the code that produces the ovals in <A HREF=#MARKER-9-113>Figure 3-13</A>. The bounding rectangles for the ovals are created with the <CODE>SetRect</CODE> procedure. The resulting rectangles are then passed to the FrameOval procedure.<P>
<B>Listing 3-6  <A NAME=MARKER-9-115></A>Using the <CODE>FrameOval</CODE> procedure to draw ovals</B><P>
<PRE>
PROCEDURE MyDrawOvals;
   VAR
      firstRect, secondRect: Rect;
BEGIN
   PenSize(2,2);
   SetRect(firstRect,20,20,70,70);   {create a bounding rectangle}
   FrameOval(firstRect);             {draw the oval}
   SetRect(secondRect,90,20,140,70); {create a bounding rectangle}
   FrameOval(secondRect);            {draw the oval}
   PenNormal;
END;
</PRE>
 <A NAME=MARKER-11-123></A>An arc is defined as a portion of an oval's circumference bounded by a pair of radii. A wedge is a pie-shaped segment bounded by a pair of radii, and it extends from the center of the oval to its circumference. You use the <CODE>FrameArc</CODE> procedure to draw an arc (as shown on the left side of <A HREF=#MARKER-9-117>Figure 3-14</A>), and you use the <CODE>PaintArc</CODE> or <CODE>FillArc</CODE> procedure to draw a wedge (as shown on the right side of <A HREF=#MARKER-9-117>Figure 3-14</A>).<P>
<B>Figure 3-14  <A NAME=MARKER-9-117></A>Drawing an arc and a wedge</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-S-21.jpg"><BR>
 <A HREF=#MARKER-9-118>Listing 3-7</A> shows the code that produces the images in <A HREF=#MARKER-9-117>Figure 3-14</A>. The <CODE>FrameArc</CODE>, <CODE>PaintArc</CODE>, and <CODE>FillArc</CODE> procedures take three parameters: a rectangle that defines an oval's boundaries, an angle indicating the start of the arc, and an angle indicating the arc's extent. For the angle parameters, 0 indicates a vertical line straight up from the center of the oval. Positive values indicate angles in the clockwise direction from this vertical line, and negative values indicate angles in the counterclockwise direction. The arc and the wedge in <A HREF=#MARKER-9-117>Figure 3-14</A> both begin at 45 and extend to 135.<P>
<B>Listing 3-7  <A NAME=MARKER-9-118></A>Using the <CODE>FrameArc</CODE> and <CODE>PaintArc</CODE> procedures</B><P>
<PRE>
PROCEDURE MyDrawArcAndPaintWedge;
   VAR
      firstRect, secondRect: Rect;
BEGIN
   SetRect(firstRect,20,20,70,70);   {create a bounding rectangle}
   FrameArc(firstRect,45,135);       {draw an arc}
   SetRect(secondRect,90,20,140,70); {create a bounding rectangle}
   PaintArc(secondRect,45,135);      {draw a wedge}
END;
</PRE>
 You can also fill, erase, and invert wedges by using, respectively, the <CODE>FillArc</CODE>, <CODE>EraseArc</CODE>, and <CODE>InvertArc</CODE> procedures.<P>
<A NAME=HEADING60-92></A>
<H2>Drawing Regions and Polygons</H2>
 Before drawing regions and polygons, you must call several routines to create them. To create a region or polygon, you first call an open routine, which tells QuickDraw to collect subsequent routines to construct the shape. You use a close procedure when you are finished constructing the region or polygon. You can then frame the shape, fill it, paint it, erase it, and invert it.<P>
 <A NAME=MARKER-2-119></A>To begin defining a region, you must use the <CODE>NewRgn</CODE> function to allocate space for it, and then call the <CODE>OpenRgn</CODE> procedure. You can then use any QuickDraw routine to construct the outline of the region. The outline can be any set of lines and shapes (including other regions) forming one or more closed loops. When you are finished constructing the region, use the <CODE>CloseRgn</CODE> procedure. <P>
<DL>
<DT><B>WARNING</B>
<DD>Ensure that the memory for a region is valid before calling routines to manipulate that region; if there isn't sufficient memory, the system may crash. Regions are limited to 32 KB in size in basic QuickDraw and 64 KB in Color QuickDraw. Before defining a region, you can use the Memory Manager function <CODE>MaxMem</CODE> to determine whether the memory for the region is valid. You can determine the current size of an existing region by calling the Memory Manager function <CODE>GetHandleSize</CODE>. (Both <CODE>MaxMem</CODE> and <CODE>GetHandleSize</CODE> are described in <I><A HREF="../Memory/Memory-2.html">Inside Macintosh: Memory</A></I>.) When you record drawing operations in an open region, the resulting region description may overflow the 32 KB or 64 KB limit. Should this happen in Color QuickDraw, the <CODE>QDError</CODE> function (described in the chapter "Color QuickDraw" in this book) returns the result code <CODE>regionTooBigError</CODE>.<B><EM></EM></B>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To draw the region, use the <CODE>FrameRgn</CODE>, <CODE>PaintRgn</CODE>, or <CODE>FillRgn</CODE> procedure. To draw the region with the background pattern of the graphics port, use the <CODE>EraseRgn</CODE> procedure; to invert the pixels in the region, use the <CODE>InvertRgn</CODE> procedure. When you no longer need the region, use the <CODE>DisposeRgn</CODE> procedure to release the memory used by the region.<P>
 <A HREF=#MARKER-9-120>Listing 3-8</A> illustrates how to create and open a region, define a shape, close the region, fill it with the all-black pattern, and dispose of the region.<P>
<B>Listing 3-8  <A NAME=MARKER-9-120></A>Creating and drawing a region</B><P>
<PRE>
PROCEDURE MyDrawDumbbell;
VAR
   grow:       LongInt;
   dumbbell:   RgnHandle;
   tempRect:   Rect;
BEGIN
   IF MaxMem(grow) &gt; kMinReserve THEN
   BEGIN
      dumbbell := NewRgn;           {create a new region}
      OpenRgn;                      {begin drawing instructions}
      SetRect(tempRect,20,20,30,50);
      FrameOval(tempRect);          {form the left &quot;weight&quot;}
      SetRect(tempRect,25,30,85,40);
      FrameRect(tempRect);          {form the bar}
      SetRect(tempRect,80,20,90,50);
      FrameOval(tempRect);          {form the right &quot;weight&quot;}
      CloseRgn(dumbbell);           {stop collecting}
      FillRgn(dumbbell,black);      {draw the shape onscreen}
      IF QDError &lt;&gt; noErr THEN
         ; {likely error is that there is insufficient memory}
      DisposeRgn(dumbbell)             {dispose of the region}
   END;
END;
</PRE>
 <A HREF=#MARKER-9-121>Figure 3-15</A> shows the shape created by <A HREF=#MARKER-9-120>Listing 3-8</A>.<P>
<B>Figure 3-15  <A NAME=MARKER-9-121></A>A shape created by a region</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-S-36.jpg"><BR>
 To assist you with scrolling, you can use QuickDraw routines to define a clipping region that excludes the scroll bars of the content region of a window. You can then scroll that area so that the region being updated does not draw into the scroll bars. <A HREF=#MARKER-9-122>Listing 3-9</A> illustrates how to create such a clipping region and, for illustrative purposes, how to fill it with a pattern. (The chapter "Basic QuickDraw" illustrates how to scroll the pixels in a rectangle such as the one created with the <CODE>ClipRect</CODE> procedure in <A HREF=#MARKER-9-122>Listing 3-9</A>.)<P>
<B>Listing 3-9  <A NAME=MARKER-9-122></A>Creating a clipping region and filling it with a pattern</B><P>
<PRE>
FUNCTION MyFillClipRegion: RgnHandle;
VAR
   grow:          LongInt;
   newClip:       Rect;
   oldClipRegion: RgnHandle;
   newClipRegion: RgnHandle;
   myWindow:      WindowPtr;
BEGIN
   IF MaxMem(grow) &gt; kMinReserve THEN
   BEGIN
      oldClipRegion := NewRgn;   {allocate old clipping region}
      myWindow := FrontWindow;   {get the front window}
      SetPort(myWindow);         {make the front window the current }
                                 { graphics port}
      GetClip(oldClipRegion);    {save the old clipping region}
      newClip := myWindow^.portRect;   {create a new rectangle}
      newClip.right := newClip.right - 15;   {exclude scroll bar}
      newClip.bottom := newClip.bottom - 15; {exclude scroll bar}
      ClipRect(newClip); {make the new rectangle the clipping region}
      newClipRegion := NewRgn;   {allocate new clipping region}
      RectRgn(newClipRegion, newClip);
      FillRgn(newClipRegion, ltGray);  {paint clipping region gray}
      SetClip(oldClipRegion);    {restore previous clipping region}
      IF QDError &lt;&gt; noErr THEN
         ; {likely error is that there is insufficient memory}
      DisposeRgn(oldClipRegion); {dispose previous clipping region}
      MyFillClipRect := (newClipRegion);
   END;
END;
</PRE>
 <A HREF=#MARKER-9-124>Figure 3-16</A> shows the results of using the code in <A HREF=#MARKER-9-122>Listing 3-9</A>.<A NAME=MARKER-2-123></A><P>
<B>Figure 3-16  <A NAME=MARKER-9-124></A>Filling a clipping region</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-S-23.jpg"><BR>
 <A NAME=MARKER-11-140></A>To create a polygon, you first call the <CODE>OpenPoly</CODE> function and then some number of <CODE>LineTo</CODE> procedures to draw lines from the first vertex of the polygon to the second, from the second to the third, and so on, until you've drawn a line to the last vertex. You then use the <CODE>ClosePoly</CODE> procedure, which completes the figure by drawing a connecting line from the last vertex back to the first. After defining a polygon in this way, you can display it with the <CODE>FramePoly</CODE>, <CODE>PaintPoly</CODE>, <CODE>FillPoly</CODE>, <CODE>ErasePoly</CODE>, and <CODE>InvertPoly</CODE> procedures. When you are finished using the polygon, use the <CODE>KillPoly</CODE> procedure to release its memory.<P>
<DL>
<DT><B>WARNING</B>
<DD>Do not create a height or width for the polygon greater than 32,767 pixels, or <CODE>PaintPoly</CODE> will crash.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A HREF=#MARKER-9-126>Listing 3-10</A> illustrates how to create a triangular polygon and fill it with a gray pattern.<P>
<B>Listing 3-10  <A NAME=MARKER-9-126></A>Creating a triangular polygon</B><P>
<PRE>
PROCEDURE MyDrawTriangle;
VAR
   triPoly: PolyHandle;
BEGIN
   triPoly := OpenPoly; {save handle and begin collecting lines}
   MoveTo(300,100);     {move to first point}
   LineTo(400,200);     {form the triangle's sides}
   LineTo(200,200);     
   ClosePoly;           {stop collecting lines}
   FillPoly(triPoly,gray); {fill the polygon with gray}
   IF QDError &lt;&gt; noErr THEN
      ; {likely error is that there is insufficient memory}
   KillPoly(triPoly);   {dispose of its memory}
END;
</PRE>
<A NAME=HEADING60-114></A>
<H2>Performing Calculations and Other Manipulations of Shapes</H2>
 <A NAME=MARKER-2-127></A>QuickDraw provides a multitude of routines for manipulating rectangles and regions. You can use the routines that manipulate rectangles to manipulate any shape based on a rectangle--namely, rounded rectangles, ovals, arcs, and wedges. For example, you could define a rectangle to bound an oval and then frame the oval. You could then use the <CODE>OffsetRect</CODE> procedure to move the oval's bounding rectangle downward. Using the offset bounding rectangle, you could frame a second, connected oval to form a figure eight with the first oval. You could use that shape to help define a region. You could create a second region, and then use the <CODE>UnionRgn</CODE> procedure to create a region from the union of the two.<P>
 The routines for performing calculations and other manipulations of rectangles are summarized in <A HREF=#MARKER-9-12>Table 3-3</A> and are described in detail in <A HREF=QuickDraw-85.html#MARKER-9-275>"Creating and Managing Rectangles" beginning on page 3-48</A>. 
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-12></A><B>Table 3-3 QuickDraw routines for calculating and manipulating rectangles</B> (Continued)</CAPTION>
<TH>Routine<TH>Description<TR>
<TD>EmptyRect<TD>Determines whether a rectangle is an empty rectangle<TR>
<TD>EqualRect<TD>Determines whether two rectangles are equal<TR>
<TD>InsetRect<TD>Shrinks or expands a rectangle<TR>
<TD>OffsetRect<TD>Moves a rectangle<TR>
<TD>PtInRect<TD>Determines whether a pixel is enclosed in a rectangle<TR>
<TD>PtToAngle<TD>Calculates the angle from the middle of a rectangle to a point <TR>
<TD>Pt2Rect<TD>Determines the smallest rectangle that encloses two points<TR>
<TD>SectRect<TD>Determines whether two rectangles intersect<TR>
<TD>UnionRect<TD>Calculates the smallest rectangle that encloses two rectangles</TABLE>
<P>
 The routines for performing calculations and other manipulations of regions are summarized in <A HREF=#MARKER-9-10>Table 3-4</A> and are described in detail in <A HREF=QuickDraw-131.html#MARKER-9-538>"Creating and Managing Regions" beginning on page 3-81</A>. 
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-10></A><B>Table 3-4 QuickDraw routines for calculating and manipulating regions</B> (Continued)</CAPTION>
<TH>Routine<TH>Description<TR>
<TD>CopyRgn<TD>Makes a copy of a region<TR>
<TD>DiffRgn<TD>Subtracts one region from another<TR>
<TD>EmptyRgn<TD>Determines whether a region is empty<TR>
<TD>EqualRgn<TD>Determines whether two regions have identical sizes, shapes, <BR>and locations<TR>
<TD>InsetRgn<TD>Shrinks or expands a region<TR>
<TD>OffsetRgn<TD>Moves a region<TR>
<TD>PtInRgn<TD>Determines whether a pixel is within a region<TR>
<TD>RectInRgn<TD>Determines whether a rectangle intersects a region<TR>
<TD>RectRgn<TD>Changes a region to a rectangle<TR>
<TD>SectRgn<TD>Calculates the intersection of two regions<TR>
<TD>SetEmptyRgn<TD>Sets a region to empty<TR>
<TD>SetRectRgn<TD>Changes a region to a rectangle<TR>
<TD>UnionRgn<TD>Calculates the union of two regions<TR>
<TD>XorRgn<TD>Calculates the difference between the union and the intersection <BR>of two regions</TABLE>
<P>
 Note that while you can use the <CODE>OffSetPoly</CODE> procedure to move a polygon, QuickDraw provides no other routines for calculating or manipulating polygons. <A NAME=MARKER-2-128></A><P>
<A NAME=HEADING60-119></A>
<H2><A NAME=MARKER-9-129></A>Copying Bits Between Graphics Ports</H2>
 <A NAME=MARKER-2-130></A><A NAME=MARKER-2-131></A><A NAME=MARKER-2-132></A>You can use the <CODE>CopyBits</CODE> procedure to copy a bit image from one graphics port to another. Along with the <CODE>CopyMask</CODE> procedure and the Color QuickDraw procedure <CODE>CopyDeepMask</CODE>, <CODE>CopyBits</CODE> is integral to QuickDraw's image-processing capabilities. You can use <CODE>CopyBits</CODE> to move offscreen graphics images into an onscreen window, to blend colors for the image in a pixel map, and to shrink and expand images. For example, <A HREF=#MARKER-9-134>Figure 3-17</A> illustrates how <CODE>CopyBits</CODE> can be used to scale the image in one window to a smaller image in another window.<P>
<B>Figure 3-17  <A NAME=MARKER-9-134></A>Shrinking images between graphics ports</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-S-22.jpg"><BR>
 <A HREF=#MARKER-9-135>Listing 3-11</A> shows the code that produces the scaled image in <A HREF=#MARKER-9-134>Figure 3-17</A>.<P>
<B>Listing 3-11  <A NAME=MARKER-9-135></A>Using the <CODE>CopyBits</CODE> procedure to copy between two windows</B><P>
<PRE>
PROCEDURE MyShrinkImages;
   VAR
      myWindow:               WindowPtr;
      sourceRect, destRect:   rect;
      halfHeight, halfWidth:  Integer;
BEGIN
   myWindow := FrontWindow;
   sourceRect.top := myWindow^.portRect.top; {create source rectangle}
   sourceRect.left := myWindow^.portRect.left;
   sourceRect.bottom := myWindow^.portRect.bottom - 15; {exclude scroll bar}
   sourceRect.right := myWindow^.portRect.right - 15;  {exclude scroll bar}

   destRect.top := gShrinkWindow^.portRect.top; {create destination rect}
   destRect.left := gShrinkWindow^.portRect.left;
   halfHeight :=              {make destination half as tall as the source}
            Integer((sourceRect.bottom - sourceRect.top)) DIV 2;
   destRect.bottom := destRect.top + halfHeight;
   halfWidth :=               {make destination half as wide as the source}
            Integer((sourceRect.right - sourceRect.left)) DIV 2;
   destRect.right := destRect.left + halfWidth;
   
   GetPort(myWindow);      {save the graphics port for the active window}
   SetPort(gShrinkWindow); {make the target window the current }
                           { graphics port for drawing purposes}
   CopyBits(myWindow^.portBits, 
            gShrinkWindow^.portBits, 
            sourceRect, 
            destRect, 
            srcCopy+ditherCopy, NIL);
   IF QDError &lt;&gt; noErr THEN
      ; {likely error is that there is insufficient memory}
   SetPort(myWindow);      {restore active window as current graphics port}
END;
</PRE>
 When copying between basic graphics ports, you specify a source bitmap and a destination bitmap to <CODE>CopyBits</CODE>. Remember that the bitmap is stored in the <CODE>portBits</CODE> field of a <CODE>GrafPort</CODE> record. By dereferencing the desired window record when it calls <CODE>CopyBits</CODE>, <A HREF=#MARKER-9-135>Listing 3-11</A> uses the bitmap for the front window, "untitled" in <A HREF=#MARKER-9-134>Figure 3-17</A>, as the source bitmap. <A HREF=#MARKER-9-135>Listing 3-11</A> uses the bitmap for the window titled "50%" as the destination bitmap.<P>
 When copying images between color graphics ports, as explained in the chapter "Color QuickDraw," you must coerce each <CODE>CGrafPort</CODE> record to a <CODE>GrafPort</CODE> record, dereference the <CODE>portBits</CODE> fields of each, and then pass these "bitmaps" to <CODE>CopyBits</CODE>.<P>
<DL>
<DT><B>Note</B>
<DD>If there is insufficient memory to complete a <CODE>CopyBits</CODE> operation in Color QuickDraw, the <CODE>QDError</CODE> function (described in the chapter "Color QuickDraw" in this book) returns the result code -143.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 You can specify differently sized source and destination rectangles, and <CODE>CopyBits</CODE> scales the source image to fit the destination. <A HREF=#MARKER-9-135>Listing 3-11</A> uses the area of the port rectangle excluding the scroll bars as the source rectangle. To scale the image in the front window, <A HREF=#MARKER-9-135>Listing 3-11</A> creates a destination rectangle that is half as high and half as wide as the source rectangle.<P>
 The manner by which <CODE>CopyBits</CODE> transfers the bits between bitmaps depends on the source mode that you specify. In <A HREF=#MARKER-9-135>Listing 3-11</A>, the <CODE>srcCopy</CODE> mode is used to copy bits from the source directly into the destination. Source modes are described in <A HREF=QuickDraw-59.html#MARKER-9-37>"Boolean Transfer Modes With 1-Bit Pixels" beginning on page 3-7</A>.<P>
<DL>
<DT><B>Note</B>
<DD>To scale shapes and regions within the same graphics port, you can use the routines described in <A HREF=QuickDraw-156.html#MARKER-9-686>"Scaling and Mapping Points, Rectangles, Polygons, and Regions" beginning on page 3-100</A>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To gracefully display complex images that your application creates, your application should use the drawing routines described in this chapter to construct such images in offscreen graphics worlds. Your application can then use the <CODE>CopyBits</CODE> procedure to transfer these images to onscreen graphics ports. This technique prevents the choppiness that can occur when you build complex images onscreen, and is described in the chapter "Offscreen Graphics Worlds," which also offers an example of using a mask to copy color pixels from an offscreen graphics world.<P>
 To copy only certain bits from a bitmap, you can use the <CODE>CopyMask</CODE> procedure, which is a specialized variant of <CODE>CopyBits</CODE>. The <CODE>CopyMask</CODE> procedure, which is described on <A HREF=QuickDraw-167.html#MARKER-9-759>page 3-115</A>, transfers bits only where the corresponding bits of another bit image, which serves as a mask, are set to 1 (that is, black). The <CODE>CopyMask</CODE> procedure does not allow scaling or resizing. However, the <CODE>CopyDeepMask</CODE> procedure, which is described on <A HREF=QuickDraw-168.html#MARKER-9-764>page 3-116</A>, does allow scaling and resizing; in effect it combines the capabilities of the <CODE>CopyBits</CODE> and <CODE>CopyMask</CODE> procedures.<A NAME=MARKER-2-137></A><A NAME=MARKER-2-138></A><A NAME=MARKER-2-139></A><P>
<A NAME=HEADING60-134></A>
<H2><A NAME=MARKER-9-140></A>Customizing QuickDraw's Low-Level Routines</H2>
 <A NAME=MARKER-11-156></A><A NAME=MARKER-2-142></A>For each shape that QuickDraw knows how to draw, there are procedures that perform these basic graphics operations on the shape: frame, paint, erase, invert, and fill. Those procedures in turn call a low-level drawing routine for the shape. For example, the <CODE>FrameOval</CODE>, <CODE>PaintOval</CODE>, <CODE>EraseOval</CODE>, <CODE>InvertOval</CODE>, and <CODE>FillOval</CODE> procedures all call the low-level procedure <CODE>StdOval</CODE>, which draws the oval. For each type of object QuickDraw can draw, including text and lines, there's a pointer to such a low-level routine. By changing these pointers, you can install your own routines, and either completely override the standard ones or call them after your routines have modified their parameters as necessary.<P>
 Other low-level routines that you can install in this way include<P>
<UL>
<LI>The procedure (called by <CODE>CopyBits</CODE>) that performs bit and pixel transfer.
<LI>The function that measures the width of text and is called by the QuickDraw text routines <CODE>CharWidth</CODE>, <CODE>StringWidth</CODE>, and <CODE>TextWidth</CODE>. (These QuickDraw text routines are described in the chapter "QuickDraw Text" in <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I>.)
<LI>The procedure that processes picture comments. The standard procedure ignores picture comments. (Picture comments are described in Appendix B of this book.)
<LI>The procedure that saves drawing commands as the definition of a picture, and the procedure that retrieves them. These enable your application to draw on remote devices, print to the disk, get picture input from the disk, and support large pictures.<P>
</UL>
 All of the low-level QuickDraw routines that your application can replace or call after performing its own operations are described in <A HREF=QuickDraw-178.html#MARKER-9-823>"Customizing QuickDraw Operations" beginning on page 3-124</A>.<P>
 The <CODE>grafProcs</CODE> field of a graphics port determines which low-level routines are called. If that field contains the value of <CODE>NIL</CODE>, the standard routines are called, so that all operations in that graphics port are done in the standard ways described in this chapter. You can set the <CODE>grafProcs</CODE> field to point to a record of pointers to your own routines. This record of pointers is defined by a data structure of type <CODE>QDProcs</CODE>, which is described on <A HREF=QuickDraw-65.html#MARKER-9-165>page 3-35</A>.<P>
 To assist you in setting up a record, QuickDraw provides the <CODE>SetStdProcs</CODE> procedure, which is described on <A HREF=QuickDraw-179.html#MARKER-9-827>page 3-125</A>. You can use the <CODE>SetStdProcs</CODE> procedure to get a <CODE>QDProcs</CODE> record with fields that point to the standard routines. You can reset the ones with which you are concerned. You can replace these low-level routines with your own, and then point to your modified <CODE>QDProcs</CODE> record in the <CODE>grafProcs</CODE> field of a <CODE>GrafPort</CODE> record to change basic QuickDraw's standard low-level behavior.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>When modifying the low-level routines for a color graphics port, you must always use the <CODE>SetStdCProcs</CODE> procedure instead of <CODE>SetStdProcs</CODE>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The chapter "Pictures" in this book provides sample code and explanations for changing the standard low-level routines for reading and writing pictures.<A NAME=MARKER-2-143></A><A NAME=MARKER-2-144></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-59.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-61.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
