/*	File:		WindStuff.c	Contains:	Window handling routines.	Written by: Jason Hodges-Harris & Don Swatman		Copyright:	Copyright © 1995-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				8/17/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				*/#include <Dialogs.h>#include "WindStuff.h"#include "MenuStuff.h"#include "MovieStuff.h"//==============================================//  Globals                                     //==============================================WindowPtr gTheWinds[kMaxWindows];  // holds the list of windowsBoolean	  gDone;                   // Set to true to make the program quit//==============================================//  AboutBox                                   //// This draws the about box. It also shows how to// use the tool box to draw a default box around// the OK box//==============================================void AboutBox(void){  GrafPtr   savePort = nil;	DialogPtr aboutDialog;	ModalFilterUPP theFilter = nil;	short     itemHit = 0;   // dialog item we've clicked on	// Get the dialog box resource	aboutDialog = GetNewDialog(9041, nil, (WindowPtr) -1 );  GetPort(&savePort);  SetPort( aboutDialog );	ShowWindow( aboutDialog );		// Get the standard filter proc  if (GetStdFilterProc(&theFilter) != noErr)  	DebugStr("\pFailed to get standard dialog filter.");  // Set item 1 - <OK> to have a default box around it	SetDialogDefaultItem(aboutDialog,1);  // Modal dialog loop	do 	{// Use "theFilter" in ModalDialog call   	ModalDialog(theFilter,&itemHit);	} while (itemHit != 1);  DisposeDialog(aboutDialog);  SetPort(savePort);}//==============================================////  Gemeral Window handling Stuff////==============================================//----------------------------------------------//  GetWindowNum//// Gets the number of a window in the list from// it's WindowPtr//----------------------------------------------short GetWindowNum ( WindowPtr pWindow ){	short windCount;	short foundWind = -1;	if (pWindow)		for (windCount=0; (windCount < kMaxWindows) && (foundWind == -1); windCount++)			if (gTheWinds[windCount] == pWindow)				foundWind = windCount;		return ( foundWind);}//----------------------------------------------//  IsOurWindow//// Find out if this is one of our window//----------------------------------------------Boolean IsOurWindow ( WindowPtr pWindow ){	return ( GetWindowNum(pWindow) != -1 );}//----------------------------------------------// IsFreeWind//// Find out if we can add "howManyNeeded" more windows//   and return a number to the first free//----------------------------------------------Boolean IsFreeWind( short *newWindNum, short howManyNeeded ){	short windCount;   // Current window list entry we're looking at	short leftToFind;  // How many more windows we need to find		leftToFind  = howManyNeeded;	*newWindNum = -1;	for (windCount=0; (windCount < kMaxWindows) && (leftToFind != 0 ); windCount++)		if (gTheWinds[windCount] == nil)			{				--leftToFind;				if (*newWindNum == -1 )					*newWindNum = windCount;			}	return(leftToFind == 0);}//----------------------------------------------//  CloseOurWindow//// Close a window pointed to by "pWindow"// Also if the window is a master movie, then // recursively close it's slave window//----------------------------------------------void CloseOurWindow ( short windNum ){	short     slaveWindNum = -1;   // slave window num	WindowPtr pSlaveWindow = nil;  // slave WindowPtr		if (gTheWinds[windNum])                   // Check it's not nil		if (IsOurWindow(gTheWinds[windNum]))    // Check it's ours		{			CloseMovieWindow( gTheWinds[windNum],												&pSlaveWindow );    // kills all the movie stuff			DisposeWindow(gTheWinds[windNum]);    // dispose of the window			gTheWinds[windNum] = nil;             // Return nil in pWindow						DoAdjustMenus();	                    // update the menus// Recursively remove the window's slave			if (pSlaveWindow)			{				slaveWindNum = GetWindowNum ( pSlaveWindow );				if (slaveWindNum != -1 )					CloseOurWindow ( slaveWindNum );			}		}}//----------------------------------------------//   CloseAllWindows////  Scans down the window list and closes each//  of the windows//----------------------------------------------void CloseAllWindows(void){	short windCount;	for (windCount = 0; windCount < kMaxWindows; windCount++)		if (gTheWinds[windCount] != nil)			CloseOurWindow( windCount );}//----------------------------------------------// DoWindUpdate//// Updates a window//----------------------------------------------void	DoWindUpdate ( WindowPtr pWindow ){		if (IsOurWindow(pWindow))	{		BeginUpdate (pWindow);// update the movie window		UpdateMovieWindow ( pWindow );				EndUpdate (pWindow);	}}//----------------------------------------------//  DragSelWind//// Handles a click in the drag area of a window// and drags selected window around desktop//----------------------------------------------void DragSelWind( WindowPtr window,									Point     mouseLoc){	Rect	dragBounds;		dragBounds = (**GetGrayRgn()).rgnBBox;   // Get the rect the window can be dragged around	DragWindow(window,mouseLoc,&dragBounds); // Now Drag it}//----------------------------------------------//  DoGoAwayWind//// Handles mouse down event in the go away box// and closes the window if neccessary//----------------------------------------------void DoGoAwayWind ( WindowPtr pWindow,										Point     mouseLoc){	short windNum;	if (TrackGoAway(pWindow,mouseLoc))	{		if (pWindow)		{			windNum = GetWindowNum ( pWindow );			if (windNum != -1 )				CloseOurWindow( windNum );		}	}}//----------------------------------------------//   CreateWindow//// Create an empty window,//   but doesn't show it just yet//----------------------------------------------void CreateWindow ( short windNum, Str255 theTitle, WindowPtr pWindowBehind ){	Rect  windRect;      // Initial window size	short diagOffset;    // offset from top left of window	// Calculate where we want to put the window and give it an initial size of 50,50	diagOffset = 50 * windNum;	SetRect( &windRect, 50,50,100,100 );	OffsetRect ( &windRect, diagOffset, diagOffset );	gTheWinds[windNum] = (WindowPtr) NewCWindow ( nil,            // Create Storage																							 	&windRect,      // Rect to put the window in																							 	theTitle,       // Windows Title																							 	false,          // Not Visible																							 	noGrowDocProc,  // Ordinary window without grow box																								pWindowBehind,  // Window this one behind																							 	true,           // Has Go away box																							 	0 );            // no Refcon (we'll use this later)																							 	                //    to store movie info}