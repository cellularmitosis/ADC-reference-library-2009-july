<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Dispatching Apple Events (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING52></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-51.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-53.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-21.html"><B>Part 1 - MacApp Theory and Architecture</B></A><BR><DD><A HREF="MacAppProgGuide-48.html"><B>Chapter 6 - Scripting</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING52-0></A>
<H1><A NAME=MARKER-2-64></A><A NAME=MARKER-9-77></A><A NAME=MARKER-2-56></A>Dispatching Apple Events</H1>
 <A NAME=MARKER-2-79></A>An application may receive Apple events from itself, from another application, from the operating system, or from a script. MacApp uses a global Apple event dispatcher object to send Apple events to the objects specified by the events. The Apple event dispatcher object works together with callbacks from the Apple Event Manager and its OSL component to dispatch Apple events. If you have built your application <I>with</I> MacApp's support for attached scripts, dispatching is a two-stage process:<P>
<UL>
<LI>MacApp's predispatch callback routine dispatches Apple events to be handled by scripts attached to objects in the application.
<LI>If an Apple event isn't handled by a script, MacApp's standard callback routine dispatches the event to its specified object.<P>
</UL>
 If you have built your application <I>without</I> MacApp's support for attached scripts, MacApp skips the predispatch step. <A HREF=MacAppProgGuide-148.html#MARKER-9-10>Appendix A</A> describes how to use the <CODE>-Attachable</CODE> option to include MacApp's attachability code when building your application with the MABuild system.<P>
 Any object that needs to respond to Apple events mixes in the multiple inheritance class <CODE><A NAME=MARKER-2-80></A>MScriptableObject</CODE>. Many MacApp classes, including <CODE>TApplication</CODE>, <CODE>TDocument</CODE>, <CODE>TWindow</CODE>, and <CODE>TFile</CODE>, already mix in <CODE>MScriptableObject</CODE>, so you don't need to mix it in again for any class that descends from one of these classes.<P>
 Classes that support scripting generally override methods of <CODE>MScriptableObject</CODE> to support a hierarchy of contained objects, to handle specific Apple events, and to get and set object properties. For example, the IconEdit sample application supports setting the color of an icon with an Apple event, so the <CODE>TIconDocument</CODE> class overrides the <CODE>GetObjectProperty</CODE> and <CODE>SetObjectProperty</CODE> methods to respond when the specified property is <CODE>pColor</CODE>.<A NAME=MARKER-2-81></A><P>
<A NAME=HEADING52-7></A>
<H2><A NAME=MARKER-2-82></A>Initializing Scripting</H2>
 MacApp initialization is described in detail in <A HREF=MacAppProgGuide-33.html#MARKER-9-19>Chapter 4, "Launching and Terminating an Application."</A> During initialization of the application, the <CODE>IApplication</CODE> method calls the <CODE><A NAME=MARKER-2-83></A>InitUScripting</CODE> routine to initialize the UScripting unit.<P>
 MacApp's global <CODE>InitUScripting</CODE> routine calls the <CODE>InitUScripting</CODE> method of the <CODE>TOSADispatcher</CODE> class. That method terminates applications that are not aware of high-level events. Otherwise, <CODE>InitUScripting</CODE> calls the Apple Event Manager routine <CODE><A NAME=MARKER-2-84></A>AEObjectInit</CODE> to initialize the OSL. If a global Apple event dispatcher object has not already been created, <CODE>InitUScripting</CODE> creates one, stores a reference to it in <CODE>TOSADispatcher::<A NAME=MARKER-2-85></A>fgDispatcher</CODE> (a global static field), and calls the <CODE>IOSADispatcher</CODE> initialization method.<P>
 The <CODE>IOSADispatcher</CODE> method does some standard initialization tasks, then calls two of its own methods to install various Apple -event- handler routines and other callback routines:<P>
<PRE>
this-&gt;InstallDispatchHandlers();
this-&gt;InstallObjectCallbacks();
</PRE>
 It is also possible to initialize MacApp's scripting support to use a custom subclass of <CODE>TOSADispatcher</CODE>. For details, see <A HREF=MacAppProgGuide-93.html#MARKER-9-57>"Recipe--Installing a Custom Subclass of TOSADispatcher," beginning on page 371</A>.<P>
<A NAME=HEADING52-13></A>
<H3><A NAME=MARKER-2-28></A><A NAME=MARKER-9-87></A>InstallDispatchHandlers</H3>
 <A NAME=MARKER-2-88></A>The <CODE>InstallDispatchHandlers</CODE> method looks for any application resources of type <CODE>'<A NAME=MARKER-2-89></A>aedt'</CODE> (Apple event dispatch table). An <CODE>'aedt'</CODE> resource is an array of entries, each of which maps an Apple event class and ID pair to a MacApp command-number constant. For example, MacApp defines an <CODE>'aedt'</CODE> resource for the four Finder Apple events that all applications are required to support:<P>
<pre><CODE><A NAME=MARKER-2-222></A>resource 'aedt' (kAEDispatchTable) <BR>{<BR> {<BR> 'aevt', 'ansr', cAppleEventReply;<BR> 'aevt', 'oapp', cFinderNew;<BR> 'aevt', 'odoc', cFinderOpen;<BR> 'aevt', 'pdoc', cFinderPrint;<BR> 'aevt', 'quit', cFinderQuit;<BR> }<BR>};<A NAME=MARKER-2-36></A></CODE></pre><P>
 This resource also defines the <CODE>cAppleEventReply</CODE> command number, used to identify asynchronous replies.<P>
 For each entry in each <CODE>'aedt'</CODE> resource, <CODE>InstallEventDispatchTables</CODE> calls the Apple Event Manager routine <CODE><A NAME=MARKER-2-92></A>AEInstallEventHandler</CODE>, passing a universal procedure pointer that specifies the <CODE><A NAME=MARKER-2-39></A>DispatchHandlerGlue</CODE> method as the event handler to call when an Apple event with the specified class and ID information is received. As a result, all Apple events handled by the application are dispatched to the same method. However, before an Apple event is dispatched to the <CODE>DispatchHandlerGlue</CODE> method, it is first predispatched to a different callback routine, described in <A HREF=#MARKER-9-108>"InstallPreDispatchHandler"</A> below.<A NAME=MARKER-2-94></A><P>
<A NAME=HEADING52-18></A>
<H3><A NAME=MARKER-2-32></A>InstallObjectCallbacks</H3>
 The <CODE>InstallObjectCallbacks</CODE> method calls the Apple Event Manager routine <CODE><A NAME=MARKER-2-41></A>AEInstallObjectAccessor</CODE>. <CODE>InstallObjectCallbacks</CODE> passes a universal procedure pointer that specifies the <CODE><A NAME=MARKER-2-34></A>ObjectAccessorGlue</CODE> method as the object-accessor routine the Apple Event Manager's <CODE>AEResolve</CODE> routine should call when resolving an Apple event object specifier. Although it is possible to install multiple object-accessor routines, MacApp uses just this one.<P>
 The <CODE>InstallObjectCallbacks</CODE> method also calls the Apple Event Manager routine <CODE><A NAME=MARKER-2-38></A>AESetObjectCallbacks</CODE>, passing universal procedure pointers that specify <CODE>TOSADispatcher</CODE> methods as callback routines for<P>
<UL>
<LI>comparing objects (the <CODE><A NAME=MARKER-2-40></A>CompareObjectsGlue</CODE> method)
<LI>counting objects (the <CODE><A NAME=MARKER-2-43></A>CountObjectsGlue</CODE> method)
<LI>disposing of tokens (the <CODE><A NAME=MARKER-2-101></A>DisposeTokenGlue</CODE> method)
<LI>working with mark tokens (the <CODE><A NAME=MARKER-2-102></A>AdjustMarksGlue</CODE>, <CODE><A NAME=MARKER-2-103></A>GetMarkTokenGlue</CODE>, and <CODE><A NAME=MARKER-2-104></A>MarkObjectGlue</CODE> methods) <P>
</UL>
 Each of these "glue" methods sets up a failure handler, then calls a similarly named method of the <CODE>TOSADispatcher</CODE> class. For example, <CODE>CompareObjectsGlue</CODE> calls <CODE><A NAME=MARKER-9-72></A>CompareObjects</CODE> and <CODE>AdjustMarksGlue</CODE> calls <CODE><A NAME=MARKER-2-106></A>AdjustMarks</CODE>. These callback glue methods may also be called by the OSL's <CODE>AEResolve</CODE> routine when resolving an Apple event object specifier.<A NAME=MARKER-2-33></A><P>
<A NAME=HEADING52-26></A>
<H3><A NAME=MARKER-9-108></A>InstallPreDispatchHandler</H3>
 If you build your application to include MacApp's attachability code, the first time you call a method such as <CODE>MScriptableObject:ReadOSAScript</CODE> or <CODE>MScriptableObject::SetOSAScript</CODE>, the <CODE>InstallPreDispatchHandler</CODE> method is called. <CODE>InstallPreDispatchHandler</CODE> calls the Apple Event Manager routine <CODE><A NAME=MARKER-2-20></A>AEInstallSpecialHandler</CODE>, passing a universal procedure pointer that specifies the <CODE>PreDispatchHandlerGlue</CODE> method as the event handler to call when predispatching Apple events. MacApp uses this routine to predispatch Apple events to objects with attached scripts.<P>
 The global <CODE><A NAME=MARKER-10-1></A>TOSADispatcher</CODE> object keeps a reference to the number of attached scripts in the application. If that number goes to 0, the predispatch handler is uninstalled.<A NAME=MARKER-2-112></A><A NAME=MARKER-2-113></A><P>
<A NAME=HEADING52-29></A>
<H2><A NAME=MARKER-9-114></A>Apple Event Dispatching</H2>
 Once MacApp's UScripting unit has been initialized, the application is ready to dispatch any Apple event it knows how to handle. Apple events are dispatched in one of two ways:<P>
<UL>
<LI>When the application receives a high-level event from an external source, it calls the Apple Event Manager routine <CODE><A NAME=MARKER-2-30></A>AEProcessAppleEvent</CODE>. The <CODE>AEProcessAppleEvent</CODE> routine examines the application's dispatch table. If the Apple event is one the application can handle, <CODE>AEProcessAppleEvent</CODE> calls the application's predispatch handler routine, using the callbacks installed by the application.
<LI>When the application sends an Apple event to itself, the Apple Event Manager calls back immediately to the Apple event dispatcher object, without going through the event loop and the <CODE>AEProcessAppleEvent</CODE> routine. The Apple event dispatcher object dispatches the event to the specified object, or to the default object if none is specified.<P>
</UL>
<A NAME=HEADING52-33></A>
<H3>Predispatching Apple Events to Attached Scripts</H3>
 <A NAME=MARKER-2-116></A>The <CODE><A NAME=MARKER-2-117></A>PreDispatchHandlerGlue</CODE> method first calls its <CODE>GetAppleEventCommandNumber</CODE> method, which calls the Apple Event Manager routine <CODE><A NAME=MARKER-2-30></A>AEGetEventHandler</CODE> to get a MacApp command number to associate with the event. Command number information is available from a table set up by the <CODE>InstallDispatchHandlers</CODE> method, based on the application's <CODE>'aedt'</CODE> resources (as described in <A HREF=#MARKER-9-87>"InstallDispatchHandlers" on page 151</A>).<P>
 If the <CODE>PreDispatchHandlerGlue</CODE> method is able to retrieve the command number information, it calls the <CODE>PreDispatchHandler</CODE> method. That method attempts to<CODE> </CODE>resolve the target object for the event. If the event does not specify a target object, MacApp uses the application object as the default target. The <CODE>PreDispatchHandler</CODE> method calls the <CODE>HandleOSAEvent</CODE> method of the target object. <CODE>HandleOSAEvent</CODE> checks whether the object has an attached script and, if it does, gives the script a chance to process the Apple event.<P>
<A NAME=HEADING52-36></A>
<H3><A NAME=MARKER-2-119></A>Dispatching Apple Events Directly to an Apple Event Object</H3>
 If the application does not include MacApp's attachability code, or if an Apple event is not handled by an object with an attached script, the Apple Event Manager makes a callback to the Apple event dispatcher object's <CODE><A NAME=MARKER-2-120></A>DispatchHandlerGlue</CODE> method, which does the following:<P>
<UL>
<LI>If the Apple event is a reply message, the <CODE>DispatchHandlerGlue</CODE> method calls a method to determine whether the application is waiting for a reply to an asynchronous Apple event. If so, and if the Apple event is a reply to a pending client command, the method posts the pending command to respond to the reply. See <A HREF=MacAppProgGuide-62.html#MARKER-2-222>"The TClientCommand Class" on page 157</A> for a more detailed explanation of MacApp's mechanism for sending an Apple event to an external process.
<LI>Otherwise, the <CODE>DispatchHandlerGlue</CODE> method calls the <CODE><A NAME=MARKER-9-81></A>DispatchHandler</CODE> method, passing a MacApp command number value. <P>
</UL>
 The <CODE>DispatchHandler</CODE> method performs several actions:<P>
<UL>
<LI>It calls a method to get the direct (Apple event) object of the event or, if an object can't be resolved, to return the default target object (normally the application object).
<LI>If the target object appears to be a container for a list of scriptable objects, the <CODE>DispatchHandler</CODE> method gets the target's container object.
<LI>If the target object has a pending command that matches the Apple event, the <CODE>DispatchHandler</CODE> method returns the error <CODE><A NAME=MARKER-2-122></A>errAEEventNotHandled</CODE>, indicating that the Apple event was not handled. This happens when the application is in the process of performing a command, the command has sent an Apple event to record its action, and the Apple event is not intercepted by an attached script. Therefore, as an optimization, we can skip processing the Apple event and let the command perform the desired action. For more information, see <A HREF=MacAppProgGuide-44.html#MARKER-9-167>"Command Objects and Apple Events," beginning on page 120</A>.
<LI>Otherwise, if the target is a container object, <CODE>DispatchHandler</CODE> calls the <CODE><A NAME=MARKER-2-123></A>DoAEOnContainedObjects</CODE> method of the target object, which does one of the following:<P>
<UL>
<LI>If the object is a scriptable object list, it creates a <CODE><A NAME=MARKER-2-124></A>TSetPropertyCommand</CODE> object to set the specified property for the objects in the list. The <CODE>TSetPropertyCommand</CODE> is described in the next section.
<LI>Otherwise, it calls the <CODE>DoScriptCommand</CODE> method of the container (target) object. The <CODE>DoScriptCommand</CODE> method uses the passed command number to decide how to handle the Apple event.<P>
</UL>
<LI>If the target is <I>not</I> a container object, <CODE>DispatchHandler</CODE> calls the <CODE>HandleScriptCommand</CODE> method of the target object. <CODE>HandleScriptCommand</CODE> is a method of <CODE>MScriptableObject</CODE>, which first gives any attached behavior objects a chance to handle the Apple event and then, if none does, calls the <CODE>DoScriptCommand</CODE> method. The <CODE>DoScriptCommand</CODE> method uses the passed command number to decide how to handle the Apple event.<P>
</UL>
 Although this is a rather complicated algorithm, for most Apple events the <CODE><A NAME=MARKER-2-126></A>DispatchHandler</CODE> method ends up performing the following actions:<P>
<UL>
<LI>It resolves the target object specified by the Apple event (or uses the default target, normally the application object).
<LI>It calls the <CODE>DoScriptCommand</CODE> method of the resolved target object, passing among other things a MacApp command-number constant.<P>
</UL>
 The <CODE>MScriptableObject::DoScriptCommand</CODE> method calls other methods of <CODE>MScriptableObject</CODE> to handle many specific commands. For example, it calls <CODE><A NAME=MARKER-2-128></A>DoAEClose</CODE> to handle a <CODE>cAEClose</CODE> or <CODE><A NAME=MARKER-2-129></A>cAEQuit</CODE> command, <CODE><A NAME=MARKER-2-130></A>DoAEMove</CODE> for a <CODE>cAEMove</CODE> command, <CODE>DoAEOpen</CODE> for a <CODE><A NAME=MARKER-2-131></A>cAEOpen</CODE> command, and so on. MacApp classes such as <CODE>TApplication</CODE>, <CODE>TDocument</CODE>, and <CODE>TWindow</CODE> override these methods to open or close windows or documents, quit the application, and so on.<P>
 Your classes that support scripting mix in the <CODE>MScriptableObject</CODE> class, so they can override these methods too. If a class handles additional commands that aren't supported by <CODE>MScriptableObject</CODE>, it can override the <CODE>DoScriptCommand</CODE> method. For more information on adding scripting support to your classes, see <A HREF=MacAppProgGuide-91.html#MARKER-9-19>Chapter 14, "Working With Scripting."</A><P>
<DL>
<DT><B>Note</B>
<DD>An application may need to create a document that is invisible to the AppleScript interface. For more information, see <A HREF=MacAppProgGuide-60.html#MARKER-9-151>"A Note on Ghost Documents," beginning on page 184</A>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING52-54></A>
<H2><A NAME=MARKER-2-132></A><A NAME=MARKER-9-73></A><A NAME=MARKER-9-134></A>The TSetPropertyCommand Class</H2>
 MacApp makes it easy for your application to set object properties based on received Apple events. A class that wishes to set a property in response to an Apple event overrides the <CODE><A NAME=MARKER-2-135></A>GetObjectProperty</CODE> method, the <CODE><A NAME=MARKER-2-136></A>SetObjectProperty</CODE> method, and possibly the <CODE><A NAME=MARKER-2-137></A>GetSetPropertyInfo</CODE> method. MacApp does the rest. <P>
 When MacApp receives a Set Data event specifying a property to be set, it creates a <CODE>TSetPropertyCommand</CODE> object to actually set the property. The command's initialization method calls the <CODE>GetSetPropertyInfo</CODE> method of the target object to obtain information about the command, including<P>
<UL>
<LI>the command number
<LI>whether the command can be undone
<LI>whether the command changes its context (the document, window, or other object the command operates on)
<LI>a reference to the command's context<P>
</UL>
 The <CODE>GetSetPropertyInfo</CODE> method of the <CODE>MScriptableObject</CODE> class provides default values that may work for your scriptable class--if not, you provide an override method.<P>
  For example, in the IconEdit sample application, which uses Apple events to set an icon's color, the <CODE>TIconDocument</CODE> class overrides the <CODE>GetSetPropertyInfo</CODE> method to supply a command number (<CODE><A NAME=MARKER-2-138></A>cSetColor</CODE>), and to specify that the context is the icon document, the command is undoable, and the command changes the document. <CODE>TIconDocument</CODE> also overrides <CODE>GetObjectProperty</CODE> to return the current icon color and <CODE>SetObjectProperty</CODE> to set the icon color.<P>
 The <CODE>TSetPropertyCommand</CODE> sets the property for a list of one or more objects. Before setting the new property, the <CODE>DoIt</CODE> method calls the <CODE>GetObjectProperty</CODE> method for each object in the list. The command object stores the original property setting so that it can restore the property to its original state for undo.<P>
 The next section describes how a <CODE>TSetPropertyCommand</CODE> command is created. For more information on getting and setting properties in your application, see <A HREF=MacAppProgGuide-93.html#MARKER-9-37>"Recipe--Setting Object Properties With Apple Events," beginning on page 355</A>.<P>
<A NAME=HEADING52-65></A>
<H2><A NAME=MARKER-9-139></A><CODE><A NAME=MARKER-2-140></A></CODE>The TPropertyAccessor Class</H2>
 The target specified by an Apple event can be a C++ object (such as a window) or a simpler Apple event object (such as a paragraph of text). The specified operation may also refer to a C++ object (such as activating a window) or to an Apple event object (such as deleting the third word in a paragraph).<P>
 To resolve the target object specified by an Apple event, the OSL may call the global Apple event dispatcher object's <CODE>ObjectAccessor</CODE> method, passing information about the current contained object. (Note that the OSL actually calls the <CODE>ObjectAccessorGlue</CODE> method, which in turn calls <CODE>ObjectAccessor</CODE>.) The <CODE>ObjectAccessor</CODE> method calls the <CODE>GetContainedObject</CODE> method of the current contained object, passing the desired object type, form, and other information.<P>
 When the Apple event's specified operation describes a <I>property</I> of the current object, the <CODE>MScriptableObject:GetContainedObject</CODE> method returns an object of type <CODE>TPropertyAccessor</CODE>. The property accessor object knows which property was specified and keeps a reference to the current object. By returning a property accessor object to handle the event, MacApp can automate the process of responding to Set Property Apple events for classes you have defined, as long as your classes override the <CODE>GetObjectProperty</CODE> and <CODE>SetObjectProperty</CODE> methods.<P>
 Once a target object has been resolved, the global Apple event dispatcher calls the object's <CODE><A NAME=MARKER-2-141></A>HandleScriptCommand</CODE> method, which eventually calls the target's <CODE><A NAME=MARKER-2-23></A>DoScriptCommand</CODE> method. For a <CODE>TPropertyAccessor</CODE> object, the <CODE>DoScriptCommand</CODE> method creates a <CODE>TSetPropertyCommand</CODE> command object (described in the previous section) and calls its <CODE>Process</CODE> method to immediately execute the command.<A NAME=MARKER-2-143></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>See <A HREF=MacAppProgGuide-44.html#MARKER-9-151>"The Command Context for Classes That Handle Apple Events," beginning on page 118</A>, for important information on supplying a context for a command object.<A NAME=MARKER-2-144></A><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING52-71></A>
<H2><A NAME=MARKER-2-145></A><A NAME=MARKER-2-222></A>The TClientCommand Class</H2>
 <A NAME=MARKER-2-147></A>MacApp provides the <CODE>TClientCommand</CODE> class as a base class for commands that send an Apple event to an external process. When any command object is posted, the application calls the command's <CODE><A NAME=MARKER-2-148></A>IsReadyToPost</CODE> method. The <CODE>TClientCommand</CODE> class overrides this method to send its Apple event immediately on posting. <CODE>TClientCommand</CODE> can handle any of three sending modes:<P>
<DL>
<DT><CODE>kAENoReply<B></B></CODE>
<DD> The constant <CODE>kAENoReply</CODE> is used when no reply to the sent Apple event is expected. The <CODE>IsReadyToPost</CODE> method returns <CODE>TRUE</CODE>, and the command is posted to the command queue. When the command is executed, the <CODE>DoIt</CODE> method sends the Apple event. No reply is generated.
<DT><CODE>kAEWaitReply<B></B></CODE>
<DD> The constant <CODE>kAEWaitReply</CODE> is used when the command should wait for a reply to the sent Apple event. The <CODE>IsReadyToPost</CODE> method sends the Apple event and waits for a reply. It then returns <CODE>TRUE</CODE>, so the command is posted to the command queue. The default <CODE>DoIt</CODE> method does nothing. Your subclass should override <CODE>DoIt</CODE> to perform an operation based on the Apple event reply.
<DT><CODE>kAEQueueReply<B></B></CODE>
<DD> The constant <CODE>kAEQueueReply</CODE> is used when an asynchronous reply is expected to the sent Apple event. The <CODE>IsReadyToPost</CODE> method sends the Apple event, tells the global Apple event dispatcher object that the command is pending, then returns <CODE>FALSE</CODE> so the command is not posted to the command queue. When a reply is received at some later point, the global Apple event dispatcher object posts the command. Again, the default <CODE>DoIt</CODE> method does nothing. Your subclass can override <CODE>DoIt</CODE> to perform an operation based on the Apple event reply.
</DL>
 When you create a command based on the <CODE>TClientCommand</CODE> class, you supply the <CODE>IClientCommand</CODE> method with an Apple event for the command to send. The sending mode of the apple event is one of the three constants described above: <CODE>kAENoReply</CODE>, <CODE>kAEWaitReply</CODE>, or <CODE>kAEQueueReply</CODE>.<A NAME=MARKER-2-149></A><A NAME=MARKER-2-32></A><A NAME=MARKER-2-151></A><A NAME=MARKER-2-152></A><A NAME=MARKER-2-153></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-51.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-53.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
