<html><head><title></title></head>

<body bgcolor="#ffffff">

 

 

<h1>

<img src="../cluster.gif">

<FONT COLOR="#000066">

<a name="173">

NSData Class Cluster

</a>

</FONT>

</h1>

<p><h3>

<a name="208">

Class Cluster Description 

</a>

</h3>

NSData objects provide an object-oriented wrapper for byte buffers. This enables simple allocated buffers (that is, data with no embedded pointers) to take on the behavior of Foundation Kit objects. NSData is typically used for data storage. It is also useful in Distributed Objects applications, where data contained in NSData objects can be copied or moved between applications. <p>

NSData objects can be used to wrap data of any size. When the data size is more than a few memory pages, NSData uses virtual memory management. NSData can also be used to wrap pre-existing data, regardless of how the data was allocated. NSData contains no information about the data itself (such as its type); the responsibility for deciding how to use the data lies with the client. In particular, it will not handle byte-order swapping when distributed between big-endian and little-endian machines. For typed data, use NSValue.<p>

NSData provides an operating system-independent way to benefit from copy-on-write memory. The copy-on-write technique means that when data is copied through a virtual memory copy, an actual copy of the data is not made until there is an attempt to modify it.<p>

The cluster's two public classes, NSData and NSMutableData, declare the programmatic interface for static and dynamic NSData objects, respectively. <p>

The objects you create using these classes are referred to as <em>data objects</em>. Because of the nature of class clusters, data objects are not actual instances of the NSData or NSMutableData classes but instead are instances of one of their private subclasses. Although a data object's class is private, its interface is public, as declared by these abstract superclasses, NSData and NSMutableData.<p>

Generally, you instantiate a data object by sending one of the <code>data...</code> messages to either the NSData or NSMutableData class object. These methods return a data object containing the bytes you pass in as arguments. If you use one of the<code> data...</code> methods whose name <em>does not</em> include "NoCopy" (such as <code>dataWithBytes:length:</code>), the bytes to be contained by the data object are copied as part of the instantiation process, and the data object then contains the copied bytes. When you subsequently release a data object that has been instantiated in this manner, the bytes contained by the data object-those that were copied during instantiation-are automatically freed. If you instantiate a data object with one of the methods whose name includes "NoCopy," however, (such as <code>dataWithBytesNoCopy:length:</code>) the bytes are not copied and are freed when the data object is released.<p>

The NSData classes adopt the NSCopying and NSMutableCopying protocols, making it convenient to convert between efficient, read-only data objects and mutable data objects.<p>

<hr><p>

<h1>

<img src="../clsclstr.gif">

<FONT COLOR="#000066">

<a name="216"><a name="//apple_ref/occ/cl/NSData">NSData</a>

</a>

</FONT>

</h1>

<p><B>Inherits From:</B><BR>  

NSObject



<p><B>Conforms To:</B><BR>

NSCoding<br>

NSCopying<br>

NSMutableCopying<br>

NSObject (NSObject) 



<p><B>Declared In:	</B><BR>

Foundation/NSData.h<br>

Foundation/NSSerialization.h



<p><p>

<a name="220"></a>

<HR WIDTH="75%" SIZE="4" ALIGN="LEFT">

<H3>

<FONT COLOR="#201040">

Class At A Glance

</FONT>

</H3>

<dl><a name="221"></a>

<dt><h4>Purpose</h4>

<dd><dl>

<dt>An NSData object stores immutable data in the form of bytes.

</dl></dd>

<a name="223"></a>

<dt><h4>Principal Attributes</h4>

</dl><ul><li>A count of the number of bytes in the data object.<br>

<li>The sequence of bytes contained in the data object.<br>

</ul><dl><a name="226"></a>

<dt><h4>Creation<p>

<Table Border="3">

<caption></caption>

<tr><td scope="row">+ data

</td><td>Returns an empty data object.

</td></tr>

<tr><td scope="row">+ dataWithBytes:length:

</td><td>Returns a data object that contains a copy of the specified bytes.

</td></tr>

<tr><td scope="row">+ dataWithBytesNoCopy:length:

</td><td>Returns a data object that contains the specified bytes (without 

copying them).

</td></tr>

<tr><td scope="row">+ dataWithContentsOfFile:

</td><td>Returns a data object initialized with the contents of a file.

</td></tr>

<tr><td scope="row">+ dataWithContentsOfMappedFile:

</td><td>Returns a data object initialized with the contents of a mapped file.

</td></tr>

<tr><td scope="row">+ dataWithData:

</td><td>Returns a data object initialized with the contents of another data 

object.

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

</h4>

<a name="227"></a>

<dt><h4>Commonly Used Methods<p>

<Table Border="3">

<caption></caption>

<tr><td>- bytes

</td><td>Returns a pointer to the data object's contents.

</td></tr>

<tr><td scope="row">- getBytes:

</td><td>Copies the data object's contents into a buffer.

</td></tr>

<tr><td scope="row">- length

</td><td>Returns the number of bytes contained by the data object.

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

</h4>

<a name="228"></a>

<dt><h4>Primitive Methods</h4>

<dd><dl>

<dt>- bytes

<dt>- length

</dl></dd>

</dl><HR WIDTH="75%" SIZE="4" ALIGN="LEFT">

<p><a name="232"></a>

<a name="description"></a>

<H2>Class Description

</H2>

The NSData class declares the programmatic interface to an object that contains immutable data in the form of bytes. NSData's two primitive methods-<code>bytes</code> and <code>length</code>-provide the basis for all of the other methods in the interface. The <code>bytes</code> method returns a pointer to the bytes contained in the data object. <code>length </code>returns the number of bytes contained in the data object. <p>

NSData provides access methods for copying bytes from a data object into a specified buffer. <code>getBytes </code>copies all of the bytes into a buffer, whereas <code>getBytes:length:</code> copies bytes into a buffer of a given length. <code>getBytes:range:</code> copies a range of bytes from a starting point within the bytes themselves. You can also obtain a data object that contains a subset of the bytes in another data object by using the <code>subdataWithRange:</code> method. Or, you can use the <code>description</code> method to return an NSString representation of the bytes in a data object.<p>

For determining if two data objects are equal, NSData provides the<code> isEqualToData:</code> method, which does a byte-for-byte comparison.<p>

The <code>writeToFile:atomically:</code> method enables you to write the contents of a data object to a file.<p>

<HR WIDTH="50%" ALIGN="LEFT">

<h2>Adopted Protocols</h2>  





<dl>

<dt>NSCoding<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="../../Protocols/NSCoding.html#//apple_ref/occ/intfm/NSCoding/encodeWithCoder:" target="_top">- encodeWithCoder:</a><dt><a href="../../Protocols/NSCoding/NSCoding.html#//apple_ref/occ/intfm/NSCoding/initWithCoder:" target="_top">- initWithCoder:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>NSCopying<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="../../Protocols/NSCopying/NSCopying.html#//apple_ref/occ/intfm/NSCopying/copyWithZone:" target="_top">- copyWithZone:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>NSMutableCopying<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="../../Protocols/NSMutableCopying/NSMutableCopying.html#//apple_ref/occ/intfm/NSMutableCopying/mutableCopyWithZone:" target="_top">- mutableCopyWithZone:</a></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<a name="244">

<HR WIDTH="50%" ALIGN="LEFT">

<h2>Method Types

</h2>

</a><dl>

<dt>Creating data objects<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSData/allocWithZone:">+ allocWithZone:</a><dt><a href="#//apple_ref/occ/clm/NSData/data">+ data</a><dt><a href="#//apple_ref/occ/clm/NSData/dataWithBytes:length:">+ dataWithBytes:length:</a><dt><a href="#//apple_ref/occ/clm/NSData/dataWithBytesNoCopy:length:">+ dataWithBytesNoCopy:length:</a><dt><a href="#//apple_ref/occ/clm/NSData/dataWithContentsOfFile:">+ dataWithContentsOfFile:</a><dt><a href="#//apple_ref/occ/clm/NSData/dataWithContentsOfMappedFile:">+ dataWithContentsOfMappedFile:</a><dt><a href="#//apple_ref/occ/clm/NSData/dataWithData:">+ dataWithData:</a><dt><a href="#//apple_ref/occ/clm/NSData/dataWithStream:">+ dataWithStream:</a><dt><a href="#//apple_ref/occ/instm/NSData/initWithBytes:length:">- initWithBytes:length:</a><dt><a href="#//apple_ref/occ/instm/NSData/initWithBytesNoCopy:length:">- initWithBytesNoCopy:length:</a><dt><a href="#//apple_ref/occ/instm/NSData/initWithContentsOfFile:">- initWithContentsOfFile:</a><dt><a href="#//apple_ref/occ/instm/NSData/initWithContentsOfMappedFile:">- initWithContentsOfMappedFile:</a><dt><a href="#//apple_ref/occ/instm/NSData/initWithData:">- initWithData:</a><dt><a href="#//apple_ref/occ/instm/NSData/initWithStream:">- initWithStream:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Accessing data<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSData/bytes">- bytes </a><dt><a href="#//apple_ref/occ/instm/NSData/description">- description</a><dt><a href="#//apple_ref/occ/instm/NSData/getBytes:">- getBytes:</a><dt><a href="#//apple_ref/occ/instm/NSData/getBytes:length:">- getBytes:length:</a><dt><a href="#//apple_ref/occ/instm/NSData/getBytes:range:">- getBytes:range:</a><dt><a href="#//apple_ref/occ/instm/NSData/subdataWithRange:">- subdataWithRange:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Deserializing data<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSData/deserializeAlignedBytesLengthAtCursor:">- deserializeAlignedBytesLengthAtCursor:</a><dt><a href="#//apple_ref/occ/instm/NSData/deserializeBytes:length:atCursor:">- deserializeBytes:length:atCursor:</a><dt><a href="#//apple_ref/occ/instm/NSData/deserializeDataAt:ofObjCType:atCursor:context:">- deserializeDataAt:ofObjCType:atCursor:context:</a><dt><a href="#//apple_ref/occ/instm/NSData/deserializeIntAtCursor:">- deserializeIntAtCursor:</a><dt><a href="#//apple_ref/occ/instm/NSData/deserializeIntAtIndex:">- deserializeIntAtIndex:</a><dt><a href="#//apple_ref/occ/instm/NSData/deserializeInts:count:atCursor:">- deserializeInts:count:atCursor:</a><dt><a href="#//apple_ref/occ/instm/NSData/deserializeInts:count:atIndex:">- deserializeInts:count:atIndex:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Testing data<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSData/isEqualToData:">- isEqualToData:</a><dt><a href="#//apple_ref/occ/instm/NSData/length">- length </a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Storing data<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSData/writeToFile:atomically:">- writeToFile:atomically:</a></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<HR WIDTH="50%" ALIGN="LEFT">

<a name="280"></a>

<a name="clm"></a>

<h2>Class Methods</h2>  





<a name="281"></a>

<h3>

 <a name="//apple_ref/occ/clm/NSData/allocWithZone:">allocWithZone:</a>

</h3>

+ (id)<code>allocWithZone:</code>(NSZone *)<em>zone</em>

<P>Creates and returns an uninitialized data object in the specified zone. If the receiver is the NSData class object, an instance of an appropriate immutable subclass is returned; otherwise, an object of the receiver's class is returned.<p>

Typically, you create temporary data objects using the <code>data... </code>class methods, not the <code>alloc...</code> and<code> init... </code>methods.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="285"></a>

<h3> <a name="//apple_ref/occ/clm/NSData/data">data</a></h3>

<code>+ (id)data</code>

<P>Creates and returns an empty data object. This method is declared primarily for the use of mutable subclasses of NSData.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="288"></a>

<h3> <a name="//apple_ref/occ/clm/NSData/dataWithBytes:length:">dataWithBytes:length:</a></h3>

+ (id)<code>dataWithBytes:</code>(const void *)<em>bytes</em><code> length:</code>(unsigned int)<em>length</em>

<P>Creates and returns a data object containing <em>length</em> bytes copied from the buffer <em>bytes</em>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSData/dataWithBytesNoCopy:length:">+ dataWithBytesNoCopy:length:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="292"></a>

<h3> <a name="//apple_ref/occ/clm/NSData/dataWithBytesNoCopy:length:">dataWithBytesNoCopy:length:</a></h3>

+ (id)<code>dataWithBytesNoCopy:</code>(void *)<em>bytes</em><code> length:</code>(unsigned int)<em>length</em>

<P>Creates and returns a data object that holds <em>length</em> bytes from the buffer <em>bytes</em>.<p>

<B>See also: </B>  

 <a href="#//apple_ref/occ/clm/NSData/dataWithBytes:length:"><code>+ dataWithBytes:length:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="296"></a>

<h3> <a name="//apple_ref/occ/clm/NSData/dataWithContentsOfFile:">dataWithContentsOfFile:</a></h3>

+ (id)<code>dataWithContentsOfFile:</code>(NSString *)<em>path</em>

<P>Creates and returns a data object by reading every byte from the file specified by <em>path</em>.<p>

The following code example creates a data object <em>myData</em> initialized with the contents of <code>myFile.txt</code>. The path must be absolute.<p>

<blockquote><pre>NSString *thePath = @"/u/smith/myFile.txt";    <br>NSData *myData = [NSData dataWithContentsOfFile:thePath];

</pre></blockquote><p><B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSData/dataWithContentsOfMappedFile:">+ dataWithContentsOfMappedFile:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="302"></a>

<h3> <a name="//apple_ref/occ/clm/NSData/dataWithContentsOfMappedFile:">dataWithContentsOfMappedFile:</a></h3>

+ (id)<code>dataWithContentsOfMappedFile:</code>(NSString *)<em>path</em>

<P>Creates and returns a data object from the mapped file specified by <em>path</em>. Because of file mapping restrictions, this method should only be used if the file is guaranteed to exist for the duration of the data object's existence. It is generally safer to use the <code>dataWithContentsOfFile:</code> method.<p>

This methods assumes that mapped files are available from the underlying operating system. A mapped file uses virtual memory techniques to avoid copying pages of the file into memory until they are actually needed.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSData/dataWithContentsOfFile:">+  dataWithContentsOfFile:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="307"></a>

<h3><a name="//apple_ref/occ/clm/NSData/dataWithData:">dataWithData:</a></h3>

+ (id)<code>dataWithData:</code>(NSData *)<em>aData</em>

<P>Creates and returns a data object containing the contents of another data object, <em>aData</em>.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="310"></a>

<h3> <a name="//apple_ref/occ/clm/NSData/dataWithStream:">dataWithStream:</a></h3>

+ (id)<code>dataWithStream:</code>(NXStream *)<em>stream</em>

<P>Creates and returns a data object containing the contents of <em>stream</em>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/initWithStream:">- initWithStream:</a>

</code><p><HR WIDTH="50%" ALIGN="LEFT">

<a name="instm"></a>

<h2>Instance Methods</h2>  





<a name="315"></a>

<h3>

 <a name="//apple_ref/occ/instm/NSData/bytes">bytes</a>

</h3>

- (const void *)<code>bytes</code>

<P>Returns a pointer to the data object's contents. This method returns read-only access to the data.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/description">- description</a>, <a href="#//apple_ref/occ/instm/NSData/getBytes:">- getBytes:</a>, <a href="#//apple_ref/occ/instm/NSData/getBytes:length:">- getBytes:length:</a>, <a href="#//apple_ref/occ/instm/NSData/getBytes:range:">- getBytes:range:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="319"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/description">description</a></h3>

@protocol NSObject

<P>- (NSString *)<code>description</code>

<P>Returns an NSString object that contains a hexadecimal representation of the receiver's contents in the property list format for NSData objects.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/bytes">- bytes</a>, <a href="#//apple_ref/occ/instm/NSData/getBytes:">- getBytes:</a>, <a href="#//apple_ref/occ/instm/NSData/getBytes:length:">- getBytes:length:</a>, <a href="#//apple_ref/occ/instm/NSData/getBytes:range:">- getBytes:range:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="324"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/deserializeAlignedBytesLengthAtCursor:">deserializeAlignedBytesLengthAtCursor:</a></h3>

- (unsigned int)<code>deserializeAlignedBytesLengthAtCursor:</code>(unsigned *)<em>cursor</em>

<P>Reads a sequence of bytes from the receiver beginning at location <em>cursor</em> and returns them formatted as an unsigned integer. On return, <em>cursor</em> is set to the location just past the bytes that were read.<p>

Use this method to read an integer that was serialized using the <code>serializeAlignedBytesLength:</code> method of NSMutableData. This method ignores any filler bytes that were serialized by the <code>serializeAlignedBytesLength:</code> method.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/deserializeIntAtCursor:">- deserializeIntAtCursor:</a>, <a href="#//apple_ref/occ/instm/NSData/deserializeIntAtIndex:">- deserializeIntAtIndex:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="329"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/deserializeBytes:length:atCursor:">deserializeBytes:length:atCursor:</a></h3>

- (void)<code>deserializeBytes:</code>(void *)<em>buffer</em> <br><code>length:</code>(unsigned int)<em>bytes</em> <br><code>atCursor:</code>(unsigned int*)<em>cursor</em>

<P>Reads a sequence of bytes from the receiver beginning at location <em>cursor</em> and places them in <em>buffer</em>. The <em>bytes</em> parameter specifies the number of bytes to be read. On return, <em>cursor</em> is set to the location just beyond the bytes that were read.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/getBytes:range:">- getBytes:range:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="333"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/deserializeDataAt:ofObjCType:atCursor:context:">deserializeDataAt:ofObjCType:atCursor:context:</a></h3>

- (void)<code>deserializeDataAt:</code>(void *)<em>data</em> <br><code>ofObjCType:</code>(const char *)<em>type</em> <br><code>atCursor:</code>(unsigned int*)<em>cursor</em> <br><code>context:</code>(id &lt;NSObjCTypeSerializationCallBack&gt;)<em>callback</em>

<P>Reads a sequence of bytes from the receiver beginning at location <em>cursor</em> and places them in <em>data</em>. The bytes are formatted according to the Objective-C type code given in <em>type</em>. If <em>type</em> specifies an object, <em>callback</em> is used to deserialize the object; in such a case, <em>callback</em> must itself be an object that conforms to the NSObjCTypeSerializationCallBack protocol. If <em>type</em> does not specify an object, <em>callback</em> can be <code>nil</code>.<p>

For information on on creating an Objective-C type code suitable for <em>type</em>, see the description of the <code>@encode()</code> compiler directive in <em>Object-Oriented Programming and the Objective-C Language</em>.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="337"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/deserializeIntAtCursor:">deserializeIntAtCursor:</a></h3>

- (int)<code>deserializeIntAtCursor:</code>(unsigned int*)<em>cursor</em>

<P>Reads a sequence of bytes from the receiver beginning at location <em>cursor</em> and returns them as an integer value. On return, <em>cursor</em> is set to the location just past the bytes that were read.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/deserializeIntAtIndex:">- deserializeIntAtIndex:</a>, <a href="#//apple_ref/occ/instm/NSMutableData/serializeInt:">- serializeInt: (NSMutableData)</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="341"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/deserializeIntAtIndex:">deserializeIntAtIndex:</a></h3>

- (int)<code>deserializeIntAtIndex:</code>(unsigned int)<em>index</em>

<P>Reads a sequence of bytes from the receiver starting at <em>index</em> and returns them as an integer value.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/getBytes:range:">- getBytes:range:</a>, <a href="#//apple_ref/occ/instm/NSMutableData/serializeInt:">- serializeInt: (NSMutableData)</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="345"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/deserializeInts:count:atCursor:">deserializeInts:count:atCursor:</a></h3>

- (void)<code>deserializeInts:</code>(int *)<em>intBuffer</em> <br><code>count:</code>(unsigned int)<em>numInts</em> <br><code>atCursor:</code>(unsigned int*)<em>cursor</em>

<P>Reads <em>numInts</em> integers as a sequence of bytes from the receiver and copies them into <em>intBuffer</em>. The bytes are read from the receiver beginning at location <em>cursor</em>. On return, <em>cursor</em> is set to the location just past the integers that were read.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/getBytes:range:">- getBytes:range:</a>, <a href="#//apple_ref/occ/instm/NSData/deserializeIntAtCursor:">- deserializeIntAtCursor:</a>, <a href="#//apple_ref/occ/instm/NSMutableData/serializeInts:count:">- serializeInts:count:</code> (NSMutableData)</a>

<p><hr WIDTH="25%" ALIGN="LEFT">

<a name="349"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/deserializeInts:count:atIndex:">deserializeInts:count:atIndex:</a></h3>

- (void)<code>deserializeInts:</code>(int *)<em>intBuffer</em> <br><code>count:</code>(unsigned int)<em>numInts</em> <br><code>atIndex:</code>(unsigned int)<em>index</em>

<P>Reads <em>numInts</em> integers as a sequence of bytes from the receiver and copies them into <em>intBuffer</em>. The bytes are read from the receiver starting at <em>index</em>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/getBytes:range:">- getBytes:range:</a>, <a href="#//apple_ref/occ/instm/NSData/deserializeIntAtIndex:">- deserializeIntAtIndex:</a>, <a href="#//apple_ref/occ/instm/NSMutableData/serializeInts:count:">- serializeInts:count:</code> (NSMutableData)</a>

<p><hr WIDTH="25%" ALIGN="LEFT">

<a name="353"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/getBytes:">getBytes:</a></h3>

- (void)<code>getBytes:</code>(void *)<em>buffer</em>

<P>Copies a data object's contents into<code> </code><em>buffer</em><code>.</code><p>

For example, the following code excerpt initializes a data object <em>myData</em> with the NSString <em>myString</em>. It then uses <code>getBytes:</code> to copy the contents of <em>myData</em> into <em>aBuffer</em>.<p>

<blockquote><pre>unsigned char aBuffer[20];<br>NSString *myString = @"Test string.";<br>NSData *myData = [NSData dataWithBytes:[myString cString]<br>        length:[myString cStringLength]];<br>    <br>[myData getBytes:aBuffer];

</pre></blockquote><p><B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/bytes">- bytes</a></code>, <a href="#//apple_ref/occ/instm/NSData/description"><code>- description</a></code>, <a href="#//apple_ref/occ/instm/NSData/getBytes:length:"><code>- getBytes:length:</a></code>, <a href="#//apple_ref/occ/instm/NSData/getBytes:range:"><code>- getBytes:range:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="359"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/getBytes:length:">getBytes:length:</a></h3>

- (void)<code>getBytes:</code>(void *)<em>buffer</em> <code>length:</code>(unsigned int)<em>length</em>

<P>Copies up to <em>length</em> bytes from the start of the receiver into <em>buffer</em>. <p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/bytes">- bytes</a></code>, <a href="#//apple_ref/occ/instm/NSData/description"><code>- description</a></code>, <a href="#//apple_ref/occ/instm/NSData/getBytes:"><code>- getBytes:</a></code><code>,</code> <a href="#//apple_ref/occ/instm/NSData/getBytes:range:"><code>- getBytes:range:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="363"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/getBytes:range:">getBytes:range:</a></h3>

- (void)<code>getBytes:</code>(void *)<em>buffer</em> <code>range:</code>(NSRange)<em>range</em>

<P>Copies the receiver's contents into <em>buffer</em>, from <em>range</em> that is within the bytes in the object. If <em>range</em> isn't within the receiver's range of bytes, an NSRangeException is raised.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/bytes">- bytes</a></code>, <a href="#//apple_ref/occ/instm/NSData/description"><code>- description</a></code>, <a href="#//apple_ref/occ/instm/NSData/getBytes:"><code>- getBytes:</a></code><code>,</code> <a href="#//apple_ref/occ/instm/NSData/getBytes:length:"><code>- getBytes:length:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="367"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/hash">hash</a></h3>

@protocol NSObject

<P>- (unsigned int)<code>hash</code>

<P>Returns an unsigned integer that can be used as a table address in a hash table structure. For a data object, <code>hash</code> returns the length of the data object. If two data objects are equal (as determined by the <code>isEqual:</code> method), they have the same hash value.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/isEqual:">- isEqual:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="372"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/initWithBytes:length:">initWithBytes:length:</a></h3>

<code>-</code> (id)<code>initWithBytes:</code>(const void *)<em>bytes</em> <code>length:</code>(unsigned int)<em>length</em>

<P>Initializes a newly allocated data object by adding to it length bytes of data copied from the buffer bytes. Returns self.<p>

<B>See also: </B>  

 <a href="#//apple_ref/occ/clm/NSData/dataWithBytes:length:"><code>+ dataWithBytes:length:</a></code>, <a href="#//apple_ref/occ/instm/NSData/initWithBytesNoCopy:length:"><code>- initWithBytesNoCopy:length:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="376"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/initWithBytesNoCopy:length:">initWithBytesNoCopy:length:</a></h3>

<code>-</code> (id)<code>initWithBytesNoCopy:</code>(void *)<em>bytes</em><code> length:</code>(unsigned int)<em>length</em>

<P>Initializes a newly allocated data object by adding to it length bytes of data from the buffer bytes. Returns self.<p>

<B>See also: </B>  

 <a href="#//apple_ref/occ/clm/NSData/dataWithBytes:length:"><code>+ dataWithBytes:length:</a></code>, <a href="#//apple_ref/occ/instm/NSData/initWithBytes:length:"><code>- initWithBytes:length:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="380"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/initWithContentsOfFile:">initWithContentsOfFile:</a></h3>

<code>-</code> (id)<code>initWithContentsOfFile:</code>(NSString *)<em>path</em>

<P>Initializes a newly allocated data object by reading into it the data from the file specified by <em>path</em>.<code> Returns self.</code><p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSData/dataWithContentsOfFile:">+ dataWithContentsOfFile:</a></code>, <a href="#//apple_ref/occ/instm/NSData/initWithContentsOfMappedFile:"><code>-  initWithContentsOfMappedFile:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="384"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/initWithContentsOfMappedFile:">initWithContentsOfMappedFile:</a></h3>

<code>-</code> (id)<code>initWithContentsOfMappedFile:</code>(NSString *)<em>path</em>

<P>Initializes a newly allocated data object by reading into it the mapped file specified by <em>path</em>.<code> Returns self.</code><p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSData/dataWithContentsOfMappedFile:">+ dataWithContentsOfMappedFile:</a></code>, <a href="#//apple_ref/occ/instm/NSData/initWithContentsOfFile:"><code>- initWithContentsOfFile:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="388"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/initWithData:">initWithData:</a></h3>

<code>-</code> (id)<code>initWithData:</code>(NSData *)<em>data</em>

<P>Initializes a newly allocated data object by placing in it the contents of another data object, <em>data</em>.<code> Returns self.</code><p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="391"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/initWithStream:">initWithStream:</a></h3>

<code>-</code> (id)<code>initWithStream:</code>(NXStream *)<em>stream</em>

<P>Initializes a newly allocated data object by placing in it the contents of <em>stream</em>. <code>Returns self.</code><p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="394"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/isEqual:">isEqual:</a></h3>

@protocol NSObject

<P>- (BOOL)<code>isEqual:</code>(id)<em>anObject</em>

<P>Returns YES if the receiver and <em>anObject</em> are equal; otherwise returns NO. A YES return value indicates that the receiver and <em>anObject</em> are both instances of classes that inherit from NSData and that both contain the same data (as determined by the <code>isEqualToData:</code> method).<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/isEqualToData:">- isEqualToData:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="399"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/isEqualToData:">isEqualToData:</a></h3>

- (BOOL)<code>isEqualToData:</code>(NSData *)<em>otherData</em>

<P>Compares the receiving data object to <em>otherData</em>. If the contents of <em>otherData</em> are equal to the contents of the receiver, this method returns YES. If not, it returns NO. Two data objects are equal if they hold the same number of bytes, and if the bytes at the same position in the objects are the same.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/isEqual:">- isEqual:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="403"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/length">length</a></h3>

- (unsigned int)<code>length</code>

<P>Returns the number of bytes contained in the receiver.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="406"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/subdataWithRange:">subdataWithRange:</a></h3>

- (NSData *)<code>subdataWithRange:</code>(NSRange)<em>range</em>

<P>Returns a data object containing a copy of the receiver's bytes that fall within the limits specified by <em>range</em>. If <em>range</em> isn't within the receiver's range of bytes, an NSRangeException is raised.<p>

For example, the following code excerpt initializes a data object, <em>data2</em>, to contain a sub-range of <em>data1</em>:<p>

<blockquote><pre>NSString *myString = @"ABCDEFG";  <br>NSRange range = {2, 4};<br>NSData *data1, *data2; <br>    <br>data1 = [NSData dataWithBytes:[myString cString]<br>        length:[myString cStringLength]];<br>    <br>data2 = [data1 subdataWithRange:range];

</pre></blockquote><p>The result of this excerpt is that <em>data2</em> contains "CDEF<code>".</code><p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="412"></a>

<h3> <a name="//apple_ref/occ/instm/NSData/writeToFile:atomically:">writeToFile:atomically:</a></h3>

- (BOOL)<code>writeToFile:</code>(NSString *)<em>path</em> <code>atomically:</code>(BOOL)<em>flag</em>

<P>Writes the bytes in the receiver to the file specified by <em>path</em>. If <em>flag</em> is YES, the data is written to a backup file and then, assuming no errors occur, the backup file is renamed to the specified file name. Otherwise, the data is written directly to the specified file.<p>

If <em>path</em> contains a tilde (~) character, you must expand it with <code>stringByExpandingTildeInPath:</code> before invoking this method.<p>

YES is returned if the operation succeeded, otherwise NO is returned.<p>

<hr><p>

<h1>

<img src="../clsclstr.gif">

<FONT COLOR="#000066">

<a name="417"><a name="//apple_ref/occ/cl/NSMutableData">NSMutableData</a>

</a>

</FONT>

</h1>

<p><B>Inherits From:</B><BR>  

NSData : NSObject



<p><B>Conforms To:</B><BR>

NSCoding<br>

NSCopying<br>

NSMutableCopying (NSData) <br>

NSObject (NSObject) 



<p><B>Declared In:	</B><BR>

Foundation/NSData.h<br>

Foundation/NSSerialization.h



<p><p>

<a name="421"></a>

<HR WIDTH="75%" SIZE="4" ALIGN="LEFT">

<H3>

<FONT COLOR="#201040">

Class At A Glance

</FONT>

</H3>

<dl><a name="422"></a>

<dt><h4>Purpose</h4>

<dd><dl>

<dt>An NSMutableData object stores mutable data in the form of bytes.

</dl></dd>

<a name="424"></a>

<dt><h4>Principal Attributes</h4>

</dl><ul><li>A count of the number of bytes in the mutable data object.<br>

<li>The sequence of bytes contained in the mutable data object.<br>

</ul><dl><a name="427"></a>

<dt><h4>Creation<p>

<Table Border="3">

<caption></caption>

<tr><td>+ dataWithCapacity:

</td><td>Returns an NSMutableData with enough allocated memory to hold a 

specified number of bytes.

</td></tr>

<tr><td scope="row">+ dataWithLength:

</td><td>Returns an NSMutableData that contains a specified number of 

zero-filled bytes.

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

</h4>

<a name="428"></a>

<dt><h4>Commonly Used Methods<p>

<Table Border="3">

<caption></caption>

<tr><td>- mutableBytes

</td><td>A pointer to the bytes in the NSMutableData object.

</td></tr>

<tr><td scope="row">- replaceBytesInRange:withBytes:

</td><td>Replaces a range of bytes in the NSMutableData object.

</td></tr>



</Table>



<Table>

<tr><td>

</Table>

</h4>

<a name="429"></a>

<dt><h4>Primitive Methods</h4>

<dd><dl>

<dt>- mutableBytes

<dt>- setLength:

</dl></dd>

</dl><HR WIDTH="75%" SIZE="4" ALIGN="LEFT">

<p><a name="433"></a>

<a name="description"></a>

<H2>Class Description

</H2>

The NSMutableData class declares the programmatic interface to an object that contains modifiable data in the form of bytes. NSMutableData's two primitive methods-<code>mutableBytes</code> and <code>setLength:</code>-provide the basis for all of the other methods in its interface. The <code>mutableBytes</code> method returns a pointer for writing into the bytes contained in the mutable data object. <code>setLength: </code>allows you to truncate or extend the length of a mutable data object. <p>

<code>increaseLengthBy:</code> also allows you to change the length of a mutable data object.<p>

The <code>appendBytes:length:</code> and <code>appendData:</code> methods let you append bytes or the contents of another data object to a mutable data object. You can replace a range of bytes in a mutable data object with zeros (using the <code>resetBytesInRange:</code> method), or with different bytes (using the <code>replaceBytesInRange:withBytes:</code> method). <p>

<a name="437">

<HR WIDTH="50%" ALIGN="LEFT">

<h2>Method Types

</h2>

</a><dl>

<dt>Creating an NSMutableData<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSMutableData/allocWithZone:">+ allocWithZone:</a><dt><a href="#//apple_ref/occ/clm/NSMutableData/dataWithCapacity:">+ dataWithCapacity:</a><dt><a href="#//apple_ref/occ/clm/NSMutableData/dataWithLength:">+ dataWithLength:</a><dt><a href="#//apple_ref/occ/instm/NSMutableData/initWithCapacity:">- initWithCapacity:</a><dt><a href="#//apple_ref/occ/instm/NSMutableData/initWithLength:">- initWithLength:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Adjusting capacity<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSMutableData/increaseLengthBy:">- increaseLengthBy:</a><dt><a href="#//apple_ref/occ/instm/NSMutableData/setLength:">- setLength: </a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Accessing data<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSMutableData/mutableBytes">- mutableBytes </a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Adding data<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSMutableData/appendBytes:length:">- appendBytes:length:</a><dt><a href="#//apple_ref/occ/instm/NSMutableData/appendData:">- appendData:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Serializing data<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSMutableData/serializeAlignedBytesLength:">- serializeAlignedBytesLength:</a><dt><a href="#//apple_ref/occ/instm/NSMutableData/serializeDataAt:ofObjCType:context:">- serializeDataAt:ofObjCType:context:</a><dt><a href="#//apple_ref/occ/instm/NSMutableData/serializeInt:">- serializeInt:</a><dt><a href="#//apple_ref/occ/instm/NSMutableData/serializeInt:atIndex:">- serializeInt:atIndex:</a><dt><a href="#//apple_ref/occ/instm/NSMutableData/serializeInts:count:">- serializeInts:count:</a><dt><a href="#//apple_ref/occ/instm/NSMutableData/serializeInts:count:atIndex:">- serializeInts:count:atIndex:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Modifying data<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSMutableData/replaceBytesInRange:withBytes:">- replaceBytesInRange:withBytes:</a><dt><a href="#//apple_ref/occ/instm/NSMutableData/resetBytesInRange:">- resetBytesInRange:</a><dt><a href="#//apple_ref/occ/instm/NSMutableData/setData:">- setData:</a></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<HR WIDTH="50%" ALIGN="LEFT">

<a name="463"></a>

<a name="clm"></a>

<h2>Class Methods</h2>  





<a name="464"></a>

<h3>

 <a name="//apple_ref/occ/clm/NSMutableData/allocWithZone:">allocWithZone:</a>

</h3>

+ (id)<code>allocWithZone:</code>(NSZone *)<em>zone</em>

<P>Creates and returns an uninitialized data object in the specified zone. If the receiver is the NSMutableData class object, an instance of an appropriate subclass is returned; otherwise, an object of the receiver's class is returned.<p>

Typically, you create objects using the <code>data...</code> class methods, not the <code>alloc...</code> and <code>init...</code> methods. Note that it's your responsibility to release objects created with the <code>alloc...</code> methods.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="468"></a>

<h3> <a name="//apple_ref/occ/clm/NSMutableData/dataWithCapacity:">dataWithCapacity:</a></h3>

+ (id)<code>dataWithCapacity:</code>(unsigned int)<em>aNumItems</em>

<P>Creates and returns an NSMutableData object, initially allocating enough memory to hold <em>aNumItems</em> objects. Mutable data objects allocate additional memory as needed, so <em>aNumItems</em> simply establishes the object's initial capacity.<p>

<B><dt>Note:	</B>

<code>dataWithCapacity:</code> doesn't necessarily allocate its memory at the time of method invocation. When 

it does allocate its memory, though, it initially allocates the specified amount.

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSMutableData/dataWithLength:">+ dataWithLength:</a></code>, <a href="#//apple_ref/occ/instm/NSMutableData/initWithCapacity:"><code>- initWithCapacity:</a></code>, <a href="#//apple_ref/occ/instm/NSMutableData/initWithLength:"><code>- initWithLength:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="473"></a>

<h3> <a name="//apple_ref/occ/clm/NSMutableData/dataWithLength:">dataWithLength:</a></h3>

+ (id)<code>dataWithLength:</code>(unsigned int)<em>length</em>

<P>Creates an autoreleased, mutable data object of <em>length</em> bytes, filled with zeros.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSMutableData/dataWithCapacity:">+ dataWithCapacity:</a></code>, <a href="#//apple_ref/occ/instm/NSMutableData/initWithCapacity:"><code>- initWithCapacity:</a></code>, <a href="#//apple_ref/occ/instm/NSMutableData/initWithLength:"><code>- initWithLength:</a>

</code><p><HR WIDTH="50%" ALIGN="LEFT">

<a name="instm"></a>

<h2>Instance Methods</h2>  





<a name="478"></a>

<h3>

 <a name="//apple_ref/occ/instm/NSMutableData/appendBytes:length:">appendBytes:length:</a>

</h3>

- (void)<code>appendBytes:</code>(const void *)<em>bytes</em> <code>length:</code>(unsigned int)<em>length</em>

<P>Appends <em>length </em>bytes to the receiver from the buffer <em>bytes</em>.<p>

This excerpt copies the bytes in <em>data2</em> into <em>aBuffer</em>, and then appends <em>aBuffer</em> to <em>data1</em>. <p>

<blockquote><pre>NSMutableData *data1, *data2;<br>NSString *firstString =  @"ABCD"; <br>NSString *secondString = @"EFGH"; <br>unsigned char *aBuffer;<br>unsigned len;<br>    <br>data1 = [NSMutableData dataWithBytes:[firstString cString]<br>        length:[firstString cStringLength]];<br>data2 = [NSMutableData dataWithBytes:[secondString cString]<br>        length:[secondString cStringLength]];<br>    <br>len = [data2 length];<br>aBuffer = malloc(len);<br>    <br>[data2 getBytes:aBuffer];<br>[data1 appendBytes:aBuffer length:len];

</pre></blockquote><p>The final value of <em>data1</em> is the series of ASCII characters "ABCDEFGH".<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSMutableData/appendData:">- appendData:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="485"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/appendData:">appendData:</a></h3>

- (void)<code>appendData:</code>(NSData *)<em>otherData</em>

<P>Appends the contents of a data object <em>otherData</em> to the receiver.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSMutableData/appendBytes:length:">- appendBytes:length:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="489"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/increaseLengthBy:">increaseLengthBy:</a></h3>

- (void)<code>increaseLengthBy:</code>(unsigned int)<em>extraLength</em>

<P>Increases the length of the receiver by <em>extraLength</em>. The additional bytes are all set to zero.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSMutableData/setLength:">- setLength:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="493"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/initWithCapacity:">initWithCapacity:</a></h3>

- (id)<code>initWithCapacity:</code>(unsigned int)<em>capacity</em>

<P>Initializes a newly allocated mutable data object, giving it enough memory to hold <em>capacity</em> bytes. Sets the length of the data object to 0. Returns <code>self</code>.<p>

<B>See also: </B>  

 <a href="#//apple_ref/occ/clm/NSMutableData/dataWithCapacity:"><code>+ dataWithCapacity:</a></code><code>, <a href="#//apple_ref/occ/instm/NSMutableData/initWithLength:"></code><code>- initWithLength:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="497"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/initWithLength:">initWithLength:</a></h3>

- (id)<code>initWithLength:</code>(unsigned int)<em>length</em>

<P>Initializes a newly allocated mutable data object, giving it enough memory to hold <em>length</em> bytes. Fills the object with zeros up to <em>length</em>. Returns <code>self</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSMutableData/dataWithCapacity:">+ dataWithCapacity:</a></code>, <a href="#//apple_ref/occ/clm/NSMutableData/dataWithLength:"><code>+ dataWithLength:</a></code>,<code> <a href="#//apple_ref/occ/instm/NSMutableData/initWithCapacity:"></code><code>- initWithCapacity:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="501"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/mutableBytes">mutableBytes</a></h3>

- (void *)<code>mutableBytes</code>

<P>Returns a pointer to the receiver's data.<p>

In the following code example, <code>mutableBytes</code> is used to return a pointer to the bytes in <em>data2</em>. The bytes in <em>data2</em> are then overwritten with the contents of <em>data1</em>.<p>

<blockquote><pre>NSMutableData *data1, *data2;<br>NSString *myString = @"string for data1"; <br>NSString *yourString = @"string for data2"; <br>unsigned char *firstBuffer, secondBuffer[20];<br><br>/* initialize data1, data2, and secondBuffer... */  <br>data1 = [NSMutableData dataWithBytes:[myString cString] <br>        length:[myString length]];<br>data2 = [NSMutableData dataWithBytes:[yourString cString]<br>        length:[yourString length]];<br>    <br>[data2 getBytes:secondBuffer];<br>NSLog(@"data2 before: \"%s\"\n", (char *)secondBuffer);<br>    <br>firstBuffer = [data2 mutableBytes];<br>[data1 getBytes:firstBuffer];<br>NSLog(@"data1: \"%s\"\n", (char *)firstBuffer);<br>    <br>[data2 getBytes:secondBuffer];<br>NSLog(@"data2 after: \"%s\"\n", (char *)secondBuffer);

</pre></blockquote><p>This is the output from the above code example:<p>

<blockquote><pre>Oct  3 15:59:51 [1113] data2 before: "string for data2"<br>Oct  3 15:59:51 [1113] data1: "string for data1"<br>Oct  3 15:59:51 [1113] data2 after: "string for data1"

</pre></blockquote><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="508"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/replaceBytesInRange:withBytes:">replaceBytesInRange:withBytes:</a></h3>

- (void)<code>replaceBytesInRange:</code>(NSRange)<em>range</em><code> withBytes:</code>(const void *)<em>bytes</em>

<P>Specifies a range within the contents of a mutable data object to be replaced by <em>bytes</em>. If the location of <em>range</em> isn't within the receiver's range of bytes, an NSRangeException is raised. The receiver is resized to accomodate the new bytes, if necessary.<p>

In the following code excerpt, a range of bytes in <em>data1</em> is replaced by the bytes in <em>data2</em>. <p>

<blockquote><pre>NSMutableData *data1, *data2;<br>NSString *myString = @"Liz and John"; <br>NSString *yourString = @"Larry"; <br>unsigned len;<br>unsigned char *aBuffer;<br>NSRange range = {8, [yourString cStringLength]};  <br>    <br>data1 = [NSMutableData dataWithBytes:[myString cString]<br>        length:[myString cStringLength]];<br>    <br>data2 = [NSMutableData dataWithBytes:[yourString cString]<br>        length:[yourString cStringLength]];<br>    <br>len = [data2 length];<br>aBuffer = malloc(len);<br>[data2 getBytes:aBuffer];<br>[data1 replaceBytesInRange:range withBytes:aBuffer];

</pre></blockquote><p>The contents of <em>data1</em> changes from "Liz and John" to "Liz and Larry."<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSMutableData/resetBytesInRange:">- resetBytesInRange:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="515"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/resetBytesInRange:">resetBytesInRange:</a></h3>

- (void)<code>resetBytesInRange:</code>(NSRange)<em>range</em>

<P>Specifies a range within the contents of a mutable data object to be replaced by zeros. If the location of <em>range</em> isn't within the receiver's range of bytes, an NSRangeException is raised. The receiver is resized to accomodate the new bytes, if necessary.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSMutableData/replaceBytesInRange:withBytes:">- replaceBytesInRange:withBytes:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="519"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/serializeAlignedBytesLength:">serializeAlignedBytesLength:</a></h3>

- (void)<code>serializeAlignedBytesLength:</code>(unsigned int)<em>length</em>

<P>Appends the bytes of <em>length</em> to the end of the receiver. This method may add extra filler bytes to increase the efficiency of deserializing subsequent data. Use of this method is optional; you can invoke <code>serializeInt:</code> instead. However, if you use this method, you should match its use by invoking <code>deserializeAlignedBytesLengthAtCursor:</code> to read the bytes of <em>length</em> later.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="522"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/serializeDataAt:ofObjCType:context:">serializeDataAt:ofObjCType:context:</a></h3>

- (void)<code>serializeDataAt:</code>(const void *)<em>data</em> <br><code>ofObjCType:</code>(const char *)<em>type</em> <br><code>context:</code>(id &lt;NSObjCTypeSerializationCallBack&gt;)<em>callback</em>

<P>Appends a sequence of bytes, specified by <em>data</em>, to the receiver. The bytes are formatted according to the Objective-C type code given in <em>type</em>. If <em>type</em> specifies an object, <em>callback</em> is used to serialize the object pointed to by <em>data</em>; in such a case, <em>callback</em> must itself be an object that conforms to the NSObjCTypeSerializationCallBack protocol. If <em>type</em> does not specify an object, <em>callback</em> can be <code>nil</code>.<p>

For informationon on creating an Objective-C type code suitable for <em>type</em>, see the description of the <code>@encode()</code> compiler directive in <em>Object-Oriented Programming and the Objective-C Language</em>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSData/deserializeDataAt:ofObjCType:atCursor:context:">- deserializeDataAt:ofObjCType:atCursor:context:</code> (NSData)</a>

<p><hr WIDTH="25%" ALIGN="LEFT">

<a name="527"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/serializeInt:">serializeInt:</a></h3>

- (void)<code>serializeInt:</code>(int)<em>value</em>

<P>Appends the bytes of <em>value</em> to the end of the receiver.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSMutableData/serializeAlignedBytesLength:">- serializeAlignedBytesLength:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="531"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/serializeInt:atIndex:">serializeInt:atIndex:</a></h3>

- (void)<code>serializeInt:</code>(int)<em>value</em> <code>atIndex:</code>(unsigned int)<em>index</em>

<P>Replaces the bytes of an integer at location <em>index</em> in the receiver with the bytes of <em>value</em>. <p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSMutableData/replaceBytesInRange:withBytes:">- replaceBytesInRange:withBytes:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="535"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/serializeInts:count:">serializeInts:count:</a></h3>

- (void)<code>serializeInts:</code>(int *)<em>intBuffer</em> <code>count:</code>(unsigned int)<em>numInts</em>

<P>Appends the bytes of <em>numInts</em> integers in <em>intBuffer</em> to the receiver.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSMutableData/serializeInt:">- serializeInt:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="539"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/serializeInts:count:atIndex:">serializeInts:count:atIndex:</a></h3>

- (void)<code>serializeInts:</code>(int *)<em>intBuffer</em> <br><code>count:</code>(unsigned int)<em>numInts</em> <br><code>atIndex:</code>(unsigned int)<em>index</em>

<P>Replaces the bytes of <em>numInts</em> integers currently in the receiver with <em>numInts</em> integers in <em>intBuffer</em>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSMutableData/replaceBytesInRange:withBytes:">- replaceBytesInRange:withBytes:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="543"></a>

<h3><a name="//apple_ref/occ/instm/NSMutableData/setData:">setData:</a></h3>

- (void)<code>setData:</code>(NSData *)<em>aData</em>

<P>Uses <code>replaceBytesInRange:withBytes:</code> to replace the entire contents of the receiver with the contents of <em>aData</em>.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="546"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableData/setLength:">setLength:</a></h3>

- (void)<code>setLength:</code>(unsigned int)<em>length</em>

<P>Extends or truncates a mutable data object to <em>length</em>. If the mutable data object is extended, the additional bytes are filled with zero.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSMutableData/increaseLengthBy:">- increaseLengthBy:</a>

</code><p>

 

 





<i>Copyright &#169; 1997, Apple Computer, Inc.   All rights

reserved.</i>



<!-- Last updated: 06/17/97 16:47:59 -->



</body>

</html>

