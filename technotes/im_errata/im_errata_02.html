<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"    "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd"><HTML><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note IMERRATA02: Inside Macintosh: Memory Errata</title><meta name="keywords" content="Macintosh OS 8 Inside Memory errata errors omissions Manager"><meta name="Description" content="Technical Note IMERRATA02: This Technical Note discussesknown errors and omissions in Inside Macintosh: Memory. Correctionsinclude: return value type of NewPtrCushion; Correction toNewPtr Description; Correction to HandToHand description;Calling conventions for PtrToHand, PtrToXHand, and PtrAndHand;Correction to DebuggerGetMax Description."><meta name="categories" content="Inside Macintosh Errata and Memory"><meta name="week-posted" content="Sep 28, 1998 - Oct 2, 1998"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><a name="//apple_ref/doc/uid/DTS10002522" title="Inside Macintosh: Memory Errata"></a><a name="top"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Carbon/index.html" target="_blank">Reference Library > Carbon</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note IMERRATA02</div>
<div id="pageheadsub">Inside Macintosh: Memory Errata</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext">	<A HREF="#Section1">Topics</a><BR><BR>	<A HREF="#Section2">About This Book</a><BR><BR>	<A HREF="#Section3">Chapter 1 - Introduction to Memory Management</a><BR><BR><A HREF="#Section4">Chapter 2 - Memory Manager</a><BR><BR><A HREF="#Section5">Chapter 3 - Virtual Memory Manager</a><BR><BR><A HREF="#Section6">Chapter 4 - Memory Management Utilities</a><BR><BR><a href="#References">References</a><BR><BR>                  <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext"> This Technote discusses known errors and omissions in <I>InsideMacintosh: Memory.</I></P><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Aug 01 1998]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name="Section1"></a><h2>Topics</h2><UL>   <LI><I>Inside Macintosh:Memory</I> doesn't apply to 64K ROM Macintoshes, August 1998</LI>      <LI><CODE>TickCount</CODE> vs. <CODE>Ticks</CODE>, August 1998</LI>      <LI>Correction to Description of Figure 1-7, October 1994</LI>      <LI>Correction to Documented Default Stack Sizes, October 1994</LI>      <LI>Addendum to Description of <CODE>SetApplLimit</CODE>, October 1994</LI>      <LI>Correction to Return Value Type, October 1994</LI>      <LI>Correction to <CODE>NewPtr</CODE> Description, October 1994</LI>      <LI>Correction to Temporary Memory Locking Requirements, August 1998</LI>      <LI>Correction to Listing for Checking for Temporary Memory Routines, October 1994</LI>      <LI>Clarification of <CODE>'sysz'</CODE> Resources and System Extensions, August 1998</LI>      <LI>Clarification of Block Alignment Boundaries, October 1994</LI>      <LI>Clarification of Block Header Diagrams, October 1994</LI>      <LI>Clarification of <CODE>PtrToHand</CODE> description, August 1998</LI>      <LI>Calling conventions for <CODE>PtrToHand</CODE>, <CODE>PtrToXHand</CODE>, and <CODE>PtrAndHand</CODE>, August 1998</LI>      <LI>Correction to <CODE>HandToHand</CODE> description, August 1998</LI>      <LI><CODE>HandAndHand</CODE> warning no longer needed, August 1998</LI>      <LI>Correction to <CODE>PtrAndHand</CODE> Assembly-Language Information, August 1998</LI>      <LI>Addendum to <CODE>StackSpace</CODE> Special Considerations, August 1998</LI>      <LI>Addendum to <CODE>MemError</CODE> Warning, August 1998</LI>      <LI>Addition to <CODE>MyGrowZone</CODE> and <CODE>MyPurgeProc</CODE> Special Considerations, August 1998</LI>      <LI>Correction to <CODE>LockMemoryContiguous</CODE> Description, October 1994</LI>      <LI>Correction to <CODE>DebuggerGetMax</CODE> Description, October 1994</LI>      <LI>Correction to <CODE>DebuggerLockMemory</CODE> Description, October 1994</LI>      <LI>Correction to <CODE>DebuggerUnlockMemory</CODE> Description, October 1994</LI>      <LI>Finding QuickDraw globals, August 1998</LI></UL><a name="Section2"></a> <P><A HREF="#top">Back to top</A></P><h2>About This Book</h2><P><B><I>Inside Macintosh:Memory</I> doesn't apply to 64K ROM Macintoshes</B></P><P>Page xi</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>This note should be added to the introduction:</P>                  <P>The intent of <I>Inside Macintosh:Memory</I> is to cover         all Macintosh models existing or foreseeable at time of         print, except for a few early models with the 64K ROMs,         which are no longer supported:</P>                  <UL>            <LI>The original Macintosh (64KB ROM, 128KB, or 512KB            RAM)</LI>                        <LI>Macintosh XL (Lisa hardware emulating an original            Macintosh)</LI>         </UL>                  <P><I>Inside Macintosh:Memory</I> does apply to the         Macintosh 512K enhanced (featuring the same 128K ROM as the         Macintosh Plus) and all Macintoshes at time of print,         including Performa, PowerBook, Power Macintosh, and Mac OS-compatible         PowerPC machines.</P>      </TD>   </TR></TABLE><a name="Section3"></a> <P><A HREF="#top">Back to top</A></P><h2>Chapter 1 - Introduction to Memory Management</h2><P><B><CODE>TickCount</CODE> vs. <CODE>Ticks</CODE></B></P><P>Pages 1-6 and 2-7</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>This is a bad example. A better example is         <CODE>MemError</CODE> vs. <CODE>MemErr</CODE>.</P>                  <P>The paragraph on page 1-6 should read:</P>                  <P>In general, it is best to avoid reading or writing         low-memory system global variables. Most of these variables         are undocumented, and the results of changing their values         can be unpredictable. Usually, when the value of a         low-memory global variable is likely to be useful to         applications, the system software provides a routine that         you can use to read or write that value. For example, you         can get the current value of the <CODE>MemErr</CODE> global         variable by calling the <CODE>MemError</CODE> function.</P>                  <P>The paragraph on page 2-7 should read:</P>                  <P>Even when <I>Inside Macintosh</I> does document a         particular system global variable, you should use any         available routines to access that variable's value instead         of examining it directly. For example, you should use the         <CODE>MemError</CODE> function to find the last error         returned by the Memory Manager instead of examining the         <CODE>MemErr</CODE> global variable directly.</P>      </TD>   </TR></TABLE><BR><P><B>Correction to Description of Figure 1-7</B></P><P>Page 1-14</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The description of Figure 1-7 is incorrect. The paragraph         immediately following Figure 1-7 should read: "In Figure         1-7, Application 2 has almost exhausted its application         heap. As a result, it has requested and received a large         block of temporary memory. Application 2 can use the         temporary memory in whatever manner it desires."</P>      </TD>   </TR></TABLE><BR><P><B>Correction to Documented Default Stack Sizes</B></P><P>Pages 1-39 through 1-40, Changing the Size of the Stack</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The documentation states that by default the stack can         grow to "32KB on computers with Color QuickDraw" (page         1-40). The actual default stack size on machines with Color         QuickDraw is 24KB. In addition, the default stack size for a         background-only application (or a "faceless background         process") is 2KB, not 8KB as claimed on page 1-40.</P>                  <P>However, the default stack size may change in the future         and should never be assumed.</P>      </TD>   </TR></TABLE><BR><P><B>Addendum to Description of <CODE>SetApplLimit</CODE></B></P><P>Pages 1-39, 1-52, and 2-84.</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The description of the <CODE>SetApplLimit</CODE> routine         should mention that <CODE>SetApplLimit</CODE> enforces a         minimum stack size equal to <CODE>DefltStack</CODE>. For         example, calling <CODE>SetApplLimit</CODE> on a         background-only application running on a Color QuickDraw         machine will result in a minimum stack size of 24KB,         regardless of the value passed to <CODE>SetApplLimit</CODE>.         The partition of the background-only application must be         large enough to accommodate a stack of that size.</P>      </TD>   </TR></TABLE><BR><P><B>Correction to Return Value Type</B></P><P>Page 1-45, Allocating Blocks of Memory</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The application-defined function         <CODE>NewPtrCushion</CODE> (defined in Listing 1-7) should         return a value of type <CODE>Ptr</CODE>, not of type         <CODE>Handle</CODE>.</P>      </TD>   </TR></TABLE><BR><P><B>Correction to <CODE>NewPtr</CODE> Description</B></P><P>Pages 1-58 through 1-59, and 2-36.</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The Assembly-Language Information for the         <CODE>NewPtr</CODE> function states that on entry register         <CODE>A0</CODE> contains the number of logical bytes         requested. In fact, register <CODE>D0</CODE> should contain         the number of logical bytes requested.</P>      </TD>   </TR></TABLE><BR><P><B>Addition to <CODE>SetCurrentA5</CODE> Description</B></P><P>Pages 1-79 and 1-81</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>There is a problem introduced with MultiFinder. It is         well documented in Technote <a href="../me/me_14.html">         ME14-The New Memory Manager and You</A>, under A5 World Problems and Heap Callback          Procedures (but the workaround suggested in this technote is unusable).</P>                  <P>The problem: when a heap is low on memory or a         <CODE>Handle</CODE> is going the be purged, the         <CODE>GrowZone</CODE> or <CODE>PurgeProc</CODE> function is         called without an <code>A5</code> world switch. This means that the         <CODE>GrowZone</CODE> or <CODE>PurgeProc</CODE> function is         called with <CODE>CurrentA5</CODE> set, according to the         <code>A5</code> world of the application that did the call          generating the low-memory or <CODE>Handle</CODE> purge condition,         rather than the value of <code>A5</code> for which the application the         <CODE>GrowZone</CODE> or <CODE>PurgeProc</CODE> function         belongs. As the Technote says, this "[will] cause all hell to         break loose". This may occur, for example, when the active         and frontmost application closes a window. The update region         of windows belonging to other applications need to be         updated, which often involves extending the update region         <CODE>Handle</CODE>, which can cause a <CODE>GrowZone</CODE>         procedure to be called, but since the window being updated         is in the background, the value of <code>A5</code> is wrong with respect         to the <CODE>GrowZone</CODE> or <CODE>PurgeProc</CODE> function.</P>                  <P>The safe workaround, which is needed only in 680x0 code,         involves saving <code>A5</code> explicitly, and recovering it using         PC-relative addressing. Going forward to Mac OS X and Carbon,         <CODE>GrowZone</CODE> and <CODE>PurgeProc</CODE> functions         will not be needed, so this problem will gradually go         away.</P>      </TD>   </TR></TABLE><a name="Section4"></a> <P><A HREF="#top">Back to top</A></P><h2>Chapter 2 - Memory Manager</h2><P><B>Correction to Temporary Memory Locking Requirement</B></P><P>Page 2-10, Extending an Application's Memory</P><P>The phrase:</P><TABLE WIDTH=500>   <TR>      <td align="left">         <BLOCKQUOTE>[...] you must never lock temporary            memory across calls to <CODE>GetNextEvent</CODE> or            <CODE>WaitNextEvent</CODE> [...]</BLOCKQUOTE>      </TD>   </TR></TABLE><BR><P>should read:</P><TABLE WIDTH=500>   <TR>      <td align="left">         <BLOCKQUOTE>[...] you should avoid locking temporary            memory across calls to <CODE>GetNextEvent</CODE> or            <CODE>WaitNextEvent</CODE> [...]</BLOCKQUOTE>      </TD>   </TR></TABLE><BR><P>See <a href="../../qa/me/me08.html">Q&amp;A ME08-Temporary Memory</A> for details.</P><P><B>Correction to Listing for Checking for Temporary Memory Routines</B></P><P>Page 2-12</P><P>Listing 2-3 on page 2-12 contains an error. The line:</P><TABLE WIDTH=500>   <TR>      <td align="left">         <pre>TempMemCallsAvailable := BAND(myRsp, gestaltTempMemSupport) &lt;&gt; 0;</pre>      </TD>   </TR></TABLE><BR><P>should be replaced by the line:</P><TABLE WIDTH=500>   <TR>      <td align="left">         <pre>TempMemCallsAvailable := BTst(myRsp, gestaltTempMemSupport);</pre>      </TD>   </TR></TABLE><BR><P><B>Clarification of <CODE>'sysz'</CODE> Resources and System Extensions</B></P><P>Page 2-13, Allocating Memory at Startup Time</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The documentation implies (page 2-13) that system         extensions running under System 7.0 and later do not need to         have '<CODE>sysz'</CODE> resources to indicate their system         heap memory requirements. This statement is misleading.         <CODE>'sysz'</CODE> resources are effective on all versions         of system software.</P>      </TD>   </TR>   <TR>      <td align="left">         <P>Furthermore, the generic term "system extension" is         ambiguous in this context. Many items in the Extensions         folder, such as components and native drivers         (<CODE>'ndrv'</CODE>s), are labeled as "system extensions"         by the Finder. However, <CODE>'sysz'</CODE> resources are         only applicable to files that may contain         <CODE>'INIT'</CODE> resources. This includes control panels,         system extensions of file type <CODE>'INIT'</CODE>, and         application extensions with an <CODE>'INIT'</CODE> resource.         [Radar ID 1245268]</P>      </TD>   </TR>   <TR>      <td align="left">         <P>Before executing an <CODE>'INIT'</CODE> resource from a         file, the Start Manager first checks to see whether the         system heap has <I>X</I> bytes of free space, where <I>X</I>         is the maximum of 16KB or the value in the file's         <CODE>'sysz'</CODE> resource. If less than <I>X</I> bytes of         free space is available, the Start Manager grows the system         heap such that <I>X</I> bytes are available for the         <CODE>'INIT'</CODE>s use.</P>      </TD>   </TR>   <TR>      <td align="left">         <P>Note that in System 7.0 and later, the system heap can         grow after the startup process has completed. The         <CODE>'sysz'</CODE> resource only controls the system heap         expansion at startup time.</P>      </TD>   </TR></TABLE><BR><P><B>Clarification of Block Alignment Boundaries</B></P><P>Page 2-22, Block Headers</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The documentation states that "on computers containing         the MC68020, MC68030, or MC68040 microprocessors, blocks are         padded to 4-byte boundaries." This is incorrect for 68040         and PowerPC machines, where blocks are always aligned on         16-byte boundaries.</P>                  <P>Starting with Mac OS 7.5, all memory blocks, regardless of         the runtime CPU, are aligned to 16-byte boundaries.</P>      </TD>   </TR></TABLE><BR><P><B>Clarification of Block Header Diagrams</B></P><P>Pages 2-22 through 2-23, Block Headers</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>Figures 2-1 (page 2-22) and 2-2 (page 2-23) might be         misleading. Remember that <I>Inside Macintosh</I> typically         draws memory diagrams with the low-memory addresses nearest         to the bottom of the diagram. (Compare Figure 1-1 on page         1-5, where the low-memory end of the diagram is explicitly         labeled.) The long word containing the block type and size         correction is the first long word in the 24-bit zone header. Similarly, the long word containing the block type         and unused space is the first long word in the 32-bit zone         header.</P>      </TD>   </TR>   <TR>      <td align="left">         <P>Figure 2-2 (page 2-23) claims that a block type of "11"         signifies a relocatable block. This is incorrect. The         correct type indicator for a relocatable block is "10".</P>      </TD>   </TR></TABLE><BR><P><B>Clarification to <CODE>PtrToHand</CODE> Description</B></P><P>Page 2-61</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The <CODE>dstHndl</CODE> parameter is not an input         parameter; therefore, the statement "The         <CODE>dstHndl</CODE> parameter must be a handle variable         that is not empty and is not a handle to an allocated block         of size 0" is misleading in that it implies that you may         have to allocate the handle yourself. This is not the case.         <CODE>PtrToHand</CODE> will allocate a handle of the         requested size and return it to you in the         <CODE>dstHndl</CODE> parameter. If no error occurs, on exit         <CODE>dstHndl</CODE> is an unlocked, non-purgeable         <CODE>Handle</CODE> of the requested size, allocated from         the current heap zone.</P>      </TD>   </TR></TABLE><BR><P><B>Correction to <CODE>HandToHand</CODE> description</B></P><P>Page 2-63</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The statement:</P>                  <BLOCKQUOTE>"The new relocatable block is created in the            same heap zone as the original block (which might not be            the current heap zone)."</BLOCKQUOTE>                  <P>is incorrect.</P>                  <P>The correct description is that the new relocatable block         is created in the current heap zone, regardless of the zone         of the original relocatable block. During         <CODE>HandToHand</CODE>, the original <CODE>Handle</CODE> is made         non-purgeable while the new one is allocated. The original         <CODE>Handle</CODE> is then returned to its original state. It is safe         to call <CODE>HandToHand</CODE> on purgeable handles, but not         on a purged handle.</P>      </TD>   </TR></TABLE><BR><P><B><CODE>HandAndHand</CODE> warning no longer needed</B></P><P>Page 2-64</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The warning is no longer needed and only applied to Macs         which use the original 64K ROMs.</P>                  <P>It is safe to call <CODE>HandAndHand</CODE> on purgeable         handles, but not on handles that have been purged.</P>      </TD>   </TR></TABLE><BR><P><B>Correction to <CODE>PtrAndHand</CODE> Assembly-Language Information</B></P><P>Page 2-65</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The description for A1's value should read "Handle to         relocatable block to which the data will be appended."</P>                  <P>size, the "Number of bytes to append", is passed in <CODE>D0</CODE>,         not <CODE>A2</CODE>.</P>      </TD>   </TR></TABLE><BR><P><B>Calling conventions for <CODE>PtrToHand</CODE>, <CODE>PtrToXHand</CODE>, and <CODE>PtrAndHand</CODE></B></P><P>Page 2-66</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>Before Assessing Memory Conditions, there should be this         note:</P>                  <P>In the description of <CODE>PtrToHand</CODE>,         <CODE>PtrToXHand</CODE>, and <CODE>PtrAndHand</CODE>,         <CODE>Ptr</CODE> or "pointer" refers to a memory address,         not necessarily to a Memory Manager <CODE>Ptr</CODE> as         returned by <CODE>NewPtr</CODE>. <CODE>Handle</CODE> does         refer to a Memory Manager <CODE>Handle</CODE>, allocated by         routines such as <CODE>NewHandle</CODE> or         <CODE>NewEmptyHandle</CODE>.</P>      </TD>   </TR></TABLE><BR><P><B>Addendum to <CODE>StackSpace</CODE> Special Considerations</B></P><P>Page 2-70</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>You should not call <CODE>StackSpace</CODE> at interrupt         time, because it sets the value returned by         <CODE>MemError</CODE> and therefore may cause the         interrupted application to fail.</P>      </TD>   </TR></TABLE><BR><P><B>Addendum to <CODE>MemError</CODE> Warning</B></P><P>Page 2-70</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>In 680x0 code, calling a function in an unloaded segment         will zero <CODE>MemErr</CODE> when the segment loader loads         the segment into memory, causing <CODE>MemError</CODE> to         return <CODE>noErr</CODE>. Therefore, you should always call         <CODE>MemError</CODE> right after the Memory Manager         function that may have caused an error.</P>      </TD>   </TR></TABLE><BR><P><B>Addition to <CODE>MyGrowZone</CODE> and <CODE>MyPurgeProc</CODE> Special Considerations</B></P><P>Page 2-90 and 2-91</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>There is a problem introduced with MultiFinder. It is well documented in          Technote <a href="../me/me_14.html"> ME14-The New Memory          Manager and You</A>, under <code>A5</code> World  Problems and Heap Callback          Procedures (but the workaround suggested in this technote is unusable).</P>                  <P>The problem: when a heap is low on memory or a         <CODE>Handle</CODE> is going the be purged, the         <CODE>GrowZone</CODE> or <CODE>PurgeProc</CODE> function is         called without an <code>A5</code> world switch. This means that the         <CODE>GrowZone</CODE> or <CODE>PurgeProc</CODE> function is         called with <CODE>CurrentA5</CODE> set according to the <code>A5</code>         world of the application that did the call generating the         low-memory or <CODE>Handle</CODE> purge condition, rather         than the value of <code>A5</code> for which the application the         <CODE>GrowZone</CODE> or <CODE>PurgeProc</CODE> function         belongs. As the Technote says, this "[will] cause all hell to         break loose". This may occur, for example, when the active         and frontmost application closes a window. The update region         of windows belonging to other applications need to be         updated, which often involves extending the update region         <CODE>Handle</CODE>, which can cause a <CODE>GrowZone</CODE>         procedure to be called, but since the window being updated         is in the background, the value of <code>A5</code> is wrong with         respect to the <CODE>GrowZone</CODE> or <CODE>PurgeProc</CODE>         function.</P>                  <P>The safe workaround, which is needed only in 680x0 code,         involves saving <code>A5</code> explicitly, and recovering it using         PC-relative addressing. Going forward to Mac OS X and Carbon,          <CODE>GrowZone</CODE> and <CODE>PurgeProc</CODE> functions         will not be needed, so this problem will gradually go         away.</P>      </TD>   </TR></TABLE><BR><a name="Section5"></a> <P><A HREF="#top">Back to top</A></P><h2>Chapter 3 - Virtual Memory Manager</h2><P><B>Correction to <CODE>LockMemoryContiguous</CODE> Description</B></P><P>Pages 3-29 through 3-30</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The Assembly-Language Information for the         <CODE>LockMemoryContiguous</CODE> function states that on         entry register <CODE>A1</CODE> contains the "number of bytes         to unlock." In fact, register <CODE>A1</CODE> contains the         number of bytes to lock.</P>      </TD>   </TR></TABLE><BR><P><B>Correction to <CODE>DebuggerGetMax</CODE> Description</B></P><P>Page 3-34</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The description of <CODE>DebuggerGetMax</CODE> states         (page 3-34): "Of course, you should use the         <CODE>Gestalt</CODE> function to check whether virtual         memory is available at all before you call the         <CODE>DebuggerGetMax</CODE> function." To see if virtual         memory is available from a debugger, it is preferable to         check to see whether the <CODE>_DebugUtil</CODE> trap is         available rather than call <CODE>Gestalt</CODE>.</P>      </TD>   </TR></TABLE><BR><P><B>Correction to <CODE>DebuggerLockMemory</CODE> Description</B></P><P>Page 3-37</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The Assembly-Language Information for the         <CODE>DebuggerLockMemory</CODE> function (page 3-37) lists         the trap macro as <CODE>_DebuggerLockMemory</CODE>. The         correct trap macro should be <CODE>_DebugUtil</CODE>.         Furthermore, the Assembly-Language Information for the         <CODE>DebuggerLockMemory</CODE> function states that on         entry register <CODE>A1</CODE> contains the "number of bytes         to hold." In fact, register <CODE>A1</CODE> contains the         number of bytes to lock.</P>      </TD>   </TR></TABLE><BR><P><B>Correction to <CODE>DebuggerUnlockMemory</CODE> Description</B></P><P>Page 3-38</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The Assembly-Language Information for the         <CODE>DebuggerUnlockMemory</CODE> function (page 3-38)         states that on entry register <CODE>A1</CODE> contains the         "number of bytes to hold." In fact, register <CODE>A1</CODE>         contains the number of bytes to unlock.</P>      </TD>   </TR></TABLE><BR><a name="Section6"></a> <P><A HREF="#top">Back to top</A></P><h2>Chapter 4 - Memory Management Utilities</h2><P><B>Finding QuickDraw globals</B></P><P>Page 4-18</P><TABLE WIDTH=500>   <TR>      <td align="left">         <P>The sentence:</P>                  <P>"However, the <CODE>A5</CODE> register always points to         the last of these global variables,         <CODE>thePort</CODE>."</P>                  <P>should read:</P>                  <P>"However, the <CODE>A5</CODE> register always contains the         address of a pointer to the last of these global variables,         <CODE>thePort</CODE>."</P>      </TD>   </TR></TABLE><BR><a name="References"></a> <P><A HREF="#top">Back to top</A></P><h2>References</h2><P><a href="../../documentation/mac/Memory/Memory-2.html">Inside Macintosh: Memory</A></p>         <P><A HREF="#top">Back to top</A></P>                  <P><A NAME=Downloads></A></P>                  <h2>Downloadables</h2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (56K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/im_errata_02.pdf">Download</A></P>               </TD>            </TR>                     </TABLE>         <BR>                  <P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/im_errata/im_errata_02.html%3Fid%3DDTS10002522-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/im_errata/im_errata_02.html%3Fid%3DDTS10002522-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/im_errata/im_errata_02.html%3Fid%3DDTS10002522-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>