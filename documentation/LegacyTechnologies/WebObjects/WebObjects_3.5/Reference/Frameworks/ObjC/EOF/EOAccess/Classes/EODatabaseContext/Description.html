<html><head><title></title></head>

<body bgcolor="#ffffff">

 

 

<h2><a name="//apple_ref/occ/cl/EODatabaseContext">EODatabaseContext</a>

 <BR>

</h2>

<p><B>Inherits From:</B><BR>  

EOCooperatingObjectStore : EOObjectStore : NSObject



<p><B>Conforms To:</B>

NSObject (NSObject)



<p><B>Declared in:</B>

EOAccess/EODatabaseContext.h 



<p><a name="776">

<a name="description"></a>

<h3>Class Description  </h3>

</a>EODatabaseContext is an EOObjectStore for relational databases, creating and saving objects based on EOEntity definitions in an EOModel. <p>

An EODatabaseContext represents a single connection to a database server, and it determines the updating and locking strategy used by its EODatabaseChannel objects. An EODatabaseContext has a corresponding EODatabase object. If the server supports multiple concurrent transactions, the EODatabase object may have several EODatabaseContexts. If the server and adaptor support it, an EODatabaseContext may in turn have several EODatabaseChannels, which handle access to the data on the server. <p>

The relationship between EODatabaseContext and other classes in the control and access layers is illustrated in the following diagram.<p>

<img src="../EODatabaseContext.gif"><p>

As a subclass of EOCooperatingObjectStore, EODatabaseContext acts as one of possibly several EOCooperatingObjectStores for an EOObjectStoreCoordinator, which mediates between EOEditingContexts and EOCooperatingObjectStores. <p>

An EODatabaseContext creates an EOAdaptorContext when initialized, and uses this object to communicate with the database server.<p>

<a name="783">

<h3> Creating and Using an EODatabaseContext</h3>

</a>Though you can create an EODatabaseContext explicitly by using the method <code>registeredDatabaseContextForModel:editingContext:</code>, you should rarely need to do so. When you create an EODatabaseDataSource, it registers an EODatabaseContext that's capable of fetching objects for the data source's entities. If objects fetched into an EOEditingContext (described more in the following section) have references to objects from EOModels that are based on another database, the EODatabaseContext creates and registers an EODatabaseContext for each of the additional databases.<p>

EODatabaseContexts are created on demand when an EOObjectStoreCoordinator posts an EOCooperatingObjectStoreNeeded notification. The EODatabaseContext class registers for the notification, and it provides the EOObjectStoreCoordinator with a new EODatabaseContext instance that can handle the request. For more discussion of this topic, see the chapter "Application Configurations" in the <em>Enterprise Objects Framework Developer's Guide</em>.<p>

For the most part, you don't need to programmatically interact with an EODatabaseContext. However, some of the reasons you might want to are as follows:<p>

<ul><li>To implement your own locking strategy, either application-wide, or on a per-fetch basis. This is described in the section "<a href="#819">Updating And Locking Strategies</a>."<p><li>To do performance tuning. This is described in the section "<a href="#799">Faulting</a>."<p><li>To intervene when objects are created and fetched to provide custom behavior. This is described in the section "<a href="#810">Delegate Methods</a>," and in the individual delegate method descriptions.<p></ul><a name="790">

<h3> Fetching and Saving Objects</h3>

</a>Conceptually, an EODatabaseContext fetches and saves objects on behalf of an EOEditingContext. However, the two objects don't interact with each other directly-an EOObjectStoreCoordinator acts as a mediator between them. The relationship between EOEditingContext, EOObjectStoreCoordinator, and EODatabaseContext is illustrated in the following figure. This configuration includes one EOObjectStoreCoordinator, and can include one or more EOEditingContexts, and one or more EODatabaseContexts.<p>

<img src="../EODatabaseContext1.gif"><p>

When an EOEditingContext fetches objects, the request is passed through the EOObjectStoreCoordinator, which forwards it to the appropriate EODatabaseContext based on the fetch specification or global ID. When the EODatabaseContext receives a request to fetch or write information to the database, it tries to use one of its EODatabaseChannels. If all of its channels are busy, it broadcasts an EODatabaseChannelNeededNotification in the hopes that an observer can provide a new channel or that an existing channel can be freed up. This observer could be a manager that decides how many database cursors can be opened by a particular client.<p>

EODatabaseContext knows how to interact with other EOCooperatingObjectStores to save changes made to an object graph in more than one database server. For a more detailed discussion of this subject, see the class specifications for EOObjectStoreCoordinator and EOCooperatingObjectStore.<p>

<a name="795">

<h3> Setting a Fetch Limit</h3>

</a>EODatabaseContext defines a hint for use with an EOFetchSpecification in the <code>objectsWithFetchSpecification:editingContext:</code> method. Named by the key EOFetchLimitHintKey, the hint's value is an NSNumber containing an unsigned integer value indicating the maximum number of objects to fetch. Depending on the value of the EOPromptAfterFetchLimitHintKey (YES or NO), the EODatabaseContext will either stop fetching objects when this limit is reached or it will ask the EOEditingContext's message handler to ask the user whether it should continue fetching.<p>

<a name="797">

<h3> Using a Custom Query</h3>

</a>EODatabaseContext defines a hint for use with an EOFetchSpecification in the <code>objectsWithFetchSpecification:editingContext:</code> method. Named by the key EOCustomQueryExpressionHintKey, the hint's value is a SQL string for performing the fetch. The expression must query the same attributes in the same order that Enterprise Objects Framework would if it were generating the SELECT expression dynamically. If this key is supplied, other characteristics of the EOFetchSpecification such as isDeep, qualifier, and sortOrderings are ignored-in that sense this key is more of a directive than a hint.<p>

<a name="799">

<h3> Faulting</h3>

</a>When an EODatabaseContext fetches an object, it examines the relationships defined in the model and creates objects representing the destinations of the fetched object's relationships. For example, if you fetch an employee object, you can ask for its manager and immediately receive an object; you don't have to get the manager's employee ID from the object you just fetched and fetch the manager yourself.<p>

EODatabaseContext doesn't immediately fetch data for the destination objects of relationships, however, since fetching is fairly expensive. To avoid this waste of time and resources, the destination objects of the class EOFault are created as placeholders. EOFaults come in two varieties: single object faults for to-one relationships, and array faults for to-many relationships.<p>

When an EOFault is accessed (sent a message), it triggers its EODatabaseContext to fetch its data and transform it into an instance of the appropriate object class. This preserves both the object's <B>id </B> and its EOGlobalID.<p>

You can fine-tune faulting behavior for additional performance gains by using two different mechanisms: batch faulting, and prefetching relationships.<p>

<a name="804">

<h4> Batch Faulting</h4>

</a>When you access an EOFault, its data is fetched from the database. However, triggering one fault has no effect on other faults-it just fetches the object or array of objects for the one fault. You can take advantage of this expensive round trip to the database server by batching faults together. EODatabaseContext provides the <code>batchFetchRelationship:forSourceObjects:editingContext:</code> method for doing this. For example, given an array of Employee objects, this method can fetch all of their departments with one round trip to the server, rather than asking the server for each of the employee's departments individually. You can use the delegate methods <a href="#1058"><B>databaseContext:shouldFetchArrayFault: </B></a> and <a href="#1062"><B>databaseContext:shouldFetchObjectFault: </B></a> to fine-tune batch faulting behavior.<p>

You can also set batch faulting in an EOModel. In that approach, you specify the <em>number</em> of faults that should be triggered along with the first fault; you don't actually control which faults are triggered the way you do with <code>batchFetchRelationship:forSourceObjects:editingContext:</code>. For more information on setting batch faulting in an EOModel, see the chapter "Using EOModeler" in the <em>Enterprise Objects Framework Developer's Guide</em>.<p>

<a name="807">

<h4> Prefetching Relationships</h4>

</a>EODatabaseContext defines a hint for use with an EOFetchSpecification in the <code>objectsWithFetchSpecification:editingContext:</code> method. Named by the key EOPrefetchingRelationshipHintKey, the hint's value is an NSArray of relationship paths whose destinations should be fetched along with the objects specified. For example, when fetching Movies, you can provide a prefetching hint for "directors", "roles.talent", and "plotSummary" to force these objects to be fetched as well, as opposed to having faults created for them. Although prefetching increases the initial fetch cost, it can improve overall performance by reducing the number of round trips made to the database server.<p>

Using this key also has an effect on how an EOFetchSpecification refreshes. "Refreshing" refers to existing objects being overwritten with fetched values-this allows your application to see changes to the database that have been made by someone else. Normally, when you set an EOFetchSpecification to refresh using <code>setRefreshesRefetchedObjects:</code>, it only refreshes the objects you're fetching. For example, if you fetch employees, you don't also fetch the employees' departments. However, if you have the EOPrefetchingRelationshipHintKey set, the refetch is propagated for all of the relationships specified for the hint.<p>

<a name="810">

<h3> Delegate Methods</h3>

</a>An EODatabaseContext shares its delegate with its EODatabaseChannel. These delegate methods are actually sent from EODatabaseChannel, but they're defined in EODatabaseContext for ease of access:<p>

<dl><dt><a href="#//apple_ref/occ/instm/NSObject/databaseContext:didSelectObjectsWithFetchSpecification:databaseChannel:"><a href="#1049">- databaseContext:didSelectObjectsWithFetchSpecification:databaseChannel:</a></a>

<dt><a href="#//apple_ref/occ/instm/NSObject/databaseContext:shouldSelectObjectsWithFetchSpecification:databaseChannel:"><a href="#1078">- databaseContext:shouldSelectObjectsWithFetchSpecification:databaseChannel:</a></a>

<dt><a href="#//apple_ref/occ/instm/NSObject/databaseContext:shouldUpdateCurrentSnapshot:newSnapshot:globalID:channel:"><a href="#1081">- databaseContext:shouldUpdateCurrentSnapshot:newSnapshot:globalID:channel:</a></a>

<dt><a href="#//apple_ref/occ/instm/NSObject/databaseContext:shouldUsePessimisticLockWithFetchSpecification:databaseChannel:"><a href="#1084">- databaseContext:shouldUsePessimisticLockWithFetchSpecification: databaseChannel:</a></a>

</dl>You can use the EODatabaseContext methods to intervene when objects are created and when they're fetched from the database. This gives you more fine-grained control over such issues as how an object's primary key is generated (<code>databaseContext:newPrimaryKeyForObject:entity:</code>), how and if objects are locked (<code>databaseContext:shouldLockObjectWithGlobalID:snapshot:</code>), what fetch specification is used to fetch objects (<code>databaseContext:shouldSelectObjectsWithFetchSpecification:databaseChannel:</code>), how batch faulting is performed (<a href="#1058"><B>databaseContext:shouldFetchArrayFault: </B></a> and <a href="#1062"><B>databaseContext:shouldFetchObjectFault: </B></a>), and so on. For more information, see the individual delegate method descriptions.<p>

<a name="817">

<h3> Snapshots</h3>

</a>An EODatabase records snapshots for its EODatabaseContexts. These snapshots form the application's view of the current state of the database server. This global view is overridden locally by EODatabaseContexts, which form their own snapshots as they make changes during a transaction. When an EODatabaseContext commits its top-level transaction, it reconciles all changed snapshots with the global view of the database object, so that other EODatabaseContexts (except those with open transactions) immediately use the new snapshots as well.<p>

<a name="819">

<h3> Updating And Locking Strategies</h3>

</a>EODatabaseContext supports two updating strategies defined by the <B>EOUpdateStrategy </B> type: <B>EOUpdateWithOptimisticLocking </B>, and <B>EOUpdateWithPessimisticLocking </B>.<p>

<B>EOUpdateWithOptimisticLocking </B> is the default update strategy. Under optimistic locking, objects aren't locked immediately on being fetched from the server. Instead, whenever you attempt to save updates to an object in the database, the object's snapshot is used to ensure that the values in the corresponding database row haven't changed since the object was fetched. As long as the snapshot matches the values in the database, the update is allowed to proceed. <p>

The <B>EOUpdateWithPessimisticLocking </B> strategy causes objects to be locked in the database when they're selected. This ensures that no one else can modify the objects until the transaction ends. However, this doesn't necessarily mean that either the select or the update operation will succeed.<p>

EODatabaseContext also supports "on-demand" locking, in which specific optimistic locks can be promoted to database locks during the course of program execution. You can either use <code>lockObjectWithGlobalID:editingContext:</code> to lock a database row for a particular object, or <code>objectsWithFetchSpecification:editingContext:</code> to fetch objects with a fetch specification that includes locking. <p>

For more discussion of locking strategies, see the chapter "Behind the Scenes" in the <em>Enterprise Objects Framework Developer's Guide</em>.<p>

 <p>

<dl><dt>Initializing instances

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/initWithDatabase:"><a href="#928">- initWithDatabase:</a></a>

</dl><dt>Fetching objects

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/objectsWithFetchSpecification:editingContext:"><a href="#956">- objectsWithFetchSpecification:editingContext:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/objectsForSourceGlobalID:relationshipName:editingContext:"><a href="#953">- objectsForSourceGlobalID:relationshipName:editingContext:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/arrayFaultWithSourceGlobalID:relationshipName:editingContext:"><a href="#880">- arrayFaultWithSourceGlobalID:relationshipName:editingContext:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/faultForGlobalID:editingContext:">- faultForGlobalID:editingContext:</a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/batchFetchRelationship:forSourceObjects:editingContext:"><a href="#888">- batchFetchRelationship:forSourceObjects:editingContext:</a></a>

</dl><dt>Getting the adaptor context

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/adaptorContext"><a href="#877">- adaptorContext</a></a>

</dl><dt>Getting the database object

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/database"><a href="#898">- database</a></a>

</dl><dt>Getting the coordinator

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/coordinator"><a href="#895">- coordinator</a></a>

</dl><dt>Managing channels

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/availableChannel"><a href="#884">- availableChannel</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/registerChannel:"><a href="#1003">- registerChannel:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/registeredChannels"><a href="#1007">- registeredChannels</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/unregisterChannel:"><a href="#1126">- unregisterChannel:</a></a>

</dl><dt>Setting the delegate

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/setDelegate:"><a href="#1022">- setDelegate:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/delegate"><a href="#901">- delegate</a></a>

</dl><dt>Committing or discarding changes

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/invalidateAllObjects"><a href="#931">- invalidateAllObjects</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/invalidateObjectsWithGlobalIDs:"><a href="#934">- invalidateObjectsWithGlobalIDs:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/rollbackChanges"><a href="#1015">- rollbackChanges</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/saveChangesInEditingContext:">- saveChangesInEditingContext:</a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/commitChanges"><a href="#891">- commitChanges</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/performChanges"><a href="#971">- performChanges</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/prepareForSaveWithCoordinator:editingContext:"><a href="#983">- prepareForSaveWithCoordinator:editingContext:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/recordUpdateForObject:changes:"><a href="#1135">- recordUpdateForObject:changes:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/recordChangesInEditingContext"><a href="#986">- recordChangesInEditingContext</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/refaultObject:withGlobalID:editingContext:"><a href="#1000">- refaultObject:withGlobalID:editingContext:</a></a>

</dl><dt>Determining if the EODatabaseContext is responsible for a particular operation

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/ownsObject:"><a href="#967">- ownsObject:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/ownsGlobalID:"><a href="#963">- ownsGlobalID:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/handlesFetchSpecification:"><a href="#925">- handlesFetchSpecification:</a></a>

</dl><dt>Managing Snapshots

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetSnapshotForGlobalID:"><a href="#917">- forgetSnapshotForGlobalID:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetSnapshotsForGlobalIDs:"><a href="#921">- forgetSnapshotsForGlobalIDs:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/localSnapshotForGlobalID:"><a href="#945">- localSnapshotForGlobalID:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshot:forGlobalID:"><a href="#989">- recordSnapshot:forGlobalID:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshots:"><a href="#1122">- recordSnapshots:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/snapshotForGlobalID:"><a href="#1030">- snapshotForGlobalID:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshot:forSourceGlobalID:relationshipName:"><a href="#1130">- recordSnapshot:forSourceGlobalID:relationshipName:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/snapshotForSourceGlobalID:relationshipName:"><a href="#1132">- snapshotForSourceGlobalID:relationshipName:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/localSnapshotForSourceGlobalID:relationshipName:"><a href="#1136">- localSnapshotForSourceGlobalID:relationshipName:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/recordToManySnapshots:"><a href="#1140">- recordToManySnapshots:</a></a>

</dl><dt>Initializing objects

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/initializeObject:withGlobalID:editingContext:"><a href="#1109">- initializeObject:withGlobalID:editingContext:</a></a>

</dl><dt>Obtaining an EODatabaseContext

<dl><dt><a href="#//apple_ref/occ/clm/EODatabaseContext/contextClassToRegister">+ (Class)contextClassToRegister</a>

</dl><dt>Locking objects

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/setUpdateStrategy:"><a href="#1026">- setUpdateStrategy:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/updateStrategy"><a href="#1038">- updateStrategy</a>   </a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/registerLockedObjectWithGlobalID:"><a href="#1011">- registerLockedObjectWithGlobalID:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:"><a href="#937">- isObjectLockedWithGlobalID:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:editingContext:"><a href="#941">- isObjectLockedWithGlobalID:editingContext:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetAllLocks"><a href="#909">- forgetAllLocks</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetLocksForObjectsWithGlobalIDs:"><a href="#913">- forgetLocksForObjectsWithGlobalIDs:</a></a>

<dt><a href="#//apple_ref/occ/instm/EODatabaseContext/lockObjectWithGlobalID:editingContext:"><a href="#1133">- lockObjectWithGlobalID:editingContext:</a></a>

</dl><dt>Returning information about objects

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/valuesForKeys:object:"><a href="#1042">- valuesForKeys:object:</a></a>

</dl><dt>Setting the context class

<dl><dt><a href="#//apple_ref/occ/clm/EODatabaseContext/contextClassToRegister"><a href="#873">+ contextClassToRegister</a></a>

<dt><a href="#//apple_ref/occ/clm/EODatabaseContext/setContextClassToRegister:"><a href="#1103">+ setContextClassToRegister:</a></a>

</dl><dt>Checking connection status

<dl><dt><a href="#//apple_ref/occ/instm/EODatabaseContext/hasBusyChannels"><a href="#1115">- hasBusyChannels</a></a>

</dl></dl><a name="872">

<a name="clm"></a>

<h3>Class Methods  </h3>

</a><a name="873">

<h4> <a name="//apple_ref/occ/clm/EODatabaseContext/contextClassToRegister">contextClassToRegister</a></h4>

</a>+ (Class)<code>contextClassToRegister</code><p>

Returns the class that is registered with an EOObjectStoreCoordinator when the coordinator broadcasts an EOCooperatingObjectStoreNeeded notification. By default this is EODatabaseContext, but you can use<a href="#1103"> <B>setContextClassToRegister: </B></a> to specify your own subclass of EODatabaseContext.<p>

When an EOObjectStoreCoordinator sends an EOCooperatingObjectStoreNeeded notification for an entity in the default model group, if contextClassToRegister is non-<code>nil</code> (and it should be-it makes no sense to set contextClassToRegister to <code>nil</code>), an instance of the contextClass is created, the model for the entity is registered, and the contextClass is registered with the requesting EOObjectStoreCoordinator. <p>

<a name="751">

<h4> <a name="//apple_ref/occ/clm/EODatabaseContext/registeredDatabaseContextForModel:editingContext:">registeredDatabaseContextForModel:editingContext:</a></h4>

</a>+ (EODatabaseContext *)<code>registeredDatabaseContextForModel:</code>(EOModel *)<em>aModel </em><code>editingContext:</code>(EOEditingContext *)<em>anEditingContext</em> <p>

Finds the EOObjectStoreCoordinator for <em>anEditingContext</em> and checks to see if it already contains an EODatabaseContext cooperating object store for <em>aModel</em>. If it does, it returns that EODatabaseContext. Otherwise it instantiates a new EODatabaseContext, adds it to the EOObjectStoreCoordinator, and returns the EODatabaseContext.<p>

<a name="1103">

<h4> <a name="//apple_ref/occ/clm/EODatabaseContext/setContextClassToRegister:">setContextClassToRegister:</a></h4>

</a>+ (void)<code>setContextClassToRegister:</code>(Class)<em>contextClass</em><p>

Sets to <em>contextClass</em> the "contextClassToRegister." For more discussion of this topic, see the method description for<a href="#873"> <B>contextClassToRegister </B></a>.<p>

<a name="876">

<a name="instm"></a>

<h3>Instance Methods </h3>

</a><a name="877">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/adaptorContext">adaptorContext</a></h4>

</a>- (EOAdaptorContext *)<code>adaptorContext</code> <p>

Returns the EOAdaptorContext used by the EODatabaseContext for communication with the database server.<p>

<a name="880">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/arrayFaultWithSourceGlobalID:relationshipName:editingContext:">arrayFaultWithSourceGlobalID:relationshipName:editingContext:</a></h4>

</a>- (NSArray *)<B>arrayFaultWithSourceGlobalID: </B>(EOGlobalID *)<em>globalID<br></em><B>relationshipName: </B>(NSString *)<em>name<br></em><B>editingContext: </B>(EOEditingContext *)<em>anEditingContext</em><p>

Overrides the EOObjectStore method <code>arrayFaultWithSourceGlobalID:relationshipName:editingContext:</code> to create a to-many fault for <em>anEditingContext</em>. <em>name</em> must correspond to an EORelationship in the EOEntity for the specified <em>globalID</em>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/faultForGlobalID:editingContext:">- faultForGlobalID:editingContext:</a>

 </B><p><a name="884">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/availableChannel">availableChannel</a></h4>

</a>- (EODatabaseChannel *)<code>availableChannel</code> <p>

Returns an EODatabaseChannel that's registered with the receiver and that isn't busy. If the method can't find a channel that meets these criteria, it posts an EODatabaseChannelNeededNotification in the hopes that someone will provide a new channel. After posting the notification, the receiver checks its list of channels again. If there are still no available channels, the receiver creates an EODatabaseChannel itself. However, if the list is not empty and there are no available channels, the method returns <code>nil</code>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/registerChannel:">- registerChannel:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/registeredChannels"><B>- registeredChannels</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/unregisterChannel:"><B>- unregisterChannel: </a>

 </B><p><a name="888">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/batchFetchRelationship:forSourceObjects:editingContext:">batchFetchRelationship:forSourceObjects:editingContext:</a></h4>

</a>- (void)<code>batchFetchRelationship:</code>(EORelationship *)<em>relationship</em> <br><code>forSourceObjects:</code>(NSArray *)<em>objects</em> <br><code>editingContext:</code>(EOEditingContext *)<em>anEditingContext</em><p>

Clear all the faults for the <em>relationship</em> of <em>anEditingContext</em>'s <em>objects</em> and performs a single, efficient, fetch (at most two fetches, if the relationship is many-to-many). This method provides a way to fetch the same relationship for multiple objects. For example, given an array of Employee objects, this method can fetch all of their departments with one round trip to the server, rather than asking the server for each of the employee's departments individually.<p>

<a name="891">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/commitChanges">commitChanges</a></h4>

</a>- (void)<code>commitChanges</code> <p>

Overrides the EOCooperatingObjectStore method <code>commitChanges</code> to instruct the adaptor to commit the transaction. If the commit is successful, any primary and foreign key changes are written back to the saved objects, database locks are released, and an EOObjectsChangedInStoreNotification (defined in EOObjectStore) is posted describing the committed changes. Raises an exception if the adaptor is unable to commit the transaction; the error message indicates the nature of the problem. You should never need to invoke this method directly.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/performChanges">- performChanges</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/rollbackChanges"><B>- rollbackChanges</a>

 </B><p><a name="895">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/coordinator">coordinator</a></h4>

</a>- (EOObjectStoreCoordinator *)<code>coordinator</code> <p>

Returns the receiver's EOObjectStoreCoordinator or <code>nil</code> if there is none.<em> </em>This method is only valid during a save operation.<p>

<a name="898">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/database">database</a></h4>

</a>- (EODatabase *)<code>database</code> <p>

Returns the receiver's EODatabase. <p>

<a name="901">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/delegate">delegate</a></h4>

</a>- (id)<code>delegate</code> <p>

Returns the receiver's delegate. <p>

<B>See also: </B>  

<em> <a href="#//apple_ref/occ/instm/EODatabaseContext/setDelegate:"></em><B>- setDelegate: </a>

 </B><p><a name="905">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/faultForGlobalID:editingContext:">faultForGlobalID:editingContext:</a></h4>

</a>- (id)<B>faultForGlobalID: </B>(EOGlobalID *)<em>globalID</em> <B>editingContext: </B>(EOEditingContext *)<em>anEditingContext</em><p>

Overrides the EOObjectStore method<em> </em><code>faultForGlobalID:editingContext:</code> to create a to-one fault for the object identified by<em> globalID</em> and register it in <em>anEditingContext.</em><p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/arrayFaultWithSourceGlobalID:relationshipName:editingContext:">- arrayFaultWithSourceGlobalID:relationshipName:editingContext:</a>

 </B><p><a name="909">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/forgetAllLocks">forgetAllLocks</a></h4>

</a>- (void)<code>forgetAllLocks</code> <p>

Clears all of the receiver's locks. Doesn't cause the locks to be forgotten in the server, only in the receiver. This method is useful when something has happened to cause the server to forget the locks and the receiver needs to be synched up. This method is invoked whenever a transaction is committed or rolled back.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/registerLockedObjectWithGlobalID:">- registerLockedObjectWithGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:"><B>- isObjectLockedWithGlobalID:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:editingContext:">- isObjectLockedWithGlobalID:editingContext:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetLocksForObjectsWithGlobalIDs:">- forgetLocksForObjectsWithGlobalIDs:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/lockObjectWithGlobalID:editingContext:"><B>- lockObjectWithGlobalID:editingContext:</a> </B>, 

<B>- lockObject </B><code>:</code> (EOEditingContext)

<p><a name="913">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/forgetLocksForObjectsWithGlobalIDs:">forgetLocksForObjectsWithGlobalIDs:</a></h4>

</a>- (void)<code>forgetLocksForObjectsWithGlobalIDs:</code>(NSArray *)<em>globalIDs</em> <p>

Clears the locks made for the enterprise objects identified by each of the EOGlobalIDs <em>globalIDs</em>. Doesn't cause the locks to be forgotten in the server, only in the receiver.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/registerLockedObjectWithGlobalID:">- registerLockedObjectWithGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:"><B>- isObjectLockedWithGlobalID:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:editingContext:">- isObjectLockedWithGlobalID:editingContext:</a> </B>, - <B>forgetAllLocks </B>, 

- <B>lockObjectWithGlobalID:editingContext: </B>, - <code>lockObject:</code> (EOEditingContext)

<p><a name="917">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/forgetSnapshotForGlobalID:">forgetSnapshotForGlobalID:</a></h4>

</a>- (void)<code>forgetSnapshotForGlobalID:</code>(EOGlobalID *)<em>globalID</em> <p>

Deletes the snapshot made for the enterprise object identified by <em>globalID</em>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshot:forGlobalID:">- recordSnapshot:forGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/localSnapshotForGlobalID:"><B>- localSnapshotForGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshots:"><B>- recordSnapshots:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/snapshotForGlobalID:">- snapshotForGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/forgetSnapshotsForGlobalIDs:"><B>- forgetSnapshotsForGlobalIDs:</a>

 </B><p><a name="921">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/forgetSnapshotsForGlobalIDs:">forgetSnapshotsForGlobalIDs:</a></h4>

</a>- (void)<code>forgetSnapshotsForGlobalIDs:</code>(NSArray *)<em>globalIDs</em><p>

Deletes the snapshots made for the enterprise objects identified by <em>globalID</em><em>s</em>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshot:forGlobalID:">- recordSnapshot:forGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/localSnapshotForGlobalID:"><B>- localSnapshotForGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshots:"><B>- recordSnapshots:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/snapshotForGlobalID:">- snapshotForGlobalID:</a>

 </B><p><a name="925">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/handlesFetchSpecification:">handlesFetchSpecification:</a></h4>

</a>- (BOOL)<code>handlesFetchSpecification:</code>(EOFetchSpecification *)<em>fetchSpecification</em> <p>

Overrides the EOCooperatingObjectStore <code>handlesFetchSpecification:</code> method to return YES if the receiver is responsible for fetching the objects described by the entity name in <em>fetchSpecification</em>. <p>

<B>See also: </B>  

<em> <a href="#//apple_ref/occ/instm/EODatabaseContext/ownsObject:"></em><B>- ownsObject:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/ownsGlobalID:"><B>- ownsGlobalID: </B><em> </a>

</em><p><a name="1115">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/hasBusyChannels">hasBusyChannels</a></h4>

</a>- (BOOL)<code>hasBusyChannels</code><p>

Returns YES if the receiver's EOAdaptorContext has channels that have outstanding operations (that is, have a fetch in progress), NO otherwise.<p>

<a name="1109">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/initializeObject:withGlobalID:editingContext:">initializeObject:withGlobalID:editingContext:</a></h4>

</a>- (void)<code>initializeObject:</code>(id)<em>object</em> <br><code>withGlobalID:</code>(EOGlobalID *)<em>globalID</em> <br><code>editingContext:</code>(EOEditingContext *)<em>anEditingContext</em><p>

Overrides EOObjectStore's <code>initializeObject:withGlobalID:editingContext:</code> to initialize <em>object</em> for <em>anEditingContext</em> by filling it with properties based on row data fetched from the adaptor. The snapshot for <em>globalID</em> is looked up and those attributes in the snapshot that are marked as class properties in the EOEntity are assigned to <em>object</em>. For relationship class properties, faults are constructed and assigned to the object.<p>

<a name="928">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/initWithDatabase:">initWithDatabase:</a></h4>

</a>- <code>initWithDatabase:</code>(EODatabase *)<em>aDatabase</em> <p>

Initializes a newly allocated EODatabaseContext with <em>aDatabase</em> as the EODatabase object it works with. The new EODatabaseContext retains <em>aDatabase</em>. Returns <B>self </B>, or <B>nil </B> if unable to create another EOAdaptorContext for the EOAdaptor of <em>aDatabase</em>. This is the designated initializer for the EODatabaseContext class.  <em> </em> <p>

<a name="931">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/invalidateAllObjects">invalidateAllObjects</a></h4>

</a>- (void)<code>invalidateAllObjects</code> <p>

Overrides the EOObjectStore method <code>invalidateAllObjects</code> to discard all snapshots in the receiver's EODatabase, forget all locks, and post an EOAllObjectsChangedInObjectStoreNotification, as well as an EOObjectsChangedInStoreNotification with the invalidated global IDs in the userInfo dictionary. Both of these notifications are defined in EOObjectStore. This method works by invoking <code>invalidateObjectsWithGlobalIDs:</code> for all of the snapshots in the receiver's EODatabase.<p>

<a name="934">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/invalidateObjectsWithGlobalIDs:">invalidateObjectsWithGlobalIDs:</a></h4>

</a>- (void)<code>invalidateObjectsWithGlobalIDs:</code>(NSArray *)<em>globalIDs</em> <p>

Overrides the EOObjectStore method<code> invalidateObjectsWithGlobalIDs:</code> to discard the snapshots for the objects identified by the EOGlobalIDs <em>globalIDs</em> and broadcasts an EOObjectsChangedInStoreNotification (defined in EOObjectStore), which causes the EOEditingContext containing objects fetched from the receiver to refault those objects. The result is that these objects will be refetched from the database the next time they're accessed.<p>

<a name="937">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:">isObjectLockedWithGlobalID:</a></h4>

</a>- (BOOL)<code>isObjectLockedWithGlobalID:</code>(EOGlobalID *)<em>globalID</em> <p>

Returns YES if the enterprise object identified by <em>globalID</em> is locked, NO otherwise.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/registerLockedObjectWithGlobalID:">- registerLockedObjectWithGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/forgetAllLocks"><B>- forgetAllLocks</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:editingContext:">- isObjectLockedWithGlobalID:editingContext:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetLocksForObjectsWithGlobalIDs:">- forgetLocksForObjectsWithGlobalIDs:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/lockObjectWithGlobalID:editingContext:"><B>- lockObjectWithGlobalID:editingContext:</a> </B>, 

<B>- lockObject </B><code>:</code> (EOEditingContext)

<p><a name="941">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:editingContext:">isObjectLockedWithGlobalID:editingContext:</a></h4>

</a>- (BOOL)<code>isObjectLockedWithGlobalID:</code>(EOGlobalID *)<em>globalID</em> <code>editingContext:</code>(EOEditingContext *)<em>anEditingContext</em><p>

Overrides the EOObjectStore method<code> isObjectLockedWithGlobalID:editingContext: </code>to return YES if the database row corresponding to <em>globalID</em> has been locked in an open transaction held by the receiver.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/registerLockedObjectWithGlobalID:">- registerLockedObjectWithGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:"><B>- isObjectLockedWithGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/forgetAllLocks"><B>- forgetAllLocks</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetLocksForObjectsWithGlobalIDs:">- forgetLocksForObjectsWithGlobalIDs:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/lockObjectWithGlobalID:editingContext:"><B>- lockObjectWithGlobalID:editingContext:</a> </B>,<B><br>

- lockObject: </B><code></code> (EOEditingContext)

<p><a name="945">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/localSnapshotForGlobalID:">localSnapshotForGlobalID:</a></h4>

</a>- (NSDictionary *)<code>localSnapshotForGlobalID:</code>(EOGlobalID *)<em>globalID</em> <p>

Returns the snapshot for the object identified by <em>globalID</em>, if there is one; else returns <code>nil</code>. Only searches locally (in the transaction scope), not in the EODatabase. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshot:forGlobalID:">- recordSnapshot:forGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/forgetSnapshotForGlobalID:"><B>- forgetSnapshotForGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshots:"><B>- recordSnapshots:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/snapshotForGlobalID:">- snapshotForGlobalID:</a>

 </B><p><a name="1136">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/localSnapshotForSourceGlobalID:relationshipName:">localSnapshotForSourceGlobalID:relationshipName:</a></h4>

</a>- (NSArray *)<code>localSnapshotForSourceGlobalID:</code>(EOGlobalID *)<em>globalID</em> <code>relationshipName:</code>(NSString *)<em>name</em><p>

Returns an array that is the snapshot for the objects at the destination of the to-many relationship named <em>name</em>, which is a property of the object identified by <em>globalID</em>. The returned array contains the globalIDs of the destination objects. If there is no snapshot, returns <code>nil</code>. Only searches locally (in the transaction scope), not in the EODatabase.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshot:forSourceGlobalID:relationshipName:">- recordSnapshot:forSourceGlobalID:relationshipName:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/snapshotForSourceGlobalID:relationshipName:">- snapshotForSourceGlobalID:relationshipName:</a>

 </B><p><a name="1133">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/lockObjectWithGlobalID:editingContext:">lockObjectWithGlobalID:editingContext:</a></h4>

</a>- (void)<code>lockObjectWithGlobalID:</code>(EOGlobalID *)<em>globalID</em> <br><code>editingContext:</code>(EOEditingContext *)<em>anEditingContext</em> <p>

Overrides the EOObjectStore method<code> lockObjectWithGlobalID:editingContext: </code>to attempt to lock the database row corresponding to <em>globalID</em> in the underlying database server, on behalf of <em>anEditingContext</em>. If a transaction is not already open at the time of the lock request, the transaction is begun and is held open until either <code>commitChanges</code> or <code>invalidateAllObjects</code> is called. At that point all locks are released. Raises an NSInternalInconsistencyException if unable to obtain the lock.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/registerLockedObjectWithGlobalID:">- registerLockedObjectWithGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:"><B>- isObjectLockedWithGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/forgetAllLocks"><B>- forgetAllLocks</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetLocksForObjectsWithGlobalIDs:">- forgetLocksForObjectsWithGlobalIDs:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:editingContext:"><B>- isObjectLockedWithGlobalID:editingContext:</a> </B>,<B><br>

- lockObject: </B><code></code> (EOEditingContext)

<p><a name="953">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/objectsForSourceGlobalID:relationshipName:editingContext:">objectsForSourceGlobalID:relationshipName:editingContext:</a></h4>

</a>- (NSArray *)<B>objectsForSourceGlobalID: </B>(EOGlobalID *)<em>globalID<br></em><B>relationshipName: </B>(NSString *)<em>name<br></em><B>editingContext: </B>(EOEditingContext *)<em>anEditingContext</em><p>

Overrides the EOObjectStore method <code>objectsForSourceGlobalID:relationshipName:editingContext: </code>to service a to-many fault. The snapshot for the source object identified by <em>globalID</em> is located and the EORelationship named <em>name</em> is used to construct a qualifier from that snapshot. This qualifier is then used to fetch the requested objects into <em>anEditingContext</em> using the method <code>objectsWithFetchSpecification:editingContext:</code>.<p>

<a name="956">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/objectsWithFetchSpecification:editingContext:">objectsWithFetchSpecification:editingContext:</a></h4>

</a>- (NSArray *)<code>objectsWithFetchSpecification:</code>(EOFetchSpecification *)<em>fetchSpecification</em> <code>editingContext:</code>(EOEditingContext *)<em>anEditingContext</em> <p>

Overrides EOObjectStore's <B>objectsWithFetchSpecification: </B><code>editingContext:</code> method to fetch objects from an external store into <em>anEditingContext</em>. The receiver obtains an available EODatabaseChannel and issues a fetch with <em>fetchSpecification</em>. If one of these objects is already present in memory, by default this method doesn't overwrite its values with the new values from the database (you can change this behavior; see the <code>setRefreshesRefetchedObjects:</code> method in the EOFetchSpecification class specification).<p>

You can fine-tune the fetching behavior by adding hints to <em>fetchSpecification</em>'s hints dictionary:<p>

<ul><li>Use EOFetchLimitHintKey and EOPromptAfterFetchLimitHintKey to specify a fetch limit.<br><li>Use EOCustomQueryExpressionHintKey to provide a raw SQL string for performing the fetch.<br><li>Use EOPrefetchingRelationshipHintKey to fetch the destinations of relationships along with the objects specified.<br></ul><p>These hints are described in more detail in the Class Description.<p>

You can use this method to implement "on-demand" locking by using a <em>fetchSpecification</em> that includes locking. For more discussion of this subject, see "<a href="#819">Updating And Locking Strategies</a>" in the class description.<p>

Raises an exception if an error occurs; the error message indicates the nature of the problem.<p>

<B>See also: </B>  

<B>- objectsWithFetchSpecification: </B> (EOEditingContext)

<p><a name="963">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/ownsGlobalID:">ownsGlobalID:</a></h4>

</a>- (BOOL)<code>ownsGlobalID:</code>(EOGlobalID *)<em>globalID</em> <p>

Overrides the EOCooperatingObjectStore method <code>ownsGlobalID:</code> to return YES if the receiver is responsible for fetching and saving the object identified by <em>globalID</em>, NO otherwise. The receiver is determined to be responsible if <em>globalID</em> is a subclass of EOKeyGlobalID and <em>globalID</em> has an entity from one of the receiver's EODatabase's EOModels.<p>

<B>See also: </B>  

 <a href="#//apple_ref/occ/instm/EODatabaseContext/handlesFetchSpecification:"><B>- handlesFetchSpecification:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/ownsObject:"><B>- ownsObject: </a>

 </B><p><a name="967">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/ownsObject:">ownsObject:</a></h4>

</a>- (BOOL)<code>ownsObject:</code>(id)<em>object</em> <p>

Overrides the EOCooperatingObjectStore method <code>ownsObject:</code> to return YES if the receiver is responsible for fetching and saving <em>object</em>, NO otherwise. The receiver is determined to be responsible if the entity corresponding to <em>object</em> is in one of the receiver's EODatabase's EOModels.<p>

<B>See also: </B>  

 <a href="#//apple_ref/occ/instm/EODatabaseContext/ownsGlobalID:"><B>- ownsGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/handlesFetchSpecification:"><B>- handlesFetchSpecification: </a>

 </B><p><a name="971">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/performChanges">performChanges</a></h4>

</a>- (void)<code>performChanges</code> <p>

Overrides the EOCooperatingObjectStore method <code>performChanges</code> to construct EOAdaptorOperations from the EODatabaseOperations produced during <code>recordChangesInEditingContext</code> and <code>recordUpdateForObject:changes:</code>. Invokes the delegate method <code>databaseContext:willOrderAdaptorOperationsFromDatabaseOperations:</code> to give the delegate an opportunity to construct alternative EOAdaptorOperations from the EODatabaseOperations. Then invokes the delegate method <code>databaseContext:willPerformAdaptorOperations:</code> to let the delegate substitute its own array of EOAdaptorOperations. Gives the EOAdaptorOperations to an available EOAdaptorChannel for execution. If the save succeeds, updates the snapshots in the receiver to reflect the new state of the server. You should never need to invoke this method directly.<p>

This method raises an exception if the adaptor is unable to perform the operations. The exception's userInfo dictionary contains these keys:<p>

<ul><li>EODatabaseContextKey<p>The EODatabaseContext object that was trying to save to its underlying repository when the exception was raised.<p><li>EODatabaseOperationsKey<p>The list of database operations the EODatabaseContext was trying to perform when the failure occurred.<p><li>EOFailedDatabaseOperationKey<p>The database operation the EODatabaseContext failed to perform.<p></ul>The userInfo dictionary may also contain some of the keys listed in the method description for the EOAdaptorChannel method <code>performAdaptorOperation:</code>. For more information, see the EOAdaptorChannel class specification.<p>

<B>See also: </B>  

<em> <a href="#//apple_ref/occ/instm/EODatabaseContext/commitChanges"></em><B>- commitChanges</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/rollbackChanges"><B>- rollbackChanges </B><em> </a>

</em><p><a name="983">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/prepareForSaveWithCoordinator:editingContext:">prepareForSaveWithCoordinator:editingContext:</a></h4>

</a>- (void)<code>prepareForSaveWithCoordinator:</code>(EOObjectStoreCoordinator *)<em>coordinator</em> <code>editingContext:</code>(EOEditingContext *)<em>anEditingContext</em> <p>

Overrides the EOCooperatingObjectStore method <code>prepareForSaveWithCoordinator:editingContext: </code>to do whatever is necessary to prepare to save changes. If needed, generates primary keys for any new objects in <em>anEditingContext</em> that are owned by the receiver. This method is invoked before the object graph is analyzed and foreign key assignments are performed. You should never need to invoke this method directly.<p>

<a name="986">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/recordChangesInEditingContext">recordChangesInEditingContext</a></h4>

</a>- (void)<code>recordChangesInEditingContext</code> <p>

Overrides the EOCooperatingObjectStore method <code>recordChangesInEditingContext</code> to construct a list of EODatabaseOperations for all changes to objects in the EOEditingContext that are owned by the receiver. Forwards any relationship changes discovered but not owned by the receiver to the EOObjectStoreCoordinator. This method is typically invoked in the course of an EOObjectStoreCoordinator saving changes through its <code>saveChangesInEditingContext:</code> method. It's invoked after <code>prepareForSaveWithCoordinator:editingContext:</code> and before <code>performChanges</code>. You should never need to invoke this method directly.<p>

<a name="989">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/recordSnapshot:forGlobalID:">recordSnapshot:forGlobalID:</a></h4>

</a>- (void)<code>recordSnapshot:</code>(NSDictionary *)<em>snapshot </em><code>forGlobalID:</code>(EOGlobalID *)<em>globalID</em> <p>

Records <em>aSnapshot</em> under <em>globalID</em>. This method only records snapshots locally (in the transaction scope). If you want to record snapshots globally, use the corresponding EODatabase method.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetSnapshotForGlobalID:">- forgetSnapshotForGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/localSnapshotForGlobalID:"><B>- localSnapshotForGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshots:"><B>- recordSnapshots:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/snapshotForGlobalID:">- snapshotForGlobalID:</a>

 </B><p><a name="1130">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/recordSnapshot:forSourceGlobalID:relationshipName:">recordSnapshot:forSourceGlobalID:relationshipName:</a></h4>

</a>- (void)<code>recordSnapshot:</code>(NSArray *)<em>globalIDs</em> <code>forSourceGlobalID:</code>(EOGlobalID *)<em>globalID</em> <code>relationshipName:</code>(NSString *)<em>name</em><p>

For the object identified by <em>globalID</em>, records an NSArray of <em>globalIDs</em> for the to-many relationship named <em>name</em>. These <em>globalIDs</em> identify the objects at the destination of the relationship. This method only records snapshots locally (in the transaction scope). If you want to record snapshots globally, use the corresponding EODatabase method.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/snapshotForSourceGlobalID:relationshipName:">- snapshotForSourceGlobalID:relationshipName:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/localSnapshotForSourceGlobalID:relationshipName:">- localSnapshotForSourceGlobalID:relationshipName:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/recordToManySnapshots:"><B>- recordToManySnapshots:</a>

 </B><p><a name="1122">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/recordSnapshots:">recordSnapshots:</a></h4>

</a>- (void)<code>recordSnapshots:</code>(NSDictionary *)<em>snapshots</em> <p>

Records the objects in <em>snapshots</em>, which should be snapshot NSDictionaries, under EOGlobalIDs. This method only records snapshots locally (in the transaction scope). If you want to record snapshots globally, use the corresponding EODatabase method.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshot:forGlobalID:">- recordSnapshot:forGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/localSnapshotForGlobalID:"><B>- localSnapshotForGlobalID:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetSnapshotForGlobalID:">- forgetSnapshotForGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/snapshotForGlobalID:"><B>- snapshotForGlobalID: </B><em> </a>

</em><p><a name="1140">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/recordToManySnapshots:">recordToManySnapshots:</a></h4>

</a>- (void)<code>recordToManySnapshots:</code>(NSDictionary *)<em>snapshots</em><p>

Records the objects in <em>snapshots</em>. <em>snapshots</em> should be an NSDictionary of NSDictionaries, in which the top-level dictionary has as its key the globaID of the enterprise object for which to-many relationships are being recorded. The key's value is a dictionary whose keys are the names of the enterprise object's to-many relationships. Each of these keys in turn has as its value an array of globalIDs that identify the objects at the destination of the relationship.<p>

This method only records snapshots locally (in the transaction scope). If you want to record snapshots globally, use the corresponding EODatabase method.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshot:forSourceGlobalID:relationshipName:">- recordSnapshot:forSourceGlobalID:relationshipName:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/snapshotForSourceGlobalID:relationshipName:">- snapshotForSourceGlobalID:relationshipName:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/localSnapshotForSourceGlobalID:relationshipName:">- localSnapshotForSourceGlobalID:relationshipName:</a>

 </B><p><a name="1135">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/recordUpdateForObject:changes:">recordUpdateForObject:changes:</a></h4>

</a>- (void)<code>recordUpdateForObject:</code>(id)<em>object</em> <code>changes:</code>(NSDictionary *)<em>changes</em> <p>

Overrides the EOCooperatingObjectStore method <code>recordUpdateForObject:changes:</code> to communicate to the receiver from another EOCooperatingObjectStore (through the EOObjectStoreCoordinator) that <em>changes</em> need to be made to an <em>object</em> in the receiver. For example, an insert of an object in a relationship property might require changing a foreign key property in an object owned by another EOCooperatingObjectStore. This method can be invoked any time after <code>prepareForSaveWithCoordinator:editingContext:</code> and before <code>performChanges</code>.<p>

<a name="1000">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/refaultObject:withGlobalID:editingContext:">refaultObject:withGlobalID:editingContext:</a></h4>

</a>- (void)<B>refaultObject: </B>(id)<em>anObject<br></em><B>withGlobalID: </B>(EOGlobalID *)<em>globalID<br></em><B>editingContext: </B>(EOEditingContext *)<em>anEditingContext</em><p>

Overrides the EOObjectStore method <code>refaultObject:withGlobalID:editingContext:</code> to refault the enterprise object <em>object</em> identified by <em>globalID</em> in <em>anEditingContext</em>. (You don't refault to-many relationship arrays, you just recreate them.) This method should be used with caution since refaulting an object doesn't remove the object snapshot from the undo stack. Newly inserted objects should not be refaulted since they can't be refetched from the external store. If you attempt to do this, an exception will be raised.<p>

<a name="1003">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/registerChannel:">registerChannel:</a></h4>

</a>- (void)<code>registerChannel:</code>(EODatabaseChannel *)<em>channel</em> <p>

Registers <em>channel</em>, which means that it adds it to the <code>availableChannel</code> pool used to service fetch and fault requests. Registered channels are retained by the receiver. You use this method if you need to perform more than one fetch simultaneously.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/availableChannel">- availableChannel</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/registeredChannels"><B>- registeredChannels</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/unregisterChannel:"><B>- unregisterChannel: </B><em> </a>

</em><p><a name="1007">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/registeredChannels">registeredChannels</a></h4>

</a>- (NSArray *)<code>registeredChannels</code> <p>

Returns all of the EODatabaseChannels that have been registered for use with the receiver. <p>

<B>See also: </B>  

<em> <a href="#//apple_ref/occ/instm/EODatabaseContext/registerChannel:"></em><B>- registerChannel:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/availableChannel"><B>- availableChannel</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/unregisterChannel:"><B>- unregisterChannel: </B><em> </a>

</em><p><a name="1011">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/registerLockedObjectWithGlobalID:">registerLockedObjectWithGlobalID:</a></h4>

</a>- (void)<code>registerLockedObjectWithGlobalID:</code>(EOGlobalID *)<em>globalID</em> <p>

Registers as a locked object the enterprise object identified by <em>globalID</em>. <p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetAllLocks">- forgetAllLocks</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:"><B>- isObjectLockedWithGlobalID:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/isObjectLockedWithGlobalID:editingContext:">- isObjectLockedWithGlobalID:editingContext:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetLocksForObjectsWithGlobalIDs:">- forgetLocksForObjectsWithGlobalIDs:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/lockObjectWithGlobalID:editingContext:"><B>- lockObjectWithGlobalID:editingContext:</a> </B>, 

<B>- lockObject </B><code>:</code> (EOEditingContext)

<p><a name="1015">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/rollbackChanges">rollbackChanges</a></h4>

</a>- (void)<code>rollbackChanges</code> <p>

Overrides the EOCooperatingObjectStore method <code>rollbackChanges</code> to instruct the adaptor to roll back the transaction. Rolls back any changed snapshots, and releases all locks.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/performChanges">- performChanges</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/commitChanges"><B>- commitChanges</a>

 </B><p><a name="1019">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/saveChangesInEditingContext:">saveChangesInEditingContext:</a></h4>

</a>- (void)<B>saveChangesInEditingContext: </B>(EOEditingContext *)<em>anEditingContext</em><p>

Overrides the EOObjectStore method <code>saveChangesInEditingContext:</code> to save the changes made in <em>anEditingContext</em>. This message is sent by an EOEditingContext to its EOObjectStore to commit changes. Normally an EOEditingContext doesn't send this message to an EODatabaseContext, but to an EOObjectStoreCoordinator. Raises an exception if an error occurs; the error message indicates the nature of the problem.<p>

<a name="1022">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/setDelegate:">setDelegate:</a></h4>

</a>- (void)<code>setDelegate:</code>(id)<em>delegate</em> <p>

Sets the receiver's delegate to <em>delegate</em>, and propagates the delegate to all of the receiver's EODatabaseChannels. EODatabaseChannels share the delegate of their EODatabaseContext.<p>

<B>See also: </B>  

<em> <a href="#//apple_ref/occ/instm/EODatabaseContext/delegate"></em><B>- delegate </B><em> </a>

</em><p><a name="1026">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/setUpdateStrategy:">setUpdateStrategy:</a></h4>

</a>- (void)<code>setUpdateStrategy:</code>(EOUpdateStrategy)<em>strategy</em> <p>

Sets the update strategy used by the EODatabaseContext to <em>strategy</em>. See "<a href="#819">Updating And Locking Strategies</a>" in the class description for information on update strategies. Raises an NSInvalidArgumentException if the receiver has any transactions in progress or if you try to set <em>strategy</em> to EOUpdateWithPessimisticLocking and the receiver's EODatabase already has snapshots. <p>

<B>See also: </B>  

<em> <a href="#//apple_ref/occ/instm/EODatabaseContext/updateStrategy"></em><B>- updateStrategy </B><em> </a>

</em><p><a name="1030">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/snapshotForGlobalID:">snapshotForGlobalID:</a></h4>

</a>- (NSDictionary *)<code>snapshotForGlobalID:</code>(EOGlobalID *)<em>globalID</em> <p>

Returns the snapshot for the object identified by <em>globalID</em>, if there is one; else returns <code>nil</code>. Searches first locally (in the transaction scope) and then in the EODatabase.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshot:forGlobalID:">- recordSnapshot:forGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/localSnapshotForGlobalID:"><B>- localSnapshotForGlobalID:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/forgetSnapshotForGlobalID:">- forgetSnapshotForGlobalID:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshots:"><B>- recordSnapshots: </B><em> </em><B>  </a>

 </B><p><a name="1132">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/snapshotForSourceGlobalID:relationshipName:">snapshotForSourceGlobalID:relationshipName:</a></h4>

</a>- (NSArray *)<code>snapshotForSourceGlobalID:</code>(EOGlobalID *)<em>globalID</em> <br><code>relationshipName:</code>(NSString *)<em>name</em><p>

Returns a snapshot that consists of an array of globalIDs. These globalIDs identify the objects at the destination of the to-many relationship named <em>name</em>, which is a property of the object identified by <em>globalID</em>. If there is no snapshot, returns <code>nil</code>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/recordSnapshot:forSourceGlobalID:relationshipName:">- recordSnapshot:forSourceGlobalID:relationshipName:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/EODatabaseContext/localSnapshotForSourceGlobalID:relationshipName:">- localSnapshotForSourceGlobalID:relationshipName:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/recordToManySnapshots:"><B>- recordToManySnapshots:</a>

 </B><p><a name="1126">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/unregisterChannel:">unregisterChannel:</a></h4>

</a>- (void)<code>unregisterChannel:</code>(EODatabaseChannel *)<em>channel</em> <p>

Unregisters the EODatabaseChannel <em>channel</em>, which means that it removes it from the <code>availableChannel</code> pool used for database communication (for example, to service fetch and fault requests). <p>

<B>See also: </B>  

<em> <a href="#//apple_ref/occ/instm/EODatabaseContext/registerChannel:"></em><B>- registerChannel:</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/registeredChannels"><B>- registeredChannels</a> </B>, <a href="#//apple_ref/occ/instm/EODatabaseContext/availableChannel"><B>- availableChannel </B><em> </a>

</em><p><a name="1038">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/updateStrategy">updateStrategy</a></h4>

</a>- (EOUpdateStrategy)<code>updateStrategy</code> <p>

Returns the update strategy used by the receiver. The default strategy is <B>EOUpdateWithOptimisticLocking </B>. See the class description for information on update strategies. <p>

<B>See also: </B>  

<em> <a href="#//apple_ref/occ/instm/EODatabaseContext/setUpdateStrategy:"></em><B>- setUpdateStrategy: </B><em> </a>

</em><p><a name="1042">

<h4> <a name="//apple_ref/occ/instm/EODatabaseContext/valuesForKeys:object:">valuesForKeys:object:</a></h4>

</a>- (NSDictionary *)<code>valuesForKeys:</code>(NSArray *)<em>keys</em> <code>object:</code>(id)<em>object</em> <p>

Overrides the EOCooperatingObjectStore method <code>valuesForKeys:object:</code> to return values for the specified <em>keys</em> from the snapshot of <em>object</em>. The returned values are used primarily by another EODatabaseContext to extract foreign key properties for objects owned by the receiver. <em> </em> <p>

<a name="1045">

<h3>Methods Implemented By the Delegate </h3>

</a><a name="1046">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:didFetchObjects:fetchSpecification:editingContext:">databaseContext:didFetchObjects:fetchSpecification:editingContext:</a></h4>

</a>- (void)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <br><code>didFetchObjects:</code>(NSArray *)<em>objects</em> <br><code>fetchSpecification:</code>(EOFetchSpecification *)<em>fetchSpecification</em> <code>editingContext:</code>(EOEditingContext *)<em>anEditingContext</em><p>

Invoked from <code>objectsWithFetchSpecification:editingContext:</code> after <em>aDatabaseContext</em> fetches <em>objects</em> using the criteria defined in <em>fetchSpecification</em> on behalf of <em>anEditingContext</em>. <p>

<a name="1049">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:didSelectObjectsWithFetchSpecification:databaseChannel:">databaseContext:didSelectObjectsWithFetchSpecification:databaseChannel:</a></h4>

</a>- (void)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <code>didSelectObjectsWithFetchSpecification:</code>(EOFetchSpecification *)<em>fetchSpecification</em> <code>databaseChannel:</code>(EODatabaseChannel *)<em>channel</em><p>

Invoked from the EODatabaseChannel method <code>selectObjectsDescribedByQualifier:...</code> to tell the delegate that <em>channel</em> selected the objects on behalf of <em>aDatabaseContext</em> as specified by <em>fetchSpecification</em>.<p>

<a name="1052">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:failedToFetchObject:globalID:">databaseContext:failedToFetchObject:globalID:</a></h4>

</a>- (BOOL)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <br><code>failedToFetchObject:</code>(id)<em>object</em> <br><code>globalID:</code>(EOGlobalID *)<em>globalID</em><p>

Sent when a to-one fault cannot find its data in the database. The <em>object</em> is a cleared fault identified by <em>globalID</em>. If this method returns YES, <em>aDatabaseContext</em> assumes that the delegate has handled the situation to its satisfaction, in whatever way it deemed appropriate (for example, by displaying an alert panel or initializing a fault object with new values). If it returns NO or if the delegate method is not implemented, <em>aDatabaseContext</em> raises an NSInternalInconsistencyException.<p>

<a name="1055">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:newPrimaryKeyForObject:entity:">databaseContext:newPrimaryKeyForObject:entity:</a></h4>

</a>- (NSDictionary *)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <code>newPrimaryKeyForObject:</code>(id)<em>object</em> <br><code>entity:</code>(EOEntity *)<em>entity</em><p>

Sent when a newly inserted enterprise <em>object</em> doesn't already have a primary key set. This delegate method can be used to implement custom primary key generation. If the delegate is not implemented or returns <code>nil</code>, then <em>aDatabaseContext</em> will send an EOAdaptorChannel a <code>primaryKeyForNewRowWithEntity:</code> message in an attempt to generate the key.<p>

The dictionary you return from this delegate method contains the attribute or attributes (if <em>object</em> has a compound primary key) that make up <em>object</em>'s primary key.<p>

<a name="1058">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:shouldFetchArrayFault:">databaseContext:shouldFetchArrayFault:</a></h4>

</a>- (BOOL)<code>databaseContext:</code>(EODatabaseContext *)<em>databaseContext</em> <code>shouldFetchArrayFault:</code>(id)<em>fault</em><p>

Invoked when a fault is fired, this delegate method lets you fine-tune the behavior of batch faulting. Delegates can fetch the array themselves (for example, by using the EODatabaseContext method <code>batchFetchRelationship:forSourceObjects:editingContext:</code>) and return NO, or return YES to allow the <em>databaseContext</em> to do the fetch itself. If <em>databaseContext</em> performs the fetch it will batch fault according to the batch count on the relationship being fetched.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/databaseContext:shouldFetchObjectFault:">- databaseContext:shouldFetchObjectFault:</a>

 </B><p><a name="1062">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:shouldFetchObjectFault:">databaseContext:shouldFetchObjectFault:</a></h4>

</a>- (BOOL)<code>databaseContext:</code>(EODatabaseContext *)<em>databaseContext</em> <code>shouldFetchObjectFault:</code>(id)<em>fault</em><p>

Invoked when a fault is fired, this delegate method lets you fine-tune the behavior of batch faulting. Delegates can fetch the fault themselves (for example, by using the EODatabaseContext method<code> objectsWithFetchSpecification:editingContext:</code>) and return NO, or return YES to allow <em>databaseContext</em> to perform the fetch. If <em>databaseContext</em> performs the fetch, it will batch fault according to the batch count on the entity being fetched.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/databaseContext:shouldFetchArrayFault:">- databaseContext:shouldFetchArrayFault:</a>

 </B><p><a name="1066">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:shouldFetchObjectsWithFetchSpecification:editingContext:">databaseContext:shouldFetchObjectsWithFetchSpecification:editingContext:</a></h4>

</a>- (NSArray *)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <code>shouldFetchObjectsWithFetchSpecification:</code>(EOFetchSpecification *)<em>fetchSpecification</em> <code>editingContext:</code>(EOEditingContext *)<em>anEditingContext</em><p>

Invoked from <code>objectsWithFetchSpecification:editingContext:</code> to give the delegate the opportunity to satisfy <em>anEditingContext</em>'s fetch request (using the criteria specified in <em>fetchSpecification</em>) from a local cache. If the delegate returns <code>nil</code>, <em>aDatabaseContext</em> performs the fetch. Otherwise, the returned array is returned as the fetch result.<p>

<a name="1069">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:shouldInvalidateObjectWithGlobalID:snapshot:">databaseContext:shouldInvalidateObjectWithGlobalID:snapshot:</a></h4>

</a>- (BOOL)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <code>shouldInvalidateObjectWithGlobalID:</code>(EOGlobalID *)<em>globalId</em> <br><code>snapshot:</code>(NSDictionary *)<em>snapshot</em><p>

Invoked from <code>invalidateObjectsWithGlobalIDs:</code>. Delegate can cause <em>aDatabaseContext</em>'s object as identified by <em>globalID</em> to not be invalidated and that object's <em>snapshot</em> to not be cleared by returning NO.<p>

<a name="1072">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:shouldLockObjectWithGlobalID:snapshot:">databaseContext:shouldLockObjectWithGlobalID:snapshot:</a></h4>

</a>- (BOOL)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <code>shouldLockObjectWithGlobalID:</code>(EOGlobalID *)<em>globalID</em> <br><code>snapshot:</code>(NSDictionary *)<em>snapshot</em><p>

Invoked from <code>lockObjectWithGlobalID:editingContext:</code>. The delegate should return YES if it wants the operation to proceed or NO if it doesn't. Values from <em>snapshot</em> are used to create a qualifier from the attributes used for locking specified for the object's entity (that is, the object identified by <em>globalID</em>). Delegates can override the locking mechanism by implementing their own locking procedure and returning NO. Methods that override the locking mechanism should raise an exception on the failure to lock exactly one object.<p>

<a name="1075">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:shouldRaiseExceptionForLockFailure:">databaseContext:shouldRaiseExceptionForLockFailure:</a></h4>

</a>- (BOOL)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <code>shouldRaiseExceptionForLockFailure:</code>(NSException *)<em>exception</em><p>

Invoked from <code>lockObjectWithGlobalID:editingContext:</code>. This method allows the delegate to suppress an <em>exception</em> that has occurred during <em>aDatabaseContext</em>'s attempt to lock the object.<p>

<a name="1078">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:shouldSelectObjectsWithFetchSpecification:databaseChannel:">databaseContext:shouldSelectObjectsWithFetchSpecification:databaseChannel:</a></h4>

</a>- (BOOL)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <code>shouldSelectObjectsWithFetchSpecification:</code>(EOFetchSpecification *)<em>fetchSpecification</em> <code>databaseChannel:</code>(EODatabaseChannel *)<em>channel</em><p>

Invoked from the EODatabaseChannel method <code>selectObjectsDescribedByQualifier:...</code> to tell the delegate that <em>channel</em> will select objects on behalf of <em>aDatabaseContext</em> as specified by <em>fetchSpecification</em>. The delegate should not modify the qualifier or fetch order. If the delegate returns YES the channel will go ahead and select the object; if the delegate returns NO (possibly after issuing custom SQL against the adaptor) the <em>channel</em> will skip the select and return.<p>

<a name="1081">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:shouldUpdateCurrentSnapshot:newSnapshot:globalID:channel:">databaseContext:shouldUpdateCurrentSnapshot:newSnapshot:globalID:channel:</a></h4>

</a>- (NSDictionary *)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <code>shouldUpdateCurrentSnapshot:</code>(NSDictionary *)<em>currentSnapshot</em> <code>newSnapshot:</code>(NSDictionary *)<em>newSnapshot</em> <br><code>globalID:</code>(EOGlobalID *)<em>globalID</em> <br><code>channel:</code>(EODatabaseChannel *)<em>channel</em><p>

Invoked from the EODatabaseChannel method <code>fetchObject</code> when <em>aDatabaseContext</em> already has a snapshot (<em>currentSnapshot</em>) for a row fetched from the database. This method is invoked without first checking whether the snapshots are equivalent (the check would be too expensive to do in the common case), so the receiver may be passed equivalent snapshots. The default behavior is to not update an older snapshot with <em>newSnapshot</em>. The delegate can override this behavior by returning an NSDictionary (possibly <em>newSnapshot</em>) that will be recorded as the updated snapshot. This will result in an EOObjectsChangedInStoreNotification being broadcast, causing the object store hierarchy to invalidate existing objects (as identified by <em>globalID</em>) built from the obsolete snapshot. Returning <code>nil</code> raises an exception. You can use this method to achieve the same effect as using an EOFetchSpecification with <code>setRefreshesRefetchedObjects:</code> set to YES-that is, it allows you to overwrite in-memory object values with values from the database that may have been changed by someone else.<p>

Returning <em>currentSnapshot</em> causes the <em>aDatabaseContext</em> to perform the default behavior (that is, not updating the older snapshot). <p>

<a name="1084">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:shouldUsePessimisticLockWithFetchSpecification:databaseChannel:">databaseContext:shouldUsePessimisticLockWithFetchSpecification:<br>databaseChannel:</a></h4>

</a>- (BOOL)<code>databaseContext:</code>(EODatabaseContext *)<em>databaseContext</em> <code>shouldUsePessimisticLockWithFetchSpecification:</code>(EOFetchSpecification *)<em>fetchSpecification</em> <code>databaseChannel:</code>(EODatabaseChannel *)<em>channel</em><p>

Invoked from the EODatabaseChannel method <code>selectObjectsDescribedByQualifier:...</code> regardless of the update strategy specified on <em>channel</em>'s <em>databaseContext</em>. The delegate should not modify the qualifier or fetch order contained in <em>fetchSpecification</em>. If the delegate returns YES the channel locks the rows being selected; if the delegate returns NO the channel selects the rows without locking.<p>

<a name="1087">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:willOrderAdaptorOperationsFromDatabaseOperations:">databaseContext:willOrderAdaptorOperationsFromDatabaseOperations:</a></h4>

</a>- (NSArray *)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <code>willOrderAdaptorOperationsFromDatabaseOperations:</code>(NSArray *)<em>databaseOperations</em><p>

Sent from <code>performChanges</code>. If the delegate responds to this message, it must return an array of EOAdaptorOperations that <em>aDatabaseContext</em> can then submit to an EOAdaptorChannel for execution. The delegate can fabricate its own array by asking each of the <em>databaseOperations</em> for its list of EOAdaptorOperations, and adding them to the array which will eventually be returned by this method. The delegate is free to optimize, order, or transform the list in whatever way it deems necessary. This method is useful for applications that need a special ordering of the EOAdaptorOperations so as not to violate any database referential integrity constraints.<p>

<a name="1090">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:willPerformAdaptorOperations:adaptorChannel:">databaseContext:willPerformAdaptorOperations:adaptorChannel:</a></h4>

</a>- (NSArray *)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <code>willPerformAdaptorOperations:</code>(NSArray *)<em>adaptorOperations</em> <br><code>adaptorChannel:</code>(EOAdaptorChannel *)<em>adaptorChannel</em><p>

Sent from <code>performChanges</code>. The delegate can return a new <em>adaptorOperations</em> array which <em>aDatabaseContext</em> will hand to <em>adaptorChannel</em> for execution in place of the old array of EOAdaptorOperations. This method is useful for applications that need a special ordering of the EOAdaptorOperations so as not to violate any database referential integrity constraints.<p>

<a name="1093">

<h4> <a name="//apple_ref/occ/instm/NSObject/databaseContext:willRunLoginPanelToOpenDatabaseChannel:">databaseContext:willRunLoginPanelToOpenDatabaseChannel:</a></h4>

</a>- (BOOL)<code>databaseContext:</code>(EODatabaseContext *)<em>aDatabaseContext</em> <code>willRunLoginPanelToOpenDatabaseChannel:</code>(EODatabaseChannel *)<em>channel</em><p>

When <em>aDatabaseContext</em> is about to use a <em>channel</em>, it checks to see if the <em>channel</em>'s corresponding EOAdaptorChannel is open. If it isn't, it attempts to open the EOAdaptorChannel by sending it an <code>openChannel</code> message. If that doesn't succeed, <em>aDatabaseContext</em> will ask the EOAdaptorChannel's adaptor to run the login panel and open the channel. <em>aDatabaseContext</em> gives the delegate a chance to intervene in this by invoking this delegate method. The delegate can return NO to stop <em>aDatabaseContext</em> from running the login panel. In this case, the delegate is responsible for opening the channel. If the delegate returns YES, <em>aDatabaseContext</em> runs the login panel.<p>

 <p>

The following notification is declared and posted by EODatabaseContext. <p>

<a name="//apple_ref/c/data/EODatabaseChannelNeededNotification">EODatabaseChannelNeededNotification</a><p>

<dl><dt>Notification Object

<dl><dt>The EODatabaseContext.

</dl><dt>userInfo Dictionary

<dl><dt>None.

<dt><a href=""></a>

This notification is broadcast whenever an EODatabaseContext is asked to perform an object store operation and it doesn't have an available EODatabaseChannel. Subscribers can create a new channel and add it to the EODatabaseContext at this time.<p>

</dl></dl>

 

 





<i>Copyright &#169; 1997, Apple Computer, Inc.   All rights

reserved.</i>



<!-- Last updated: 10/16/97 11:22:26 -->



</body>

</html>

