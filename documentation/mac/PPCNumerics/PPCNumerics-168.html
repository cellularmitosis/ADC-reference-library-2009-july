<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Porting SANE to PowerPC Numerics(IM:PN)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING168></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="PPCNumerics-167.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="PPCNumerics-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="PPCNumerics-192.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="PPCNumerics-169.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="PPCNumerics-2.html"><B>PowerPC Numerics </B></A> / <A HREF="PPCNumerics-165.html"><B>Part 3 - Appendixes</B></A><BR><DD><A HREF="PPCNumerics-166.html"><B>Appendix A - SANE Versus PowerPC  Numerics</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING168-0></A>
<H1>Porting SANE to PowerPC Numerics</H1>
 <A NAME=MARKER-2-62></A>If you have a program that is written to take advantage of SANE features, you might want to port it to the PowerPC processor to take advantage of the increased speed. This section provides tips on how to do so.<P>
 Perform the following steps to be sure that your program will run on both 680x0-based and PowerPC processor-based Macintosh computers:<P>
<OL>
<LI>Replace all uses of type <CODE>comp</CODE> with type <CODE>double</CODE> or <CODE>long int</CODE>.
<LI>Replace <CODE>sane.h</CODE> and <CODE>math.h</CODE> with <CODE>fp.h</CODE> and <CODE>fenv.h</CODE>.
<LI>Replace uses of <CODE>extended</CODE> with<CODE> double_t</CODE> or, if this is not possible, with <CODE>long double</CODE>.
<LI>Replace SANE-specific functions with their MathLib equivalents. SANE-specific functions include the functions listed as implemented differently in MathLib in the section <A HREF=#MARKER-9-72>"Differences in Transcendental Functions" on page A-5</A>, all class and sign inquiry functions, and all environmental control functions. <P>
</OL>
 The following sections guide you through these four steps.<P>
<A NAME=HEADING168-8></A>
<H2>Replacing Variables of Type comp </H2>
 <A NAME=MARKER-2-63></A><A NAME=MARKER-2-10></A>The first step in porting a SANE program is to remove uses of the data type <CODE>comp</CODE>. The type <CODE>comp</CODE> is a floating-point type with 64 bits of precision. In SANE, type <CODE>comp</CODE> is automatically converted to extended format whenever an expression is evaluated, just like every other SANE data format. In other words, <CODE>comp</CODE> is a floating-point type disguised as an integer type. In most cases you can replace type <CODE>comp</CODE> with type <CODE>double</CODE>, which provides 53 bits of precision. If your <CODE>comp</CODE> variables require greater than 53 bits of precision, you might need to write your own integer arithmetic package.<A NAME=MARKER-2-65></A><P>
<A NAME=HEADING168-10></A>
<H2>Using MathLib Instead of the SANE Library</H2>
 <A NAME=MARKER-2-66></A>The next step in porting a SANE program is to use the header files <CODE>fp.h</CODE> and <CODE>fenv.h</CODE>. The files <CODE>fp.h</CODE> and <CODE>fenv.h</CODE> replace <CODE>sane.h</CODE> and <CODE>math.h</CODE>. All of the transcendental functions declared in <CODE>sane.h</CODE> are now declared in <CODE>fp.h</CODE>, and most of them work exactly the same way in the two environments. If your program includes the header file <CODE>math.h</CODE> instead of <CODE>sane.h</CODE>, you should replace it with <CODE>fp.h</CODE> as well. The <CODE>fp.h</CODE> file declares all of the functions and macros declared in the ANSI header file <CODE>math.h</CODE> plus some additional ones.<P>
 <A NAME=MARKER-2-67></A>Be aware of the differences in function prototypes in the files <CODE>sane.h</CODE> and <CODE>fp.h</CODE>. If your program currently uses <CODE>sane.h</CODE>, the declarations for transcendental functions look like this:<P>
<PRE>
extended func_name (extended func_params);
</PRE>
 In other words, all transcendental functions in <CODE>sane.h</CODE> are type <CODE>extended</CODE> and take type <CODE>extended</CODE> as arguments. These declarations mean that you can pass any floating-point type to a transcendental function without losing precision.<P>
 <A NAME=MARKER-2-68></A>In <CODE>fp.h</CODE>, the typical transcendental function declaration has the form<P>
<PRE>
double_t func_name (double_t func_params);
</PRE>
 The <CODE>double_t</CODE> type changes definition based on which processor the program is run on. For the PowerPC processor, <CODE>double_t</CODE> is defined to be type <CODE>double</CODE>. For the 680x0 processor, <CODE>double_t</CODE> is defined to be type <CODE>extended</CODE>. Therefore, when you change from using <CODE>sane.h</CODE> to using <CODE>fp.h</CODE>, your program will compile on both the 680x0 and the PowerPC processors and there will be no change in the way your program runs on the 680x0. For more information on the <CODE>double_t</CODE> type, see <A HREF=#MARKER-9-87>"Portable Declarations" on page A-9</A>. <P>
 In some cases, a numeric function also has a <CODE>long double</CODE> implementation in MathLib. The declarations of the <CODE>long double</CODE> implementations are in <CODE>fp.h</CODE> and have the form<P>
<PRE>
long double func_namel (long double func_params);
</PRE>
 See the function descriptions in Part 2 of this book to find out if a function you are using has a <CODE>long double</CODE> implementation. If it does, you should examine the types of the parameters you are passing to that function and you should examine the return values. If a function parameter or return value requires more than 53 bits of precision, you may need to use the <CODE>long double</CODE> implementation of the function when it runs on a PowerPC processor. To do this, you simply add the letter <I>l</I> to the function call.<P>
<A NAME=HEADING168-21></A>
<H2>Replacing Extended Format Variables</H2>
 <A NAME=MARKER-2-69></A>When changing extended variables, first change all variables that are declared as <CODE>extended</CODE> to type <CODE>double_t</CODE>. For the 680x0 processor, <CODE>double_t</CODE> is defined as <CODE>extended</CODE>. For the PowerPC processor, <CODE>double_t</CODE> is defined as <CODE>double</CODE>. Once you make this change, your program runs with no changes on the 680x0 processor but now also runs on the PowerPC processor. Next, you need to examine each <CODE>double_t</CODE> variable to see if it will overflow on the PowerPC processor. If the variable requires more than 53 bits of precision, change its declaration to <CODE>long double</CODE>.<A NAME=MARKER-2-70></A><A NAME=MARKER-2-71></A><P>
<A NAME=HEADING168-23></A>
<H2>Using MathLib Functions</H2>
 As mentioned previously, PowerPC Numerics (specifically, the MathLib library) provides a superset of the functions that SANE provides. In most cases you don't need to make any changes to your existing calls to the SANE library. However, there are a few transcendental functions that have a different implementation in MathLib. Also, the names have changed for the class and sign inquiries and floating-point environmental controls.<P>
<A NAME=HEADING168-25></A>
<H3><A NAME=MARKER-9-72></A>Differences in Transcendental Functions</H3>
 <A NAME=MARKER-2-73></A>The following transcendental functions are implemented differently in MathLib than in the SANE library:<P>
<UL>
<LI>The <A NAME=MARKER-9-1></A><CODE>copysign</CODE> function does not follow the IEEE standard in SANE, which reverses the order of the function's parameters. PowerPC Numerics follows the parameter order described in the IEEE standard.
<LI>The <A NAME=MARKER-2-75></A><CODE>exp1</CODE> function in SANE is named <CODE>expm1</CODE> in PowerPC Numerics.
<LI>The <CODE><A NAME=MARKER-9-2></A>ipower</CODE> function is replaced with the <CODE>pow</CODE> function in PowerPC Numerics.
<LI>The <A NAME=MARKER-2-77></A><CODE>log1</CODE> function in SANE is named <CODE>log1p</CODE> in PowerPC Numerics.
<LI>The <A NAME=MARKER-2-78></A>nextafter functions in SANE are <CODE>nextfloat</CODE>, <CODE>nextdouble</CODE>, and <CODE>nextextended</CODE>. In PowerPC Numerics, they are <CODE>nexafterf</CODE>, <CODE>nextafterd</CODE>, and <CODE>nextafterl</CODE> for <CODE>float</CODE>, <CODE>double</CODE>, and <CODE>long double</CODE>, respectively.
<LI>The <CODE><A NAME=MARKER-9-19></A>nan</CODE> function in SANE takes a character parameter, but the PowerPC Numerics <CODE>nan</CODE> function takes a character string parameter.
<LI>The SANE <A NAME=MARKER-2-80></A><CODE>pi</CODE> function is replaced with the constant <CODE>pi</CODE>, the SANE <CODE>inf</CODE> function is replaced with the constant <CODE>INFINITY</CODE>, and the <CODE>NAN</CODE> constant remains the same.
<LI>The <CODE><A NAME=MARKER-2-81></A>pow</CODE> function behaves differently in the two environments. For example, in SANE <CODE>pow(NAN,0)</CODE> returns a NaN, whereas in PowerPC Numerics, <CODE>pow(NAN,0)</CODE> returns <BR>a 1.
<LI>The <CODE>remainder</CODE> function in SANE takes three parameters, the last one being a return value. The PowerPC Numerics <CODE>remainder</CODE> function takes two parameters. The <CODE>remquo</CODE> function is analogous to the SANE <CODE>remainder</CODE> function.
<LI>The <A NAME=MARKER-2-82></A><CODE>scalb</CODE> function does not follow the IEEE standard in SANE, which reverses the order of the function's parameters. PowerPC Numerics follows the parameter order described in the IEEE standard.<A NAME=MARKER-2-83></A><P>
</UL>
<A NAME=HEADING168-37></A>
<H3>Differences in Class and Sign Inquiries</H3>
 The class and sign inquiry functions declared in <CODE>sane.h</CODE> are not implemented in MathLib. Instead, MathLib provides a set of macros that perform the same actions. <BR><A HREF=#MARKER-9-1>Table A-1</A> shows the declarations in <CODE>sane.h</CODE> on the left and the corresponding declaration in the MathLib header file <CODE>fp.h</CODE> on the right.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-1></A><B>Table A-1 Class and sign inquiries in SANE versus MathLib</B></CAPTION>
<TH><CODE>sane.h</CODE> declaration<TH><CODE>fp.h</CODE> declaration<TR>
<TD><BR>#define <A NAME=MARKER-2-2></A>SNAN        0<BR>#define <A NAME=MARKER-2-3></A>QNAN        1<BR>#define <A NAME=MARKER-2-4></A>INFINITE    2<BR>#define <A NAME=MARKER-2-5></A>ZERONUM     3<BR>#define <A NAME=MARKER-2-10></A>NORMALNUM   4<BR>#define <A NAME=MARKER-2-18></A>DENORMALNUM 5<BR>typedef short <A NAME=MARKER-2-9></A>numclass;<TD>enum NumberKind { <BR>FP_SNAN = 0, <BR>FP_QNAN, <BR>FP_INFINITE, <BR>FP_ZERO, <BR>FP_NORMAL, <BR>FP_SUBNORMAL };<TR>
<TD>numclass <A NAME=MARKER-2-28></A>classfloat (extended x);<BR>numclass <A NAME=MARKER-2-10></A>classdouble(extended x);<BR>numclass <A NAME=MARKER-2-11></A>classcomp(extended x);<BR>numclass <A NAME=MARKER-2-12></A>classextended(extended x);<TD>#define fp_classify(x)<A HREF="#FOOTNOTE-68">[68]</A><TR>
<TD>long <A NAME=MARKER-2-13></A>signnum (extended x);<TD>#define signbit(x)</TABLE>
<P>
<A NAME=HEADING168-39></A>
<H3>Differences in Environmental Controls</H3>
 <A NAME=MARKER-2-21></A>MathLib's environmental control functions are declared in the header file <CODE>fenv.h</CODE>. They affect only rounding direction modes and floating-point exceptions, and they are different from the functions that perform the same tasks in the SANE library. <P>
 If the SANE program uses rounding precision modes, you must remove this code to run it on the PowerPC processor. The PowerPC processor almost always uses less precision than SANE when evaluating expressions, so this should not be a problem. See <A HREF=PPCNumerics-20.html#MARKER-9-1>Chapter 3, "Expression Evaluation,"</A> for details.<P>
 If the SANE program uses halts, you need to replace them with your own exception handling routines.<P>
 Replace the floating-point environmental access function or macro on the left side of <A HREF=#MARKER-9-14>Table A-2</A> with the corresponding function or macro on the right side. If your compiler supports the environmental access switch described in <A HREF=PPCNumerics-178.html#MARKER-9-2>Appendix D, "FPCE Recommendations for Compilers,"</A> you must turn the switch on before using any of the functions or macros from <A HREF=#MARKER-9-14>Table A-2</A>. 
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-14></A><B>Table A-2 Environmental access functions in SANE versus MathLib</B> </CAPTION>
<TH><CODE>sane.h</CODE> declaration<TH><CODE>fenv.h</CODE> declaration<TR>
<TD>#define <A NAME=MARKER-2-15></A>INVALID   1<BR>#define <A NAME=MARKER-2-16></A>UNDERFLOW 2<BR>#define <A NAME=MARKER-2-17></A>OVERFLOW  4<BR>#define <A NAME=MARKER-2-18></A>DIVBYZERO 8<BR>#define <A NAME=MARKER-2-19></A>INEXACT  16<TD>#define FE_INEXACT     0x02000000<BR>#define FE_DIVBYZERO   0x04000000<BR>#define FE_UNDERFLOW   0x08000000<BR>#define FE_OVERFLOW    0x10000000<BR>#define FE_INVALID     0x20000000<TR>
<TD>#define <A NAME=MARKER-2-20></A>IEEEDEFAULTENV<TD>#define FE_DFL_ENV &amp;_FE_DFL_ENV<TR>
<TD>typedef short <A NAME=MARKER-2-21></A>exception;<TD>typedef long int fexcept_t;<TR>
<TD>typedef short <A NAME=MARKER-2-22></A>environment<TD>typedef long int fenv_t;<TR>
<TD>#define <A NAME=MARKER-2-23></A>TONEAREST  0<BR>#define <A NAME=MARKER-2-24></A>UPWARD     1<BR>#define <A NAME=MARKER-2-25></A>DOWNWARD   2<BR>#define <A NAME=MARKER-2-26></A>TOWARDZERO 3<TD>#define FE_TONEAREST    0x00000000<BR>#define FE_TOWARDZERO   0x00000001<BR>#define FE_UPWARD       0x00000002<BR>#define FE_DOWNWARD     0x00000003<TR>
<TD>typedef short <A NAME=MARKER-2-27></A>rounddir;<TD>--<TR>
<TD>void <A NAME=MARKER-2-28></A>setexception(exception e, <BR>                  long s);<TD>int fesetexcept(const fexcept_t <BR>                *flagp, int excepts);<BR>int feclearexcept(int excepts);<BR>int feraiseexcept(int excepts);<TR>
<TD>long <A NAME=MARKER-2-29></A>testexception(exception e);<TD>int fetestexcept(int excepts);<TR>
<TD>void <A NAME=MARKER-2-30></A>setround (rounddir r);<TD>int fesetround(int round);<TR>
<TD>rounddir <A NAME=MARKER-2-31></A>getround(void);<TD>int fegetround(void);<TR>
<TD colspan=2>&nbsp;<TR>
<TD>void <A NAME=MARKER-2-32></A>setenvironment(environment e);<TD>void fesetenv(const fenv_t *envp);<TR>
<TD>void <A NAME=MARKER-2-33></A>getenvironment(environment *e);<TD>void fegetenv(fenv_t *envp);<TR>
<TD>void <A NAME=MARKER-2-34></A>procentry(environment *e);<TD>int feholdexcept(fenv_t *envp);<DFN><A HREF="#FOOTNOTE-69">[69]</A></DFN><TR>
<TD>void <A NAME=MARKER-2-35></A>procexit(environment e);<TD>void feupdateenv(const fenv_t *envp);</TABLE>
<P>
 <A HREF=#MARKER-9-85>Listing A-1</A> is a C code fragment that runs on both the 680x0 and PowerPC processors. It performs the <CODE>pow</CODE> function, tests for the occurrence of the inexact exception, and prints the results.<P>
<B>Listing A-1  <A NAME=MARKER-9-85></A>Using environmental controls in SANE and PowerPC Numerics</B><P>
<PRE>
   double_t x, y, result;/* double on PowerPC,extended on 680x0 */
#ifdef __SANE__         /* 680x0 processor */
   exception fp_inexact;
#else                   /* PowerPC processor */
   fexcept_t fp_inexact;
#endif

#ifdef __SANE__         /* 680x0 processor */
   setenvironment(IEEEDEFAULTENV);
#else                   /* PowerPC processor */
   fesetenv(FE_DFL_ENV);
#endif

   result = pow(x, y);

#ifdef __SANE__         /* 680x0 processor */
   fp_inexact = testexception (INEXACT);
#else                   /* PowerPC processor */
   fp_inexact = fetestexcept (FE_INEXACT);
#endif

   printf (&quot;pow(%g,%g) = %g\t&quot;, x, y, result);
   if (fp_inexact) 
      printf (&quot;INEXACT\n&quot;);

</PRE>
<A NAME=HEADING168-47></A>
<H2>Compatibility Tools in MathLib</H2>
 <A NAME=MARKER-2-86></A>This section describes some tools provided in MathLib that help with compatibility between two environments. The tools include type definitions that help you make efficient, portable variable declarations and macros that are defined differently on the two architectures.<P>
<A NAME=HEADING168-49></A>
<H3><A NAME=MARKER-9-87></A>Portable Declarations</H3>
 <A NAME=MARKER-9-4></A>MathLib defines two floating-point type definitions, <CODE>float_t</CODE> and <CODE>double_t</CODE>, in the header file <CODE>Types.h</CODE>. If you define a variable to be <CODE>float_t</CODE> or <CODE>double_t</CODE>, it means "use the most efficient floating-point type for this architecture." <A HREF=#MARKER-9-42>Table A-3</A> shows the definitions for <CODE>float_t</CODE> and <CODE>double_t</CODE> on PowerPC architecture compared with 680x0 architecture.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><CODE><A NAME=MARKER-9-42>Table A-3
</A>float_t</CODE> and <CODE>double_t</CODE> definitions</CAPTION>
<TH>Architecture<TH><CODE>float_t</CODE><TH><CODE>double_t</CODE><TR>
<TD>PowerPC<TD>float<TD>double<TR>
<TD>680x0<TD>long double<TD>long double</TABLE>
<P>
 The PowerPC architecture is based on the IEEE double format. The most natural format for computations is double, but the architecture allows computations in single format as well. Therefore, <CODE>float_t</CODE> is defined to be <CODE>float</CODE> (single precision) and <CODE>double_t</CODE> is defined to be <CODE>double</CODE> for the PowerPC architecture. The 680x0 architecture is based on the extended format and performs all computations in extended format regardless of the type of the operands. Therefore, <CODE>float_t</CODE> and <CODE>double_t</CODE> are both <CODE>long double</CODE> (extended precision) for the 680x0 architecture.<P>
 If you declare a variable to be type <CODE>double_t</CODE> and you compile the source code as a PowerPC application, the variable is double format. If you recompile the same source code as an 680x0 application, the variable is extended format.<P>
 If your compiler is FPCE-compliant, it also supports the pragmas that allow the most efficient floating-point type to be used for function return values, parameters, and local variables. See <A HREF=PPCNumerics-178.html#MARKER-9-2>Appendix D, "FPCE Recommendations for Compilers,"</A> for more information on these pragmas. <A NAME=MARKER-2-41></A><P>
<A NAME=HEADING168-54></A>
<H3>Macros</H3>
 You might find the following macros useful to isolate 680x0-specific code from PowerPC-specific code:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Macro<TH>Description<TR>
<TD><CODE><A NAME=MARKER-2-36></A></CODE>__<CODE>SANE</CODE>__<CODE></CODE><TD>Defined if <CODE>sane.h</CODE> is used<TR>
<TD><CODE><A NAME=MARKER-2-37></A></CODE>__<CODE>FP</CODE>__<CODE></CODE><TD>Defined if <CODE>fp.h</CODE> is used<TR>
<TD><CODE><A NAME=MARKER-2-38></A>LONG_DOUBLE_SIZE</CODE><TD>Returns the size in bytes of <CODE>long double</CODE> on the processor on which the program is run<TR>
<TD><CODE><A NAME=MARKER-2-39></A>DOUBLE_SIZE</CODE><TD>Returns the size in bytes of <CODE>double</CODE> on the processor on which the program is run<TR>
<TD><CODE><A NAME=MARKER-2-40></A>DECIMAL_DIG</CODE><TD>Returns the maximum size in digits of a decimal number that can be converted to binary<A NAME=MARKER-2-41></A></TABLE>
<P>
 <A NAME=MARKER-2-90></A><A NAME=MARKER-2-12></A><P>
<HR>

<A NAME="FOOTNOTE-68">[68] The <CODE>fpclassify</CODE> macro returns a long integer.
<HR>

<A NAME="FOOTNOTE-69">[69] The <CODE>feholdexcept</CODE> function, although it replaces the <CODE>procentry</CODE> SANE function, affects only the exception flags. It does not affect the rounding direction. 

</BLOCKQUOTE>
<HR>
<center>
<A HREF="PPCNumerics-167.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="PPCNumerics-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="PPCNumerics-192.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="PPCNumerics-169.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="PPCNumerics-3.html">&copy; Apple Computer, Inc.</A><br>13 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
