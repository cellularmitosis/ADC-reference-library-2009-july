<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>QTCoreVideo301 - /Classes/OpenGL/Shaders/ShaderKit/GLSLKit.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../index.html#//apple_ref/doc/uid/TP30000925" target="_top">Sample Code</a> &gt; <a href="../GraphicsImaging/index.html#//apple_ref/doc/uid/TP30000925-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../GraphicsImaging/idxQuickTime-date.html#//apple_ref/doc/uid/TP30000925-TP30000424-TP30000457">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">QTCoreVideo301</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">QTCoreVideo301</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Classes/OpenGL/Shaders/ShaderKit/GLSLKit.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Classes/Alert/Alert.c</option>
<option value="listing2.html">/Classes/Alert/Alert.h</option>
<option value="listing3.html">/Classes/Alert/AlertPanelKit.h</option>
<option value="listing4.html">/Classes/Alert/AlertPanelKit.m</option>
<option value="listing5.html">/Classes/MemObject/MemObject.h</option>
<option value="listing6.html">/Classes/MemObject/MemObject.m</option>
<option value="listing7.html">/Classes/MemObject/Memory.c</option>
<option value="listing8.html">/Classes/MemObject/Memory.h</option>
<option value="listing9.html">/Classes/OpenGL/Quad/OpenGLQuad.h</option>
<option value="listing10.html">/Classes/OpenGL/Quad/OpenGLQuad.m</option>
<option value="listing11.html">/Classes/OpenGL/Shaders/ShaderKit/GLSLKit.h</option>
<option value="listing12.html">/Classes/OpenGL/Shaders/ShaderKit/GLSLKit.m</option>
<option value="listing13.html">/Classes/OpenGL/Shaders/ShaderUnit/GLSLUnit.h</option>
<option value="listing14.html">/Classes/OpenGL/Shaders/ShaderUnit/GLSLUnit.m</option>
<option value="listing15.html">/Classes/OpenGL/Shaders/ShaderUnit/GLSLUnitDictConsts.h</option>
<option value="listing16.html">/Classes/OpenGL/Shaders/ShaderUnit/GLSLUnitsController.h</option>
<option value="listing17.html">/Classes/OpenGL/Shaders/ShaderUnit/GLSLUnitsController.m</option>
<option value="listing18.html">/Classes/OpenGL/Shaders/Types/GLSLTypes.h</option>
<option value="listing19.html">/Classes/OpenGL/Shaders/Units/Blur/GLSLBlurUnit.h</option>
<option value="listing20.html">/Classes/OpenGL/Shaders/Units/Blur/GLSLBlurUnit.m</option>
<option value="listing21.html">/Classes/OpenGL/Shaders/Units/Brighten/GLSLBrightenUnit.h</option>
<option value="listing22.html">/Classes/OpenGL/Shaders/Units/Brighten/GLSLBrightenUnit.m</option>
<option value="listing23.html">/Classes/OpenGL/Shaders/Units/ColorInvert/GLSLColorInvertUnit.h</option>
<option value="listing24.html">/Classes/OpenGL/Shaders/Units/ColorInvert/GLSLColorInvertUnit.m</option>
<option value="listing25.html">/Classes/OpenGL/Shaders/Units/Dilation/GLSLDilationUnit.h</option>
<option value="listing26.html">/Classes/OpenGL/Shaders/Units/Dilation/GLSLDilationUnit.m</option>
<option value="listing27.html">/Classes/OpenGL/Shaders/Units/EdgeDetection/GLSLEdgeDetectionUnit.h</option>
<option value="listing28.html">/Classes/OpenGL/Shaders/Units/EdgeDetection/GLSLEdgeDetectionUnit.m</option>
<option value="listing29.html">/Classes/OpenGL/Shaders/Units/Erosion/GLSLErosionUnit.h</option>
<option value="listing30.html">/Classes/OpenGL/Shaders/Units/Erosion/GLSLErosionUnit.m</option>
<option value="listing31.html">/Classes/OpenGL/Shaders/Units/ExtractColor/GLSLExtractColorUnit.h</option>
<option value="listing32.html">/Classes/OpenGL/Shaders/Units/ExtractColor/GLSLExtractColorUnit.m</option>
<option value="listing33.html">/Classes/OpenGL/Shaders/Units/Fog/GLSLFogUnit.h</option>
<option value="listing34.html">/Classes/OpenGL/Shaders/Units/Fog/GLSLFogUnit.m</option>
<option value="listing35.html">/Classes/OpenGL/Shaders/Units/GrayInvert/GLSLGrayInvertUnit.h</option>
<option value="listing36.html">/Classes/OpenGL/Shaders/Units/GrayInvert/GLSLGrayInvertUnit.m</option>
<option value="listing37.html">/Classes/OpenGL/Shaders/Units/Grayscale/GLSLGrayscaleUnit.h</option>
<option value="listing38.html">/Classes/OpenGL/Shaders/Units/Grayscale/GLSLGrayscaleUnit.m</option>
<option value="listing39.html">/Classes/OpenGL/Shaders/Units/HeatSig/GLSLHeatSignatureUnit.h</option>
<option value="listing40.html">/Classes/OpenGL/Shaders/Units/HeatSig/GLSLHeatSignatureUnit.m</option>
<option value="listing41.html">/Classes/OpenGL/Shaders/Units/Saturation/GLSLSaturationUnit.h</option>
<option value="listing42.html">/Classes/OpenGL/Shaders/Units/Saturation/GLSLSaturationUnit.m</option>
<option value="listing43.html">/Classes/OpenGL/Shaders/Units/Sepia/GLSLSepiaUnit.h</option>
<option value="listing44.html">/Classes/OpenGL/Shaders/Units/Sepia/GLSLSepiaUnit.m</option>
<option value="listing45.html">/Classes/OpenGL/Shaders/Units/Sharpen/GLSLSharpenUnit.h</option>
<option value="listing46.html">/Classes/OpenGL/Shaders/Units/Sharpen/GLSLSharpenUnit.m</option>
<option value="listing47.html">/Classes/OpenGL/Shaders/Units/Sky/GLSLSkyUnit.h</option>
<option value="listing48.html">/Classes/OpenGL/Shaders/Units/Sky/GLSLSkyUnit.m</option>
<option value="listing49.html">/Classes/OpenGL/Shaders/Units/Toon/GLSLToonUnit.h</option>
<option value="listing50.html">/Classes/OpenGL/Shaders/Units/Toon/GLSLToonUnit.m</option>
<option value="listing51.html">/Classes/OpenGL/View/OpenGLViewKit.h</option>
<option value="listing52.html">/Classes/OpenGL/View/OpenGLViewKit.m</option>
<option value="listing53.html">/Classes/QT/CoreVideo/QTCoreVideoController.h</option>
<option value="listing54.html">/Classes/QT/CoreVideo/QTCoreVideoController.m</option>
<option value="listing55.html">/Classes/QT/CoreVideo/QTCoreVideoOpenGLView.h</option>
<option value="listing56.html">/Classes/QT/CoreVideo/QTCoreVideoOpenGLView.m</option>
<option value="listing57.html">/Classes/QT/VisualContext/QTVisualContextKit.h</option>
<option value="listing58.html">/Classes/QT/VisualContext/QTVisualContextKit.m</option>
<option value="listing59.html">/main.m</option>
<option value="listing60.html">/QTCoreVideo301_Prefix.pch</option></select>
				</p>
				</form>
				<p><strong><a href="QTCoreVideo301.zip">Download Sample</a></strong> (&#147;QTCoreVideo301.zip&#148;, 1.56M)<BR>
<strong><a href="QTCoreVideo301.dmg">Download Sample</a></strong> (&#147;QTCoreVideo301.dmg&#148;, 1.83M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//---------------------------------------------------------------------------
//
//    File: GLSLKit.m
//
//  Abstract: Utility toolkit for fragement and vertex shaders
//              
//  Disclaimer: IMPORTANT:  This Apple software is supplied to you by
//  Inc. (&quot;Apple&quot;) in consideration of your agreement to the following terms, 
//  and your use, installation, modification or redistribution of this Apple 
//  software constitutes acceptance of these terms.  If you do not agree with 
//  these terms, please do not use, install, modify or redistribute this 
//  Apple software.
//  
//  In consideration of your agreement to abide by the following terms, and
//  subject to these terms, Apple grants you a personal, non-exclusive
//  license, under Apple&apos;s copyrights in this original Apple software (the
//  &quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
//  Software, with or without modifications, in source and/or binary forms;
//  provided that if you redistribute the Apple Software in its entirety and
//  without modifications, you must retain this notice and the following
//  text and disclaimers in all such redistributions of the Apple Software. 
//  Neither the name, trademarks, service marks or logos of Apple Inc. may 
//  be used to endorse or promote products derived from the Apple Software 
//  without specific prior written permission from Apple.  Except as 
//  expressly stated in this notice, no other rights or licenses, express
//  or implied, are granted by Apple herein, including but not limited to
//  any patent rights that may be infringed by your derivative works or by
//  other works in which the Apple Software may be incorporated.
//  
//  The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
//  MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
//  THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
//  FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
//  OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//  
//  IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
//  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//  INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
//  MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
//  AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
//  STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
// 
//  Copyright (c) 2004-2007 Apple Inc., All rights reserved.
//
//---------------------------------------------------------------------------

//------------------------------------------------------------------------

#import &quot;AlertPanelKit.h&quot;
#import &quot;GLSLKit.h&quot;

//------------------------------------------------------------------------

//------------------------------------------------------------------------

struct GLSLAttributes
{
    const GLcharARB    *fragmentShaderSource;    // the GLSL source for our fragment Shader
    const GLcharARB    *vertexShaderSource;        // the GLSL source for our vertex Shader
    GLhandleARB            programObject;            // the program object
};

typedef struct GLSLAttributes   GLSLAttributes;

//------------------------------------------------------------------------

//------------------------------------------------------------------------

#pragma mark -- Compiling shaders &amp; linking a program object --

//------------------------------------------------------------------------

//------------------------------------------------------------------------

static GLhandleARB CompileShader(GLenum theShaderType, const GLcharARB **theShader, GLint *theShaderCompiled) 
{
    GLhandleARB shaderObject = NULL;
    
    if ( *theShader != NULL ) 
    {
        GLint infoLogLength = 0;
        
        shaderObject = glCreateShaderObjectARB(theShaderType);
        
        glShaderSourceARB(shaderObject, 1, theShader, NULL);
        glCompileShaderARB(shaderObject);
        
        glGetObjectParameterivARB(shaderObject, GL_OBJECT_INFO_LOG_LENGTH_ARB, &amp;infoLogLength);
        
        if (infoLogLength &gt; 0) 
        {
            GLcharARB *infoLog = (GLcharARB *)malloc(infoLogLength);
            
            if (infoLog != NULL)
            {
                glGetInfoLogARB(shaderObject, infoLogLength, &amp;infoLogLength, infoLog);
                
                NSLog(@&quot;&gt;&gt; [OpenGL Shader Kit] Shader compile log:\n%s\n&quot;, infoLog);
                
                free(infoLog);
            } // if
        } // if

        glGetObjectParameterivARB(shaderObject, GL_OBJECT_COMPILE_STATUS_ARB, theShaderCompiled);
        
        if ( *theShaderCompiled == 0 )
        {
            [[AlertPanelKit withTitle:@&quot;OpenGL Shader Kit&quot; 
                              message:@&quot;WARNING: Failed to compile shader!&quot;
                                 exit:NO] displayAlertPanel];

            NSLog(@&quot;&gt;&gt; [OpenGL Shader Kit] WARNING: Failed to compile shader!\n%s\n&quot;, theShader);
        } // if
    } // if
    else 
    {
        *theShaderCompiled = 0;
    } // else
    
    return shaderObject;
} // CompileShader

//------------------------------------------------------------------------

static BOOL LinkProgram(GLhandleARB programObject) 
{
    GLint  infoLogLength = 0;
    GLint  programLinked = 0;
    BOOL   linkSuccess   = NO;
    
    glLinkProgramARB(programObject);
    
    glGetObjectParameterivARB(programObject , GL_OBJECT_INFO_LOG_LENGTH_ARB, &amp;infoLogLength);
    
    if (infoLogLength &gt;  0) 
    {
        GLcharARB *infoLog = (GLcharARB *)malloc(infoLogLength);
        
        if (infoLog != NULL)
        {
            glGetInfoLogARB(programObject, infoLogLength, &amp;infoLogLength, infoLog);
            
            NSLog(@&quot;&gt;&gt; [OpenGL Shader Kit] Program link log:\n%s\n&quot;, infoLog);
            
            free(infoLog);
        } // if
    } // if
    
    glGetObjectParameterivARB(programObject, GL_OBJECT_LINK_STATUS_ARB, &amp;programLinked);
    
    if ( programLinked == 0 )
    {
        [[AlertPanelKit withTitle:@&quot;OpenGL Shader Kit&quot; 
                          message:@&quot;WARNING: Failed to link program!&quot;
                             exit:NO] displayAlertPanel];

        NSLog(@&quot;&gt;&gt; [OpenGL Shader Kit] WARNING: Failed to link program 0x%lx\n&quot;, (GLint)&amp;programObject);
    } // if
    else
    {
        linkSuccess = YES;
    } // else
    
    return  linkSuccess;
} // LinkProgram

//------------------------------------------------------------------------

static GLhandleARB GetShader(GLenum theShaderType, GLSLAttributesRef theShaderAttributes)
{
    GLhandleARB  shaderHandle   = NULL;
    GLint        shaderCompiled = GL_FALSE;
        
    switch( theShaderType )
    {
        case GL_VERTEX_SHADER_ARB:
            
            shaderHandle = CompileShader(theShaderType, &amp;theShaderAttributes-&gt;vertexShaderSource, &amp;shaderCompiled);
            break;
            
        case GL_FRAGMENT_SHADER_ARB:
        
        default:
            
            shaderHandle = CompileShader(theShaderType, &amp;theShaderAttributes-&gt;fragmentShaderSource, &amp;shaderCompiled);
            break;
    } // switch
            
    if ( !shaderCompiled ) 
    {
        if ( shaderHandle ) 
        {
            glDeleteObjectARB(shaderHandle);
            shaderHandle = NULL;
        } // if
    } // if
    
    return shaderHandle;
} // GetShader

//------------------------------------------------------------------------

static GLhandleARB NewProgramObject(GLhandleARB theVertexShader, GLhandleARB theFragmentShader)
{
    GLhandleARB programObject = NULL;
    
    // Create a program object and link shaders
    
    if ( ( theVertexShader != NULL ) || ( theFragmentShader != NULL ) )
    {
        programObject = glCreateProgramObjectARB( );
        
        if ( programObject != NULL )
        {
            BOOL fragmentShaderAttached = NO;
            BOOL vertexShaderAttached   = NO;
            BOOL programObjectLinked    = NO;
            
            if ( theVertexShader != NULL )
            {
                vertexShaderAttached = YES;
                
                glAttachObjectARB(programObject, theVertexShader);
                glDeleteObjectARB(theVertexShader);   // Release
                
                theVertexShader = NULL;
            } // if
            
            if ( theFragmentShader != NULL )
            {
                fragmentShaderAttached = YES;
                
                glAttachObjectARB(programObject, theFragmentShader);
                glDeleteObjectARB(theFragmentShader); // Release
                
                theFragmentShader = NULL;
            } // if
            
            if ( vertexShaderAttached || fragmentShaderAttached )
            {
                programObjectLinked = LinkProgram(programObject);

                if ( !programObjectLinked ) 
                {
                    glDeleteObjectARB(programObject);
                    
                    programObject = NULL;
                } // if
            } // if
        } // if
    } // if
    
    return programObject;
} // NewProgramObject

//------------------------------------------------------------------------

static BOOL GetProgramObject(GLSLAttributesRef theShaderAttributes)
{
    BOOL  newProgramObject = NO;
    
    // Load and compile both shaders
    
    GLhandleARB vertexShader   = GetShader(GL_VERTEX_SHADER_ARB, theShaderAttributes);
    GLhandleARB fragmentShader = GetShader(GL_FRAGMENT_SHADER_ARB, theShaderAttributes);
    
    // Create a program object and link both shaders
            
    theShaderAttributes-&gt;programObject = NewProgramObject(vertexShader, fragmentShader);
    
    if ( theShaderAttributes-&gt;programObject != NULL )
    {
        newProgramObject = YES;
    } // if
    
    return  newProgramObject;
} // GetProgramObject

//------------------------------------------------------------------------

static BOOL ValidateProgramObject(GLSLAttributesRef theShaderAttributes)
{
    BOOL  programObjectValidated = YES;
    GLint validateStatusSuccess;

    glValidateProgramARB(theShaderAttributes-&gt;programObject);
    
    glGetObjectParameterivARB(theShaderAttributes-&gt;programObject, GL_VALIDATE_STATUS, &amp;validateStatusSuccess);
    
    if ( !validateStatusSuccess )
    {
        GLint  infoLogLength = 0;
        
        glGetObjectParameterivARB(theShaderAttributes-&gt;programObject , GL_OBJECT_INFO_LOG_LENGTH_ARB, &amp;infoLogLength);
        
        if (infoLogLength &gt;  0) 
        {
            GLcharARB *infoLog = (GLcharARB *)malloc(infoLogLength);
            
            if (infoLog != NULL)
            {
                glGetInfoLogARB(theShaderAttributes-&gt;programObject, infoLogLength, &amp;infoLogLength, infoLog);                

                [[AlertPanelKit withTitle:@&quot;OpenGL Shader Kit&quot; 
                                  message:@&quot;ERROR: In validating program object!&quot;
                                     exit:NO] displayAlertPanel];

                NSLog(@&quot;&gt;&gt; [OpenGL Shader Kit] ERROR: In validating program object!\n%s\n&quot;, infoLog);
                
                free( infoLog );
            } // if
        } // if
        
        programObjectValidated = NO;
    } // if
    
    return  programObjectValidated;
} // ValidateProgramObject

//------------------------------------------------------------------------

static GLint GetUniformLocation(GLhandleARB theProgramObject, const GLcharARB *theUniformName)
{
    GLint uniformLoacation = glGetUniformLocationARB(theProgramObject, theUniformName);
    
    if (uniformLoacation == -1) 
    {
        NSString *alertMessage = [NSString stringWithFormat:@&quot;WARNING: No such uniform named \&quot;%s\&quot;&quot;,theUniformName];
        
        if ( alertMessage )
        {
            [[AlertPanelKit withTitle:@&quot;OpenGL Shader Kit&quot; 
                              message:alertMessage
                                 exit:NO] displayAlertPanel];
        } // if
        
        NSLog( @&quot;&gt;&gt; [OpenGL Shader Kit] WARNING: No such uniform named \&quot;%s\&quot;!&quot;, theUniformName );
    } // if

    return uniformLoacation;
} // getUniformLocation

//------------------------------------------------------------------------

//------------------------------------------------------------------------

#pragma mark -- Check for extensions --

//------------------------------------------------------------------------

//------------------------------------------------------------------------

static inline GLboolean CheckForExtension(const char *extensionName, const GLubyte *extensions)
{
    GLboolean  bExtensionAvailable = gluCheckExtension((GLubyte *)extensionName, extensions);
    
    return bExtensionAvailable;
} // CheckForExtension

//------------------------------------------------------------------------

static inline void CheckForAndLogExtensionAvailable(const GLboolean extensionAvailable, const char *extensionName)
{
    if (extensionAvailable == GL_FALSE)
    {
        NSString *alertMessage = [NSString stringWithFormat:@&quot;WARNING: \&quot;%s\&quot; extension is not available!&quot;,extensionName];
        
        if ( alertMessage )
        {
            [[AlertPanelKit withTitle:@&quot;OpenGL Shader Kit&quot; 
                              message:alertMessage
                                 exit:NO] displayAlertPanel];
        } // if
        
        NSLog(@&quot;&gt;&gt; [OpenGL Shader Kit] WARNING: \&quot;%s\&quot; extension is not available!&quot;, extensionName);
    } // if
} // CheckForExtensions

//------------------------------------------------------------------------

static BOOL SoftwareRendering( )
{
    const GLubyte *extensions = glGetString(GL_EXTENSIONS);
    
    GLboolean  bShaderObjectAvailable      = CheckForExtension(       &quot;GL_ARB_shader_objects&quot;, extensions);
    GLboolean  bShaderLanguage100Available = CheckForExtension( &quot;GL_ARB_shading_language_100&quot;, extensions);
    GLboolean  bVertexShaderAvailable      = CheckForExtension(        &quot;GL_ARB_vertex_shader&quot;, extensions);
    GLboolean  bFragmentShaderAvailable    = CheckForExtension(      &quot;GL_ARB_fragment_shader&quot;, extensions);
    
    BOOL  bSoftwareRendering =        ( bShaderObjectAvailable      == GL_FALSE )
                                ||    ( bShaderLanguage100Available == GL_FALSE )
                                ||    ( bVertexShaderAvailable      == GL_FALSE ) 
                                ||    ( bFragmentShaderAvailable    == GL_FALSE );
    
    if ( bSoftwareRendering )
    {
        // Software rendering, so fragment shaders will excuteWithCVTexture

        CheckForAndLogExtensionAvailable(      bShaderObjectAvailable,       &quot;GL_ARB_shader_objects&quot; );
        CheckForAndLogExtensionAvailable( bShaderLanguage100Available, &quot;GL_ARB_shading_language_100&quot; );
        CheckForAndLogExtensionAvailable(      bVertexShaderAvailable,        &quot;GL_ARB_vertex_shader&quot; );
        CheckForAndLogExtensionAvailable(    bFragmentShaderAvailable,      &quot;GL_ARB_fragment_shader&quot; );
    } // if
    
    return  bSoftwareRendering;
} // SoftwareRendering

//------------------------------------------------------------------------

//------------------------------------------------------------------------

@implementation GLSLKit

//------------------------------------------------------------------------

#pragma mark -- Get shaders from resource --

//------------------------------------------------------------------------

- (GLcharARB *) getShaderSourceFromResource:(NSString *)theShaderResourceName extension:(NSString *)theExtension
{
    NSBundle  *appBundle         = [NSBundle mainBundle];
    NSString  *shaderTempSource  = [appBundle pathForResource:theShaderResourceName ofType:theExtension];
    GLcharARB *shaderSource      = NULL;
    
    shaderTempSource = [NSString stringWithContentsOfFile:shaderTempSource];
    shaderSource     = (GLcharARB *)[shaderTempSource cStringUsingEncoding:NSASCIIStringEncoding];
    
    return  shaderSource;
} // getShaderSourceFromResource

//------------------------------------------------------------------------

- (void) getFragmentShaderSourceFromResource:(NSString *)theFragmentShaderResourceName
{
    shaderAttributes-&gt;fragmentShaderSource 
        = [self getShaderSourceFromResource:theFragmentShaderResourceName extension:@&quot;fs&quot; ];
} // getFragmentShaderSourceFromResource

//------------------------------------------------------------------------

- (void) getVertexShaderSourceFromResource:(NSString *)theVertexShaderResourceName
{
    shaderAttributes-&gt;vertexShaderSource 
        = [self getShaderSourceFromResource:theVertexShaderResourceName extension:@&quot;vs&quot; ];
} // getVertexShaderSourceFromResource

//------------------------------------------------------------------------

- (BOOL) getProgramObject:(NSString *)theShadersName
{
    BOOL  gotProgramObject       = NO;
    BOOL  validatedProgramObject = NO;

    gotProgramObject = GetProgramObject(shaderAttributes);
    
    if (!gotProgramObject)
    {
        NSString *alertMessage = [NSString stringWithFormat:@&quot;WARNING: Failed to compile+link GLSL \&quot;%@\&quot; fragment and/or vertex shader(s)!&quot;,theShadersName];
        
        if ( alertMessage )
        {
            [[AlertPanelKit withTitle:@&quot;OpenGL Shader Kit&quot; 
                              message:alertMessage
                                 exit:NO] displayAlertPanel];
        } // if

        NSLog(@&quot;&gt;&gt; [OpenGL Shader Kit] WARNING: Failed to compile+link GLSL \&quot;%@\&quot; fragment and/or vertex shader(s)!&quot;, theShadersName);
    } // if
    else
    {
        validatedProgramObject = ValidateProgramObject(shaderAttributes);
        
        if (!validatedProgramObject)
        {
            [[AlertPanelKit withTitle:@&quot;OpenGL Shader Kit&quot; 
                              message:@&quot;&gt;&gt; WARNING: Failed to validate the program object!&quot;
                                 exit:NO] displayAlertPanel];

            NSLog(@&quot;&gt;&gt; [OpenGL Shader Kit] WARNING: Failed to validate the program object!&quot;);
        } // if
    } // else
    
    return ( gotProgramObject &amp;&amp; validatedProgramObject );
} // getProgramObject

//------------------------------------------------------------------------

- (BOOL) getShadersFromResource:(NSString *)theShadersName
{
    BOOL  shadersReadyToUse = NO;
    
    shaderAttributes = (GLSLAttributesRef)[self pointer];
    
    if ( [self isPointerValid] )
    {
        // Load vertex and fragment shaders
        
        [self getVertexShaderSourceFromResource:theShadersName];
        [self getFragmentShaderSourceFromResource:theShadersName];

        shadersReadyToUse = [self getProgramObject:theShadersName];
    } // if
    else
    {
        [[AlertPanelKit withTitle:@&quot;OpenGL Shader Kit&quot; 
                          message:@&quot;Failure Allocating Memory For Shader Attributes&quot;
                             exit:NO] displayAlertPanel];
    } // else
    
    return  shadersReadyToUse;
} // getShadersFromResource

//------------------------------------------------------------------------

#pragma mark -- Designated initializer --

//------------------------------------------------------------------------

- (id) initWithGLSLShadersInAppBundle:(NSString *)theShadersName
{    
    self = [super initMemoryWithType:kMemAlloc size:sizeof(GLSLAttributes)];
    
    if ( self )
    {
        if ( !SoftwareRendering( ) )
        {    
            [self getShadersFromResource:theShadersName];
        } // if
    } // if
    
    return self;
} // initWithShadersInAppBundle

//------------------------------------------------------------------------

#pragma mark -- Deallocating Resources --

//------------------------------------------------------------------------

- (void) dealloc
{
    // Delete OpenGL resources
    
    if ( shaderAttributes-&gt;programObject != NULL )
    {
        glDeleteObjectARB( shaderAttributes-&gt;programObject );
    } // if
    
    //Dealloc the superclass
    
    [super dealloc];
} // dealloc

//------------------------------------------------------------------------

#pragma mark -- Accessors --

//------------------------------------------------------------------------

- (void) enable
{
    // For details on glUseProgramObjectARB refer to:
    //
    // http://developer.3dlabs.com/openGL2/slapi/UseProgramObjectARB.htm
    
    glUseProgramObjectARB( shaderAttributes-&gt;programObject );
} // enable

//------------------------------------------------------------------------

- (void) disable
{
    glUseProgramObjectARB( NULL );
} // disable

//------------------------------------------------------------------------

- (GLint) uniformLocation:(NSString *)theUniformName
{
    GLint uniformLoacation = -1;
    
    if ( theUniformName )
    {
        const GLcharARB *uniformName = (GLcharARB *)[theUniformName cStringUsingEncoding:NSASCIIStringEncoding];
        
        uniformLoacation = GetUniformLocation( shaderAttributes-&gt;programObject, uniformName );
    } // if
    
    return uniformLoacation;
} // getUniformLocation

//------------------------------------------------------------------------

@end

//------------------------------------------------------------------------

//------------------------------------------------------------------------

</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/QTCoreVideo301/listing12.html%3Fid%3DDTS40007785-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/QTCoreVideo301/listing12.html%3Fid%3DDTS40007785-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/QTCoreVideo301/listing12.html%3Fid%3DDTS40007785-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>