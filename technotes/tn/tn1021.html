<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1021: Creating Off-Screen Bitmaps When Speed is Critical</title>    <meta name="keywords" content="Mac OS 8 creating off-screen bitmap eliminating grafports quickdraw">    <meta name="Description" content="Technical Note TN1021: This Technical Note provides an exampleof creating an off-screen bitmap by hand, drawing to it,and then copying from it to the screen. This technique isuseful for the creation of regions when OpenRgn is not anoption. This Technical note includes sample code that illustratesCreating an Off-Screen Bitmap and eliminating an offscreenbitmap in C, and Pascal."><meta name="categories" content="QuickDraw"><meta name="week-posted" content="Jan 29, 1996 - Feb 2, 1996"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002863" title="Creating Off-Screen Bitmaps When Speed is Critical"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/GraphicsImaging/idxPerformance-date.html" target="_blank">Graphics & Imaging > Performance</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1021</div>
<div id="pageheadsub">Creating Off-Screen Bitmaps When Speed is Critical</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td></tr><tr bgcolor="#e6e6e6">    <td background="images/tnmenubody.gif" width=300 align=left><span id="menutitle">    CONTENTS     <BR>    <BR></span>    </td></tr><tr bgcolor="#e6e6e6">    <td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext"><A HREF = "#RTFToC1">Drawing Off-Screen Bitmaps</a><br><br><A HREF = "#Summary">Summary</a><br><br><A HREF = "#References">References</a><br><br><A HREF="#Downloads">Downloadables</A></P>   <!-- end_toc -->  </td></tr> <tr>    <td width=300 align=left scope="row"><img src="images/tnmenubottom.gif" alt="" width=300 height=16>    </td></tr>    </table></td><td width=300 valign="top" align=left><!-- begin_intro_text -->  <P id = "introtext">This Technote provides an example of creating an off-screen bitmap by hand,drawing to it, and then copying from it to the screen. Apple encourages the useof GWorlds for your off-screen needs. In some cases, however, creating your ownoff-screens can be beneficial. The resulting off-screen bitmaps can be usedlike a 1-bit GWorld, but with improved performance.</p><P id = "introtext">This technique is useful for the creation of regions when OpenRgn is not anoption. For example, in making a region from a line, draw the line in anoffscreen and call BitMapToRegion to convert the offscreen's bitmap to aregion. These offscreen bitmaps can be also be substituted for pixmaps inroutines such as CopyMask, where the mask is black and white, and speed is ofgreat importance.</p><P id = "introtext">This Technote is written primarily for those involved in speed-criticalprojects, such as game developers and graphics applications developers.</p><TABLE BORDER=0 WIDTH=275><TR><td bgcolor="#E6E6E6" align=left><P id = "introtext"><B>Note: </B><BR>This technique for creating off-screen bitmaps is intended forblack and white uses only. If your needs include only color ports, you shouldreview Macintosh Technical Note <A HREF = "../qd/qd_13.html">QD 13 - "Principia Off-Screen Graphics Environments."</a></p></TD></TR></TABLE><!-- end_intro_text --><!-- begin_date --><h3 align=center>&nbsp;[Feb 1 1996]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR> <!-- begin_content --><a name="RTFToC1"></a><h2>Drawing Off-Screen Bitmaps</h2><P>The following is an example of creating and drawing to an off-screen bitmap,then copying from it to an on-screen window. The example is supplied in both aC and Pascal versions, and will work with all compilers.</p><h3>Creating an Off-Screen Bitmap in C</h3><P>Let's look at a general purpose function to create an off-screen bitmap. Thisfunction creates the GrafPort on the heap. You can also create it on the stackand pass the uninitialized structure to a function similar to this one.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Boolean CreateOffscreenBitMap(GrafPtr *newOffscreen, Rect *inBounds){    GrafPtr savePort;    GrafPtr newPort;    GetPort(&amp;savePort);    /* need this to restore thePort after OpenPort */    newPort = (GrafPtr) NewPtr(sizeof(GrafPort));    /* allocate the grafPort */    if (MemError() != noErr)        return false;        /* failed to allocate the off-screen port */    /*    the call to OpenPort does the following . . .        allocates space for visRgn (set to screenBits.bounds) and        clipRgn (set wide open)        sets portBits to screenBits        sets portRect to screenBits.bounds        (See Inside Mac: Imaging with QuickDraw,        pages 2-38 to 2-39)        side effect: does a SetPort(&amp;offScreen)    */    OpenPort(newPort);    /* make bitmap the size of the bounds that caller supplied */    newPort-&gt;portRect = *inBounds;    newPort-&gt;portBits.bounds = *inBounds;    RectRgn(newPort-&gt;clipRgn, inBounds);    /* avoid wide-open clipRgn, be safe  */    RectRgn(newPort-&gt;visRgn, inBounds);    /* in case newBounds is screen bounds */    /* rowBytes is size of row, it must be rounded up to an even number of bytes */    newPort-&gt;portBits.rowBytes = ((inBounds-&gt;right - inBounds-&gt;left +                            15) &gt;&gt; 4) &lt;&lt; 1;    /* number of bytes in BitMap is rowBytes * number of rows */    /* see notes at end of Technote about using _NewHandle rather than _NewPtr*/    newPort-&gt;portBits.baseAddr =            NewPtr(newPort-&gt;portBits.rowBytes * (long) (inBounds-&gt;bottom                                - inBounds-&gt;top));    if (newPort-&gt;portBits.baseAddr == nil) { /* check to see if we had                        enough room for the bits */        SetPort(savePort);        ClosePort(newPort);      /* dump the visRgn and clipRgn */        DisposPtr((Ptr)newPort); /* dump the GrafPort */        return false;            /* tell caller we failed */        }    /* since the bits are just memory, let's clear them before we start*/    EraseRect(inBounds);     /* OpenPort did a SetPort(newPort) so we are ok */    *newOffscreen = newPort;    SetPort(savePort);    return true;               /* tell caller we succeeded! */}</pre>	</TD></TR></TABLE></CENTER><h3>Eliminating an Off-Screen Bitmap in C</h3><P>To eliminate an off-screen bitmap created by the previous function, use thisfunction: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>void DestroyOffscreenBitMap(GrafPtr oldOffscreen){    ClosePort(oldOffscreen);            /* dump the visRgn and clipRgn */    DisposPtr(oldOffscreen-&gt;portBits.baseAddr);    /* dump the bits */    DisposPtr((Ptr)oldOffscreen);            /* dump the port */}</pre>	</TD></TR></TABLE></CENTER><h3>Using an Off-Screen Bitmap in C</h3><P>Now that you know how to create and destroy an off-screen bitmap, let's gothrough the motions of using one. First, let's define a few things to make theNewWindow call a little clearer.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#define kIsVisible true#define kNoGoAway false#define kNoWindowStorage 0L#define kFrontWindow ((WindowPtr) -1L)</pre>	</TD></TR></TABLE></CENTER><P>Here's the body of the test code: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>main(){    char* myString = &quot;\pThe EYE&quot;;  /* string to display */    GrafPtr   offscreen;           /* our off-screen bitmap */    Rect      ovalRect;            /* used for example drawing */    Rect      myWBounds;           /* for creating window */    Rect      OSRect;              /* portRect and bounds for off-screen bitmap*/    WindowPtr myWindow;    InitToolbox();                 /* exercise for the reader */    myWBounds = qd.screenBits.bounds;  /* size of main screen */    InsetRect(&amp;myWBounds, 50,50);  /* make it fit better */    myWindow = NewWindow(kNoWindowStorage, &amp;myWBounds, &quot;\pTest Window&quot;,                    kIsVisible,noGrowDocProc, kFrontWindow,                    kNoGoAway, 0);    if (!CreateOffscreenBitMap(&amp;offscreen, &amp;myWindow-&gt;portRect)) {        SysBeep(1);        ExitToShell();        }    /* Example drawing to our off-screen bitmap*/    SetPort(offscreen);    OSRect = offscreen-&gt;portRect;  /* offscreen bitmap's local coordinate rect */    ovalRect = OSRect;    FillOval(&amp;ovalRect, qd.black);    InsetRect(&amp;ovalRect, 1, 20);    FillOval(&amp;ovalRect, qd.white);    InsetRect(&amp;ovalRect, 40, 1);    FillOval(&amp;ovalRect, qd.black);    MoveTo((ovalRect.left + ovalRect.right - StringWidth(myString)) &gt;&gt; 1,                (ovalRect.top + ovalRect.bottom - 12) &gt;&gt; 1);    TextMode(srcXor);    DrawString(myString);    /* copy from the off-screen bitmap to the on-screen window.  Note    that in this case the source and destination rects are the same size    and both cover the entire area.  These rects are allowed to be    portions of the source and/or destination and do not have to be the    same size.  If they are not the same size then _CopyBits scales the    image accordingly.    */    SetPort(myWindow);    CopyBits(&amp;offscreen-&gt;portBits, &amp;(*myWindow).portBits,        &amp;offscreen-&gt;portRect, &amp;(*myWindow).portRect, srcCopy, 0L);    DestroyOffscreenBitMap(offscreen);    /* dump the off-screen bitmap*/    while (!Button());     /* give user a chance to see our work of art*/}</pre>	</TD></TR></TABLE></CENTER><h3>Creating an Off-Screen Bitmap in Pascal</h3><P>Let's look at a general purpose function to create an off-screen bitmap. Thisfunction creates the GrafPort on the heap. You can also create it on the stackand pass the uninitialized structure to a function similar to this one.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>FUNCTION CreateOffscreenBitMap(VAR newOffscreen: GrafPtr; inBounds: Rect)                : BOOLEAN;    savePort  : GrafPtr;    newPort   : GrafPtr;    GetPort(savePort);    {need this to restore thePort after OpenPort changes it}    newPort : = GrafPtr(NewPtr(sizeof(GrafPort)));    {allocate the GrafPort}    IF MemError &lt;&gt; noErr THEN BEGIN        CreateOffscreenBitMap : = false;    {failed to allocate it}        EXIT(CreateOffscreenBitMap);    END;    {    the OpenPort call does the following . . .    allocates space for visRgn (set to screenBits.bounds) and clipRgn    (set wide open)    sets portBits to screenBits    sets portRect to screenBits.bounds    (See Inside Mac: Imaging with QuickDraw, pages 2-38 to 2-39)    side effect: does a SetPort(offScreen)    }    OpenPort(newPort);    {make bitmap exactly the size of the bounds that caller supplied}    WITH newPort^ DO BEGIN {portRect, clipRgn, and visRgn are in newPort}        portRect : = inBounds;        RectRgn(clipRgn, inBounds);    {avoid wide-open clipRgn, to be safe}        RectRgn(visRgn, inBounds);    {in case inBounds is &gt; screen bounds}    END;    WITH newPort^.portBits DO BEGIN    {baseAddr, rowBytes and bounds are in newPort}        bounds : = inBounds;        {rowBytes is size of row  It must be rounded up to even number of bytes}        rowBytes : = ((inBounds.right - inBounds.left + 15) DIV 16) * 2;        {number of bytes in BitMap is rowBytes * number of rows}        {see note at end of Technical Note about using _NewHandle rather than _NewPtr}        baseAddr : = NewPtr(rowBytes * LONGINT(inBounds.bottom - inBounds.top));    END;    IF baseAddr == nilTHEN BEGIN    {see if we had enough room for the bits}        SetPort(savePort);        ClosePort(newPort);              {dump the visRgn and clipRgn }        DisposPtr(Ptr(newPort));         {dump the GrafPort}        CreateOffscreenBitMap : = false;    END    ELSE BEGIN        {since the bits are just memory, let's erase them before we start }        EraseRect(inBounds);    {OpenPort did a SetPort(newPort)}        newOffscreen : = newPort;        SetPort(savePort);        CreateOffscreenBitMap : = true;    END;</pre>	</TD></TR></TABLE></CENTER><h3>Eliminating an Off-Screen Bitmap in Pascal</h3><P>Here is the procedure to get rid of an off-screen bitmap created by theprevious function: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>PROCEDURE DestroyOffscreenBitMap(oldOffscreen : GrafPtr);    ClosePort(oldOffscreen);        {dump the visRgn and clipRgn }    DisposPtr(oldOffscreen^.portBits.baseAddr);    {dump the bits }    DisposPtr(Ptr(oldOffscreen));            {dump the port };</pre>	</TD></TR></TABLE></CENTER><h3>Using an Off-Screen Bitmap: MPW Pascal</h3><P>Now that you know how to create and destroy an off-screen bitmap, let's testone out. First, let's define a few things to make the NewWindow call a littleclearer.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>CONST    kIsVisible   = true;    kNoGoAway    = false;    kMakeFrontWindow = -1;    myString     = 'The EYE';  {string to display}</pre>	</TD></TR></TABLE></CENTER><P>Here's the body of the test code: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>VAR    offscreen : GrafPtr;    {our off-screen bitmap}    ovalRect  : Rect;       {used for example drawing}    myWBounds : Rect;       {for creating window}    OSRect    : Rect;       {portRect and bounds for off-screen bitmap}    myWindow  : WindowPtr;    InitToolbox;                       {exercise left to the reader}    myWBounds : = screenBits.bounds;    {size of main screen }    InsetRect(myWBounds, 50,50);       {make it fit better }    myWindow : = NewWindow(NIL, myWBounds, 'Test Window', kIsVisible,            noGrowDocProc, WindowPtr(kMakeFrontWindow), kNoGoAway, 0);    IF NOT CreateOffscreenBitMap(offscreen,myWindow^.portRect) THEN BEGIN        SysBeep(1);        ExitToShell;    END;    {Example drawing to our off-screen bitmap }    SetPort(offscreen);    OSRect : = offscreen^.portRect;    {offscreen bitmap's local coordinate rect }    ovalRect : = OSRect;    FillOval(ovalRect, black);    InsetRect(ovalRect, 1, 20);    FillOval(ovalRect, white);    InsetRect(ovalRect, 40, 1);    FillOval(ovalRect, black);    WITH ovalRect DO        MoveTo((left+right-StringWidth(myString)) DIV 2, (top+bottom-12) DIV 2);    TextMode(srcXor);    DrawString(myString);    {copy from the off-screen bitmap to the on-screen window.  Note    that in this case the source and destination rects are the same size    and both cover the entire area.  These rects are allowed to be    portions of the source and/or destination and do not have to be the    same size.  If they are not the same size then _CopyBits scales the    image accordingly}    SetPort(myWindow);    CopyBits(offscreen^.portBits, myWindow^.portBits,            offscreen^.portRect, myWindow^.portRect, srcCopy, NIL);    DestroyOffscreenBitMap(offscreen);    {remove the evidence}    WHILE NOT Button DO;    {give user a chance to see the results}.</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><a name = "Summary"></a><h2>Summary</h2><P>In the example code, the bits of the BitMap structure pointed to by thebaseAddr field are allocated by a NewPtr call.</p><P>Keeping a large off-screen around for any length of time may lead to heapfragmentation. One alternative that lessens this problem is to get the bits viaNewHandle, so that the Memory Manager can move them when necessary. Toimplement this approach, you need to keep the handle separate from the GrafPort(for example, in a structure that combines a GrafPort and a Handle). When usingthe off-screen bitmap, lock the handle and put the dereferenced handle into thebaseAddr field. You can then unlock the handle when not using the off-screenbitmap.</p><P><A HREF="#top">Back to top</A></P><A NAME="References"></a><H2>References</h2><p><a href="../../documentation/mac/QuickDraw/QuickDraw-2.html"><i>Inside Macintosh: Imaging with QuickDraw</i></A></p> <P><A HREF="#top">Back to top</A></P>          <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (56K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1021.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER>		<!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1021.html%3Fid%3DDTS10002863-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1021.html%3Fid%3DDTS10002863-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1021.html%3Fid%3DDTS10002863-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>