<HTML><head><script language="JavaScript" src="../../RM/frametest.js"></script><TITLE> New Data Handler APIs</TITLE><script language=javascript> window.parent.focus(); </script></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><!-- QTnavbar start --><P><I>What's New in QuickTime 5</I><P>| <A HREF="Max.7b.htm">Previous</A> | <A HREF="Max.1.htm">Chapter Contents</A> | <A HREF="Max.htm">Chapter Top</A> | <A HREF="Max.7d.htm">Next</A> |</P></DIV><!-- QTnavbar end --><H1 CLASS="H1.Heading1"><A NAME="pgfId=62942"> </A>New Data Handler APIs</H1><P CLASS="T1.Text1"><A NAME="pgfId=62943"> </A>QuickTime&nbsp;5 includes the addition of new data handler APIs -- <TT CLASS="cv">DataHGetFileTypeOrdering</TT><A NAME="marker=88224"> </A> and <TT CLASS="cv">DataHGetMIMETypeAsync</TT><A NAME="marker=88225"> </A>, discussed in this section. </P><P CLASS="T1.Text1"><A NAME="pgfId=62945"> </A>The <TT CLASS="cv">DataHGetFileTypeOrdering </TT>call allows for returning a list defining the order that file type-related information should be considered (for example, file type, file extension, MIME type) by a client. This allows a data handler such the URL data handler to indicate that MIME type information is more useful than, say, filename extension or Mac OS file type. </P><P CLASS="T1.Text1"><A NAME="pgfId=77731"> </A>The <TT CLASS="cv">DataHGetMIMETypeAsync</TT> call has been introduced in order to remove synchronous blocks from QuickTime's movie opening code. </P><P CLASS="T1.Text1"><A NAME="pgfId=78554"> </A>QuickTime&nbsp;5 also introduces a Pointer data handler, which supports references to data in memory. </P><DIV><H4 CLASS="RoH.RoutineHeading"><A NAME="pgfId=62946"> </A>DataHGetFileTypeOrdering</H4><P CLASS="T1.Text1"><A NAME="pgfId=62947"> </A>Returns a handle of OSTypes which defines a preferred ordering for file typing information.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=98064"> </A>ComponentResult DataHGetFileTypeOrdering(DataHandler dh,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataHFileTypeOrderingHandle * orderingListHandle);</code><br><P CLASS="T1.Text1"><A NAME="pgfId=62949"> </A><A NAME="marker=98066"> </A>The OSTypes in the list can have one of these values:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=98070"> </A>// Types for DataHGetFileTypeOrdering<BR>enum {<BR>&nbsp;&nbsp;&nbsp;&nbsp;kDataHFileTypeMacOSFileType= 'ftyp',<BR>&nbsp;&nbsp;&nbsp;&nbsp;kDataHFileTypeExtension= 'fext',<BR>&nbsp;&nbsp;&nbsp;&nbsp;kDataHFileTypeMIME= 'mime'<BR> };</code><br><DIV><H5 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=62951"> </A>DISCUSSION</H5><P CLASS="T1.Text1"><A NAME="pgfId=62952"> </A>This is a new optional data handler component API that allows for returning a handle of OSTypes. The returned handle may only contain a subset of the currently defined types (i.e., Mac OS file type, extension, MIME type) to limit the consideration to reasonable types. For example, a Mac OS file type isn't meaningful if a data handler doesn't know it. </P><P CLASS="T1.Text1"><A NAME="pgfId=62953"> </A>Before making a call to <TT CLASS="cv">DataHGetFileTypeOrdering</TT>, the client should have opened the data handler and called <TT CLASS="cv">DataHSetDataRef</TT> or <TT CLASS="cv">DataHSetDataRefWithAnchor</TT>. This allows the data handler to return a different ordering based on the particular file. This might allow for a data handler to vary its ordering based on the location of the file. For example, on the Mac OS, it might use extensions only on foreign volumes. For other volumes, it might use a Mac OS file type followed by a file extension.</P><P CLASS="Note"><A NAME="pgfId=90625"> </A>If the data handler has not set the data reference, it can either choose to return an error, or a reasonable default ordering list. </P></DIV></DIV><DIV><H4 CLASS="RoH.RoutineHeading"><A NAME="pgfId=90629"> </A>GetMovieImporterForDataRef (Updated)</H4><P CLASS="T1.Text1"><A NAME="pgfId=90626"> </A>The <TT CLASS="cv">GetMovieImporterForDataRef</TT> function has been updated to call <TT CLASS="cv">DataHGetMIMETypeAsync</TT> if instructed to do so. There is a new flag <TT CLASS="cv">kGetMovieImporterUseAsyncCalls</TT> that the client can pass to indicate this behavior. If <TT CLASS="cv">GetMovieImporterForDataRef</TT> is allowed to use async calls, it should return <TT CLASS="cv">notEnoughDataErr</TT> if it would block. Without this flag, the call may block.</P></DIV><DIV><H4 CLASS="RoH.RoutineHeading"><A NAME="pgfId=77571"> </A>DataHGetMIMETypeAsync</H4><P CLASS="T1.Text1"><A NAME="pgfId=77744"> </A>Accommodates asynchronous discovery of a HTTP/FTP connection's MIME type. </P><CODE CLASS="Cv.Code"><A NAME="pgfId=98074"> </A>pascal ComponentResult DataHGetMIMETypeAsync(DataHandler dh, Str255 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mimeType, DataHCompletionUPP <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completionRtn, long refCon);</code><br><DIV><H5 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=77709"> </A><A NAME="marker=98076"> </A>DISCUSSION</H5><P CLASS="T1.Text1"><A NAME="pgfId=77722"> </A>The <TT CLASS="cv">DataHGetMIMETypeAsync</TT> call removes synchronous blocks from QuickTime's movie opening code. <TT CLASS="cv">DataHGetMIMEType</TT>, the only call available before, will block if the data is not available yet and will continue blocking until either the information becomes available or the operation times out in 60 seconds. If it times out, it returns the error notEnoughDataErr.</P><P CLASS="T1.Text1"><A NAME="pgfId=77707"> </A>The semantics of usage are the same as the already-available <TT CLASS="cv">DataHGetFileTypeAsync</TT> call. With each call, a pointer to the value to be updated is passed to the routine. For <TT CLASS="cv">DataHGetMIMEType</TT>, it is a pointer to a Str255 that will hold the MIME type when (if) it becomes available. The <TT CLASS="cv">completionRtn</TT> is a standard DataHCompletion proc that is called when either the data becomes available or there is a failure (timeout, <TT CLASS="cv">DataHFinishData()</TT> called with cancel). The <TT CLASS="cv">refCon</TT> value is passed to the completion routine. The pointer will not be updated until the completion routine fires.</P><P CLASS="T1.Text1"><A NAME="pgfId=77595"> </A>If a completion routine is not specified, however, the call will return immediately. If the MIME type is known, it will update <TT CLASS="cv">mimeType</TT> and return <TT CLASS="cv">noErr</TT>. If the information is not known yet, the error <TT CLASS="cv">notEnoughDataErr</TT> will be returned. This allows non-blocking calls to be made to <TT CLASS="cv">DataHGetMIMETypeAsync</TT>. If it returns another error, that indicates some other failure.</P></DIV></DIV><DIV><H4 CLASS="RoH.RoutineHeading"><A NAME="pgfId=77775"> </A>QTGetMIMETypeInfo </H4><P CLASS="T1.Text1"><A NAME="pgfId=77777"> </A>Allows information to be retrieved about a particular MIME type. The type of information is specified by a selector. </P><CODE CLASS="Cv.Code"><A NAME="pgfId=98080"> </A>pascal OSErr  QTGetMIMETypeInfo ( const char * mimeStringStart, short <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mimeStringLength, OSType infoSelector, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *infoDataPtr, long *infoDataSize );</code><br><P CLASS="T1.Text1"><A NAME="pgfId=77785"> </A><A NAME="marker=98082"> </A>where the <TT CLASS="cv">mimeStringStart</TT> argument is a pointer to the first character of a string holding the MIME type amd <TT CLASS="cv">mimeStringLength</TT> contains the number of characters in the MIME type string. These two arguments allow references to Pascal, C and non-delimited string buffers to be passed with equal abandon.</P><P CLASS="T1.Text1"><A NAME="pgfId=77790"> </A>The <TT CLASS="cv">infoSelector</TT> parameter holds the type of information being requested. <TT CLASS="cv">infoDataPtr</TT> is a pointer to the value to be updated. <TT CLASS="cv">infoDataSize</TT> on input is the size of the data being expected and on output is the size of the data being retrieved. In all current cases these will hold the same size. In general, this approach allows some sanity checking on the size of the info data buffer passed. </P><P CLASS="T1.Text1"><A NAME="pgfId=77797"> </A>Two selectors are defined:</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=98086"> </A>kQTGetMIMETypeInfoIsQuickTimeMovieType = 'moov',// info is a pointer to a Boolean</code><br><DL COMPACT><DD CLASS="DD.DefinitionDefCont"><A NAME="pgfId=77801"> </A>Corresponds to a MIME type for a QuickTime movie. The current check is against <TT CLASS="cv">&quot;video/quicktime&quot;</TT> and <TT CLASS="cv">&quot;application/x-quicktimeplayer&quot;</TT> but can be extended in the future.</DD></DL COMPACT><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=98092"> </A>kQTGetMIMETypeInfoIsUnhelpfulType = 'dumb'// info is a pointer to a Boolean</code><br><DL COMPACT><DD CLASS="DD.DefinitionDefCont"><A NAME="pgfId=78352"> </A>Useful in trying to determine an importer, this returns false for <TT CLASS="cv">&quot;application/octet-stream&quot;</TT>, a MIME type which often indicates a poorly configured server. This allows the MIME check to be bypassed for obviously bogus MIME type information.</DD></DL COMPACT></DIV><H2 CLASS="H2.Heading2TOC"><A HREF="Max.7d.htm#pgfId=78358" CLASS="Hypertext">Pointer Data Handler</A></H2><H2 CLASS="H2.Heading2TOC"><A HREF="Max.7e.htm#pgfId=78354" CLASS="Hypertext">New Load State Defined</A></H2><H2 CLASS="H2.Heading2TOC"><A HREF="Max.7f.htm#pgfId=70793" CLASS="Hypertext">Autoplay and the Movie Toolbox</A></H2><H2 CLASS="H2.Heading2TOC"><A HREF="Max.80.htm#pgfId=77308" CLASS="Hypertext">New Media Type Supported</A></H2><hr>&#169; 2001 Apple Computer, Inc.<!-- QTnavbar start --><P><I>What's New in QuickTime 5</I><P>| <A HREF="Max.7b.htm">Previous</A> | <A HREF="Max.1.htm">Chapter Contents</A> | <A HREF="Max.htm">Chapter Top</A> | <A HREF="Max.7d.htm">Next</A> |</P></DIV><!-- QTnavbar end --></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>