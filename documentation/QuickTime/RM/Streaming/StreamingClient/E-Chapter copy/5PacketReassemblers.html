<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>QuickTime Streaming Guide: Packet Reassemblers</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Packet Reassemblers"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers" title="Packet Reassemblers"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000433" target="_top">QuickTime</a> &gt; <a href="../../../../Streaming-date.html#//apple_ref/doc/uid/TP30000440-TP30000433-TP30000577" target="_top">Streaming</a> &gt; <a href="../A-Intro/1Introduction.html#//apple_ref/doc/uid/TP30001145-IntroductiontoQuickTimeStreamingGuide-DontLinkElementID_51">QuickTime Streaming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../D-Chapter/4MediaPacketizers.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Z-RevHistory/revisionhistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-SW1" title="Packet Reassemblers"></a>
<h1>Packet Reassemblers</h1>



<p>A packet reassembler extracts meaningful chunks of data, such as video frames, from streams of RTP packets. A reassembler can be specific to a particular media type and compression format, such as a reassembler for Sorenson video, or it can be more generalized, such as a reassembler for any uncompressed audio, or even a reassembler for any QuickTime media.</p>
<p>Streaming media over RTP generally involves some packet loss. It is the responsibility of the reassembler to perform any loss recovery that goes beyond discarding data chunks that contain lost packets.</p>
<a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-DontLinkElementID_41" title="Writing a Packet Reassembler"></a>
<h2><a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-WritingaPacketReassembler" title="Writing a Packet Reassembler"></a>Writing a Packet Reassembler</h2>
<p>QuickTime includes a base reassembler that performs most of the routine work of packet reassembly. Your packet reassembler sets flags that control the behavior of the base reassembler. Your reassembler can also implement several functions to override the base reassembler, essentially taking over from it at almost any point.</p>
<p>The reassembler component must implement several functions, and must also provide a public component resource that describes the type of media, compression, and track characteristics that the reassembler supports. This resource also provides information on the reassembler&#8217;s relative speed and the format&#8217;s ability to handle loss.</p>
<p>The following functions can be implemented by packet reassembler components. As noted, some of these functions must be implemented in your component, some can be delegated to the base component, and some are base component utility functions that your component can call.</p>
<ul class="ul">
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmInitialize" target="_top">RTPRssmInitialize</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmReset" target="_top">RTPRssmReset</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmComputeChunkSize" target="_top">RTPRssmComputeChunkSize</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmAdjustPacketParams" target="_top">RTPRssmAdjustPacketParams</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmCopyDataToChunk" target="_top">RTPRssmCopyDataToChunk</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSendPacketList" target="_top">RTPRssmSendPacketList</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetTimeScaleFromPacket" target="_top">RTPRssmGetTimeScaleFromPacket</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSetInfo" target="_top">RTPRssmSetInfo</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetInfo" target="_top">RTPRssmGetInfo</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSetCapabilities" target="_top">RTPRssmSetCapabilities</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetCapabilities" target="_top">RTPRssmGetCapabilities</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSetPayloadHeaderLength" target="_top">RTPRssmSetPayloadHeaderLength</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetPayloadHeaderLength" target="_top">RTPRssmGetPayloadHeaderLength</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSetTimeScale" target="_top">RTPRssmSetTimeScale</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetTimeScale" target="_top">RTPRssmGetTimeScale</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmNewStreamHandler" target="_top">RTPRssmNewStreamHandler</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSendStreamHandlerChanged" target="_top">RTPRssmSendStreamHandlerChanged</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSetSampleDescription" target="_top">RTPRssmSetSampleDescription</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetChunkAndIncrRefCount" target="_top">RTPRssmGetChunkAndIncrRefCount</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSendChunkAndDecrRefCount" target="_top">RTPRssmSendChunkAndDecrRefCount</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSendLostChunk" target="_top">RTPRssmSendLostChunk</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmClearCachedPackets" target="_top">RTPRssmClearCachedPackets</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmReleasePacketList" target="_top">RTPRssmReleasePacketList</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmIncrChunkRefCount" target="_top">RTPRssmIncrChunkRefCount</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmDecrChunkRefCount" target="_top">RTPRssmDecrChunkRefCount</a></code></p></li>
</ul>
<a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-DontLinkElementID_42" title="Reassembler Component Type and Subtype"></a>
<h3><a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-ReassemblerComponentTypeandSubtype" title="Reassembler Component Type and Subtype"></a>Reassembler Component Type and Subtype</h3>
<p>Packetizers have a component type of <code>kRTPReassemblerType</code> <code>('rtpr'</code>). The subtype can be any four-character combination. Note, however, that all-lowercase types are reserved by Apple.</p>

<a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-DontLinkElementID_43" title="The &#39;rsmi&#39; Public Resource"></a>
<h3><a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-ThersmiPublicResource" title="The &#39;rsmi&#39; Public Resource"></a>The 'rsmi' Public Resource</h3>
<p>A reassembler must provide a public resource of type <code><!--a target="_top" -->'rsmi'<!--/a--></code>. The public resource contains information about the capabilities of a given reassembler. This information lists the RTP payload types the reassembler can work with. In addition, it provides information about the reassembler&#8217;s performance characteristics, specifically its speed and ability to recover from lost packets.</p>
<p>If more than one reassembler is available for a given RTP payload type, QuickTime will choose the one with the best performance characteristics, such as speed or ability to deal with packet loss.</p>
<p>The format of the public resource is defined in <code>QTStreamingComponents</code>.<code>r</code> as follows:</p>

<div class="codesample"><table><tr><td scope="row"><pre>type 'rsmi' {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;array infoArray {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;align long;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;longint = $$CountOf(characteristicArray); /* Array size */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;array characteristicArray {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hex longinttag;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hex longint value;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>hex longintpayloadFlags;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/* kRTPPayloadTypeStaticFlag or kRTPPayloadTypeDynamicFlag */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;byte&#160;&#160;&#160;&#160;payloadID;&#160;&#160;&#160;&#160;&#160;&#160;/* if static payload */<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;byte = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;byte = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;byte = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cstring;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* if dynamic payload */ <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define kRTPPayloadSpeedTag 'sped'/* 0-255, 255 is fastest */ ]<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define kRTPPayloadLossRecoveryTag 'loss'<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;/* 0-255, 0 can't handle any loss, 128 can handle 50% packet loss */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define kRTPPayloadTypeStaticFlag 0x00000001<span></span></pre></td></tr><tr><td scope="row"><pre>#define kRTPPayloadTypeDynamicFlag 0x00000002<span></span></pre></td></tr></table></div>

<p>The payload flags field is set to <code>kRTPMPPayloadTypeDynamicFlag</code> if the reassembler handles a dynamic payload type, or <code>kRTPMPPayloadTypeStaticFlag</code> if it handles a static type.</p>
<p>The payload ID field of the <code><!--a target="_top" -->'rsmi'<!--/a--></code> resource is set to the IETF-defined RTP payload value if a static payload type is used.</p>
<p>The C string contains the RTP payload type text for dynamic types.</p>
<p>A declaration in a .r file might look like this:</p>

<div class="codesample"><table><tr><td scope="row"><pre>resource kRTPReassemblerInfoResType (128) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;kRTPPayloadSpeedTag, 128,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;kRTPPayloadLossRecoveryTag, 50<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;},<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;kRTPPayloadTypeDynamicFlag, 0, "x-oval"<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;}<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div>

<p>This resource indicates that the reassembler is of average speed and that it can handle 50% packet loss while still providing some meaningful data. It handles the dynamic RTP payload type identified by <code>x-oval</code>.</p>
<p>The speed tag is relative to other reassemblers of the same type. A value of 128 is a reasonable default.</p>

<a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-DontLinkElementID_44" title="The Base Reassembler"></a>
<h3><a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-TheBaseReassembler" title="The Base Reassembler"></a>The Base Reassembler</h3>
<p>Your packet reassembler relies on a base reassembler component to do most of the routine reassembly work. Your reassembler can modify some of the base reassembler&#8217;s default behaviors simply by setting flags. With a few exceptions, your reassembler implements reassembler functions only when it needs to override the normal behavior of the base reassembler.</p>
<p>The base reassembler&#8217;s main function is to assemble incoming packets into &#8220;chunks&#8221;, then pass the chunks to a stream handler. A chunk is the amount of data useful to a particular stream handler, such as a video frame or twenty milliseconds of audio.</p>
<p>Your reassembler must specify the type of stream handler needed, but your reassembler doesn&#8217;t work with stream handlers directly. The base reassembler does this for you.</p>
<p>The default behavior of the base reassembler is as follows:</p>
<ol class="ol">
<li class="li"><p>The base reassembler fills out an <code><!--a target="_top" -->RTPRssmPacket<!--/a--></code> struct for each packet it receives.</p></li>
<li class="li"><p>The base reassembler puts the packets into a packet list, which corresponds to a data chunk. By default, the packet list contains all the packets with the same RTP transmission time, which is also the sample time. The base reassembler will start a new packet list when it receives a packet with a different RTP transmission time or with the RTP marker bit set. Your reassembler can change this default by telling the base reassembler that every packet is a chunk.</p></li>
<li class="li"><p>Once a packet list is complete, the base reassembler creates a chunk from it. By default, the chunk is made by concatenating the payload of each packet in the packet list. By default, the payload is assumed to be the entire contents of the packet following the RTP header and the payload header. The base reassembler assumes a zero-length payload header (no payload header) unless your reassembler sets a nonzero payload header length as the default.</p></li>
<li class="li"><p>By default, the base reassembler discards chunks with missing packets. The base reassembler can be set to inform your reassembler that a chunk has missing packets.</p></li>
</ol>
<p>By implementing certain functions, you can cause the base reassembler to call your reassembler at one of several points to override or modify the default behavior:</p>
<div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Implement this function</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Your reassembler will be called</p></th>
</tr>


<tr>
<td  scope="row"><p><code>RTPRssmAdjustPacketParams</code></p></td>
<td ><p>When each packet is received, after the base reassembler fills out the <code>RTPRssmPacket</code> struct</p></td>
</tr>
<tr>
<td  scope="row"><p><code>RTPRssmSendPacketList</code></p></td>
<td ><p>When the packet list is complete</p></td>
</tr>
<tr>
<td  scope="row"><p><code>RTPRssmComputeChunkSize</code></p></td>
<td ><p>When the chunk size is calculated</p></td>
</tr>
<tr>
<td  scope="row"><p><code>RTPRssmCopyDataToChunk</code></p></td>
<td ><p>When the data is copied into the chunk record</p></td>
</tr>

</table></div>
<p>This is discussed further in the sections <span class="content_text"><a href="5PacketReassemblers.html#//apple_ref/doc/uid/TP30001145-PacketReassemblers-HandlingPacketsYourself">Handling Packets Yourself</a></span> and <span class="content_text"><a href="5PacketReassemblers.html#//apple_ref/doc/uid/TP30001145-PacketReassemblers-HandlingChunksYourself">Handling Chunks Yourself</a></span>.</p>

<a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-DontLinkElementID_45" title="Opening Your Reassembler"></a>
<h3><a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-OpeningYourReassembler" title="Opening Your Reassembler"></a>Opening Your Reassembler</h3>
<p>QuickTime may open your packet reassembler to check its version or to get information. It may then close your reassembler without ever initializing it or using it to process packets.</p>
<p>Your reassembler component must be able to perform the standard component functions, such as <code>_Version</code>, and its specific <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetInfo" target="_top">RTPRssmGetInfo</a></code> function, without being initialized.</p>
<p>When opened, your packet reassembler must open a base reassembler component. Your reassembler should delegate any functions it does not implement. It should also support the <code>_Target</code> call.</p>
<p>A typical reassembler&#8217;s <code>_Open</code> and <code>_Target</code> functions might look like this:</p>

<div class="codesample"><table><tr><td scope="row"><pre>pascal ComponentResult RTPOvalRssm_Open(RTPOvalRssmGlobalsPtr globals,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ComponentInstance self) <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma unused (inGlobals)<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;ComponentResult&#160;err;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;globals = (RTPOvalRssmGlobalsPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;NewPtrClear(sizeof(RTPOvalRssmGlobalsRecord)); <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if ( (err = MemError()) != noErr )<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;goto exit;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;SetComponentInstanceStorage(self, (Handle)globals);<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;globals-&#62;self = self;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;err = OpenADefaultComponent(kRTPReassemblerType, kRTPBaseReassemblerType,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#38;globals-&#62;delegateComponent); <span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;if ( err == noErr )<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;err = RTPOval_Target(globals, self);<span></span></pre></td></tr><tr><td scope="row"><pre>exit:<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult RTPOval _Target(RTPOvalRssmGlobalsPtr inGlobals,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ComponentInstance inParentComponent) <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;inGlobals-&#62;parent = inParentComponent;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;return ComponentSetTarget(inGlobals-&#62;delegateComponent, inParentComponent);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-DontLinkElementID_46" title="Initialization"></a>
<h3><a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-Initialization" title="Initialization"></a>Initialization</h3>
<p>Your reassembler must implement the <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmInitialize" target="_top">RTPRssmInitialize</a></code> function. When initialized, your reassembler is passed an <code><!--a target="_top" -->RTPRssmInitParams<!--/a--></code> struct containing three initialization parameters:</p>

<div class="codesample"><table><tr><td scope="row"><pre>struct RTPRssmInitParams {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;UInt32&#160;&#160;&#160;&#160;&#160;&#160;reserved;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;UInt8&#160;&#160;&#160;&#160;&#160;&#160;&#160;payloadType;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;UInt8&#160;&#160;&#160;&#160;&#160;&#160;&#160;pad[3];<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;TimeBase&#160;&#160;&#160;&#160;timeBase;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;TimeScale&#160;&#160;&#160;controlTimeScale;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct RTPRssmInitParamsRTPRssmInitParams;<span></span></pre></td></tr></table></div>

<div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Term</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Definition</p></th>
</tr>


<tr>
<td  scope="row"><p><code>payloadType</code></p></td>
<td ><p>One-byte identifier for the payload type. It is the same number as sent in the RTP header. This is useful if your reassembler handles more than one format.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>timeBase</code></p></td>
<td ><p>The timebase for the presentation.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>controlTimescale</code></p></td>
<td ><p>The timescale used for actions such as start, stop, etc. This is independent of the timescale used for the media. For example, the control timescale could be 600 while the media timescale could be 90000.</p></td>
</tr>

</table></div>
<p>During initialization, your reassembler should open a stream handler of the appropriate type. For example, if your reassembler works with H.261 packets, it should open a video stream handler. Stream handler types are specified in the same manner as track types (video is <code>videoMediaType</code>, and so on). There are currently stream handlers for audio, video, text, and MIDI.</p>
<p>Your reassembler opens a stream handler by calling <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmNewStreamHandler" target="_top">RTPRssmNewStreamHandler</a></code>. You must specify the stream handler type when you open it. If your reassembler handles multiple media types, it can open a stream handler later, after it learns what kind of media is in the stream.</p>
<p>You should initialize the sample description of the stream handler when you open it, if possible. It can be set or changed later if necessary. The stream handler will be unable to process any data until its sample description is set.</p>
<p>Your reassembler should also initialize the timescale of the stream handler at this time. If your reassembler needs to get the timescale from the stream, it can monitor incoming packets and set the timescale when it is known. (No chunks will be sent to the stream handler until its timescale is set).</p>
<p>During initialization, your reassembler should call <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSetCapabilities" target="_top">RTPRssmSetCapabilities</a></code> with any initial flags to control the base reassembler&#8217;s default behaviors, such as <code>kRTPRssmEverySampleAChunkFlag</code> or <code>kRTPRssmTrackLostPacketsFlag</code>.</p>
<p>You should also call <code>SetPayloadHeaderLength</code> at this time if you know the payload header length for your packets.</p>
<p>A typical reassembler initialization function might look like this:</p>

<div class="codesample"><table><tr><td scope="row"><pre>EXTERN_API( ComponentResult )<span></span></pre></td></tr><tr><td scope="row"><pre>RTPRssmOVAL_Initialize(<span></span></pre></td></tr><tr><td scope="row"><pre>RTPHOVALGlobalsPtrinGlobals,<span></span></pre></td></tr><tr><td scope="row"><pre>RTPRssmInitParams *inInitParams )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma unused(inInitParams)<span></span></pre></td></tr><tr><td scope="row"><pre>ComponentResulterr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>ImageDescriptionHandle imageDesc;<span></span></pre></td></tr><tr><td scope="row"><pre>SInt32     flags = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>inGlobals-&#62;fTimeScale = kOVALRTPTimeScale;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>flags = kRTPRssmQueueAndUseMarkerBitFlag + kRTPRssmTrackLostPacketsFlag;<span></span></pre></td></tr><tr><td scope="row"><pre>err = RTPRssmSetCapabilities(inGlobals-&#62;delegateComponent, flags, -1L );<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;if (err == noErr) {<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;imageDesc = __GetMyImageDesc( inGlobals );<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;if( imageDesc )<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;err = RTPRssmNewStreamHandler(inGlobals-&#62;delegateComponent,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;VideoMediaType, ( SampleDescriptionHandle ) imageDesc,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;inGlobals-&#62;fTimeScale, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;} &#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;else<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;err = memFullErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;}<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-DontLinkElementID_47" title="Setup and Information Functions"></a>
<h3><a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-SetupandInformationFunctions" title="Setup and Information Functions"></a>Setup and Information Functions</h3>
<p>If you do not open a stream handler and set its timescale during initialization, you must implement the <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetTimeScaleFromPacket" target="_top">RTPRssmGetTimeScaleFromPacket</a></code> function. If you have not set the stream handler&#8217;s timescale, the base reassembler will call your reassembler&#8217;s <code>GetTimeScaleFromPacket</code> function with every incoming packet until a stream handler is open and its time scale is set.</p>
<p>If you cannot determine the timescale based on the contents of the packet, return <code>qtsUnknownValueErr</code> or a 0 timescale.</p>

<div class="codesample"><table><tr><td scope="row"><pre>EXTERN_API( ComponentResult ) RTPRssmGetTimeScaleFromPacket(<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;RTPReassembler rtpr,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;QTSStreamBuffer *inStreamBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;TimeScale *&#160;outTimeScale);<span></span></pre></td></tr></table></div>

<p>The <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetInfo" target="_top">RTPRssmGetInfo</a></code>, <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSetInfo" target="_top">RTPRssmSetInfo</a></code>, and <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmHasCharacteristic" target="_top">RTPRssmHasCharacteristic</a></code> functions can be called at any time, even prior to initialization. <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmHasCharacteristic" target="_top">RTPRssmHasCharacteristic</a></code> is called to determine what features your reassembler supports. <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetInfo" target="_top">RTPRssmGetInfo</a></code> is used to get information from your reassembler. <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSetInfo" target="_top">RTPRssmSetInfo</a></code> could be used to send information to your reassembler, but there are currently no selectors that do this.</p>
<p>These functions are commonly used if your reassembler supports passing of non-media data, such as transformation matrices. The functions are typically called after your reassembler reports a change in a non-media parameter by calling <code>RTPRssmSendStreamHandlerChange</code>, as described in <span class="content_text"><a href="../D-Chapter/4MediaPacketizers.html#//apple_ref/doc/uid/TP30001145-MediaPacketizers-PassingNonMediaData">Passing Non-Media Data</a></span>. The selectors used for passing non-media data are the same for <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmHasCharacteristic" target="_top">RTPRssmHasCharacteristic</a></code> and <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetInfo" target="_top">RTPRssmGetInfo</a></code>. These selectors begin with <code>kQTSSource</code> and are defined in <code>QTStreaming</code>.<code>h</code>.</p>
<p>Delegate any selectors you do not support or do not understand to the base reassembler for all of these functions:</p>

<div class="codesample"><table><tr><td scope="row"><pre>EXTERN_API( ComponentResult ) RTPRssmSetInfo(<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;RTPReassembler    rtpr,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;OSType          &#160;inSelector,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;void *&#160;&#160;         ioParams) ;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EXTERN_API( ComponentResult ) RTPRssmGetInfo&#160;&#160;(<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;RTPReassembler rtpr,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;OSType &#160;&#160;&#160;&#160;inSelector,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;void *&#160;&#160;&#160;&#160;&#160;ioParams) ;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EXTERN_API( ComponentResult ) RTPRssmHasCharacteristic(<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;RTPReassembler rtpr,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;OSType &#160;&#160;&#160;&#160;&#160;inCharacteristic,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;Boolean *&#160;&#160;&#160;outHasIt) ;<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-DontLinkElementID_48" title="Handling Packets Yourself"></a>
<h3><a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-HandlingPacketsYourself" title="Handling Packets Yourself"></a>Handling Packets Yourself</h3>
<p>Your packet reassembler can be called when each packet is received. If you have not yet opened a stream handler and set its timescale, you will receive a <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetTimeScaleFromPacket" target="_top">RTPRssmGetTimeScaleFromPacket</a></code> call for each received packet.</p>
<p>Once the stream handler&#8217;s timescale is set, the default behavior for the base reassembler is to fill out an <code><!--a target="_top" -->RTPRssmPacket<!--/a--></code> struct for each incoming packet, then to add each packet to the current packet list. The base reassembler starts a new packet list when a packet&#8217;s RTP marker bit is set, or the RTP timestamp changes, or if your reassembler has set the <code>kRTPRssmEveryPacketAChunkFlag</code> <code></code> in<code></code> <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSetCapabilities" target="_top">RTPRssmSetCapabilities</a></code>.</p>
<p>If you want to fill out or modify the <code><!--a target="_top" -->RTPRssmPacket<!--/a--></code> struct for each packet yourself, because you use variable payload header lengths, for example, implement the <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmAdjustPacketParams" target="_top">RTPRssmAdjustPacketParams</a></code> function.</p>

<div class="codesample"><table><tr><td scope="row"><pre>EXTERN_API( ComponentResult ) RTPRssmAdjustPacketParams(<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;RTPReassembler    rtpr,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;RTPRssmPacket     *inPacket,<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;SInt32 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  &#160;inFlags) ;<span></span></pre></td></tr></table></div>

<p>The <code>inPacket</code> parameter points to the <code><!--a target="_top" -->RTPRssmPacket<!--/a--></code> struct for the current packet. This structure has already been filled in by the base reassembler:</p>

<div class="codesample"><table><tr><td scope="row"><pre>struct RTPRssmPacket {<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;struct RTPRssmPacket      *next;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;struct RTPRssmPacket      *prev;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;QTSStreamBuffer           *streamBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;Boolean                   paramsFilledIn;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;UInt8 &#160;&#160;                  pad[1];<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;UInt16 &#160;                  sequenceNum;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;UInt32 &#160;                  transportHeaderLength;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;UInt32 &#160;                  payloadHeaderLength;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;UInt32 &#160;                  dataLength;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;SHServerEditParameters    serverEditParams;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;TimeValue64 &#160;&#160;&#160;&#160;          timeStamp;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;SInt32 &#160;                  chunkFlags;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#160;&#160;&#160;&#160;SInt32 &#160;                  packetFlags;<span></span></pre></td></tr><tr><td scope="row"><pre>}; typedef struct RTPRssmPacketRTPRssmPacket;<span></span></pre></td></tr></table></div>

<div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Field</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Definition</p></th>
</tr>


<tr>
<td  scope="row"><p><code>next</code></p></td>
<td ><p>The next packet in the list; <code>NULL</code> if this is  the last packet.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>prev</code></p></td>
<td ><p>The previous packet in the list; <code>NULL</code> if this is the first packet.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>streamBuffer</code></p></td>
<td ><p>The stream buffer containing the packet data.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>pad</code></p></td>
<td ><p>Not used.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>sequenceNum</code></p></td>
<td ><p>The sequence number associated with the packet. Sequence numbers are unsigned 16 bit numbers and wrap around. (65535 is followed by 0, 1, 2, etc). Sequence numbers start at arbitrary numbers.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>transportHeaderLength</code></p></td>
<td ><p>The length of the RTP header. The payload specific part of the packet begins immediately after the transport header. Do not assume that the RTP header length is 12.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>payloadHeaderLength</code></p></td>
<td ><p>The length of the payload header. The payload header (if any) starts immediately after the RTP header. This number gets filled in by the base reassembler by using the number passed into <code>RTPRssmSetPayloadHeaderLength</code>. It can also be modified by the derived reassembler.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>dataLength</code></p></td>
<td ><p>The length of the payload data. This is usually the length of the packet minus transport header length minus payload header length. The base reassembler will set the default value to that. Your reassembler can modify the number.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>timeStamp</code></p></td>
<td ><p>The 64 bit timestamp associated with the packet in the stream timebase (not the movie timebase). The timestamp sent in the RTP header is 32 bits and wraps around. The 64 bit timestamp in this structure accounts for the wraparound. The lower 32 bits are exactly the timestamp sent in the RTP header. The upper 32 bits are the number of wraparounds.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>chunkFlags</code></p></td>
<td ><p>Flags that should be set in the chunk that is sent to the stream handler. The base reassembler calculates the value that is set in the <code>SHCHunkRecord</code> structure by OR-ing all the chunk flags in the <code>RTPRssmPacket</code> list. Your reassembler should fill in these flags as appropriate. Flags you could set include <code>kSHChunkFlagSyncSample</code> (set this flag if the chunk is a sync sample) or <code>kSHChunkFlagDataLoss</code> (set this flag if the chunk has data loss in it; for example, if there was data loss in the video frame and the reassembler did partial recovery).</p></td>
</tr>
<tr>
<td  scope="row"><p><code>packetFlags</code></p></td>
<td ><p>The base reassembler fills in this value. Defined flags include <code>kRTPRssmPacketHasMarkerBitSet</code> = 0x00000001 (the base reassembler fills in this value from the RTP header) and <code>kRTPRssmPacketHasServerEditFlag</code> = 0x00010000 (the derived reassembler should set this flag to 1 if this packet has a server edit; you should also fill in the <code>serverEditParams</code> field).</p></td>
</tr>

</table></div>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-DontLinkElementID_70" title="Important:"></a><p><strong>Important:</strong>&nbsp;
Do not modify the data in the stream buffer. For example, if you have to flip bytes for endian differences between network byte order and the native byte order, copy the resulting data. Do not flip the bytes in place. Other components might have references to the same data. </p><p>
</p></div>

<a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-DontLinkElementID_49" title="Handling Chunks Yourself"></a>
<h3><a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-HandlingChunksYourself" title="Handling Chunks Yourself"></a>Handling Chunks Yourself</h3>
<p>The base reassembler automatically builds chunks from packets and sends them to the stream handler you have opened. If any packets are missing from the chunk, the base reassembler discards the entire chunk.</p>
<p>You can take over from the base reassembler at several points in the chunk-building process by implementing the appropriate function. Do this if your reassembler performs loss recovery, or if the base reassembler&#8217;s default behavior needs to be modified to correctly build chunks for the stream handler.</p>
<p>Your reassembler is responsible for creating and sending the chunk, beginning at whatever point you take over, and continuing until the chunk is sent or discarded.</p>
<p>The process of creating a chunk begins when the base reassembler has a complete packet list. To take over at this point, implement <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSendPacketList" target="_top">RTPRssmSendPacketList</a></code>. You might want to do this if you were altering the packet list for loss recovery.</p>
<p>If you implement <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSendPacketList" target="_top">RTPRssmSendPacketList</a></code>, you are responsible for deleting the packet list when you are through with it, by calling <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmReleasePacketList" target="_top">RTPRssmReleasePacketList</a></code>.</p>
<p>Next, the base reassembler calculates the chunk size. It does this by summing the payload size for each packet in the list. The payload size is calculated by subtracting the RTP header and the payload header from the packet size. To take over at this point, implement <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmComputeChunkSize" target="_top">RTPRssmComputeChunkSize</a></code>. You might want to do this if you need to add data to the chunk that isn&#8217;t in the packets, or to use a different method for calculating the payload size.</p>
<p>If you implement <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmComputeChunkSize" target="_top">RTPRssmComputeChunkSize</a></code>, you will need to allocate a chunk of the appropriate size. To do this, call <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmGetChunkAndIncrRefCount" target="_top">RTPRssmGetChunkAndIncrRefCount</a></code>. This will allocate the chunk and set the number of references to it to 1. QuickTime will maintain the chunk until the number of references to it is 0. The reference count is automatically decremented when you send the chunk. You can increment the counter by calling <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmIncrChunkRefCount" target="_top">RTPRssmIncrChunkRefCount</a></code> if you want QuickTime to preserve the chunk for later use (by substituting for a lost chunk, for example).</p>
<p>Once the chunk size has been calculated and the chunk has been allocated, the base reassembler moves the data from the packets into the chunk. The data moved will be a simple concatenation of the packet payloads. The payload size and offset within each packet are calculated in the same manner as used for calculating chunk size. To be able to take over at this point, implement <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmCopyDataToChunk" target="_top">RTPRssmCopyDataToChunk</a></code>. You would need to do this to modify the bytes at packet boundaries for an H.261 packet reassembler, for example.</p>
<p>Bear in mind that if you implement <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmSendPacketList" target="_top">RTPRssmSendPacketList</a></code>, you are responsible for the steps performed in <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmComputeChunkSize" target="_top">RTPRssmComputeChunkSize</a></code> and <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmCopyDataToChunk" target="_top">RTPRssmCopyDataToChunk</a></code>. Similarly, if you implement <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmComputeChunkSize" target="_top">RTPRssmComputeChunkSize</a></code>, you must perform the steps for <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmCopyDataToChunk" target="_top">RTPRssmCopyDataToChunk</a></code>. Only the first of these functions that you implement will be called. You take over the chunk-building process from there.</p>
<p>If you implement any of the three functions just discussed, you are responsible for sending the chunk by calling <code>RTPRssmSendChunkAndDecrCount</code>.</p>
<p>Other things your reassembler might do at this point are to</p>
<ul class="spaceabove">
<li class="li"><p>Tell the stream handler that the sample description has changed (<code>RTPRssmSetSampleDescription</code>).</p></li>
<li class="li"><p>Tell the stream handler that some non-media data has changed, such as a transformation matrix or sound volume (<code>RTPRssmSendStreamHandlerChanged</code> ). You may receive a series of <code>GetInfo</code> calls to determine what has changed.</p></li>
<li class="li"><p>Tell the stream handler not to send the chunk. The reference counter will be decremented; if it becomes zero, the chunk is deallocated (<code>RTPRssmSendLostChunk</code>).</p></li>
<li class="li"><p>Tell the base reassembler to keep a copy of this chunk for your later use (<code>RTPRssmIncrChunkRefCount</code>). Be sure to increment the ref count before you send the chunk. You must eventually call <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmDecrChunkRefCount" target="_top">RTPRssmDecrChunkRefCount</a></code> for every call to <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmIncrChunkRefCount" target="_top">RTPRssmIncrChunkRefCount</a></code> or you will create a memory leak.</p></li>
</ul>

<a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-DontLinkElementID_50" title="Reset and Clear Cache Functions"></a>
<h3><a name="//apple_ref/doc/uid/TP30001145-PacketReassemblers-ResetandClearCacheFunctions" title="Reset and Clear Cache Functions"></a>Reset and Clear Cache Functions</h3>
<p>Your reassembler can be called at any time with the <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmReset" target="_top">RTPRssmReset</a></code> function, which you must implement. Reset all your variables, release any chunks being held for you, and prepare for a new run of data. At the end of an <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmReset" target="_top">RTPRssmReset</a></code> function, your state should be identical to its state after the first <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmInitialize" target="_top">RTPRssmInitialize</a></code> call.</p>
<p>You can instruct the base reassembler to release any packets in the packet list it is currently building by calling <code><a href="../../../../Reference/QTRef_Streaming/Reference/reference.html#//apple_ref/c/func/RTPRssmClearCachedPackets" target="_top">RTPRssmClearCachedPackets</a></code>. You might do this if you are handling packets yourself and you determine that the list the base reassembler is building should be discarded.</p>





        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../D-Chapter/4MediaPacketizers.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Z-RevHistory/revisionhistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-01-10<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/QuickTime/RM/Streaming/StreamingClient/E-Chapter copy/5PacketReassemblers.html%3Fid%3DTP30001145-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/QuickTime/RM/Streaming/StreamingClient/E-Chapter copy/5PacketReassemblers.html%3Fid%3DTP30001145-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/QuickTime/RM/Streaming/StreamingClient/E-Chapter copy/5PacketReassemblers.html%3Fid%3DTP30001145-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>