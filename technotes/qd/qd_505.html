<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note QD505: Basic QuickDraw Q&amp;As</title><meta name="keywords" content="Mac OS 8 QuickDraw Reversing Images colors srcOr PicComments questions"><meta name="Description" content="Technical Note QD505: This Technical Note contains a collectionof archived Q&amp;As relating to QuickDraw--questions sent theDeveloper Support Center (DSC) along with answers from theDSC engineers. Archived Q&amp;As include: Determining whetherCopyBits to a PICT was successful; Random function requiresprior InitGraf rect call; GetIconCacheData rect &amp; SetIconCacheDatarect bug and workaround; DrawText and DrawString patchedto be script aware; QuickDraw globals at INIT time; Use crsrNewflag to unobscure cursor without mouse move; Macintosh CalcMaskand CopyMask code sample; Code for filling an area fullybounded by polygon; and Code for reversing Macintosh PICTimages.">                                       <meta name="categories" content="QuickDraw"><meta name="week-posted" content="Oct 1, 1990 - Oct 5, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002735" title="Basic QuickDraw Q&As"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note QD505</div>
<div id="pageheadsub">Basic QuickDraw Q&amp;As</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note contains a collection of archived Q&amp;As relating to a specific topic--questions sent the Developer Support Center (DSC) along withanswers from the DSC engineers. Current Q&amp;As can be found on the <a href="../../qa/index.html">Macintosh Technical Q&amp;As web site</a>.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><H2>Determining whether <code>CopyBits</code> to a PICT was successful</h2><p>Date Written:  1/7/93</p><p>Last reviewed:  3/1/93</p><p>If I'm recording a PICT and doing a <code>CopyBits</code> of a really big image into thePICT, how can I determine whether I'm out of memory?</p><BR><p>The only reliable way to see whether a <code>CopyBits</code> to a PICT succeeded is afterthe fact. You need to test the PICT's <code>picFrame rect</code> <i>(Inside Macintosh</i>Volume V, page V-87) to see whether it's empty after the <code>CopyBits</code>. The testwould look like:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>If (EmptyRect(&amp;(**myPicture).picFrame))</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></p><H2>Random function requires prior <code>InitGraf rect</code> call</h2><p>Date Written:  12/16/92</p><p>Last reviewed:  3/1/93</p><p>The <code>Random</code> function call listed in QuickDraw.h can't be called from MPW toolswithout crashing my system. It appears to work when the function is called fromapplications or cdevs. What could be causing this problem?</p><BR><p>Use SANE's <code>RandomX</code> function instead of QuickDraw's <code>Random</code> function if possiblebecause it gives you better randomness. If you do use QuickDraw's <code>Random</code>function, be sure to call <code>InitGraf rect</code> before calling <code>Random</code> from any applicationor tool. <code>InitGraf rect</code> initializes a set of QuickDraw global variables for use withthe QuickDraw tools; these globals must be initialized because the <code>Random</code>function uses one of them as a seed to generate the random number.</p><p>Normally, it's not good practice to call initialization routines from within anMPW tool, but calling <code>InitGraf rect</code> is OK. For more information on which initialization routines are OK to call and which ones aren't, see page 7 in the MPW Tools chapter of Building and Managing Programs in MPW.</p><p>Sometimes it isn't obvious when you need to call <code>InitGraf rect</code> before using the<code>Random</code> function. For example, if you're using the Macintosh serial tool in afaceless background application, you'll need to initialize QuickDraw becausethe tool calls <code>Random</code>.</p><P><A HREF="#top">Back to top</A></p><H2>GetIconCacheData rect &amp; SetIconCacheData rect bug and workaround</h2><p>Date Written:  12/8/92</p><p>Last reviewed:  3/1/93</p><p>The Icon Utilities routine <code>GetIconCacheData rect</code> leaves two bytes of garbage on thestack. This surfaced as a problem for me because it prevented a saved registerfrom getting restored properly. <code>SetIconCacheData rect</code> probably has the same problem,since it calls the same trap internally. I solved the problem by encapsulating<code>GetIconCacheData rect</code> within my own static function, like so:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static OSErr _GetIconCacheData rect( Handle theCache, void **theData ){return  GetIconCacheData rect( theCache, theData );}#define  GetIconCacheData rect  _GetIconCacheData rect</pre>	</TD></TR></TABLE></CENTER><p>I then call <code>GetIconCacheData rect</code> normally. The #define redirects my call to mystatic wrapper function. The extra two bytes on the stack are recovered whenthe wrapper function UNLKs and returns. This method has the advantage that thecalling code will still work even after the trap is fixed. Am I correct?</p><BR><p>You're quite correct; this is a bug in <code>GetIconCacheData rect</code> and <code>SetIconCacheData rect</code>.Here's the offending code from the source:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>EXIT    MOVEA.L    (SP)+, A0   ; Pop return address into A0        ADDQ.L     #6, SP      ; Point stack at return value        MOVE.W     D0, (SP)    ; Put return value on the stack        JMP       (A0)         ; Return</pre>	</TD></TR></TABLE></CENTER><p>As you can see, the exit routine is adding 6 to the stack to clear up the inputparameters instead of 8 (handle and handle), so an extra word of garbage isbeing left on the stack. Thanks for letting us know about the problem.</p><P><A HREF="#top">Back to top</A></p><H2><code>DrawText</code> and DrawString patched to be script aware</h2><p>Date Written:  11/16/92</p><p>Last reviewed:  6/14/93</p><p>While localizing our software, we were told not to assume that a character isonly one byte, and thus not to use DrawChar. Does this mean that we can't use<code>DrawText</code> or <code>DrawString</code>?</p><BR><p><code>DrawChar</code> takes a one-byte character as a parameter, so it isn't suitable fordrawing a character whose internal representation requires two bytes. However, <code>DrawText</code> and <code>DrawString</code> (both end up in the same bottleneck procedure StdText) are patched in script-aware systems, and do recognize whether a given byte in a given font-script still corresponds to a one-byte character, or is the first byte of a two-byte character. In the latter case, it transparently fetches thenext byte, and looks up the right glyph encoded by a double byte, before actually drawing the glyph.</p><P><A HREF="#top">Back to top</A></p><H2>QuickDraw globals at INIT time</h2><p>Date Written:  6/1/92</p><p>Last reviewed:  9/15/92</p><p>If I call <code>InitGraf rect</code> before I reference <code>CurrentA5</code>, will <code>CurrentA5</code> be valid andcan the QuickDraw globals be referenced off it? The <code>screenBits</code> bounds valuesseem screwy on some machines. Does the problem lie with <code>CurrentA5</code>? Should I bereferencing A5?</p><BR><p>Here's the process used by <code>ShowINIT</code>, which is remarkably compatible with systemsoftware and other INITs (and it had better be, because it's used by more thanhalf the system extensions available):</p><ol type="1" start="1">	<li>It saves the value in the <code>CurrentA5</code> global to restore it later.</li>	<li>It points the A5 register at 4 bytes of storage for use by the system.</li>	<li>It copies the value now in A5 into the <code>CurrentA5</code> global.</li>	<li>It calls <code>InitGraf rect</code>, passing a pointer to the thePort field of a QuickDraw globals structure.</li>	<li>It opens a port and draws as necessary. [This is where all the functionality goes.]</li>	<li>After it's done, it closes its port.</li>	<li>It copies the value saved in step (1) into the A5 register.</li>	<li>It copies the restored A5 value into the <code>CurrentA5</code> global.</li></ol><p>To summarize, <code>ShowINIT</code> saves the A5, creates and initializes its own A5 world,does its drawing, then restores the previous A5 world. For more information on this subject, see the Macintosh Technical Note <u><A HREF = "../pt/pt_35.html">"Stand-Alone Code."</a></u></p><P><A HREF="#top">Back to top</A></p><H2>Macintosh QuickDraw LineTo bug and workaround</h2><p>Date Written:  4/23/92</p><p>Last reviewed:  7/13/92</p><p>Our zooming function crashes into flames when we pass valid coordinate valuesto <code>LineTo</code>, as in the following example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    SetPort(myPort);    MoveTo(154,31619);    LineTo(74, -31742); (* You are dead! *)</pre>	</TD></TR></TABLE></CENTER><p>What can we do to avoid <code>LineTo</code> crashes like this?</p><BR><p>The QuickDraw Engineering group is aware of the problem you described. The bugprobably is going to be fixed in the next release that includes bug fixes.Given that waiting for a system solution may demand more patience than isreasonable, you may want to consider including in your software some form ofworkaround that will prevent your users from crashing every time an operationtakes the software to the limits of QuickDraw.</p><p>One way to approach this problem is to replace the <code>lineProc</code> bottleneck. All youneed to do is to check the distance between the current pen position and the line's end, and when the distance becomes too big (let's say more than 32000) your procedure will call <code>StdLine</code> a couple of times, splitting the operation in two.</p><p>Replacing the bottlenecks is a very straightforward operation (which you areprobably already using) and in most of the cases will only result in anotherlevel of indirection into StdLine but that will prevent your program fromcalling QuickDraw with parameters that are guaranteed to cause crashes.</p><P><A HREF="#top">Back to top</A></p><H2>Use crsrNew flag to unobscure cursor without mouse move</h2><p>Date Written:  3/3/92</p><p>Last reviewed:  6/14/93</p><p>The Macintosh QuickDraw routine <code>ObscureCursor</code> hides the cursor until the nexttime the mouse is moved, but it isn't affected by <code>HideCursor</code> or <code>ShowCursor</code>. Ourapplication needs to use <code>ObscureCursor</code> while the user is typing but needs thecursor to be visible after no typing has occurred for a short period. How do we"undo" <code>ObscureCursor</code>, since we can't rely on the user to move the mouse?</p><BR><p>The only way (besides actual mouse movement) to make an obscured cursor visibleagain is to convince the system that the mouse has moved. There's no really good way to do this via Toolbox calls, so you're going to have to do it the hard way and simply update the low-memory cursor information to tell the system the cursor moved (even though you don't need to update the actual position).</p><p>To tell the system the cursor has changed location, simply set the <code>crsrNew</code> flag(a byte located at $<code>08CE</code>) to 1. When the system sees this byte is 1, it willassume the cursor has moved and redraw the unobscured cursor at the appropriateplace (where it was all along), and reset <code>CrsrNew</code>, waiting for the mouse tomove again.</p><P><A HREF="#top">Back to top</A></p><H2>Macintosh CalcMask and CopyMask code sample</h2><p>Date Written:  2/27/92</p><p>Last reviewed:  6/14/93</p><p>I can't get the black-and-white version of my lasso-type tool to work correctlywith <code>CalcMask</code> and <code>CopyMask</code>. With <code>CalcCMask</code> it seems to work fine. What could Ibe doing wrong?</p><BR><p><code>CalcMask</code> and <code>CalcCMask</code> are similar in that they both generate a 1-bit maskgiven a source bitmap. With <code>CalcCMask</code>, though, a pixMap can be used in place ofthe source bitmap; the <code>seedRGB</code> determines which color sets the bits in the maskimage. An easy mistake to make is to forget that <code>CalcCMask</code> accepts a pointer toa bitmap data structure while <code>CalcMask</code> expects a pointer to the actual bitimage. And unlike <code>CalcCMask</code>, which uses bounding <code>Rects</code> for the image'sdimensions, <code>CalcMask</code> uses the bitmap's <code>rowBytes</code> and pixel image offsets todetermine the bounding Rects for the image. A typical call to these routineswould be:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    BitMap source, mask;    CalcMask (source.baseAddr, mask.baseAddr, source.rowBytes,              mask.rowBytes, source.bounds.bottom-source.bounds.top,              source.rowBytes&gt;&gt;1);    CalcCMask (&amp;source, &amp;mask, &amp;(*source).bounds, &amp;(*mask).bounds,               &amp;seedRGB, nil, 0);</pre>	</TD></TR></TABLE></CENTER><p>One last thing to note when using <code>CalcMask</code> is that the width of the image is inwords and not bytes. To learn more about these routines, see page 24 of <i>Inside Macintosh</i> Volume IV and page 72 of <i>Inside Macintosh</i> Volume V. Also, the <i>Developer CD Series</i> disc contains a sample, <A HREF = "downloads/qd_505.hqx">CalcCMask&amp;CalcMask</a>, that shows how to use both these routines.</p><P><A HREF="#top">Back to top</A></p><H2>Code for filling an area fully bounded by polygon</h2><p>Date Written:  2/21/92</p><p>Last reviewed:  6/14/93</p><p>Currently, when a polygon is filled, an even-odd rule is applied to determinewhich areas of the polygon are to be filled. For our application, we also needto fill all the areas of the defined polygon. Is there a relatively easy way toaccomplish this?</p><BR><p>There are many different ways to fill polygons, as you may know. If you do notwant to use QuickDraw's standard <code>FillPoly</code> routine, you'll have to create yourown. The following sample illustrates one technique that might be used to fillthe area fully bounded by a polygon. It can be dropped right into the trafficlight sample (sample.p) that ships with MPW as a replacement for its <code>DrawWindow</code>procedure. The green star is drawn using <code>FillPoly</code> and the black star is drawnusing my filling technique that uses an offscreen bitmap and <code>calcMask</code> to fillin the poly the desired way, then <code>CopyBits</code> to transfer it to the onscreen port.The drawbacks of this method are that it is not as fast as writing aspecialized poly routine; the benefits are that it's small, fast enough formost operations, and can be used for more than just polygons.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>{$S Main}PROCEDURE DrawWindow(window: WindowPtr);var        MyPoly:PolyHandle;        MyRgn :RgnHandle;        OffPort,OnPort:GrafPtr;    Function    CreateOffport(VAR newOffscreen:grafPtr;inBounds:Rect):Boolean;    var    SavePort,NewPort:Grafptr;    begin        GetPort(SavePort);        NewPort:=GrafPtr(NewPtr(sizeof(grafport)));        If MemError&lt;&gt;noErr then Begin            CreateOffport:=false;            EXIT(CreateOffport);        END;        OpenPort(newPort);        With newPort^ do begin            portRect :=Inbounds;            RectRgn(ClipRgn,inBounds);            RectRgn(visRgn, inBounds);        End;        With newPort^.PortBits DO BEGIN            Bounds:=Inbounds;            rowBytes:= ((inBounds.right-inBounds.Left+15) DIV 16) *2;            baseAddr:= NewPtr(rowBytes                            * LONGINT(inBounds.Bottom-inBounds.Top));        End;        If MemError &lt;&gt;noErr THEN BEGIN            SetPort(SavePort);            ClosePort(newPort);            DisposPtr(ptr(newPort));            CreateOffport:=false;          END        ELSE  BEGIN            EraseRect(inBounds);            newOffscreen :=newPort;            setPort(SavePort);            CreateOffPort:=true;        end;    end;    Procedure    KillOffPort(oldOffscreen :GrafPtr);    Begin        ClosePort(oldOffscreen);        DisposPtr(OldOffscreen^.portBits.baseAddr);        DisposPtr(ptr(OldOffScreen));    End;BEGIN    If NOT (CreateOffPort(offPort,window^.portRect)) THEN Exit(DrawWindow);    If NOT (CreateOffPort(onPort,window^.portRect)) THEN Exit(DrawWindow);    SetPort(window);    MyRgn:=NewRgn;    OpenRgn;        MoveTo(10,25);        Lineto(70,25);        Lineto(15,70);        Lineto(40,10);        Lineto(65,70);        Lineto(10,25);    CloseRgn(MyRgn);    MyPoly:=OpenPoly;        MoveTo(10,25);        Lineto(70,25);        Lineto(15,70);        Lineto(40,10);        Lineto(65,70);        Lineto(10,25);    ClosePoly;    OffsetPoly(MyPoly,0,100);    SetPort(OffPort);    FramePoly(MyPoly);    { Now &quot;Fill the poly&quot; the right way }    CalcMask(    Offport^.portBits.BaseAddr,OnPort^.portBits.BaseAddr,                OffPort^.portBits.RowBytes, OnPort^.portBits.RowBytes,                OffPort^.portRect.bottom-OnPort^.portRect.Top,                OffPort^.portBits.RowBytes DIV 2);    SetPort(OnPort);    SetPort(Window);    If gStopped then        CopyBits(    OnPort^.portBits, Window^.portBits,                    OnPort^.portRect, Window^.portRect, srcCopy, NIL)    ELSE        CopyBits(    OffPort^.portBits, Window^.portBits,                    OffPort^.portRect, Window^.portRect, srcCopy, NIL);    IF gStopped THEN      begin        ForeColor(greenColor);        FrameRgn(MyRgn);      end    ELSE      begin        ForeColor(greenColor);        PaintRgn(MyRgn);      end;    ForeColor(blackColor);    DisposeRgn(MyRgn);    KillPoly(MyPoly);    KillOffPort(Offport);    KillOffPort(OnPort);END; {DrawWindow}</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></p><H2>Inside Macintosh Vol. V PICT opcode size should be fixed</h2><p>Date Written:  1/22/92</p><p>Last reviewed:  2/28/92</p><p>The definition of PICT version 2 on pages 92-105 of <i>Inside Macintosh</i>Volume V says that the data size of the opcodes <code>$001A</code> and <code>$001B</code> is variable,but also that the data is an <code>RGBColor</code>. This is confusing, since the size of an<code>RGBColor</code> is fixed at six bytes. How can these two opcodes vary in the amount ofassociated data?</p><BR><p>Seems like you've run into a cut/paste problem. All the opcodes that refer toTable 4 are new for Color QuickDraw. Also, most of them are variable in length,so the author simply had a standard notation for anything that was explainedfurther in table 4 (page V-103). The information contained in table 4 is, infact, accurate. The size information of several of the opcodes listed is notvariable even though the preceding pages told you they were.</p><p>All you gotta do is believe Table 4 and you will be fine.</p><P><A HREF="#top">Back to top</A></p><H2>PICTs with PostScript PICT comments and memory use</h2><p>Date Written:  1/10/92</p><p>Last reviewed:  6/14/93</p><p>Why does my PICT (including dotted lines) use so much memory when drawn inMacDraw, and even more when drawn in SuperPaint? Do they include <code>PicComments</code>for PostScript?</p><BR><p>Your guess that it has to do with PicComments is quite right; both MacDraw andSuperPaint include a PostScript representation of the dotted (dashed) lines andsome other graphic operations in the PICT, together with the QuickDrawcommands. During printing, this allows the LaserWriter driver to take advantageof specific PostScript capabilities that are unavailable in QuickDraw, likeprimitives for dashed lines.</p><p>On the other hand, the PostScript representation for dashed lines is muchshorter than the QuickDraw representation, which requires a (long, very long...) sequence of <code>ShortLine</code> opcodes. So, another piece of explanation for thelarge PICT size basically is that QuickDraw does not have facilities todescribe dotted lines in an economic way.</p><p>SuperPaint also includes a copy of a proprietary dictionary, which addssubstantially to the size of a PICT. On the other hand, the code that residesin that dictionary makes the picture's PostScript representation that muchbetter. Ultimately, WYSIWYG is the goal, and sometimes it takes a little extracode to make that happen. (Incidentally, the PostScript dictionary contained inpictures created by older versions of SuperPaint makes assumptions about thecontents of the LaserPrep file which are not true for the recent versions ofthe LaserWriter driver. Documents containing such pictures will not printcorrectly any more.)</p><p>To determine the primitives that define other nonstandard QuickDraw objectsfound in drawing applications, you can use MPW's <code>DeRez</code> function or athird-party utility such as Palomar Software's PICT Detective on the resourcePICT. These tools will provide the opcodes that define the PICT.</p><P><A HREF="#top">Back to top</A></p><H2>Where <code>CopyBits</code> looks for memory to use</h2><p>Date Written:  1/3/92</p><p>Last reviewed:  1/27/92</p><p>Where does <code>CopyBits</code> look for the memory it needs?</p><BR><p><code>CopyBits</code> checks the stack to determine if there is enough stack space for it tocopy the whole image, which in some cases may be roughly up to 5 extra rowbytesof special effects per row, depending on what special effects such as ditheringor scaling are being used. If there is not enough stack space for the wholeimage, <code>CopyBits</code> then tries for half the image, and keeps halving until it getsdown to one row of the image (plus the room for the special effects rows). Ifthere is not enough stack space for one row of the image, then <code>CopyBits</code> triesto allocate temporary memory.</p><p>Before allocating temporary memory, <code>CopyBits</code> checks if the temporary memorytraps are available. (They are available under both System 6 MultiFinder andSystem 7.) If the traps are available, <code>CopyBits</code> tries to allocate a 256K bytebuffer for use as a "fake" stack. (<code>CopyBits</code> used to try for a 64K block, butthis has been changed, and it may change again.) If this succeeds, then all iswell and the image is copied. If the temporary memory traps do not exist, or if<code>CopyBits</code> cannot allocate a 256K buffer, then the image is not copied and<code>CopyBits</code> returns.</p><p><code>CopyBits</code> does not check in the application heap for free memory, at least notfor its work buffer. For its work buffer it will only use the stack, and afterthat it resorts to temporary memory, if available. There are some circumstancesthat may cause memory allocations in the application heap, but this memory isnot used for <code>CopyBits</code>'s image buffer.</p><p>Also, please note that the implementation of <code>CopyBits</code> is subject to change infuture versions of QuickDraw.</p><P><A HREF="#top">Back to top</A></p><H2>GrafPort patStretch: valid values</h2><p>Date Written:  12/19/91</p><p>Last reviewed:  6/14/93</p><p>I'd like to know more about that <code>PatStretch</code> field inside a <code>GrafPort</code> or<code>CGrafPort</code>. If I stuff a values in <code>PatStretch(4)</code> then nothing happens; printslook the same, even using a standard bottleneck. Please tell me how I can getthis to work.</p><BR><p><code>PatStretch</code> only works with values of 2 or 3. With any other value, it defaultsto no stretching. The "2" case was created because of the ImageWriter(72-&gt;144 dpi) situation. The "3" case was added to support the ImageWriterLQ and the AppleFax modem.</p><p>So why wasn't a "4" (72-&gt;300 dpi) handler added for the LaserWriter driver?Good question. Somehow or other it was decided that pattern stretching for theLaserWriter driver would be done completely by the driver itself. TheLaserWriter driver actually does pattern stretching by using a pattern 4 timesas large, rather than 4.17. In other words, it really scales the 72 dpi patternto 288 dpi rather than 300 dpi. You may want to take a similar approach, sinceyou'd only have to work with whole numbers this way.</p><p>So, if you want to do 4-times pattern stretching, you must scale the patternyourself. If you copy the original pattern into an area that's twice as wideand twice as tall and use that, you should be all set. You'll need to usePrGeneral to set the printer to the appropriate resolution and <code>CopyBits</code> to copythe pattern into the object that needs to be filled, using the "cookie cutter"approach to fill the object.</p><p>X-Ref:<i>Inside Macintosh</i> Volume I, page I-150</p><P><A HREF="#top">Back to top</A></p><H2>How to tell whether GetPictInfo is available</h2><p>Date Written:  12/16/91</p><p>Last reviewed:  6/14/93</p><p>How do you determine whether the Picture Utilities Package function <code>GetPictInfo</code>is available? <code>Gestalt</code> doesn't seem to have the right stuff!</p><BR><p>To determine whether the <code>GetPictInfo</code> routine is available, check the systemversion number with the Gestalt function. <code>GetPictInfo</code> is available in systemsoftware version 7.0 and later. Use the Gestalt selector <code>gestaltSystemVersion</code>to determine the version of the system currently running. Usually it's best notto rely on the system version to determine whether features are available, butin this case, it's the only way to determine whether the Picture UtilitiesPackage is available.</p><p>For example, the following C function will determine whether the GetPictInfocall is available:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#include &lt;GestaltEQU.h&gt;Boolean IsGetPictInfoAvail(){OSErr err;long feature;err = Gestalt(gestaltSystemVersion,&amp;feature);/* Check for System 7 and later */return (feature &gt;= 0x00000700);}</pre>	</TD></TR></TABLE></CENTER><p>In <i>Inside Macintosh</i> Volume VI, see page 3-42 for information on usingGestalt to check the system version number, and see page 18-3 for informationon the Picture Utilities Package.</p><P><A HREF="#top">Back to top</A></p><H2>Detecting whether application window is partially hidden</h2><p>Date Written:  9/26/92</p><p>Last reviewed:  6/14/93</p><p>We draw directly to the screen to gain the fastest possible animation speed,and when we need compatibility--such as when windows overlap or for multiplescreens--we do use <code>CopyBits</code>. How do we tell whether the window is hidden orthat the visible part is not rectangular?</p><BR><p>If your window is covered partially by another applications window or if yourlayer has been hidden by the process menu, the <code>visRgn</code> of your window's grafportwill not be the <code>portRect</code> anymore. (Keep in mind that if you scroll by modifyingthe <code>portRect</code> of the <code>grafport</code>, then you'll have to do a more complex calculation...) Here is a small Pascal routine that returns this information:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Function Use<code>CopyBits</code>(thePort:grafptr):Boolean;begin     Use<code>CopyBits</code>:= NOT( (thePort^.VisRgn^^.rgnSize=10) and        (thePort^.visRgn^^.RgnBBox=thePort^.PortRect) );end;The rect strucRgn^^.rgnBBox will be zero for a visible window if the systemhas hidden the application.</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></p><H2>CopyBits bug and workaround</h2><p>Date Written:  6/26/91</p><p>Last reviewed:  6/14/93</p><p>Has anyone run across what I'm told is a bug in <code>CopyBits</code>? It works like this:In the deep, dark workings of <code>CopyBits</code>, some routine tries to read the twobytes preceding the <code>baseAddress</code> of the source <code>PixMap</code>. If the <code>baseAddress</code> is atthe start of a card's NuBus space and there isn't a card filling the adjacentspace, this causes a bus error! Has anyone found a good workaround?</p><BR><p>The short answer is: you're right. QuickDraw inadvertently reads from memorybelow the base address of a pixmap. The workaround is to place the video baseaddress 32 bytes into the slot memory space for the card; if the card you'reusing doesn't have this workaround, there's nothing you can do other thanmaking sure there's a card in the next-lower slot.</p><P><A HREF="#top">Back to top</A></p><H2>Macintosh animation samples</h2><p>Date Written:  11/6/91</p><p>Last reviewed:  6/14/93</p><p>Do you have an example of flicker-free animation on the Macintosh?</p><BR><p>We have some good stuff that's written in MPW Pascal. It's DTS Sample Code #16, OffSample, and this uses some routines defined in DTS Sample Code #15, <A HREF = "downloads/SC.015.Offscreen.sea.hqx">OffScreen</a>. Also, the System 7.0 CD sample code folder contains a smaller sample called <A HREF = "downloads/gmonde-1-1a1.hqx">"GMonde"</a> that uses GWorlds.</p><P><A HREF="#top">Back to top</A></p><H2>System 7 QuickDraw <code>DrawText</code> performance</h2><p>Date Written:  11/4/91</p><p>Last reviewed:  11/27/91</p><p>We've noticed that using <code>DrawText</code> is much slower in System 7, especially whendrawing in color (anything other than black on white). What can be done torestore the drawing speed to System 6 levels?</p><BR><p>A QuickDraw function like DrawString or <code>DrawText</code> will be slower under certaincircumstances in System 7 than System 6. Specifically, if you are drawing in<code>srcCopy</code> mode and you colorize the text--that is, foreground color is not blackand background color is not white <i>(Inside Macintosh</i> Volume VI, page17-16)--then QuickDraw really slows down as you have noticed. <i>Sometimes,</i>the speed of drawing is 6 times as slow as System 6.</p><p>The cause of this slowness is a known System 7 bug. The bug has concerned theengineers greatly and will be responded to in an appropriate manner in the future.</p><p>There are a few workarounds: One, you can avoid using the <code>srcCopy</code> mode and usethe default <code>srcOr</code> mode instead. However, this is not a real workaround, sinceyou may have essential reasons to use <code>srcCopy</code>. The other option is to create anoffscreen pixmap or <code>GWorld</code> and perform a <code>DrawText</code> with <code>srcOr</code> to this <code>GWorld</code>with colorization. Then, you can perform a <code>CopyBits</code> from the offscreen to thescreen with <code>srcCopy</code> mode and no colorization. Using <code>CopyBits</code> will not cost youmuch time. Again, this is a workaround and is not ideal.</p><p>The srcOr is a bit slower than in System 6.0.x, but it does not have a bug;rather it is a side effect of system enhancements. The slow speed is atrade-off taken to receive the host of other benefits.</p><P><A HREF="#top">Back to top</A></p><H2>Updating Macintosh cursor without mouse competition</h2><p>Date Written:  6/12/91</p><p>Last reviewed:  6/14/93</p><p>How can I programmatically move the Macintosh mouse without the real mouse interfering?</p><BR><p>The real answer to your question is twofold: First, you can do exactly what youwant to do with the sample included below. <i>However,</i> this is not a goodthing to do, it would be better if you took the solution used in Apple's GuidedTour disks: Always hide the cursor and then decouple the cursor from the mouse.Then, instead of using the system's cursor, simply draw your own "cursor" usingQuickDraw and treat it as a little animated bitmap on the screen. This avoidsall the problems that you have with the mouse competing. (Apple does update themouse globals with the mouse position so that other things function correctly.)</p><p>Now, as promised, here is the way to do what you want using the real cursor. Asyou have discovered, setting the <code>crsrCouple</code> variable to false prohibits themouse from affecting the cursor; unfortunately, it also prohibits the <code>jcrsrTask</code>routine from drawing the cursor. The solution to this is to set <code>crsr</code> couple toTRUE, call the cursor drawing routine <code>jCrsrTask</code> yourself, and then set the<code>crsrCouple</code> variable to false, as shown below:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>procedure callcrsr;              inline $2078 ,$08EE ,$4E90;{            move.L    jcrsrTask,A0            jsr    (A0) }Procedure FudgeMouse;type    PointPtr=^Point;var        RawMouse:PointPtr;        MTemp:PointPtr;        RandPt:Point;        CrsrNew:ptr;        CrsrCouple:ptr;        fred:Longint;begin        RawMouse:=PointPtr($82C);        MTemp:=PointPtr($828);        CrsrNew:=ptr($8CE);        CrsrCouple:=ptr($8CF);        RandPt:=RawMouse^;        repeat            RandPt.h:=RandPt.h+1;            RandPt.V:=RandPt.v+1;            RawMouse^:=RandPt;            MTemp^:=RandPt;            CrsrNew^:=1;            CrsrCouple^:=1;            callCrsr;            crsrCouple^:=0;            repeat until fred&lt;tickCount;            fred:=tickCount+3;        until Button;        crsrCouple^:=1;end;</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></p><H2>Techniques for graying Macintosh text</h2><p>Date Written:  6/3/91</p><p>Last reviewed:  6/14/93</p><p>How do I draw grayed-out text on the Macintosh, like the text for disabledbuttons or menu items?</p><BR><p>There are currently two different kinds of grayed text: First, there's"patterned" gray, where every other dot is missing. This really only looks goodwith Chicago or other heavy fonts and was always used for graying out menus andcontrols in system software through 6.0.x, and is still used in 7.0 when thescreen is set to less than 4 bits deep. This is done by first drawing the textin a normal, <code>srcCopy</code> transfer mode. Then a gray rectangle is drawn over thetext using the <code>patBic</code> mode. This "erases" half the bits in the text, and israpid enough that there is very rarely any flicker.</p><p>The second kind of text is the actually gray text, which is used in System 7 onscreens that are 4 bits deep or deeper for menus, controls, and other grayedtext. To draw this text, just call <code>GetGray</code> (as documented on page 17-27 of<i>Inside Macintosh</i> Volume VI) to get an appropriate gray. Then draw thetext in that color.</p><P><A HREF="#top">Back to top</A></p><H2>Use srcOr instead of srcCopy for Macintosh text drawing</h2><p>Date Written:  6/4/91</p><p>Last reviewed:  10/9/91</p><p><code>DrawText</code> with srcCopy takes six times as long as with <code>srcOr</code> now that myMacintosh is running System 7. Why is this so slow? Is this a bug in System 7?</p><BR><p>It's true that <code>srcCopy</code> is slower than <code>srcOr</code> when handling text, especially incolor mode. This loss in speed occurs because <code>CopyBits</code> is a lot smarter than itused to be. It can handle foreground and background colors a lot better, butthat improvement came at the cost of speed. Our recommended method for drawingtext is to erase before drawing, and use <code>srcOr</code> to draw, not <code>srcCopy</code>.Alternatively, you could draw colorized text in srcOr mode off screen and thenuse <code>CopyBits</code> to draw it on the screen in <code>srcCopy</code> mode without colorization.</p><P><A HREF="#top">Back to top</A></p><H2>Code for reversing Macintosh PICT images</h2><p>Date Written:  3/4/91</p><p>Last reviewed:  6/14/93</p><p>Is there a simple way to put PICT images up in mirror image format, or is theresample code showing how to flip an offscreen bitmap?</p><BR><p>There is no easy way to do this, nor do we have sample code showing how to flipan offscreen bitmap. Indeed, the best way to do what you want is to draw it toan offscreen pixel map and reverse it.</p><p>If you are using Color QuickDraw, always draw it to an 8-bit-per-pixeloffscreen bitmap, and then the reverse is a very simple task. Here is some sample Pascal code that might roughly do what you want, with the following assumptions:</p><ol type="1" start="1">	<li>You are going to add error checking where appropriate.</li>	<li><code>Rowbytes</code> correspond exactly to pixel width of the port.</li>	<li>The port is 8 bits deep.</li>    	<li>You add the code to make this sketch work.</li>    	<li>The origin of your offscreen port is (0,0).</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Procedure FlipScanLine(theV:Integer; thePort:cGrafPtr);{ Given any scan line number in the indicated port, this routine will flip }{ that scan line horizontally. This routine assumes that you have made     }{ sure that scan line theV exists. }type ScanLn=Packed Array [0..0] of Byte;   ScanPtr=^ScanLine;var thePixMap:PixMapPtr;   Index,Size:Integer;   ThisScanLine:ScanPtr;   TempPixel:Byte;Begin thePixMap:=thePort^.PortPixMap^;{ First create a pointer to the scan line we are currently reversing. } ThisScanLine:=ScanPtr(thePixMap^.BaseAddr); ThisScanLine:=ScanPtr(ord4(ThisScanLine)+(thePixMap^.RowBytes*theV));{ Now simply reverse all the bytes. }{ The scan line is simply an array [0..RowBytes] of Byte, and since this is }{ 8 bits per pixel, each one is a single pixel.} Size:=thePixMap^.RowBytes; For Index:=0 to (Size div 2) do  begin   tempPixel:=ThisScanLine^[Index];   ThisScanLine^[Index]:=ThisScanLine[Size-Index-1];   ThisScanLine^[Index]:=tempPixel;  end;end;</pre>	</TD></TR></TABLE></CENTER><p>This same procedure can be used also to swap a 1-, 2- or 4-bit-per-pixel pixmapif you add a function that accepts a byte and swaps the pixels in it.</p><P><A HREF="#top">Back to top</A></p><H2>Using dithered drawing mode with QuickDraw</h2><p>Date Written:  11/28/90</p><p>Last reviewed:  12/19/90</p><p>When I draw a 32-bit Macintosh PICT image from a file to an 8-bit port via anoffscreen <code>GWorld</code>, I use dither mode in the <code>CopyBits</code> call and the results arequite impressive. If there is not enough memory to allocate the <code>GWorld</code>, I drawthe image directly to the port. But since there does not seem to be any way totell QuickDraw to use dithered drawing mode, the image looks horrible.</p><p>Do you have any suggestions? I have installed bottleneck procs to allow<code>DrawPicture</code> to get its data from the file instead of the handle in memory. Isthere a way, while in the bottlenecks, to find the <code>CopyBits</code> call that comesfrom the picture and force it to use dithered mode instead of source mode? Idon't want to try and parse the PICT myself, but I thought that maybe aQuickDraw global could be modified in my <code>StdBits</code> proc to force dithered drawing for that operation only?</p><BR><p>You can install a <code>StdBits</code> or <code>bitsProc</code> bottleneck procedure to get all the<code>CopyBits</code> calls when the picture is being played back. One of the parameters tothe <code>StdBits</code> call is the mode. You can install a procedure that saves thecurrent mode, and then passes ditherMode to the original <code>StdBits</code> proc. This isall you should need to do. It's been done here so we know it works, only not inany form that can be sent to you as sample code at this time.</p><P><A HREF="#top">Back to top</A></p><H2>Using PicComments to rotate text</h2><p>Date Written:  11/28/90</p><p>Last reviewed:  12/19/90</p><p>I have a PostScript routine (using <code>TextBegin/TextEnd</code>) to generate bitmappedrotated text on the screen (which can be later printed on QuickDraw printers).Why do I get duplicate text? I get both bitmapped rotated text and PostScriptrotated text when I print on the LaserWriter II, and both bitmapped rotatedtext and horizontal text on the ImageWriter. When I make a machine dependentcheck (check type of printer) and call the proper printing procedure, it worksfine. Because of the speed and memory considerations of generating the rotatedbitmapped text (especially at 300 dpi), is there a way to ensure that theprinter will use the PostScript BEFORE generating the bitmap?</p><BR><p>We will use the following Macintosh <code>PicComments</code> to hide your QuickDraw callsfrom the LaserWriter, but the ImageWriter will use them:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>PostScriptBegin &gt;&gt; Put your CopyBits and QuickDraw calls to image your rotated &gt;&gt; bitmapped text here....PostScriptEnd</pre>	</TD></TR></TABLE></CENTER><p>By wrapping your QuickDraw code within the <code>PostScriptBegin</code> and <code>PostScriptEnd</code><code>PicComments</code>, the code will be ignored by the LaserWriter, but the ImageWriter will use the QuickDraw calls. Basically, the <code>PostScriptBegin</code> and <code>PostScriptEnd</code> PicComments tell the LaserWriter driver to turn "off" QuickDraw. In theImageWriter case, the ImageWriter does not understand the PicComments. Therefore, it will use the QuickDraw calls to create and image your bitmapped text.</p><p>Now, we need to use the rotation <code>PicComments</code> to rotate the text on theLaserWriter, but have the ImageWriter ignore the code:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Rect  zeroRect;SetRect (&amp;zeroRect, 0, 0, 0, 0);TextBeginTextCenter      ClipRect (&amp;zeroRect);      &gt;&gt; Draw your text to be rotated on the LaserWriter....      ClipRect (&amp;rPageRect);TextEnd</pre>	</TD></TR></TABLE></CENTER><p>Wrapping your text drawing call(s) between the <code>ClipRect</code> calls will ensure thatthe text is drawn only on the LaserWriter. Setting the <code>ClipRect</code> to zero tellsthe ImageWriter to ignore all QuickDraw calls until the <code>ClipRect</code> is reset tosomething "real" (actually, a zero <code>ClipRect</code> prevents QuickDraw from drawinganything). After we have completed drawing the rotated text, we reset the<code>ClipRect</code> to the dimensions of <code>rPage</code> (that is, <code>rPage</code> is the image-able area ofthe currently selected printer--see <i>Inside Macintosh</i> Volume II, page150). This will allow all of your normal drawing to continue on the ImageWriterand LaserWriter. If you did not reset the ClipRect after the <code>TextEnd</code> call,nothing would be drawn on the ImageWriter or LaserWriter.</p><P><A HREF="#top">Back to top</A></p><H2>Why grafPort's clipRgn should be changed before OpenPicture</h2><p>Date Written:  11/1/90</p><p>Last reviewed:  12/19/90</p><p>On page 189 of <i>Inside Macintosh</i> Volume I, in the QuickDraw chapter'sdescription of <code>OpenPicture</code>, is the following warning: "A grafPort's clipRgn isinitialized to an arbitrarily large region. You should always change theclipRgn to a smaller region before calling OpenPicture, or no drawing may occurwhen you call DrawPicture." The "arbitrarily large" clipping region rectangleis set to -32767,- 32767,32767,32767 (top, left, bottom, right) for new ports.This is the largest rectangle possible. If this is not a "valid" clippingrectangle for pictures, what is? Is there some specific limit to the size ofthe clipping rectangle? Does it depend on either available memory or the sizeof the picture?</p><BR><p><i>Inside Macintosh'</i>s warning is based on truth but it's incomplete. It didn'tactually say that this rectangle is invalid as a clipping region, because thisis in fact a perfectly valid clipping region. But, you could run into problemsif you use this as a clipping region when creating a QuickDraw picture. It'snot a matter of available memory or size; it's a simple matter of 16-bit signedinteger overflow and underflow.</p><p>When you open a picture, the current clip region is recorded in the picture(this wasn't necessarily true in some early versions of QuickDraw). When youdraw the resulting picture using the picture's picFrame as the destinationrectangle, there won't be any problems. But if you use a destination rectanglethat's larger than the <code>picFrame</code>, QuickDraw scales everything in the pictureproportionately, including the clip region. If you allowed the default clipregion to be recorded into the picture, then its <code>rgnBBox</code>, already as large aspossible, will be made even larger. That means that the -32767 coordinatesmight wrap around to the positive number range, and the 32767 coordinates mightwrap around to the negative number range. This leaves you with an empty clipregion. Nothing at all gets drawn when the current port's clip region is empty.</p><p>If the destination rectangle is smaller than the picture's <code>picFrame</code>, you won'thave any problems because the default clip region will be made smaller, andthat's no problem.</p><p>This is why <i>Inside Macintosh</i> suggests that you make the clip regionsmaller than the default clip region before opening a picture. By doing this,you're almost guaranteed that the clip region won't get scaled to the pointthat it turns inside out. What size should you make it? Small enough so thatthe risk of the clip region's coordinates being scaled out of QuickDrawcoordinate space is minimal. I usually just set the clip region to the picFrame of the picture. It's hard to go wrong this way.</p><P><A HREF="#top">Back to top</A></p><H2>Calling InitCursor instead of SetCursor</h2><p>Date Written:  10/23/90</p><p>Last reviewed:  6/14/93</p><p>Is it legal to call <code>InitCursor</code> instead of <code>SetCursor(arrow)</code> when I want to setthe cursor to an arrow (after my normal one-time program initialization code,in my <code>UpdateCursor</code> routine)? The only reason I'd want to do such a nasty thingis to save code. Calling a trap with no parameters is less code than one withparameters. What, exactly, if anything, does <code>InitCursor</code> do besides setting thecursor to an arrow and setting the cursor level to zero?</p><BR><p>There's no problem at all with this, as long as you are aware that the hidden,busy, and obscured states are cleared when you call <code>InitCursor</code>, so if thecursor was hidden or obscured for good reason it'll suddenly reappear. It alsogets the arrow from QuickDraw, of course, but that's not a problem.</p><P><A HREF="#top">Back to top</A></p><H2>Macintosh PICT-to-PostScript conversion</h2><p>Date Written:  8/3/90</p><p>Last reviewed:  10/8/91</p><p>How do I convert PICT format data to PostScript in my printer driver?</p><BR><p>Converting PICT files to PostScript involves a detailed understanding of bothbitmaps (or pixmaps) and the graphics state in PostScript, which is a datastructure defining the context in which other graphic operators in PostScriptexecute. If you don't know PostScript, the following manuals are a must:</p><ul type="circle">	<li>PostScript Language Tutorial and Cookbook (Addison-Wesley) is an introduction to PostScript.</li>	<li>PostScript Language Reference Manual (Addison-Wesley).</li>	<li>PostScript Language Program Design (Addison-Wesley) details designing efficient PostScript programs. It has a lot of useful sample programs on topics like writing a print spooler.</li></ul><p>You need to convert all the QuickDraw operations in a PICT to correspondingPostScript operations. To get a feel for this conversion, you can analyze thePostScript dump from a LaserWriter to see how it converts a PICT to PostScript.Under System 6.x, a PostScript dump can be obtained by pressing Command-K whileprinting. Under System 7.0, you can get a dump by selecting the PostScript Fileoption in the Print dialog.</p><p>Some areas of QuickDraw, such as transfer modes, do not have a correspondencein PostScript. The PostScript imaging model is designed so that all areas of apage affected by an image are marked as if with opaque paint. Using image maskscan help. See the Graphics chapter in the PostScript reference manual.</p><p>PICT-to-PostScript conversion can be a long process, especially if one isunfamiliar with PostScript. Using the above books and the PostScript dump fromthe LaserWriter (but ONLY as a general guide) should help.</p><P><A HREF="#top">Back to top</A></p><H2>Sending PostScript via PostScriptHandle PicComment</h2><p>Date Written:  5/1/90</p><p>Last reviewed:  10/9/91</p><p>If I use the <code>PostScriptHandle PicComment</code> to send PostScript code to theLaserWriter driver, do I need to open a picture and then draw the picture tothe driver, or can I just use the <code>PicComment</code> with no picture open while drawingto the printer's <code>grafPort</code>?</p><BR><p>You don't need to create a picture with your <code>PicComment</code> in it and draw thepicture to the driver. The best method for sending PostScript code to theLaserWriter is to use the <code>PostScriptHandle PicComment</code> documented in theMacintosh Technical Note "Optimizing for the LaserWriter--Picture Comments," as shown below.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>PrOpenPage(...){ Send some QuickDraw so that the Printing Manager gets a }{ chance to define the clipping region. }PenSize(0,0);MoveTo(0,0);LineTo(0,0);PenSize(1,1);PicComment(PostScriptBegin, 0, NIL);{ QuickDraw representation of graphic. }MoveTo(100, 100);LineTo(200, 200);{ PostScript representation of graphic. }thePSHandle^^ := '100 100 moveto 200 200 lineto stroke';PicComment(PostScriptHandle, GetHandleSize(thePSHandle),        thePSHandl);PicComment(PostScriptEnd, 0, NIL);PrClosePage(...)</pre>	</TD></TR></TABLE></CENTER><p>The above code prints a line on any type of printer, PostScript or not. Thefirst <code>MoveTo/LineTo</code> combination is required to give the LaserWriter driver achance to define a clipping region. The LaserWriter driver replaces the<code>grafProcs</code> record in the <code>grafPort</code> returned from <code>PrOpenDoc</code>. In order for theLaserWriter driver to get execution time, you must execute a QuickDraw drawingroutine that calls one of the <code>grafProcs</code>. In this case, the <code>MoveTo/LineTo</code>combination calls the <code>StdLine grafProc</code>. When <code>StdLine</code> executes, it notices thatthe <code>grafPort</code> has been reinitialized, and therefore initializes the clippingregion for the port. Until the <code>MoveTo/LineTo</code> combination is executed, theclipping region for the port is set to (0,0,0,0). If PostScript code is sentvia the <code>PostScriptHandle</code> <code>PicComment</code> before executing any QuickDraw routines,all PostScript operations will be clipped to (0,0,0,0).</p><p>The next thing that's done is to send the <code>PostScriptBegin PicComment</code>. Thiscomment is recognized only by PostScript printer drivers. When the driverreceives this comment, it saves the current state of the PostScript device (byexecuting the PostScript gsave operator), then disables all QuickDraw drawingoperations. This way, the QuickDraw representation of the graphic will beignored by PostScript devices. In the above example, the second <code>MoveTo/LineTo</code>combination is executed only on non-PostScript devices.</p><p>The next <code>PicComment</code> is PostScriptHandle, which tells the driver that the datain <code>thePSHandle</code> is to be sent to the device as PostScript code. The driver thenpasses this code unchanged to the PostScript device for execution. The<code>PostScriptHandle</code> comment is recognized only by PostScript printer drivers.</p><p>The last <code>PicComment</code>, <code>PostScriptEnd</code>, tells the driver to restore the previousstate of the device (via a PostScript <code>grestore</code> call), and to enable QuickDrawdrawing operations.</p><p>Since most <code>PicComments</code> are ignored by QuickDraw devices, only the QuickDrawrepresentation is printed. Since <code>PostScriptBegin</code> tells PostScript drivers toignore QuickDraw operations, only the PostScript representation is printed onPostScript devices. This is a truly device-independent method for providingboth PostScript and QuickDraw representations of a document.</p><P><A HREF="#top">Back to top</A></p><H2>Macintosh QuickDraw region quirks</h2><p>Date Written:  1/1/90</p><p>Last reviewed:  11/21/90</p><p>I'm working with regions, and I'm having problems with Macintosh QuickDrawtrashing the heap and crashing, even though my regions are under 32K.</p><BR><p>There are some quirks in the current version of QuickDraw. Here are some thecommonly-encountered problems:</p><ol type="1" start="1">	<li>When doing operations which use more than one region, sduch as <code>UnionRgn</code>, <code>DiffRgn</code>, <code>XorRgn</code>, or <code>SectRgn</code>, the sum of the sizes of the source regions <i>must be less than</i> 32K,  regardless of the size of the resulting region.</li>	<li><code>FrameRgn</code> will fail if it tries to frame a region bigger than 16K.</li>	<li>If <code>CloseRgn</code> fails, the internal region data is already corrupt; there is nothing you can do to recover. <code>CloseRgn</code> will also fail if there isn't at least a 32K block of free space available.</li></ol><p>Here are some workarounds:</p><ol type="1" start="1">	<li>Keep regions small and not too complex. Keep track of the sizes of all regions so you can check the SUM of the sizes before calling a routine that has a 32K limit.</li>	<li>Keep 32K free, or allocate a 32K block and release it just before calling CloseRgn.</li></ol><p>Apple is working on these problems and expects to fix them in future versions of QuickDraw.</p><P><A HREF="#top">Back to top</A></p><H2>How to get Macintosh QuickDraw arc endpoints</h2><p>Date Written:  1/1/90</p><p>Last reviewed:  6/14/93</p><p>Is there a way to obtain the endpoints of an arc drawn by the MacintoshQuickDraw arc routines, such as <code>FrameArc</code> and <code>PaintArc</code>?</p><BR><p>Given a rectangle R which frames the arc you wish to draw, convert your anglesto an absolute coordinate system, where three o'clock is 0 degrees and 12o'clock is 90 degrees.</p><p>Now, let:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    x = .5 (+ or -) (R.right - R.left)    y = .5 (+ or -) (R.bottom - R.top)</pre>	</TD></TR></TABLE></CENTER><p>The endpoint of the curve will be defined by:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    EndPoint.h = x (+ or -) cos(ang);    EndPoint.v = y (+ or -) sin(ang);</pre>	</TD></TR></TABLE></CENTER><p>h &amp; v are relative to center of rectangle R</p><p>This calculates only the upper endpoint of the arc, but you can easilycalculate the other endpoint using the same formula by calculating the absoluteangle for the start point and applying the same formula.</p><p>Here is a subroutine which illustrates the algorithm, in ThinkSpeed Pascal:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>{ DrawCurve: draw an arc from 0 degrees until the point defined }{ by 'angle'. At that point draw a 4 by 4 crosshair. }procedure DrawCurve (frame : Rect; angle : integer);var  x, y : integer;  xr, yr : extended;  rad : extended;begin  { Convert angle to radians }  rad := (90 - angle) / 180 * 3.14159;  { Find end point }  xr := (frame.right - frame.left) * cos(rad) / 2;  yr := (frame.bottom - frame.top) * sin(rad) / 2;  x := (frame.right + frame.left) / 2 + Num2Integer(xr);  y := (frame.bottom + frame.top) / 2 + Num2Integer(yr);  { Draw crosshair }  MoveTo(x - 4, y);  LineTo(x + 4, y);  MoveTo(x, y - 4);  LineTo(x, y + 4);  { Draw arc }  FrameArc(frame, 0, angle);end;</pre>	</TD></TR></TABLE></CENTER><a name="Downloads"></a>         <P><A HREF="#top">Back to top</A></p><H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (80K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/qd_505.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/qd/qd_505.html%3Fid%3DDTS10002735-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/qd/qd_505.html%3Fid%3DDTS10002735-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/qd/qd_505.html%3Fid%3DDTS10002735-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>