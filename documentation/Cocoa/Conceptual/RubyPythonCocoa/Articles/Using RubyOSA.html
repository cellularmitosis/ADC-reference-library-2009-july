<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Ruby and Python Programming Topics for Mac OS X: Using RubyOSA</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Using RubyOSA"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40006573" title="Using RubyOSA"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../index.html" target="_top">Ruby and Python Programming Topics for Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="BuildingRubyCocoaAppl.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="UsingScriptingBridge.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40006573-SW1" title="Using RubyOSA"></a><hr /><H1>Using RubyOSA</H1><p>RubyOSA is a bridge that lets developers control scriptable applications, including the Finder, using the Ruby scripting language. An application is called scriptable when it makes its operations and data available in response to messages called Apple events. RubyOSA provides a bridge between Ruby and the Open Scripting Architecture (OSA), an infrastructure for interprocess communication that uses Apple events as its mechanism for event dispatching and data transport. (AppleScript is the original OSA scripting language, and is still quite popular.)</p><p>A scriptable application specifies the set of scripting terms it understands and its scriptable interface in an XML dictionary called an <code>sdef</code> file (“sdef” for scriptable definition). At runtime RubyOSA parses the scriptable definition of a given application and populates a new namespace with classes, methods, constants, enumerations, and all other symbols described by the definition. It also dynamically creates Ruby proxy objects to represent these symbols and uses OSA mechanisms to build and send Apple events to applications and receive their responses.</p><p>RubyOSA has some obvious advantages, especially for Ruby programmers. With it you can control applications on Mac OS X and get requested objects back from them. You can do anything with these object that you can do in regular Ruby code, such as string manipulations and regular expressions. Your code also has access to all installed Ruby modules and libraries. Finally, you can combine RubyOSA and RubyCocoa in the same script to apply the technologies of the Mac OS X frameworks to the access to scriptable applications that OSA makes possible. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="Using%20RubyOSA.html#//apple_ref/doc/uid/TP40006573-DontLinkElementID_18">Installing RubyOSA</a>
				
			<br/>
			
        
			
			
				<a href="Using%20RubyOSA.html#//apple_ref/doc/uid/TP40006573-DontLinkElementID_19">The Basics</a>
				
			<br/>
			
        
			
			
				<a href="Using%20RubyOSA.html#//apple_ref/doc/uid/TP40006573-DontLinkElementID_20">The OSA Class</a>
				
			<br/>
			
        
			
			
				<a href="Using%20RubyOSA.html#//apple_ref/doc/uid/TP40006573-SW8">Conversions and Conventions</a>
				
			<br/>
			
        
			
			
				<a href="Using%20RubyOSA.html#//apple_ref/doc/uid/TP40006573-DontLinkElementID_21">Some Examples</a>
				
			<br/>
			
        
			
			
				<a href="Using%20RubyOSA.html#//apple_ref/doc/uid/TP40006573-DontLinkElementID_22">Documenting Application Dictionaries</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40006573-DontLinkElementID_18" title="Installing RubyOSA"></a><h2>Installing RubyOSA</h2><p>You can download the latest version of RubyOSA from its open-source repository and install it on your system by running the following command in a Terminal shell:</p><div class="codesample"><table><tr><td scope="row"><pre>sudo gem install rubyosa<span></span></pre></td></tr></table></div><p></p><a name="//apple_ref/doc/uid/TP40006573-DontLinkElementID_19" title="The Basics"></a><h2>The Basics</h2><p>The essential idea behind using RubyOSA is to get a proxy instance of a scriptable application and then send messages to it. The messages that you can send are described in the application’s scriptable definition, or dictionary. Let’s start by looking at a simple example (<span class="content_text">Listing 1</span>). </p><a name="//apple_ref/doc/uid/TP40006573-SW3" title="Listing 1The iTunes_inspect.rb script"></a><p class="codesample"><strong>Listing 1&nbsp;&nbsp;</strong>The <code>iTunes_inspect.rb</code> script</p><div class="codesample"><table><tr><td scope="row"><pre># Quick inspection of iTunes' sources, playlists and tracks.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>require 'rubygems'<span></span></pre></td></tr><tr><td scope="row"><pre>require 'rbosa'<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>app = OSA.app('iTunes')<span></span></pre></td></tr><tr><td scope="row"><pre>OSA.utf8_strings = true<span></span></pre></td></tr><tr><td scope="row"><pre>app.sources.each do |source|<span></span></pre></td></tr><tr><td scope="row"><pre>    puts source.name<span></span></pre></td></tr><tr><td scope="row"><pre>    source.playlists.each do |playlist|<span></span></pre></td></tr><tr><td scope="row"><pre>        puts " -> #{playlist.name}"<span></span></pre></td></tr><tr><td scope="row"><pre>        playlist.tracks.each do |track|<span></span></pre></td></tr><tr><td scope="row"><pre>            puts "     -> #{track.name}" if track.enabled?<span></span></pre></td></tr><tr><td scope="row"><pre>        end<span></span></pre></td></tr><tr><td scope="row"><pre>    end<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div><p>When you run this script from the command line, it prints information similar to the following lines:</p><div class="codesample"><table><tr><td scope="row"><pre>Library<span></span></pre></td></tr><tr><td scope="row"><pre>-> Classical CD<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Toccata &amp; Fugue in D Minor<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Air on the G String (2nd movement from Orchestral Suite No. 3 in D)<span></span></pre></td></tr><tr><td scope="row"><pre>     -> No.13 Waltz of the Flowers<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Montagues And Capulets<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Egmont Overture, Op 84<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Die Zauberflöte<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Horn concerto 3EFlat, 1. Allegro<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Horn concerto 3EFlat 2. Romance. Larguetto<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Horn concerto 3EFlat, 3. Allegro<span></span></pre></td></tr><tr><td scope="row"><pre>     ........<span></span></pre></td></tr></table></div><p>The first thing to notice about the script in <span class="content_text"><a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW3">Listing 1</a></span> is <code>require ‘rbosa’</code>. This statement loads the rbosa library, which includes the OSA class. The next line of the script is equally important:</p><div class="codesample"><table><tr><td scope="row"><pre>app = OSA.app('iTunes')<span></span></pre></td></tr></table></div><p>This line returns a proxy Ruby object representing a scriptable application, in this case iTunes. (Note that all you have to do specify the name of the application; you don’t have to include its file-system location or its extension.) From this point on, the script sends messages to the application object and the objects it “contains,“ and performs Ruby operations on the results. In RubyOSA’s internal representation of a scriptable application, a hierarchy of objects descends from the application object; sending a message to the application object may return a collection objects, each of which may be a collection of subordinate objects. You can send appropriate messages to each of these objects. Take these lines as an example: </p><div class="codesample"><table><tr><td scope="row"><pre>app.sources.each do |source|<span></span></pre></td></tr><tr><td scope="row"><pre>    puts source.name<span></span></pre></td></tr><tr><td scope="row"><pre>    source.playlists.each do |playlist|<span></span></pre></td></tr><tr><td scope="row"><pre>        puts " -> #{playlist.name}"<span></span></pre></td></tr></table></div><p>The <code>sources</code> message to the iTunes proxy object returns an object that implements the Ruby Array interface. The script then loops through the array and in a block sends a <code>name</code> message to each fetched object (<code>source</code>, representing a music source) and prints the returned Ruby string. It next sends <code>playlists</code> to <code>source</code> and iterates through the array returned from that call, which represents the playlists associated with that music source. It prints the name of each playlist. And so on proceeds the script.</p><p>This might seem simple and straightforward—and it is—but a question might arise: where do you find out which messages you can send to a scriptable application’s hierarchy of objects? RubyOSA includes a documentation tool, <code>rdoc-osa</code>. Using this you tool you can generate a set of HTML pages that document the scriptable definition of a Mac OS X application. <span class="content_text">“The Basics”</span> shows the opening page of the iTunes documentation.</p><br/><div><a name="//apple_ref/doc/uid/TP40006573-SW2" title="Figure 1A page from the rdoc-osa documentation for iTunes"></a><p><strong>Figure 1&nbsp;&nbsp;</strong>A page from the rdoc-osa documentation for iTunes</p><img src = "../Art/rdoc_osa.jpg" alt = "A page from the rdoc-osa documentation for iTunes" ></div><br/><p>If you were to use this documentation, you would find that sending <code>sources</code> to a proxy object representing the iTunes application returns an array (or list) of OSA::iTunes::Source objects. Sending <code>playlists</code> to one of these objects returns an array of OSA::ITunes::Playlist objects. And sending <code>tracks</code> to one of these objects returns an array of OSA::ITunes::Track objects. You can then send <code>name</code> to one of these objects to get the name of the track. </p><a name="//apple_ref/doc/uid/TP40006573-DontLinkElementID_20" title="The OSA Class"></a><h2>The OSA Class</h2><p>You might have wondered about the following line in the sample script in <span class="content_text"><a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW3">Listing 1</a></span>:</p><div class="codesample"><table><tr><td scope="row"><pre>OSA.utf8_strings = true<span></span></pre></td></tr></table></div><p>OSA is a Ruby class in its own right, and has other methods besides <code>app</code>, among them <code>utf8_strings</code>. <span class="content_text">Listing 2</span> describes the methods of the OSA class.</p><a name="//apple_ref/doc/uid/TP40006573-SW4" title="Table 1Methods of the OSA class"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1&nbsp;&nbsp;</strong>Methods of the OSA class</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Method</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>OSA.app(</code><em>application-specifier</em><code>)</code></p></td><td ><p>Returns an OSA proxy object representing the application specified by the string <em>application-specifier</em>. You can specify the application by name, by bundle ID, by path, or by signature. For more information on specifying applications, both local and remote, see below.</p></td></tr><tr><td  scope="row"><p><code>OSA.lazy_events</code></p></td><td ><p>Controls whether OSA proxy objects are resolved on demand or are resolved automatically. By default objects are resolved on demand (<code>true</code>), meaning that OSA objects are resolved only when necessary. </p><p>Object resolution involves the sending of an Apple event to discover the type of an object. Thus automatic resolution can have performance implications when there is a considerable number of objects (for example, a loop to get all iTunes tracks). However, this might be unavoidable when the target application’s scriptable definition doesn’t describe the types of objects, instead using the “reference” type for each of them.</p></td></tr><tr><td  scope="row"><p><code>OSA.utf8_strings</code></p></td><td ><p>Controls whether strings will be encoded as Unicode (UTF8) or as ASCII. By default this property is set to <code>false</code> because some applications might not be able to handle Unicode strings.</p></td></tr><tr><td  scope="row"><p><code>OSA.timeout</code></p></td><td ><p>Controls the timeout period for getting responses to Apple events. The value is expressed in ticks (seconds). By default it's set to -1, which is about one minute.  A value of -2 means there is no timeout.</p></td></tr><tr><td  scope="row"><p><code>OSA.wait_reply</code></p></td><td ><p>Controls whether RubyOSA should expect a result from the Apple events it sends. If set to <code>nil</code> (the default), RubyOSA determines the value by examining the scriptable definition; this might (rarely) result in a malformed application command. Set this value to <code>true</code> (or <code>false</code>) to force RubyOSA to send back (or not send back) a return value.</p></td></tr></table></div><p>All RubyOSA objects inherit from the <code>OSA::Element</code> class, which is completely opaque to the user. </p><p>With the RubyOSA <code>app</code> method you can identify scriptable applications in several ways:</p><ul class="ul"><li class="li"><p>By name, simply by putting the application name (minus the app extension) between single quotation marks. </p><p>Example: <code>OSA.app(‘Finder’)</code></p><p>This simple style of argument is a convenience for <code>:name => ‘AppName’</code>. RubyOSA uses Launch Services to locate the scriptable application to launch and use. </p></li><li class="li"><p>By file-system path, using the <code>:path</code> key.</p><p>Example: <code>OSA.app(:path => ‘/Users/jdoe/Applications/BBEdit.app’)</code></p></li><li class="li"><p>By the application’s bundle ID, using the <code>:bundle_id</code> key.</p><p>Example: <code>OSA.app(:bundle_id => ‘com.apple.iTunes’)</code></p></li><li class="li"><p>By an application’s four-character creator signature (if any), using the <code>:signature</code> key.</p><p>Example: <code>OSA.app(:signature -> ‘woof’)</code></p></li></ul><p>The <code>app</code> method also lets you specify applications on remote machines as well as locally—thus you can control and get data from applications that aren’t even installed on your local system. After specifying the application by name, you add one to three key-value pairs identifying the machine, the user name, and the password. For each pair, use the <code>:machine</code>, <code>:username</code>, and <code>:password</code> keys, respectively. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>OSA.app('iTunes', :machine => 'kubla.acme.com', :username => 'jdoe' :password => '3x534C2')<span></span></pre></td></tr></table></div><p>There are a few things to be aware of when calling the <code>app</code> method to get proxy instances of remote applications: First, you may only specify the remote-access key-value pairs when the first argument specifies the application by name. Second, if you omit the <code>:username</code> or <code>:password</code> keys (or both), RubyOSA prompts for the user name and password (or both). </p><ul class="ul"><li class="li"><p>The Remote Apple Events checkbox in the Sharing pane of System Preferences on the remote machine should be checked for your RubyOSA script to control its applications.</p></li><li class="li"><p>You may only specify the remote-access key-value pairs when the first argument specifies the application by name. </p></li><li class="li"><p>if you omit the <code>:username</code> or <code>:password</code> keys (or both), RubyOSA prompts for the user name and password (or both).</p></li></ul><a name="//apple_ref/doc/uid/TP40006573-SW8" title="Conversions and Conventions"></a><h2>Conversions and Conventions</h2><p>When you send a message whose name has a plural form (for example, <code>sources</code>), what you get in return may look and behave like an Array, but it is actually an list element (OSA::ObjectSpecifierList ) containing object specifiers—that is, references to real objects. Although the Ruby Array class is not directly used in this case, the OSA::ObjectSpecifierList class conforms to the Array interface; in other words, it mixes the Enumerable module. Therefore you can call <em>most</em> of the methods on an object-specifier list that you can call on an Array.</p><p>Methods with names such as <code>title</code> and <code>name</code> refer to properties in a scriptable definition and return the appropriate Ruby objects (in both these cases, String objects). On the other hand, methods such as <code>current_track</code> return an object specifier, in this case an object specifier of the OSA::ITunes::Track class. The rule that RubyOSA follows to distinguish between these two general types of properties is that when the type of the property is defined within the target application's scriptable definition (as <code>current_track</code> is), it returns an object specifier. Otherwise it assumes the object is of a primitive type (<code>String</code>, <code>Integer</code>, <code>Date</code>, and so on) and it resolves the return value directly by querying for the type with an extra Apple event.</p><a name="//apple_ref/doc/uid/TP40006573-DontLinkElementID_21" title="Some Examples"></a><h2>Some Examples</h2><p>To better appreciate the varieties of ways in which you might use RubyOSA, let’s examine a few of the examples installed in <code>/Developer/Examples/Ruby/RubyOSA</code>. The script in <span class="content_text">Listing 3</span> creates a proxy instance of the Finder application and from it requests the current contents of the Desktop. Using Ruby regular expressions and string-manipulation methods, it formats and prints these items.</p><a name="//apple_ref/doc/uid/TP40006573-SW5" title="Listing 2The Finder_show_desktop.rb script"></a><p class="codesample"><strong>Listing 2&nbsp;&nbsp;</strong>The <code>Finder_show_desktop.rb</code> script</p><div class="codesample"><table><tr><td scope="row"><pre># Lists the content of the Finder desktop.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>require 'rubygems';<span></span></pre></td></tr><tr><td scope="row"><pre>require 'rbosa'<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ary = OSA.app('Finder').desktop.entire_contents.get<span></span></pre></td></tr><tr><td scope="row"><pre>ary.each do |x|<span></span></pre></td></tr><tr><td scope="row"><pre>    next unless x.is_a?(OSA::Finder::Item)<span></span></pre></td></tr><tr><td scope="row"><pre>    puts "#{x.class.name.sub(/^.+::/, '').sub(/_/, ' ').ljust(25)} #{x.name}"<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 3</span> is a script that displays the album artwork associated with the iTunes track that is currently playing. Note that it creates a temporary file to hold the image data and then makes a <code>system</code> call to open this file in the Preview application. With the <code>system</code> call your script can do anything that can be done at the command line.</p><a name="//apple_ref/doc/uid/TP40006573-SW6" title="Listing 3The iTunes_artwork.rb script"></a><p class="codesample"><strong>Listing 3&nbsp;&nbsp;</strong>The <code>iTunes_artwork.rb</code> script</p><div class="codesample"><table><tr><td scope="row"><pre># Open the artwork of the current iTunes track in Preview.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>require 'rubygems'<span></span></pre></td></tr><tr><td scope="row"><pre>require 'rbosa'<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>artworks = OSA.app('iTunes').current_track.artworks<span></span></pre></td></tr><tr><td scope="row"><pre>if artworks.size == 0<span></span></pre></td></tr><tr><td scope="row"><pre>  puts "No artwork for current track."<span></span></pre></td></tr><tr><td scope="row"><pre>  exit 1<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>fname = '/tmp/foo.' + artworks[0].format.downcase.strip<span></span></pre></td></tr><tr><td scope="row"><pre>File.open(fname, 'w') { |io| io.write(artworks[0].data) }<span></span></pre></td></tr><tr><td scope="row"><pre>system("open -a Preview #{fname}")<span></span></pre></td></tr></table></div><p>What is noteworthy about the script in <span class="content_text">Listing 4</span> is that it exchanges data between proxy instances of two applications, TextEdit and Mail. It gets the selected messages in all current Mail viewers and copies each the content of each message to a TextEdit window.</p><a name="//apple_ref/doc/uid/TP40006573-SW7" title="Listing 4The get_selected_mail.rb script"></a><p class="codesample"><strong>Listing 4&nbsp;&nbsp;</strong>The <code>get_selected_mail.rb</code> script</p><div class="codesample"><table><tr><td scope="row"><pre># Copy contents of selected Mail messages to a TextEdit window<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>require 'rubygems'<span></span></pre></td></tr><tr><td scope="row"><pre>require 'rbosa'<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>textedit = OSA.app('TextEdit')<span></span></pre></td></tr><tr><td scope="row"><pre>mailApp = OSA.app('Mail')<span></span></pre></td></tr><tr><td scope="row"><pre>viewers = mailApp.message_viewers<span></span></pre></td></tr><tr><td scope="row"><pre>viewers.each do |viewer|<span></span></pre></td></tr><tr><td scope="row"><pre>    viewer.selected_messages.each do |message|<span></span></pre></td></tr><tr><td scope="row"><pre>        textedit.make(OSA::TextEdit::Document).text = message.content<span></span></pre></td></tr><tr><td scope="row"><pre>     end<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div><p>Finally. the <span class="content_text">Listing 5</span> script updates in the iChat status area the time the system has been running since it was last booted. It is similar to <span class="content_text"><a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW3">Listing 1</a></span> it that it makes a system call, but instead of calling the <code>system</code> method, it invokes the <code>uptime</code> command simply by enclosing it single quotes. It then formats the output of the command and assigns this formatted string to the iChat <code>status_message</code> property. All this occurs in a closed loop, which is re-executed after a five-second pause, which causes a periodic update of the system-uptime message.</p><a name="//apple_ref/doc/uid/TP40006573-SW9" title="Listing 5The iChat_uptime.rb script"></a><p class="codesample"><strong>Listing 5&nbsp;&nbsp;</strong>The <code>iChat_uptime.rb</code> script</p><div class="codesample"><table><tr><td scope="row"><pre># Periodically set your iChat status to the output of uptime(1).<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>require 'rubygems'<span></span></pre></td></tr><tr><td scope="row"><pre>require 'rbosa'<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>app = OSA.app('iChat')<span></span></pre></td></tr><tr><td scope="row"><pre>previous_status_message = app.status_message<span></span></pre></td></tr><tr><td scope="row"><pre>trap('INT') { app.status_message = previous_status_message; exit 0 }<span></span></pre></td></tr><tr><td scope="row"><pre>while true<span></span></pre></td></tr><tr><td scope="row"><pre>    u = `uptime`<span></span></pre></td></tr><tr><td scope="row"><pre>    hours = u.scan(/^\s*(\d+:\d+)\s/).to_s + ' hours'<span></span></pre></td></tr><tr><td scope="row"><pre>    days = u.scan(/\d+\sdays/).to_s<span></span></pre></td></tr><tr><td scope="row"><pre>    app.status_message = "OSX up #{days} #{hours}"<span></span></pre></td></tr><tr><td scope="row"><pre>    sleep 5<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div><p>This script traps interruption of the script (such as happens when the user presses Control-C) and restores the previous value of the iChat status message before exiting.</p><a name="//apple_ref/doc/uid/TP40006573-DontLinkElementID_22" title="Documenting Application Dictionaries"></a><h2>Documenting Application Dictionaries</h2><p>You can use the <code>rdoc-osa</code> tool to generate HTML or <code>ri</code> documentation for the dictionary (that is, scriptable definition) of an application. Using <code>rdoc-osa</code> is simple. For example, to generate HTML documentation of the iTunes dictionary, you would enter the following command on a shell’s command line:</p><div class="codesample"><table><tr><td scope="row"><pre>rdoc-osa --name iTunes<span></span></pre></td></tr></table></div><p>The <code>ruby-osa</code> tool generates the documentation from the application’s dictionary and puts in in a folder named <code>doc</code> in the current working directory. Instead of identifying the application by name, you can identify it by path, bundle ID, or four-character creator signature. To generate <code>ri</code> documentation instead of HTML, append “<code>--ri</code>“ to the command. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40006573-DontLinkElementID_33" title="Note"></a><p><strong>Note:</strong>&nbsp;<code>ri</code> is a Ruby tool for viewing documentation in a format familiar to Ruby programmers. To learn more about <code>ri</code>, type “<code>ri --h</code>“ at the command line.</p></div><p>To get help on <code>rdoc-osa</code>, enter “<code>rdoc-osa --h</code>“ at the command line. The <code>rdoc-osa</code> tool accepts all options used in <code>rdoc</code>, the documentation generator for Ruby classes and modules. Enter “<code>rdoc --h</code>“ at the command line to learn about the options for that tool.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="BuildingRubyCocoaAppl.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="UsingScriptingBridge.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-10-31<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/RubyPythonCocoa/Articles/Using RubyOSA.html%3Fid%3DTP40004936-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/RubyPythonCocoa/Articles/Using RubyOSA.html%3Fid%3DTP40004936-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/RubyPythonCocoa/Articles/Using RubyOSA.html%3Fid%3DTP40004936-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
