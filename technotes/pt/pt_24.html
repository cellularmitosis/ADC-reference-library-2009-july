<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note PT24: MacPaint Document Format</title><meta name="categories" content="Platforms and Tools"><meta name="week-posted" content="Dec 27, 1982 - Jan 7, 1983"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002678" title="MacPaint Document Format"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note PT24</div>
<div id="pageheadsub">MacPaint Document Format</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Introduction</A><BR><BR><A HREF="#Section2">Header</A><BR><BR><A HREF="#Section3">Bitmap</A><BR><BR><A HREF="#Section4">Reading Sample</A><BR><BR><A HREF="#Section5">Writing Sample</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note describes the internal format of a MacPaintreg. document,which is a standard used by many other programs.  This description is the sameas that found in the "Macintosh Miscellaneous" section of early <i>InsideMacintosh</i> versions.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1988]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><h2>Introduction</h2>            <P>MacPaint documents have a file type of <code>'PNTG'</code>, and since they use only the datafork, you can ignore the resource fork.  The data fork contains a 512-byteheader followed by compressed data which represents a single bitmap (576 pixelswide by 720 pixels tall).  At a resolution of 72 pixels per inch, this bitmapoccupies the full 8 inch by 10 inch printable area of a standard ImageWriterprinter page.</p><P><A HREF="#top">Back to top</A></p><a name="Section2"></a><h2>Header</h2><p>The first 512 bytes of the document form a header of the following format:</p><ul type="disc">	<li>4-byte version number (default = 2)</li>	<li>38*8 = 304 bytes of patterns</li>	<li>204 unused bytes (reserved for future expansion)</li></ul><P>As a Pascal record, the document format could look like the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    MPHeader = RECORD        Version:    LONGINT;        PatArray:    ARRAY [1..38] of Pattern;        Future:    PACKED ARRAY [1..204] of SignedByte;</pre>	</TD></TR></TABLE></CENTER><p>If the version number is zero, the document uses default patterns, so you canignore the rest of the header block, and if your program generates MacPaintdocuments, you can write 512 bytes of zero for the document header.  Mostprograms which read MacPaint documents can skip the header when reading.</p><P><A HREF="#top">Back to top</A></p><a name="Section3"></a><h2>Bitmap</h2><p>Following the header are 720 compressed scan lines of data which form the 576pixel wide by 720 pixel tall bitmap.  Without compression, this bitmap wouldoccupy 51,840 bytes and chew up disk space pretty fast; typical MacPaintdocuments compress to about 10K using the <code>_PackBits</code> procedure tocompress runs of equal bytes within each scan line.  The bitmap part of aMacPaint document is simply the output of <code>_PackBits</code> called 720 times,with 72 bytes of input each time.</p><p>To determine the maximum size of a MacPaint file, it is worth noting what<i>Inside Macintosh</i> says about <code>_PackBits</code>:</p><p>"The worst case would be when <code>_PackBits</code> adds one byte to the row ofbytes when packing."</p><p>If we include an extra 512 bytes for the file header information to the size ofan uncompressed bitmap (51,840), then the total number of bytes would be52,352.  If we take into account the extra 720 "potential" bytes (one for eachrow) to the previous total, the maximum size of a MacPaint file becomes 53,072bytes.</p><P><A HREF="#top">Back to top</A></p><a name="Section4"></a><h2>Reading Sample</h2><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROCEDURE ReadMPFile;    { This is a small example procedure written in Pascal that demonstrates      how to read MacPaint files. As a final step, it takes the data that      was read and displays it on the screen to show that it worked.      Caveat: This is not intended to be an example of good programming      practice, in that the possible errors merely cause the program to exit.      This is VERY uninformative, and there should be some sort of error handler      to explain what happened. For simplicity, and thus clarity, those types      of things were deliberately not included. This example will not work      on a 128K Macintosh, since memory allocation is done too simplistically.    }    CONST        DefaultVolume = 0;        HeaderSize = 512;        { size of MacPaint header in bytes }        MaxUnPackedSize = 51840;    { maximum MacPaint size in bytes }                        { 720 lines * 72 bytes/line }    VAR        srcPtr:     Ptr;        dstPtr:     Ptr;        saveDstPtr:    Ptr;        lastDestPtr:    Ptr;        srcFile:     INTEGER;        srcSize:     LONGINT;        errCode:    INTEGER;        scanLine:    INTEGER;        aPort:    GrafPort;        theBitMap:    BitMap;    BEGIN        errCode := FSOpen('MP TestFile', DefaultVolume, srcFile); { Open the        file. }        IF errCode &lt;&gt; noErr THEN ExitToShell;        errcode := SetFPos(srcFile, fsFromStart, HeaderSize);    { Skip the        header )        IF errCode &lt;&gt; noErr THEN ExitToShell;        errCode := GetEOF(srcFile, srcSize);    { Find out how big the file        is, }        IF errCode &lt;&gt; noErr THEN ExitToShell;    { and figure out source        size. }        srcSize := srcSize - HeaderSize ;        { Remove the header from        count. }        srcPtr := NewPtr(srcSize);            { Make buffer just the        right size }        IF srcPtr = NIL THEN ExitToShell;        errCode := FSRead(srcFile, srcSize, srcPtr); { Read the data into the        buffer. }        IF errCode &lt;&gt; noErr THEN ExitToShell;    { File marker is past        header. }        errCode := FSClose(srcFile);        { Close the file we just        read. }        IF errCode &lt;&gt; noErr THEN ExitToShell;        { Create a buffer that will be used for the Destination BitMap. }        dstPtr := NewPtrClear(MaxUnPackedSize);    {MPW library routine, see        TN 219}        IF dstPtr = NIL THEN ExitToShell;        saveDstPtr := dstPtr;        { Unpack each scan line into the buffer. Note that 720 scan lines are          guaranteed to be in the file. (They may be blank lines.) In the          UnPackBits call, the 72 is the count of bytes done when the file was          created.  MacPaint does one scan line at a time when creating the          file. The destination pointer is tested each time through the scan          loop. UnPackBits should increment this pointer by 72, but in the          case where the packed file is corrupted UnPackBits may end up          sending bits into uncharted territory.  A temporary pointer &quot;lastDstPtr&quot;          is used for testing the result.}        FOR scanLine := 1 TO 720 DO BEGIN             lastDstPtr := dstPtr;             UnPackBits(srcPtr, dstPtr, 72);     { bumps both pointers }             IF ORD4(lastDstPtr) + 72 &lt;&gt; ORD4(dstPtr) THEN ExitToShell;        END;        { The buffer has been fully unpacked. Create a port that we can draw into.        You should save and restore the current port.  }        OpenPort(@aPort);        { Create a BitMap out of our saveDstPtr that can be copied to the screen. }        theBitMap.baseAddr := saveDstPtr;        theBitMap.rowBytes := 72;         { width of MacPaint picture }        SetPt(theBitMap.bounds.topLeft, 0, 0);        SetPt(theBitMap.bounds.botRight, 72*8, 720); {maximum rectangle}        { Now use that BitMap and draw the piece of it to the screen.          Only draw the piece that is full screen size (portRect). }        CopyBits(theBitMap, aPort.portBits, aPort.portRect,            aPort.portRect, srcCopy, NIL);        { We need to dispose of the memory we've allocated.  You would not          dispose of the destPtr if you wish to edit the data.  }        DisposPtr(srcPtr);    { dispose of the source buffer }        DisposPtr(dstPtr);    { dispose of the destination buffer }</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></p><a name="Section5"></a><h2>Writing Sample</h2><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROCEDURE WriteMPFile;    { This is a small example procedure written in Pascal that demonstrates how      to write MacPaint files. It will use the screen as a handy BitMap to be      written to a file.    }    CONST        DefaultVolume = 0;        HeaderSize = 512;    { size of MacPaint header in bytes }        MaxFileSize = 53072;    { maximum MacPaint file size. }    VAR        srcPtr:     Ptr;        dstPtr:     Ptr;        dstFile:     INTEGER;        dstSize:     LONGINT;        errCode:    INTEGER;        scanLine:    INTEGER;        aPort:    GrafPort;        dstBuffer:    PACKED ARRAY[1..HeaderSize] OF BYTE;        I:    LONGINT;        picturePtr:    Ptr;        tempPtr:    BigPtr;        theBitMap:    BitMap;    BEGIN        { Make an empty buffer that is the picture size. }        picturePtr := NewPtrClear(MaxFileSize);    {MPW library routine, see        TN 219}        IF picturePtr = NIL THEN ExitToShell;        { Open a port so we can get to the screen's BitMap easily.  You should          save and restore the current port. }        OpenPort(@aPort);        { Create a BitMap out of our dstPtr that can be copied to the screen. }        theBitMap.baseAddr := picturePtr;        theBitMap.rowBytes := 72;         { width of MacPaint picture }        SetPt(theBitMap.bounds.topLeft, 0, 0);        SetPt(theBitMap.bounds.botRight, 72*8, 720); {maximum rectangle}        { Draw the screen over into our picture buffer. }        CopyBits(aPort.portBits, theBitMap, aPort.portRect,            aPort.portRect, srcCopy, NIL);        { Create the file, giving it the right Creator and File type.}        errCode := Create('MP TestFile', DefaultVolume, 'MPNT', 'PNTG');        IF errCode &lt;&gt; noErr THEN ExitToShell;        { Open the data file to be written. }        errCode := FSOpen(dstFileName, DefaultVolume, dstFile);        IF errCode &lt;&gt; noErr THEN ExitToShell;        FOR I := 1 to HeaderSize DO        { Write the header as all zeros. }             dstBuffer[I] := 0;        errCode := FSWrite(dstFile, HeaderSize, @dstBuffer);        IF errCode &lt;&gt; noErr THEN ExitToShell;        { Now go into a loop where we pack each line of data into the buffer,          then write that data to the file. We are using the line count of 72          in order to make the file readable by MacPaint. Note that the          Pack/UnPackBits can be used for other purposes. }        srcPtr := theBitMap.baseAddr;         { point at our picture BitMap }        FOR scanLine := 1 to 720 DO             BEGIN                dstPtr := @dstBuffer;         { reset the pointer to bottom }                PackBits(srcPtr, dstPtr, 72);         { bumps both ptrs }                dstSize := ORD(dstPtr)-ORD(@dstBuffer);    { calc packed size }                errCode := FSWrite(dstFile, dstSize, @dstBuffer);                IF errCode &lt;&gt; noErr THEN ExitToShell;             END;        errCode := FSClose(dstFile);        { Close the file we just wrote. }        IF errCode &lt;&gt; noErr THEN ExitToShell;</pre>	</TD></TR></TABLE></CENTER><a name="References"></a><P><A HREF="#top">Back to top</A></p><h2>References</h2><P><i>Inside Macintosh</i>, Volume I-135, QuickDraw</p><P><i>Inside Macintosh</i>, Volume I-465, Toolbox Utilities</p><P><i>Inside Macintosh</i>, Volume II-77, The File Manager</p><P>MacPaint is a registered trademark of Claris Corporation.</p>         <a name=Downloads></A>                  <P><A HREF="#top">Back to top</A></p><h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/pt_24.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/pt/pt_24.html%3Fid%3DDTS10002678-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/pt/pt_24.html%3Fid%3DDTS10002678-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/pt/pt_24.html%3Fid%3DDTS10002678-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>