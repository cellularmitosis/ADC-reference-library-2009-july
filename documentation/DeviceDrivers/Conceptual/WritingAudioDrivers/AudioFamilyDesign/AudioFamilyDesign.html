<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Audio Device Driver Programming Guide: Audio Family Design</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Audio Family Design"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000731" title="Audio Family Design"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/MusicAudio-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30000452" target="_top">Audio</a> &gt; <a href="../About/About.html#//apple_ref/doc/uid/TP30000729-CH204-DontLinkElementID_4">Audio Device Driver Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AudioOnMacOSX/AudioOnMacOSX.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ImplementDriver/ImplementDriver.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000731-DontLinkElementID_6" title="Audio Family Design"></a><h1><a name="//apple_ref/doc/uid/TP30000731-CJBBAGJF" title="Audio Family Design"></a>Audio Family Design</h1><p>All audio drivers, regardless of platform, must perform the same general actions. For input streams, drivers receive digital audio data from the hardware in a stream of frames consistent with the current sampling rate and audio format. They modify the data, if necessary, to a form acceptable to the clients of the device (say, 32-bit floating point) and make the altered frames accessible to those clients at the current sampling rate. In the reverse (output) direction, the job of the audio driver is essentially the same. It accepts digital audio data from the clients of the device, changes that stream of sample frames to a form required by the hardware (say, 16-bit integer), and gives the data to the device’s controller at the current sampling rate.</p>
<p>Drivers must also initially configure the hardware, respond to client requests to change device attributes (for example, volume), and notify clients when some attribute or state of the audio device has changed. They must guard against data corruption in a multithreaded environment, and they must be prepared to respond to systemwide events, such as sleep/wake notifications.</p>
<p>The Audio family provides object-oriented abstractions to help your driver deal with many of these things. The family itself takes care of much of the work for you; you just supply the behavior that is specific to your hardware. To do this, it is useful to know how your code fits together with the family implementation, which is what this chapter is about.</p>


<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-TPXREF101">The Classes of the Audio Family</a>
				
			<br/>
			
        
			
			
				<a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBIDABE">The Audio I/O Model Up Close</a>
				
			<br/>
			
        
			
			
				<a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-TPXREF114">Interfaces With the Audio HAL</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000731-TPXREF101" title="The Classes of the Audio Family"></a><h2>The Classes of the Audio Family</h2>
<p>As you can with any object-oriented system, you can come to an understanding of the design of the I/O Kit Audio family by examining the classes of the family. The examination in this section looks at the roles of the family, the properties they encapsulate, the audio entities they represent, and the relationships they have with each other. The relationships considered are not only the static relationships imposed by inheritance but also the dynamic relationships characterized by containment, dependency, and control. </p>
<p>The Audio family consists of about a dozen classes, all having the prefix “IOAudio”:</p>
<ul class="ul"><li class="li"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code></p></li>
<li class="li"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code></p></li>
<li class="li"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code></p></li>
<li class="li"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code></p></li>
<li class="li"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioPort_h/Classes/IOAudioPort/index.html#//apple_ref/cpp/cl/IOAudioPort" target="_top">IOAudioPort</a></code></p></li>
<li class="li"><p><code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code></p></li>
<li class="li"><p><code><!--a target="_top" -->IOAudioControlUserClient<!--/a--></code></p></li>
<li class="li"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioLevelControl_h/Classes/IOAudioLevelControl/index.html#//apple_ref/cpp/cl/IOAudioLevelControl" target="_top">IOAudioLevelControl</a></code></p></li>
<li class="li"><p><code><!--a target="_top" -->IOAudioSelectorControl<!--/a--></code></p></li>
<li class="li"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioToggleControl_h/Classes/IOAudioToggleControl/index.html#//apple_ref/cpp/cl/IOAudioToggleControl" target="_top">IOAudioToggleControl</a></code></p></li></ul>
<p>The inheritance relationships among these classes, as depicted in <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBJAJED">Figure 2-1</a></span>, are uncomplicated. </p>
<br/><div><a name="//apple_ref/doc/uid/TP30000731-CJBJAJED" title="Figure 2-1The Audio family class hierarchy"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>The Audio family class hierarchy</p>
<img src = "../Art/audioclasshierarchy.gif" alt = "The Audio family class hierarchy" width="634" height="166"></div><br/>
<p>All classes of the Audio family directly or indirectly inherit from <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top">IOService</a></code>; thus objects of these classes are full-fledged driver objects, with the capability for responding to driver life-cycle messages and for participating in the matching process. In practice, however, an instance of an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> subclass, as root object of the audio driver, usually matches against the provider’s nub (the provider being a PCI controller or FireWire or USB device, in most cases). Audio drivers are typically “leaf” objects in the driver stack, and typically their only client is the Audio HAL, in user space. Therefore they do not publish nubs of their own.</p>
<p>Two classes, <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> and <code><!--a target="_top" -->IOAudioControlUserClient<!--/a--></code>, inherit from the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOUserClient_h/Classes/IOUserClient/index.html#//apple_ref/cpp/cl/IOUserClient" target="_top">IOUserClient</a></code> class. Objects of these classes represent user-client connections that enable the Audio family to communicate with the Audio HAL. Five of the Audio family classes are subclasses of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code>, providing behavior specific to certain types of audio-device controls (mute switches, volume controls, and so on). For further details on the user-client and control classes of the Audio Family, see <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBEBEFC">“The Roles of Audio Family Objects.”</a></span> </p>
<p>An understanding of the static inheritance relationships between classes of the Audio family goes only so far to clarify what instances of those classes do in a typical audio driver. It is more illuminating to consider the dynamic relationships among these objects.</p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF102" title="Dynamic Relationships in the Audio Family"></a><h3>Dynamic Relationships in the Audio Family</h3>
<p>An I/O Kit audio driver consists of a variable number of objects that represent or encapsulate certain aspects of an audio device. Many of these objects own references to other objects. The most significant objects in a “live” audio driver derive from four Audio family classes:</p>
<ul class="spaceabove"><li class="li"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code></p></li>
<li class="li"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code></p></li>
<li class="li"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code></p></li>
<li class="li"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code></p></li></ul>
<p><span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBECHEG">Figure 2-2</a></span> illustrates the dynamic relationships of these objects.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000731-CJBECHEG" title="Figure 2-2Audio family objects in a typical driver and what they represent"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>Audio family objects in a typical driver and what they represent</p><img src = "../Art/audiodriverobjects.gif" alt = "Audio family objects in a typical driver and what they represent" width="338" height="278"></div><br/>
<p>The root object in an audio driver is an instance of a custom subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code>. It represents an audio device in a general, overall sense. An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object is the root object for a couple of reasons: it creates and coordinates many of the other objects in the driver, and it is typically the object that must match against the provider’s nub. </p>
<p>The custom subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> adds attributes and implements behavior that are specific to the device. It is responsible for identifying, configuring, and creating all necessary audio-engine objects and attaching those objects to itself. It must map all hardware resources from the provider’s nub and, when requested by the system, it must change the values of controls.</p>
<p>Furthermore, an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object is the power controller and power policy maker for the driver; in coordination with its <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> objects, it must properly determine system idleness and deal with power-state transitions (sleep and wake), deactivating and reactivating its audio engines as necessary. (See <span class="content_text"><a href="../ImplementDriver/ImplementDriver.html#//apple_ref/doc/uid/TP30000732-CJBJDJCB">“Handling Sleep/Wake Notifications”</a></span> for more information.)</p>
<p>A driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object contains one or more <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> objects as instance variables. Each of these objects is an instance of a custom subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>. An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object represents the I/O engine (usually a DMA engine) of the audio device; its job is to transfer audio data to or from one or more sample buffers and the hardware. The object starts and stops the audio I/O engine when requested; once started, it should run continuously, looping through the sample buffers until stopped. While it is running, an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> takes a timestamp and increments a loop count each time it “wraps around” a sample buffer (see <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBIDABE">“The Audio I/O Model Up Close”</a></span>). The Core Audio framework (Audio HAL) uses this timing information to calculate the exact position of the audio engine at any time.</p>
<p>An audio driver needs only one <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object unless it needs to manage sample buffers of different sizes or to have sample frames transferred at different rates. In these cases, it should instantiate and configure the required number of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> instances.</p>
<p>An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object itself contains one or more instances of the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> class. An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object primarily represents a sample buffer, which it encapsulates. It also encapsulates the mix buffer for an output audio stream. It describes the direction of the stream as well as the format information that can be applied to the sample buffer. The format information includes such data as number of channels, sampling format, and bit depth. If a sample buffer has multiple channels, the channels are typically interleaved (although separate <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> instances can be used to represent non-interleaved different channels). Often an audio engine has one <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object for an input stream and another for an output stream.</p>
<p>An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> also contains one or more <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects as instance variables. Such an object represents a controllable attribute of the audio device, such as mute, volume, or master gain. An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> is usually associated with a specific channel in a specific stream. However, it can control all channels of an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> or even all channels of an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>. At hardware-initialization time, an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> (or perhaps the driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object) creates the necessary <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects and adds them to the appropriate <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>. </p>
<p>Each <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> is known as a “default control” because the Audio HAL recognizes and uses it based on its attributes. Most value changes to the controls originate with clients of the Audio HAL, which passes them via the user-client interface to the designated value-change handlers in the driver. Notifications of value changes in audio controls can also travel in the other way; for example, if a user turns the volume knob on a speaker, the driver communicates this change to Audio HAL clients.</p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF103" title="The Audio Family and the I/O Registry"></a><h3>The Audio Family and the I/O Registry</h3>
<p>As it does with all I/O Kit drivers, the I/O Registry captures the client-provider relationships and the properties of audio drivers. By using the I/O Registry Explorer application or the <code>ioreg</code> command-line tool, you can view the objects of “live” audio drivers in the I/O Registry and examine the properties of those objects. The visual presentation that these tools provide clarifies the client-provider relationships among Audio-family objects and the relationships between audio objects and other objects in the driver stack. You can use these tools to verify driver status and for debugging problems.</p>
<p><span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBGHJHA">Figure 2-3</a></span> shows how some of the objects in a USB audio driver appear in the I/O Registry.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000731-CJBGHJHA" title="Figure 2-3A USB audio driver displayed in the IORegistryExplorer application"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>A USB audio driver displayed in the IORegistryExplorer application</p><img src = "../Art/appleusbaudio_regexp.gif" alt = "A USB audio driver displayed in the IORegistryExplorer application" width="439" height="410"></div><br/>
<p>In addition to these programming uses, the I/O Registry also serves a critical function in the architecture of the Mac OS X audio system. The control properties of an audio driver—volume, mute, gain settings—are stored in the I/O Registry and are associated with an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> object. The Audio HAL looks for, recognizes, and uses the object based on its attributes, which it discovers through the I/O Registry. See <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBIIEBG">“IOAudioControl”</a></span> for further information.</p>
<p>For details on matching properties, device attributes, and other I/O Registry keys, see the header file <code>Kernel.framework/Headers/IOKit/audio/IOAudioDefines.h</code> or the associated reference documentation for <code><a href="../../../../Darwin/Reference/IOKit/IOAudioDefines_h/index.html#//apple_ref/doc/header/IOAudioDefines.h" target="_top">IOAudioDefines.h</a></code>.</p>
<a name="//apple_ref/doc/uid/TP30000731-CJBEBEFC" title="The Roles of Audio Family Objects"></a><h3>The Roles of Audio Family Objects</h3>
<p>The previous section looked in a general way at the major objects in a “live” audio driver, describing what those objects basically do and what their relationships are with one another. This section probes a little deeper and examines the roles of all Audio family classes (and objects) in more detail.</p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF104" title="IOAudioDevice"></a><h4>IOAudioDevice</h4>
<p>Every audio driver based on the Audio family must have one instance of a custom subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code>. The driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object is the central, coordinating node of the driver’s object tree—the “root” object. All other objects ultimately depend on it or are contained by it. </p>
<p>Because of its status as root object, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object represents the audio hardware generally. This central position gives it several roles:</p>
<ul class="spaceabove"><li class="li"><p>It is the object that usually matches against the provider’s nub.</p></li>
<li class="li"><p>It initializes the device, mapping hardware resources from the provider’s nub, and otherwise reads and writes to the device registers as necessary.</p></li>
<li class="li"><p>It creates the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> objects of the driver and can create the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects used by the driver.</p></li>
<li class="li"><p>It usually manages synchronization of values between hardware controls and the associated software controls associated with its audio-engine objects.</p></li>
<li class="li"><p>It acts as the power controller and policy maker for the audio hardware; in this role, it must respond to system sleep, system wake, and domain idleness transitions by deactivating and reactivating its audio engines as necessary.</p></li></ul>
<p>The driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object fulfills other functions. It controls access to the audio hardware to ensure, in the driver’s multithreaded environment, that the hardware doesn’t get into an inconsistent state. Toward this end, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> superclass provides a separate work loop (<code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOWorkLoop_h/Classes/IOWorkLoop/index.html#//apple_ref/cpp/cl/IOWorkLoop" target="_top">IOWorkLoop</a></code>) and a command gate (<code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOCommandGate_h/Classes/IOCommandGate/index.html#//apple_ref/cpp/cl/IOCommandGate" target="_top">IOCommandGate</a></code>) to synchronize access by all objects in the driver. All other objects in the driver—<code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>, <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code>, and <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code>—contain references to the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code>’s work loop and the command gate as instance variables. All Audio family classes take care of executing I/O and hardware-related code on the command gate for all calls into the driver that they know about. Generally, drivers should ensure that all I/O and hardware-specific operations are executed with the command gate closed.</p>
<p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> also offers timer services to the audio driver. These services allow different objects within the driver to receive notifications that are guaranteed to be delivered at the requested timer interval, if not sooner. Different target objects can register for timer callbacks at a specific interval; however, <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> makes the actual timer interval the smallest of those requested.</p>
<p>The idea behind this design is that there is no harm in having timed events in an audio driver occur sooner than requested. By coalescing the callback intervals, the Audio family obviates the overhead of multiple timers in a single driver.</p>
<p>In some cases, however, this may result in unexpected behavior if you make assumptions based on the amount of time elapsed, such as assuming that the hardware has played a certain number of samples. You should thus always make certain to test to make sure conditions are appropriate before performing such operations.</p>
<p>Your driver itself can have localized strings that are accessible by the Audio HAL. These strings can include such things as name, manufacturer, and input sources. Follow the Mac OS X localization procedure for these strings, putting them in a file named <code>Localizable.strings</code> in the locale-specific subdirectories of your bundle. The driver should have a property named <code>IOAudioDeviceLocalizedBundleKey</code>, which has a value of the path of the bundle or kernel extension holding the localized strings, relative to <code>/System/Library/Extensions</code>. The driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object should set this property in its implementation of the <code><!--a target="_top" -->initHardware<!--/a--></code> method.</p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF105" title="IOAudioEngine"></a><h4>IOAudioEngine</h4>
<p>An audio engine object represents and manages an audio device’s I/O engine. In an audio driver, the object is an instance of a custom subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>. The audio engine has two main roles:</p>
<ul class="spaceabove"><li class="li"><p>To configure a hardware DMA engine to transfer audio data (in the form of a stream of sample frames) between the device and the sample buffer at a specific sampling rate. (In the absence of a hardware DMA engine, the audio engine may emulate this functionality in software.)</p></li>
<li class="li"><p>To move data between the sample buffer and the mix buffer after appropriately converting the data to the format expected by the client or hardware (depending on direction).</p></li></ul>
<p>You can find more information on this topic in <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBIDABE">“The Audio I/O Model Up Close.”</a></span>)</p>
<p>An instance of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> (described in <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBGHCGJ">“IOAudioStream”</a></span>) represents and encapsulates a sample buffer in a driver (and a mix buffer for output streams). Each <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> in a driver must create one or more <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> objects for each sample buffer required by the I/O engine. A typical driver has at least an input <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> and an output <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code>.</p>
<p>An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object may also create the audio-control objects (<code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code>) required by the device, although this task can be handled by the driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code>. During the initialization phase, the driver must add all created <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> instances and <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> instances to the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> as instance variables using the appropriate <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> methods. This must happen before it activates the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> (with the <code>activateAudioEngine</code> method).</p>
<p>In addition to facilitating the transfer of audio data in and out of the sample and mix buffers, an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> has a number of functions:</p>
<ul class="spaceabove"><li class="li"><p>It must stop and start the I/O engine when requested.</p></li>
<li class="li"><p>When the I/O engine is started, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object must ensure that it runs continuously and, at the end of the sample buffer, loops to the beginning of the buffer. As the engine loops, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> takes a timestamp and increments a loop count.</p></li>
<li class="li"><p>It must provide the current sample on demand.</p></li>
<li class="li"><p>If the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> supports multiple stream formats or sampling rates, it must modify the hardware appropriately when a format or rate changes.</p></li></ul>
<p>An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> has several attributes and structures associated with it. Most important of these is a status buffer (<code><a href="../../../../Darwin/Reference/IOKit/IOAudioTypes_h/index.html#//apple_ref/c/tdef/IOAudioEngineStatus" target="_top">IOAudioEngineStatus</a></code>) that it shares with the Audio HAL. This status buffer is a structure that the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> must update each time the I/O engine loops around to the start of the sample buffer. The structure contains four fields, three of which hold critical values: </p>
<ul class="spaceabove"><li class="li"><p>The number of times the audio engine has looped to the start of the sample buffer</p></li>
<li class="li"><p>The timestamp of the most recent occurrence of this looping</p></li>
<li class="li"><p>The current location of the erase head (in terms of sample frame)</p></li></ul>
<p>It is important that these fields, especially the timestamp field, be as accurate as possible. The Core Audio framework (Audio HAL) uses this timing information to calculate the exact position of the audio engine at any time. The shared status buffer is thus the basis for the timer and synchronization mechanism used by the Mac OS X audio subsystem.</p>
<p>The erase head mentioned in the previous paragraph is another attribute of an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object. The erase head is a software construct that zeroes out the mix and sample buffers just after the sample frames have been played in an output stream. It is always moving just behind the audio engine to avoid erasing data that has not yet been played. However, it also must remain well ahead of the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> clipping and conversion routines that convert the audio data in the mix buffer to ensure that no stale data from a previous loop iteration is mixed or clipped.</p>
<p>An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object performs a number of initializations to fine-tune the synchronization mechanism described above. For example, it provides methods for setting the latency of the audio engine and for varying the offset between the Audio HAL and the audio engine’s I/O head.</p>
<a name="//apple_ref/doc/uid/TP30000731-CJBGHCGJ" title="IOAudioStream"></a><h4>IOAudioStream</h4>
<p>An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object represents a single, independently addressable audio input or output stream (which may include multiple channels). It contains the following (as instance variables):</p>
<ul class="spaceabove"><li class="li"><p>A sample buffer</p></li>
<li class="li"><p>A mix buffer (for output streams)</p></li>
<li class="li"><p>Supported format information (sample rate, bit depth, and number of channels)</p></li>
<li class="li"><p>The starting channel ID</p></li>
<li class="li"><p>The number of current clients</p></li>
<li class="li"><p>All <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects that affect the channels of the stream</p></li></ul>
<p>An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> is an instance variable of the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object that creates it. When the audio engine creates an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object, it must list all supported sample formats as well as all the supported sample rates for each format. The current format must be explicitly set.</p>
<p>If a sample buffer has multiple channels, the channels are typically interleaved on a frame-by-frame basis. If your hardware uses separate buffers for each channel, however, you may use separate <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> instances for different channels.</p>
<p>The <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> class defines the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/tdef/IOAudioStream/AudioIOFunction" target="_top">AudioIOFunction</a></code> type for the callbacks (typically implemented by the owning <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>) that clip and convert output audio data from the float mix buffer to the sample buffer in the format required by the hardware. See <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBIDABE">“The Audio I/O Model Up Close”</a></span> for further information.</p>
<p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> includes convenience methods that permit <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> objects to be created from and saved to <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top">OSDictionary</a></code> objects. </p>
<a name="//apple_ref/doc/uid/TP30000731-CJBIIEBG" title="IOAudioControl"></a><h4>IOAudioControl</h4>
<p>An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> object represents a controllable attribute of an audio device, such as mute, volume, input/output selector, or master gain. It is usually associated with a specific channel in a specific stream, but can be used to control all channels in an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> or even all channels in an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>.</p>
<p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects are typically instance variables of the owning <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object. However, <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects associated with a specific stream may also be stored in the relevant <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object.</p>
<p>Usually an instance of an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass creates its <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> instances when it initializes the hardware (in the <code><!--a target="_top" -->initHardware<!--/a--></code> method). However, the driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object may be the object that creates the necessary <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects. In either case, the driver must add the control objects to the appropriate <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> using the <code><!--a target="_top" -->addDefaultAudioControl<!--/a--></code> method. </p>
<p>Thus an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> object is associated with an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object, an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object, and a channel of the stream. All of its attributes are stored in the I/O Registry. It is known as a “default control” because the Audio HAL recognizes and uses it based on its attributes, which are discovered through the I/O Registry. </p>
<p>When the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> (or <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code>) object creates <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects, it must obtain from the audio device the starting channel identifier (an integer) for the audio stream. When the driver creates the first <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> for the stream, it assigns this channel ID to it. When it creates <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects for any other channels of the stream (based on the number of channels the stream supports), it simply increments the ID of the channel associated with the control.</p>
<p>For audio devices with more than one audio stream, each stream should start at the next free ID beyond the highest numbered ID that the previous stream could contain. This can be obtained by adding the maximum number of channels in any given stream format to the starting ID.</p>
<p>The Audio family assigns <code>enum</code> identifiers to channel IDs in <code><a href="../../../../Darwin/Reference/IOKit/IOAudioTypes_h/index.html#//apple_ref/doc/header/IOAudioTypes.h" target="_top">IOAudioTypes.h</a></code>; these include identifiers for left, right, center, left-rear, and right-rear channels, as well as an identifier for all channels. </p>
<p>In addition to channel ID, the Audio family uses a multitier classification scheme (defined by enums in <code><a href="../../../../Darwin/Reference/IOKit/IOAudioTypes_h/index.html#//apple_ref/doc/header/IOAudioTypes.h" target="_top">IOAudioTypes.h</a></code>) to identify <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> types:</p>
<ul class="spaceabove"><li class="li"><p>Audio types: output, input, mixer, pass-through, and processing</p></li>
<li class="li"><p>Audio subtypes:</p><ul class="nested"><li class="nested li"><p>For output: internal speaker, external speaker, headphones, line, and S/PDIF</p></li>
<li class="nested li"><p>For input: internal microphone, external microphone, CD, line, and S/PDIF</p></li></ul></li>
<li class="li"><p>Control types: level and selector</p></li>
<li class="li"><p>Control subtypes: volume, mute, input, output, clock services</p></li>
<li class="li"><p>Usage type: input, output, and pass-through</p></li></ul>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000731-DontLinkElementID_7" title="Note"></a><p><strong>Note:</strong>&nbsp;For information about creating custom control types beyond those specified, see <span class="content_text"><a href="../CustomControls/CustomControls.html#//apple_ref/doc/uid/TP30000729-CH236-CHDDBDFF">“Tips, Tricks, and Frequently Asked Questions.”</a></span></p></div>
<p>When you create an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> object, you specify control type, control subtype, usage type, and channel name (in addition to channel ID).</p>
<p>The level and selector control types correspond to subclasses of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code>, described in <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBJGGJI">Table 2-1</a></span>. </p>
<a name="//apple_ref/doc/uid/TP30000731-CJBJGGJI" title="Table 2-1Subclasses of IOAudioControl"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>Subclasses of IOAudioControl</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Subclass</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th>
</tr>


<tr>
<td  scope="row"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioLevelControl_h/Classes/IOAudioLevelControl/index.html#//apple_ref/cpp/cl/IOAudioLevelControl" target="_top">IOAudioLevelControl</a></code></p></td>
<td ><p>Implements an audio control based on a minimum and maximum value. A control subtype specifically creates a volume control using minimum and maximum decibels associated with these levels.</p></td>
</tr>
<tr>
<td  scope="row"><p><code><!--a target="_top" -->IOAudioSelectorControl<!--/a--></code></p></td>
<td ><p>Implements an audio control based on selection of discrete elements. Control subtypes include those for mute, input/output, and clock services.</p></td>
</tr>
<tr>
<td  scope="row"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioToggleControl_h/Classes/IOAudioToggleControl/index.html#//apple_ref/cpp/cl/IOAudioToggleControl" target="_top">IOAudioToggleControl</a></code></p></td>
<td ><p>Implements an audio control based on binary values (off and on, start and stop, and so on) such as might pertain to a mute control.</p></td>
</tr>

</table></div>
<p>Some objects in an audio driver—typically the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object because of its central role—must implement what is known as “value change handlers.” A value change handler is a callback routine that conforms to one of three prototypes defined in <code>IOAudioControl.h</code> based on the type of value (integer, <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/OSObject_h/Classes/OSObject/index.html#//apple_ref/cpp/cl/OSObject" target="_top">OSObject</a></code>, or <code>void *</code> data). When invoked, a value change handler should write the change in value to the audio hardware.</p>
<p>Changes to control values that originate with clients of the Audio HAL—for example, a user moving the volume slider in the menu bar—initiate a long series of actions in the Audio HAL and the Audio family:</p>
<ol class="ol"><li class="li"><p>The Audio HAL goes through the I/O Registry to determine the property or properties associated with the value change.</p></li>
<li class="li"><p>Via the <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> object, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> superclass’s implementation of <code><!--a target="_top" -->setProperties<!--/a--></code> is invoked. </p></li>
<li class="li"><p>Using the dictionary of properties passed into <code><!--a target="_top" -->setProperties<!--/a--></code>, <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> locates the target control object and calls <code><!--a target="_top" -->setValueAction<!--/a--></code> on it.</p></li>
<li class="li"><p>The <code><!--a target="_top" -->setValueAction<!--/a--></code> method calls <code><!--a target="_top" -->setValue<!--/a--></code> on the driver’s work loop while holding the driver’s command gate.</p></li>
<li class="li"><p>The <code><!--a target="_top" -->setValue<!--/a--></code> method first calls <code><!--a target="_top" -->performValueChange<!--/a--></code>, which does two things:</p><ol class="ol"><li class="ol ol"><p>It calls the value change handler for the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> (which must conform to the appropriate function prototype for the callback).</p></li>
<li class="ol ol"><p>It sends a notification of the change to all clients of the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> (<code><!--a target="_top" -->sendValueChangeNotification<!--/a--></code>).</p></li></ol></li>
<li class="li"><p>Finally, <code><!--a target="_top" -->setValue<!--/a--></code> calls <code><!--a target="_top" -->updateValue<!--/a--></code> to update the I/O Registry with the new value.</p></li></ol>
<p>When a change is physically made to audio hardware—for example, a user turns a volume dial on an external speaker—what must be done is much abbreviated. When the driver detects a control-value change in hardware, it simply calls <code><!--a target="_top" -->hardwareValueChanged<!--/a--></code> on the driver’s work loop. This method updates the value in the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> instance and in the I/O Registry, and then sends a notification to all interested clients.</p>
<a name="//apple_ref/doc/uid/TP30000731-CJBGFCIA" title="User Client Classes"></a><h4>User Client Classes</h4>
<p>The Audio family provides two user-client classes, <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> and <code><!--a target="_top" -->IOAudioControlUserClient<!--/a--></code>. The Audio family automatically instantiates objects of each class for each <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object and each <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> in a driver. These objects enable the communication of audio data and notifications between the driver and the Audio HAL. You should not have to do anything explicitly in your code to have the default user-client objects created for, and used by, your driver.</p>
<p>For further details, see <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBGIAEC">“User Client Objects.”</a></span></p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF106" title="IOAudioPort"></a><h4>IOAudioPort</h4>
<p>The <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioPort_h/Classes/IOAudioPort/index.html#//apple_ref/cpp/cl/IOAudioPort" target="_top">IOAudioPort</a></code> class instantiates objects that represent a logical or physical port, or a functional unit in an audio device. An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioPort_h/Classes/IOAudioPort/index.html#//apple_ref/cpp/cl/IOAudioPort" target="_top">IOAudioPort</a></code> object represents an element in the signal chain in the audio device and may contain one or more <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects through which different attributes of the port can be represented and adjusted.</p>
<p>The <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioPort_h/Classes/IOAudioPort/index.html#//apple_ref/cpp/cl/IOAudioPort" target="_top">IOAudioPort</a></code> class is deprecated and may eventually be made obsolete. The class is currently public to maintain compatibility. Driver writers are discouraged from using <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioPort_h/Classes/IOAudioPort/index.html#//apple_ref/cpp/cl/IOAudioPort" target="_top">IOAudioPort</a></code> objects in their code.</p>
<a name="//apple_ref/doc/uid/TP30000731-CJBIDABE" title="The Audio I/O Model Up Close"></a><h2>The Audio I/O Model Up Close</h2>
<p>In the previous chapter, the section <span class="content_text"><a href="../AudioOnMacOSX/AudioOnMacOSX.html#//apple_ref/doc/uid/TP30000730-BBCCCFFA">“The Audio I/O Model on Mac OS X”</a></span> described the Mac OS X audio I/O model from the perspective of how that model compares to the Mac OS 9 model. Because it was a comparative overview, that description left out some important details. The following discussion supplies those details, with the intent that a fuller understand of the audio I/O model is of particular benefit to audio driver writers. </p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF107" title="Ring Buffers and Timestamps"></a><h3>Ring Buffers and Timestamps</h3>
<p>In Mac OS X, the driver’s audio engine programs the audio device’s DMA engine to read from or write to a single (typically large) ring buffer. In a ring buffer, the DMA engine (or a software emulation thereof) wraps around to the start of the buffer when it finishes writing to (or reading from) the end of the buffer. Thus the DMA engine continuously loops through the sample buffer, reading or writing audio data, depending on direction. As it wraps, the DMA engine is expected to fire an interrupt. The driver (in an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object) records the time when this interrupt occurs by calling <code><!--a target="_top" -->takeTimeStamp<!--/a--></code> in the driver’s work loop.</p>
<p>In calling <code><!--a target="_top" -->takeTimeStamp<!--/a--></code>, the driver writes two critical pieces of data to an area of memory shared between the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> and its Audio HAL clients. The first is an extremely accurate timestamp (based on <code><a href="../../../../Darwin/Reference/ManPages/man3/utime.3.html#//apple_ref/doc/man/3/utime" target="_top">utime</a></code>), and the other is an incremented loop count. The structure defining these (and other) fields is <code><a href="../../../../Darwin/Reference/IOKit/IOAudioTypes_h/index.html#//apple_ref/c/tdef/IOAudioEngineStatus" target="_top">IOAudioEngineStatus</a></code>. The engine’s user-client object maps the memory holding the <code><a href="../../../../Darwin/Reference/IOKit/IOAudioTypes_h/index.html#//apple_ref/c/tdef/IOAudioEngineStatus" target="_top">IOAudioEngineStatus</a></code> information into the address spaces of the Audio HAL clients.</p>
<p>For information about handling timestamp approximation, see <span class="content_text"><a href="../CustomControls/CustomControls.html#//apple_ref/doc/uid/TP30000729-CH236-CHDCABHF">“Faking Timestamps.”</a></span></p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF108" title="The Audio HAL Predicts"></a><h3>The Audio HAL Predicts</h3>
<p>The Audio HAL uses the accumulated timestamps and loop counts in a sophisticated calculation that predicts when the I/O engine will be at any location in the sample buffer; as a result, it can also predict when each client of a particular I/O engine should be ready to provide audio data to the hardware or accept audio data from it. This calculation takes into account not only the current sample-frame position of the I/O engine, but also the buffer sizes of the clients, which can vary.</p>
<p>Each client of the Audio HAL has its own I/O thread. The Audio HAL puts this thread to sleep until the time comes for the client to read or write audio data. Then the Audio HAL wakes the client thread. This is a kind of software-simulated interrupt, which involves much less overhead than a hardware interrupt.</p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF109" title="Interpolation"></a><h4>Interpolation</h4>
<p>Before going further, it is worthwhile to consider some of the theory behind this design. The Mac OS X audio system makes the assumption that a hardware I/O engine, as it processes audio data in the sample buffer, is proceeding continuously at a <em>more or less</em> constant rate. The “more or less” qualification is important here because, in reality, there will be slight variations in this rate for various reasons, such as imperfections in clock sources. So the mechanism by which the Audio HAL continually uses timestamps to calculate and predict a wake-up time for each of its client I/O threads can be considered an interpolation engine. It is a highly accurate predictive mechanism that “smooths out” these slight variations in engine rate, building in some leeway so that there is no discernible effect on audio quality.</p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF110" title="Client Buffers and I/O Procedures"></a><h4>Client Buffers and I/O Procedures</h4>
<p>As noted earlier, each client of the Audio HAL can define the size of its audio buffer. There are no restrictions, except that the buffer can be no larger than the size of the hardware sample buffer. For performance reasons, almost all clients prefer buffer sizes that are considerably smaller. Buffer sizes are typically a power of two. The Audio HAL takes the buffer sizes of its clients into account when it calculates the next I/O cycle for those clients.</p>
<p>Each client of the Audio HAL must also implement a callback function conforming to the type <code><a href="../../../../MusicAudio/Reference/CACoreAudioReference/AudioHardware/CompositePage.html#//apple_ref/c/tdef/AudioDeviceIOProc" target="_top">AudioDeviceIOProc</a></code>. When the Audio HAL wakes a sleeping client I/O thread, it calls this function, passing in the buffers (input and output) whose sizes were specified by the client. It is in this implementation of the <code><a href="../../../../MusicAudio/Reference/CACoreAudioReference/AudioHardware/CompositePage.html#//apple_ref/c/tdef/AudioDeviceIOProc" target="_top">AudioDeviceIOProc</a></code> routine that the client gives audio data to the hardware or receives it from the hardware.</p>
<p>The following section, <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBDAJII">“A Walk Through the I/O Model,”</a></span> discusses what happens next in detail.</p>
<a name="//apple_ref/doc/uid/TP30000731-CJBDAJII" title="A Walk Through the I/O Model"></a><h3>A Walk Through the I/O Model</h3>
<p>With the essential timing mechanism used for audio I/O in mind, we can now follow a cycle of that I/O through the audio system to see exactly what happens. What happens is different between input and output audio streams. An output stream involves a more complicated path because each client is contributing, frame by frame, to the final sound played by speakers or recorded by some device. </p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF111" title="Output Streams"></a><h4>Output Streams</h4>
<p>Let’s begin with an output stream. <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBDIIIA">Figure 2-4</a></span> illustrates the relationship between the buffers of Audio HAL clients and the buffers of the audio driver during an output cycle. Refer to this diagram during the following discussion.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000731-CJBDIIIA" title="Figure 2-4Multiple Audio HAL client buffers and the mix buffer (output)"></a><p><strong>Figure 2-4&nbsp;&nbsp;</strong>Multiple Audio HAL client buffers and the mix buffer (output)</p><img src = "../Art/multiplehalclients.gif" alt = "Multiple Audio HAL client buffers and the mix buffer (output)" width="310" height="211"></div><br/>
<p>For each of its clients, the Audio HAL calculates intervals that are based on the accumulated timestamps and loop counts associated with an I/O engine as well as client buffer sizes. The Audio HAL sleeps the I/O threads of its clients for these intervals, waking each thread when it’s time for the client to give the hardware its data. In waking the thread, it calls the <code><a href="../../../../MusicAudio/Reference/CACoreAudioReference/AudioHardware/CompositePage.html#//apple_ref/c/tdef/AudioDeviceIOProc" target="_top">AudioDeviceIOProc</a></code> routine implemented by the client, passing in a number of buffers and timestamps:</p>
<ul class="spaceabove"><li class="li"><p>A list of input buffers along with a timestamp that indicates when the data was recorded</p></li>
<li class="li"><p>A list of output buffers along with a timestamp that indicates when the data will be played</p></li>
<li class="li"><p>A timestamp to be used for “now” rather than the device clock </p></li></ul>
<p>The input and output timestamps allow the client to make various calculations, such as how much time it has before the data is played. The inclusion of both input and output parameters enables clients that are both producers and consumers of audio data (for example, a recording unit with playback capabilities) to process both streams at the same time. In this case, the client first takes the data in the list of input buffers before filling the output buffers with 32-bit floating-point samples.</p>
<p>When the client returns in its <code><a href="../../../../MusicAudio/Reference/CACoreAudioReference/AudioHardware/CompositePage.html#//apple_ref/c/tdef/AudioDeviceIOProc" target="_top">AudioDeviceIOProc</a></code> routine, the Audio HAL puts the I/O thread to sleep until the next time data is required from the client. The Audio HAL gives the samples in the output buffer to the associated <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> object, which calls the appropriate <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object to have the samples moved from the client buffer to the appropriate frames in the engine’s mix buffer. Other clients can also deposit data in the same locations in the mix buffer. If another client already has deposited data in those frames, the new client’s floating-point values are simply added to the existing values. </p>
<p>Clients can contribute output data to a frame almost until the I/O engine is ready for that data. The <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object containing the mix buffer knows how many clients it has and when each has contributed its share of data to any one frame of the mix buffer (for the current loop through it). In addition, the driver (through the Audio family) maintains a “watchdog” timer that tracks the current location of each client relative to the I/O engine. If a client has not provided audio data by the time the I/O engine needs to accesses it, the watchdog timer fires and clips all of the currently mixed samples into the sample buffer.</p>
<p>Because some time is needed to perform this clip operation, the watchdog actually fires a short amount of time before the data is needed. It is possible that a “late” client could attempt to put data in the location of the mix buffer after the watchdog has fired but before the I/O engine has processed the data. To accommodate this situation, the driver backs up and remixes and clips the data in an attempt to get the “late” samples to the I/O engine in time.</p>
<p>Next, the driver’s clip routine, <code><!--a target="_top" -->clipOutputSamples<!--/a--></code>, is invoked. In its implementation of this method, the driver must clip any excess floating-point values under –1.0 and over 1.0 —which can happen when multiple clients are adding their values to existing values in the same frame—and then convert these values to whatever format is required by the hardware. When <code><!--a target="_top" -->clipOutputSamples<!--/a--></code> returns, the converted values have been written to the corresponding locations in the sample buffer. The DMA engine grabs the frames as it progresses through the sample buffer and the hardware plays them as sound.</p>
<p>Since a picture is worth a thousand words, the interaction of these processes is described in <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-TPXREF116">Figure 2-5</a></span>.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000731-TPXREF116" title="Figure 2-5Interplay of the I/O engine, erase heads, and clip routine (output)"></a><p><strong>Figure 2-5&nbsp;&nbsp;</strong>Interplay of the I/O engine, erase heads, and clip routine (output)</p><img src = "../Art/sampleandmixbuffers.gif" alt = "Interplay of the I/O engine, erase heads, and clip routine (output)" width="320" height="162"></div><br/>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF112" title="Erase Heads and Timer Services"></a><h4>Erase Heads and Timer Services</h4>
<p>The Audio family includes a further refinement to the synchronized actions described in the preceding paragraphs. Between the I/O engine and the clipping and converting done by the driver, it runs parallel “erase heads” in both the mix and sample buffers. These erase heads simply zero-fill the corresponding frames at the same time. This precaution reduces the possibility that any frame could become polluted with leftover bits.</p>
<p>The erase heads are run in a separate thread and have their own timer. They are programmed to run four times per sample-buffer cycle. They do not erase the entire range of frames between the current locations of the DMA engine and the driver’s clip routine, allowing a little space for the remixing of data from tardy clients.</p>
<p>The erase head’s timer is run using <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code>’s timer services. Its interval is, of course, closely tied to the rate of the I/O engine and the timestamps taken by the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>.</p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF113" title="Input Streams"></a><h4>Input Streams</h4>
<p>With input audio streams, the picture is much simpler. There is no mix buffer and there are no erase heads. The Audio HAL clients are consumers of the data in this case, and not producers of it, so there is no need for these things.</p>
<p>Neither is there any need for a clip routine. The driver has to convert the integer data coming from the hardware to the 32-bit floating point required by the Audio HAL. But in the input direction, the driver is in a position to fit the converted data within the –1.0 to 1.0 floating-point maximum range.</p>
<p>So the simplified sequence is this: shortly after the I/O engine writes the input data into the sample buffer, the driver—in its implementation of the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> method <code><!--a target="_top" -->convertInputSamples<!--/a--></code>—converts that data to 32-bit floating point. Then the data is given, via the <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> interface, to each Audio HAL client in that client’s <code><a href="../../../../MusicAudio/Reference/CACoreAudioReference/AudioHardware/CompositePage.html#//apple_ref/c/tdef/AudioDeviceIOProc" target="_top">AudioDeviceIOProc</a></code> callback routine.</p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF114" title="Interfaces With the Audio HAL"></a><h2>Interfaces With the Audio HAL</h2>
<p>Audio drivers communicate with the Audio HAL and its clients using two mechanisms. The principal mechanism uses user-client objects to pass audio data, control value changes, and notifications across the kernel-user space boundary. The other mechanism allows driver writers to export custom device properties to Audio HAL clients.</p>
<a name="//apple_ref/doc/uid/TP30000731-CJBGIAEC" title="User Client Objects"></a><h3>User Client Objects</h3>
<p>As described earlier in <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBGFCIA">“User Client Classes,”</a></span> the Audio family automatically configures and creates the appropriate number of user-client objects for a driver. These objects enable the communication of audio data and notifications between the driver and the Audio HAL. The objects typically are instances of either the <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> class or the <code><!--a target="_top" -->IOAudioControlUserClient<!--/a--></code> class. One <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> object is created for each <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> in a driver, and one <code><!--a target="_top" -->IOAudioControlUserClient<!--/a--></code> object is created for each <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code>.</p>
<p>An <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> object acts as the conduit through which audio data is passed between the audio driver and the Audio HAL. It is also the agent that maps the buffer maintained by an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> into memory shared with the associated Audio HAL device. (As you may recall, this buffer contains the timestamp and count of the most recent “wrap” of the sample buffer by the I/O engine.) Finally, the <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> responds to requests by Audio HAL clients to get and set the properties of the hardware. An <code><!--a target="_top" -->IOAudioControlUserClient<!--/a--></code> object has a more limited role compared to a <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> object. It merely sends a notification to interested clients of the Audio HAL when the value of a control (represented by <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code>) changes.</p>
<p>The interaction of these user clients with the Audio HAL and other parts of your driver is shown in <span class="content_text"><a href="AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-TPXREF117">Figure 2-6</a></span>.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000731-TPXREF117" title="Figure 2-6The Audio family&acirc;&#128;&#153;s user clients"></a><p><strong>Figure 2-6&nbsp;&nbsp;</strong>The Audio family’s user clients</p>
<img src = "../Art/audiouserclients.gif" alt = "The Audio family’s user clients" width="445" height="388"></div><br/>
<p>You do not have to do anything explicitly in your code to have the Audio family create the default user-client objects for your driver, nor do you have to write any code to enable your driver to use these objects. It all happens automatically for your driver. But it could happen that you want custom behavior from your user clients; for example, you might want the user client to perform hardware mixing, writing the combined samples into a new buffer used by a single client. When you want custom user-client behavior, you can subclass the <code><!--a target="_top" -->IOAudioEngineUserClient<!--/a--></code> class or the <code><!--a target="_top" -->IOAudioControlUserClient<!--/a--></code> class. These classes are described in <code>IOAppleEngineUserClient.h</code> and <code>IOAppleControlUserClient.h</code>.</p>
<a name="//apple_ref/doc/uid/TP30000731-TPXREF115" title="Custom Core Audio Properties"></a><h3>Custom Core Audio Properties</h3>
<p>Sometimes you might have an audio device with properties that are not covered by what the Audio HAL specifies (in the Core Audio framework’s <code>AudioHardware.h</code>). For these situations, you can create a bundle that contains code implementing these device-specific properties on behalf of the Audio HAL. Then you can put this bundle in a location where it can be exported to user space. The bundle must be accessible by Core Foundation Bundle Services APIs (CFBundle).</p>
<p>To give the Audio HAL access to your device-property code, the bundle must also present the programmatic interface defined in the Core Audio header file <code>AudioDriverPlugIn.h</code>. These routines allow the Audio HAL clients to open and close the device and to get and set the device properties. When the driver changes a property, it calls one of two notification callbacks implemented by clients (one defined for Audio HAL device properties and the other for stream properties) to notify them of the change. </p>
<p>When you have created a bundle conforming to the interface in <code>AudioDriverPlugIn.h</code>, you usually install it inside your driver’s kernel extension in <code>/System/Library/Extensions</code>. Because it is a bundle, it can also contain localizations of strings relevant to the new properties. The Audio HAL finds the bundle by looking in the I/O Registry for two keys: <code><!--a  -->kIOAudioEngineCoreAudioPlugInKey<!--/a--></code> and <code><!--a  -->kIOAudioDeviceLocalizedBundleKey<!--/a--></code>. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AudioOnMacOSX/AudioOnMacOSX.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ImplementDriver/ImplementDriver.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WritingAudioDrivers/AudioFamilyDesign/AudioFamilyDesign.html%3Fid%3DTP30000729-3.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WritingAudioDrivers/AudioFamilyDesign/AudioFamilyDesign.html%3Fid%3DTP30000729-3.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WritingAudioDrivers/AudioFamilyDesign/AudioFamilyDesign.html%3Fid%3DTP30000729-3.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>