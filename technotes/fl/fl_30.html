<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-August-01 --><!-- Includes revisions to graphics tags --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note FL30: Resolving Alias Files Quietly</title><meta name="keywords" content="Mac OS 8 File Manager FollowFinderAlias ResolveAliasFile quietly mounted volume"><meta name="Description" content="Technical Note FL30: This Technical Note offers an alternativefunction to ResolveAliasFile, ResolveAliasFileMountOption,which uses the previously undocumented FollowFinderAliastrap to resolve alias files only if their target is on analready mounted volume. Also included is an IsAliasFile routinefor identifying alias files. These routines are documentedin both the Pascal and C languages."><meta name="categories" content="Files"><meta name="week-posted" content="Nov 1, 1999 - Nov 5, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002456" title="Resolving Alias Files Quietly"></a><A NAME="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxFileManagement-date.html">File Management</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note FL30</div>
<div id="pageheadsub">Resolving Alias Files Quietly</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext">					<A HREF="#Section1">Introduction</a><BR><BR>					<A HREF="#Section2">Keeping Quiet</a><BR><BR>					<A HREF="#Section3">Quiet Calls</a><BR><BR>					<A HREF="#Section4">MPW Pascal</a><BR><BR>					<A HREF="#Section5">MPW C</a><BR><BR>					 <A HREF="#References">References</A><BR><BR>   <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id = "introtext"><code>ResolveAliasFile</code> always presents the user identity dialog when mounting remote volumes. This Technical Note offers an alternative function, <code>ResolveAliasFileMountOption</code>, which uses the previously undocumented <code>FollowFinderAlias</code> trap to resolve alias files only if the target is on a volume that has been mounted. Also included is an <code>IsAliasFile</code> routine for identifying alias files.</p><p id = "introtext">A new routine, <code>ResolveAliasWithMountFlags</code>, was introduced with Mac OS 8.5.<code>ResolveAliasWithMountFlags</code> is identical to <code>ResolveAlias</code> with the exception that it provides the <code>mountFlags</code> parameter allowing callers to suppress disk switch alerts.  The <code>mountFlags</code> parameter can be set to <code>kResolveAliasFileNoUI</code> to prevent any user interaction, including disk switch alerts, while the alias is being resolved.  See Technote <a href="../tn/tn1142.html">Mac OS 8.5 Technote: Part IX</A> for usage details.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[May 01 1992]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR><!-- begin_content --><a name="Section1"></a><h2>Introduction</h2><p>Finder alias files are one aspect of the Macintosh human interface considered"reserved for users."  The internal format of Finder alias files is intentionally undefined because it is subject to change and because Finder alias files should be neither created nor altered by applications. The Finder is the user's domain, and Finder alias files are a user convenience.</p><p>Most applications do not need to take special steps to accommodate Finder aliasfiles. They are resolved by the Finder before they are passed to an applicationin an Open Documents Apple event, as well as by the Standard File Package whenit creates the reply record. Occasionally an application may need to resolvealias files manually. That is normally done by calling <code>ResolveAliasFile</code>, as documented in Chapter 9 of <i>Inside Macintosh </i>Volume VI.</p><p>If a Finder alias file resolves to an item on an unmounted remote volume,<code>ResolveAliasFile</code> will attempt to mount the volume to resolve the alias. For servers, this will bring up the user identity dialog box shown on page 7-24 of <i>Inside Macintosh</i> Volume VI. For removable volumes, this will raise the"Please insert..." dialog. Presentation of a dialog may be inappropriate for the application. For example, a Standard File hook procedure that quietly opens the selected file in order to offer a preview of its contents would not want the dialog presented whenever the user selects an alias to a remote item.</p><P><A HREF="#top">Back to top</A></P><a name="Section2"></a><h2>Keeping Quiet</h2><p>The <code>ResolveAliasFileMountOption</code> function listed below allows anapplication to resolve a Finder alias file only if the alias file's target is on a currentlymounted volume. If the target is unavailable and the <code>mountRemoteVols</code> parameter is false, <code>ResolveAliasFileMountOption</code> returns the error nsvErr. <code>ResolveAliasFileMountOption</code> operates like <code>ResolveAliasFile</code> if <code>mountRemoteVols</code> is true. <code>ResolveAliasFileMountOption</code> updates the alias file if necessary, and returns fnfErr if the alias file is part of a circular chain.</p><p><code>ResolveAliasFileMountOption</code> uses the previously undocumented trap<code>FollowFinderAlias</code> to resolve the alias file's <code>'alis'</code> resource. This is preferable to passing the <code>'alis'</code> to <code>MatchAlias</code> because it makes no assumptions about how the alias was created or how it should be resolved. Finder aliases may actually be relative aliases rather than direct aliases. In any case, <code>FollowFinderAlias</code> will take the steps necessary to resolve  them properly.</p><p><code>FollowFinderAlias</code> should not be used except when necessary to resolve the<code>'alis'</code> resource of a Finder alias file. Aliases created by applications should be resolved with the Alias Manager calls <code>ResolveAlias</code> and <code>MatchAlias</code>.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR><code>FollowFinderAlias</code> is used internally by Apple Computer,Inc. It has not been tested for use by application software. While we do notanticipate any problems, it is the responsibility of the developer to ensurethat it operates appropriately and reliably for their application.</p></TD></TR></TABLE></CENTER><BR><p><code>ResolveAliasFileMountOption</code> uses the function <code>IsAliasFile</code>, alsolisted below, to determine if a file is an alias file. In keeping with theinterface of <code>ResolveAliasFile</code>, <code>IsAliasFile</code> will indicate ifthe specified item is a folder rather than a file.</p><P><A HREF="#top">Back to top</A></P><a name="Section3"></a><h2>Quiet Calls</h2><p>To determine if an FSSpec points to an alias file, a folder, or neither, use <code>IsAliasFile</code>.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>FUNCTION IsAliasFile(fileFSSpec: FSSpec;                         VAR aliasFileFlag: BOOLEAN;                         VAR folderFlag: BOOLEAN): OSErr;</pre>	</TD></TR></TABLE></CENTER><p><code>IsAliasFile</code> simply calls <code>PBGetCatInfo</code> to check if the FSSpec'starget has its directory or isAlias bits set. These are described in <i>Inside Macintosh</i> Volume IV, page 122, and <i>Inside Macintosh</i> Volume VI, page9-36.</p><p>To resolve an alias file without any dialogs appearing, use <code>ResolveAliasFileMountOption</code>.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>FUNCTION ResolveAliasFileMountOption(VAR fileFSSpec: FSSpec;                                         resolveAliasChains: BOOLEAN;                                         VAR targetIsFolder: BOOLEAN;                                         VAR wasAliased: BOOLEAN;                                         mountRemoteVols: BOOLEAN): OSErr;<br></pre>	</TD></TR></TABLE></CENTER><p>The first four parameters of <code>ResolveAliasFileMountOption </code>are the sameas those of <code>ResolveAliasFile</code>. <code>fileFSSpec</code> is the specification for a file, aliasfile, or folder. <code>resolveAliasChains</code> should be true if the resolution shouldfollow down a chain of alias files. <code>targetIsFolder</code> is a return parameter thatis set if the <code>fileFSSpec</code> points to or resolves to a folder. wasAliased returnstrue if the input <code>fileFSSpec</code> was for an alias file.</p><p>If the <code>mountRemoteVols</code> parameter is true, <code>ResolveAliasFileMountOption</code>will attempt to mount a volume if necessary to resolve an alias file,making the call equivalent to <code>ResolveAliasFile</code>. If <code>mountRemoteVols</code> isfalse and the file spec is for an alias file that resolves to a volume notcurrently mounted, the call will return <code>nsvErr</code> rather than attempt tomount it.</p><p>The <code>FollowFinderAlias</code> trap is intended only for resolving aliasrecords obtained from Finder alias files.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>FUNCTION FollowFinderAlias(fromFile: FSSpecPtr;                               alias: AliasHandle;                               logon: BOOLEAN;                               VAR target: FSSpec;                               VAR wasChanged: BOOLEAN): OSErr;        INLINE $700F,$A823;  { MOVEQ #$0F,D0; _AliasDispatch; }</pre>	</TD></TR></TABLE></CENTER><p>fromFile is a pointer to a file for a first attempt at a relative resolution;pass a pointer to the alias file's <code>FSSpec</code> for this. alias is a handle to thealias record taken from the alias file's resources. If logon is true, the aliasmanager will attempt to mount a volume if necessary to complete the resolution.target will be the <code>FSSpec</code> found by the resolution. If wasChanged is truefollowing the call, <code>FollowFinderAlias</code> has updated the alias record, and thecaller should call <code>ChangedResource</code> and <code>WriteResource</code> if the updated record isto be saved in the resource file.</p><p><code>FollowFinderAlias</code> does a single resolution; it does not follow a chain of aliasfiles. <code>FollowFinderAlias</code> returns the same errors as MatchAlias.</p><P><A HREF="#top">Back to top</A></P><a name="Section4"></a><h2>MPW Pascal</h2><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    {*------------------*     | IsAliasFile      |     *------------------*}    FUNCTION IsAliasFile(fileFSSpec: FSSpec;                         VAR aliasFileFlag: BOOLEAN;                         VAR folderFlag: BOOLEAN): OSErr;    { sets aliasFileFlag if the FSSpec points to an alias file;      sets folderFlag if the FSSpec points to a folder }      CONST        kAliasFileBit = 15; { bit of FInfo.fdFlags indicating alias file }        kDirBit = 4;        { bit of CInfoPBRec.ioFlAttrib indicating directory }      VAR        myCInfoPBRec: CInfoPBRec;        retCode: OSErr;      BEGIN        { if called from C we could accidentally be passed nil parameters }        IF (@fileFSSpec = NIL) OR (@aliasFileFlag = NIL) OR (@folderFlag = NIL) THEN          BEGIN            IsAliasFile := paramErr;            Exit(IsAliasFile);          END;        aliasFileFlag := FALSE;        folderFlag := FALSE;        { get the item's catalog information }        WITH myCInfoPBRec DO          BEGIN            ioCompletion := NIL;            ioNamePtr := @fileFSSpec.name;            ioVRefNum := fileFSSpec.vRefNum;            ioFDirIndex := 0;            ioDirID := fileFSSpec.parID;            ioFVersNum := 0;  { MFS compatibility; see Technote #204 }          END;        retCode := PBGetCatInfoSync(@myCInfoPBRec);        IF retCode = noErr THEN          { set aliasFileFlag if the item is not a directory and the            aliasFile bit is set }          BEGIN            IF BTst(myCInfoPBRec.ioFlAttrib, kDirBit) THEN              folderFlag := TRUE            ELSE IF BTst(myCInfoPBRec.ioFlFndrInfo.fdFlags, kAliasFileBit) THEN              aliasFileFlag := TRUE;          END;        IsAliasFile := retCode;      END;</pre>	</TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    {*-----------------------------*     | ResolveAliasFileMountOption |     *-----------------------------*}    FUNCTION ResolveAliasFileMountOption(VAR fileFSSpec: FSSpec;                                         resolveAliasChains: BOOLEAN;                                         VAR targetIsFolder: BOOLEAN;                                         VAR wasAliased: BOOLEAN;                                         mountRemoteVols: BOOLEAN): OSErr;    { ResolveAliasFileMountOption operates identically to ResolveAliasFile,      except that if mountRemoteVols is false, no attempt will be made to      resolve aliases that point to items on non-local volumes }    { if mountRemoteVols is false, ResolveAliasFileMountOption returns nsvErr if      fileFSSpec points to an unmounted volume }    { this routine requires the Alias Manager, available under System 7 }      CONST        kAliasFileBit = 15;  { bit of FInfo.fdFlags indicating alias file }        kMaxChains = 10;  { maximum number of aliases to resolve before giving up }        VAR        myResRefNum, chainCount: INTEGER;        alisHandle: Handle;        initFSSpec: FSSpec;        updateFlag, foundFlag, wasAliasedTemp, specChangedFlag: BOOLEAN;        retCode: OSErr;      FUNCTION FollowFinderAlias(fromFile: FSSpecPtr;                                 alias: AliasHandle;                                 logon: BOOLEAN;                                 VAR target: FSSpec;                                 VAR wasChanged: BOOLEAN): OSErr;        INLINE $700F,$A823;  { MOVEQ #$0F,D0; _AliasDispatch; }      { FollowFinderAlias resolves an alias taken from a Finder alias file,        updating the alias record (but not the alias resource in the file) if        necessary.        Warning: This trap is used internally by Apple Computer, Inc.          It has not been tested for use by application software.          While we do not anticipate any problems, it is the responsibility          of the developer to ensure that it operates appropriately and          reliably for their application.        fromFile is a pointer to a file for a first attempt at a relative search        (pass the alias file's FSSpec); alias is a handle for the alias record        taken from the file's resources; the alias manager will attempt to mount        a volume if logon is TRUE; target is the found FSSpec; wasChanged is set        to TRUE if the alias record needs updating.        FollowFinderAlias does a single resolution; it does not follow a chain of        alias files.        FollowFinderAlias returns the same errors as MatchAlias. }        BEGIN { ResolveAliasFileMountOption }        { check parameters }        IF (@fileFSSpec = NIL) OR (@targetIsFolder = NIL) OR (@wasAliased = NIL) THEN          BEGIN            ResolveAliasFileMountOption := paramErr;            Exit(ResolveAliasFileMountOption);          END;        initFSSpec := fileFSSpec; { so FSSpec can be restored in case of error }        chainCount := kMaxChains; { circular alias chain protection }        targetIsFolder := FALSE;        foundFlag := FALSE;        specChangedFlag := FALSE; { in case of error, restore file spec if it changed }        myResRefNum := -1;        { resource file not open }        { loop through chain of alias files }        REPEAT          chainCount := chainCount - 1;          { check if FSSpec is an alias file or a directory }          { note that targetIsFolder =&gt; NOT wasAliased }          retCode := IsAliasFile(fileFSSpec, wasAliased, targetIsFolder);          IF (retCode &lt;&gt; noErr) OR (NOT wasAliased) THEN Leave; { break from loop }          { get the resource file reference number }          myResRefNum := FSpOpenResFile(fileFSSpec, fsCurPerm);          retCode := ResError;          IF myResRefNum = -1 THEN Leave;          { the first 'alis' resource in the file is the appropriate alias }          alisHandle := Get1IndResource(rAliasType, 1);          retCode := ResError;          IF alisHandle = NIL THEN Leave;          { load the resource explicitly in case SetResLoad(FALSE) }          LoadResource(alisHandle);          retCode := ResError;          IF retCode &lt;&gt; noErr THEN Leave;          retCode := FollowFinderAlias(@fileFSSpec, AliasHandle(alisHandle),            mountRemoteVols, fileFSSpec, updateFlag);          { FollowFinderAlias returns nsvErr if volume not mounted }          IF retCode = noErr THEN            BEGIN              IF updateFlag THEN                { the resource in the alias file needs updating }                BEGIN                  { we don't care if these cause errors, which they may                    do if we don't have write permission }                  ChangedResource(alisHandle);                  WriteResource(alisHandle);                END;              specChangedFlag := TRUE; { in case of error, restore file spec }              retCode := IsAliasFile(fileFSSpec, wasAliasedTemp, targetIsFolder);              IF retCode = noErr THEN                { we're done unless it was an alias file and we're                  following a chain }                foundFlag := NOT (wasAliasedTemp AND resolveAliasChains);            END;          CloseResFile(myResRefNum);          myResRefNum := -1;        UNTIL (retCode &lt;&gt; noErr) OR (chainCount = 0) OR (foundFlag);        { return file not found error for circular alias chains }        IF (chainCount = 0) AND (NOT foundFlag) THEN retCode := fnfErr;        { if error occurred, close resource file and restore the original FSSpec }        IF myResRefNum &lt;&gt; -1 THEN CloseResFile(myResRefNum);        IF (retCode &lt;&gt; noErr) AND (specChangedFlag) THEN fileFSSpec := initFSSpec;        ResolveAliasFileMountOption := retCode;      END;</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><a name="Section5"></a><h2>MPW C</h2><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    /*-------------*     | IsAliasFile |     *-------------*/    pascal OSErr IsAliasFile(const FSSpec *fileFSSpec,                             Boolean *aliasFileFlag,                             Boolean *folderFlag)    /* sets aliasFileFlag if the FSSpec points to an alias file;       sets folderFlag if the FSSpec points to a folder */    {      CInfoPBRec myCInfoPBRec;      OSErr retCode;      if (fileFSSpec == nil || aliasFileFlag == nil || folderFlag == nil)        return paramErr;      *aliasFileFlag = *folderFlag = false;      /* get the item's catalog information */      myCInfoPBRec.hFileInfo.ioCompletion = nil;      myCInfoPBRec.hFileInfo.ioNamePtr = &amp;fileFSSpec-&gt;name;      myCInfoPBRec.hFileInfo.ioVRefNum = fileFSSpec-&gt;vRefNum;      myCInfoPBRec.hFileInfo.ioDirID = fileFSSpec-&gt;parID;      myCInfoPBRec.hFileInfo.ioFVersNum = 0;  /* MFS compatibility, see TN #204 */      myCInfoPBRec.hFileInfo.ioFDirIndex = 0;      retCode = PBGetCatInfoSync(&amp;myCInfoPBRec);      /* set aliasFileFlag if the item is not a directory and the         aliasFile bit is set */      if (retCode == noErr) {        /* check directory bit */        if ((myCInfoPBRec.hFileInfo.ioFlAttrib &amp; ioDirMask) != 0)          *folderFlag = true;        /* check isAlias bit */        else if ((myCInfoPBRec.hFileInfo.ioFlFndrInfo.fdFlags &amp; 0x8000) != 0)          *aliasFileFlag = true;      }      return retCode;    }    /*-------------------*     | FollowFinderAlias |     *-------------------*/    pascal OSErr FollowFinderAlias(const FSSpec *fromFile,                                   AliasHandle alias,                                   Boolean logon,                                   FSSpec *target,                                   Boolean *wasChanged)      = {0x700F, 0xA823};  /* MOVEQ #$0F,D0; _AliasDispatch; */    /*  FollowFinderAlias resolves an alias taken from a Finder alias file,        updating the alias record (but not the alias resource in the file) if        necessary.        Warning: This trap is used internally by Apple Computer, Inc.          It has not been tested for use by application software.          While we do not anticipate any problems, it is the responsibility          of the developer to ensure that it operates appropriately and          reliably for their application. */    /*-----------------------------*     | ResolveAliasFileMountOption |     *-----------------------------*/    pascal OSErr ResolveAliasFileMountOption(FSSpec *fileFSSpec,                                             Boolean resolveAliasChains,                                             Boolean *targetIsFolder,                                             Boolean *wasAliased,                                             Boolean mountRemoteVols)    {    /* maximum number of aliases to resolve before giving up */    #define MAXCHAINS 10      short myResRefNum;      Handle alisHandle;      FSSpec initFSSpec;      Boolean updateFlag, foundFlag, wasAliasedTemp, specChangedFlag;      short chainCount;      OSErr retCode;      if (fileFSSpec == nil || targetIsFolder == nil || wasAliased == nil)        return paramErr;      initFSSpec = *fileFSSpec; /* so FSSpec can be restored in case of error */      chainCount = MAXCHAINS;   /* circular alias chain protection */      myResRefNum = -1;         /* resource file not open */      *targetIsFolder = foundFlag = specChangedFlag = false;      /* loop through chain of alias files */      do {        chainCount--;        /* check if FSSpec is an alias file or a directory */        /* note that targetIsFolder =&gt; NOT wasAliased      */        retCode = IsAliasFile(fileFSSpec, wasAliased, targetIsFolder);        if (retCode != noErr || !(*wasAliased)) break;        /* get the resource file reference number */        myResRefNum = FSpOpenResFile(fileFSSpec, fsCurPerm);        retCode = ResError();        if (myResRefNum == -1) break;        /* the first 'alis' resource in the file is the appropriate alias */        alisHandle = Get1IndResource(rAliasType, 1);        retCode = ResError();        if (alisHandle == nil) break;        /* load the resource explicitly in case SetResLoad(FALSE) */        LoadResource(alisHandle);        retCode = ResError();        if (retCode != noErr) break;        retCode = FollowFinderAlias(fileFSSpec, (AliasHandle) alisHandle,          mountRemoteVols, fileFSSpec, &amp;updateFlag);        /* FollowFinderAlias returns nsvErr if volume not mounted */        if (retCode == noErr) {          if (updateFlag) {            /* the resource in the alias file needs updating */            ChangedResource(alisHandle);            WriteResource(alisHandle);          }          specChangedFlag = true; /* in case of error, restore file spec */          retCode = IsAliasFile(fileFSSpec, &amp;wasAliasedTemp, targetIsFolder);          if (retCode == noErr)            /* we're done unless it was an alias file and we're following a chain */            foundFlag = !(wasAliasedTemp &amp;&amp; resolveAliasChains);        }        CloseResFile(myResRefNum);        myResRefNum = -1;      } while (retCode == noErr &amp;&amp; chainCount &gt; 0 &amp;&amp; !foundFlag);      /* return file not found error for circular alias chains */      if (chainCount == 0 &amp;&amp; !foundFlag) retCode = fnfErr;      /* if error occurred, close resource file and restore the original FSSpec */      if (myResRefNum != -1) CloseResFile(myResRefNum);      if (retCode != noErr &amp;&amp; specChangedFlag) *fileFSSpec = initFSSpec;      return retCode;    }</pre>	</TD></TR></TABLE></CENTER>    <P><A HREF="#top">Back to top</A></P><a name="References"></a><h2>References</h2><p><i>Inside Macintosh</i>, Volume VI, Alias Manager</p><p><i>Inside Macintosh</i>, Volume VI, Finder Interface, pp. 9-29 to 9-32</p><P><A HREF="#top">Back to top</A></P><P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (60K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/fl_30.pdf">Download</A></P>               </TD>            </TR></table><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/fl/fl_30.html%3Fid%3DDTS10002456-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/fl/fl_30.html%3Fid%3DDTS10002456-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/fl/fl_30.html%3Fid%3DDTS10002456-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>