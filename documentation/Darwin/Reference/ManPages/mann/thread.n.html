<html><head><title>Mac OS X
 Manual Page For thread(n)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/n/thread" title="Mac OS X
 Manual Page for thread(n)"><a name="//apple_ref/doc/man/n/thread" title="Mac OS X
 Manual Page for thread(n)"><!-- headerDoc=man; indexgroup=Section n; uid="//apple_ref/doc/man/n/thread"; name=thread(n) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>

thread(n)                                                                                          thread(n)



____________________________________________________________________________________________________________

<b>NAME</b>
       thread - Extension for script access to Tcl threading

<b>SYNOPSIS</b>
       package require <b>Tcl</b>  <b>8.3</b>

       package require <b>Thread</b>  <b>?2.6?</b>

       <b>thread::create</b> ?-joinable? ?-preserved? ?script?

       <b>thread::preserve</b> ?id?

       <b>thread::release</b> ?-wait? ?id?

       <b>thread::id</b>

       <b>thread::errorproc</b> ?procname?

       <b>thread::unwind</b>

       <b>thread::exit</b>

       <b>thread::names</b>

       <b>thread::exists</b> <u>id</u>

       <b>thread::send</b> ?-async? <u>id</u> <u>script</u> ?varname?

       <b>thread::broadcast</b> <u>id</u> <u>script</u>

       <b>thread::wait</b>

       <b>thread::eval</b> ?-lock mutex? <u>arg</u> ?arg ...?

       <b>thread::join</b> <u>id</u>

       <b>thread::configure</b> <u>id</u> ?option? ?value? ?...?

       <b>thread::transfer</b> <u>id</u> <u>channel</u>

       <b>thread::detach</b> <u>channel</u>

       <b>thread::attach</b> <u>channel</u>

       <b>thread::mutex</b>

       <b>thread::mutex</b> <b>create</b> ?-recursive?

       <b>thread::mutex</b> <b>destroy</b> <u>mutex</u>

       <b>thread::mutex</b> <b>lock</b> <u>mutex</u>

       <b>thread::mutex</b> <b>unlock</b> <u>mutex</u>

       <b>thread::rwmutex</b>

       <b>thread::rwmutex</b> <b>create</b>

       <b>thread::rwmutex</b> <b>destroy</b> <u>mutex</u>

       <b>thread::rwmutex</b> <b>rlock</b> <u>mutex</u>

       <b>thread::rwmutex</b> <b>wlock</b> <u>mutex</u>

       <b>thread::rwmutex</b> <b>unlock</b> <u>mutex</u>

       <b>thread::cond</b>

       <b>thread::cond</b> <b>create</b>

       <b>thread::cond</b> <b>destroy</b> <u>cond</u>

       <b>thread::cond</b> <b>notify</b> <u>cond</u>

       <b>thread::cond</b> <b>wait</b> <u>cond</u> <u>mutex</u> ?ms?

____________________________________________________________________________________________________________

<b>DESCRIPTION</b>
       The  <b>thread</b>  extension creates threads that contain Tcl interpreters, and it lets you send scripts to
       those threads for evaluation.  Additionaly, it provides script-level access to basic thread  synchro-<font color="#ffffff" class="whiteout">nization&nbsp;synchronization</font>
       nization primitives, like mutexes and condition variables.

<b>COMMANDS</b>
       This  section  describes  commands for creating and destroying threads and sending scripts to threads
       for evaluation.

       <b>thread::create</b> ?-joinable? ?-preserved? ?script?
              This command creates a thread that contains a Tcl interpreter.   The  Tcl  interpreter  either
              evaluates  the  optional  <b>script</b>, if specified, or it waits in the event loop for scripts that
              arrive via the <b>thread::send</b> command. The result, if any,  of  the  optional  <b>script</b>  is  never
              returned  to  the  caller.   The result of <b>thread::create</b> is the ID of the thread. This is the
              small integer handle which identifies the newly created thread for all other package commands.
              The  handle  of the thread goes out of scope automatically when thread is marked for exit (see
              the <b>thread::release</b> command below).

              If the optional <b>script</b> argument contains the <b>thread::wait</b> command the thread will  enter  into
              the  event loop. If such command is not found  in the <b>script</b> the thread will run the <b>script</b> to
              the end and exit. In that case, the handle may be safely ignored since it refers to  a  thread
              which does not exists any more at the time when the command returns.

              Using  flag <b>-joinable</b> it is possible to create a joinable thread, i.e. one upon whose exit can
              be waited upon by using <b>thread::join</b> command. Note that only Tcl8.4+  core  supports  joinable
              threads.  Note  also  that  failure  to  join  a thread created with <b>-joinable</b> flag results in
              resource and memory leaks.

              Threads created by the <b>thread::create</b> cannot be destroyed forcefully. Consequently,  there  is
              no   corresponding   thread  destroy  command.  A  thread  may  only  be  released  using  the
              <b>thread::release</b> and if its internal reference count drops to zero, the thread  is  marked  for
              exit.  This  kicks the thread out of the event loop servicing and the thread continues to exe-<font color="#ffffff" class="whiteout">cute&nbsp;execute</font>
              cute commands passed in the <b>script</b> argument, following the <b>thread::wait</b> command. If  this  was
              the last command in the script, as usualy the case, the thread will exit.

              It  is  possible  to create a situation in which it may be impossible to terminate the thread,
              for example by putting some endless loop after the <b>thread::wait</b> or  entering  the  event  loop
              again  by  doing  an  vwait-type of command. In such cases, the thread may never exit. This is
              considered to be a bad practice and should be avoided if possible. This is best illustrated by
              the example below:

                  # You should never do ...
                  set tid [thread::create {
                      package require Http
                      thread::wait
                      vwait forever ; # &lt;-- this!
                  }]

              The  thread  created  in  the  above  example  will  never be able to exit.  After it has been
              released with the last matching  <b>thread::release</b>  call,  the  thread  will  jump  out  of  the
              <b>thread::wait</b>  and continue to execute commands following. It will enter <b>vwait</b> command and wait
              endlessly for events. There is no way one can terminate such thread, so you wouldn't  want  to
              do this!

              Each  newly created has its internal reference counter set to 0 (zero), i.e. it is unreserved.
              This counter gets incremented by a call to <b>thread::preserve</b>  and  decremented  by  a  call  to
              <b>thread::release</b>  command. These two commands implement simple but effective thread reservation
              system and offer predictable and controllable thread termination capabilities. It  is  however
              possible  to  create initialy preserved threads by using flag <b>-preserved</b> of the <b>thread::create</b>
              command. Threads created with this flag have the initial value of the reference counter  of  1
              (one), and are thus initially marked reserved.

       <b>thread::preserve</b> ?id?
              This command increments the thread reference counter. Each call to this command increments the
              reference counter by one (1).  Command returns the value of the reference  counter  after  the
              increment.   If  called  with  the optional thread <b>id</b>, the command preserves the given thread.
              Otherwise the current thread is preserved.

              With reference counting, one can implement controlled access to a shared Tcl thread. By incre-
              menting  the reference counter, the caller signalizes that he/she wishes to use the thread for
              a longer period of time. By decrementing the counter, caller signalizes that he/she  has  fin-<font color="#ffffff" class="whiteout">ished&nbsp;finished</font>
              ished using the thread.

       <b>thread::release</b> ?-wait? ?id?
              This command decrements the thread reference counter. Each call to this command decrements the
              reference counter by one (1).  If called with the optional thread <b>id</b>, the command releases the
              given  thread.  Otherwise,  the  current thread is released.  Command returns the value of the
              reference counter after the decrement.  When the reference counter reaches zero (0), the  tar-<font color="#ffffff" class="whiteout">get&nbsp;target</font>
              get  thread  is  marked  for  termination.  You  should  not  reference  the  thread after the
              <b>thread::release</b> command returns zero or negative integer.  The handle of the thread  goes  out
              of  scope  and  should not be used any more. Any following reference to the same thread handle
              will result in Tcl error.

              Optional flag <b>-wait</b> instructs the caller thread to wait for the target thread to exit, if  the
              effect  of  the  command  would result in termination of the target thread, i.e. if the return
              result would be zero (0). Without the flag, the caller thread does not  wait  for  the  target
              thread  to  exit.  Care  must  be  taken when using the <b>-wait</b>, since this may block the caller
              thread indefinitely.  This option has been implemented for users  of  Tcl  8.3  version  only.
              Users of Tcl 8.4 or later should create joinable threads, by using the <b>-joinable</b> option of the
              <b>thread::create</b> command and the <b>thread::join</b> to wait for thread exit.

       <b>thread::id</b>
              This command returns the ID of the current thread.

       <b>thread::errorproc</b> ?procname?
              This command sets a handler for errors that occur in scripts sent  asynchronously,  using  the
              <b>-async</b>  flag  of  the  <b>thread::send</b> command, to other threads. If no handler is specified, the
              current handler is returned. The empty string resets  the  handler  to  default  (unspecified)
              value.  An uncaught error in a thread causes an error message to be sent to the standard error
              channel. This default reporting scheme can be changed by  registering  a  procedure  which  is
              called  to  report  the  error.  The  <u>procname</u>  is  called in the interpreter that invoked the
              <b>thread::errorproc</b> command. The <u>procname</u> is called like this:

                  myerrorproc thread_id errorInfo

       <b>thread::unwind</b>
              Use of this command is deprecated in favour of more advanced thread reservation system  imple-<font color="#ffffff" class="whiteout">mented&nbsp;implemented</font>
              mented  with <b>thread::preserve</b> and <b>thread::release</b> commands. Support for <b>thread::unwind</b> command
              will dissapear in some future major release of the extension.

              This command stops a prior <b>thread::wait</b> command. Execution of the script passed to newly  cre-<font color="#ffffff" class="whiteout">ated&nbsp;created</font>
              ated  thread will continue from the <b>thread::wait</b> command. If <b>thread::wait</b> was the last command
              in the script, the thread will exit. The command returns empty  result  but  may  trigger  Tcl
              error with the message "target thread died" in some situations.

       <b>thread::exit</b>
              Use  of this command is deprecated in favour of more advanced thread reservation system imple-<font color="#ffffff" class="whiteout">mented&nbsp;implemented</font>
              mented with <b>thread::preserve</b> and <b>thread::release</b> commands. Support  for  <b>thread::exit</b>  command
              will dissapear in some future major release of the extension.

              This  command  forces  a  thread stuck in the <b>thread::wait</b> command to unconditionaly exit. The
              execution of <b>thread::exit</b> command is guaranteed to leave the program memory in  the  unconsis-<font color="#ffffff" class="whiteout">tent&nbsp;unconsistent</font>
              tent state, produce memory leaks and otherwise affect other <!-- a -->subsytem(s)<!-- /a --> of the Tcl application
              in an unpredictable manner. The command returns empty result but may trigger  Tcl  error  with
              the message "target thread died" in some situations.

       <b>thread::names</b>
              This  command  returns a list of thread IDs. These are only for threads that have been created
              via <b>thread::create</b> command.  If your application creates other threads at the  C  level,  they
              are not reported by this command.

       <b>thread::exists</b> <u>id</u>
              Returns true (1) if thread given by the <u>id</u> parameter exists, false (0) otherwise. This applies
              only for threads that have been created via <b>thread::create</b> command.

       <b>thread::send</b> ?-async? <u>id</u> <u>script</u> ?varname?
              This command passes a <u>script</u> to another thread and, optionally, waits for the result.  If  the
              <b>-async</b>  flag  is  specified,  the  command  does  not wait for the result and it returns empty
              string.  The target thread must enter it's event loop in order to  receive  scripts  sent  via
              this  command.  This  is done by default for threads created without a startup script. Threads
              can enter the event loop explicitly by calling <b>thread::wait</b> or any other relevant Tcl/Tk  com-<font color="#ffffff" class="whiteout">mand,&nbsp;command,</font>
              mand, like <b>update</b>, <b>vwait</b>, etc.

              Optional <b>varname</b> specifies name of the variable to store the result of the <u>script</u>. Without the
              <b>-async</b> flag, the command returns the evaluation code, similarily to  the  standard  Tcl  <b>catch</b>
              command. If, however, the <b>-async</b> flag is specified, the command returns immediately and caller
              can later <b>vwait</b> on ?varname? to get the result of the passed <u>script</u>

                  set t1 [thread::create]
                  set t2 [thread::create]
                  thread::send -async $t1 "set a 1" result
                  thread::send -async $t2 "set b 2" result
                  for {set i 0} {$i &lt; 2} {incr i} {
                      vwait result
                  }

              In the above example, two threads were fed work and both of them were instructed to  signalize
              the  same variable "result" in the calling thread.  The caller entered the event loop twice to
              get both results. Note, however, that the order of the received results may vary, depending on
              the current system load, type of work done, etc, etc.

              Many  threads  can simultaneously send scripts to the target thread for execution. All of them
              are entered into the event queue of the target thread and executed on the FIFO  basis,  inter-
              mingled with optional other events pending in the event queue of the target thread.

       <b>thread::broadcast</b> <u>id</u> <u>script</u>
              This  command passes a <u>script</u> to all threads created by the package for execution. It does not
              wait for response from any of the threads.

       <b>thread::wait</b>
              This enters the event loop so a thread can receive messages  from  the  <b>thread::send</b>  command.
              This  command should only be used within the script passed to the <b>thread::create</b>. It should be
              the very last command in the script. If this is not the case, the exiting thread will continue
              executing  the  script  lines  pass the <b>thread::wait</b> which is usually not what you want and/or
              expect.

                  set t1 [thread::create {
                      #
                      # Do some initialization work here
                      #
                      thread::wait ; # Enter the event loop
                  }]

       <b>thread::eval</b> ?-lock mutex? <u>arg</u> ?arg ...?
              This command concatenates passed arguments and evaluates the resulting script under the  mutex
              protection.  If no mutex is specified by using the ?-lock mutex? optional argument, the inter-<font color="#ffffff" class="whiteout">nal&nbsp;internal</font>
              nal static mutex is used.

       <b>thread::join</b> <u>id</u>
              This command waits for the thread with ID <u>id</u> to exit and then returns it's exit  code.  Errors
              will  be returned for threads which are not joinable or already waited upon by another thread.
              Upon the join the handle of the thread has gone out of scope and should not be used any  more.

              NOTE: This command is available only when loaded into the Tcl8.4+ shell.

       <b>thread::configure</b> <u>id</u> ?option? ?value? ?...?
              This  command configures various low-level aspects of the thread with ID <u>id</u> in the similar way
              as the standard Tcl command <b>fconfigure</b> configures some Tcl channel options. Options  currently
              supported are: <b>-eventmark</b> and <b>-unwindonerror</b>.

              The  <b>-eventmark</b>  option,  when  set, limits the number of asynchronously posted scripts to the
              thread event loop.  The <b>thread::send</b> <b>-async</b> command will block until  the  number  of  pending
              scripts  in  the  event loop does not drop below the value configured with <b>-eventmark</b>. Default
              value for the <b>-eventmark</b> is 0 (zero) which effectively disables the checking, i.e. allows  for
              unlimited number of posted scripts.

              The  <b>-unwindonerror</b>  option, when set, causes the target thread to unwind if the result of the
              script processing resulted in error. Default value for the <b>-unwindonerror</b> is 0  (false),  i.e.
              thread continues to process scripts after one of the posted scripts fails.

       <b>thread::transfer</b> <u>id</u> <u>channel</u>
              This  moves  the  specified <u>channel</u> from the current thread and interpreter to the main inter-<font color="#ffffff" class="whiteout">preter&nbsp;interpreter</font>
              preter of the thread with the given <u>id</u>. After the move the current interpreter has  no  access
              to  the channel any more, but the main interpreter of the target thread will be able to use it
              from now on.  The command waits until the other thread has incorporated the  channel.  Because
              of this it is possible to deadlock the participating threads by commanding the other through a
              synchronous <b>thread::send</b> to transfer a channel to us.  This easily extends into  longer  loops
              of  threads  waiting  for  each other. Other restrictions: the channel in question must not be
              shared among multiple interpreters running in the sending thread. This automatically  excludes
              the special channels for standard input, output and error.

              Due  to  the internal Tcl core implementation and the restriction on transferring shared chan-<font color="#ffffff" class="whiteout">nels,&nbsp;channels,</font>
              nels, one has to take extra measures when transferring socket channels  created  by  accepting
              the connection out of the <b>socket</b> commands callback procedures:

                  socket -server _Accept 2200
                  proc _Accept {s ipaddr port} {
                      after idle [list Accept $s $ipaddr $port]
                  }
                  proc Accept {s ipaddr port} {
                      set tid [thread::create]
                      thread::transfer $tid $s
                  }

              NOTE: this command is available only when loaded into the Tcl8.4+ shell.

       <b>thread::detach</b> <u>channel</u>
              This  detaches  the specified <u>channel</u> from the current thread and interpreter. After that, the
              current interpreter has no access to the channel any more. The channel is in the parked  state
              until  some  other  (or  the  same)  thread  attaches  the  channel again with <b>thread::attach</b>.
              Restrictions: same as for transferring shared channels with the <b>thread::transfer</b> command.

              NOTE: this command is available only when loaded into the Tcl8.4+ shell.

       <b>thread::attach</b> <u>channel</u>
              This attaches the previously detached <u>channel</u> in the current thread/interpreter.  For  already
              existing  channels, the command does nothing, i.e. it is not an error to attach the same chan-<font color="#ffffff" class="whiteout">nel&nbsp;channel</font>
              nel more than once. The first operation will actualy perform the operation, while  all  subse-<font color="#ffffff" class="whiteout">quent&nbsp;subsequent</font>
              quent  operation  will just do nothing. Command throws error if the <u>channel</u> cannot be found in
              the list of detached channels and/or in the current interpreter.

              NOTE: this command is available only when loaded into the Tcl8.4+ shell.

       <b>thread::mutex</b>
              Mutexes are most common thread synchronization  primitives.   They  are  used  to  synchronize
              access from two or more threads to one or more shared resources. This command provides script-<font color="#ffffff" class="whiteout">level&nbsp;scriptlevel</font>
              level access to exclusive and/or recursive mutexes. Exclusive mutexes can be locked only  once
              by one thread, while recursive mutexes can be locked many times by the same thread. For recur-<font color="#ffffff" class="whiteout">sive&nbsp;recursive</font>
              sive mutexes, number of lock and unlock operations must match, otherwise, the mutex will never
              be released, which would lead to various deadlock situations.

              Care has to be taken when using mutexes in an multithreading program.  Improper use of mutexes
              may lead to various deadlock situations, especially when using exclusive mutexes.

              The <b>thread::mutex</b> command supports following subcommands and options:

              <b>thread::mutex</b> <b>create</b> ?-recursive?
                     Creates the mutex and returns it's opaque handle. This handle should be  used  for  any
                     future  reference to the newly created mutex.  If no optional ?-recursive? argument was
                     specified, the command creates the exclusive mutex. With the ?-recursive? argument, the
                     command creates a recursive mutex.

              <b>thread::mutex</b> <b>destroy</b> <u>mutex</u>
                     Destroys  the  <u>mutex</u>.  Mutex should be in unlocked state before the destroy attempt. If
                     the mutex is locked, the command will throw Tcl error.

              <b>thread::mutex</b> <b>lock</b> <u>mutex</u>
                     Locks the <u>mutex</u>. Locking the exclusive mutex may throw Tcl error if on attempt to  lock
                     the same mutex twice from the same thread. If your program logic forces you to lock the
                     same mutex twice or more from the same thread (this may happen in  recursive  procedure
                     invocations) you should consider using the recursive mutexes.

              <b>thread::mutex</b> <b>unlock</b> <u>mutex</u>
                     Unlocks  the  <u>mutex</u>  so  some  other  thread  may lock it again.  Attempt to unlock the
                     already unlocked mutex will throw Tcl error.

       <b>thread::rwmutex</b>
              This command creates many-readers/single-writer mutexes. Reader/writer mutexes  allow  you  to
              serialize  access  to a shared resource more optimally.  In situations where a shared resource
              gets mostly read and seldom modified, you might gain some performace  by  using  reader/writer
              mutexes instead of exclusive or recursive mutexes.

              For reading the resource, thread should obtain a read lock on the resource.  Read lock is non-<font color="#ffffff" class="whiteout">exclusive,&nbsp;nonexclusive,</font>
              exclusive, meaning that more than one thread can obtain a read  lock  to  the  same  resource,
              without  waiting on other readers.  For changing the resource, however, a thread must obtain a
              exclusive write lock. This lock effectively blocks all  threads  from  gaining  the  read-lock
              while  the resource is been modified by the writer thread.  Only after the write lock has been
              released, the resource may be read-locked again.

              The <b>thread::rwmutex</b> command supports following subcommands and options:

              <b>thread::rwmutex</b> <b>create</b>
                     Creates the reader/writer mutex and returns it's opaque handle.  This handle should  be
                     used for any future reference to the newly created mutex.

              <b>thread::rwmutex</b> <b>destroy</b> <u>mutex</u>
                     Destroys the reader/writer <u>mutex</u>. If the mutex is already locked, attempt to destroy it
                     will throw Tcl error.

              <b>thread::rwmutex</b> <b>rlock</b> <u>mutex</u>
                     Locks the <u>mutex</u> for reading. More than one thread may read-lock the same <u>mutex</u>  at  the
                     same time.

              <b>thread::rwmutex</b> <b>wlock</b> <u>mutex</u>
                     Locks  the <u>mutex</u> for writing. Only one thread may write-lock the same <u>mutex</u> at the same
                     time. Attempt to write-lock same mutex twice from the same thread will throw Tcl error.

              <b>thread::rwmutex</b> <b>unlock</b> <u>mutex</u>
                     Unlocks  the  <u>mutex</u>  so some other thread may lock it again.  Attempt to unlock already
                     unlocked mutex will throw Tcl error.

       <b>thread::cond</b>
              This command provides script-level access to condition variables.  A condition  variable  cre-<font color="#ffffff" class="whiteout">ates&nbsp;creates</font>
              ates  a safe environment for the program to test some condition, sleep on it when false and be
              awakened when it might have become true. A condition variable is always used in the conjuction
              with an exclusive mutex. If you attempt to use other type of mutex in conjuction with the con-<font color="#ffffff" class="whiteout">dition&nbsp;condition</font>
              dition variable, a Tcl error will be thrown.

              The command supports following subcommands and options:

              <b>thread::cond</b> <b>create</b>
                     Creates the condition variable and returns it's opaque handle.  This handle  should  be
                     used for any future reference to newly created condition variable.

              <b>thread::cond</b> <b>destroy</b> <u>cond</u>
                     Destroys  condition  variable  <u>cond</u>.  Extreme care has to be taken that nobody is using
                     (i.e. waiting on) the condition variable, otherwise unexpected errors may happen.

              <b>thread::cond</b> <b>notify</b> <u>cond</u>
                     Wakes up all threads waiting on the condition variable <u>cond</u>.

              <b>thread::cond</b> <b>wait</b> <u>cond</u> <u>mutex</u> ?ms?
                     This command is used to suspend program execution until the condition variable <u>cond</u> has
                     been  signalled  or the optional timer has expired.  The exclusive <u>mutex</u> must be locked
                     by the calling thread on entrance to this command. If the  mutex  is  not  locked,  Tcl
                     error  is  thrown.   While  waiting  on  the  <u>cond</u>, the command releases <u>mutex</u>.  Before
                     returning to the calling thread, the command re-acquires the <u>mutex</u> again. Unlocking the
                     <u>mutex</u> and waiting on the condition variable <u>cond</u> is done atomically.

                     The  <b>ms</b>  command  option, if given, must be an integer specifying time interval in mil-<font color="#ffffff" class="whiteout">liseconds&nbsp;milliseconds</font>
                     liseconds the command waits to be signalled.  Otherwise the command waits on  condition
                     notify forever.

                     In  multithreading  programs,  there are many situations where a thread has to wait for
                     some event to happen until it is allowed to proceed.  This is usually  accomplished  by
                     repeatedly  testing a condition under the mutex protection and waiting on the condition
                     variable until the condition evaluates to true:

                         set mutex [thread::mutex create]
                         set cond  [thread::cond  create]

                         thread::mutex lock
                         while {&lt;some_condition_is_true&gt;} {
                             thread::cond wait $cond $mutex
                         }
                         # Do some work under mutex protection
                         thread::mutex unlock

                     Repeated testing of the condition is needed since the condition variable may  get  sig-<font color="#ffffff" class="whiteout">nalled&nbsp;signalled</font>
                     nalled  without  the  condition  being  actually changed (spurious thread wake-ups, for
                     example).

<b>DISCUSSION</b>
       The fundamental threading model in Tcl is that there can be one or more Tcl interpreters per  thread,
       but  each Tcl interpreter should only be used by a single thread which created it.  A "shared memory"
       abstraction is awkward to provide in Tcl because Tcl makes assumptions about variable and data owner-<font color="#ffffff" class="whiteout">ship.&nbsp;ownership.</font>
       ship.  Therefore  this extension supports a simple form of threading where the main thread can manage
       several background, or "worker" threads.  For example, an event-driven server can  pass  requests  to
       worker  threads, and then await responses from worker threads or new client requests. Everything goes
       through the common Tcl event loop, so message passing between threads  works  naturally  with  event-<font color="#ffffff" class="whiteout">driven&nbsp;eventdriven</font>
       driven  I/O, <b>vwait</b> on variables, and so forth. For the transfer of bulk information it is possible to
       move channels between the threads.

       For advanced multithreading scripts, script-level access to  two  basic  synchronization  primitives,
       mutex and condition variables, is also supported.

<b>SEE</b> <b>ALSO</b>
       <a href="http://www.tcl.tk/doc/howto/thread_model.html"><u>http://www.tcl.tk/doc/howto/thread</u><b>_</b><u>model.html</u></a> tpool, tsv, ttrace

<b>KEYWORDS</b>
       events, message passing, mutex, synchronization, thread



Tcl Threading                                        2.6                                           thread(n)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/mann/thread.n.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/mann/thread.n.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/mann/thread.n.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
