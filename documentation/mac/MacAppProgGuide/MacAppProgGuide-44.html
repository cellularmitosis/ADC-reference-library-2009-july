<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Performing Operations With Command Objects (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING44></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-43.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-45.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-21.html"><B>Part 1 - MacApp Theory and Architecture</B></A><BR><DD><A HREF="MacAppProgGuide-40.html"><B>Chapter 5 - Events and Commands</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING44-0></A>
<H1><A NAME=MARKER-9-142></A><A NAME=MARKER-2-143></A>Performing Operations With Command Objects</H1>
 MacApp provides a flexible mechanism for using command objects to perform operations in your application. This mechanism supports recording command operations with Apple events and performing command operations with attached scripts.<P>
 The section <A HREF=MacAppProgGuide-41.html#MARKER-9-27>"The Command Queue," beginning on page 99</A>, describes how command objects are stored in a command queue and processed by the application object. This section provides additional detail on how command objects work, including a description of how a command operation is performed, undone, and redone.<P>
<A NAME=HEADING44-3></A>
<H2>Command Handlers</H2>
 A command handler is an object instantiated from the <CODE><A NAME=MARKER-2-144></A>TCommandHandler</CODE> class or one of its subclasses. MacApp uses command-handler objects to help manage doing, undoing, and redoing of commands. The <CODE>TApplication</CODE>, <CODE>TDocument</CODE>, <CODE>TWindow</CODE>, and <CODE>TView</CODE> classes are all command-handling classes. Any command-handler object can have a command object associated with it through its <CODE><A NAME=MARKER-2-145></A>fLastCommand</CODE> field.<P>
<A NAME=HEADING44-5></A>
<H2>The Application Object</H2>
 The application object, instantiated from your subclass of one of MacApp's application classes, plays several important roles in performing commands. When you post a command object to be performed, MacApp stores it in the application object's command queue <A HREF=MacAppProgGuide-41.html#MARKER-9-27>(page 99)</A>. The application object periodically retrieves commands from the queue and performs them. It also provides methods to help in performing undo and redo for command objects <A HREF=#MARKER-9-202>(page 125)</A>.<P>
<A NAME=HEADING44-7></A>
<H2><A NAME=MARKER-2-146></A><A NAME=MARKER-9-147></A>Command Objects</H2>
 A command object is an object instantiated from the <CODE>TCommand</CODE> class or one of its subclasses. A command's <CODE>DoIt</CODE> method performs the command operation. A simple command is one that does not support undo--its <CODE><A NAME=MARKER-2-148></A>fCanUndo</CODE> field is set to <CODE>FALSE</CODE> (the default is <CODE>TRUE</CODE>). For a command that <I>does</I> support undo, the <CODE>UndoIt</CODE> method undoes the command operation and the <CODE>RedoIt</CODE> method redoes the operation.<P>
<A NAME=HEADING44-9></A>
<H3><A NAME=MARKER-2-149></A>The Command Context</H3>
 When you initialize a command object, you associate a context with it. The context is a reference to a command-handler object, such as a document or view. It is possible to have one active command per context. For example, an application can manage a separate undo operation for each of its open documents.<P>
 You can get the context from a command-handler object (such as a window or document) by calling its <CODE><A NAME=MARKER-2-150></A>GetContext</CODE> method. The default implementation of <CODE>GetContext</CODE>, in <CODE>TCommandHandler</CODE>, just returns a reference to the command handler itself. For view objects, <CODE>GetContext</CODE> returns a reference to the view's document, if it has one--otherwise, it returns a reference to the view's window.<P>
<A NAME=HEADING44-12></A>
<H3><A NAME=MARKER-9-151></A>The Command <A NAME=MARKER-2-152></A>Context for Classes That Handle Apple Events</H3>
 Classes that handle Apple events normally mix in the <CODE>MScriptableObject</CODE> class. <CODE>MScriptableObject</CODE> supplies the <CODE>GetCommandContext</CODE> method.<P>
<UL>
<LI>For objects that descend from <CODE>TCommandHandler</CODE>, <CODE>GetCommandContext</CODE> calls the object's <CODE>GetContext</CODE> method, which normally returns the object itself as the command context.
<LI>For objects that <I>do not</I> descend from <CODE>TCommandHandler</CODE>, <CODE>GetCommandContext</CODE> supplies as the context the default Apple event target object, which is normally the application object. As a result, the command's context will default to the application object, <I>not</I> to the class that created the command.<P>
</UL>
<DL>
<DT><B>IMPORTANT</B>
<DD>If your application mixes <CODE>MScriptableObject</CODE> with a class that is not a descendant of <CODE>TCommandHandler</CODE>, and that class creates command objects to handle Apple events, it should override the <CODE><A NAME=MARKER-2-153></A>GetCommandContext</CODE> method. Otherwise, the default Apple event target object, usually the application object, will serve as the command's context.<EM></EM><A NAME=MARKER-2-154></A><A NAME=MARKER-2-155></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING44-17></A>
<H3>When a Command Is Complete</H3>
 A simple command is complete as soon as its <CODE>DoIt</CODE> method is executed. An undoable command remains active, allowing a user to undo or redo the command operation until another undoable command is associated with the same context. A command object is automatically freed when it is completed, unless its <CODE><A NAME=MARKER-2-156></A>fFreeOnCompletion</CODE> field is set to <CODE>FALSE</CODE> (the default value is <CODE>TRUE</CODE>).<P>
 When a command is completed and the command operation was left in the done state, MacApp calls the command object's <CODE><A NAME=MARKER-2-157></A>Commit</CODE> method. You override the <CODE>Commit</CODE> method to perform a task after the command operation is completed. For example, a command may mark data for deletion, then unmark or re-mark it as the user chooses Undo and Redo. The overridden <CODE>Commit</CODE> method, which is called only if the command is completed in the done state, actually deletes the data.<P>
<A NAME=HEADING44-20></A>
<H3>Command Numbering</H3>
 <A NAME=MARKER-2-158></A>Each command object has a command number, which is stored in the command's <CODE><A NAME=MARKER-2-159></A>fIdentifier</CODE> field. Many command numbers also serve as menu item command numbers. MacApp uses the command number to identify the command and to set the Undo/Redo menu item text <A HREF=#MARKER-9-202>(page 125)</A>. For more information on command numbers, see <A HREF=MacAppProgGuide-46.html#MARKER-9-239>"MacApp's Command-Numbering System," beginning on page 131</A><P>
<A NAME=HEADING44-22></A>
<H2><A NAME=MARKER-2-160></A><A NAME=MARKER-9-161></A>Performing a Command Operation</H2>
 When your application needs to respond to a user action, you create a command object and associate a command-handler context with it. Then you call the context's <CODE><A NAME=MARKER-2-162></A>PostCommand</CODE> method to insert the command into the application object's command queue.<P>
 The application object retrieves and processes items from its command queue in first-in, first-out order. When the application object processes a command object, it calls the command's <CODE><A NAME=MARKER-2-163></A>Process</CODE> method. The <CODE>Process</CODE> method calls the <CODE><A NAME=MARKER-2-164></A>PerformCommand</CODE> method of the command object's context.<P>
 In some situations, your application may need to perform an operation immediately. For example, if you respond to an Apple event by posting a command, you may get a time-out error while the command is in the queue. So instead, you should create and initialize a command object, then call its <CODE>Process</CODE> method directly, instead of posting the command to the command queue.<P>
 The next section describes how a command object can send an Apple event to record its operation or allow an attached script to handle the operation. For commands that send an Apple event, you again may want to call <CODE>Process</CODE> directly to control the order in which Apple events are recorded.<A NAME=MARKER-2-165></A><P>
<A NAME=HEADING44-27></A>
<H2><A NAME=MARKER-2-166></A><A NAME=MARKER-9-167></A>Command Objects and Apple Events</H2>
 A command object based on the <CODE>TCommand</CODE> class can send an Apple event describing its command operation. MacApp's Apple event-dispatching mechanism (described in <A HREF=MacAppProgGuide-52.html#MARKER-9-77>"Dispatching Apple Events," beginning on page 150</A>) allows attached scripts to respond to Apple events, so using command objects lets your application handle user actions in a flexible way. The next two sections demonstrate how a MacApp application handles an operation specified directly by a user action and how it handles the same operation specified by an Apple event.<P>
<A NAME=HEADING44-29></A>
<H3><A NAME=MARKER-2-168></A>Using a Command Object That Sends an Apple Event</H3>
 To handle a user menu choice with a command object that sends an Apple event:<P>
<OL>
<LI>In the <CODE>DoMenuCommand</CODE> method of a command-handler object (such as a document or view), you create and post a command object to handle the user menu choice. You set the command's <CODE>fUseAppleEvent</CODE> field to <CODE>TRUE</CODE>, indicating that the command should send an Apple event when it is performed.
<LI>The application object retrieves the command object from the command queue and tells the command's context (a command-handler object such as a document or view; usually the same object that created the command) to perform the command. Since <CODE>fUseAppleEvent</CODE> is <CODE>TRUE</CODE>, the context asks the command to supply an Apple event describing the command operation, then sends the resulting Apple event. At this point, the Apple event may be recorded.
<LI>MacApp's predispatch callback routine dispatches the Apple event to its specified object, typically a command handler such as a document or view object and possibly the same context that sent the Apple event. This gives any script attached to the target object a chance to handle the Apple event. (The predispatch handler is installed only if at least one object in the application currently has an attached script.)
<LI>If the Apple event isn't handled by a script, MacApp's standard callback routine, <CODE><A NAME=MARKER-2-170></A>TOSDispatcher::<A NAME=MARKER-2-171></A>DispatchHandler</CODE>, dispatches the event to its specified object. However, the <CODE>DispatchHandler</CODE> method has built-in machinery that attempts to associate the target object with a command handler (by calling the <CODE>IsPendingAction</CODE> method, which in turn calls the <CODE>GetCommandContext</CODE> method), and to determine whether the command handler is the same one that sent the current Apple event.<P>
For example, if a context, such as a document object, has performed a command that has sent an Apple event to make the operation recordable, it isn't necessary to dispatch the Apple event to the context to create a command to handle the operation, since the context has already created such a command. <P>
On the other hand, if the Apple event <I>was</I> sent by the currently pending command, the <CODE>DispatchHandler</CODE> method returns without handling the event. As a result, the command's context continues to perform the command and calls the <CODE>DoIt</CODE> method, which does the command operation.<P>
Finally, if a failure occurs while processing the Apple event, the pending command will serve as a fallback. This is why MacApp's scripting architecture has commands create Apple events.<A NAME=MARKER-2-172></A><P>
</OL>
<A NAME=HEADING44-38></A>
<H3>Using a Command Object to Respond to an <A NAME=MARKER-2-173></A>Apple Event</H3>
 The previous section describes how to use a command object to handle an operation specified by a user menu choice. This section describes how to handle the same operation when it is specified by an Apple event. The Apple event may be sent by a script, or by an external process or other source outside the application. If recording is on, the Apple event will already have been recorded before it is received by MacApp:<P>
<OL>
<LI>MacApp's predispatch callback routine dispatches the Apple event to its specified object, typically a command handler such as a document or view object. This gives any script attached to the target object a chance to handle the Apple event. (The predispatch handler is installed only if at least one object in the application currently has an attached script.)
<LI>If the Apple event isn't handled by an attached script, MacApp's standard callback routine dispatches the event to its specified object. The <CODE>DispatchHandler</CODE> method determines that the Apple event <I>wasn't</I> sent by the target object itself as part of a command operation. It goes ahead and calls the target object's <CODE><A NAME=MARKER-2-174></A>DoScriptCommand</CODE> method, passing in a MacApp command number for the specified event.
<LI>In the <CODE>DoScriptCommand</CODE> method of the target object (an object based on a class that mixes in <CODE><A NAME=MARKER-2-175></A>MScriptableObject</CODE>), you create a command object to perform the specified operation. You set the command's <CODE>fUseAppleEvent</CODE> field to <CODE>FALSE</CODE>, indicating that the command should <I>not</I> send an Apple event when it is performed, since the command is already being created in response to a received Apple event.<P>
You <I>do not</I> post the command to the command queue. Instead, you call its <CODE>Process</CODE> method to process the command immediately. Then, if an error occurs, you can handle it while you still have access to the Apple event that initiated the command.
<LI>Because <CODE>fUseAppleEvent</CODE> is <CODE>FALSE</CODE>, the context does not ask the command to supply an Apple event describing the command operation. It just calls the <CODE>DoIt</CODE> method, which performs the command operation.<P>
</OL>
 Although the processes described in this and the previous section are somewhat complex, they can be reduced to a couple of fairly straightforward rules:<P>
<UL>
<LI>To handle a user-specified operation, create and post a command object that can perform the operation. If the operation is recordable or you want to give an attached script an opportunity to handle it, set the <CODE>fUseAppleEvent</CODE> field to <CODE>TRUE</CODE> and override the <CODE>MakeAppleEvent</CODE> method to create an Apple event that describes the command operation. You create the command object in a method such as <CODE>DoMenuCommand</CODE> or <CODE>DoMouseCommand</CODE>.
<LI>To handle the same operation specified by an Apple event, create the same type of command object, but set the <CODE>fUseAppleEvent</CODE> field to <CODE>FALSE</CODE> and call the command's <CODE>Process</CODE> method. You create the command object in the <CODE>DoScriptCommand</CODE> method of a class that mixes in <CODE>MScriptableObject</CODE>.<P>
</UL>
 In the <CODE>TCommand</CODE> class, <CODE><A NAME=MARKER-2-178></A>fUseAppleEvent</CODE> defaults to <CODE>FALSE</CODE> and <CODE><A NAME=MARKER-2-179></A>MakeAppleEvent</CODE> just returns <CODE>NULL</CODE>. Subclasses override the <CODE>MakeAppleEvent</CODE> method to create an Apple event that describes the command operation. Several MacApp command classes provide examples of this mechanism, including <CODE><A NAME=MARKER-2-180></A>TNewDocumentCommand</CODE>, <CODE><A NAME=MARKER-2-181></A>TPrintCommand</CODE>, and <CODE><A NAME=MARKER-2-182></A>TQuitAppCommand</CODE>.<A NAME=MARKER-2-183></A><A NAME=MARKER-2-184></A><P>
<A NAME=HEADING44-49></A>
<H2><A NAME=MARKER-9-185></A><A NAME=MARKER-2-186></A>Linked Commands</H2>
 MacApp supports "linking" of two commands, which means that doing, undoing, redoing, or committing either command causes its linked command to be done, undone, redone, or committed as well. For example, to perform a drag operation that causes data to be moved between two views, the source view creates a command to delete the data and the destination view creates a command to insert the data. The commands are then linked together, so undoing or redoing the operation changes the data in each view as required. (This process is described in greater detail in <A HREF=MacAppProgGuide-72.html#MARKER-9-29>Chapter 9, "Drag and Drop."</A>)<P>
 MacApp's <CODE>TCommandHandler</CODE> class automatically manages operations on linked commands. For example, when MacApp performs a command, it checks the command's <CODE>fValidationFailed</CODE> field. If either command of a linked pair of commands fails to complete because of a validation error, MacApp ensures that both commands are left undone and that the Clipboard is also left in its previous state.<P>
<A NAME=HEADING44-52></A>
<H2><A NAME=MARKER-2-187></A><A NAME=MARKER-9-188></A>Undoing a Command Operation</H2>
 When you define a command class to perform an undoable operation, you supply <CODE><A NAME=MARKER-2-189></A>DoIt</CODE>, <CODE><A NAME=MARKER-2-190></A>UndoIt</CODE>, and <CODE><A NAME=MARKER-2-191></A>RedoIt</CODE> methods. MacApp supplies a mechanism for calling these methods at the appropriate time, making much of the work of undoing and redoing a command operation automatic.<P>
<A NAME=HEADING44-54></A>
<H3><A NAME=MARKER-2-192></A><A NAME=MARKER-9-193></A>The Undo/Redo Menu Item</H3>
 The <A NAME=MARKER-2-194></A>Undo/Redo menu item appears in the Edit menu. It is enabled or disabled by the following process:<P>
<OL>
<LI>MacApp calls <CODE>gApplication-&gt;<A NAME=MARKER-2-195></A>SetupTheMenus</CODE> whenever the status of menu items might need to be updated (see <A HREF=MacAppProgGuide-86.html#MARKER-9-41>"Enabling and Disabling Menu Items," beginning on page 306</A>).
<LI>The <CODE>SetupTheMenus</CODE> method first disables each menu item on each menu MacApp manages, then calls the <CODE>HandleSetupMenus</CODE> method of the current target object. 
<LI>The <CODE>HandleSetupMenus</CODE> method causes the <CODE>DoSetupMenus</CODE> method to be called for each behavior object and event-handler object in the target chain.
<LI>For the <CODE>TCommandHandler</CODE> class, the <CODE>HandleSetupMenus</CODE> method calls the <CODE><A NAME=MARKER-2-196></A>SetupUndoMenu</CODE> method.
<LI>If the command-handler object has an undoable command associated with it, <CODE>SetupUndoMenu</CODE> enables the <CODE>cUndo</CODE> menu command. It then calls an application method, <CODE><A NAME=MARKER-2-198></A>SetUndoText</CODE>, passing a Boolean value that indicates whether the command is in the done or undone state.
<LI>The <CODE>SetUndoText</CODE> method determines what text should go in the Undo/Redo menu item and sets that text. It calls the global routine <CODE>CommandToName</CODE> to get the menu item text based on the command number, then prepends the word "Undo" or "Redo", depending on the state of the command. For a Copy command in the done state, for example, the text would be set to "Undo Copy".<P>
</OL>
 Setting the text for an Undo/Redo menu item depends on information stored in the application's <CODE>'CMNU'</CODE> resources. These resources describe an application's menus and associate a command number with each menu item.<P>
 For commands that do not appear on any menu, you specify the Undo/Redo text in a special <CODE>'CMNU'</CODE> resource called the <A NAME=MARKER-2-200></A>Buzzwords menu. This resource is described in <A HREF=MacAppProgGuide-86.html#MARKER-9-40>"The Buzzwords 'CMNU' Resource," beginning on page 305</A>. The Buzzwords menu does not appear in your application's menu bar--you use it only to supply MacApp with information about commands that do not appear on any menu.<P>
 If, for example, your application has a drawing command that is initiated by dragging with the mouse (it doesn't appear on any of your application's menus), you supply an entry to the Buzzwords menu that specifies "Drawing" as the Undo/Redo text for the command. As a result, MacApp can display the text "Undo Drawing".<P>
<A NAME=HEADING44-65></A>
<H3><A NAME=MARKER-2-201></A><A NAME=MARKER-9-202></A>The Undo/Redo Flow of Control</H3>
 When the Undo/Redo menu item is enabled, the user can reverse the state of the current command by typing Command-Z or choosing the Undo menu item. The result is a call to the current target object's <CODE><A NAME=MARKER-2-203></A>HandleMenuCommand</CODE> method. The flow of control to the <CODE>HandleMenuCommand</CODE> method is shown in <A HREF=#MARKER-9-209>Figure 5-7</A>. (The general operation of the <CODE>HandleMenuCommand</CODE> method is shown in <A HREF=MacAppProgGuide-42.html#MARKER-9-95>Figure 5-4</A>.)<P>
 The <CODE>cUndo</CODE> menu command is typically handled by the <CODE>DoMenuCommand</CODE> method of the <CODE>TDocument</CODE> class, which calls the application object's <CODE>DoUndoRedo</CODE> method. The <CODE><A NAME=MARKER-2-182></A>DoUndoRedo</CODE> method posts a <CODE>TClientCommand</CODE> to send an Undo Apple event.<P>
 The Undo event sent by the <CODE><A NAME=MARKER-2-205></A>TClientCommand</CODE> object is received immediately and dispatched to the document object's <CODE>DoScriptCommand</CODE> method. The same dispatching occurs if an Undo event specifying the document object as its target is received from a script or other source. The document's <CODE>DoScriptCommand</CODE> method handles the Undo event by calling the application object's <CODE>UndoRedoInContext</CODE> method.<P>
 Both the <CODE>TDocument</CODE> and the <CODE>TApplication</CODE> classes handle the <CODE><A NAME=MARKER-2-207></A>cUndo</CODE> command number by calling <CODE>UndoRedoInContext</CODE> from their <CODE>DoScriptCommand</CODE> methods. If you handle undo/redo in a context other than an application or document, your context's <CODE>DoScriptCommand</CODE> method should also call the application object's <CODE>UndoRedoInContext</CODE> method.<A NAME=MARKER-2-208></A><P>
<B>Figure 5-7  <A NAME=MARKER-9-209></A>Initiating an undo operation</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-046.gif"><P>
 The application's <CODE><A NAME=MARKER-2-210></A>UndoRedoInContext</CODE> method creates and posts a <CODE>TUndoRedoCommand</CODE> object, which is inserted into the application's command queue. <A HREF=#MARKER-9-211>Figure 5-8</A> continues where <A HREF=#MARKER-9-209>Figure 5-7</A> leaves off, at the current target object's <CODE>HandleMenuCommand</CODE> method.<P>
<B>Figure 5-8  <A NAME=MARKER-9-211></A>Handling an Undo command or Undo Apple event</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-047.gif"><P>
 <A HREF=#MARKER-9-211>Figure 5-8</A> shows the steps leading to the creation and posting of a <CODE>TUndoRedoCommand</CODE> object, including the case of an Undo event received from an attached script or from a source outside the application. The application object retrieves the <CODE><A NAME=MARKER-2-213></A>TUndoRedoCommand</CODE> object from the command queue and processes it, resulting in a call to the <CODE>DoIt</CODE> method. The <CODE>TUndoRedoCommand</CODE>::<CODE>DoIt</CODE> method retrieves a command from its context, typically the document object. If the command is currently in the done state, <CODE>DoIt</CODE> calls the command's <CODE>UndoIt</CODE> method; if the command is in the undone state, <CODE>DoIt</CODE> calls the <CODE>RedoIt</CODE> method.<P>
<DL>
<DT><B>Note</B>
<DD>This process is slightly more complicated when the command is a linked command. Linked commands are described in <A HREF=#MARKER-9-185>"Linked Commands," beginning on page 123</A>.<EM></EM><A NAME=MARKER-2-214></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING44-77></A>
<H2><A NAME=MARKER-2-215></A>Commands and Change Notification</H2>
 When the <CODE>TCommandHandler::<A NAME=MARKER-2-216></A>DoPerformCommand</CODE> method calls a command object's <CODE>Commit</CODE> method after the command's operation is performed, it also calls the command's <CODE><A NAME=MARKER-2-217></A>DoNotification</CODE> method. The <CODE>TCommand::DoNotification</CODE> method calls the <CODE><A NAME=MARKER-10-4></A>Changed</CODE> method of the object referenced by its <CODE><A NAME=MARKER-2-219></A>fObjectToModify</CODE> field. The <CODE>fObjectToModify</CODE> field normally refers to the command's context--the same object referred to by the <CODE><A NAME=MARKER-2-220></A>fContext</CODE> field.<P>
 Your application can take advantage of this notification mechanism. For example, the <CODE>Changed</CODE> method of the <CODE>TDocument</CODE> class modifies the document's change count, to keep track of whether the document needs to be saved.<P>
<A NAME=HEADING44-80></A>
<H2><A NAME=MARKER-9-221></A><A NAME=MARKER-2-222></A>Commands and the Clipboard</H2>
 MacApp's command mechanism makes it relatively easy to work with the Clipboard. For example, MacApp automatically switches back and forth between Undo and Redo Clipboard views as the user chooses to undo and redo a command that affects the Clipboard. MacApp's Clipboard support can display <CODE>'PICT'</CODE> and <CODE>'TEXT'</CODE> data types in a Clipboard view. You can build on MacApp's support to cut and paste your private data types as well.<P>
 Basic Clipboard support is described in the next section. Commands that work with the Clipboard are implemented in <A HREF=MacAppProgGuide-115.html#MARKER-9-19>Chapter 22, "Working With the Clipboard."</A><A NAME=MARKER-2-223></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-43.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-45.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
