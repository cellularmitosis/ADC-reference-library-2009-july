<html><head><title>Designing Enterprise Objects</title></head><body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOF Developer's Guide</font><br><br><!--end of path --> <a href="EOsI.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="EOsI2.html"><IMG SRC="ArrowLeft.gif">Previous Section</a> <a name="2657"><h1> Implementing an Enterprise Object</h1></a><a name="2661">As discussed in the section<a href="EOsI2.html#825"> "EOGenericRecord or Custom Class?"</a>, one of the first decisions you need to make about an enterprise object is whether you want it to be an EOGenericRecord or a custom class. Use EOGenericRecords to represent enterprise objects that don't require custom behavior, and create custom classes to represent enterprise objects that do.<p></a><a name="8276">Enterprise Objects Framework interacts with generic records and custom classes the same way. It defines the set of methods for supporting operations common to all enterprise objects and uses only those methods. The EOEnterpriseObject interface (or informal protocol in Objective-C) specifies the complete set. It includes methods for initializing instances, announcing changes, setting and retrieving property values, and performing validation of state. <p></a><a name="8601">You rarely need to implement the EOEnterpriseObject interface from scratch. The Framework provides default implementations of all its methods. In Java, the class EOCustomObject implements the interface, so your custom classes should inherit from it. In Objective-C, categories on the root class, NSObject, provide default implementations. Regardless of what language you choose, some of the default method implementations are for custom classes to override, but most are meant to be used as defined by the Framework. Many methods are used internally by the Framework and are rarely invoked by your application code. For more information on EOEnterpriseObject and its methods, see the interface specification in <em>Enterprise Objects Framework Reference</em>.<p></a><a name="8642">The remainder of this chapter describes implementing custom classes.<p></a><a name="8638"><h2> Generating Source Files</h2></a><a name="8639">The easiest way to create a custom enterprise object is with EOModeler's Generate Java Files, Generate ObjC Files, and Generate Client Java Files commands. These commands take the attributes and relationships you've defined in your model, and use them to generate source code for a corresponding enterprise object class.<p></a><a name="7288">You can generate the source code in Java (Generate Java Files) or Objective-C (Generate ObjC Files). The Generate Client Java Files command creates source code for classes that will be used in the client side of a distributed WebObjects application.<p></a><a name="7339">If you choose Java as your language, EOModeler creates a <strong>.java</strong> file for your class. If you choose Objective-C, it creates both a header (<strong>.h</strong>) and an implementation (<strong>.m</strong>) file. No matter what the language, the source files created by EOModeler are completely functional.<p></a><a name="8669"><h2> Superclass</h2></a><a name="8810">EOModeler assumes that your custom classes descend from EOCustomObject (or NSObject in Objective-C) so that they inherit the Framework's default implementations of the EOEnterpriseObject interface.<p></a><a name="8685"><h2> Instance Variables</h2></a><a name="8818">EOModeler's generated source code files contain instance variables for all of the corresponding entities class properties, both attributes and relationships alike. For example, the following code excerpts show the instance variables created for the Member class:<p></a><a name="9001">In Java, (from <strong>Member.java</strong>)<p></a><pre><a name="8827">protected String city;<br>protected NSGregorianDate memberSince;<br>protected String phone;<br>protected String state;<br>protected String streetAddress;<br>protected String zip;<br>protected Number customerID;<br>protected String firstName;<br>protected String lastName;<br>protected CreditCard creditCard;<br>protected NSMutableArray rentals;</a></pre><a name="8820">In Objective-C (from <strong>Member.h</strong>)<p></a><pre><a name="8849">NSString *city;<br>NSCalendarDate *memberSince;<br>NSString *phone;<br>NSString *state;<br>NSString *streetAddress;<br>NSString *zip;<br>NSNumber *customerID;<br>NSString *firstName;<br>NSString *lastName;<br>CreditCard *creditCard;<br>NSMutableArray *rentals;</a></pre><a name="8688">All of the instance variables correspond to attributes in the Member entity except for <strong>creditCard</strong> and <strong>rentals</strong>, which correspond to relationships.<p></a><a name="9013"><h3> Primary key generation</h3></a><a name="8654">Enterprise objects don't have to declare instance variables for primary key and foreign key values. The Framework manages primary and foreign keys automatically.<p></a><a name="9014">The default mechanism for assigning unique primary keys is provided with the EOAdaptorChannel method <strong>primaryKeyForNewRowWithEntity</strong> (or <strong>primaryKeyForNewRowWithEntity:</strong> in Objective-C). If you need to provide a custom mechanism for assigning primary keys, you can implement the EODatabaseContext delegate method <strong>databaseContextNewPrimaryKey</strong> (or <strong>databaseContext:newPrimaryKeyForObject:entity:</strong> in Objective-C). Using either of these two techniques means you don't need to store the primary key in your enterprise object. For more discussion of primary keys, see the chapter <a href="FAQ.html#7958"> "Answers to Common Design Questions"</a>.<p></a><a name="9015">Note that Enterprise Objects Framework doesn't support modifiable primary key values-you shouldn't design your application so that users can change a primary key's value. If you really need this behavior, you have to implement it by deleting an affected object and reinserting it with a new primary key.<p></a><a name="716"><h2> Writing Accessor Methods</h2></a><a name="856">When you generate source files for custom classes in EOModeler, the resulting files include default accessor methods. Accessor methods let you set and return the values of your class properties (instance variables). For example, here are some of Customer's accessor methods:<p></a><a name="9023">In Java, (from <strong>Member.java</strong>)<p></a><pre><a name="9226">public NSGregorianDate memberSince() {<br>	willChange();<br>	return memberSince;<br>}<br><br>public void setMemberSince(NSGregorianDate value) {<br>	willChange();<br>	memberSince = value;<br>}<br><br>public CreditCard creditCard() {<br>	willChange();<br>	return creditCard;<br>}<br><br>public void setCreditCard(CreditCard value) {<br>	willChange();<br>	creditCard = value;<br>}<br><br>public NSArray rentals() {<br>	willRead();<br>	return rentals;<br>}<br><br>public void setRentals(NSMutableArray value) {<br>	willChange();<br>	rentals = value;<br>}<br><br>public void addToRentals(Rental object) {<br>	willChange();<br>	rentals.addObject(object);<br>}<br><br>public void removeFromRentals(Rental object) {<br>	willChange();<br>	rentals.removeObject(object);<br>}</a></pre><a name="9039">In Objective-C (from <strong>Member.m</strong>)<p></a><pre><a name="9353">- (void)setMemberSince:(NSCalendarDate *)value<br>{<br>	[self willChange];<br>	[memberSince autorelease];<br>	memberSince = [value retain];<br>}<br>- (NSCalendarDate *)memberSince { return memberSince; }<br><br>- (void)setCreditCard:(CreditCard *)value<br>{<br>	// a to-one relationship<br>	[self willChange];<br>	[creditCard autorelease];<br>	creditCard = [value retain];<br>}<br>- (CreditCard *)creditCard { return creditCard; }<br><br>- (void)addToRentals:(Rental *)object<br>{<br>	// a to-many relationship<br>	[self willChange];<br>	[rentals addObject:object];<br>}<br>- (void)removeFromRentals:(Rental *)object<br>{<br>	// a to-many relationship<br>	[self willChange];<br>	[rentals removeObject:object];<br>}<br>- (NSArray *)rentals { return rentals; }</a></pre><a name="1000">Features introduced by these code excerpts are discussed in the following sections.<p></a><a name="12319"><B>Note: </B> You don't have to provide accessor methods for your object's properties. The Framework can access your object's properties directly (through its instance variables). For more information, see the section <a href="EOsI3.html#9425"> "Accessing an Enterprise Object's Data"</a>."<p></a><a name="873"><h3> Change Notification</h3></a><a name="1016">In the above code excerpts from Member source files<strong>,</strong> you can see that each of the "set" methods includes an invocation of the <strong>willChange</strong> method.<p></a><a name="1017">In Enterprise Objects Framework, objects that need to know about changes to an enterprise object register as observers for change notifications. When an enterprise object is about to change, it has the responsibility of posting a change notification so that registered observers are notified. To do this, enterprise objects should invoke the method <strong>willChange</strong> prior to altering their state. This is invoked by default in generated source code's "set" methods, but whenever you add your own methods that change the object's state, you need to remember to include an invocation.<p></a><a name="9358">An implementation of <strong>willChange</strong> is provided in EOCustomObject (or NSObject in Objective-C), so you don't have to implement it yourself. For more information on change notification, see the specification for the control layer's EOObserverCenter class in <em>Enterprise Objects Framework Reference</em>.<p></a><a name="5794"><B>Note: </B> If you're using EOGenericRecord, you don't have to worry about invoking <strong>willChange</strong>. As the default enterprise object class, EOGenericRecord handles change notifications as part of its normal behavior.<p></a><a name="11048"><h3> Faulting</h3></a><a name="11050">Similar to the way "set" methods invoke the <strong>willChange</strong> method, Java "get" methods include an invocation of <strong>willRead</strong>. This method is part of Enterprise Objects Framework's <em>faulting</em> mechanism for postponing an object's initialization until its actually needed. Faulting is also provided with Objective-C, but its implementation is different and doesn't require the <strong>willRead</strong> method.<p></a><a name="11093">In Java, the <strong>willRead</strong> method and a handful of others are defined in the Framework's EOFaulting interface. EOFaulting is a part of EOEnterpriseObject, so your custom classes inherit a default implementation of it. The default implementation of <strong>willRead</strong> checks to see if the receiver has already been fully initialized. If it hasn't been, it fills the object with values fetched from the database. Before your application attempts to message an object, you must ensure that it has its data. To do this, enterprise objects invoke the method <strong>willRead</strong> prior to any attempt to access the object's state, most typically in "get" methods. Enterprise Objects don't have to invoke <strong>willRead</strong> in "set" methods, because the <strong>willChange</strong> method invokes <strong>willRead</strong> for you.<p></a><a name="11113">For more information on faulting, see the interface specification for EOFaulting in <em>Enterprise Objects Framework Reference</em>. For more information on Objective-C's faulting mechanism, see the EOFault class specification.<p></a><a name="9378"><h3> Accessing Data through Relationships</h3></a><a name="9379">Relationships and flattened properties are treated no differently than properties based on the entity's original attributes.<p></a><a name="1018">For example, Customer can use its <strong>creditCard </strong>relationship to traverse the object graph and change values in the CreditCard object. If you want to access information about a Customer's credit card, your code can do something like this:<p></a><a name="9389">In Java:<p></a><pre><a name="9397">customer.creditCard().limit();</a></pre><a name="9393">In Objective-C:<p></a><pre><a name="1093">[[member creditCard] limit];</a></pre><a name="9421">You can also modify attributes in the object graph regardless of what table they came from. For example, suppose that Customer's <strong>streetAddress</strong> attribute was flattened from an Address entity. Customer could have a <strong>setStreetAddress</strong> method that modified the attribute, even though it's not actually stored in the Customer table.<p></a><a name="9425"><h3> Accessing an Enterprise Object's Data</h3></a><a name="1188">In implementing your enterprise object classes, you want to focus on the code that's unique to your application, not on code that deals with fitting your objects into the Framework. To this end, the Framework uses a standard interface for accessing an enterprise object's properties and provides a default implementation that takes advantage of methods you're likely to write for your own use anyway.<p></a><a name="9467">This data transport mechanism is defined by the EOKeyValueCoding interface (or informal protocol in Objective-C). It specifies that properties of an object are accessed indirectly by name (or <em>key</em>), rather than directly through invocation of an accessor method or as instance variables. EOKeyValueCoding is incorporated in the EOEnterpriseObject interfaces, so your custom classes automatically inherit key-value coding behavior that is sufficient for most purposes.<p></a><a name="9551">The basic methods for accessing an object's values are <strong>takeValueForKey</strong> and <strong>valueForKey</strong> (<strong>takeValue:forKey:</strong> and <strong>valueForKey:</strong> in Objective-C), which set or return the value for the specified key, respectively. The default implementations use the accessor methods normally implemented by objects (or to access instance variables directly if need be), so that you don't have to write special code simply to integrate your objects into the Enterprise Objects Framework.<p></a><a name="12544">There are corresponding methods <strong>takeStoredValueForKey</strong> and <strong>storedValueForKey</strong> (<strong>takeStoredValue:forKey:</strong> and <strong>storedValueForKey:</strong> in Objective-C) are similar, but they're considered to be private to the Framework and to the enterprise object class that provides them. The stored value methods are for use by the Framework for transporting data to and from trusted sources. For example, <strong>takeStoredValueForKey</strong> is used to initialize an object's properties with values fetched from the database, whereas <strong>takeValueForKey</strong> is used to modify an object's properties to values provided by a user.<p></a><a name="12545"> Public Access with the Basic Methods<p></a><a name="12546">When accessing an object's class properties, the default implementations of the basic key-value coding methods use the class definition. They look for "set" methods in the following sequence:<p></a><pre><a name="6481">set<em>Property</em></a><a name="6489">_set<em>Property</em></a></pre><a name="6490">where <em>property</em> is the name of the property as in <strong>lastName</strong>. Note that the first letter of the property name is made uppercase as in <strong>setLastName</strong>.<p></a><a name="6460">Similarly, the key-value coding methods look for "get" methods in the following sequence:<p></a><pre><a name="6461">get<em>Property</em></a><a name="6462">property</a><a name="6463">_get<em>Property</em></a><a name="6468">_<em>property</em></a></pre><a name="6469">If no accessor methods can be found, the key-value coding methods look for instance variables containing the property's name and sets or retrieves their value directly. The search order for instance variables is as follows:<p></a><pre><a name="6476">property</a><a name="6477">_<em>property</em></a></pre><a name="6478">where <em>property</em> is the name of the property as in <strong>lastName</strong>.<p></a><a name="872">By using the accessor methods you normally define for your objects, the default implementations of the key-value coding methods allow you to concentrate on implementing custom behavior. They also allow your objects to determine how their properties are accessed. For example, your Employee class can define a <strong>salary</strong> method that just returns an employee's salary directly or calculates it from another value.<p></a><a name="12553"><B>Note: </B> You shouldn't use "set" methods to perform validation. Rather, you should use the validation methods, described in<a href="EOsI3.html#9884"> "Performing Validation"</a>.<p></a><a name="12558"> Private Access with the Stored Value Methods<p></a><a name="12559">The stored value methods, <strong>takeStoredValueForKey</strong> and <strong>storedValueForKey</strong>, are used by the framework to store and restore an enterprise object's properties, either from the database or from an in-memory snapshot (for undoing changes to an object and for synchronizing objects between child and parent editing contexts in a nested configuration, for example).This access is considered private to the enterprise object and is invoked by the Framework to effect persistence on the object's behalf. On the other hand, the basic key-value coding methods are the public API to an enterprise object. They are invoked by clients external to the object, such as for interactions with the user interface or with other enterprise objects.<p></a><a name="9671">Like the basic key-value coding methods, the stored value methods access an object's properties by invoking property-specific accessor methods or by directly accessing instance variables. However, the stored value methods use a different search order for resolving the property key: they search for a private accessor first (a method beginning with an underbar), then for an instance variable, and finally for a public accessor. Enterprise object classes can take advantage of this distinction to simply set or get values when properties are accessed through the private API (on &#32;behalf of a trusted source) and to perform additional processing when properties are accessed through the public API. Put another way, the stored value methods allow you bypass the logic in your public accessor methods, whereas the basic key-value coding methods execute that logic.<p></a><a name="9672">The stored value methods are especially useful in cases where property values are interdependent. For example, suppose you need to update a total whenever an object's <strong>bonus</strong> property is set:<p></a><a name="9716">In Java:<p></a><pre><a name="9673">void setBonus(double newBonus) {<br>	willChange();<br>	_total += (newBonus - _bonus);<br>	_bonus = newBonus;<br>} </a></pre><a name="9720">In Objective-C:<p></a><pre><a name="9674">- &#32;(void)setBonus:(double)newBonus {<br>	[self willChange];<br>	_total += (newBonus - _bonus);<br>	_bonus = newBonus;<br>} </a></pre><a name="9675">This total-updating code should be activated when the object is updated with values provided by a user (through the user interface), but not when the <strong>bonus</strong> property is restored from the database. Since the Framework restores the property using <strong>takeStoredValueForKey</strong> and since this method accesses the <strong>_bonus</strong> instance variable in preference to calling the public accessor, the unnecessary (and possibly expensive and harmful) recomputation of <strong>_total</strong> is avoided. If the object actually wants to intervene when a property is set from the database, it has two options:<p></a><ul><a name="9679"><p><li>Implement <strong>_setBonus</strong> (<strong>_setBonus:</strong> in Objective-C).</a><a name="13512"><p><li>Replace the Framework's default stored value search order with the same search order used by the basic methods. To do this, in your custom class, implement the static method <strong>useStoredAccessor</strong> to return <strong>false</strong>. (In Objective-C, override the class method <strong>useStoredAccessor</strong> to return NO.)</a><a name="13513"> Error Handling methods<p></a></ul><a name="9754">EOKeyValueCoding defines two additional methods for handling error conditions: <strong>handleQueryWithUnboundKey</strong> and <strong>handleTakeValueForUnboundKey</strong> (<strong>handleQueryWithUnboundKey:</strong> and <strong>handleTakeValue:forUnboundKey:</strong> in Objective-C). The default implementation of the key-value coding methods invoke these methods when they receive a key for which they can find no accessor methods or instance variables. The default implementations throw exceptions, but you can override them to handle the error in a way that's appropriate for your custom class.<p></a><a name="820"><h2> Writing Derived Methods</h2></a><a name="819">The source files generated by EOModeler provide a basic implementation that doesn't go beyond the functionality provided by an EOGenericRecord. But you can use the files as a basis for adding behavior to your enterprise object.<p></a><a name="1095">One kind of behavior you might want to add to your enterprise object class is the ability to apply a filter to an object's to-many relationship property and return a subset of the destination objects. For example, you could have an <strong>overdueRentals</strong> method in the Customer class that returns the subset of a customer's rentals that are overdue:<p></a><a name="9782">In Java:<p></a><pre><a name="9821">public NSArray overdueRentals() {<br>	EOQualifier qualifier;<br><br>	qualifier = new EOKeyValueQualifier(<br>		"isOverdue",<br>		EOQualifier.QualifierOperatorEqual,<br>		new Boolean(true));<br><br>	return EOQualifier.filteredArrayWithQualifier(<br>		allRentals(),<br>		qualifier);<br>}</a></pre><a name="9786">In Objective-C:<p></a><pre><a name="11726">- (NSArray *)overdueRentals {<br>	EOQualifier *qualifier;<br><br>	qualifier = [[[EOKeyValueQualifier alloc]<br>		initWithKey:@"isOverdue"<br>		operatorSelector:EOQualifierOperatorEqual<br>		value:[NSNumber numberWithBool:YES]autorelease];<br><br>	return [[self allRentals]<br>		filteredArrayUsingQualifier:qualifier];<br>}</a></pre><a name="11664">The <strong>overdueRentals</strong> method creates a qualifier to find all of a customer's overdue rentals. The qualifier is performed in memory against the complete set of a customer's rentals.<p></a><a name="9826">With the addition of this method, Customer has a "get" accessor method with no corresponding "set" method. A <strong>setOverdueRentals</strong> method doesn't make sense because <strong>overdueRentals</strong> is derived. However, since Enterprise Objects Framework invokes accessor methods automatically, you may wonder if the absence of a <strong>setOverdueRentals</strong> method can cause problems. The answer is no, you don't have to define a corresponding set method. Enterprise Objects Framework will not attempt to invoke <strong>setOverdueRentals</strong> unless you bind the <strong>overdueRentals</strong> property to an editable user interface object. <p></a><a name="9884"><h2> Performing Validation</h2></a><a name="9912">A good part of your application's business logic is usually validation-for example, verifying that customers don't exceed their credit limits, that return dates don't come before their corresponding check out dates, and so on. In your enterprise object classes, you implement methods that check for invalid data, and the framework automatically invokes them before saving anything to the database.<p></a><a name="10632">The EOValidation interface (informal protocol in Objective-C) defines the way that enterprise objects validate their values. The validation methods can check for illegal value types, values outside of established limits, illegal relationships, and so on. Like EOKeyValueCoding, EOValidation is incorporated in the EOEnterpriseObject interface, so your custom classes automatically inherit some basic validation behavior. The default implementations of these methods check the object's state against constraints and rules defined in your model.<p></a><a name="10764">There are two kinds of validation methods. The first validates an entire object to see if it's ready for a specific operation (inserting, updating, and deleting) and the second validates individual properties. The two different types are discussed in more detail in the following sections. For more a more detailed discussion, see the EOValidation interface specification in the <em>Enterprise Objects Framework Reference</em>.<p></a><a name="10689"><h3> Validating Before an Operation</h3></a><a name="10712">The methods for validating an object before a specific operation are:<p></a><ul><a name="10690"><li>	validateForSave</a><a name="10691"><li>	validateForDelete</a><a name="10692"><li>	validateForInsert</a><a name="10693"><li>	validateForUpdate</a></ul><a name="10694">When you perform a particular operation on an enterprise object (such as attempting to delete it), the EOEditingContext sends a validation message to your enterprise object appropriate to the operation. Based on the result, the operation is either accepted or refused. For example, referential integrity constraints in your model might state that you can't delete a Customer object that has Rentals. If a user attempts to delete a customer that has rentals, the deletion is refused.<p></a><a name="10695">You might want to override these methods to perform additional validation to what can be specified in a model. For example, your application should never allow a fee to be deleted if it hasn't been paid. You could implement this in a Fee class as follows:<p></a><a name="10696">In Java:<p></a><pre><a name="11756">public void validateForDelete() throws EOValidation.Exception<br>{<br>	EOValidation.Exception superException = null;<br>	EOValidation.Exception myException = null;<br><br>	try {<br>		super.validateForDelete()<br>	} catch (EOValidation.Exception s) {<br>		superException = s;<br>	}<br><br>	if (!isPaid())<br>		myException = new EOValidation.Exception(<br>			"You can't remove an unpaid fee.");<br><br>	if (superException &amp;&amp; myException) {<br>		NSMutableArray exceptions = new NSMutableArray();<br>		exceptions.addObject(superException);<br>		exceptions.addObject(myException);<br>		throw<br>			EOValidation.Exception.aggregateExceptionWithExceptions(<br>				exceptions);<br>	} else if (superException) {<br>		throw(superException);<br>	} else if (myException) {<br>		throw(myException);<br>	}<br>}</a></pre><a name="10698">In Objective-C:<p></a><pre><a name="10699">- (NSException *)validateForDelete<br>{<br>	NSException *superException = [super validateForSave];<br>	NSException *myException = nil;<br><br>	if (![self isPaid])<br>		myException = [NSException validationExceptionWithFormat:<br>			@"You can't remove an unpaid fee."];<br><br>	if (superException &amp;&amp; myException) {<br>		return [NSException aggregateExceptionWithExceptions:<br>			[NSArray arrayWithObjects:<br>			superException, myException, nil];<br>	} else if (superException) {<br>		return superException;<br>	} else if (myException) {<br>		return myException)<br>	}<br><br>	return nil;<br>}</a></pre><a name="10700">The default implementation of <strong>validateForDelete</strong> inherited by your custom classes performs basic checking based on referential integrity rules specified in your model. Your custom classes should therefore invoke super's implementation before performing their own validation as and should combine any exception thrown by super's implementation with their own as shown above.<p></a><a name="10701">Note that the Java and Objective-C validation methods work slightly differently. The Java methods throw exceptions to indicate a validation failure whereas the Objective-C methods create and return exceptions for the Framework to raise.<p></a><a name="10702">The advantage of using one of the <strong>validateFor...</strong> methods is that they allow you to perform both "inter-" and "intra-" object validation before a particular operation occurs. This is useful if you have an enterprise object whose properties have interdependencies. For example, if you're saving rental data, you might want to confirm that the check out date precedes the return date before committing the changes. <p></a><a name="10623"><h3> Validating Individual Properties</h3></a><a name="10715">EOValidation defines a fifth method for validating individual properties: <strong>validateValueForKey</strong> (<strong>validateValue:forKey:</strong> in Objective-C). It's like the key-value coding methods in that it validates properties by name (or <em>key</em>). The default implementation of <strong>validateValueForKey</strong> that your custom classes inherit searches for a method of the form <strong>validate</strong>Key and invokes it if it exists. These are the methods that your custom classes can implement to validate individual properties. For example, the Customer class might have a <strong>validateStreetAddress</strong> method:<p></a><a name="10453">In Java:<p></a><pre><a name="10510">public void validateStreetAddress(String address)<br>	throws EOValidation.Exception<br>{<br>	if (/** address is invalid */)<br>		throw new EOValidation.Exception("Invalid address.");<br>}</a></pre><a name="10449">In Objective-C:<p></a><pre><a name="10447">- (NSException *)validateStreetAddress:(NSString *)address<br>{<br>	if (/* address is invalid...*/)<br>		return [NSException validationExceptionWithFormat:<br>			@"Invalid address."];<br><br>	return nil;<br>}</a></pre><a name="6092">If a user tries to assign a value to <strong>streetAddress</strong>, the default implementation of <strong>validateValueForKey </strong>invokes the <strong>validateStreetAddress</strong> method. Based on the result, the operation is either accepted or refused.<p></a><a name="10739">Prior to invoking your validateKey methods, the default implementation of <strong>validateValueForKey</strong> validates the property against constraints specified in your model (such as NULL constraints).<p></a><a name="11673">Note that the default implementations of <strong>validateForSave</strong>, <strong>validateForInsert</strong>, and <strong>validateForUpdate</strong> provided by EOCustomObject (NSObject in Objective-C) invoke <strong>validateValueForKey</strong> for each of an object's class properties.<p></a><a name="1189"><h3> Validating User Input</h3></a><a name="4908">Besides putting validation in a model and in an enterprise object class, you can also put validation in the user interface. The way that validation is normally added to the user interface is through formatters, which perform data type and formatting validation when users enter values.<p></a><a name="10771">Additionally, you can design your Application Kit and Java client applications so that the validation in your enterprise objects is performed as soon as a user attempts to leave an editable field in the user interface. There are two steps to doing this:<p></a><ol><a name="1191"><P><li>In Interface Builder, display the Attributes view of the EODisplayGroup Inspector and check "Validate immediately".</a><a name="1197"><P><li>In your enterprise object class, implement <strong>validate</strong>Property<strong> </strong>to check the value of the key for which the user is entering a value. For example, if the key is <strong>salary</strong>, you'd implement the method <strong>validateSalary</strong>.</a></ol><a name="1198">If <strong>validateSalary</strong> fails (that is, if the salary value isn't within acceptable bounds), the user is forced to correct the value before being allowed to leave the field.<p></a><a name="11679">Note that in this scenario, <strong>validateValueForKey</strong> is invoked with values directly from the user interface. When <strong>validateValueForKey</strong> is invoked from <strong>validateForSave</strong>, <strong>validateForInsert</strong>, or <strong>validateForUpdate</strong>, it's invoked with values that are already in the object.<p></a><a name="1162"><h2> Creating and Inserting Objects</h2></a><a name="1176">In an Enterprise Objects Framework application, when new enterprise objects are inserted into the database, it's often through a display group-either an EODisplayGroup for Application Kit and Java client applications or a WODisplayGroup for WebObjects applications (assuming the application has a graphical user interface). However, it's also common to create and insert an enterprise object programmatically-either because your application doesn't have a graphical user interface, or because you're creating and inserting objects as the by-product of another operation.<p></a><a name="1178">To create an instance of a custom Java enterprise object class, you invoke a constructor of the following form:<p></a><pre><a name="10808">public MyCustomEO (<br>	EOEditingContext &#32;anEOEditingContext,<br>	EOClassDescription &#32;anEOClassDescription,<br>	EOGlobalID &#32;anEOGlobalID)</a></pre><a name="10809">Typically you invoke this constructor with <strong>null</strong> arguments as follows:<p></a><pre><a name="11807">rental = new MyCustomEO(null, null, null);</a></pre><a name="11689">You can provide real values, but most enterprise object classes don't make use of the arguments. The only common exception to this is EOGenericRecord, which requires the arguments to identify the object's class description. EOGenericRecord is handled in a different way, as described later in this section.<p></a><a name="11812">In Objective-C, you use <strong>alloc</strong> and <strong>init</strong> like you would with any other object, so you don't have to worry about providing arguments.<p></a><a name="11813">Once you create an object, you insert it into an EOEditingContext using EOEditingContext's <strong>insertObject </strong>method (<strong>insertObject:</strong> in Objective-C). For example, the following code excerpts for the Customer class create Fee and Rental enterprise objects as the by-product of a customer renting a unit at a video store. Once the objects have been created, they're inserted into the current enterprise object's EOEditingContext.<p></a><a name="10918">In Java:<p></a><pre><a name="10939">public void rentUnit(Unit unit)<br>{<br>	EOEditingContext ec;<br>	Fee fee;<br>	Rental rental;<br><br>	ec = editingContext();<br><br>	// Create new objects and insert them into the editing context<br>	fee = new Fee(null, null, null);<br>	ec.insertObject(fee);<br>	rental = new Rental(null, null, null);<br>	ec.insertObject(rental);<br><br>	// Manipulate relationships<br>	rental addObjectToBothSidesOfRelationshipWithKey(fee, "fees");<br>	rental.addObjectToBothSidesOfRelationshipWithKey(unit, "unit");<br>	addObjectToBothSidesOfRelationshipWithKey(rental, "rentals");<br>}</a></pre><a name="10922">In Objective-C:<p></a><pre><a name="12191">- (void)rentUnit:(Unit *)unit<br>{<br>	EOEditingContext *ec;<br>	Fee *fee;<br>	Rental *rental;<br><br>	ec = [self editingContext];<br><br>	// Create new objects and insert them into the editing context<br>	fee = [[[Fee alloc] init] autorelease];<br>	[ec insertObject:fee];<br>	rental = [[[Rental alloc] init] autorelease];<br>	[ec insertObject:rental];<br><br>	[rental addObject:fee<br>		toBothSidesOfRelationshipWithKey:@"fees"];<br>	[rental addObject:unit<br>		toBothSidesOfRelationshipWithKey:@"unit"];<br><br>	[self addObject:rental<br>		toBothSidesOfRelationshipWithKey:@"rentals"];<br>}</a></pre><a name="11684">EOEditingContext's <strong>insertObject</strong> method has the effect of registering the specified enterprise object with the editing context. In other words, it registers the object to be inserted in the database the next time the editing context saves changes. Inserting a new object into an editing context also has the side effect of further initializing the object, so you should always insert new objects into an editing context before modifying them (such as by manipulating their relationships). For more information, see the section<a href="EOsI3.html#842"> "Setting Defaults for New Enterprise Objects"</a>.<p></a><a name="12235">You create an instances of EOGenericRecord differently from the way you create custom objects: To create a generic record, use EOClassDescription's <strong>createInstanceWithEditingContext</strong> method (<strong>createInstanceWithEditingContext:globalID:zone:</strong> in Objective-C) as follows:<p></a><a name="12238">In Java:<p></a><pre><a name="12239">String entityName; // Assume this exists.<br>EOEditingContext editingContext; // Assume this exists.<br>EOClassDescription classDescription;<br>EOEnterpriseObject eo;<br><br>classDescription = EOClassDescription.classDescriptionForEntityName(entityName);<br><br>eo = classDescription.createInstanceWithEditingContext(<br>		editingContext, null);<br><br>if (eo) editingContext.insertObject(eo);</a></pre><a name="12240">In Objective-C:<p></a><pre><a name="12241">NSString *entityName; // Assume this exists.<br>EOEditingContext *editingContext; // Assume this exists.<br>EOClassDescription classDescription;<br>id eo;<br><br>classDescription = [EOClassDescription<br>		classDescriptionForEntityName:entityName];<br>eo = [classDescription<br>		createInstanceWithEditingContext:editingContext<br>		globalID:nil<br>		zone:[editingContext zone]];<br><br>if (eo) [editingContext insertObject:eo];</a></pre><a name="12242">The EOClassDescription method createInstanceWithEditingContext is preferable to using an EOGenericRecord constructor (or to using EOGenericRecord's <strong>init...</strong> method in Objective-C) because the same code works if you later use a custom enterprise object class instead of EOGenericRecord. Strictly speaking, it's better to use EOClassDescription's <strong>createInstanceWithEditingContext</strong> for all types of enterprise objects-EOGenericRecords as well as your custom classes. The createInstanceWithEditingContext method is the most general way to create an enterprise object-it works regardless of whether the object is represented by a custom class or an EOGenericRecord.<p></a><a name="1170"><h3> Working with Relationships</h3></a><a name="326">In the code excerpt shown in the preceding section, notice that before the objects are inserted into the EOEditingContext, the method <strong>addObjectToBothSidesOfRelationshipWithKey</strong> (<strong>addObject:toBothSidesOfRelationshipWithKey:</strong> in Objective-C) is used. This method is part of the EORelationshipManipulation interface (informal protocol in Objective-C). EORelationshipManipulation provides methods for manipulating an enterprise object's relationship properties. It is a part of the EOEnterpriseObject interface, and so your custom classes inherit a default implementation from EOCustomObject (or NSObject in Objective-C).<p></a><a name="749"><strong>addObjectToBothSidesOfRelationshipWithKey</strong> is used to manage reciprocal relationships, in which the destination entity of a relationship has a back reference to the source. For example, Fee and Unit both have back references to Rental, and Rental has a back reference to Customer. In other words, not only does the model define a relationship from Customer to Fee and Rental, it also defines a relationship from Rental back to Customer and from Fee to Rental. When you insert an object into a relationship (such as adding a new Rental object to Customer's <strong>rentals</strong> relationship property, which is an NSArray) <em>and</em> the inserted object has a back reference to the enterprise object, you need to be sure to add the object to both sides of the relationship. Otherwise, your object graph will get out of sync-your Customer object's <strong>rentals</strong> array will contain the Rental object, but the Rental object won't know the Customer who rented it.<p></a><a name="352">You can update object references explicitly-that is, you can directly update the Rental object's <strong>customer</strong> property, which represents its relationship to the Customer object. But it's simpler to just use <strong>addObjectToBothSidesOfRelationshipWithKey</strong>. This method is safe to use regardless of whether the source relationship is to-one or to-many, whether the reciprocal relationship is to-one or to-many, or whether the relationship is reciprocal at all.<p></a><a name="5528">You should observe the following guidelines in working with relationships:<p></a><ul><a name="6372"><p><li>For non-reciprocal relationships, you can just use your class's regular accessor methods. These methods have the form <strong>addTo</strong>Property (<strong>addTo</strong>Property<strong>:</strong> in Objective-C) where <em>Property</em> is a relationship array.</a><a name="5535"><p><li>When in doubt, use the method <strong>addObjectToBothSidesOfRelationshipWithKey</strong>. This method works for reciprocal and non-reciprocal relationships alike, and it's the safest choice if you don't know ahead of time what objects your code will be working with-for example, if you're providing a framework to be used by others.</a><a name="5536"><p><li>If you're working with reciprocal relationships and you do know the objects you'll be working with ahead of time, the best choice is to implement custom accessor methods in your enterprise object class to handle the reciprocal relationships. Custom accessor methods are preferable to <strong>addObjectToBothSidesOfRelationshipWithKey</strong> simply because they provide type checking.</a></ul><a name="1194">In addition to the <strong>addObjectToBothSidesOfRelationshipWithKey</strong> method, EORelationshipManipulation defines the following methods:<p></a><ul><a name="11212"><li>addObjectToPropertyWithKey</a><a name="11217"><li>removeObjectFromPropertyWithKey</a><a name="11222"><li>removeObjectFromBothSidesOfRelationshipWithKey</a></ul><a name="1212">The method <strong>addObjectToPropertyWithKey</strong> (<strong>addObject:toPropertyWithKey:</strong> in Objective-C) adds a specified object to the relationship property (an NSArray) with the specified name (key). This method is the primitive used by <strong>addObjectToBothSidesOfRelationshipWithKey</strong>. The default implementation uses the class definition as follows:<p></a><ol><a name="11209"><P><li>If this method is passed the key <strong>projects</strong>, for example, the default implementation looks for a method with the name <strong>addToProjects</strong>. </a><a name="1215"><P><li>If the <strong>addToProjects</strong> method isn't found, <strong>addObjectToPropertyWithKey</strong> looks for a property called <strong>projects</strong>. If it finds it, it adds the argument to the array (assuming the array is mutable). If the array is immutable, it creates a new version of the array that includes the new element.</a><a name="1216"><P><li>If the property is <strong>null</strong> (<strong>nil</strong> in Objective-C), a new empty array is created and assigned to the object.</a></ol><a name="1219">The method <strong>removeObjectFromPropertyWithKey</strong> (<strong>removeObject:fromPropertyWithKey:</strong> in Objective-C) removes a specified object from the relationship property (an NSArray) with the specified name (key).<p></a><a name="1220">This method follows the same pattern as <strong>addObjectToPropertyWithKey</strong>. That is, it looks for a selector of the form <strong>removeFromProjects</strong>, and then for a property called <strong>projects</strong>. If neither of these can be found, it throws an exception. If it finds the property but it doesn't contain the specified object, this method simply returns.<p></a><a name="1225">The method <strong>removeObjectFromBothSidesOfRelationshipWithKey</strong> (<strong>removeObject:fromBothSidesOfRelationshipWithKey:</strong> in Objective-C) removes a specified object from both sides of a relationship property with the specified name. Like <strong>addObjectToBothSidesOfRelationshipWithKey</strong>, this method is safe to use regardless of whether the source relationship is to-one or to-many, or whether the reciprocal relationship is to-one or to-many. 	<p></a><a name="842"><h2> Setting Defaults for New Enterprise Objects </h2></a><a name="1106">When new objects are created in your application and inserted into the database, it's common to assign default values to some of their properties. For example, the Member class has a <strong>memberSince</strong> property. It's likely that you would assign that property a value when you create and insert a new object instead of forcing the user to supply a value for it. <p></a><a name="1109">To assign default values to newly created enterprise objects, you use the method <strong>awakeFromInsertionInEditingContext</strong> (<strong>awakeFromInsertionInEditingContext:</strong> in Objective-C). This method is automatically invoked immediately after your enterprise object class creates a new object and inserts it into the EOEditingContext. <p></a><a name="807">The following implementation of <strong>awakeFromInsertion</strong> in the Member class sets the current date as the value of the <strong>memberSince</strong> property:<p></a><a name="11280">In Java:<p></a><pre><a name="11340">public void awakeFromInsertion(EOEditingContext ec)<br>{<br>	super.awakeFromInsertion(ec);<br>	// Assign current date to memberSince<br>	if (memberSince == null) <br>		memberSince = new NSGregorianDate();<br>}</a></pre><a name="11288">In Objective-C:<p></a><pre><a name="1112">- (void)<br>awakeFromInsertionInEditingContext:(EOEditingContext *)ec<br>{<br>	[super awakeFromInsertionInEditingContext:ec];<br>	// Assign current date to memberSince<br>	if (!memberSince) <br>		memberSince = [[NSCalendarDate date] retain];<br>}</a></pre><a name="11370">You use the <strong>awakeFromInsertion</strong> method to set default values for enterprise objects that represent new data. For enterprise objects that represent existing data, the Enterprise Objects Framework provides the method <strong>awakeFromFetch</strong> (<strong>awakeFromFetchInEditingContext:</strong> in Objective-C), which is sent to an enterprise object that has just been created from a database row and initialized with database values. Your enterprise objects can implement this method to provide additional initialization. Because the Framework is still busy fetching when an enterprise object receives <strong>awakeFromFetch</strong>, the object must be careful about sending messages to other enterprise objects that might need to be <em>faulted</em> in. For more information about faulting, see the chapter "Behind the Scenes" and the EOFaulting interface specification in the <em>Enterprise Objects Framework Reference</em>.<p></a><a name="11380"><h3> Initializing Enterprise Objects</h3></a><a name="11416">Since all of an enterprise object's class property values are assigned through the key-value coding methods, no special initialization is usually needed in your constructors (or <strong>init...</strong> methods in Objective-C). Specifically, you don't generally assign default values to your enterprise objects in constructors since it is invoked to create instances of your class being fetched from the database. Any values you assign in a constructor will be overwritten by the values fetched from the database.<p></a><a name="11422">However you can take advantage of extra information available at the time your enterprise object is initialized. In Java, instances of custom classes must provide a constructor of the following form:<p></a><pre><a name="11432">public MyCustomEO (<br>	EOEditingContext &#32;anEOEditingContext,<br>	EOClassDescription &#32;anEOClassDescription,<br>	EOGlobalID &#32;anEOGlobalID)</a></pre><a name="11428">The Framework uses such a constructor to create your objects, so you can use the provided arguments to influence the creation. In Objective-C, enterprise objects can be created with either <strong>init</strong> or <strong>initWithEditingContext:classDescription:globalID:</strong>. If an enterprise object implements the <strong>initWithEditingContext:classDescription:globalID:</strong> method, the Framework uses this method instead of <strong>init</strong>, allowing the object to affect its creation based on the data provided.<p></a><a name="11418"><h2> Writing Business Logic</h2></a><a name="11419">So far the examples in this chapter have focused on working with your enterprise objects in fairly simple ways: creating them, accessing their data, modifying them, and validating changes before you save them to the database. But enterprise object classes can also implement more sophisticated business logic. For example, suppose you need a pay method in your Fee class that sets the fee's <strong>datePaid</strong> property and also notifies the fee's rental that the fee has been paid. You could implement this as follows:<p></a><a name="11560">In Java:<p></a><pre><a name="11597">public void pay()<br>{<br>	setDatePaid(new NSGregorianDate());<br><br>	// Notify the rental that this fee has been paid.<br>	rental.feePaid();<br>}</a></pre><a name="11561">In Objective-C:<p></a><pre><a name="1157">- (void)pay<br>{<br>	[self setDatePaid:[[NSCalendarDate calendarDate] retain];<br><br>	// Notify the rental that this fee has been paid.<br>	[rental feePaid];<br>}</a></pre><a name="839">When you implement a method such as this in your enterprise object class, you don't have to be concerned with registering the changes or updating the values displayed in the user interface. An Enterprise Objects Framework application revolves around the graph of enterprise objects, and the Framework assumes responsibility for making sure that all parts of your application are notified when an object's value changes. Thus, all parts of your application have the same view of the data and remain in sync. <p></a><P> <a href="EOsI.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="EOsI4.html"><IMG SRC="ArrowRight.gif">Next Section</a><P></body></html>