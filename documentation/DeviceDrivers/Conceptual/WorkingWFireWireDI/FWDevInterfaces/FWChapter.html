<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>FireWire Device Interface Guide: Using the FireWire Device Interface Libraries</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Using the FireWire Device Interface Libraries"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40000969-CH203" title="Using the FireWire Device Interface Libraries"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/FireWire-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30000511" target="_top">FireWire</a> &gt; <a href="../FWDevIntro/FWDevintro.html#//apple_ref/doc/uid/TP40000969-CH205-BABGJCGG">FireWire Device Interface Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../FWDevAccess/FWDevAccess.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../FWDevEndianness/FWDevEndianness.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40000969-CH203-TPXREF101" title="Using the FireWire Device Interface Libraries"></a><h1>Using the FireWire Device Interface Libraries</h1><p>This chapter uses sample code from the FireWire SDK to illustrate how to use the FireWire device interface libraries. (The latest version of the SDK is available for download at <span class="content_text"><a href="http://developer.apple.com/hardwaredrivers/download" target="_top">http://developer.apple.com/hardwaredrivers/download</a></span>.) The first section, <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHHBDGD">“Using the IOFireWireLib,”</a></span> describes two sample projects. The first sets up isochronous communication with a device and the second sets up a pseudo-address space in the Macintosh to handle FireWire packets. The second section, <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHJJDAE">“Using the IOFireWireSBP2Lib,”</a></span> presents a sample project that creates a user-space driver to access an SBP-2 device. Finally, <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHDEBJH">“Using the IOFireWireAVCLib”</a></span> describes a project that accesses an AV/C unit with the IOFireWireAVCLib interfaces.</p><p>The code samples in this chapter omit most of the steps required to create matching dictionaries, search the I/O Registry, and get device interfaces. For code samples that show how to perform these tasks, see <span class="content_text"><a href="../FWDevAccess/FWDevAccess.html#//apple_ref/doc/uid/TP40000969-CH202-TPXREF101">“Accessing FireWire Devices From Applications”</a></span> or the code projects in the FireWire SDK.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHHBDGD" title="Using the IOFireWireLib"></a><h2>Using the IOFireWireLib</h2><p>The IOFireWireLib provides the lowest level interfaces available to communicate directly with a FireWire device from an application. It also provides interfaces to set up isochronous communication with a FireWire device. </p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHEICCB" title="Setting Up Isochronous Communication"></a><h3>Setting Up Isochronous Communication</h3><p>Isochronous communication takes place on channels that can each have at most one talker and any number of listeners. The IOFireWire family abstracts these concepts into channel objects and port objects. Channel objects correspond to FireWire bus channels and port objects are either remote or local and correspond to either talkers or listeners. Remote ports correspond to external devices and have methods you can override to support your device. The local port corresponds to the Macintosh and does not have methods you can override. You use these objects in your application to map out the flow of isochronous communication before any actual data transfer begins.</p><p>To manage the isochronous data your device sends and receives, you create a datastream control language (or DCL) program. The DCL program is a linked list of DCL commands that specify where to place each received packet and where to find the data to send. A DCL program can run both linearly, from beginning to end, and nonlinearly, by jumping from one command to another. You can even set up a DCL program to modify its jumps during execution, creating a dynamically changeable program. The IOFireWire family makes writing DCL programs easier by providing a function that allows you to create a pool of DCL command objects ready for use and functions that fill in DCL command objects with your parameters.</p><p>The IOFireWireLibIsochTest project creates a remote port and a local port, allocates an isochronous channel, sets up the remote port as a listener and the local port as the talker, and then starts the channel. The program includes a simple DCL program that manages the packets. IOFireWireLibIsochTest matches on the local node (the Macintosh itself) so you can run it even if no external FireWire devices are currently plugged in.</p><p>To begin with, the IOFireWireLibIsochTest project acquires a Mach port, creates a matching dictionary for the local node, and gets an IOFireWireDeviceInterface object for it. These steps closely follow those described in <span class="content_text"><a href="../FWDevAccess/FWDevAccess.html#//apple_ref/doc/uid/TP40000969-CH202-CCHCIBDB">“Finding FireWire Devices”</a></span> so this section does not repeat them.</p><p>The code fragments and listings in this section use the variables in <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHJGAFD">Listing 3-1</a></span>.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHJGAFD" title="Listing 3-1Variable definitions for IOFireWireLibIsochTest"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>Variable definitions for IOFireWireLibIsochTest</p><div class="codesample"><table><tr><td scope="row"><pre>//global declarations<span></span></pre></td></tr><tr><td scope="row"><pre>IOFireWireLibDCLCommandPoolRef  gCommandPool;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt8                           gBuf[1024];<span></span></pre></td></tr><tr><td scope="row"><pre>UInt8                           gBuf2[1024];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//local declarations in the main function<span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn                        result;<span></span></pre></td></tr><tr><td scope="row"><pre>IOFireWireLibNubRef             localNode;<span></span></pre></td></tr><tr><td scope="row"><pre>IOFireWireLibLocalIsochPortRef  localIsochPort;<span></span></pre></td></tr><tr><td scope="row"><pre>IOFireWireLibRemoteIsochPortRef remoteIsochPort;<span></span></pre></td></tr><tr><td scope="row"><pre>IOFireWireLibIsochChannelRef    isochChannel;<span></span></pre></td></tr></table></div><p>To exclusively open the device (in this case, the Macintosh), IOFireWireLibIsochTest <code>main</code> function calls the IOFireWireLibDeviceInterface function <code>open</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>result = (*localNode)->Open( localNode );<span></span></pre></td></tr></table></div><p>Next, it creates a pool of DCL command structures. The function <code>CreateDCLCommandPool</code> calls the IOFireWireLibDeviceInterface function of the same name, creating a DCL command pool object and returning an interface to it that the program can use to build a DCL program. <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHDJEJC">Listing 3-2</a></span> shows the function call followed by the function definition, excluding error checking.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHDJEJC" title="Listing 3-2Creating a DCL command pool"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>Creating a DCL command pool</p><div class="codesample"><table><tr><td scope="row"><pre>//Call to CreateDCLCommandPool from main.<span></span></pre></td></tr><tr><td scope="row"><pre>result = CreateDCLCommandPool( localNode, &amp;gCommandPool );<span></span></pre></td></tr><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre>//CreateDCLCommandPool function.<span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn CreateDCLCommandPool( IOFireWireLibNubRef inNub,<span></span></pre></td></tr><tr><td scope="row"><pre>    IOFireWireLibDCLCommandPoolRef* outCommandPool ) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Create a DCL command pool.<span></span></pre></td></tr><tr><td scope="row"><pre>    *outCommandPool = (*inNub)->CreateDCLCommandPool( inNub, 0x1000,<span></span></pre></td></tr><tr><td scope="row"><pre>        CFUUIDGetUUIDBytes( kIOFireWireDCLCommandPoolInterfaceID ) );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Before it can start the isochronous channel, the IOFireWireLibIsochTest <code>main</code> function first creates the remote and local port objects and an isochronous channel object. The IOFireWireLib contains interfaces for each of these objects that provide functions to manage them.</p><p><span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHHAACI">Listing 3-3</a></span> shows the <code>CreateRemoteIsochPort</code> function (along with its call from <code>main</code>) which includes a number of callback functions you can override to provide device-specific functions, such as how to start and stop the port and which channels your device supports.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHHAACI" title="Listing 3-3Creating a remote isochronous port"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>Creating a remote isochronous port</p><div class="codesample"><table><tr><td scope="row"><pre>//Call to CreateRemoteIsochPort from main.<span></span></pre></td></tr><tr><td scope="row"><pre>result = CreateRemoteIsochPort( localNode, &amp;remoteIsochPort );<span></span></pre></td></tr><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre>//CreateRemoteIsochPort function.<span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn CreateRemoteIsochPort( IOFireWireLibNubRef inNub,<span></span></pre></td></tr><tr><td scope="row"><pre>    IOFireWireLibRemoteIsochPortRef* outPort ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOFireWireLibRemoteIsochPortRef port;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Call the IOFireWireDeviceInterface function CreateRemoteIsochPort to<span></span></pre></td></tr><tr><td scope="row"><pre>    //create a remote port object and return an interface to it. The "false"<span></span></pre></td></tr><tr><td scope="row"><pre>    //parameter indicates that this port will not be a talker.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    port = (*inNub)->CreateRemoteIsochPort( inNub, false, CFUUIDGetUUIDBytes<span></span></pre></td></tr><tr><td scope="row"><pre>                                (kIOFireWireRemoteIsochPortInterfaceID ) );<span></span></pre></td></tr><tr><td scope="row"><pre>    (*port)->SetGetSupportedHandler( port, &amp;RemotePort_GetSupported );<span></span></pre></td></tr><tr><td scope="row"><pre>    (*port)->SetAllocatePortHandler( port, &amp;RemotePort_AllocatePort );<span></span></pre></td></tr><tr><td scope="row"><pre>    (*port)->SetReleasePortHandler( port, &amp;RemotePort_ReleasePort );<span></span></pre></td></tr><tr><td scope="row"><pre>    (*port)->SetStartHandler( port, &amp;RemotePort_Start );<span></span></pre></td></tr><tr><td scope="row"><pre>    (*port)->SetStopHandler( port, &amp;RemotePort_Stop );<span></span></pre></td></tr><tr><td scope="row"><pre>    *outPort = port;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In IOFireWireLibIsochTest, the <code>RemotePort_GetSupported</code> function indicates that it supports all channels and the remaining callback functions simply print messages. You should add your own code to these callback functions to support your device.</p><p>To create the local isochronous port, the IOFireWireLibIsochTest <code>main</code> function calls the function <code>CreateLocalIsochPort</code>. This function uses the IOFireWireDeviceInterface function of the same name to create a local isochronous port object with a particular DCL program and return an interface to it. <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHCJDCB">Listing 3-4</a></span> shows the <code>CreateLocalIsochPort</code> function, along with its call from <code>main</code>.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHCJDCB" title="Listing 3-4Creating a local isochronous port"></a><p class="codesample"><strong>Listing 3-4&nbsp;&nbsp;</strong>Creating a local isochronous port</p><div class="codesample"><table><tr><td scope="row"><pre>//Call to CreateLocalIsochPort from main.<span></span></pre></td></tr><tr><td scope="row"><pre>result = CreateLocalIsochPort( localNode, &amp;localIsochPort );<span></span></pre></td></tr><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre>//CreateLocalIsochPort function.<span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn CreateLocalIsochPort( IOFireWireLibNubRef inNub,<span></span></pre></td></tr><tr><td scope="row"><pre>    IOFireWireLibLocalIsochPortRef* outPort ) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Set the pointer dclProgram to a simple DCL program created in<span></span></pre></td></tr><tr><td scope="row"><pre>    //the IOFireWireLibIsochTest function WriteTalkingDCLProgram (not shown).<span></span></pre></td></tr><tr><td scope="row"><pre>    DCLCommandStruct*   dclProgram = WriteTalkingDCLProgram();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Use the IOFireWireDeviceInterface function PrintDCLProgram<span></span></pre></td></tr><tr><td scope="row"><pre>    //to print the contents of the DCL program.<span></span></pre></td></tr><tr><td scope="row"><pre>    (*inNub)->PrintDCLProgram( inNub, dclProgram, 6 );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Create a local isochronous port object and return an interface<span></span></pre></td></tr><tr><td scope="row"><pre>    //for it. The "true" parameter indicates that this port will be a talker.<span></span></pre></td></tr><tr><td scope="row"><pre>    *outPort = (*inNub)->CreateLocalIsochPort( inNub, true, dclProgram, 0, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>        0, nil, 0, nil, 0, CFUUIDGetUUIDBytes(<span></span></pre></td></tr><tr><td scope="row"><pre>        kIOFireWireLocalIsochPortInterfaceID ) );<span></span></pre></td></tr><tr><td scope="row"><pre>    return *outPort;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Now the IOFireWireLibIsochTest <code>main</code> function uses channel interface functions to set up isochronous communication. First, it designates the remote port as a listener and the local port as the talker:</p><div class="codesample"><table><tr><td scope="row"><pre>result = (*isochChannel)->AddListener( isochChannel,<span></span></pre></td></tr><tr><td scope="row"><pre>    (IOFireWireLibIsochPortRef) remoteIsochPort );<span></span></pre></td></tr><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre>result = (*isochChannel)->SetTalker( isochChannel,<span></span></pre></td></tr><tr><td scope="row"><pre>    (IOFireWireLibIsochPortRef) localIsochPort );<span></span></pre></td></tr></table></div><p>Then, it uses another channel interface function to allocate the channel:</p><div class="codesample"><table><tr><td scope="row"><pre>result = (*isochChannel)->AllocateChannel( isochChannel );<span></span></pre></td></tr></table></div><p>The channel interface function <code>AllocateChannel</code> calls the <code>GetSupported</code> methods on all the ports to find out which channels they support, reconciles the answers, and requests a particular channel and bandwidth from the FireWire bus.</p><p>After the channel is allocated, the IOFireWireLibIsochTest <code>main</code> function calls the channel interface <code>Start</code> function which calls the <code>Start</code> functions on all the ports:</p><div class="codesample"><table><tr><td scope="row"><pre>result = (*isochChannel)->Start( isochChannel );<span></span></pre></td></tr></table></div><p>To make sure the callbacks get called, the <code>main</code> function then calls an IOFireWireDeviceInterface function to add the isochronous callback dispatcher to the program’s run loop:</p><div class="codesample"><table><tr><td scope="row"><pre>(*localNode)->AddIsochCallbackDispatcherToRunLoop( localNode,<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopGetCurrent() );<span></span></pre></td></tr></table></div><p>For the purposes of testing, the <code>main</code> function calls the Core Foundation function <code>CFRunLoopRunInMode</code> to run the run loop and trigger the callback functions for 15 seconds. After that time, the <code>main</code> function then calls the channel interface <code>Stop</code> function which calls the <code>_Stop</code> functions on all the ports:</p><div class="codesample"><table><tr><td scope="row"><pre>result = (*isochChannel)->Stop( isochChannel );<span></span></pre></td></tr></table></div><p>Finally, the IOFireWireLibIsochTest <code>main</code> function releases the interfaces it acquired. It first releases the isochronous channel object with the channel interface function <code>ReleaseChannel</code> and then it uses the IOCFPlugInInterface function <code>Release</code> to release the interface itself:</p><div class="codesample"><table><tr><td scope="row"><pre>result = (*isochChannel)->ReleaseChannel( isochChannel );<span></span></pre></td></tr><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre>(*isochChannel)->Release( isochChannel );<span></span></pre></td></tr></table></div><p>The <code>main</code> function similarly releases the local and remote port interfaces, then calls the IOFireWireDeviceInterface function <code>Close</code> on the local node before releasing its interface, and releases the original CFPlugInInterface:</p><div class="codesample"><table><tr><td scope="row"><pre>IODestroyPlugInInterface( gCFPlugInInterface );<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHIJEDE" title="Setting Up a Packet-Handling Project"></a><h3>Setting Up a Packet-Handling Project</h3><p>The IOFireWire family defines two types of address space on the Macintosh: Physical address space and pseudo-address space. The IOFireWireDeviceInterface provides IOFireWirePhysicalAddressSpace objects, which are allocated in a range of hardware-backed addresses and IOFireWirePseudoAddressSpace objects, which are allocated in a range of addresses outside the physical range and are accessible only through software.</p><p>As mentioned in <span class="content_text"><a href="../FWDevOverview/FWDevOverview.html#//apple_ref/doc/uid/TP40000969-CH201-CCHJIHJG">“FireWire Overview,”</a></span> FireWire defines 64-bit addresses of which the lower 48 bits are for device-specific use. The physical address space range is the lower 32 bits of the device-specific range mapped onto the 32 -bit Macintosh RAM. Thus, in terms of FireWire addresses, an IOFireWirePhysicalAddressSpace object is an allocated subrange in the range $0000.00000000 to $0000.FFFFFFFF. An IOFireWirePseudoAddressSpace object is an allocated subrange of FireWire addresses of $1.00000000 and higher.</p><p>The FireWire controller chip can write directly to and read directly from a physical address space without any software intervention. For this reason, you can transfer large amounts of data to and from this address space efficiently. Because there is no software involvement in such a transfer, however, there is no indication of when the transfer is complete or if it failed. To handle this, you must also allocate a pseudo-address space to serve as a messaging area. Your remote device then transfers its data to a physical address space and sends a message of success or failure to a pseudo-address space that alerts your software.</p><p>The IOFireWirePacketQueueTest project uses functions of the IOFireWireDeviceInterface to create an IOFireWirePseudoAddressSpace interface object that represents a pseudo-address space on the local node. The project then uses functions of the IOFireWirePseudoAddressSpace interface to get the FireWire address of the address space and set up callback routines for writing and reading to the address space. It also sets up a callback routine for handling packets that must be dropped when the queue of packets coming into the pseudo-address space fills up too quickly.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000969-CH203-DontLinkElementID_7" title="Note"></a><p><strong>Note:</strong>&nbsp;The IOFireWirePacketQueueTest project only <em>receives</em> asynchronous data; it does not send any data. To use IOFireWirePacketQueueTest, you should also run a program that sends data, such as FWUtil (also available in the FireWire SDK).</p></div><p>The <code>main</code> function of the <code>IOFireWirePacketQueueTest.cpp</code> first calls the <code>GetIOFireWireDevices</code> function to put all IOFireWireLocalNode device objects into an array. Then, it uses standard Core Foundation and I/O Kit functions to get an IOFireWireDeviceInterface for the first object in the array (see <span class="content_text"><a href="../FWDevAccess/FWDevAccess.html#//apple_ref/doc/uid/TP40000969-CH202-CCHEAIEE">“Getting FireWire Device Interfaces”</a></span> for sample code illustrating this process). After using IOFireWireDeviceInterface functions to open the device and set up a callback dispatcher, the <code>main</code> function then creates a pseudo-address space object and gets an interface to it, as <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHBDDFH">Listing 3-5</a></span> shows.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHBDDFH" title="Listing 3-5Getting an IOFireWirePseudoAddressSpaceInterface"></a><p class="codesample"><strong>Listing 3-5&nbsp;&nbsp;</strong>Getting an IOFireWirePseudoAddressSpaceInterface</p><div class="codesample"><table><tr><td scope="row"><pre>Ptr                     gBuf = 0; //Buffer for backing store.<span></span></pre></td></tr><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre>IOFireWireLibDeviceRef  interface;<span></span></pre></td></tr><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre>IOFireWireLibPseudoAddressSpaceRef  addressSpace = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>IOFireWireLibPhysicalAddressSpaceRefphysAddressSpace = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//Allocate backing store and put some text into gBuf for testing.<span></span></pre></td></tr><tr><td scope="row"><pre>gBuf = (Ptr) new char[40960];<span></span></pre></td></tr><tr><td scope="row"><pre>sprintf( gBuf, "Testing..." );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//Use IOFireWireDeviceInterface function CreatePseudoAddressSpace to<span></span></pre></td></tr><tr><td scope="row"><pre>//create a pseudo-address space object and get an interface to it.<span></span></pre></td></tr><tr><td scope="row"><pre>//In the call to CreatePseudoAddressSpace, 40960 is the size of the<span></span></pre></td></tr><tr><td scope="row"><pre>//address space, addressSpace is the reference value passed to all<span></span></pre></td></tr><tr><td scope="row"><pre>//callback functions, and 4096 is the size of the queue that<span></span></pre></td></tr><tr><td scope="row"><pre>//receives packets from the bus.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>addressSpace = (*interface)->CreatePseudoAddressSpace( interface,<span></span></pre></td></tr><tr><td scope="row"><pre>    40960, (void*) addressSpace, 4096, gBuf, kFWAddressSpaceAutoCopyOnWrite,<span></span></pre></td></tr><tr><td scope="row"><pre>    CFUUIDGetUUIDBytes( kIOFireWirePseudoAddressSpaceInterfaceID ) );<span></span></pre></td></tr></table></div><p>Next, the <code>main</code> function uses IOFireWirePseudoAddressSpaceInterface functions to set up callback handler routines for reading and writing to the pseudo-address space and handling skipped packets. When a <code>write</code> to the pseudo-address space occurs, the <code>PacketWriteHandler</code> routine prints out information about the pseudo-address space and the packets it received. Similarly, when a <code>read</code> occurs, the <code>PacketReadHandler</code> routine handles the <code>read</code> and then prints out information about the <code>read</code> request. The <code>SkippedPacketHandler</code> routine simply prints out the number of skipped packets. All three handler routines end with a call to the IOFireWirePseudoAddressSpaceInterface function <code>ClientCommandIsComplete</code>, which notifies the pseudo-address space that a packet notification handler has completed its work, as in this example from <code>SkippedPacketHandler</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>//In the following function call, commandID is the same ID that was<span></span></pre></td></tr><tr><td scope="row"><pre>//passed to the packet notification handler and kIOReturnSuccess is<span></span></pre></td></tr><tr><td scope="row"><pre>//the completion status of the packet handler.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>(*addressSpace)->ClientCommandIsComplete( addressSpace,<span></span></pre></td></tr><tr><td scope="row"><pre>    commandID, kIOReturnSuccess );<span></span></pre></td></tr></table></div><p>The <code>main</code> function then sets everything in motion by calling <code>CFRunLoopRun</code>. Finally, it releases all the interfaces it acquired and ends.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHJJDAE" title="Using the IOFireWireSBP2Lib"></a><h2>Using the IOFireWireSBP2Lib</h2><p>The SBP2SampleProject in the FireWire SDK adds another layer of complexity to the standard application-level access of a FireWire device. Instead of acquiring interfaces from the IOFireWireSBP2Lib and using them to communicate with a device, the SBP2SampleProject provides a user-space driver plug-in that exists between the application and the IOFireWireSBP2Lib. The application in the SBP2SampleProject creates a matching dictionary and gets an interface, but it is an interface to the user-space driver, not to the device object itself. The user-space driver then gets an interface from the IOFireWireSBP2Lib and uses it to access the in-kernel SBP-2 services. This design allows multiple applications to use the same user-space driver plug-in to access a device.</p><p>The SBP2SampleProject is a multi-threaded project. For an example of the same project in a single-threaded environment, see the SBP2SampleProject-SingleThread project.</p><p>The SBP2SampleProject driver abstracts device access into two logical layers. The lower layer is a transport layer that handles such tasks as SBP-2 ORB chaining and login maintenance. The upper layer is a protocol layer that receives commands from the application and creates and submits the appropriate ORBs to the transport layer to execute them. This architecture allows you to modify the upper, protocol layer to meet your device’s needs without having to change much of the transport layer of the driver.</p><p>This section introduces the main features of the SBP2SampleProject and points out where you can change the code to use it as a foundation for your own project. In order to be universally applicable, the SBP2SampleProject accesses the computer’s hard disk. To test the unmodified project on your Macintosh, follow the instructions included in the FireWire SDK to disable the built-in hard disk driver and allow the sample driver to attach.</p><p>Although disabling a built-in driver to allow your user-space driver to attach is an acceptable testing procedure, you should provide your own kernel extension (or KEXT) that can successfully compete with other drivers. This not only ensures that the I/O Kit finds and loads your KEXT for your device, but also provides the CFPlugIn information that identifies your user-space driver plug-in. In general, you should provide your own KEXT when your driver is a user-space plug-in that your application loads using the function <code>IOCreatePlugInInterfaceForService</code> or when there may be other drivers competing for your device. Examine the bundle settings of the <code>SBP2SampleDriver.kext</code> to see how the driver plug-in is identified. For more information on developing a KEXT, see <em><a href="../../WritingDeviceDriver/index.html#//apple_ref/doc/uid/TP30000694" target="_top">I/O Kit Device Driver Design Guidelines</a></em>.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-TPXREF105" title="Setting Up the Application"></a><h3>Setting Up the Application</h3><p>The application portion of the SBP2SampleProject is written in Objective-C using the Cocoa framework and contains two code files: <code>SelectorController.m</code> and <code>LUNController.m</code>. In addition to GUI-related tasks, the implementation of the SelectorController class is responsible for:</p><ul class="spaceabove"><li class="li"><p>Getting the Mach port</p></li><li class="li"><p>Creating a matching dictionary for IOFireWireSBP2LUN objects</p></li><li class="li"><p>Getting an iterator over the set of matching objects</p></li><li class="li"><p>Instantiating a LUNController object to create a name string for each matching IOFireWireSBP2LUN object</p></li><li class="li"><p>Populating an array with matching IOFireWireSBP2LUN objects</p></li><li class="li"><p>Using the LUNController object to get an interface to the driver plug-in for each IOFireWireSBP2LUN object the user selects</p></li><li class="li"><p>Releasing the Mach port</p></li></ul><p>The main task of the implementation of the LUNController class is to get the driver plug-in interface and use it to communicate with the device. An instance of the LUNController class:</p><ul class="spaceabove"><li class="li"><p>Uses the device object reference from an instance of SelectorController to get device properties from the I/O Registry</p></li><li class="li"><p>Gets the driver plug-in interface for the device object and sets up callbacks on the current run loop</p></li><li class="li"><p>Performs device <code>login</code> and <code>logout</code></p></li><li class="li"><p>Performs a <code>read</code> of the first four blocks of the device</p></li><li class="li"><p>Releases the driver plug-in interface</p></li></ul><p>The implementation of the LUNController class uses the same Core Foundation functions to get the interface to the driver plug-in as described in <span class="content_text"><a href="../FWDevAccess/FWDevAccess.html#//apple_ref/doc/uid/TP40000969-CH202-CCHEAIEE">“Getting FireWire Device Interfaces.”</a></span> For example,</p><div class="codesample"><table><tr><td scope="row"><pre>//Get CFPlugIn interface.<span></span></pre></td></tr><tr><td scope="row"><pre>status = IOCreatePlugInInterfaceForService( fLUNReference,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSBP2SampleDriverTypeID, kIOCFPlugInInterfaceID, &amp;fCFPlugInInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>    &amp;score );<span></span></pre></td></tr><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre>//Get driver plug-in interface.<span></span></pre></td></tr><tr><td scope="row"><pre>result = (*fCFPlugInInterface)->QueryInterface( fCFPlugInInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>    CFUUIDGetUUIDBytes( kSBP2SampleDriverInterfaceID ), (LPVOID *)<span></span></pre></td></tr><tr><td scope="row"><pre>    &amp;fDriverInterface );<span></span></pre></td></tr></table></div><p>The only difference is in the parameters identifying the type of interface. Instead of using <code>kIOFireWireSBP2LibTypeID</code>, it uses <code>kSBP2SampleDriverTypeID</code> to get the IOCFPlugInInterface. Then, it calls <code>QueryInterface</code> with <code>kSBP2SampleDriverInterfaceID</code> to get the interface to the driver plug-in. Both <code>kSBP2SampleDriverTypeID</code> and <code>kSBP2SampleDriverInterfaceID</code> are defined in <code>SBP2SampleDriverInterface.h</code>.</p><p>An instance of the LUNController class performs device functions (<code>login</code>, <code>logout</code>, and <code>read</code>) using functions of the driver plug-in interface. The <code>login</code> and <code>logout</code> functions are straightforward calls to the driver plug-in interface:</p><div class="codesample"><table><tr><td scope="row"><pre>(*fDriverInterface)->loginToDevice( fDriverInterface );<span></span></pre></td></tr><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre>(*fDriverInterface)->logoutOfDevice( fDriverInterface );<span></span></pre></td></tr></table></div><p>The LUNController instance uses a separate thread to perform the <code>read</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>[NSThread detachNewThreadSelector:@selector(runReadTransaction:)<span></span></pre></td></tr><tr><td scope="row"><pre>    toTarget:self withObject:nil];<span></span></pre></td></tr></table></div><p>Then, in the <code>runReadWorker</code> method, the LUNController instance uses the driver plug-in interface to send the <code>read</code> command:</p><div class="codesample"><table><tr><td scope="row"><pre>(*fDriverInterface)->readBlock( fDriverInterface, transactionID, 1, &amp;block );<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000969-CH203-TPXREF106" title="Setting Up the Protocol Layer"></a><h3>Setting Up the Protocol Layer</h3><p>The SBP2SampleProject classes SBP2SampleDriver and SBP2SampleDriverPlugInGlue define objects that comprise the protocol layer. The protocol layer first creates the transport layer, then creates the ORBs, fills and queues them, and communicates with the transport layer to submit them. In turn, the transport layer relays ORB-status and login-status messages to the protocol layer so the SBP2SampleDriver object can react accordingly.</p><p>The “glue” in SBP2SampleDriverPlugInGlue mainly refers to code that supplies the SBP2SampleDriver’s methods as CFPlugIn functions (other code handles C++ idiosyncrasies, such as supplying static methods that can call virtual methods on objects). Recall that the application uses standard CFPlugIn functions, such as <code>QueryInterface</code>, to get and use the driver plug-in interface. If your application is getting IOFireWireLib or IOFireWireSBP2Lib interfaces directly, the libraries provide this “glue” behind the scenes. The SBP2SampleProject, however, must explicitly provide this code so the application can use the driver plug-in interface as if it were an IOFireWire family device interface.</p><p>The SBP2SampleDriver class implements many of the same methods an in-kernel driver does, such as <code>start</code>, <code>stop</code>, and <code>probe</code>. In its <code>start</code> method, the driver calls a method of the SBP2SampleORBTransport class to create the transport layer and uses the returned reference to tell the layer to start.</p><p>Next, it uses the transport layer’s <code>createORB</code> method to create a <code>TEST_UNIT_READY</code> ORB. The <code>TEST_UNIT_READY</code> ORB is part of the configuration process for SBP-2 hard drives (see <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHCIJFD">“Handling Device Configuration and Reconfiguration”</a></span> for more information on the device configuration process). Your device may have different configuration needs. Finally, it uses the <code>createORB</code> method again to create a pool of free ORBs to draw from later and the Core Foundation function <code>CFArrayCreateMutable</code> to create an array to hold in-progress ORBs.</p><p>The <code>stop</code> method of the SBP2SampleDriver class releases the ORB pool and in-progress ORB array and calls the <code>stop</code> method of the SBP2SampleORBTransport class to initiate the shutdown of the transport layer. The <code>probe</code> method merely checks to be sure that the referenced device object is of type IOFireWireSBP2LUN.</p><p>The SBP2SampleDriver class implementation uses Core Foundation array-handling functions to create and manage its queue of in-progress ORBs, as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>CFMutableArrayRef   fInProgressORBQueue;<span></span></pre></td></tr><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre>//kSBP2SampleFreeORBCount is defined in SBP2SampleDriver.h<span></span></pre></td></tr><tr><td scope="row"><pre>fInProgressORBQueue = CFArrayCreateMutable( kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSBP2SampleFreeORBCount, SBP2SampleORB::getCFArrayCallbacks() );<span></span></pre></td></tr></table></div><p>Because the SBP2SampleDriver project is multithreaded, it’s possible that one thread might remove an ORB from the free ORB pool at the same time another thread appends one. To protect against this, the SBP2SampleDriver methods that handle the free ORB pool get a lock on a mutex before removing or appending ORBs and release the lock afterwards, as <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHDBAJI">Listing 3-6</a></span> shows.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHDBAJI" title="Listing 3-6The getORBFromFreePool method of the SBP2SampleDriver class"></a><p class="codesample"><strong>Listing 3-6&nbsp;&nbsp;</strong>The getORBFromFreePool method of the SBP2SampleDriver class</p><div class="codesample"><table><tr><td scope="row"><pre>SBP2SampleORB * SBP2SampleDriver::getORBFromFreePool( void )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CFIndex freeORBCount;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_mutex_lock( &amp;fFreePoolLock );<span></span></pre></td></tr><tr><td scope="row"><pre>    while ( ( freeORBCount = CFArrayGetCount( fFreeORBPool ) ) == 0 ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        //If there are no free ORBs, wait for one.<span></span></pre></td></tr><tr><td scope="row"><pre>        pthread_cond_wait( &amp;fFreePoolCondition, &amp;fFreePoolLock );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    //Remove the ORB from the pool.<span></span></pre></td></tr><tr><td scope="row"><pre>    SBP2SampleORB * orb = (SBP2SampleORB*) CFArrayGetValueAtIndex(<span></span></pre></td></tr><tr><td scope="row"><pre>        fFreeORBPool, 0 );<span></span></pre></td></tr><tr><td scope="row"><pre>    orb->retain();<span></span></pre></td></tr><tr><td scope="row"><pre>    CFArrayRemoveValueAtIndex( fFreeORBPool, 0 );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_mutex_unlock( &amp;fFreePoolLock );<span></span></pre></td></tr><tr><td scope="row"><pre>    return orb;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If you need to customize the sample driver’s queueing mechanisms, examine the following methods in which the SBP2SampleDriver class does most of its ORB-handling work:</p><ul class="spaceabove"><li class="li"><p><code>getORBFromFreePool</code> gets a lock on the <code>fFreePoolLock</code> mutex and waits for a free ORB which it removes from the pool and returns.</p></li><li class="li"><p><code>addORBToFreePool</code> gets a lock on the <code>fFreePoolLock</code> mutex, appends the passed-in ORB to the free pool, and sends a signal that wakes up threads that are waiting for free ORBs.</p></li><li class="li"><p><code>appendORBToInProgressQueue</code> uses a Core Foundation function to add the passed-in ORB to the queue of in-progress ORBs.</p></li><li class="li"><p><code>removeORBFromInProgressQueue</code> uses Core Foundation functions to find the index of the passed-in ORB in the queue of in-progress ORBs and removes it.</p></li></ul><p>The status of the ORBs is tracked by methods that send reports between the protocol and transport layers. The sample driver uses the transport layer’s <code>submitORB</code> method to send an ORB to the device. The transport layer responds by calling one of the following SBP2SampleDriver class methods:</p><ul class="spaceabove"><li class="li"><p><code>completeORB</code> if the device received the ORB</p></li><li class="li"><p><code>suspendORBs</code> when a bus reset occurs or if the device is unplugged</p></li><li class="li"><p><code>resumeORBs</code> if the device is again logged in</p></li><li class="li"><p><code>loginLost</code> if the connection to the device is lost</p></li></ul><a name="//apple_ref/doc/uid/TP40000969-CH203-TPXREF107" title="Setting Up the Transport Layer"></a><h3>Setting Up the Transport Layer</h3><p>The transport layer of the SBP2SampleProject is responsible for acquiring the appropriate IOFireWireSBP2Lib interfaces that allow direct communication with the device and using those interfaces to send ORBs and manage the login status of the device.</p><p>The transport layer comprises four classes, listed in order of proximity to the device object:</p><ul class="spaceabove"><li class="li"><p>SBP2SampleSBP2LibGlue</p></li><li class="li"><p>SBP2SampleLoginController</p></li><li class="li"><p>SBP2SampleORB</p></li><li class="li"><p>SBP2SampleORBTransport</p></li></ul><p>When the protocol layer starts the transport layer, the <code>start</code> method of the SBP2SampleSBP2LibGlue class executes, acquiring an IOFireWireSBP2LibLUNInterface. Using this interface, the SBP2SampleSBP2LibGlue instance opens the LUN and gets the IOFireWireSBP2LibLoginInterface. The IOFireWireSBP2LibLoginInterface supplies APIs for login maintenance and command execution.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000969-CH203-DontLinkElementID_8" title="Note"></a><p><strong>Note:</strong>&nbsp;The SBP2SampleSBP2LibGlue class implementation also shows how to get the IOFireWireLibInterface using the session reference the IOFireWireSBP2LibLUNInterface supplies, but this is conditionally bypassed in the code.</p></div><p>The SBP2SampleSBP2LibGlue class uses the IOFireWireSBP2LibLoginInterface to register status callbacks that the in-kernel SBP-2 services use to notify the driver, such as <code>setLoginCallback</code> and <code>setStatusNotify</code>. In addition, the class uses this interface to create an IOFireWireSBP2LibMgmtORBInterface object that gives you access to an SBP-2 management ORB. This object allows you to execute commands such as <code>QueryLogin</code>, <code>AbortTask</code>, and <code>LogicalUnitReset</code>. In this project, the SBP2SampleSBP2LibGlue class uses the IOFireWireSBP2LibMgmtORBInterface object functions to set the command to be managed by the management ORB (with <code>setManageeLogin</code>), set the function of the management ORB (with <code>setCommandFunction</code>), and set the ORB completion routine (with <code>setORBCompleteCallback</code>).</p><p>The SBP2SampleLoginController class uses the IOFireWireSBP2LibLoginInterface to send <code>login</code> and <code>logout</code> commands to the device. The <code>loginCompletion</code> method checks status parameters and tries to log in again if necessary. You can add code here to check for status values specific to your device. The SBP2SampleLoginController class also handles callback messages from the device describing the status of the device’s connection. You can subclass the methods that handle the login states (lost, suspended, and resumed) to perform device-specific tasks.</p><p>The SBP2SampleORB class implementation is responsible for the ORB object itself. Methods in this class initialize a new SBP2SampleORB object that represents the ORB and provide access to various fields in the IOFireWireSBP2LibORBInterface objects, such as the transaction identification and the maximum ORB payload size.</p><p>The SBP2SampleORBTransport class abstracts the transport of ORBs from the protocol layer to the lowest levels of the transport layer. When the SBP2SampleDriver class initiates the transport layer, it calls the factory method of the SBP2SampleORBTransport class. In its <code>start</code> method, the SBP2SampleORBTransport class instantiates the SBP2SampleSBP2LibGlue class which acquires the IOFireWireSBP2Lib interfaces it needs to communicate with the device. The SBP2SampleORBTransport class also implements the <code>submitORB</code> method for the protocol layer, using the IOFireWireSBP2LibLoginInterface function <code>submitORB</code>.</p><p>The SBP2SampleORBTransport class notifies the protocol layer of ORB status with a method called <code>statusNotify</code>. <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHDICCJ">Listing 3-7</a></span> shows the <code>statusNotify</code> method. It does not show the method <code>parseStatus</code> that interprets the ORB’s status and returns one of the values enumerated at the beginning of the SBP2SampleORBTransport class implementation, or the messages <code>statusNotify</code> sends to <code>FWLog</code> (a macro defined in <code>FWDebugging.h</code>).</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHDICCJ" title="Listing 3-7The statusNotify method of the SBP2SampleORBTransport class"></a><p class="codesample"><strong>Listing 3-7&nbsp;&nbsp;</strong>The statusNotify method of the SBP2SampleORBTransport class</p><div class="codesample"><table><tr><td scope="row"><pre>void SBP2SampleORBTransport::statusNotify( FWSBP2NotifyParams * params )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    SBP2SampleORB * orb = ( SBP2SampleORB *)params->refCon;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 event = parseStatus( params );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch( event )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kStatusDeadBitSet:<span></span></pre></td></tr><tr><td scope="row"><pre>            //Suspend protocol layer.<span></span></pre></td></tr><tr><td scope="row"><pre>            fDriverLayer->suspendORBs();<span></span></pre></td></tr><tr><td scope="row"><pre>            //Complete this ORB.<span></span></pre></td></tr><tr><td scope="row"><pre>            completeORB( orb, kIOReturnError );<span></span></pre></td></tr><tr><td scope="row"><pre>            //Reset the fetch agent.<span></span></pre></td></tr><tr><td scope="row"><pre>            (*fSBP2LoginInterface)->submitFetchAgentReset(<span></span></pre></td></tr><tr><td scope="row"><pre>                fSBP2LoginInterface );<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kStatusDummyORBComplete:<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( orb == fDummyORB ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                // All is initialized so resume protocol layer.<span></span></pre></td></tr><tr><td scope="row"><pre>                fDriverLayer->resumeORBs();<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            else {<span></span></pre></td></tr><tr><td scope="row"><pre>                //This must be an aborted ORB.<span></span></pre></td></tr><tr><td scope="row"><pre>                completeORB( orb, kIOReturnError );<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>            case kStatusORBComplete:<span></span></pre></td></tr><tr><td scope="row"><pre>                // Complete the protocol layer’s ORBs.<span></span></pre></td></tr><tr><td scope="row"><pre>                completeORB( orb, kIOReturnSuccess );<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            case kStatusORBError:<span></span></pre></td></tr><tr><td scope="row"><pre>                completeORB( orb, kIOReturnIOError );<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            case kStatusORBReset:<span></span></pre></td></tr><tr><td scope="row"><pre>                //This is a command reset so tell the protocol layer (it<span></span></pre></td></tr><tr><td scope="row"><pre>                //should already be suspended at this point).<span></span></pre></td></tr><tr><td scope="row"><pre>                completeORB( orb, kIOReturnNotReady );<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            case kStatusORBTimeout:<span></span></pre></td></tr><tr><td scope="row"><pre>                //Suspend the protocol layer.<span></span></pre></td></tr><tr><td scope="row"><pre>                fDriverLayer->suspendORBs();<span></span></pre></td></tr><tr><td scope="row"><pre>                //Complete this ORB.<span></span></pre></td></tr><tr><td scope="row"><pre>                completeORB( orb, kIOReturnError );<span></span></pre></td></tr><tr><td scope="row"><pre>                //Reset the LUN.<span></span></pre></td></tr><tr><td scope="row"><pre>                (*fLUNResetORBInterface)->submitORB( fLUNResetORBInterface<span></span></pre></td></tr><tr><td scope="row"><pre>                    );<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHDICCJ">Listing 3-7</a></span>, the <code>completeORB</code> method refers to a method of the SBP2SampleORBTransport class only if the ORB in question is the dummy ORB (described in <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHCIJFD">“Handling Device Configuration and Reconfiguration”</a></span>); otherwise, it refers to a method of the SBP2SampleDriver class.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHCIJFD" title="Handling Device Configuration and Reconfiguration"></a><h3>Handling Device Configuration and Reconfiguration</h3><p>Both the transport and protocol layers must perform some configuration before they can accept commands from the application. This occurs when the application starts up and after bus resets. The transport layer appends a dummy ORB (an ORB with no command) to a special register on the SBP-2 device called the fetch agent which holds the address of the ORB the device is currently working on. At login or after a bus reset, you must write the address of the first ORB directly to the fetch agent register. You can then chain all subsequent ORBs onto that first ORB. In this case, the dummy ORB’s function is to always be the first ORB executed at login or after a bus reset.</p><p>Because the project is written to access a mass storage device, the protocol layer reconfigures the device when the application starts up and after every bus reset. The protocol layer sends a <code>TEST_UNIT_READY</code> ORB because the device is a hard disk—your device might require another type of ORB. The protocol layer must wait until the transport layer has executed the dummy ORB before it can send the <code>TEST_UNIT_READY</code> ORB. The application must wait until both these ORBs have executed before it can start sending its own ORBs.</p><p>When the project first starts up, an instance of the LUNController class calls the <code>loginToDevice</code> method of the SBP2SampleDriver class in response to user input. The protocol and transport layers then perform the following steps to initialize the device and ready it to accept ORBs from the application:</p><ul class="spaceabove"><li class="li"><p>The SBP2SampleDriver instance calls the <code>loginToDevice</code> method of the SBP2SampleLoginController class.</p></li><li class="li"><p>The SBP2SampleLoginController instance uses the IOFireWireSBP2LibLoginInterface function <code>submitLogin</code> to log in to the device.</p></li><li class="li"><p>When the login is complete, it triggers the SBP2SampleLoginController callback method <code>loginCompletion</code> which calls the SBP2SampleORBTransport class’s <code>loginResumed</code> method.</p></li><li class="li"><p>The SBP2SampleORBTransport instance submits a dummy ORB.</p></li><li class="li"><p>When the dummy ORB completes, the <code>statusNotify</code> method of the SBP2SampleORBTransport calls the SBP2SampleDriver’s <code>resumeORBs</code> method which sets the <code>fSuspended</code> flag to <code>false</code> and submits a <code>TEST_UNIT_READY</code> ORB to the transport layer.</p></li><li class="li"><p>The SBP2SampleORBTransport instance submits the <code>TEST_UNIT_READY</code> ORB.</p></li><li class="li"><p>When the <code>TEST_UNIT_READY</code> ORB completes, the SBP2SampleORBTransport <code>statusNotify</code> method calls the <code>completeORB</code> method of the SBP2SampleDriver class.</p></li><li class="li"><p>The SBP2SampleDriver <code>completeORB</code> method checks if the ORB just completed is a <code>TEST_UNIT_READY</code> ORB and, if it is, it sets the flag <code>fDeviceReady</code> to <code>true</code> and proceeds to submit ORBs from the application.</p></li></ul><p>After bus resets, the steps are similar:</p><ul class="spaceabove"><li class="li"><p>The SBP2SampleLoginController instance receives a <code>kIOMessageServiceIsSuspended</code> message and, if it is currently logged in to the device, it sets the <code>fLoggedIn</code> flag to <code>false</code>.</p></li><li class="li"><p>The SBP2SampleDriver instance executes its <code>suspendORBs</code> method which sets the <code>fSuspended</code> flag to <code>true</code> and the <code>fDeviceReady</code> flag to <code>false</code>.</p></li><li class="li"><p>When the device successfully reconnects, the SBP2SampleLoginController instance receives a <code>kIOMessageFWSBP2ReconnectComplete</code> message and sets the <code>fLoggedIn</code> flag to <code>true</code>.</p></li><li class="li"><p>The SBP2SampleORBTransport instance then calls the SBP2SampleLoginController class’s <code>loginResumed</code> method (which you can modify to perform device-specific operations) and submits a dummy ORB.</p></li><li class="li"><p>When the dummy ORB completes, the <code>statusNotify</code> method of the SBP2SampleORBTransport calls the SBP2SampleDriver’s <code>resumeORBs</code> method which sets the <code>fSuspended</code> flag to <code>false</code> and submits a <code>TEST_UNIT_READY</code> ORB to the transport layer.</p></li><li class="li"><p>The SBP2SampleORBTransport instance submits the <code>TEST_UNIT_READY</code> ORB.</p></li><li class="li"><p>When the <code>TEST_UNIT_READY</code> ORB completes, the SBP2SampleORBTransport <code>statusNotify</code> method calls the <code>completeORB</code> method of the SBP2SampleDriver class.</p></li><li class="li"><p>The SBP2SampleDriver <code>completeORB</code> method checks if the ORB just completed is a <code>TEST_UNIT_READY</code> ORB and, if it is, it sets the flag <code>fDeviceReady</code> to <code>true</code> and proceeds to submit ORBs from the application.</p></li></ul><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHDEBJH" title="Using the IOFireWireAVCLib"></a><h2>Using the IOFireWireAVCLib</h2><p>The IOFireWireAVCLib provides two interfaces that you can use independently of each other. The IOFireWireAVCLibProtocolInterface allows you to treat the Macintosh as an AV/C unit, setting up local plugs and receiving AV/C requests. The IOFireWireAVCLibUnitInterface supplies methods that send AV/C commands to an external AV/C unit. The IOFireWireAVCLibUnitInterface also provides a method to get the session reference so you can simultaneously get the IOFireWireLibDeviceInterface to access an external device and read its plug control registers.</p><p>The AVCBrowser project shows how to use both interfaces. First, it uses the IOFireWireAVCLibProtocolInterface to allocate and read input and output plugs on the Macintosh and receive AV/C requests. Then, it finds all AV/C units currently in the I/O Registry and gets an IOFireWireAVCLibUnitInterface for each. With this interface, the project opens the unit and sends it commands. Finally, the project gets an IOFireWireDeviceInterface for the device object underlying the IOFireWireAVCUnit object and reads its plug control registers.</p><p>AVCBrowser is written in Objective-C using the Cocoa framework and, as such, contains several methods that handle the user interface. For the sake of brevity, this document focuses on only those methods that acquire and use the IOFireWireAVCLib interfaces.</p><p>AVCBrowser contains four classes:</p><ul class="ul"><li class="li"><p>DevicesController implements a DevicesController object that contains an array of AV/C units it finds in the I/O Registry and includes an instance method to open the device and display information about its input and output plugs.</p></li><li class="li"><p>AVCDevice implements an AVCDevice object that contains information about an IOFireWireAVCUnit object, including a handle to its IOFireWireAVCLibUnitInterface and an IOFireWireDeviceInterface for its underlying IOFireWireDevice object.</p></li><li class="li"><p>PlugBrowserController implements a PlugBrowserController object that responds to user requests for information about a particular AV/C unit’s input and output plugs.</p></li><li class="li"><p>Plug implements a Plug object for each plug on an AV/C unit that includes information on its broadcast status and channel.</p></li></ul><p>The implementation of the DevicesController <code>init</code> method uses standard I/O Kit functions to get a Mach port and to search the I/O Registry for IOFireWireLocalNode objects (if there is more than one FireWire bus, there is more than one IOFireWireLocalNode object representing the Macintosh). For each object it finds, the <code>init</code> method gets an IOFireWireAVCLibProtocolInterface and it uses the interface function <code>setMessageCallback</code> to receive bus reset and reconnect messages. It also sets up a routine to handle requests sent to the Macintosh from an AV/C device (in this sample, a video camera), using the interface function <code>setAVCRequestCallback</code> .</p><p>The DevicesController <code>init</code> method then sets up input and output plugs on the local node and reads their values using IOFireWireAVCLibProtocolInterface functions, as <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHFIADI">Listing 3-8</a></span> shows.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHFIADI" title="Listing 3-8Setting up plugs on the local node"></a><p class="codesample"><strong>Listing 3-8&nbsp;&nbsp;</strong>Setting up plugs on the local node</p><div class="codesample"><table><tr><td scope="row"><pre>IOFireWireAVCLibProtocolInterface ** avcInterface;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 inputPlug, outputPlug;<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t result;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//Not shown in this listing: acquisition of ‘avcInterface’ and error<span></span></pre></td></tr><tr><td scope="row"><pre>//checking using the value of ‘result’.<span></span></pre></td></tr><tr><td scope="row"><pre>if ( (*avcInterface)->allocateInputPlug )<span></span></pre></td></tr><tr><td scope="row"><pre>    //In the call to allocateInputPlug, writePlug is the callback function<span></span></pre></td></tr><tr><td scope="row"><pre>    //called when a successful lock transition plug has been performed<span></span></pre></td></tr><tr><td scope="row"><pre>    //and inputPlug is set to the plug number upon successful allocation.<span></span></pre></td></tr><tr><td scope="row"><pre>    result = (*avcInterface)->allocateInputPlug( avcInterface, self,<span></span></pre></td></tr><tr><td scope="row"><pre>        writePlug, &amp;inputPlug )<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ( (*avcInterface)->readInputPlug ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 val;<span></span></pre></td></tr><tr><td scope="row"><pre>    val = (*avcInterface)->readInputPlug( avcInterface, inputPlug );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( (*avcInterface)->updateInputPlug )<span></span></pre></td></tr><tr><td scope="row"><pre>        (*avcInterface)->updateInputPlug( avcInterface, inputPlug, val,<span></span></pre></td></tr><tr><td scope="row"><pre>            val+1 );<span></span></pre></td></tr><tr><td scope="row"><pre>    val = (*avcInterface)->readInputPlug( avcInterface, inputPlug );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ( (*avcInterface)->freeInputPlug )<span></span></pre></td></tr><tr><td scope="row"><pre>    (*avcInterface)->freeInputPlug( avcInterface, inputPlug );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ( (*avcInterface)->allocateOutputPlug )<span></span></pre></td></tr><tr><td scope="row"><pre>    (*avcInterface)->allocateOutputPlug( avcInterface, self, writePlug,<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;outputPlug );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ( (*avcInterface)->readOutputPlug )<span></span></pre></td></tr><tr><td scope="row"><pre>    (*avcInterface)->readOutputPlug( avcInterface, outputPlug );<span></span></pre></td></tr></table></div><p>To set up a dispatcher for kernel messages to the program, the <code>init</code> method uses the IOFireWireAVCLibProtocolInterface function <code>addCallbackDispatcherToRunLoop</code>, as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>(*avcInterface)->addCallbackDispatcherToRunLoop( avcInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopGetCurrent() );<span></span></pre></td></tr></table></div><p>After setting up the IOFireWireAVCLibProtocolInterface for the local node, the <code>init</code> method then registers for notification of new IOFireWireAVCUnit objects in the I/O Registry, using the functions described in <span class="content_text"><a href="../FWDevAccess/FWDevAccess.html#//apple_ref/doc/uid/TP40000969-CH202-CCHCIBDB">“Finding FireWire Devices.”</a></span> To find all IOFireWireAVCUnit objects already present in the I/O Registry and arm the notification, the DevicesController class calls its function <code>serviceMatchingCallback</code>. This function instantiates an AVCDevice object (declared in <code>AVCDevice.h</code>) for each IOFireWireAVCUnit object it finds.</p><p>The implementation of the AVCDevice class method <code>withIOService:</code> uses I/O Kit and Core Foundation functions to extract the IOFireWireAVCUnit object’s <code>GUID</code> (globally unique identifier), <code>Unit_Type</code>, and <code>FireWire Product Name</code> properties. You can use these properties (or any of the properties of the IOFireWireAVCUnit object listed in <span class="content_text"><a href="../FWDevAccess/FWDevAccess.html#//apple_ref/doc/uid/TP40000969-CH202-CCHHJHEG">Table 2-2</a></span>) to create a more specific matching dictionary. The <code>withIOService:</code> method calls the private function <code>findPluginForDevice</code> to create a dictionary that matches on IOFireWireAVCUnit objects with the passed-in GUID and to create an interface of type IOCFPlugInInterface for it.</p><p>The <code>withIOService:</code> method queries the IOCFPlugInInterface from <code>findPluginForDevice</code> to get the IOFireWireAVCLibUnitInterface. It then uses IOFireWireAVCLibUnitInterface functions to open the unit, set up a callback routine and dispatcher, and send a command to the unit, as <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHGADDG">Listing 3-9</a></span> shows.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHGADDG" title="Listing 3-9Communicating with an external AV/C device"></a><p class="codesample"><strong>Listing 3-9&nbsp;&nbsp;</strong>Communicating with an external AV/C device</p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn    result;<span></span></pre></td></tr><tr><td scope="row"><pre>IOFireWireAVCLibUnitInterface   **avcInterface;<span></span></pre></td></tr><tr><td scope="row"><pre>AVCDevice   *theDevice;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32      size;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt8       cmd[8], response[8];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>cmd[kAVCCommandResponse] = kAVCStatusInquiryCommand;<span></span></pre></td></tr><tr><td scope="row"><pre>cmd[kAVCAddress] = kAVCUnitAddress;<span></span></pre></td></tr><tr><td scope="row"><pre>cmd[kAVCOpcode] = kAVCUnitInfoOpcode;<span></span></pre></td></tr><tr><td scope="row"><pre>cmd[3] = cmd[4] = cmd[5] = cmd[6] = cmd[7] = 0xff;<span></span></pre></td></tr><tr><td scope="row"><pre>size = 8;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//Error-checking by examining ‘result’ is not shown here.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>result = (*avcInterface)->open( avcInterface );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//In the call to setMessageCallback, avcMessage is the completion routine<span></span></pre></td></tr><tr><td scope="row"><pre>//that forwards AV/C bus status messages from the I/O Kit.<span></span></pre></td></tr><tr><td scope="row"><pre>(*avcInterface)->setMessageCallback( avcInterface, theDevice, avcMessage );<span></span></pre></td></tr><tr><td scope="row"><pre>(*avcInterface)->addCallbackDispatcherToRunLoop( avcInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopGetCurrent() );<span></span></pre></td></tr><tr><td scope="row"><pre>result = (*avcInterface)->AVCCommand( avcInterface, cmd, 8, response, &amp;size<span></span></pre></td></tr><tr><td scope="row"><pre>    );<span></span></pre></td></tr></table></div><p>Next, the <code>withIOService:</code> method passes the IOFireWireAVCUnit object’s GUID property and the IOFireWireDevice service type to the <code>findPluginForDevice</code> function to get an IOCFPlugInInterface for the corresponding device object. It then gets an IOFireWireDeviceInterface for the device object and uses interface functions to add a callback dispatcher to the current run loop and open the device, as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>IOFireWireLibDeviceRef  resultInterface;<span></span></pre></td></tr><tr><td scope="row"><pre>(*resultInterface)->AddCallbackDispatcherToRunLoop( resultInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopGetCurrent() );<span></span></pre></td></tr><tr><td scope="row"><pre>(*resultInterface)->Open( resultInterface );<span></span></pre></td></tr></table></div><p>Finally, the <code>withIOService:</code> method uses the instance method <code>readQuad:</code> to call the IOFireWireDeviceInterface function <code>ReadQuadlet</code> with the addresses of the master output and input plugs, as <span class="content_text"><a href="FWChapter.html#//apple_ref/doc/uid/TP40000969-CH203-CCHDJDCH">Listing 3-10</a></span> shows.</p><a name="//apple_ref/doc/uid/TP40000969-CH203-CCHDJDCH" title="Listing 3-10Reading the plug control registers of an external AV/C device"></a><p class="codesample"><strong>Listing 3-10&nbsp;&nbsp;</strong>Reading the plug control registers of an external AV/C device</p><div class="codesample"><table><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre>AVCDevice *theDevice = [[self alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre>FWAddress addr;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 master;<span></span></pre></td></tr><tr><td scope="row"><pre>addr.addressHi = 0xffff;<span></span></pre></td></tr><tr><td scope="row"><pre>addr.addressLo = 0xf0000900;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//Read the master output plug.<span></span></pre></td></tr><tr><td scope="row"><pre>master = [theDevice readQuad:addr];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//Place results in the AVCDevice object ‘theDevice’.<span></span></pre></td></tr><tr><td scope="row"><pre>[theDevice setOutMax: [NSNumber numberWithUnsignedInt:(1 &lt;&lt; (master >> 30))<span></span></pre></td></tr><tr><td scope="row"><pre>    * 100]];<span></span></pre></td></tr><tr><td scope="row"><pre>[theDevice setOutBase: [NSNumber numberWithUnsignedInt:(master >> 24 &amp;<span></span></pre></td></tr><tr><td scope="row"><pre>    0x3f)]];<span></span></pre></td></tr><tr><td scope="row"><pre>[theDevice setOutNum: [NSNumber numberWithUnsignedInt:master &amp; 0x1f]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>addr.addressLo = 0xf0000980;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//Read the master input plug.<span></span></pre></td></tr><tr><td scope="row"><pre>master = [theDevice readQuad:addr];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//Place results in the AVCDevice object ‘theDevice’.<span></span></pre></td></tr><tr><td scope="row"><pre>[theDevice setInMax: [NSNumber numberWithUnsignedInt:(1 &lt;&lt; (master >> 30)) *<span></span></pre></td></tr><tr><td scope="row"><pre>    100]];<span></span></pre></td></tr><tr><td scope="row"><pre>[theDevice setInMax: [NSNumber numberWithUnsignedInt:(master >> 24 &amp; 0x3f)]];<span></span></pre></td></tr><tr><td scope="row"><pre>[theDevice setInMax: [NSNumber numberWithUnsignedInt:master &amp; 0x1f]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//The readQuad: instance method.<span></span></pre></td></tr><tr><td scope="row"><pre>-(UInt32)readQuad:(FWAddress)addr<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 val = 0xdeadbeef;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn status;<span></span></pre></td></tr><tr><td scope="row"><pre>    status = (*_interface)->ReadQuadlet( _interface, _device, &amp;addr, &amp;val,<span></span></pre></td></tr><tr><td scope="row"><pre>        kFWDontFailOnReset, 0 );<span></span></pre></td></tr><tr><td scope="row"><pre>    return val;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When the AVCBrowser project runs, the user can choose to open a particular AV/C device and view its type, packet speed, and number of input and output plugs. For each plug, the user can view information about it, such as if it is online and broadcasting.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../FWDevAccess/FWDevAccess.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../FWDevEndianness/FWDevEndianness.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WorkingWFireWireDI/FWDevInterfaces/FWChapter.html%3Fid%3DTP40000969-3.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WorkingWFireWireDI/FWDevInterfaces/FWChapter.html%3Fid%3DTP40000969-3.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WorkingWFireWireDI/FWDevInterfaces/FWChapter.html%3Fid%3DTP40000969-3.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>