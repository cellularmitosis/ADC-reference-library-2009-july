<html>	<head>		<title>EORelationship Concepts</title>	</head><BODY bgcolor=#ffffff>		<!-- start of header -->		<!--#include virtual="/includes/framesetheader" -->		<!-- end of header --><!-- start of path --><table cellspacing=0 border=0 width=600 valign="left"><tr><td scope="row"><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="../../../../../index.html" target="_top">Documentation</a> <b>></b> <a href="../../../../webobjects.html" target="_top">WebObjects</a></font></td></tr></table><br><!-- end of path -->		<a href="../../EOAccessTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> 		<h1><font color="#000066"><a name="//apple_ref/UNKNOWN_LANGUAGE/cl/EORelationship.Concepts">EORelationship.Concepts</a></font></h1>		<br>		<br>		<a name="CHJBBJID"></a>		<h2>Creating a Simple Relationship</h2>		<p>A simple relationship is defined by the attributes it compares in connecting its source and destination entities. Each source-destination pair of attributes is encapsulated in an EOJoin object. For example, to create a relationship from the Movie entity to the Studio entity, a join has to be created from the <b>studioId</b> attribute of the Movie entity to the same attribute of the Studio entity. The values of these two attributes must be equal for a match to result. Note that <b>studioId</b> is the primary key attribute for the Studio entity, so there can only be one studio per movie; this relationship is therefore to-one.</p>		<p>This code excerpt creates an EORelationship for the relationship described above and adds it to the EOEntity for the Movie entity:</p>		<blockquote>			<pre>EOEntity movieEntity;       // Assume this exists. EOEntity studioEntity;      // Assume this exists.EOAttribute studioIDAttribute;EOAttribute movieStudioIDAttribute;EOJoin toStudioJoin;EORelationship toStudioRelationship;    studioIDAttribute = studioEntity.attributeNamed(&quot;studioID&quot;);movieStudioIDAttribute = movieEntity.attributeNamed(&quot;studioID&quot;);	toStudioJoin = new EOJoin(movieStudioIDAttribute, studioIDAttribute);    toStudioRelationship = new EORelationship();toStudioRelationship.setEntity(movieEntity);toStudioRelationship.setName(&quot;studio&quot;);toStudioRelationship.addJoin(toStudioJoin);toStudioRelationship.setToMany(false);toStudioRelationship.setJoinSemantic(EORelationship.InnerJoin);</pre>		</blockquote>		<br>		<p>This code first gets the attributes from the source and destination entities, and then creates an EOJoin with them. Next, a new EORelationship is created, its name is set, and it's added to <b>movieEntity</b>. The EOJoin is added to the relationship and the relationship is set to be to-one. Finally, in the <b>setJoinSemantic</b> line, InnerJoin indicates that only objects that actually have a matching destination object will be included in the result when the relationship is traversed. </p>		<p>Creating a to-many relationship in the opposite direction merely swaps the source and destination attributes, and assigns the relationship to the EOEntity for the Studio entity:</p>		<blockquote>			<pre>EOJoin toMoviesJoin;EORelationship toMoviesRelationship;toMoviesJoin = new EOJoin(studioIDAttribute, movieStudioIDAttribute);toMoviesRelationship = new EORelationship();toMoviesRelationship.setName(&quot;movies&quot;);studioEntity.addRelationship(toMoviesRelationship);toMoviesRelationship.addJoin(toMoviesJoin);toMoviesRelationship.setToMany(true);toMoviesRelationship.setJoinSemantic(EORelationship.InnerJoin);</pre>		</blockquote>		<br>		<p>Note that this relationship is to-many precisely because the destination attribute isn't the primary key for its entity (Movie), and therefore isn't unique with regard to that entity.</p>		<p>A relationship isn't restricted to only one EOJoin. It's entirely possible for a relationship to be defined based on two or more attributes in the source and destination entities. For example, consider an employees database that contains a picture of each employee identified by first and last name. You'd define the relationship by joining each of the first and last names in the Employee entity to the same attribute in the <b>EmpPhoto</b> attribute.</p>		<p>A simple relationship is considered to reference all of the attributes in its joins. You can use the referencesProperty method to find out if an EORelationship references a particular attribute.</p>		<br>		<a name="CHJDAGED"></a>		<h2>Creating a Flattened Relationship</h2>		<p>A flattened relationship depends on several simple relationships already existing. Assuming that several do exist, creating a flattened relationship is straightforward. For example, suppose that the Movie entity has a to-many relationship to the Director entity, called <b>toDirectors</b>. The Director entity in turn has a relationship to the Talent entity called <b>toTalent</b>. In the Movies database, the Director table acts as an intermediate table between Movie and Talent. In this situation, it make sense to flatten the relationship Movies has to Director (<b>toDirectors</b>) to give Movie access to the Talent table through Director's <b>toTalent</b> relationship. For more discussion of when to use flattened relationships, see the chapters &quot;Designing Enterprise Objects&quot; and &quot;Advanced Enterprise Object Modeling&quot; in the <i>Enterprise Objects Framework Developer's Guide</i>.</p>		<p>This code excerpt creates a flattened relationship from Movie to Talent:</p>		<blockquote>			<pre>EOEntity movieEntity;   // Assume this exists.       EORelationship toDirectorsRelationship = new EORelationship();toDirectorsRelationship.setEntity(movieEntity);toDirectorsRelationship.setName(&quot;directors&quot;);toDirectorsRelationship.setDefinition:(&quot;toDirector.toTalent&quot;);movieEntity.addRelationship(toDirectorsRelationship);</pre>		</blockquote>		<br>		<p>All that's needed to establish the relationship is a data path (also called the definition) naming each component relationship connected, with the names separated by periods. Note that because the cardinality of a flattened relationship is determinable from its components, no setToMany message is required here.</p>		<p>A simple relationship is considered to reference all of the relationships in its definition, plus every attribute referenced by the component relationships. You can use the referencesProperty method to find out if an EORelationship references another relationship or attribute.</p>		<p>&copy; 2001 Apple Computer, Inc. (Last Published April 13, 2001)</p>		<br>		<a href="../../EOAccessTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> <!-- start of footer -->		<!--#include virtual="/includes/framesetfooter" -->		<!-- end of footer -->	</body></html>