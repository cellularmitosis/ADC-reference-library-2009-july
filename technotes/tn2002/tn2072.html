<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><HEAD><title>Technical Note TN2072: FireWire: DCL Programs Under Mac OS X</title><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><meta name="keywords" content="FireWire DCL Hardware DV isoch isochronous Trogdor"><meta name="Description" content="Describes the structure and creation of DCL programs under Mac OS X."><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR=WHITE><a name="//apple_ref/doc/uid/DTS10003108" title="FireWire: DCL Programs Under Mac OS X"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/HardwareDrivers/index.html">Hardware & Drivers</a> &gt; <a href="../../technicalnotes/HardwareDrivers/idxFireWire-date.html">FireWire</a> &gt; </p><!-- end_header_information --><!-- begin_titles_information --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN2072</div>
<div id="pageheadsub">FireWire: DCL Programs Under Mac OS X</div>
</h1>
</td></tr></table></CENTER><!-- end_titles_information --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600> <TR> <TD align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0"><tr><td width=300 valign="top" align=left scope="row"><table border="0" width="300" cellpadding="0" cellspacing="0"><tr>            <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td></tr><tr bgcolor="#e6e6e6"><td background="images/tnmenubody.gif" width=300 align=left><span id="menutitle">CONTENTS<br><br></span></td></tr><tr bgcolor="#e6e6e6"><td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc -->                    <p id="menutext"><A HREF="#Section1">What is DCL?</A><BR><BR><A HREF="#Section2">DCL commands</A><BR><BR><A HREF="#Section3">Structure and execution of a DCL program</A><BR><BR><A HREF="#Section4">Allocating buffers</A><BR><BR><A HREF="#Section5">What data is received?</A><BR><BR><A HREF="#Section11">What data is transmitted?</A><BR><BR><A HREF="#Section6">DCL program strategies</A><BR><BR><A HREF="#Section7">Receiving variable size packets</A><BR><BR><A HREF="#Section8">Transmitting variable size packets</A><BR><BR><A HREF="#Section9">A word about threads</A><BR><BR><A HREF="#Section10">Summary</A><BR><BR><A HREF="#References">Related Materials</A></P> <!-- end_toc --> </td></tr><tr><td width=300 align=left scope="row"><img src="images/tnmenubottom.gif" alt="" width=300 height=16></td></tr></table></td><td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note offers advice and tips on writing DCL programs for isochronous FireWire devices.</p><p id="introtext">This Technical Note is primarily directed at developers who are writing user space code to get data from or send data to isochronous FireWire devices.</p><p id="introtext">You should be familiar with general I/O Kit and device interface concepts presented in <A href="../../documentation/Darwin/General/AccessingHardware/">"Accessing Hardware From Applications"</A>.</p><p id="introtext">Also you will find the examples and documentation in the FireWire SDK for Mac OS X helpful in your efforts. The current FireWire SDK is available <A HREF="http://developer.apple.com/sdk/index.html#FireWireX">here</A>.</p><p id="introtext">A detailed description of the FireWire specification is beyond the scope of this document. For more information, see Apple's <A HREF="http://developer.apple.com/firewire/">FireWire technology page</A> and the <A HREF="http://1394ta.org">1394 Trade Association</A> website.</p><!-- end_intro_text -->         <!-- begin_date --><H4 ALIGN=center>[Jun 21, 2003]</H4><!-- end_date --></TD></TR></TABLE><BR><BR><!-- end_table_box --><A NAME="Section1"></A><h2>What is DCL?</h2><P>The Datastream Control Language (DCL) is a set of commands that control data flow in to or out of a data stream. A DCL program consists of a number of DCL commands collected together into a linked list. A DCL program is associated with and controls a particular data stream, for example an isochronous channel.</P><P><A HREF="#top">Back to top</A></P><BR><BR><A NAME="Section2"></A><h2>DCL commands</h2><P>This section describes the DCL commands available for use in your DCL program. Each command is allocated using the <code>AllocateXXXDCL</code> methods provided by the <code>IOFireWireLibDCLCommandPool</code> interface, where "<code>XXX</code>" is one of the DCL commands, for example <code>AllocateSendPacketStartDCL</code>.</P><ul>    <li>    <dl>    <dt><b><code>SendPacketStart</code></b></dt>        <dd>Specifies the first part (or all) of a packet buffer to be sent to a data stream. An isochronous packet header will be generated for you.        </dd>    </dl>    </li>        <li>    <dl>    <dt><b><code>SendPacketWithHeaderStart</code></b></dt>        <dd>Specifies the first part (or all) of a packet buffer including an isochronous packet header to be sent to a data stream. The first quadlet of this buffer must be the 1394 isochronous packet header you wish sent with this packet.        </dd>    </dl>    </li>    <li>    <dl>    <dt><b><code>SendPacket</code></b></dt>        <dd>Specifies additional bytes to be appended to the previous <code>Send</code> command.        </dd>    </dl>    </li>    <li>    <dl>    <dt><b><code>ReceivePacketStart</code></b></dt>        <dd>Specifies a buffer that will receive the first part (or all) of a packet from a data stream.        </dd>    </dl>    </li>    <li>    <dl>    <dt><b><code>ReceivePacket</code></b></dt>        <dd>Specifies a buffer that will receive the next packet from a data stream.          </dd>    </dl>    </li>    <li>    <dl>    <dt><b><code>CallProc</code></b></dt>        <dd>When this command is executed a user provided callback function is invoked. Note that the DCL program <em>does not wait</em> for the callback to return, it continues to execute <em>independently</em> of the CPU. See <A HREF="#Section3">Structure and Execution of a DCL Program</A>.        </dd>    </dl>    </li>    <li>    <dl>    <dt><b><code>Label</code></b></dt>        <dd>Specifies a location in the DCL program that can be used as the target of a <code>Jump</code> command.        </dd>    </dl>    </li>    <li>    <dl>    <dt><b><code>Jump</code></b></dt>        <dd>Used to change the flow of the DCL program execution by jumping to a <code>Label</code> (see above).        </dd>    </dl>    </li>    <li>    <dl>    <dt><b><code>SetTagSyncBits</code></b></dt>        <dd>Specifies the tag and sync bits in the isochronous packet header for packets that are sent to a data stream.        </dd>    </dl>    </li>    <li>    <dl>    <dt><b><code>TimeStamp</code></b></dt>        <dd>This command takes a pointer to a timestamp variable (a pointer to a 32 bit value). The variable will be filled in when the <code>TimeStamp</code> command is updated by an <code>UpdateDCLList</code> command (see above).<BR>The timestamp is a 16-bit value as defined in the 1394 Open Host Controller Interface Specification v1.1, section 7.1.5.3:<BR><P ALIGN=center><img src="images/tn2072_1.jpg" alt="" width="226" height="60" align="middle"></P><P ALIGN=center>Figure 1. Timestamp</P><P>When copied to your timestamp variable the 16 bit value shown in Figure 1., above, is placed in the high order 16 bits. The low order 16 bits of your timestamp variable are set to zero.</P>        </dd>    </dl>    </li>    <li>    <dl>    <dt><b><code>UpdateDCLList</code></b></dt>        <dd>This command is used to update a list of <code>Send</code>, <code>Receive</code>, or <code>TimeStamp</code> commands. For example it prepares receive or send buffers by byte-swapping packet headers and copies time stamp information into the timestamp pointed to by a <code>TimeStamp</code> command.<BR><BR>Updating is performed by the CPU: keep in mind that while the updating is performed, the DCL program <em>continues to run independently of the CPU</em>.<BR><BR>Note that the very first time a transmit DCL command runs, you don't need an update step. This is because the FireWire software does the update before it starts the DCL program. However you must update a transmit DCL command before it is run again.<BR><BR>Receive DCLs must always be updated before you look at the buffers. The update handles any byte-swapping or endian issues.<BR><BR>Timestamp DCLs must always be updated before you read the timestamp. The update process generates the timestamp.        </dd>    </dl>    </li><BR>    <li>    <dl>    <dt><b>Unimplemented commands</b></dt>        <dd>Certain DCL commands are not currently implemented, even though they do have a method to allocate them in the <code>IOFireWireLibDCLCommandPool</code> interface. Therefore, do not use the following methods when writing your DCL programs:<BR><P><code>AllocateTransferBufferDCL</code></P><P><code>AllocateReceiveBufferDCL</code></P><P><code>AllocateSendBufferDCL</code></P>    </dd>    </dl>    </li></ul><P><A HREF="#top">Back to top</A></P><BR><BR><A NAME="Section3"></A><h2>Structure and execution of a DCL program</h2><P>A DCL program is essentially a linked list of DCL commands. The program is compiled and run on the FireWire hardware <em>independently</em> of the CPU. In other words the DCL program <em>runs in hardware in real time</em>. This has certain implications that will be explored further in the section <A HREF="#Section6">DCL program strategies</A>.</P><P>DCL programs are executed in linked list order starting with the first DCL command in the list. The order of execution can be modified by use of <code>Jump</code> commands that can redirect program execution to a specific <code>Label</code>. You can create quite complex programs using <code>Jump</code> and <code>Label</code> commands and you can even modify the destination of a <code>Jump</code> command while the program is running. Using <code>Jump</code> and <code>Label</code> commands is explored more in the section <A HREF="#Section6">DCL program strategies</A>.</P><P>Each DCL command has a field <code>pNextDCLCommand</code> that points to the next DCL command in the program. To indicate the end of the DCL program, set the <code>pNextDCLCommand</code> in the last DCL command of the program to zero.  Even if the last DCL command is a <code>Jump</code> back to the top of the program, the <code>pNextDCLCommand</code> field must be set to zero to mark the end of the program. If the <code>pNextDCLCommand</code> field is not zero it's likely you will hang the DCL compiler.</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><TD BGCOLOR="#E6E6E6"><P><B>Note:</B><BR>Typically a DCL program will contain a number of <code>ReceivePacketStart</code> or <code>SendPacketStart</code> commands. Though available, the <code>ReceivePacket</code> and <code>SendPacket</code> commands are generally not used.</P></TD></TR></TABLE></CENTER><BR><P>There are three basic rules to follow when writing DCL programs:</P><ul>    <li>    A <code>Label</code> command must be followed immediately by a <code>SendPacketStart</code> or <code>ReceivePacketStart</code> command.    </li>    <li>    An <code>UpdateDCLList</code> or <code>CallProc</code> command must directly follow a <code>SendPacketStart</code> or <code>ReceivePacketStart</code> command, or an <code>UpdateDCLList</code> or <code>CallProc</code> command that directly follows a <code>SendPacketStart</code> or <code>ReceivePacketStart</code> command.    </li>        <li>For best results make sure that your packet buffers don't cross page boundaries (more about this later).    </li></ul><P><BR><H3>A simple example:</H3>The simplest DCL program for receiving packets consists of a <code>Label</code>, some number of <code>ReceivePacketStart</code> commands, an <code>UpdateDCLList</code>, and a <code>CallProc</code>. For example:</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><TD BGCOLOR="#E6E6E6"><pre>LabelReceivePacketStartReceivePacketStartReceivePacketStartReceivePacketStartReceivePacketStartUpdateDCLListCallProc</pre></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><TD BGCOLOR="#E6E6E6"><pre>Address    DCL command          pNexDCLCommand points to:0001       Label                  00020002       ReceivePacketStart     00030003       ReceivePacketStart     00040004       ReceivePacketStart     00050005       ReceivePacketStart     00060006       ReceivePacketStart     00070007       UpdateDCLList          00080008       CallProc               NULL (end of DCL program)</pre></TD></TR></TABLE></CENTER><BR><P>This DCL program would receive 5 packets, update the received data to handle any endian issues, then call the user supplied callback function to alert your code that the 5 packets had been received and were ready to be read.</P><P><BR><H3>A looping example:</H3>A slightly more complicated example involves setting up continuous reception of data from the data stream by using a <code>Jump</code> command to create a loop:</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><TD BGCOLOR="#E6E6E6"><pre>Label1ReceivePacketStart(198 ReceivePacketStart commands)ReceivePacketStartUpdateDCLListCallProcJump Label1</pre></TD></TR></TABLE></CENTER><BR>This DCL program would receive a total of 200 packets (total of 200  <code>ReceivePacketStart</code> commands), update the received data, call the user supplied callback function, then loop back to <code>Label1</code> and begin receiving data again.<BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550><TR><TD BGCOLOR="#E6E6E6"><P><B>IMPORTANT:</B><BR>The DCL program above is only an example showing looping and is <em>not</em> a practical implementation for receiving data. See the section <A HREF="#Section6">DCL program strategies</A> for details.</P></TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><BR><BR><A NAME="Section4"></A><h2>Allocating buffers</h2><P>When allocating a buffer for your packets use <code>vm_allocate</code> to create the buffer and <code>vm_deallocate</code> to release the buffer when you are finished with it. In addition, you will get best performance if your DCL data buffers do not cross page boundaries.</P><P>A good strategy is to calculate how many of your packets will fit into a virtual memory page, allocate the memory as a single block, and carve it up into your packet buffers. You don't have to worry about page-aligning the memory since <code>vm_allocate</code> always returns page-aligned memory.</P><P>How big is a virtual memory page? You can use <code>getpagesize</code> (defined in <code>unistd.h</code>) to calculate your allocation size and to align your buffer(s) to ensure that they aren't crossing page boundaries.</P><BR>Example:<BR><BR>Suppose you need 500 buffers, each of which will be 800 bytes, becauseyou are receiving packets that are up to 800 bytes long (including the isochronous header).If you just allocated an array of 500 x 800, many of the buffers would cross page boundaries. Currently a virtual memory page = 4096 (4kB), so you can calculate how many 800-byte buffers fit neatly into a 4kB page: <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>    <TD BGCOLOR="#E6E6E6"><PRE>4096 / 8 = 5 buffers/page (with 96 bytes left over on each page)500 buffers / 5 buffers/page = 100 pages</PRE>    </TD></TR></TABLE></CENTER><P>Since <code>vm_allocate</code> is guaranteed to give you page-aligned memory, you don't have to worry about page-aligning the returned memory:</P><!-- listing starts here --><CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=550><TR><TD><P><B>Listing 1</B>. Allocating page-aligned buffers.</P></TD></TR><TR><TD BGCOLOR="#E6E6E6"><PRE>kern_return_t    result;vm_address_t    p, savePtr;vm_size_t    allocSize;allocSize = 100 * getpagesize();    // size of memory allocation// allocate memory at any addressresult = vm_allocate( current_task(),                      &amp;p,                      allocSize,                      FALSE );        if( KERN_SUCCESS == result ){    savePtr = p;    // save the ptr for later vm_deallocate    // now p points to 100 pages beginning at a page-aligned address.    ...}...// when all doneresult = vm_deallocate( current_task(), savePtr, allocSize );</PRE></TD></TR></TABLE></CENTER><!-- listing ends here --><P><A HREF="#top">Back to top</A></P><BR><BR><A NAME="Section5"></A><h2>What data is received?</h2><P>The data in the receive buffers consists of the 4 byte isochronous packet header followed by the data payload from the received packet. The CRC quadlets for the isochronous header and the payload are not placed in the receive buffer.</P><P>This implies that each packet receive buffer needs to be payloadSize + 4 bytes in length.</P><P><A HREF="#top">Back to top</A></P><BR><BR><A NAME="Section11"></A><h2>What data is transmitted?</h2><P>If you are using a <code>SendPacketStart</code> command an isochronous packet header is generated for you and the data in the transmit buffer becomes the payload for that packet.</P><P>If you are using a <code>SendPacketWithHeaderStart</code> you must generate your own isochronous packet header. The packet header will be the first quadlet in the transmit buffer followed immediately by the payload data.</P><P>In either case the CRC quadlets for the isochronous packet header and payload are generated for you.</P><P><A HREF="#top">Back to top</A></P><BR><BR><A NAME="Section6"></A><h2>DCL program strategies</h2><P>Generally, for continuous streams of data, you want your DCL program to have several segments. This is because the FireWire hardware continues running the DCL program <em>while your <code>CallProc</code> is executing</em>. Therefore you must provide enough buffers to continue receiving the incoming packets while your <code>CallProc</code> is executing.</P><P>The FireWire hardware DMAs incoming packets directly into your buffers. If your DCL program has a loop or loops in it, you run the risk of having the DMA wrap around and overwrite the already received data. This can happen if your <code>CallProc</code> is delayed, or if you spend too much time in your <code>CallProc</code>.</P><P>A better DCL program that provides a mechanism to detect if there has been an overrun is shown here:</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><TD BGCOLOR="#E6E6E6"><pre>    Label 1    ReceivePacketStartOp x 200    Timestamp (optional)    Update (200 packets + timestamp)    CallProc A    Jump A -&gt; Label 2    Label 2    ReceivePacketStartOp x 200    Timestamp (optional)    Update (200 packets + timestamp)    CallProc B    Jump B -&gt; Label 3    Label 3    ReceivePacketStartOp x 200    Timestamp (optional)    Update (200 packets + timestamp)    CallProc C    Jump C -&gt; Label 4    Label 4    ReceivePacketStartOp (just one, to satisfy the rules above)    CallProc D    (end = link to next DCL == NULL)</pre></TD></TR></TABLE></CENTER><BR>Here's how it works:<ol>    <li>When <code>CallProc A</code> is run it does whatever processing of the data is necessary and then it modifies two of the <code>Jump</code> commands. It modifies <code>Jump A</code> to point to <code>Label 4</code> and it modifies <code>Jump C</code> to point to <code>Label 1</code>:<BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><TD BGCOLOR="#E6E6E6"><pre>    Label 1    ReceivePacketStartOp x 200    Timestamp (optional)    Update (200 packets + timestamp)    CallProc A-&gt;  Jump A -&gt; Label 4    Label 2    ReceivePacketStartOp x 200    Timestamp (optional)    Update (200 packets + timestamp)    CallProc B    Jump B -&gt; Label 3    Label 3    ReceivePacketStartOp x 200    Timestamp (optional)    Update (200 packets + timestamp)    CallProc C-&gt;  Jump C -&gt; Label 1    Label 4    ReceivePacketStartOp (just one, to satisfy the rules above)    CallProc D    (end = link to next DCL == NULL)</pre></TD></TR></TABLE></CENTER><BR><P>This may seem like you are changing <code>Jump A</code> just before it executes, but you really are not. Remember: the DCL program continues to run and is well past <code>Jump A</code> before your <code>CallProc</code> is invoked.</P></li>    <li>When <code>CallProc B</code> is run it does whatever processing of the data is necessary and then it modifies two of the <code>Jump</code> commands. It modifies <code>Jump A</code> to point to <code>Label 2</code> and it modifies <code>Jump B</code> to point to <code>Label 4</code>:<BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><TD BGCOLOR="#E6E6E6"><pre>    Label 1    ReceivePacketStartOp x 200    Timestamp (optional)    Update (200 packets + timestamp)    CallProc A-&gt;  Jump A -&gt; Label 2    Label 2    ReceivePacketStartOp x 200    Timestamp (optional)    Update (200 packets + timestamp)    CallProc B-&gt;  Jump B -&gt; Label 4    Label 3    ReceivePacketStartOp x 200    Timestamp (optional)    Update (200 packets + timestamp)    CallProc C    Jump C -&gt; Label 1    Label 4    ReceivePacketStartOp (just one, to satisfy the rules above)    CallProc D    (end = link to next DCL == NULL)</pre></TD></TR></TABLE></CENTER><BR></li>    <li>When <code>CallProc C</code> is run it does whatever processing of the data is necessary and then it modifies two of the <code>Jump</code> commands. It modifies <code>Jump B</code> to point to <code>Label 3</code> and it modifies <code>Jump C</code> to point to <code>Label 4</code>:<BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><TD BGCOLOR="#E6E6E6"><pre>    Label 1    ReceivePacketStartOp x 200    Timestamp (optional)    Update (200 packets + timestamp)    CallProc A    Jump A -&gt; Label 2    Label 2    ReceivePacketStartOp x 200    Timestamp (optional)    Update (200 packets + timestamp)    CallProc B-&gt;  Jump B -&gt; Label 3    Label 3    ReceivePacketStartOp x 200    Timestamp (optional)    Update (200 packets + timestamp)    CallProc C-&gt;  Jump C -&gt; Label 4    Label 4    ReceivePacketStartOp (just one, to satisfy the rules above)    CallProc D    (end = link to next DCL == NULL)</pre></TD></TR></TABLE></CENTER><BR></li></ol><P>This technique effectively "extends" the DCL program each time a <code>CallProc</code> is run. Another way to think about it is each time a <code>CallProc</code> is run you are moving the end of the program farther away from where it is currently executing.</P><P>If <code>CallProc D</code> is ever called then you know that the DCL program ran out of receive buffers because software was slow. This guarantees you will detect if a wraparound ever occurs and can take appropriate action.</P><P>The above example is equally applicable to DCL programs that send packets.</P><P><A HREF="#top">Back to top</A></P><BR><BR><A NAME="Section7"></A><h2>Receiving variable size packets</h2><P>Some isochronous streams will have variable size packets. To receive these packets, create your receive buffers so they are large enough to receive the largest packet you expect. Each buffer will receive one packet. The isochronous header is included as the first quadlet of each incoming packet. You can look at the header to see the actual payload size of each received packet. Make sure that your DCL program executes an <code>UpdateDCLList</code> command before you examine the header.</P><P><A HREF="#top">Back to top</A></P><BR><BR><A NAME="Section8"></A><h2>Transmitting variable size packets</h2><P>Currently Mac OS X does not support changing the data size of a transmit DCL on the fly. If you need to transmit variable size packets it is still possible to do so provided that you know ahead of time the order and sizes of all packets you are transmitting. Construct your DCL program with a number of segments, each segment responsible for a different packet size. By careful manipulation of the targets of your <code>Jump</code> DCLs during your <code>CallProc</code>s you can create a stream of variable sized packets.</P><P><A HREF="#top">Back to top</A></P><BR><BR><A NAME="Section9"></A><h2>A word about threads</h2><P>Timely scheduling of your DCL CallProcs is essential to efficient data transmission and reception. A good technique to ensure this is to have your DCL CallProcs run on a separate real-time thread:</P><ol>    <li>    Create a thread that you will use for reception or transmission. Note that each thread has its own CFRunLoop.    <br>    </li>    <li>    Use the <code>AddCallbackDispatcherToRunLoop</code> and <code>AddIsochCallbackDispatcherToRunLoop</code> methods to add the callback dispatchers to the thread's CFRunLoop.    <br>    </li>    <li>    Use the Mach Thread API <code>thread_policy_set</code> to change your thread's priority to be a real-time thread. Using <code>thread_policy_set</code> is described in the book <I>Inside Mac OS X: Kernel Progamming</I>, chapter "Mach Scheduling and Thread Interfaces", section "Using the Mach Thread API to Influence Scheduling".    </li>        <li>    Run the thread's runloop by calling <code>CFRunLoopRun</code>.    </li>    </ol><P><A HREF="#top">Back to top</A></P><BR><BR><A NAME="Section10"></A><h2>Summary</h2><P>DCL programs can be tricky. Program structure, allocation of buffers, and proper handling of <code>CallProc</code>s are vital to creating an efficient and robust DCL program. By using the techniques described in this Technical note you can avoid many headaches and ensure that your DCL program does what you expect.</P><P><A HREF="#top">Back to top</A></P><BR><BR><!-- put additional content here --><A NAME="References"></A><H2>Related Materials</H2><CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550><TR><TD align=left><P><A HREF="http://developer.apple.com/sdk/index.html#FireWireX">FireWire SDK for Mac OS X</A></P><P><Ahref="../../documentation/Darwin/General/AccessingHardware/">Inside Mac OS X: Accessing Hardware From Applications</A></P><P><Ahref="../../documentation/Darwin/General/KernelProgramming/">Inside Mac OS X: Kernel Programming</A></P><P><A HREF="http://developer.apple.com/firewire/">Apple FireWire technology page</A></P><P><A HREF="http://1394ta.org">1394 Trade Association</A></P></TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><BR><BR><!-- document_end_content --></TD></TR></TABLE></CENTER><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn2002/tn2072.html%3Fid%3DDTS10003108-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn2002/tn2072.html%3Fid%3DDTS10003108-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn2002/tn2072.html%3Fid%3DDTS10003108-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>