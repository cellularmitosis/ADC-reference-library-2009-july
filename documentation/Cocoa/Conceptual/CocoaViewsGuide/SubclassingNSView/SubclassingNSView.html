<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>View Programming Guide for Cocoa: Creating a Custom View</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Creating a Custom View"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002978-CH7" title="Creating a Custom View"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40002978-CH1-SW1">View Programming Guide for Cocoa</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WorkingWithAViewHierarchy/WorkingWithAViewHierarchy.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AdvancedSubclassing/AdvancedSubclassing.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40002978-CH7-SW4" title="Creating a Custom View"></a><h1>Creating a Custom View</h1><p>The <code>NSView</code> class acts mainly as an abstract superclass; generally you create instances of its subclasses, not of <code>NSView</code> itself. <code>NSView</code> provides the general mechanism for displaying content on the screen and for handling mouse and keyboard events, but its instances lack the ability to actually draw anything. If your application needs to display content or handle mouse and keyboard events in a specific manner, you'll need to create a custom subclass of <code>NSView</code>.</p><p>In order to provide a concrete example, this chapter describes the implementation of <code>DraggableItemView</code>, a subclass of <code>NSView</code>. The <code>DraggableItemView</code> class displays a simple item and allows the user to drag it within the view. The view also supports moving the item by pressing the arrow keys and setting the color of the item. It provides key-value-coding compliance for the location of the item, its color, and the background color of the view. The class illustrates the following view programming tasks:</p><ul class="ul"><li class="li"><p>Allocating and deallocating the view.</p></li><li class="li"><p>Drawing the view content.</p></li><li class="li"><p>Marking portions of the view for updating in response to value changes.</p></li><li class="li"><p>Responding to user-initiated mouse events.</p></li><li class="li"><p>Updating the cursor when the mouse is over the draggable item.</p></li><li class="li"><p>Responding to user-initiated key press events.</p></li><li class="li"><p>Implementing <code>NSResponder</code> action methods.</p></li><li class="li"><p>Providing key-value-coding compliant accessors for its settable properties.</p></li></ul><p>The <em><a href="../../../../../samplecode/DragItemAround/index.html#//apple_ref/doc/uid/DTS10003900" target="_top">DragItemAround</a></em> source code is available through Apple Developer Connection.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="SubclassingNSView.html#//apple_ref/doc/uid/TP40002978-CH7-SW20">Allocating the View</a>
				
			<br/>
			
        
			
			
				<a href="SubclassingNSView.html#//apple_ref/doc/uid/TP40002978-CH7-SW22">Drawing View Content</a>
				
			<br/>
			
        
			
			
				<a href="SubclassingNSView.html#//apple_ref/doc/uid/TP40002978-CH7-SW26">Responding to User Events and Actions</a>
				
			<br/>
			
        
			
			
				<a href="SubclassingNSView.html#//apple_ref/doc/uid/TP40002978-CH7-SW34">Property Accessor Methods</a>
				
			<br/>
			
        
			
			
				<a href="SubclassingNSView.html#//apple_ref/doc/uid/TP40002978-CH7-SW36">Deallocating the View</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002978-CH7-SW20" title="Allocating the View"></a><h2>Allocating the View</h2><p>Applications create a new instance of a view object using <code>initWithFrame:</code>, the designated initializer for the <code>NSView</code> class. A subclass can specify another method as its designated initializer, but the <code>initWithFrame:</code> method must provide the basic functionality required. As an example, the <code>NSTextView</code> implementation of <code>initWithFrame:</code> creates the entire collection of container objects associated with an <code>NSTextView</code> instance while the designated initializer, <code>initWithFrame:textContainer:</code> expects the underlying container objects to be provided explicitly. The <code>initWithFrame:</code> method creates the collection, and then calls <code>initWithFrame:textContainer:</code>. Your custom classes should take the same approach.</p><p>The <code>DraggableItemView</code> class overrides <code>initWithFrame:</code> and sets the exposed properties of the draggable item to the default values, as shown in <span class="content_text">Listing 4-1</span>.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW6" title="Listing 4-1DraggableItemView implementation of initWithFrame: "></a><p class="codesample"><strong>Listing 4-1&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>initWithFrame:</code> </p><div class="codesample"><table><tr><td scope="row"><pre>- (id)initWithFrame:(NSRect)frame {<span></span></pre></td></tr><tr><td scope="row"><pre>    self = [super initWithFrame:frame];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self) {<span></span></pre></td></tr><tr><td scope="row"><pre>          // setup the initial properties of the<span></span></pre></td></tr><tr><td scope="row"><pre>          // draggable item<span></span></pre></td></tr><tr><td scope="row"><pre>          [self setItemPropertiesToDefault:self];<span></span></pre></td></tr><tr><td scope="row"><pre>       }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>The code for initializing the item color, background color, and location of the draggable item is factored into a separate method. This allows the item's properties to be reset to their default values, shown later. The implementation in <span class="content_text">Listing 4-2</span> simply calls the accessor methods for the properties, providing the default values.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW3" title="Listing 4-2DraggableItemView implementation of setItemPropertiesToDefault:"></a><p class="codesample"><strong>Listing 4-2&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>setItemPropertiesToDefault:</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setItemPropertiesToDefault:sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setLocation:NSMakePoint(0.0,0.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setItemColor:[NSColor redColor]];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setBackgroundColor:[NSColor whiteColor]];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP40002978-CH7-SW21" title="Initializing View Instances Created in Interface Builder"></a><h3>Initializing View Instances Created in Interface Builder</h3><p>View instances that are created in Interface Builder don't call <code>initWithFrame:</code> when their nib files are loaded, which often causes confusion. Remember that Interface Builder archives an object when it saves a nib file, so the view instance will already have been created and <code>initWithFrame:</code> will already have been called.</p><p>The <code>awakeFromNib</code> method provides an opportunity to provide initialization of a view when it is created as a result of a nib file being loaded. When a nib file that contains a view object is loaded, each view instance receives an <code>awakeFromNib</code> message when all the objects have been unarchived. This provides the object an opportunity to initialize any attributes that are not archived with the object in Interface Builder. The <code>DraggableItemView</code> class is extremely simple, and doesn't implement <code>awakeFromNib</code>.</p><p>There are two exceptions to the <code>initWithFrame:</code> behavior when creating view instances in Interface Builder. Its important to understand these exceptions to ensure that your views initialize properly.</p><p>If you have not created an Interface Builder palette for your custom view, there are two techniques you can use to create instances of your subclass within Interface Builder. The first is using the <strong>Custom View</strong> proxy item in the Interface Builder containers palette. This view is a stand-in for your custom view, allowing you to position and size the view relative to other views. You then specify the subclass of <code>NSView</code> that the view represents using the inspector.  When the nib file is loaded by the application, the custom view proxy creates a new instance of the specified view subclass and initializes it using the <code>initWithFrame:</code> method, passing along any autoresizing flags as necessary. The view instance then receives an <code>awakeFromNib</code> message. </p><p>The second technique is to specify a custom class is used when your custom view subclass inherits from a view that Interface Builder provides support for directly. For example, you can create an <code>NSScrollView</code> instance in Interface Builder and specify that a custom subclass (<code>MyScrollView</code>) should be used instead, again using the inspector. In this case, when the nib file is loaded by the application, the view instance has already been created and the <code>MyScrollView</code> implementation of <code>initWithFrame:</code> is never called. The <code>MyScrollView</code> instance receives an <code>awakeFromNib</code> message and can configure itself accordingly. </p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW22" title="Drawing View Content"></a><h2>Drawing View Content</h2><p>Rather than drawing immediately when it determines that drawing is necessary, Cocoa uses a deferred drawing mechanism.  An application typically marks a view or a portion of a view as requiring update. At the end of the event loop or in response to an explicit display request, the view machinery locks focus on the view and calls the view's <code>drawRect:</code> method to cause the view to be redrawn. By coalescing update requests in this manner, an application can reduce redundant drawing, increasing performance.</p><p>If you need to force immediate drawing of a view, send the view one of the <code>display...</code> messages declared by both <code>NSView</code> and <code>NSWindow</code>. You can also lock focus on a view yourself, draw something, and then unlock focus. However, posting deferred drawing requests through the <code>setNeedsDisplay:</code> or <code>setNeedsDisplayInRect:</code> methods is the preferred approach because it is more efficient.</p><p>In addition to drawing to the screen, views are responsible for providing the content when printing. As with displaying to the screen, the Application Kit locks focus on the view and calls the view's <code>drawRect:</code> method. While it is drawing a view can determine if it is drawing to the screen or another device and customize its output appropriately. Views can also customize their printed output by adding headers and footers as well as customizing pagination. See <em><a href="../../Printing/index.html#//apple_ref/doc/uid/10000083i" target="_top">Printing Programming Topics for Cocoa</a></em> for more information on the Cocoa printing architecture and views.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW23" title="Implementing the drawRect: Method"></a><h3>Implementing the drawRect: Method</h3><p>In order for a concrete subclass of <code>NSView</code> to display any kind of content, it need only implement the <code>drawRect:</code> method. This method is invoked during the display process to generate code that’s rendered by the window server into a raster image. <code>drawRect:</code> takes a single argument, a rectangle describing the area that needs to be drawn in the receiver’s own coordinate system.</p><p>The <code>DraggableItemView</code> implementation of <code>drawRect:</code> fills the bounds of the view with the specified background color. It then calculates the bounds of the draggable item (<span class="content_text">Listing 4-3</span>) and fills it with the specified color. </p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW18" title="Listing 4-3DraggableItemView implementation of calculatedItemBounds:"></a><p class="codesample"><strong>Listing 4-3&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>calculatedItemBounds:</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (NSRect)calculatedItemBounds<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect calculatedRect;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // calculate the bounds of the draggable item<span></span></pre></td></tr><tr><td scope="row"><pre>    // relative to the location<span></span></pre></td></tr><tr><td scope="row"><pre>    calculatedRect.origin=location;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // the example assumes that the width and height<span></span></pre></td></tr><tr><td scope="row"><pre>    // are fixed values<span></span></pre></td></tr><tr><td scope="row"><pre>    calculatedRect.size.width=60.0;<span></span></pre></td></tr><tr><td scope="row"><pre>    calculatedRect.size.height=20.0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return calculatedRect;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>The complete implementation of <code>drawRect:</code> is shown in <span class="content_text">Listing 4-4</span>.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW1" title="Listing 4-4DraggableItemView implementation of drawRect:"></a><p class="codesample"><strong>Listing 4-4&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>drawRect:</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (void)drawRect:(NSRect)rect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // erase the background by drawing white<span></span></pre></td></tr><tr><td scope="row"><pre>    [[NSColor whiteColor] set];<span></span></pre></td></tr><tr><td scope="row"><pre>    [NSBezierPath fillRect:rect];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // set the current color for the draggable item<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self itemColor] set];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // draw the draggable item<span></span></pre></td></tr><tr><td scope="row"><pre>    [NSBezierPath fillRect:[self calculatedItemBounds]];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Sending drawing instructions and data to the window server has a cost, and it’s best to minimize that cost where possible. You can do this by testing whether a particular graphic shape intersects the rectangle that the <code>drawRect:</code> method is asked to draw. See <span class="content_text"><a href="../Optimizing/Optimizing.html#//apple_ref/doc/uid/TP40002978-CH11-SW1">“Optimizing View Drawing”</a></span> for more information, as well as additional performance recommendations.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002978-CH7-SW24" title="Note"></a><p><strong>Note:</strong>&nbsp;The implementation of the <code>NSView</code> class before Mac OS X v10.4.3 could discard any rectangles marked as needing display within a subclass's implementation of <code>drawRect:</code>. For maximum compatibility, when marking areas as requiring display from within the <code>drawRect:</code> method it is best to call the view's <code>setNeedsDisplayInRect:</code> method using the <code>NSObject</code> instance method <code>performSelector:withObject:afterDelay:</code>. </p></div><a name="//apple_ref/doc/uid/TP40002978-CH7-SW25" title="Marking a View as Needing Display"></a><h3>Marking a View as Needing Display</h3><p>The most common way of causing a view to redisplay is to tell it that its image is invalid. On each pass through the event loop, all views that need to redisplay do so. <code>NSView</code> defines two methods for marking a view’s image as invalid: <code>setNeedsDisplay:</code>, which invalidates the view’s entire bounds rectangle, and <code>setNeedsDisplayInRect:</code>, which invalidates a portion of the view. The automatic display of views is controlled by their window; you can turn this behavior off using the <code>NSWindow</code> <code>setAutodisplay:</code> method. You should rarely need to do this, however; the autodisplay mechanism is well suited to most kinds of update and redisplay.</p><p>The autodisplay mechanism invokes various methods that actually do the work of displaying. You can also use these methods to force a view to redisplay itself immediately when necessary. <code>display</code> and <code>displayRect:</code> are the counterparts to the methods mentioned above; both cause the receiver to redisplay itself regardless of whether it needs to or not. Two additional methods, <code>displayIfNeeded</code> and <code>displayIfNeededInRect:</code>, redisplay invalidated rectangles in the receiver if it’s been marked invalid with the methods above. The rectangles that actually get drawn are guaranteed to be at least those marked as invalid, but the view may coalesce them into larger rectangles to save multiple invocations of <code>drawRect:</code>.</p><p>If you want to exclude background views from drawing when forcing display to occur unconditionally, you can use <code>NSView</code> methods that explicitly omit backing up to an opaque ancestor. These methods, are <code>displayRectIgnoringOpacity:</code>, <code>displayIfNeededIgnoringOpacity</code>, and <code>displayIfNeededInRectIgnoringOpacity:</code>. </p><p>In the <code>DraggableItemView</code> example, <code>setNeedsDisplayInRect:</code> is called when the draggable item's location is set explicitly, when the location is being offset, and when the item's color is changed. When the background color is set, the entire view is marked as needing display.</p><p>From a design perspective, especially with the Model-View-Controller pattern in mind, it is best to ensure that calls to the <code>display...</code> methods be generated by the view itself, its superview, or a subview, rather than a controller or model object. It is better to inform the view that a model value is about to change, change the model value, and then inform the view that the change has occurred. This allows the view to invalidate the appropriate rectangles before and after the changes. Key-value observing and its change notification design is tailor-made for this use. See <em><a href="../../KeyValueObserving/index.html#//apple_ref/doc/uid/10000177i" target="_top">Key-Value Observing Programming Guide</a></em> for more information.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW2" title="View Opacity"></a><h3>View Opacity</h3><p>The <code>display...</code> methods must find an opaque background behind the view that requires displaying and begin drawing from there forward. The <code>display...</code> methods search up the view hierarchy to locate the first view that responds <code>YES</code> to an <code>isOpaque</code> message, bringing the invalidated rectangles along.</p><p>If a view instance can guarantee that it will fill all the pixels within its bounds using opaque colors, it should implement the method <code>isOpaque</code>, returning <code>YES</code>. The <code>NSView</code> implementation of <code>isOpaque</code> returns <code>NO</code>. Subclasses should override this method to return <code>YES</code> if all pixels within the view's content will be drawn opaquely.</p><p>The <code>isOpaque</code> method is called during drawing, and may be called several times for a given view in a drawing pass. Subclasses should avoid computationally intensive calculations in their implementation of the <code>isOpaque</code> method. Simple tests–for example determining if the background color is opaque as the <code>DraggableItemView</code> does–are acceptable. The <code>DraggableItemView</code> implementation is shown in <span class="content_text">Listing 4-5</span>.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW7" title="Listing 4-5DraggableItemView implementation of isOpaque"></a><p class="codesample"><strong>Listing 4-5&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>isOpaque</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)isOpaque<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // If the background color is opaque, return YES<span></span></pre></td></tr><tr><td scope="row"><pre>    // otherwise, return NO<span></span></pre></td></tr><tr><td scope="row"><pre>    return [[self backgroundColor] alphaComponent] >= 1.0 ? YES : NO;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP40002978-CH7-SW26" title="Responding to User Events and Actions"></a><h2>Responding to User Events and Actions</h2><p>Views are typically the receivers of most event and action messages. An <code>NSView</code> subclass overrides the appropriate event handling methods declared by the <code>NSResponder</code> class. When an instance of the custom view instance is the first responder, it receives the event messages as they are posted, before other objects.  Similarly, by implementing the action methods, often sent by other user interface objects such as menu items, when the custom view instance is the first responder, it receives those messages. See <em><a href="../../EventOverview/index.html#//apple_ref/doc/uid/10000060i" target="_top">Cocoa Event-Handling Guide</a></em> for a complete discussion on event handling and the responder chain.</p><p>Event messages are passed up the responder chain from the first responder. For all views, with the exception of a window's content view, a view's next responder is its superview. When view instances are inserted into the view hierarchy the next responder is set automatically. You should never send the <code>setNextResponder:</code> message directly to a view object. If you need to add objects to the responder chain, you should add them at the top of a window's responder chain—by subclassing <code>NSWindow</code> itself if it has no delegate, or the delegate class if it does.</p><p>As the class that handles display, <code>NSView</code> is typically the recipient of mouse and keyboard events. Mouse events start at the view that the click occurs in, and are passed up the responder chain. Keyboard events start at the first responder and are passed up the responder chain.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW19" title="Becoming First Responder"></a><h3>Becoming First Responder</h3><p>A view that is the first responder receives key events and action messages before other objects. Views can advertise that they can become the first responder by overriding the <code>acceptsFirstResponder</code> message and returning <code>YES</code>. The default <code>NSResponder</code> implementation returns <code>NO</code>. If a view is not the first responder it receives only mouse-down messages. Because the <code>DraggableItemView</code> object responds to basic key-down events, as well as the <code>NSResponder</code> action messages that are generated in response to pressing the arrow keys, it returns <code>YES</code> for <code>acceptsFirstResponder</code> as shown in <span class="content_text">Listing 4-6</span>.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW5" title="Listing 4-6DraggableItemView implementation of acceptsFirstResponder"></a><p class="codesample"><strong>Listing 4-6&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>acceptsFirstResponder</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)acceptsFirstResponder<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>A view receives a <code>becomeFirstResponder</code> message when the window attempts to make the view first responder. The default implementation of this method always returns <code>YES</code>. Similarly, when a view will resign as first responder it receives a <code>resignFirstResponder</code> message. To resign first responder status, <code>resignFirstResponder</code> returns <code>YES</code>. There may be valid reasons for a view to decline resigning first responder status, for example if an action is incomplete.</p><p>If a view becomes the first responder specifically to accept key events or <code>NSResponder</code> actions, it should reflect this by drawing a focus ring. The focus ring informs the user which object is the current first responder for key events. </p><p>Views that can become first responder and handle key events typically take part in the key view loop of a window. The key-view loop allows the user to switch between views in a window by pressing the Tab or Shift-Tab keys. <code>NSView</code> provides a number of methods for setting and getting the views in the key-view loop. Most often the key-view loop ordering is set in Interface Builder by connecting a view to another view's <code>nextKeyView</code> outlet.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW27" title="Handling Mouse Click and Dragging Events"></a><h3>Handling Mouse Click and Dragging Events</h3><p>Custom view subclasses can interpret mouse events in any way that is appropriate. Button type views send a target-action message, whereas clicking in a drawing view might select a graphic. There are four basic types of mouse events passed to a view: mouse down, mouse dragging, mouse up, and mouse movement.</p><p>By default a view does not receive mouse-down events if it isn't in the frontmost window, referred to as the key window. By overriding the <code>acceptsFirstMouse:</code> method and returning <code>YES</code>, the window becomes the key window immediately and acts upon the mouse-down.</p><p>Mouse-down events are sent when the user presses the mouse button while the cursor is in a view. If the window containing the view is not the key window, the window becomes the key window and discards the mouse-down event. An application can change this behavior, causing the initial mouse-down to make the window key and be passed to the appropriate view by overriding the <code>acceptsFirstMouse:</code> method and returning <code>YES</code>.</p><p>The window determines which view in the view hierarchy to send the mouse-down event using the <code>NSView</code> method <code>hitTest:</code>. Once the correct view is located, it is sent a <code>mouseDown:</code> event. There are corresponding mouse-down events posted for actions made with the right mouse button, as well as with other mouse buttons using the <code>rightMouseDown:</code> and <code>otherMouseDown:</code> methods respectively. The location of the mouse event in the coordinate system of the receiver's window is returned by sending the event object passed to the <code>mouseDown:</code> method a <code>locationInWindow</code> message. To translate the point to the view's coordinate system, use the method <code>convertPoint:fromView:</code> passing <code>nil</code> as the view parameter. <span class="content_text">Listing 4-7</span> illustrates the <code>DraggableItemView</code> subclass's implementation of the <code>mouseDown:</code> method.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW8" title="Listing 4-7DraggableItemView implementation of mouseDown:"></a><p class="codesample"><strong>Listing 4-7&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>mouseDown:</code></p><div class="codesample"><table><tr><td scope="row"><pre>-(void)mouseDown:(NSEvent *)event<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint clickLocation;<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL itemHit=NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // convert the mouse-down location into the view coords<span></span></pre></td></tr><tr><td scope="row"><pre>    clickLocation = [self convertPoint:[event locationInWindow]<span></span></pre></td></tr><tr><td scope="row"><pre>                  fromView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // did the mouse-down occur in the item?<span></span></pre></td></tr><tr><td scope="row"><pre>    itemHit = [self isPointInItem:clickLocation];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Yes it did, note that we're starting to drag<span></span></pre></td></tr><tr><td scope="row"><pre>    if (itemHit) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // flag the instance variable that indicates<span></span></pre></td></tr><tr><td scope="row"><pre>    // a drag was actually started<span></span></pre></td></tr><tr><td scope="row"><pre>    dragging=YES;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // store the starting mouse-down location;<span></span></pre></td></tr><tr><td scope="row"><pre>    lastDragLocation=clickLocation;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // set the cursor to the closed hand cursor<span></span></pre></td></tr><tr><td scope="row"><pre>    // for the duration of the drag<span></span></pre></td></tr><tr><td scope="row"><pre>    [[NSCursor closedHandCursor] push];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>This implementation gets the mouse-down location and converts it to the view's coordinate system. Since the dragging item subclass allows the user to drag the item only when the mouse-down event occurs in the draggable rectangle, the implementation calls the <code>isPointInItem:</code> method, shown in <span class="content_text">Listing 4-8</span> to test whether the mouse-down was within the draggable item's bounds. If it is, the dragging instance variable is set to <code>YES</code> to note that the view should not ignore <code>mouseDragged:</code> events. To better reflect to the user that a drag is in progress the cursor is set to the closed hand cursor.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW17" title="Listing 4-8DraggableItemView implementation of isPointInItem:"></a><p class="codesample"><strong>Listing 4-8&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>isPointInItem:</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)isPointInItem:(NSPoint)testPoint<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL itemHit=NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // test first if we're in the rough bounds<span></span></pre></td></tr><tr><td scope="row"><pre>    itemHit = NSPointInRect(testPoint,[self calculatedItemBounds]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // yes, lets further refine the testing<span></span></pre></td></tr><tr><td scope="row"><pre>    if (itemHit) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // if this was a non-rectangular shape, you would refine<span></span></pre></td></tr><tr><td scope="row"><pre>    // the hit testing here<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return itemHit;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Notice that the <code>mouseDown:</code> implementation in <span class="content_text">Listing 4-7</span> does not call the super implementation.  The <code>NSView</code> class's default implementation for the mouse handling events are inherited from <code>NSResponder</code> and pass the event up the responder chain for handling, bypassing the view in question entirely. Typically a custom <code>NSView</code> subclass should not call the super implementation of any of the mouse-event methods.</p><p>Views often need to track the dragging of the mouse after a mouse-down event is received. While the mouse button is held down and the mouse moves, the view receives <code>mouseDragged:</code> messages. The <code>DraggableItemView</code> implementation of <code>mouseDragged:</code> is shown in <span class="content_text">Listing 4-9</span>.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW9" title="Listing 4-9DraggableItemView implementation of mouseDragged:"></a><p class="codesample"><strong>Listing 4-9&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>mouseDragged</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>-(void)mouseDragged:(NSEvent *)event<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (dragging) {<span></span></pre></td></tr><tr><td scope="row"><pre>       NSPoint newDragLocation=[self convertPoint:[event locationInWindow]<span></span></pre></td></tr><tr><td scope="row"><pre>                                         fromView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>       // offset the item by the change in mouse movement<span></span></pre></td></tr><tr><td scope="row"><pre>       // in the event<span></span></pre></td></tr><tr><td scope="row"><pre>       [self offsetLocationByX:(newDragLocation.x-lastDragLocation.x)<span></span></pre></td></tr><tr><td scope="row"><pre>                          andY:(newDragLocation.y-lastDragLocation.y)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>       // save the new drag location for the next drag event<span></span></pre></td></tr><tr><td scope="row"><pre>       lastDragLocation=newDragLocation;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>       // support automatic scrolling during a drag<span></span></pre></td></tr><tr><td scope="row"><pre>       // by calling NSView's autoscroll: method<span></span></pre></td></tr><tr><td scope="row"><pre>       [self autoscroll:event];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>The view instance receives all the mouse-dragged notifications for the view, but the subclass is only interested in drag events that were initiated by mouse-down events in the draggable item itself. By testing the instance variable <code>dragging</code>, the view can determine whether the drag should be acted upon. If so, then the draggable item is offset by the change in mouse location since the last mouse event, which is tracked by the class's instance variable <code>lastDragLocation</code>. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002978-CH7-SW28" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>mouseDragged:</code> implementation shown in <span class="content_text">Listing 4-9</span> calls the <code>NSView</code> method <code>autoscroll:</code>, passing the event as the parameter. If a <code>DraggableItemView</code> instance is embedded in a scroll view, this causes the scroll view to automatically scroll when the mouse is dragged outside of the view. When the view is not contained within a scroll view, it does nothing. See Scroll View Programming Guide for more information.</p></div><p>The <code>offsetLocationByX:andY:</code> method called by the <code>mouseDragged:</code> method is shown in <span class="content_text">Listing 4-10</span>. It marks the draggable item's area as needing display before and after altering the item's location by the requested amount. If the view returns <code>YES</code> when sent an <code>isFlipped</code> message, the offset in the vertical direction is multiplied by -1 to correspond to the flipped view coordinates. In the <code>DraggableItemView</code> implementation the code is factored into its own method because it will be reused later.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW10" title="Listing 4-10DraggableItemView implementation of offsetLocationByX:andY:"></a><p class="codesample"><strong>Listing 4-10&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>offsetLocationByX:andY:</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (void)offsetLocationByX:(float)x andY:(float)y<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // tell the display to redraw the old rect<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setNeedsDisplayInRect:[self calculatedItemBounds]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // since the offset can be generated by both mouse moves<span></span></pre></td></tr><tr><td scope="row"><pre>    // and moveUp:, moveDown:, etc.. actions, we'll invert<span></span></pre></td></tr><tr><td scope="row"><pre>    // the deltaY amount based on if the view is flipped or<span></span></pre></td></tr><tr><td scope="row"><pre>    // not.<span></span></pre></td></tr><tr><td scope="row"><pre>    int invertDeltaY = [self isFlipped] ? -1: 1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    location.x=location.x+x;<span></span></pre></td></tr><tr><td scope="row"><pre>    location.y=location.y+y*invertDeltaY;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // invalidate the new rect location so that it'll<span></span></pre></td></tr><tr><td scope="row"><pre>    // be redrawn<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setNeedsDisplayInRect:[self calculatedItemBounds]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Finally, when the mouse button is released, the view receives a <code>mouseUp:</code> message. The <code>DraggableItemView</code> implementation shown in <span class="content_text">Listing 4-11</span> updates the dragging instance variable to indicate that the dragging action has completed and resets the cursor. The <code>invalidateCursorRectsForView:</code> message is discussed at the end of this section.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW11" title="Listing 4-11DraggableItemView implementation of mouseUp:"></a><p class="codesample"><strong>Listing 4-11&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>mouseUp:</code></p><div class="codesample"><table><tr><td scope="row"><pre>-(void)mouseUp:(NSEvent *)event<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    dragging=NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // finished dragging, restore the cursor<span></span></pre></td></tr><tr><td scope="row"><pre>    [NSCursor pop];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // the item has moved, we need to reset our cursor<span></span></pre></td></tr><tr><td scope="row"><pre>    // rectangle<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>A second technique for handling mouse dragging is sometimes used, commonly referred to as “short circuting” the event loop. An application can implement the <code>mouseDown:</code> method and loop continuously, collecting mouse-dragged events until the mouse-up event is received. Events that do not match the event mask remain in the event queue and are handled when the loop exists. </p><p>If the <code>DraggableItemView</code> class were to implement the same behavior using this technique, it would only implement the <code>mouseDown:</code> method, eliminating the <code>mouseDragged:</code> and <code>mouseUp:</code> method implementations. The <code>mouseDown:</code> implementation shown in <span class="content_text">Listing 4-12</span> uses the “short circuting” technique.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW12" title="Listing 4-12Alternate mouseDown: implementation"></a><p class="codesample"><strong>Listing 4-12&nbsp;&nbsp;</strong>Alternate <code>mouseDown:</code> implementation</p><div class="codesample"><table><tr><td scope="row"><pre>-(void)mouseDown:(NSEvent *)event<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL loop = YES;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint clickLocation;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // convert the initial mouse-down location into the view coords<span></span></pre></td></tr><tr><td scope="row"><pre>    clickLocation = [self convertPoint:[event locationInWindow]<span></span></pre></td></tr><tr><td scope="row"><pre>                  fromView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // did the mouse-down occur in the draggable item?<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([self isPointInItem:clickLocation]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // we're dragging, so let's set the cursor<span></span></pre></td></tr><tr><td scope="row"><pre>    // to the closed hand<span></span></pre></td></tr><tr><td scope="row"><pre>    [[NSCursor closedHandCursor] push];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint newDragLocation;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // the tight event loop pattern doesn't require the use<span></span></pre></td></tr><tr><td scope="row"><pre>    // of any instance variables, so we'll use a local<span></span></pre></td></tr><tr><td scope="row"><pre>    // variable localLastDragLocation instead.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint localLastDragLocation;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // save the starting location as the first relative point<span></span></pre></td></tr><tr><td scope="row"><pre>    localLastDragLocation=clickLocation;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while (loop) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // get the next event that is a mouse-up or mouse-dragged event<span></span></pre></td></tr><tr><td scope="row"><pre>        NSEvent *localEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>        localEvent= [[self window] nextEventMatchingMask:NSLeftMouseUpMask | NSLeftMouseDraggedMask];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        switch ([localEvent type]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case NSLeftMouseDragged:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // convert the new drag location into the view coords<span></span></pre></td></tr><tr><td scope="row"><pre>            newDragLocation = [self convertPoint:[localEvent locationInWindow]<span></span></pre></td></tr><tr><td scope="row"><pre>                        fromView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // offset the item and update the display<span></span></pre></td></tr><tr><td scope="row"><pre>            [self offsetLocationByX:(newDragLocation.x-localLastDragLocation.x)<span></span></pre></td></tr><tr><td scope="row"><pre>                       andY:(newDragLocation.y-localLastDragLocation.y)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // update the relative drag location;<span></span></pre></td></tr><tr><td scope="row"><pre>            localLastDragLocation=newDragLocation;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // support automatic scrolling during a drag<span></span></pre></td></tr><tr><td scope="row"><pre>            // by calling NSView's autoscroll: method<span></span></pre></td></tr><tr><td scope="row"><pre>            [self autoscroll:localEvent];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case NSLeftMouseUp:<span></span></pre></td></tr><tr><td scope="row"><pre>            // mouse up has been detected,<span></span></pre></td></tr><tr><td scope="row"><pre>            // we can exit the loop<span></span></pre></td></tr><tr><td scope="row"><pre>            loop = NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // finished dragging, restore the cursor<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSCursor pop];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // the rectangle has moved, we need to reset our cursor<span></span></pre></td></tr><tr><td scope="row"><pre>            // rectangle<span></span></pre></td></tr><tr><td scope="row"><pre>            [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        default:<span></span></pre></td></tr><tr><td scope="row"><pre>            // Ignore any other kind of event.<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>    return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<div class="notebox"><a name="//apple_ref/doc/uid/TP40002978-CH7-SW29" title="Note"></a><p><strong>Note:</strong>&nbsp;Short circuiting the event loop using this pattern has both advantages and disadvantages. A tight event loop provides more control over how other events interact with your application while a drag is in progress. This approach also typically requires less code and all the dragging variables are local to the method. It is more difficult for subclasses to override dragging behavior without re-implementing all the dragging code. Also, during a tight event loop, timers do not fire as expected and the application’s main thread is unable to process any other application requests. </p>Implementing the individual <code>mouseDown:</code>, <code>mouseDragged:</code>, and <code>mouseUp:</code> methods is often a better design choice when writing an event-driven application.  Each of the methods have a clearly defined scope, which often leads to clearer code. This approach also makes it much easier for subclasses to override behavior for handling mouse-down, mouse-dragged, and mouse-up events. However, this technique can require more code and instance variables. </p></div><a name="//apple_ref/doc/uid/TP40002978-CH7-SW30" title="Tracking Mouse Movements"></a><h3>Tracking Mouse Movements</h3><p>In addition to mouse-down, mouse-dragged, and mouse-up events, a view can also receive mouse-moved events. Mouse-moved events allow the view to track the location of the cursor whenever it is located above the view. By default, views don't receive mouse-moved events because they can occur very often, as a result clogging the event queue. </p><p>Mouse-moved events are initiated by the <code>NSWindow</code> instance that contains a view. In order for a view to receive mouse-moved events, it must explicitly request them by sending its window a <code>setAcceptsMouseMovedEvents:</code> message, passing <code>YES</code> as the parameter. When enabled, a view receives <code>mouseMoved:</code> events whenever the cursor is located within the view. Unfortunately, it is not possible to enable mouse-moved events for a single view using this technique.</p><p>The <code>NSView</code> class allows a view instance to register tracking rectangles. Registering an object as the owner of a tracking rectangle causes the owner to receive <code>mouseEntered:</code> and <code>mouseExited:</code> messages as the cursor enters and exists the rectangle. An application registers tracking rectangles using the <code>NSView</code> method <code>addTrackingRect:owner:userData:assumeInside:</code>. The tracking rectangle is provided in the view's coordinate system, and the owner is the object that will receive the <code>mouseEntered:</code> and <code>mouseExited:</code> messages. The <code>userData</code> parameter is any arbitrary object that will be provided as the <code>userData</code> object in the <code>NSEvent</code> object passed to the <code>mouseEntered:</code> and <code>mouseExited:</code> methods. The <code>assumeInside</code> parameter indicates whether the cursor should be assumed to be inside the tracking rectangle initially. The method returns a tracking tag that identifies the tracking rectangle, and the tracking tag is used to unregister the owner for tracking notifications using the method <code>removeTrackingRect:</code>. An application can register tracking rectangles only for views that are currently displayed in a window.</p><p>Although tracking rectangles are created and used by views, they are actually maintained by a view's window. As a result, tracking rectangles do not automatically move or resize when the view does. It is a subclass's responsibility to remove and re-register tracking rectangles when the frame of the view changes or it is inserted as a subview. This is commonly done by overriding the <code>NSView</code> method <code>resetCursorRects</code>. </p><p><code>NSView</code> also provides methods to support a common use of tracking rectangles; changing the cursor as a result of the mouse entering a rectangle. The <code>addCursorRect:cursor:</code> method allows you to register a rectangle using the view's coordinate system and specify the cursor that should be displayed while the mouse is over that rectangle. Cursor rectangles are volatile. When the view's window resizes, the frame or bounds of a view changes, the view is moved in the hierarchy, or the view is scrolled, the view receives a <code>resetCursorRects</code> message. Subclasses should override <code>resetCursorRects</code> and register any required cursor rectangles and tracking rectangles in that method. The <code>removeCursorRect:cursor:</code> method allows you to explicitly remove a cursor rectangle that matches the provided parameters exactly. The <code>discardCursorRects</code> method removes all the cursor rectangles for a view.</p><p>The <code>DraggableItemView</code> provides visual feedback that the cursor is over the draggable item by changing the cursor to the open handle. The implementation of <code>resetCursorRects</code>, shown in <span class="content_text">Listing 4-13</span>, discards all the current cursor rectangles and adds a new cursor rectangle for the draggable item's bounds.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW13" title="Listing 4-13DraggableItemView implementation of resetCursorRects"></a><p class="codesample"><strong>Listing 4-13&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>resetCursorRects</code></p><div class="codesample"><table><tr><td scope="row"><pre>-(void)resetCursorRects<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // remove the existing cursor rects<span></span></pre></td></tr><tr><td scope="row"><pre>    [self discardCursorRects];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // add the draggable item's bounds as a cursor rect<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // clip the draggable item's bounds to the view's visible rect<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect clippedItemBounds = NSIntersectionRect([self visibleRect], [self calculatedItemBounds]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // if the clipped item bounds isn't empty then the item is at least partially<span></span></pre></td></tr><tr><td scope="row"><pre>    // in the visible rect. Register the clipped item bounds<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!NSIsEmptyRect(clippedItemBounds)) {<span></span></pre></td></tr><tr><td scope="row"><pre>         [self addCursorRect:clippedItemBounds cursor:[NSCursor openHandCursor]];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Adding a cursor rectangle for a view does not automatically restrict the cursor rectangle to the visible area of the view. You must do this yourself by finding the intersection of the proposed cursor rectangle with the view's visible rectangle. If the resulting rectangle is not empty it should be passed as the first argument to the <code>addCursorRect:cursor:</code> method. </p><p>You should never call <code>resetCursorRects</code> directly; instead send the view's window an <code>invalidateCursorRectsForView:</code> message, passing the appropriate view. The <code>DraggableItemView</code> object needs to reset its cursor rectangle each time the draggable item moves. The <code>mouseUp:</code> implementation shown in <span class="content_text"><a href="SubclassingNSView.html#//apple_ref/doc/uid/TP40002978-CH7-SW11">Listing 4-11</a></span> sends the view's window an <code>invalidateCursorRectsForView:</code> message, passing the view itself as the parameter. Likewise, in the version of <code>mouseDown:</code> that short circuits the event loop, shown in <span class="content_text"><a href="SubclassingNSView.html#//apple_ref/doc/uid/TP40002978-CH7-SW12">Listing 4-12</a></span>, the <code>invalidateCursorRectsForView:</code> message is sent when the mouse-up event is detected.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW31" title="Handling Key Events in a View"></a><h3>Handling Key Events in a View</h3><p>As discussed in <span class="content_text">“Becoming First Responder,”</span> a view receives key-down events only if it overrides <code>acceptsFirstResponder</code> and returns <code>YES</code>. Because the <code>DraggableItemView</code> object responds to user key-presses, the class overrides this method and returns <code>YES</code>.</p><p>There are two key-down related methods provided by <code>NSResponder</code>: the methods <code>keyDown:</code> and <code>performKeyEquivalent:</code>.  <code>NSResponder</code> also declares a number of responder actions that are triggered by key-down events. These actions map specific keystrokes to common actions. By implementing the appropriate action methods, you can bypass overriding the more complicated <code>keyDown:</code> method.</p><p>Your custom view should override the <code>performKeyEquivalent:</code> method if your view reacts to simple key equivalents. An example usage of a key equivalent is setting the Return key as the key equivalent of a button.  When the user presses Return, the button acts as though it had been clicked. A subclass's implementation of <code>performKeyEquivalent:</code> should return <code>YES</code> if it has handled the key event, <code>NO</code> if it should be passed up the event chain. If a view implements <code>performKeyEquivalent:</code>, it typically does not also implement <code>keyDown:</code>.</p><p>The <code>DraggableItemView</code> class overrides the <code>keyDown:</code> method, shown in <span class="content_text">Listing 4-14</span>, which allows the user to press the R key to reset the position of the draggable rectangle to the origin of the view.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW14" title="Listing 4-14DraggableItemView implementation of keyDown:"></a><p class="codesample"><strong>Listing 4-14&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>keyDown:</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (void)keyDown:(NSEvent *)event<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL handled = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString  *characters;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // get the pressed key<span></span></pre></td></tr><tr><td scope="row"><pre>    characters = [event charactersIgnoringModifiers];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // is the "r" key pressed?<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([characters isEqual:@"r"]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Yes, it is<span></span></pre></td></tr><tr><td scope="row"><pre>        handled = YES;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // reset the rectangle<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setItemPropertiesToDefault:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!handled)<span></span></pre></td></tr><tr><td scope="row"><pre>        [super keyDown:event];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<div class="notebox"><a name="//apple_ref/doc/uid/TP40002978-CH7-SW32" title="Note"></a><p><strong>Note:</strong>&nbsp;If your subclass overrides the <code>keyDown:</code> method, you must call the super implementation for key events that your view does not handle; otherwise the action methods are ignored.</p></div><p>A view handles the <code>NSResponder</code> action methods by simply implementing the appropriate method. The <code>DraggableItemView</code> class implements four of these methods, corresponding to the up, down, left, and right movement actions. The implementations are shown in <span class="content_text">Listing 4-15</span>.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW15" title="Listing 4-15DraggableItemView implementation of moveUp:, moveDown:, moveLeft:, and moveRight: actions"></a><p class="codesample"><strong>Listing 4-15&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>moveUp:</code>, <code>moveDown:</code>, <code>moveLeft:</code>, and <code>moveRight:</code> actions</p><div class="codesample"><table><tr><td scope="row"><pre>-(void)moveUp:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self offsetLocationByX:0 andY: 10.0];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)moveDown:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self offsetLocationByX:0 andY:-10.0];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)moveLeft:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self offsetLocationByX:-10.0 andY:0.0];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)moveRight:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self offsetLocationByX:10.0 andY:0.0];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Each of the methods in <span class="content_text">Listing 4-15</span> offset the draggable item's location in the appropriate direction using the <code>offsetLocationByX:andY:</code> method, passing the amount to offset the rectangle. The vertical offset is adjusted by the <code>offsetLocationByX:andY:</code> implementation as appropriate if the view is flipped. After moving the rectangle, each method invalidates the cursor rectangles. This functionality could also have been implemented in <code>keyDown:</code> directly by examining the Unicode character of the pressed key, detecting the arrow keys, and acting accordingly. However, using the responder action methods allow the commands to be remapped by the user.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW33" title="Handling Action Methods via the Responder Chain"></a><h3>Handling Action Methods via the Responder Chain</h3><p><code>NSResponder</code> isn't the only class that can generate events on the responder chain. Any control that implements target-action methods can send those actions through the responder chain rather than to a specific object by connecting the control to the first responder proxy in Interface Builder and specifying the action. A detailed discussion of sending action messages through the responder chain is available in "<span class="content_text"><!--a target="_top" -->Event and Action Messages in the Responder Chain<!--/a--></span>" in <em><a href="../../EventOverview/index.html#//apple_ref/doc/uid/10000060i" target="_top">Cocoa Event-Handling Guide</a></em>.</p><p>The <code>DraggableItemView</code> class implements the <code>changeColor:</code> method that is sent through the responder chain when the color is changed in a Color panel. <span class="content_text">Listing 4-16</span> shows the <code>DraggableItemView</code> implementation of <code>changeColor:</code>.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW16" title="Listing 4-16DraggableItemView implementation of changeColor:"></a><p class="codesample"><strong>Listing 4-16&nbsp;&nbsp;</strong><code>DraggableItemView</code> implementation of <code>changeColor:</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (void)changeColor:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Set the color in response<span></span></pre></td></tr><tr><td scope="row"><pre>    // to the color changing in the Color panel.<span></span></pre></td></tr><tr><td scope="row"><pre>    // get the new color by asking the sender, the Color panel<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setItemColor:[sender color]];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>When the Color panel is visible and an instance of the <code>DraggableItemView</code> class is the first responder, changing the color in the Color panel causes the rectangle to change color. </p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW34" title="Property Accessor Methods"></a><h2>Property Accessor Methods</h2><p>Classes should provide key-value-coding-compliant accessor methods for all their public properties. This provides a published interface to other objects that need to set the various display aspects of the view. Accessor methods also enforce good design and encapsulate memory management issues, which greatly reduces the chance of memory leaks and crashes.</p><p>The <code>DraggableItemView</code> class implements getter and setter accessor methods for the following properties: <code>itemColor</code>, <code>backgroundColor</code>, and <code>location</code>. Each of the setter accessor methods test to see if the new value is different from the current value and, if it is, saves the new value and marks the view as needing to redisplay the appropriate portion. In addition, the <code>setLocation:</code> method also invalidates the cursor tracking rectangle when the location changes.</p><a name="//apple_ref/doc/uid/TP40002978-CH7-SW35" title="Listing 4-17DraggableItemView accessor methods"></a><p class="codesample"><strong>Listing 4-17&nbsp;&nbsp;</strong><code>DraggableItemView</code> accessor methods</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setItemColor:(NSColor *)aColor<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (![itemColor isEqual:aColor]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [itemColor release];<span></span></pre></td></tr><tr><td scope="row"><pre>        itemColor = [aColor retain];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // if the colors are not equal, mark the<span></span></pre></td></tr><tr><td scope="row"><pre>        // draggable rect as needing display<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setNeedsDisplayInRect:[self calculatedItemBounds]];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (NSColor *)itemColor<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [[itemColor retain] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setBackgroundColor:(NSColor *)aColor<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (![backgroundColor isEqual:aColor]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [backgroundColor release];<span></span></pre></td></tr><tr><td scope="row"><pre>        backgroundColor = [aColor retain];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // if the colors are not equal, mark the<span></span></pre></td></tr><tr><td scope="row"><pre>        // draggable rect as needing display<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setNeedsDisplayInRect:[self calculatedItemBounds]];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (NSColor *)backgroundColor<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [[backgroundColor retain] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setLocation:(NSPoint)point<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // test to see if the point actually changed<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!NSEqualPoints(point,location)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // tell the display to redraw the old rect<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setNeedsDisplayInRect:[self calculatedItemBounds]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // reassign the rect<span></span></pre></td></tr><tr><td scope="row"><pre>        location=point;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // display the new rect<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setNeedsDisplayInRect:[self calculatedItemBounds]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // invalidate the cursor rects<span></span></pre></td></tr><tr><td scope="row"><pre>        [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (NSPoint)location {<span></span></pre></td></tr><tr><td scope="row"><pre>    return location;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP40002978-CH7-SW36" title="Deallocating the View"></a><h2>Deallocating the View</h2><p>The <code>dealloc</code> method is called when a view's retain count is zero. Your application should never call <code>dealloc</code> explicitly. The autorelease mechanism calls it when appropriate.</p><p>The <code>DraggableItemView</code> implementation of <code>dealloc</code> releases the display color object and calls the super implementation of <code>dealloc</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)dealloc<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [color release];<span></span></pre></td></tr><tr><td scope="row"><pre>    color=nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WorkingWithAViewHierarchy/WorkingWithAViewHierarchy.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AdvancedSubclassing/AdvancedSubclassing.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-04-10<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaViewsGuide/SubclassingNSView/SubclassingNSView.html%3Fid%3DTP40002978-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaViewsGuide/SubclassingNSView/SubclassingNSView.html%3Fid%3DTP40002978-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaViewsGuide/SubclassingNSView/SubclassingNSView.html%3Fid%3DTP40002978-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>