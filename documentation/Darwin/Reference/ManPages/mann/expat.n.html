<html><head><title>Mac OS X
 Manual Page For expat(n)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/n/expat" title="Mac OS X
 Manual Page for expat(n)"><a name="//apple_ref/doc/man/n/expat" title="Mac OS X
 Manual Page for expat(n)"><!-- headerDoc=man; indexgroup=Section n; uid="//apple_ref/doc/man/n/expat"; name=expat(n) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
expat(n)                                                                                            expat(n)



____________________________________________________________________________________________________________

<b>NAME</b>
       expat - Creates an instance of an expat parser object

<b>SYNOPSIS</b>
       <b>package</b> <b>require</b> <b>tdom</b>

       <b>expat</b> ?<u>parsername</u>? ?<u>-namespace</u>? ?<u>arg</u> <u>arg</u> <u>..</u>

       <b>xml::parser</b> ?<u>parsername</u>? ?<u>-namespace</u>? ?<u>arg</u> <u>arg</u> <u>..</u>
____________________________________________________________________________________________________________

<b>DESCRIPTION</b>
       The  parser  created with <u>expat</u> or <u>xml::parser</u> (which is just another name for the same command in an
       own namespace) are able to parse any kind of well-formed XML. The parsers  are  stream  oriented  XML
       parser.  This  means  that  you register handler scripts with the parser prior to starting the parse.
       These handler scripts are called when the parser discovers the associated structures in the  document
       being  parsed.  A start tag is an example of the kind of structures for which you may register a han-<font color="#ffffff" class="whiteout">dler&nbsp;handler</font>
       dler script.

       The parsers do not validate the XML document. They do parse the internal DTD and, at request,  exter-<font color="#ffffff" class="whiteout">nal&nbsp;external</font>
       nal  DTD  and  external  entities,  if  you  resolve the identifier of the external entities with the
       -externalentitycommand script (see there).

       Additionly, the Tcl extension code that implements this command provides an API for  adding  C  level
       coded  handlers.  Up  to  now,  there  exists  the  parser  extension command "tdom". The handler set
       installed by this extension build an in memory "tDOM" DOM tree,  while  the  parser  is  parsing  the
       input.

       It  is possible to register an arbitrary amount of different handler scripts and C level handlers for
       most of the events. If the event occurs, they are called in turn.

<b>COMMAND</b> <b>OPTIONS</b>
       <b>-namespace</b>

              Enables namespace parsing. You must use this option while creating the parser with  the  <b>expat</b>
              or <b>xml::parser</b> command. You can't enable (nor disable) namespace parsing with <b>&lt;parserobj&gt;</b> <b>con</b>-<font color="#ffffff" class="whiteout">figure&nbsp;configure</font>
              <b>figure</b> <b>...</b>.

       <b>-final</b>  <u>boolean</u>

              This option indicates whether the document data next presented to  the  parse  method  is  the
              final  part  of  the document. A value of "0" indicates that more data is expected. A value of
              "1" indicates that no more is expected.  The default value is "1".

              If this option is set to "0" then the parser will not report certain errors if the XML data is
              not  well-formed  upon end of input, such as unclosed or unbalanced start or end tags. Instead
              some data may be saved by the parser until the next call to the parse  method,  thus  delaying
              the reporting of some of the data.

              If  this  option is set to "1" then documents which are not well-formed upon end of input will
              generate an error.

       <b>-baseurl</b>  <u>url</u>

              Reports the base url of the document to the parser.

       <b>-elementstartcommand</b>  <u>script</u>

              Specifies a Tcl command to associate with the start tag of an element. The actual command con-<font color="#ffffff" class="whiteout">sists&nbsp;consists</font>
              sists  of  this  option  followed  by  at  least  two arguments: the element type name and the
              attribute list.

              The attribute list is a Tcl list consisting of name/value pairs, suitable for passing  to  the
              array set Tcl command.

              Example:


                     proc HandleStart {name attlist} {
                         puts stderr "Element start ==&gt; $name has attributes $attlist"
                     }

                     $parser configure -elementstartcommand HandleStart

                     $parser parse {&lt;test id="123"&gt;&lt;/test&gt;}


              This would result in the following command being invoked:


                     HandleStart text {id 123}

       <b>-elementendcommand</b>  <u>script</u>

              Specifies  a  Tcl command to associate with the end tag of an element. The actual command con-<font color="#ffffff" class="whiteout">sists&nbsp;consists</font>
              sists of this option followed by at least one argument: the element type name. In addition, if
              the  -reportempty  option is set then the command may be invoked with the -empty configuration
              option to indicate whether it is an empty element. See the  description  of  the  -reportempty
              option for an example.

              Example:


                     proc HandleEnd {name} {
                         puts stderr "Element end ==&gt; $name"
                     }

                     $parser configure -elementendcommand HandleEnd

                     $parser parse {&lt;test id="123"&gt;&lt;/test&gt;}


              This would result in the following command being invoked:



                     HandleEnd test


       <b>-characterdatacommand</b>  <u>script</u>

              Specifies a Tcl command to associate with character data in the document, ie. text. The actual
              command consists of this option followed by one argument: the text.

              It is not guaranteed that character data will be passed to the application in a single call to
              this  command.  That is, the application should be prepared to receive multiple invocations of
              this callback with no intervening callbacks from other features.

              Example:



                     proc HandleText {data} {
                         puts stderr "Character data ==&gt; $data"
                     }

                     $parser configure -characterdatacommand HandleText

                     $parser parse {&lt;test&gt;this is a test document&lt;/test&gt;}


              This would result in the following command being invoked:



                     HandleText {this is a test document}

       <b>-processinginstructioncommand</b>  <u>script</u>

              Specifies a Tcl command to associate with processing instructions in the document. The  actual
              command consists of this option followed by two arguments: the PI target and the PI data.

              Example:



                     proc HandlePI {target data} {
                         puts stderr "Processing instruction ==&gt; $target $data"
                     }

                     $parser configure -processinginstructioncommand HandlePI

                     $parser parse {&lt;test&gt;&lt;?special this is a processing instruction?&gt;&lt;/test&gt;}


              This would result in the following command being invoked:




                     HandlePI special {this is a processing instruction}


        <b>-notationdeclcommand</b>  <u>script</u>

              Specifies  a  Tcl  command  to associate with notation declaration in the document. The actual
              command consists of this option followed by four arguments: the notation name, the base uri of
              the  document (this means, whatever was set by the -baseurl option), the system identifier and
              the public identifier. The notation name is never empty, the other arguments may be.

        <b>-externalentitycommand</b>  <u>script</u>

              Specifies a Tcl command to associate with references to external entities in the document. The
              actual  command  consists of this option followed by three arguments: the base uri, the system
              identifier of the entity and the public identifier of the entity. The base uri and the  public
              identifier may be the empty list.

              This  handler  script has to return a tcl list consisting of three elements. The first element
              of this list signals, how the external entity is returned to the processor. At the moment, the
              three allowed types are "string", "channel" and "filename". The second element of the list has
              to be the (absolute) base URI of the external entity to be parsed.  The third element  of  the
              list  are  data, either the already read data out of the external entity as string in the case
              of type "string", or the name of a tcl channel, in the case of type "channel", or the path  to
              the  external  entity  to  be  read in case of type "filename". Behind the scene, the external
              entity referenced by the returned Tcl channel, string or file name  will  be  parsed  with  an
              expat  external entity parser with the same handler sets as the main parser. If parsing of the
              external entity fails, the whole parsing is stopped with an error message. If  a  Tcl  command
              registered  as externalentitycommand isn't able to resolve an external entity it is allowed to
              return TCL_CONTINUE. In this case, the wrapper give the next registered  externalentitycommand
              a try. If no externalentitycommand is able to handle the external entity parsing stops with an
              error.

              Example:



                     proc externalEntityRefHandler {base systemId publicId} {
                         if {![regexp {^[a-zA-Z]+:/} $systemId]}  {
                             regsub {^[a-zA-Z]+:} $base {} base
                             set basedir [file dirname $base]
                             set systemId "[set basedir]/[set systemId]"
                         } else {
                             regsub {^[a-zA-Z]+:} $systemId systemId
                         }
                         if {[catch {set fd [open $systemId]}]} {
                             return -code error \
                                     -errorinfo "Failed to open external entity $systemId"
                         }
                         return [list channel $systemId $fd]
                     }

                     set parser [expat -externalentitycommand externalEntityRefHandler \
                                       -baseurl "file:///local/doc/doc.xml" \
                                       -paramentityparsing notstandalone]
                     $parser parse {&lt;?xml version='1.0'?&gt;
                     &lt;!DOCTYPE test SYSTEM "test.dtd"&gt;
                     &lt;test/&gt;}


              This would result in the following command being invoked:




                     externalEntityRefHandler file:///local/doc/doc.xml test.dtd {}


              External entities are only tried to resolve via this handler script, if necessary. This means,
              external  parameter  entities  triggers this handler only, if -paramentityparsing is used with
              argument "always" or if -paramentityparsing is used with argument "notstandalone" and the doc-<font color="#ffffff" class="whiteout">ument&nbsp;document</font>
              ument isn't marked as standalone.

        <b>-unknownencodingcommand</b>  <u>script</u>

              Not implemented at Tcl level.

       <b>-startnamespacedeclcommand</b>  <u>script</u>

              Specifies  a  Tcl command to associate with start scope of namespace declarations in the docu-<font color="#ffffff" class="whiteout">ment.&nbsp;document.</font>
              ment. The actual command consists of this option followed by two arguments: the namespace pre-<font color="#ffffff" class="whiteout">fix&nbsp;prefix</font>
              fix  and  the  namespace  URI.  For an xmlns attribute, prefix will be the empty list.  For an
              xmlns="" attribute, uri will be the empty list. The call to the start and end element handlers
              occur between the calls to the start and end namespace declaration handlers.

        <b>-endnamespacedeclcommand</b>  <u>script</u>

              Specifies a Tcl command to associate with end scope of namespace declarations in the document.
              The actual command consists of this option followed by the namespace prefix  as  argument.  In
              case  of an xmlns attribute, prefix will be the empty list. The call to the start and end ele-<font color="#ffffff" class="whiteout">ment&nbsp;element</font>
              ment handlers occur between the calls to the start and end namespace declaration handlers.

        <b>-commentcommand</b>  <u>script</u>

              Specifies a Tcl command to associate with comments in the document. The  actual  command  con-<font color="#ffffff" class="whiteout">sists&nbsp;consists</font>
              sists of this option followed by one argument: the comment data.

              Example:




                     proc HandleComment {data} {
                         puts stderr "Comment ==&gt; $data"
                     }

                     $parser configure -commentcommand HandleComment

                     $parser parse {&lt;test&gt;&lt;!-- this is &lt;obviously&gt; a comment --&gt;&lt;/test&gt;}


              This would result in the following command being invoked:




                     HandleComment { this is &lt;obviously&gt; a comment }


        <b>-notstandalonecommand</b>  <u>script</u>

              This  Tcl command is called, if the document is not standalone (it has an external subset or a
              reference to a parameter entity, but does not have standalone="yes"). It  is  called  with  no
              additional arguments.

        <b>-startcdatasectioncommand</b>  <u>script</u>

              Specifies  a Tcl command to associate with the start of a CDATA section.  It is called with no
              additional arguments.

        <b>-endcdatasectioncommand</b>  <u>script</u>

              Specifies a Tcl command to associate with the end of a CDATA section.  It is  called  with  no
              additional arguments.

        <b>-elementdeclcommand</b>  <u>script</u>

              Specifies a Tcl command to associate with element declarations. The actual command consists of
              this option followed by two arguments: the name of the element and the content model. The con-<font color="#ffffff" class="whiteout">tent&nbsp;content</font>
              tent  model  arg  is a tcl list of four elements. The first list element specifies the type of
              the XML element; the six different possible types are reported as  "MIXED",  "NAME",  "EMPTY",
              "CHOICE",  "SEQ" or "ANY". The second list element reports the quantifier to the content model
              in XML Syntax ("?", "*" or "+") or is the empty list. If the type is "MIXED", then the quanti-<font color="#ffffff" class="whiteout">fier&nbsp;quantifier</font>
              fier  will  be  "{}",  indicating an PCDATA only element, or "*", with the allowed elements to
              intermix with PCDATA as tcl list as the fourth argument. If the type is "NAME",  the  name  is
              the  third  arg;  otherwise  the  third argument is the empty list. If the type is "CHOICE" or
              "SEQ" the fourth argument will contain a list of content  models  build  like  this  one.  The
              "EMPTY", "ANY", and "MIXED" types will only occur at top level.

              Examples:




                     proc elDeclHandler {name content} {
                          puts "$name $content"
                     }

                     set parser [expat -elementdeclcommand elDeclHandler]
                     $parser parse {&lt;?xml version='1.0'?&gt;
                     &lt;!DOCTYPE test [
                     &lt;!ELEMENT test (#PCDATA)&gt;
                     ]&gt;
                     &lt;test&gt;foo&lt;/test&gt;}


              This would result in the following command being invoked:




                     test {MIXED {} {} {}}

                     $parser reset
                     $parser parse {&lt;?xml version='1.0'?&gt;
                     &lt;!DOCTYPE test [
                     &lt;!ELEMENT test (a|b)&gt;
                     ]&gt;
                     &lt;test&gt;&lt;a/&gt;&lt;/test&gt;}


              This would result in the following command being invoked:




                     elDeclHandler test {CHOICE {} {} {{NAME {} a {}} {NAME {} b {}}}}


        <b>-attlistdeclcommand</b>  <u>script</u>

              Specifies a Tcl command to associate with attlist declarations. The actual command consists of
              this option followed by five arguments.  The Attlist declaration handler is called for  *each*
              attribute.  So  a  single  Attlist declaration with multiple attributes declared will generate
              multiple calls to this handler. The arguments are the element name this attribute belongs  to,
              the  name  of  the  attribute,  the type of the attribute, the default value (may be the empty
              list) and a required flag. If this flag is true and the default value is not the  empty  list,
              then this is a "#FIXED" default.

              Example:




                     proc attlistHandler {elname name type default isRequired} {
                         puts "$elname $name $type $default $isRequired"
                     }

                     set parser [expat -attlistdeclcommand attlistHandler]
                     $parser parse {&lt;?xml version='1.0'?&gt;
                     &lt;!DOCTYPE test [
                     &lt;!ELEMENT test EMPTY&gt;
                     &lt;!ATTLIST test
                               id      ID      #REQUIRED
                               name    CDATA   #IMPLIED&gt;
                     ]&gt;
                     &lt;test/&gt;}


              This would result in the following commands being invoked:




                     attlistHandler test id ID {} 1
                     attlistHandler test name CDATA {} 0


        <b>-startdoctypedeclcommand</b>  <u>script</u>

              Specifies  a  Tcl command to associate with the start of the DOCTYPE declaration. This command
              is called before any DTD or internal subset is parsed.  The actual command  consists  of  this
              option followed by four arguments: the doctype name, the system identifier, the public identi-<font color="#ffffff" class="whiteout">fier&nbsp;identifier</font>
              fier and a boolean, that shows if the DOCTYPE has an internal subset.

        <b>-enddoctypedeclcommand</b>  <u>script</u>

              Specifies a Tcl command to associate with the end of the DOCTYPE declaration. This command  is
              called after processing any external subset.  It is called with no additional arguments.

        <b>-paramentityparsing</b>  <u>never|notstandalone|always</u>

              "never"  disables expansion of parameter entities, "always" expands always and "notstandalone"
              only, if the document isn't "standalone='no'". The default ist "never"

        <b>-entitydeclcommand</b>  <u>script</u>

              Specifies a Tcl command to associate with any entity declaration. The actual command  consists
              of  this  option followed by seven arguments: the entity name, a boolean identifying parameter
              entities, the value of the entity, the base uri, the system identifier, the public  identifier
              and  the notation name. According to the type of entity declaration some of this arguments may
              be the empty list.

        <b>-ignorewhitecdata</b>  <u>boolean</u>

              If this flag is set, element content which contain only whitespaces isn't  reported  with  the
              <b>-characterdatacommand</b>.

        <b>-ignorewhitespace</b>  <u>boolean</u>
              Another name for  <u>-ignorewhitecdata</u>; see there.

        <b>-handlerset</b>  <u>name</u>

              This  option  sets  the Tcl handler set scope for the configure options. Any option value pair
              following this option in the same call to the parser are modifying the named Tcl handler  set.
              If  you don't use this option, you are modifying the default Tcl handler set, named "default".

        <b>-noexpand</b>  <u>boolean</u>

              Normally, the parser will try to expand references to entities defined in the internal subset.
              If this option is set to a true value this entities are not expanded, but reported literal via
              the default handler. <b>Warning:</b> If you set this option to true and  doesn't  install  a  default
              handler  (with  the  -defaultcommand  option) for every handler set of the parser all internal
              entities are silent lost for the handler sets without a default handler.

       <b>-useForeignDTD</b>  <u>&lt;boolen&gt;</u>
              If &lt;boolen&gt; is true and the document does not have an external subset, the  parser  will  call
              the  -externalentitycommand  script with empty values for the systemId and publicID arguments.
              This option must be set, before the first piece of data is parsed. Setting this option,  after
              the parsing has started has no effect. The default is not to use a foreign DTD. The default is
              restored, after reseting the parser.  Pleace  notice,  that  a  -paramentityparsing  value  of
              "never"  (which  is  the  default)  suppresses  any call to the -externalentitycommand script.
              Pleace notice, that, if the document also doesn't have an internal subset, the  -startdoctype-<font color="#ffffff" class="whiteout">declcommand&nbsp;-startdoctypedeclcommand</font>
              declcommand and enddoctypedeclcommand scripts, if set, are not called.

 <b>COMMAND</b> <b>METHODS</b>
       <b>parser</b> <b>configure</b> <u>option</u> <u>value</u> <u>?option</u> <u>value?</u>


              Sets  configuration options for the parser. Every command option, except <u>-namespace</u> can be set
              or modified with this method.

       <b>parser</b> <b>cget</b> <u>?-handlerset</u> <u>name?</u> <u>option</u>


              Return the current configuration value option for the parser.

              If the -handlerset option is used, the configuration for the named handler set is returned.

       <b>parser</b> <b>free</b>


              Deletes the parser and the parser command.

       <b>parser</b> <b>get</b>  <u>-specifiedattributecount|-idattributeindex|-currentbytecount|-currentlinenumber|-current</u>-<font color="#ffffff" class="whiteout">columnnumber|-currentbyteindex&nbsp;-specifiedattributecount|-idattributeindex|-currentbytecount|-currentlinenumber|-currentcolumnnumber|-currentbyteindex</font>
       <u>columnnumber|-currentbyteindex</u>


              <b>-specifiedattributecount</b>

                     Returns the number of the attribute/value  pairs  passed  in  last  call  to  the  ele-<font color="#ffffff" class="whiteout">mentstartcommand&nbsp;elementstartcommand</font>
                     mentstartcommand  that  were  specified  in  the  start-tag rather than defaulted. Each
                     attribute/value pair counts as 2; thus this corresponds to an index into the  attribute
                     list passed to the elementstartcommand.

              <b>-idattributeindex</b>

                     Returns  the  index  of  the  ID  attribute passed in the last call to XML_StartElemen-<font color="#ffffff" class="whiteout">tHandler,&nbsp;XML_StartElementHandler,</font>
                     tHandler, or -1 if there is no ID attribute.  Each attribute/value pair  counts  as  2;
                     thus  this corresponds to an index into the attributes list passed to the elementstart-<font color="#ffffff" class="whiteout">command.&nbsp;elementstartcommand.</font>
                     command.

              <b>-currentbytecount</b>

                     Return the number of bytes in the current event.  Returns 0  if  the  event  is  in  an
                     internal entity.

              <b>-currentlinenumber</b>

                     Returns the line number of the current parse location.

              <b>-currentcolumnnumber</b>

                     Returns the column number of the current parse location.

              <b>-currentbyteindex</b>

                     Returns the byte index of the current parse location.

              Only one value may be requested at a time.

       <b>parser</b> <b>parse</b> <u>data</u>


              Parses  the  XML  string  <u>data</u>. The event callback scripts will be called, as there triggering
              events happens.

       <b>parser</b> <b>parsechannel</b> <u>channelID</u>


              Reads the XML data out of the tcl channel <u>channelID</u> (starting at the current access  position,
              without  any  seek) up to the end of file condition and parses that data. The channel encoding
              is respected. Use the helper proc tDOM::xmlOpenFile out of the tDOM script library to  open  a
              file, if you want to use this method.

       <b>parser</b> <b>parsefile</b> <u>filename</u>


              Reads  the  XML data directly out of the file with the filename <u>filename</u> and parses that data.
              This is done with low level file operations. The XML data must  be  in  ISO-8859-1,  UTF-8  or
              UTF-16 encoding. If applicable, this is the fastest way, to parse XML data.

       <b>parser</b> <b>reset</b>


              Resets the parser in preparation for parsing another document.

<b>Callback</b> <b>Command</b> <b>Return</b> <b>Codes</b>
       A  script invoked for any of the parser callback commands, such as -elementstartcommand, -elementend-<font color="#ffffff" class="whiteout">command,&nbsp;-elementendcommand,</font>
       command, etc, may return an error code other than "ok" or "error".  All  callbacks  may  in  addition
       return "break" or "continue".

       If  a callback script returns an "error" error code then processing of the document is terminated and
       the error is propagated in the usual fashion.

       If a callback script returns a "break" error code then all further processing of every handler script
       out  of this Tcl handler set is suppressed for the further parsing. This does not influence any other
       handler set.

       If a callback script returns a "continue" error code then processing of the current element, and  its
       children,  ceases  for every handler script out of this Tcl handler set and processing continues with
       the next (sibling) element. This does not influence any other handler set.

<b>SEE</b> <b>ALSO</b>
       expatapi, tdom

<b>KEYWORDS</b>
       SAX



Tcl                                                                                                 expat(n)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/mann/expat.n.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/mann/expat.n.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/mann/expat.n.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
