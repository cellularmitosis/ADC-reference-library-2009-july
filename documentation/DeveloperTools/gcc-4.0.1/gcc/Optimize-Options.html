<html lang="en">
<head>
<title>Optimize Options - Using the GNU Compiler Collection (GCC)</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Using the GNU Compiler Collection (GCC)">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Invoking-GCC.html#Invoking-GCC" title="Invoking GCC">
<link rel="prev" href="Debugging-Options.html#Debugging-Options" title="Debugging Options">
<link rel="next" href="Preprocessor-Options.html#Preprocessor-Options" title="Preprocessor Options">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled ``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Optimize-Options"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Preprocessor-Options.html#Preprocessor-Options">Preprocessor Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Debugging-Options.html#Debugging-Options">Debugging Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Invoking-GCC.html#Invoking-GCC">Invoking GCC</a>
<hr>
</div>

<h3 class="section">3.10 Options That Control Optimization</h3>

<p><a name="index-optimize-options-468"></a><a name="index-options_002c-optimization-469"></a>
These options control various sorts of optimizations.

 <p>Without any optimization option, the compiler's goal is to reduce the
cost of compilation and to make debugging produce the expected
results.  Statements are independent: if you stop the program with a
breakpoint between statements, you can then assign a new value to any
variable or change the program counter to any other statement in the
function and get exactly the results you would expect from the source
code.

 <p>Turning on optimization flags makes the compiler attempt to improve
the performance and/or code size at the expense of compilation time
and possibly the ability to debug the program.

 <p>The compiler performs optimization based on the knowledge it has of
the program.  Optimization levels <samp><span class="option">-O2</span></samp> and above, in
particular, enable <em>unit-at-a-time</em> mode, which allows the
compiler to consider information gained from later functions in
the file when compiling a function.  Compiling multiple files at
once to a single output file in <em>unit-at-a-time</em> mode allows
the compiler to use information gained from all of the files when
compiling each of them.

 <p>Not all optimizations are controlled directly by a flag.  Only
optimizations that have a flag are listed.

     <dl>
<dt><code>-O</code><dt><code>-O1</code><dd><a name="index-O-470"></a><a name="index-O1-471"></a>Optimize.  Optimizing compilation takes somewhat more time, and a lot
more memory for a large function.

     <p>With <samp><span class="option">-O</span></samp>, the compiler tries to reduce code size and execution
time, without performing any optimizations that take a great deal of
compilation time.

     <p><samp><span class="option">-O</span></samp> turns on the following optimization flags:
     <pre class="smallexample">          -fdefer-pop 
          -fdelayed-branch 
          -fguess-branch-probability 
          -fcprop-registers 
          -floop-optimize 
          -fif-conversion 
          -fif-conversion2 
          -ftree-ccp 
          -ftree-dce 
          -ftree-dominator-opts 
          -ftree-dse 
          -ftree-ter 
          -ftree-lrs 
          -ftree-sra 
          -ftree-copyrename 
          -ftree-fre 
          -ftree-ch 
          -fmerge-constants
     </pre>
     <p><samp><span class="option">-O</span></samp> also turns on <samp><span class="option">-fomit-frame-pointer</span></samp> on machines
where doing so does not interfere with debugging.

     <p><samp><span class="option">-O</span></samp> doesn't turn on <samp><span class="option">-ftree-sra</span></samp> for the Ada compiler. 
This option must be explicitly specified on the command line to be
enabled for the Ada compiler.

     <br><dt><code>-O2</code><dd><a name="index-O2-472"></a>Optimize even more.  GCC performs nearly all supported optimizations
that do not involve a space-speed tradeoff.  The compiler does not
perform loop unrolling or function inlining when you specify <samp><span class="option">-O2</span></samp>. 
As compared to <samp><span class="option">-O</span></samp>, this option increases both compilation time
and the performance of the generated code.

     <p><samp><span class="option">-O2</span></samp> turns on all optimization flags specified by <samp><span class="option">-O</span></samp>.  It
also turns on the following optimization flags:
     <pre class="smallexample">          -fthread-jumps 
          -fcrossjumping 
          -foptimize-sibling-calls 
          -fcse-follow-jumps  -fcse-skip-blocks 
          -fgcse  -fgcse-lm  
          -fexpensive-optimizations 
          -fstrength-reduce 
          -frerun-cse-after-loop  -frerun-loop-opt 
          -fcaller-saves 
          -fforce-mem 
          -fpeephole2 
          -fschedule-insns  -fschedule-insns2 
          -fsched-interblock  -fsched-spec 
          -fregmove 
          -fstrict-aliasing 
          -fdelete-null-pointer-checks 
          -freorder-blocks  -freorder-functions 
          -funit-at-a-time 
          -falign-functions  -falign-jumps 
          -falign-loops  -falign-labels 
          -ftree-pre
     </pre>
     <p>Please note the warning under <samp><span class="option">-fgcse</span></samp> about
invoking <samp><span class="option">-O2</span></samp> on programs that use computed gotos.

     <!-- APPLE LOCAL begin optimization -->
<p>In Apple's version of GCC, <samp><span class="option">-fstrict-aliasing</span></samp>,
<samp><span class="option">-freorder-blocks</span></samp>, and <samp><span class="option">-fsched-interblock</span></samp>
are disabled by default when optimizing. 
<!-- APPLE LOCAL end optimization -->

     <br><dt><code>-O3</code><dd><a name="index-O3-473"></a>Optimize yet more.  <samp><span class="option">-O3</span></samp> turns on all optimizations specified by
<samp><span class="option">-O2</span></samp> and also turns on the <samp><span class="option">-finline-functions</span></samp>,
<samp><span class="option">-funswitch-loops</span></samp> and <samp><span class="option">-fgcse-after-reload</span></samp> options.

     <br><dt><code>-O0</code><dd><a name="index-O0-474"></a>Do not optimize.  This is the default.

     <!-- APPLE LOCAL begin -fast -->
<br><dt><code>-fast</code><dd><a name="index-fast-475"></a>Optimize for maximum performance. <samp><span class="option">-fast</span></samp> changes the overall optimization
strategy of GCC in order to produce the fastest possible running code for PPC7450
and G5 architectures. By default, <samp><span class="option">-fast</span></samp> optimizes for G5. Programs
optimized for G5 will not run on PPC7450. To optimize for PPC7450, add
<samp><span class="option">-mcpu=7450</span></samp> on command line.

     <p><samp><span class="option">-fast</span></samp> currently enables the following optimization flags (for G5 and PPC7450). 
These flags may change in the future.  You cannot override any of these options if you use
<samp><span class="option">-fast</span></samp> except by setting <samp><span class="option">-mcpu=7450</span></samp> (or <samp><span class="option">-fPIC</span></samp>, see below).

     <pre class="smallexample">          -O3
          -falign-loops-max-skip=15
          -falign-jumps-max-skip=15
          -falign-loops=16
          -falign-jumps=16
          -falign-functions=16
          -malign-natural (except when -fastf is specified)
          -ffast-math
          -fstrict-aliasing
          -funroll-loops
          -ftree-loop-linear
          -ftree-loop-memset
          -mcpu=G5
          -mpowerpc-gpopt
          -mtune=G5  (unless -mtune=G4 is specified).
          -fsched-interblock
          -fgcse-sm
          -mpowerpc64
     </pre>
     <p>To build shared libraries with <samp><span class="option">-fast</span></samp>, specify <samp><span class="option">-fPIC</span></samp>
on the command line as <samp><span class="option">-fast</span></samp> turns on <samp><span class="option">-mdynamic-no-pic</span></samp>
otherwise.

     <p>Important notes: <samp><span class="option">-ffast-math</span></samp> results in code that is not necessarily
IEEE-compliant.  <samp><span class="option">-fstrict-aliasing</span></samp> is highly likely to break
non-standard-compliant programs.  <samp><span class="option">-malign-natural</span></samp> only works properly if
the entire program is compiled with it, and none of the standard headers/libraries
contain any code that changes alignment when this option is used.

     <p>On Intel target, <samp><span class="option">-fast</span></samp> currently enables the following optimization flags:

     <pre class="smallexample">          -O3
          -fomit-frame-pointer
          -fstrict-aliasing
          -momit-leaf-frame-pointer
          -fno-tree-pre
          -falign-loops
     </pre>
     <p>All choices of flags enabled by <samp><span class="option">-fast</span></samp> are subject to change without notice.

     <!-- APPLE LOCAL end -fast -->
<!-- APPLE LOCAL begin 4231761 -Oz -->
<br><dt><code>-Os</code><dd><a name="index-Os-476"></a>Optimize for size, but not at the expense of speed. 
<samp><span class="option">-Os</span></samp> enables all <samp><span class="option">-O2</span></samp> optimizations that
do not typically increase code size.  However, instructions
are chosen for best performance, regardless of size. 
To optimize solely for size on Darwin, use <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <p>The following options are set for <samp><span class="option">-O2</span></samp>, but are disabled under <samp><span class="option">-Os</span></samp>:
     <pre class="smallexample">          -falign-functions  -falign-jumps  -falign-loops 
          -falign-labels  -freorder-blocks  -freorder-blocks-and-partition 
          -fprefetch-loop-arrays
     </pre>
     <!-- APPLE LOCAL begin 4200438 -->
<p>When optimizing with <samp><span class="option">-Os</span></samp> or <samp><span class="option">-Oz</span></samp> (APPLE ONLY) on
Darwin, any function up to 30 &ldquo;estimated insns&rdquo; in size will be
considered for inlining.  When compiling C and Objective-C sourcefiles with
<samp><span class="option">-Os</span></samp> or <samp><span class="option">-Oz</span></samp> on Darwin, functions explictly marked
with the <code>inline</code> keyword up to 450 &ldquo;estimated insns&rdquo; in size
will be considered for inlining. 
<!-- APPLE LOCAL end 4200438 -->
<!-- APPLE LOCAL begin Disable string insns with -Os on Darwin (radar 3509006) -->
When compiling for Apple POWERPC targets, <samp><span class="option">-Os</span></samp> and
<samp><span class="option">-Oz</span></samp> (APPLE ONLY) disable use of the string instructions even though they
would usually be smaller, because the kernel can't emulate them
correctly in some rare cases.  This behavior is not portable to any
other gcc environment, and will not affect most programs at all.  If
you really want the string instructions, use -mstring. 
<!-- APPLE LOCAL end Disable string insns with -Os on Darwin (radar 3509006) -->

     <br><dt><code>-Oz</code><dd><a name="index-Oz-477"></a>(APPLE ONLY) Optimize for size, regardless of performance. 
<samp><span class="option">-Oz</span></samp> enables the same optimization flags that <samp><span class="option">-Os</span></samp>
uses, but <samp><span class="option">-Oz</span></samp> also enables other optimizations intended solely
to reduce code size.  In particular, instructions that encode into
fewer bytes are preferred over longer instructions that execute in
fewer cycles.  <samp><span class="option">-Oz</span></samp> on Darwin is very similar to <samp><span class="option">-Os</span></samp>
in FSF distributions of GCC.  <samp><span class="option">-Oz</span></samp> employs the same inlining
limits and avoids string instructions just like <samp><span class="option">-Os</span></samp>. 
<!-- APPLE LOCAL end 4231761 -Oz -->

     <p>If you use multiple <samp><span class="option">-O</span></samp> options, with or without level numbers,
the last such option is the one that is effective. 
</dl>

 <p>Options of the form <samp><span class="option">-f</span><var>flag</var></samp> specify machine-independent
flags.  Most flags have both positive and negative forms; the negative
form of <samp><span class="option">-ffoo</span></samp> would be <samp><span class="option">-fno-foo</span></samp>.  In the table
below, only one of the forms is listed&mdash;the one you typically will
use.  You can figure out the other form by either removing `<samp><span class="samp">no-</span></samp>'
or adding it.

 <p>The following options control specific optimizations.  They are either
activated by <samp><span class="option">-O</span></samp> options or are related to ones that are.  You
can use the following flags in the rare cases when &ldquo;fine-tuning&rdquo; of
optimizations to be performed is desired.

     <dl>
<dt><code>-fno-default-inline</code><dd><a name="index-fno_002ddefault_002dinline-478"></a>Do not make member functions inline by default merely because they are
defined inside the class scope (C++ only).  Otherwise, when you specify
<samp><span class="option">-O</span></samp><!-- /@w -->, member functions defined inside class scope are compiled
inline by default; i.e., you don't need to add `<samp><span class="samp">inline</span></samp>' in front of
the member function name.

     <br><dt><code>-fno-defer-pop</code><dd><a name="index-fno_002ddefer_002dpop-479"></a>Always pop the arguments to each function call as soon as that function
returns.  For machines which must pop arguments after a function call,
the compiler normally lets arguments accumulate on the stack for several
function calls and pops them all at once.

     <!-- APPLE LOCAL begin 4231761 -Oz -->
<p>Disabled at levels <samp><span class="option">-O</span></samp>, <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>,
<samp><span class="option">-Oz</span></samp> (APPLE ONLY). 
<!-- APPLE LOCAL end 4231761 -Oz -->

     <br><dt><code>-fforce-mem</code><dd><a name="index-fforce_002dmem-480"></a>Force memory operands to be copied into registers before doing
arithmetic on them.  This produces better code by making all memory
references potential common subexpressions.  When they are not common
subexpressions, instruction combination should eliminate the separate
register-load.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fforce-addr</code><dd><a name="index-fforce_002daddr-481"></a>Force memory address constants to be copied into registers before
doing arithmetic on them.  This may produce better code just as
<samp><span class="option">-fforce-mem</span></samp> may.

     <br><dt><code>-fomit-frame-pointer</code><dd><a name="index-fomit_002dframe_002dpointer-482"></a>Don't keep the frame pointer in a register for functions that
don't need one.  This avoids the instructions to save, set up and
restore frame pointers; it also makes an extra register available
in many functions.  <strong>It also makes debugging impossible on
some machines.</strong>

     <p>On some machines, such as the VAX, this flag has no effect, because
the standard calling sequence automatically handles the frame pointer
and nothing is saved by pretending it doesn't exist.  The
machine-description macro <code>FRAME_POINTER_REQUIRED</code> controls
whether a target machine supports this flag.  See <a href="../gccint/Registers.html#Registers">Register Usage</a>.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O</span></samp>, <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-foptimize-sibling-calls</code><dd><a name="index-foptimize_002dsibling_002dcalls-483"></a>Optimize sibling and tail recursive calls.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fno-inline</code><dd><a name="index-fno_002dinline-484"></a>Don't pay attention to the <code>inline</code> keyword.  Normally this option
is used to keep the compiler from expanding any functions inline. 
Note that if you are not optimizing, no functions can be expanded inline.

     <br><dt><code>-finline-functions</code><dd><a name="index-finline_002dfunctions-485"></a>Integrate all simple functions into their callers.  The compiler
heuristically decides which functions are simple enough to be worth
integrating in this way.

     <p>If all calls to a given function are integrated, and the function is
declared <code>static</code>, then the function is normally not output as
assembler code in its own right.

     <p>Enabled at level <samp><span class="option">-O3</span></samp>.

     <br><dt><code>-finline-limit=</code><var>n</var><dd><a name="index-finline_002dlimit-486"></a>By default, GCC limits the size of functions that can be inlined.  This flag
allows the control of this limit for functions that are explicitly marked as
inline (i.e., marked with the inline keyword or defined within the class
definition in c++).  <var>n</var> is the size of functions that can be inlined in
number of pseudo instructions (not counting parameter handling).  The default
value of <var>n</var> is 600. 
Increasing this value can result in more inlined code at
the cost of compilation time and memory consumption.  Decreasing usually makes
the compilation faster and less code will be inlined (which presumably
means slower programs).  This option is particularly useful for programs that
use inlining heavily such as those based on recursive templates with C++.

     <p>Inlining is actually controlled by a number of parameters, which may be
specified individually by using <samp><span class="option">--param </span><var>name</var><span class="option">=</span><var>value</var></samp>. 
The <samp><span class="option">-finline-limit=</span><var>n</var></samp> option sets some of these parameters
as follows:

          <dl>
 <dt><code>max-inline-insns-single</code><dd>  is set to <var>n</var>/2. 
 <br><dt><code>max-inline-insns-auto</code><dd>  is set to <var>n</var>/2. 
 <br><dt><code>min-inline-insns</code><dd>  is set to 130 or <var>n</var>/4, whichever is smaller. 
 <br><dt><code>max-inline-insns-rtl</code><dd>  is set to <var>n</var>. 
</dl>

     <p>See below for a documentation of the individual
parameters controlling inlining.

     <p><em>Note:</em> pseudo instruction represents, in this particular context, an
abstract measurement of function's size.  In no way, it represents a count
of assembly instructions and as such its exact meaning might change from one
release to an another.

     <br><dt><code>-fkeep-inline-functions</code><dd><a name="index-fkeep_002dinline_002dfunctions-487"></a>In C, emit <code>static</code> functions that are declared <code>inline</code>
into the object file, even if the function has been inlined into all
of its callers.  This switch does not affect functions using the
<code>extern inline</code> extension in GNU C.  In C++, emit any and all
inline functions into the object file.

     <br><dt><code>-fkeep-static-consts</code><dd><a name="index-fkeep_002dstatic_002dconsts-488"></a>Emit variables declared <code>static const</code> when optimization isn't turned
on, even if the variables aren't referenced.

     <p>GCC enables this option by default.  If you want to force the compiler to
check if the variable was referenced, regardless of whether or not
optimization is turned on, use the <samp><span class="option">-fno-keep-static-consts</span></samp> option.

     <br><dt><code>-fmerge-constants</code><dd>Attempt to merge identical constants (string constants and floating point
constants) across compilation units.

     <p>This option is the default for optimized compilation if the assembler and
linker support it.  Use <samp><span class="option">-fno-merge-constants</span></samp> to inhibit this
behavior.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O</span></samp>, <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fmerge-all-constants</code><dd>Attempt to merge identical constants and identical variables.

     <p>This option implies <samp><span class="option">-fmerge-constants</span></samp>.  In addition to
<samp><span class="option">-fmerge-constants</span></samp> this considers e.g. even constant initialized
arrays or initialized constant variables with integral or floating point
types.  Languages like C or C++ require each non-automatic variable to
have distinct location, so using this option will result in non-conforming
behavior.

     <br><dt><code>-fmodulo-sched</code><dd><a name="index-fmodulo_002dsched-489"></a>Perform swing modulo scheduling immediately before the first scheduling
pass.  This pass looks at innermost loops and reorders their
instructions by overlapping different iterations.

     <br><dt><code>-fno-branch-count-reg</code><dd><a name="index-fno_002dbranch_002dcount_002dreg-490"></a>Do not use &ldquo;decrement and branch&rdquo; instructions on a count register,
but instead generate a sequence of instructions that decrement a
register, compare it against zero, then branch based upon the result. 
This option is only meaningful on architectures that support such
instructions, which include x86, PowerPC, IA-64 and S/390.

     <p>The default is <samp><span class="option">-fbranch-count-reg</span></samp>, enabled when
<samp><span class="option">-fstrength-reduce</span></samp> is enabled.

     <br><dt><code>-fno-function-cse</code><dd><a name="index-fno_002dfunction_002dcse-491"></a>Do not put function addresses in registers; make each instruction that
calls a constant function contain the function's address explicitly.

     <p>This option results in less efficient code, but some strange hacks
that alter the assembler output may be confused by the optimizations
performed when this option is not used.

     <p>The default is <samp><span class="option">-ffunction-cse</span></samp>

     <br><dt><code>-fno-zero-initialized-in-bss</code><dd><a name="index-fno_002dzero_002dinitialized_002din_002dbss-492"></a>If the target supports a BSS section, GCC by default puts variables that
are initialized to zero into BSS.  This can save space in the resulting
code.

     <p>This option turns off this behavior because some programs explicitly
rely on variables going to the data section.  E.g., so that the
resulting executable can find the beginning of that section and/or make
assumptions based on that.

     <p>The default is <samp><span class="option">-fzero-initialized-in-bss</span></samp>.

     <br><dt><code>-fbounds-check</code><dd><a name="index-fbounds_002dcheck-493"></a>For front-ends that support it, generate additional code to check that
indices used to access arrays are within the declared range.  This is
currently only supported by the Java and Fortran front-ends, where
this option defaults to true and false respectively.

     <br><dt><code>-fmudflap -fmudflapth -fmudflapir</code><dd><a name="index-fmudflap-494"></a><a name="index-fmudflapth-495"></a><a name="index-fmudflapir-496"></a><a name="index-bounds-checking-497"></a><a name="index-mudflap-498"></a>For front-ends that support it (C and C++), instrument all risky
pointer/array dereferencing operations, some standard library
string/heap functions, and some other associated constructs with
range/validity tests.  Modules so instrumented should be immune to
buffer overflows, invalid heap use, and some other classes of C/C++
programming errors.  The instrumentation relies on a separate runtime
library (<samp><span class="file">libmudflap</span></samp>), which will be linked into a program if
<samp><span class="option">-fmudflap</span></samp> is given at link time.  Run-time behavior of the
instrumented program is controlled by the <samp><span class="env">MUDFLAP_OPTIONS</span></samp>
environment variable.  See <code>env MUDFLAP_OPTIONS=-help a.out</code>
for its options.

     <p>Use <samp><span class="option">-fmudflapth</span></samp> instead of <samp><span class="option">-fmudflap</span></samp> to compile and to
link if your program is multi-threaded.  Use <samp><span class="option">-fmudflapir</span></samp>, in
addition to <samp><span class="option">-fmudflap</span></samp> or <samp><span class="option">-fmudflapth</span></samp>, if
instrumentation should ignore pointer reads.  This produces less
instrumentation (and therefore faster execution) and still provides
some protection against outright memory corrupting writes, but allows
erroneously read data to propagate within a program.

     <br><dt><code>-fstrength-reduce</code><dd><a name="index-fstrength_002dreduce-499"></a>Perform the optimizations of loop strength reduction and
elimination of iteration variables.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fthread-jumps</code><dd><a name="index-fthread_002djumps-500"></a>Perform optimizations where we check to see if a jump branches to a
location where another comparison subsumed by the first is found.  If
so, the first branch is redirected to either the destination of the
second branch or a point immediately following it, depending on whether
the condition is known to be true or false.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fcse-follow-jumps</code><dd><a name="index-fcse_002dfollow_002djumps-501"></a>In common subexpression elimination, scan through jump instructions
when the target of the jump is not reached by any other path.  For
example, when CSE encounters an <code>if</code> statement with an
<code>else</code> clause, CSE will follow the jump when the condition
tested is false.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fcse-skip-blocks</code><dd><a name="index-fcse_002dskip_002dblocks-502"></a>This is similar to <samp><span class="option">-fcse-follow-jumps</span></samp>, but causes CSE to
follow jumps which conditionally skip over blocks.  When CSE
encounters a simple <code>if</code> statement with no else clause,
<samp><span class="option">-fcse-skip-blocks</span></samp> causes CSE to follow the jump around the
body of the <code>if</code>.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-frerun-cse-after-loop</code><dd><a name="index-frerun_002dcse_002dafter_002dloop-503"></a>Re-run common subexpression elimination after loop optimizations has been
performed.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-frerun-loop-opt</code><dd><a name="index-frerun_002dloop_002dopt-504"></a>Run the loop optimizer twice.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fgcse</code><dd><a name="index-fgcse-505"></a>Perform a global common subexpression elimination pass. 
This pass also performs global constant and copy propagation.

     <p><em>Note:</em> When compiling a program using computed gotos, a GCC
extension, you may get better runtime performance if you disable
the global common subexpression elimination pass by adding
<samp><span class="option">-fno-gcse</span></samp> to the command line.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fgcse-lm</code><dd><a name="index-fgcse_002dlm-506"></a>When <samp><span class="option">-fgcse-lm</span></samp> is enabled, global common subexpression elimination will
attempt to move loads which are only killed by stores into themselves.  This
allows a loop containing a load/store sequence to be changed to a load outside
the loop, and a copy/store within the loop.

     <p>Enabled by default when gcse is enabled.

     <br><dt><code>-fgcse-sm</code><dd><a name="index-fgcse_002dsm-507"></a>When <samp><span class="option">-fgcse-sm</span></samp> is enabled, a store motion pass is run after
global common subexpression elimination.  This pass will attempt to move
stores out of loops.  When used in conjunction with <samp><span class="option">-fgcse-lm</span></samp>,
loops containing a load/store sequence can be changed to a load before
the loop and a store after the loop.

     <p>Not enabled at any optimization level.

     <br><dt><code>-fgcse-las</code><dd><a name="index-fgcse_002dlas-508"></a>When <samp><span class="option">-fgcse-las</span></samp> is enabled, the global common subexpression
elimination pass eliminates redundant loads that come after stores to the
same memory location (both partial and full redundancies).

     <p>Not enabled at any optimization level.

     <br><dt><code>-fgcse-after-reload</code><dd><a name="index-fgcse_002dafter_002dreload-509"></a>When <samp><span class="option">-fgcse-after-reload</span></samp> is enabled, a redundant load elimination
pass is performed after reload.  The purpose of this pass is to cleanup
redundant spilling.

     <br><dt><code>-floop-optimize</code><dd><a name="index-floop_002doptimize-510"></a>Perform loop optimizations: move constant expressions out of loops, simplify
exit test conditions and optionally do strength-reduction as well.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O</span></samp>, <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-floop-optimize2</code><dd><a name="index-floop_002doptimize2-511"></a>Perform loop optimizations using the new loop optimizer.  The optimizations
(loop unrolling, peeling and unswitching, loop invariant motion) are enabled
by separate flags.

     <br><dt><code>-fcrossjumping</code><dd><a name="index-crossjumping-512"></a>Perform cross-jumping transformation.  This transformation unifies equivalent code and save code size.  The
resulting code may or may not perform better than without cross-jumping.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fif-conversion</code><dd><a name="index-if_002dconversion-513"></a>Attempt to transform conditional jumps into branch-less equivalents.  This
include use of conditional moves, min, max, set flags and abs instructions, and
some tricks doable by standard arithmetics.  The use of conditional execution
on chips where it is available is controlled by <code>if-conversion2</code>.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O</span></samp>, <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fif-conversion2</code><dd><a name="index-if_002dconversion2-514"></a>Use conditional execution (where available) to transform conditional jumps into
branch-less equivalents.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O</span></samp>, <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fdelete-null-pointer-checks</code><dd><a name="index-fdelete_002dnull_002dpointer_002dchecks-515"></a>Use global dataflow analysis to identify and eliminate useless checks
for null pointers.  The compiler assumes that dereferencing a null
pointer would have halted the program.  If a pointer is checked after
it has already been dereferenced, it cannot be null.

     <p>In some environments, this assumption is not true, and programs can
safely dereference null pointers.  Use
<samp><span class="option">-fno-delete-null-pointer-checks</span></samp> to disable this optimization
for programs which depend on that behavior.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fexpensive-optimizations</code><dd><a name="index-fexpensive_002doptimizations-516"></a>Perform a number of minor optimizations that are relatively expensive.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-foptimize-register-move</code><dt><code>-fregmove</code><dd><a name="index-foptimize_002dregister_002dmove-517"></a><a name="index-fregmove-518"></a>Attempt to reassign register numbers in move instructions and as
operands of other simple instructions in order to maximize the amount of
register tying.  This is especially helpful on machines with two-operand
instructions.

     <p>Note <samp><span class="option">-fregmove</span></samp> and <samp><span class="option">-foptimize-register-move</span></samp> are the same
optimization.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fdelayed-branch</code><dd><a name="index-fdelayed_002dbranch-519"></a>If supported for the target machine, attempt to reorder instructions
to exploit instruction slots available after delayed branch
instructions.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O</span></samp>, <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fschedule-insns</code><dd><a name="index-fschedule_002dinsns-520"></a>If supported for the target machine, attempt to reorder instructions to
eliminate execution stalls due to required data being unavailable.  This
helps machines that have slow floating point or memory load instructions
by allowing other instructions to be issued until the result of the load
or floating point instruction is required.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fschedule-insns2</code><dd><a name="index-fschedule_002dinsns2-521"></a>Similar to <samp><span class="option">-fschedule-insns</span></samp>, but requests an additional pass of
instruction scheduling after register allocation has been done.  This is
especially useful on machines with a relatively small number of
registers and where memory load instructions take more than one cycle.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fno-sched-interblock</code><dd><a name="index-fno_002dsched_002dinterblock-522"></a>Don't schedule instructions across basic blocks.  This is normally
enabled by default when scheduling before register allocation, i.e. 
with <samp><span class="option">-fschedule-insns</span></samp> or at <samp><span class="option">-O2</span></samp> or higher.

     <br><dt><code>-fno-sched-spec</code><dd><a name="index-fno_002dsched_002dspec-523"></a>Don't allow speculative motion of non-load instructions.  This is normally
enabled by default when scheduling before register allocation, i.e. 
with <samp><span class="option">-fschedule-insns</span></samp> or at <samp><span class="option">-O2</span></samp> or higher.

     <br><dt><code>-fsched-spec-load</code><dd><a name="index-fsched_002dspec_002dload-524"></a>Allow speculative motion of some load instructions.  This only makes
sense when scheduling before register allocation, i.e. with
<samp><span class="option">-fschedule-insns</span></samp> or at <samp><span class="option">-O2</span></samp> or higher.

     <br><dt><code>-fsched-spec-load-dangerous</code><dd><a name="index-fsched_002dspec_002dload_002ddangerous-525"></a>Allow speculative motion of more load instructions.  This only makes
sense when scheduling before register allocation, i.e. with
<samp><span class="option">-fschedule-insns</span></samp> or at <samp><span class="option">-O2</span></samp> or higher.

     <br><dt><code>-fsched-stalled-insns=</code><var>n</var><dd><a name="index-fsched_002dstalled_002dinsns-526"></a>Define how many insns (if any) can be moved prematurely from the queue
of stalled insns into the ready list, during the second scheduling pass.

     <br><dt><code>-fsched-stalled-insns-dep=</code><var>n</var><dd><a name="index-fsched_002dstalled_002dinsns_002ddep-527"></a>Define how many insn groups (cycles) will be examined for a dependency
on a stalled insn that is candidate for premature removal from the queue
of stalled insns.  Has an effect only during the second scheduling pass,
and only if <samp><span class="option">-fsched-stalled-insns</span></samp> is used and its value is not zero.

     <br><dt><code>-fsched2-use-superblocks</code><dd><a name="index-fsched2_002duse_002dsuperblocks-528"></a>When scheduling after register allocation, do use superblock scheduling
algorithm.  Superblock scheduling allows motion across basic block boundaries
resulting on faster schedules.  This option is experimental, as not all machine
descriptions used by GCC model the CPU closely enough to avoid unreliable
results from the algorithm.

     <p>This only makes sense when scheduling after register allocation, i.e. with
<samp><span class="option">-fschedule-insns2</span></samp> or at <samp><span class="option">-O2</span></samp> or higher.

     <br><dt><code>-fsched2-use-traces</code><dd><a name="index-fsched2_002duse_002dtraces-529"></a>Use <samp><span class="option">-fsched2-use-superblocks</span></samp> algorithm when scheduling after register
allocation and additionally perform code duplication in order to increase the
size of superblocks using tracer pass.  See <samp><span class="option">-ftracer</span></samp> for details on
trace formation.

     <p>This mode should produce faster but significantly longer programs.  Also
without <samp><span class="option">-fbranch-probabilities</span></samp> the traces constructed may not
match the reality and hurt the performance.  This only makes
sense when scheduling after register allocation, i.e. with
<samp><span class="option">-fschedule-insns2</span></samp> or at <samp><span class="option">-O2</span></samp> or higher.

     <br><dt><code>-freschedule-modulo-scheduled-loops</code><dd><a name="index-fscheduling_002din_002dmodulo_002dscheduled_002dloops-530"></a>The modulo scheduling comes before the traditional scheduling, if a loop was modulo scheduled
we may want to prevent the later scheduling passes from changing its schedule, we use this
option to control that.

     <br><dt><code>-fcaller-saves</code><dd><a name="index-fcaller_002dsaves-531"></a>Enable values to be allocated in registers that will be clobbered by
function calls, by emitting extra instructions to save and restore the
registers around such calls.  Such allocation is done only when it
seems to result in better code than would otherwise be produced.

     <p>This option is always enabled by default on certain machines, usually
those which have no call-preserved registers to use instead.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-ftree-pre</code><dd>Perform Partial Redundancy Elimination (PRE) on trees.  This flag is
enabled by default at <samp><span class="option">-O2</span></samp> and <samp><span class="option">-O3</span></samp>.

     <br><dt><code>-ftree-fre</code><dd>Perform Full Redundancy Elimination (FRE) on trees.  The difference
between FRE and PRE is that FRE only considers expressions
that are computed on all paths leading to the redundant computation. 
This analysis faster than PRE, though it exposes fewer redundancies. 
This flag is enabled by default at <samp><span class="option">-O</span></samp> and higher.

     <br><dt><code>-ftree-ccp</code><dd>Perform sparse conditional constant propagation (CCP) on trees.  This flag
is enabled by default at <samp><span class="option">-O</span></samp> and higher.

     <br><dt><code>-ftree-dce</code><dd>Perform dead code elimination (DCE) on trees.  This flag is enabled by
default at <samp><span class="option">-O</span></samp> and higher.

     <br><dt><code>-ftree-dominator-opts</code><dd>Perform dead code elimination (DCE) on trees.  This flag is enabled by
default at <samp><span class="option">-O</span></samp> and higher.

     <br><dt><code>-ftree-ch</code><dd>Perform loop header copying on trees.  This is beneficial since it increases
effectiveness of code motion optimizations.  It also saves one jump.  This flag
is enabled by default at <samp><span class="option">-O</span></samp> and higher.  It is not enabled
<!-- APPLE LOCAL 4231761 -Oz -->
for <samp><span class="option">-Os</span></samp> or <samp><span class="option">-Oz</span></samp> (APPLE ONLY), since it usually increases code size.

     <!-- APPLE LOCAL begin lno -->
<br><dt><code>-ftree-elim-checks</code><dd>Perform elimination of checks based on scalar evolution informations. 
This flag is disabled by default. 
<!-- APPLE LOCAL end lno -->

     <br><dt><code>-ftree-loop-optimize</code><dd>Perform loop optimizations on trees.  This flag is enabled by default
at <samp><span class="option">-O</span></samp> and higher.

     <br><dt><code>-ftree-loop-linear</code><dd>Perform linear loop transformations on tree.  This flag can improve cache
performance and allow further loop optimizations to take place. 
<!-- APPLE LOCAL begin buggy opt 4420531 3950497 3984937 4013797 -->
This flag is known to have bugs that cause incorrect code to be generated in
some rare cases. Note this flag is included in -fast. 
<!-- APPLE LOCAL end buggy opt 4420531 3950497 3984937 4013797 -->

     <br><dt><code>-ftree-loop-im</code><dd>Perform loop invariant motion on trees.  This pass moves only invariants that
would be hard to handle at RTL level (function calls, operations that expand to
nontrivial sequences of insns).  With <samp><span class="option">-funswitch-loops</span></samp> it also moves
operands of conditions that are invariant out of the loop, so that we can use
just trivial invariantness analysis in loop unswitching.  The pass also includes
store motion.

     <br><dt><code>-ftree-loop-ivcanon</code><dd>Create a canonical counter for number of iterations in the loop for that
determining number of iterations requires complicated analysis.  Later
optimizations then may determine the number easily.  Useful especially
in connection with unrolling.

     <br><dt><code>-fivopts</code><dd>Perform induction variable optimizations (strength reduction, induction
variable merging and induction variable elimination) on trees.

     <br><dt><code>-ftree-sra</code><dd>Perform scalar replacement of aggregates.  This pass replaces structure
references with scalars to prevent committing structures to memory too
early.  This flag is enabled by default at <samp><span class="option">-O</span></samp> and higher.

     <br><dt><code>-ftree-copyrename</code><dd>Perform copy renaming on trees.  This pass attempts to rename compiler
temporaries to other variables at copy locations, usually resulting in
variable names which more closely resemble the original variables.  This flag
is enabled by default at <samp><span class="option">-O</span></samp> and higher.

     <br><dt><code>-ftree-ter</code><dd>Perform temporary expression replacement during the SSA-&gt;normal phase.  Single
use/single def temporaries are replaced at their use location with their
defining expression.  This results in non-GIMPLE code, but gives the expanders
much more complex trees to work on resulting in better RTL generation.  This is
enabled by default at <samp><span class="option">-O</span></samp> and higher.

     <br><dt><code>-ftree-lrs</code><dd>Perform live range splitting during the SSA-&gt;normal phase.  Distinct live
ranges of a variable are split into unique variables, allowing for better
optimization later.  This is enabled by default at <samp><span class="option">-O</span></samp> and higher.

     <br><dt><code>-ftree-vectorize</code><dd>Perform loop vectorization on trees.

     <!-- APPLE LOCAL begin optimization -->
<p>In Apple's version of GCC, <samp><span class="option">-fstrict-aliasing</span></samp> is enabled by default
when loop vectorization is enabled. See <samp><span class="option">-fstrict-aliasing</span></samp> document
for more information. 
<!-- APPLE LOCAL end optimization -->

     <br><dt><code>-ftracer</code><dd><a name="index-ftracer-532"></a>Perform tail duplication to enlarge superblock size.  This transformation
simplifies the control flow of the function allowing other optimizations to do
better job.

     <br><dt><code>-funroll-loops</code><dd><a name="index-funroll_002dloops-533"></a>Unroll loops whose number of iterations can be determined at compile
time or upon entry to the loop.  <samp><span class="option">-funroll-loops</span></samp> implies both
<samp><span class="option">-fstrength-reduce</span></samp> and <samp><span class="option">-frerun-cse-after-loop</span></samp>.  This
option makes code larger, and may or may not make it run faster.

     <br><dt><code>-funroll-all-loops</code><dd><a name="index-funroll_002dall_002dloops-534"></a>Unroll all loops, even if their number of iterations is uncertain when
the loop is entered.  This usually makes programs run more slowly. 
<samp><span class="option">-funroll-all-loops</span></samp> implies the same options as
<samp><span class="option">-funroll-loops</span></samp>,

     <br><dt><code>-fsplit-ivs-in-unroller</code><dd><a name="index-g_t_002dfsplit_002divs_002din_002dunroller-535"></a>Enables expressing of values of induction variables in later iterations
of the unrolled loop using the value in the first iteration.  This breaks
<!-- APPLE LOCAL 3791237 mainline -->
long dependency chains, thus improving efficiency of the scheduling passes.

     <p>Combination of <samp><span class="option">-fweb</span></samp> and CSE is often sufficient to obtain the
same effect.  However in cases the loop body is more complicated than
a single basic block, this is not reliable.  It also does not work at all
on some of the architectures due to restrictions in the CSE pass.

     <p>This optimization is enabled by default.

     <br><dt><code>-fvariable-expansion-in-unroller</code><dd><a name="index-g_t_002dfvariable_002dexpansion_002din_002dunroller-536"></a>With this option, the compiler will create multiple copies of some
local variables when unrolling a loop which can result in superior code.

     <br><dt><code>-fprefetch-loop-arrays</code><dd><a name="index-fprefetch_002dloop_002darrays-537"></a>If supported by the target machine, generate instructions to prefetch
memory to improve the performance of loops that access large arrays.

     <p>These options may generate better or worse code; results are highly
dependent on the structure of loops within the source code.

     <br><dt><code>-fno-peephole</code><dt><code>-fno-peephole2</code><dd><a name="index-fno_002dpeephole-538"></a><a name="index-fno_002dpeephole2-539"></a>Disable any machine-specific peephole optimizations.  The difference
between <samp><span class="option">-fno-peephole</span></samp> and <samp><span class="option">-fno-peephole2</span></samp> is in how they
are implemented in the compiler; some targets use one, some use the
other, a few use both.

     <p><samp><span class="option">-fpeephole</span></samp> is enabled by default. 
<!-- APPLE LOCAL 4231761 -Oz -->
<samp><span class="option">-fpeephole2</span></samp> enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fno-guess-branch-probability</code><dd><a name="index-fno_002dguess_002dbranch_002dprobability-540"></a>Do not guess branch probabilities using heuristics.

     <p>GCC will use heuristics to guess branch probabilities if they are
not provided by profiling feedback (<samp><span class="option">-fprofile-arcs</span></samp>).  These
heuristics are based on the control flow graph.  If some branch probabilities
are specified by `<samp><span class="samp">__builtin_expect</span></samp>', then the heuristics will be
used to guess branch probabilities for the rest of the control flow graph,
taking the `<samp><span class="samp">__builtin_expect</span></samp>' info into account.  The interactions
between the heuristics and `<samp><span class="samp">__builtin_expect</span></samp>' can be complex, and in
some cases, it may be useful to disable the heuristics so that the effects
of `<samp><span class="samp">__builtin_expect</span></samp>' are easier to understand.

     <p>The default is <samp><span class="option">-fguess-branch-probability</span></samp> at levels
<!-- APPLE LOCAL 4231761 -Oz -->
<samp><span class="option">-O</span></samp>, <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-freorder-blocks</code><dd><a name="index-freorder_002dblocks-541"></a>Reorder basic blocks in the compiled function in order to reduce number of
taken branches and improve code locality.

     <p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>.

     <br><dt><code>-freorder-blocks-and-partition</code><dd><a name="index-freorder_002dblocks_002dand_002dpartition-542"></a>In addition to reordering basic blocks in the compiled function, in order
to reduce number of taken branches, partitions hot and cold basic blocks
into separate sections of the assembly and .o files, to improve
paging and cache locality performance.

     <p>This optimization is automatically turned off in the presence of
exception handling, for linkonce sections, for functions with a user-defined
section attribute and on any architecture that does not support named
sections.

     <br><dt><code>-freorder-functions</code><dd><a name="index-freorder_002dfunctions-543"></a>Reorder functions in the object file in order to
improve code locality.  This is implemented by using special
subsections <code>.text.hot</code> for most frequently executed functions and
<code>.text.unlikely</code> for unlikely executed functions.  Reordering is done by
the linker so object file format must support named sections and linker must
place them in a reasonable way.

     <p>Also profile feedback must be available in to make this option effective.  See
<samp><span class="option">-fprofile-arcs</span></samp> for details.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-fstrict-aliasing</code><dd><a name="index-fstrict_002daliasing-544"></a>Allows the compiler to assume the strictest aliasing rules applicable to
the language being compiled.  For C (and C++), this activates
optimizations based on the type of expressions.  In particular, an
object of one type is assumed never to reside at the same address as an
object of a different type, unless the types are almost the same.  For
example, an <code>unsigned int</code> can alias an <code>int</code>, but not a
<code>void*</code> or a <code>double</code>.  A character type may alias any other
type.

     <p>Pay special attention to code like this:
     <pre class="smallexample">          union a_union {
            int i;
            double d;
          };
          
          int f() {
            a_union t;
            t.d = 3.0;
            return t.i;
          }
     </pre>
     <p>The practice of reading from a different union member than the one most
recently written to (called &ldquo;type-punning&rdquo;) is common.  Even with
<samp><span class="option">-fstrict-aliasing</span></samp>, type-punning is allowed, provided the memory
is accessed through the union type.  So, the code above will work as
expected.  However, this code might not:
     <pre class="smallexample">          int f() {
            a_union t;
            int* ip;
            t.d = 3.0;
            ip = &amp;t.i;
            return *ip;
          }
     </pre>
     <p>Every language that wishes to perform language-specific alias analysis
should define a function that computes, given an <code>tree</code>
node, an alias set for the node.  Nodes in different alias sets are not
allowed to alias.  For an example, see the C front-end function
<code>c_get_alias_set</code>.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>, <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-falign-functions</code><dt><code>-falign-functions=</code><var>n</var><dd><a name="index-falign_002dfunctions-545"></a>Align the start of functions to the next power-of-two greater than
<var>n</var>, skipping up to <var>n</var> bytes.  For instance,
<samp><span class="option">-falign-functions=32</span></samp> aligns functions to the next 32-byte
boundary, but <samp><span class="option">-falign-functions=24</span></samp> would align to the next
32-byte boundary only if this can be done by skipping 23 bytes or less.

     <p><samp><span class="option">-fno-align-functions</span></samp> and <samp><span class="option">-falign-functions=1</span></samp> are
equivalent and mean that functions will not be aligned.

     <p>Some assemblers only support this flag when <var>n</var> is a power of two;
in that case, it is rounded up.

     <p>If <var>n</var> is not specified or is zero, use a machine-dependent default.

     <p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>.

     <br><dt><code>-falign-labels</code><dt><code>-falign-labels=</code><var>n</var><dd><a name="index-falign_002dlabels-546"></a>Align all branch targets to a power-of-two boundary, skipping up to
<var>n</var> bytes like <samp><span class="option">-falign-functions</span></samp>.  This option can easily
make code slower, because it must insert dummy operations for when the
branch target is reached in the usual flow of the code.

     <p><samp><span class="option">-fno-align-labels</span></samp> and <samp><span class="option">-falign-labels=1</span></samp> are
equivalent and mean that labels will not be aligned.

     <p>If <samp><span class="option">-falign-loops</span></samp> or <samp><span class="option">-falign-jumps</span></samp> are applicable and
are greater than this value, then their values are used instead.

     <p>If <var>n</var> is not specified or is zero, use a machine-dependent default
which is very likely to be `<samp><span class="samp">1</span></samp>', meaning no alignment.

     <p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>.

     <!-- APPLE LOCAL begin -falign-loops-max-skip -->
<br><dt><code>-falign-loops-max-skip</code><br><dt><code>-falign-loops-max-skip=</code><var>n</var><dd><a name="index-falign_002dloops_002dmax_002dskip-547"></a>Align loops to a power-of-two boundary, but do not skip more than
<var>n</var> bytes to do so. 
<!-- APPLE LOCAL end -falign-loops-max-skip -->

     <br><dt><code>-falign-loops</code><dt><code>-falign-loops=</code><var>n</var><dd><a name="index-falign_002dloops-548"></a>Align loops to a power-of-two boundary, skipping up to <var>n</var> bytes
like <samp><span class="option">-falign-functions</span></samp>.  The hope is that the loop will be
executed many times, which will make up for any execution of the dummy
operations.

     <p><samp><span class="option">-fno-align-loops</span></samp> and <samp><span class="option">-falign-loops=1</span></samp> are
equivalent and mean that loops will not be aligned.

     <p>If <var>n</var> is not specified or is zero, use a machine-dependent default.

     <p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>.

     <br><dt><code>-falign-jumps</code><dt><code>-falign-jumps=</code><var>n</var><dd><a name="index-falign_002djumps-549"></a>Align branch targets to a power-of-two boundary, for branch targets
where the targets can only be reached by jumping, skipping up to <var>n</var>
bytes like <samp><span class="option">-falign-functions</span></samp>.  In this case, no dummy operations
need be executed.

     <!-- APPLE LOCAL begin -falign-jumps-max-skip -->
<br><dt><code>-falign-jumps-max-skip</code><dt><code>-falign-jumps-max-skip=</code><var>n</var><dd><a name="index-falign_002djump_002dmax_002dskips-550"></a>Align branch targets to a power-of-two boundary, but do not skip more than
<var>n</var> bytes to do so. 
<!-- APPLE LOCAL end -falign-jumps-max-skip -->

     <p><samp><span class="option">-fno-align-jumps</span></samp> and <samp><span class="option">-falign-jumps=1</span></samp> are
equivalent and mean that loops will not be aligned.

     <p>If <var>n</var> is not specified or is zero, use a machine-dependent default.

     <p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>.

     <br><dt><code>-funit-at-a-time</code><dd><a name="index-funit_002dat_002da_002dtime-551"></a>Parse the whole compilation unit before starting to produce code. 
This allows some extra optimizations to take place but consumes
more memory (in general).  There are some compatibility issues
with <em>unit-at-at-time</em> mode:
          <ul>
<li>enabling <em>unit-at-a-time</em> mode may change the order
in which functions, variables, and top-level <code>asm</code> statements
are emitted, and will likely break code relying on some particular
ordering.  The majority of such top-level <code>asm</code> statements,
though, can be replaced by <code>section</code> attributes.

          <li><em>unit-at-a-time</em> mode removes unreferenced static variables
and functions are removed.  This may result in undefined references
when an <code>asm</code> statement refers directly to variables or functions
that are otherwise unused.  In that case either the variable/function
shall be listed as an operand of the <code>asm</code> statement operand or,
in the case of top-level <code>asm</code> statements the attribute <code>used</code>
shall be used on the declaration.

          <li>Static functions now can use non-standard passing conventions that
may break <code>asm</code> statements calling functions directly.  Again,
attribute <code>used</code> will prevent this behavior. 
</ul>

     <p>As a temporary workaround, <samp><span class="option">-fno-unit-at-a-time</span></samp> can be used,
but this scheme may not be supported by future releases of GCC.

     <p>Enabled at levels <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>.

     <br><dt><code>-fweb</code><dd><a name="index-fweb-552"></a>Constructs webs as commonly used for register allocation purposes and assign
each web individual pseudo register.  This allows the register allocation pass
to operate on pseudos directly, but also strengthens several other optimization
passes, such as CSE, loop optimizer and trivial dead code remover.  It can,
however, make debugging impossible, since variables will no longer stay in a
&ldquo;home register&rdquo;.

     <!-- APPLE LOCAL 3791237 mainline -->
<p>Enabled by default with <samp><span class="option">-funroll-loops</span></samp>.

     <br><dt><code>-fno-cprop-registers</code><dd><a name="index-fno_002dcprop_002dregisters-553"></a>After register allocation and post-register allocation instruction splitting,
we perform a copy-propagation pass to try to reduce scheduling dependencies
and occasionally eliminate the copy.

     <!-- APPLE LOCAL begin 4231761 -Oz -->
<p>Disabled at levels <samp><span class="option">-O</span></samp>, <samp><span class="option">-O2</span></samp>, <samp><span class="option">-O3</span></samp>, <samp><span class="option">-Os</span></samp>,
<samp><span class="option">-Oz</span></samp> (APPLE ONLY). 
<!-- APPLE LOCAL end 4231761 -Oz -->

     <br><dt><code>-fprofile-generate</code><dd><a name="index-fprofile_002dgenerate-554"></a>
Enable options usually used for instrumenting application to produce
profile useful for later recompilation with profile feedback based
optimization.  You must use <samp><span class="option">-fprofile-generate</span></samp> both when
compiling and when linking your program.

     <p>The following options are enabled: <code>-fprofile-arcs</code>, <code>-fprofile-values</code>, <code>-fvpt</code>.

     <br><dt><code>-fprofile-use</code><dd><a name="index-fprofile_002duse-555"></a>Enable profile feedback directed optimizations, and optimizations
generally profitable only with profile feedback available.

     <p>The following options are enabled: <code>-fbranch-probabilities</code>,
<code>-fvpt</code>, <code>-funroll-loops</code>, <code>-fpeel-loops</code>, <code>-ftracer</code>.

 </dl>

 <p>The following options control compiler behavior regarding floating
point arithmetic.  These options trade off between speed and
correctness.  All must be specifically enabled.

     <dl>
<dt><code>-ffloat-store</code><dd><a name="index-ffloat_002dstore-556"></a>Do not store floating point variables in registers, and inhibit other
options that might change whether a floating point value is taken from a
register or memory.

     <p><a name="index-floating-point-precision-557"></a>This option prevents undesirable excess precision on machines such as
the 68000 where the floating registers (of the 68881) keep more
precision than a <code>double</code> is supposed to have.  Similarly for the
x86 architecture.  For most programs, the excess precision does only
good, but a few programs rely on the precise definition of IEEE floating
point.  Use <samp><span class="option">-ffloat-store</span></samp> for such programs, after modifying
them to store all pertinent intermediate computations into variables.

     <br><dt><code>-ffast-math</code><dd><a name="index-ffast_002dmath-558"></a>Sets <samp><span class="option">-fno-math-errno</span></samp>, <samp><span class="option">-funsafe-math-optimizations</span></samp>, <br>
<samp><span class="option">-fno-trapping-math</span></samp>, <samp><span class="option">-ffinite-math-only</span></samp>,
<samp><span class="option">-fno-rounding-math</span></samp>, <samp><span class="option">-fno-signaling-nans</span></samp>
and <samp><span class="option">fcx-limited-range</span></samp>.

     <p>This option causes the preprocessor macro <code>__FAST_MATH__</code> to be defined.

     <p>This option should never be turned on by any <samp><span class="option">-O</span></samp> option since
it can result in incorrect output for programs which depend on
an exact implementation of IEEE or ISO rules/specifications for
math functions.

     <br><dt><code>-fno-math-errno</code><dd><a name="index-fno_002dmath_002derrno-559"></a>Do not set ERRNO after calling math functions that are executed
with a single instruction, e.g., sqrt.  A program that relies on
IEEE exceptions for math error handling may want to use this flag
for speed while maintaining IEEE arithmetic compatibility.

     <!-- APPLE LOCAL begin disable math-errno -->
<p>(APPLE ONLY) The Darwin math libraries never set errno, so there is
no point in having the compiler generate code that assumes they
might.  Therefore, the default is <samp><span class="option">-fno-math-errno</span></samp> on Darwin. 
<!-- APPLE LOCAL end disable math-errno -->

     <br><dt><code>-funsafe-math-optimizations</code><dd><a name="index-funsafe_002dmath_002doptimizations-560"></a>Allow optimizations for floating-point arithmetic that (a) assume
that arguments and results are valid and (b) may violate IEEE or
ANSI standards.  When used at link-time, it may include libraries
or startup files that change the default FPU control word or other
similar optimizations.

     <p>This option should never be turned on by any <samp><span class="option">-O</span></samp> option since
it can result in incorrect output for programs which depend on
an exact implementation of IEEE or ISO rules/specifications for
math functions.

     <p>The default is <samp><span class="option">-fno-unsafe-math-optimizations</span></samp>.

     <br><dt><code>-ffinite-math-only</code><dd><a name="index-ffinite_002dmath_002donly-561"></a>Allow optimizations for floating-point arithmetic that assume
that arguments and results are not NaNs or +-Infs.

     <p>This option should never be turned on by any <samp><span class="option">-O</span></samp> option since
it can result in incorrect output for programs which depend on
an exact implementation of IEEE or ISO rules/specifications.

     <p>The default is <samp><span class="option">-fno-finite-math-only</span></samp>.

     <br><dt><code>-fno-trapping-math</code><dd><a name="index-fno_002dtrapping_002dmath-562"></a>Compile code assuming that floating-point operations cannot generate
user-visible traps.  These traps include division by zero, overflow,
underflow, inexact result and invalid operation.  This option implies
<samp><span class="option">-fno-signaling-nans</span></samp>.  Setting this option may allow faster
code if one relies on &ldquo;non-stop&rdquo; IEEE arithmetic, for example.

     <p>This option should never be turned on by any <samp><span class="option">-O</span></samp> option since
it can result in incorrect output for programs which depend on
an exact implementation of IEEE or ISO rules/specifications for
math functions.

     <p>The default is <samp><span class="option">-ftrapping-math</span></samp>.

     <br><dt><code>-frounding-math</code><dd><a name="index-frounding_002dmath-563"></a>Disable transformations and optimizations that assume default floating
point rounding behavior.  This is round-to-zero for all floating point
to integer conversions, and round-to-nearest for all other arithmetic
truncations.  This option should be specified for programs that change
the FP rounding mode dynamically, or that may be executed with a
non-default rounding mode.  This option disables constant folding of
floating point expressions at compile-time (which may be affected by
rounding mode) and arithmetic transformations that are unsafe in the
presence of sign-dependent rounding modes.

     <p>The default is <samp><span class="option">-fno-rounding-math</span></samp>.

     <p>This option is experimental and does not currently guarantee to
disable all GCC optimizations that are affected by rounding mode. 
Future versions of GCC may provide finer control of this setting
using C99's <code>FENV_ACCESS</code> pragma.  This command line option
will be used to specify the default state for <code>FENV_ACCESS</code>.

     <br><dt><code>-fsignaling-nans</code><dd><a name="index-fsignaling_002dnans-564"></a>Compile code assuming that IEEE signaling NaNs may generate user-visible
traps during floating-point operations.  Setting this option disables
optimizations that may change the number of exceptions visible with
signaling NaNs.  This option implies <samp><span class="option">-ftrapping-math</span></samp>.

     <p>This option causes the preprocessor macro <code>__SUPPORT_SNAN__</code> to
be defined.

     <p>The default is <samp><span class="option">-fno-signaling-nans</span></samp>.

     <p>This option is experimental and does not currently guarantee to
disable all GCC optimizations that affect signaling NaN behavior.

     <br><dt><code>-fsingle-precision-constant</code><dd><a name="index-fsingle_002dprecision_002dconstant-565"></a>Treat floating point constant as single precision constant instead of
implicitly converting it to double precision constant.

     <br><dt><code>-fcx-limited-range</code><dt><code>-fno-cx-limited-range</code><dd><a name="index-fcx_002dlimited_002drange-566"></a><a name="index-fno_002dcx_002dlimited_002drange-567"></a>When enabled, this option states that a range reduction step is not
needed when performing complex division.  The default is
<samp><span class="option">-fno-cx-limited-range</span></samp>, but is enabled by <samp><span class="option">-ffast-math</span></samp>.

     <p>This option controls the default setting of the ISO C99
<code>CX_LIMITED_RANGE</code> pragma.  Nevertheless, the option applies to
all languages.

 </dl>

 <p>The following options control optimizations that may improve
performance, but are not enabled by any <samp><span class="option">-O</span></samp> options.  This
section includes experimental options that may produce broken code.

     <dl>
<dt><code>-fbranch-probabilities</code><dd><a name="index-fbranch_002dprobabilities-568"></a>After running a program compiled with <samp><span class="option">-fprofile-arcs</span></samp>
(see <a href="Debugging-Options.html#Debugging-Options">Options for Debugging Your Program or <samp><span class="command">gcc</span></samp></a>), you can compile it a second time using
<samp><span class="option">-fbranch-probabilities</span></samp>, to improve optimizations based on
the number of times each branch was taken.  When the program
compiled with <samp><span class="option">-fprofile-arcs</span></samp> exits it saves arc execution
counts to a file called <samp><var>sourcename</var><span class="file">.gcda</span></samp> for each source
file  The information in this data file is very dependent on the
structure of the generated code, so you must use the same source code
and the same optimization options for both compilations.

     <p>With <samp><span class="option">-fbranch-probabilities</span></samp>, GCC puts a
`<samp><span class="samp">REG_BR_PROB</span></samp>' note on each `<samp><span class="samp">JUMP_INSN</span></samp>' and `<samp><span class="samp">CALL_INSN</span></samp>'. 
These can be used to improve optimization.  Currently, they are only
used in one place: in <samp><span class="file">reorg.c</span></samp>, instead of guessing which path a
branch is mostly to take, the `<samp><span class="samp">REG_BR_PROB</span></samp>' values are used to
exactly determine which path is taken more often.

     <br><dt><code>-fprofile-values</code><dd><a name="index-fprofile_002dvalues-569"></a>If combined with <samp><span class="option">-fprofile-arcs</span></samp>, it adds code so that some
data about values of expressions in the program is gathered.

     <p>With <samp><span class="option">-fbranch-probabilities</span></samp>, it reads back the data gathered
from profiling values of expressions and adds `<samp><span class="samp">REG_VALUE_PROFILE</span></samp>'
notes to instructions for their later usage in optimizations.

     <p>Enabled with <samp><span class="option">-fprofile-generate</span></samp> and <samp><span class="option">-fprofile-use</span></samp>.

     <br><dt><code>-fvpt</code><dd><a name="index-fvpt-570"></a>If combined with <samp><span class="option">-fprofile-arcs</span></samp>, it instructs the compiler to add
a code to gather information about values of expressions.

     <p>With <samp><span class="option">-fbranch-probabilities</span></samp>, it reads back the data gathered
and actually performs the optimizations based on them. 
Currently the optimizations include specialization of division operation
using the knowledge about the value of the denominator.

     <br><dt><code>-fspeculative-prefetching</code><dd><a name="index-fspeculative_002dprefetching-571"></a>If combined with <samp><span class="option">-fprofile-arcs</span></samp>, it instructs the compiler to add
a code to gather information about addresses of memory references in the
program.

     <p>With <samp><span class="option">-fbranch-probabilities</span></samp>, it reads back the data gathered
and issues prefetch instructions according to them.  In addition to the opportunities
noticed by <samp><span class="option">-fprefetch-loop-arrays</span></samp>, it also notices more complicated
memory access patterns&mdash;for example accesses to the data stored in linked
list whose elements are usually allocated sequentially.

     <p>In order to prevent issuing double prefetches, usage of
<samp><span class="option">-fspeculative-prefetching</span></samp> implies <samp><span class="option">-fno-prefetch-loop-arrays</span></samp>.

     <p>Enabled with <samp><span class="option">-fprofile-generate</span></samp> and <samp><span class="option">-fprofile-use</span></samp>.

     <br><dt><code>-frename-registers</code><dd><a name="index-frename_002dregisters-572"></a>Attempt to avoid false dependencies in scheduled code by making use
of registers left over after register allocation.  This optimization
will most benefit processors with lots of registers.  Depending on the
debug information format adopted by the target, however, it can
make debugging impossible, since variables will no longer stay in
a &ldquo;home register&rdquo;.

     <p>Not enabled by default at any level because it has known bugs.

     <br><dt><code>-ftracer</code><dd><a name="index-ftracer-573"></a>Perform tail duplication to enlarge superblock size.  This transformation
simplifies the control flow of the function allowing other optimizations to do
better job.

     <p>Enabled with <samp><span class="option">-fprofile-use</span></samp>.

     <br><dt><code>-funroll-loops</code><dd><a name="index-funroll_002dloops-574"></a>Unroll loops whose number of iterations can be determined at compile time or
upon entry to the loop.  <samp><span class="option">-funroll-loops</span></samp> implies
<!-- APPLE LOCAL begin 3791237 -->
<samp><span class="option">-frerun-cse-after-loop</span></samp> and <samp><span class="option">-fweb</span></samp>. 
It also turns on complete loop peeling (i.e. complete removal of loops with
small constant number of iterations).  This option makes code larger, and may
or may not make it run faster. 
<!-- APPLE LOCAL end 3791237 -->

     <p>Enabled with <samp><span class="option">-fprofile-use</span></samp>.

     <br><dt><code>-funroll-all-loops</code><dd><a name="index-funroll_002dall_002dloops-575"></a>Unroll all loops, even if their number of iterations is uncertain when
the loop is entered.  This usually makes programs run more slowly. 
<samp><span class="option">-funroll-all-loops</span></samp> implies the same options as
<samp><span class="option">-funroll-loops</span></samp>.

     <br><dt><code>-fpeel-loops</code><dd><a name="index-fpeel_002dloops-576"></a>Peels the loops for that there is enough information that they do not
roll much (from profile feedback).  It also turns on complete loop peeling
(i.e. complete removal of loops with small constant number of iterations).

     <p>Enabled with <samp><span class="option">-fprofile-use</span></samp>.

     <br><dt><code>-fmove-loop-invariants</code><dd><a name="index-fmove_002dloop_002dinvariants-577"></a>Enables the loop invariant motion pass in the new loop optimizer.  Enabled
at level <samp><span class="option">-O1</span></samp>

     <br><dt><code>-funswitch-loops</code><dd><a name="index-funswitch_002dloops-578"></a>Move branches with loop invariant conditions out of the loop, with duplicates
of the loop on both branches (modified according to result of the condition).

     <br><dt><code>-fprefetch-loop-arrays</code><dd><a name="index-fprefetch_002dloop_002darrays-579"></a>If supported by the target machine, generate instructions to prefetch
memory to improve the performance of loops that access large arrays.

     <!-- APPLE LOCAL 4231761 -Oz -->
<p>Disabled at levels <samp><span class="option">-Os</span></samp> and <samp><span class="option">-Oz</span></samp> (APPLE ONLY).

     <br><dt><code>-ffunction-sections</code><dt><code>-fdata-sections</code><dd><a name="index-ffunction_002dsections-580"></a><a name="index-fdata_002dsections-581"></a>Place each function or data item into its own section in the output
file if the target supports arbitrary sections.  The name of the
function or the name of the data item determines the section's name
in the output file.

     <p>Use these options on systems where the linker can perform optimizations
to improve locality of reference in the instruction space.  Most systems
using the ELF object format and SPARC processors running Solaris 2 have
linkers with such optimizations.  AIX may have these optimizations in
the future.

     <p>Only use these options when there are significant benefits from doing
so.  When you specify these options, the assembler and linker will
create larger object and executable files and will also be slower. 
You will not be able to use <code>gprof</code> on all systems if you
specify this option and you may have problems with debugging if
you specify both this option and <samp><span class="option">-g</span></samp>.

     <br><dt><code>-fbranch-target-load-optimize</code><dd><a name="index-fbranch_002dtarget_002dload_002doptimize-582"></a>Perform branch target register load optimization before prologue / epilogue
threading. 
The use of target registers can typically be exposed only during reload,
thus hoisting loads out of loops and doing inter-block scheduling needs
a separate optimization pass.

     <br><dt><code>-fbranch-target-load-optimize2</code><dd><a name="index-fbranch_002dtarget_002dload_002doptimize2-583"></a>Perform branch target register load optimization after prologue / epilogue
threading.

     <br><dt><code>-fbtr-bb-exclusive</code><dd><a name="index-fbtr_002dbb_002dexclusive-584"></a>When performing branch target register load optimization, don't reuse
branch target registers in within any basic block. 
<!-- APPLE LOCAL begin mainline -->

     <br><dt><code>-fstack-protector</code><dd>Emit extra code to check for buffer overflows, such as stack smashing
attacks.  This is done by adding a guard variable to functions with
vulnerable objects.  This includes functions that call alloca, and
functions with buffers larger than 8 bytes.  The guards are initialized
when a function is entered and then checked when the function exits. 
If a guard check fails, an error message is printed and the program exits.

     <br><dt><code>-fstack-protector-all</code><dd>Like <samp><span class="option">-fstack-protector</span></samp> except that all functions are protected. 
<!-- APPLE LOCAL end mainline -->

     <br><dt><code>--param </code><var>name</var><code>=</code><var>value</var><dd><a name="index-param-585"></a>In some places, GCC uses various constants to control the amount of
optimization that is done.  For example, GCC will not inline functions
that contain more that a certain number of instructions.  You can
control some of these constants on the command-line using the
<samp><span class="option">--param</span></samp> option.

     <p>The names of specific parameters, and the meaning of the values, are
tied to the internals of the compiler, and are subject to change
without notice in future releases.

     <p>In each case, the <var>value</var> is an integer.  The allowable choices for
<var>name</var> are given in the following table:

          <dl>
<dt><code>sra-max-structure-size</code><dd>The maximum structure size, in bytes, at which the scalar replacement
of aggregates (SRA) optimization will perform block copies.  The
default value, 0, implies that GCC will select the most appropriate
size itself.

          <br><dt><code>sra-field-structure-ratio</code><dd>The threshold ratio (as a percentage) between instantiated fields and
the complete structure size.  We say that if the ratio of the number
of bytes in instantiated fields to the number of bytes in the complete
structure exceeds this parameter, then block copies are not used.  The
default is 75.

          <br><dt><code>max-crossjump-edges</code><dd>The maximum number of incoming edges to consider for crossjumping. 
The algorithm used by <samp><span class="option">-fcrossjumping</span></samp> is O(N^2) in
the number of edges incoming to each block.  Increasing values mean
more aggressive optimization, making the compile time increase with
probably small improvement in executable size.

          <br><dt><code>min-crossjump-insns</code><dd>The minimum number of instructions which must be matched at the end
of two blocks before crossjumping will be performed on them.  This
value is ignored in the case where all instructions in the block being
crossjumped from are matched.  The default value is 5.

          <br><dt><code>max-goto-duplication-insns</code><dd>The maximum number of instructions to duplicate to a block that jumps
to a computed goto.  To avoid O(N^2) behavior in a number of
passes, GCC factors computed gotos early in the compilation process,
and unfactors them as late as possible.  Only computed jumps at the
end of a basic blocks with no more than max-goto-duplication-insns are
unfactored.  The default value is 8.

          <br><dt><code>max-delay-slot-insn-search</code><dd>The maximum number of instructions to consider when looking for an
instruction to fill a delay slot.  If more than this arbitrary number of
instructions is searched, the time savings from filling the delay slot
will be minimal so stop searching.  Increasing values mean more
aggressive optimization, making the compile time increase with probably
small improvement in executable run time.

          <br><dt><code>max-delay-slot-live-search</code><dd>When trying to fill delay slots, the maximum number of instructions to
consider when searching for a block with valid live register
information.  Increasing this arbitrarily chosen value means more
aggressive optimization, increasing the compile time.  This parameter
should be removed when the delay slot code is rewritten to maintain the
control-flow graph.

          <br><dt><code>max-gcse-memory</code><dd>The approximate maximum amount of memory that will be allocated in
order to perform the global common subexpression elimination
optimization.  If more memory than specified is required, the
optimization will not be done.

          <br><dt><code>max-gcse-passes</code><dd>The maximum number of passes of GCSE to run.  The default is 1.

          <br><dt><code>max-pending-list-length</code><dd>The maximum number of pending dependencies scheduling will allow
before flushing the current state and starting over.  Large functions
with few branches or calls can create excessively large lists which
needlessly consume memory and resources.

          <br><dt><code>max-inline-insns-single</code><dd>Several parameters control the tree inliner used in gcc. 
This number sets the maximum number of instructions (counted in GCC's
internal representation) in a single function that the tree inliner
will consider for inlining.  This only affects functions declared
inline and methods implemented in a class declaration (C++). 
The default value is 450.

          <br><dt><code>max-inline-insns-auto</code><dd>When you use <samp><span class="option">-finline-functions</span></samp> (included in <samp><span class="option">-O3</span></samp>),
a lot of functions that would otherwise not be considered for inlining
by the compiler will be investigated.  To those functions, a different
(more restrictive) limit compared to functions declared inline can
be applied. 
The default value is 90.

          <br><dt><code>large-function-insns</code><dd>The limit specifying really large functions.  For functions larger than this
limit after inlining inlining is constrained by
<samp><span class="option">--param large-function-growth</span></samp>.  This parameter is useful primarily
to avoid extreme compilation time caused by non-linear algorithms used by the
backend. 
This parameter is ignored when <samp><span class="option">-funit-at-a-time</span></samp> is not used. 
The default value is 2700.

          <br><dt><code>large-function-growth</code><dd>Specifies maximal growth of large function caused by inlining in percents. 
This parameter is ignored when <samp><span class="option">-funit-at-a-time</span></samp> is not used. 
The default value is 100 which limits large function growth to 2.0 times
the original size.

          <br><dt><code>inline-unit-growth</code><dd>Specifies maximal overall growth of the compilation unit caused by inlining. 
This parameter is ignored when <samp><span class="option">-funit-at-a-time</span></samp> is not used. 
The default value is 50 which limits unit growth to 1.5 times the original
size.

          <br><dt><code>max-inline-insns-recursive</code><dt><code>max-inline-insns-recursive-auto</code><dd>Specifies maximum number of instructions out-of-line copy of self recursive inline
function can grow into by performing recursive inlining.

          <p>For functions declared inline <samp><span class="option">--param max-inline-insns-recursive</span></samp> is
taken into acount.  For function not declared inline, recursive inlining
happens only when <samp><span class="option">-finline-functions</span></samp> (included in <samp><span class="option">-O3</span></samp>) is
enabled and <samp><span class="option">--param max-inline-insns-recursive-auto</span></samp> is used.  The
default value is 450.

          <br><dt><code>max-inline-recursive-depth</code><dt><code>max-inline-recursive-depth-auto</code><dd>Specifies maximum recursion depth used by the recursive inlining.

          <p>For functions declared inline <samp><span class="option">--param max-inline-recursive-depth</span></samp> is
taken into acount.  For function not declared inline, recursive inlining
happens only when <samp><span class="option">-finline-functions</span></samp> (included in <samp><span class="option">-O3</span></samp>) is
enabled and <samp><span class="option">--param max-inline-recursive-depth-auto</span></samp> is used.  The
default value is 450.

          <br><dt><code>inline-call-cost</code><dd>Specify cost of call instruction relative to simple arithmetics operations
(having cost of 1).  Increasing this cost disqualify inlinining of non-leaf
functions and at same time increase size of leaf function that is believed to
reduce function size by being inlined.  In effect it increase amount of
inlining for code having large abstraction penalty (many functions that just
pass the argumetns to other functions) and decrease inlining for code with low
abstraction penalty.  Default value is 16.

          <br><dt><code>max-unrolled-insns</code><dd>The maximum number of instructions that a loop should have if that loop
is unrolled, and if the loop is unrolled, it determines how many times
the loop code is unrolled.

          <br><dt><code>max-average-unrolled-insns</code><dd>The maximum number of instructions biased by probabilities of their execution
that a loop should have if that loop is unrolled, and if the loop is unrolled,
it determines how many times the loop code is unrolled.

          <br><dt><code>max-unroll-times</code><dd>The maximum number of unrollings of a single loop.

          <br><dt><code>max-peeled-insns</code><dd>The maximum number of instructions that a loop should have if that loop
is peeled, and if the loop is peeled, it determines how many times
the loop code is peeled.

          <br><dt><code>max-peel-times</code><dd>The maximum number of peelings of a single loop.

          <br><dt><code>max-completely-peeled-insns</code><dd>The maximum number of insns of a completely peeled loop.

          <br><dt><code>max-completely-peel-times</code><dd>The maximum number of iterations of a loop to be suitable for complete peeling.

          <br><dt><code>max-unswitch-insns</code><dd>The maximum number of insns of an unswitched loop.

          <br><dt><code>max-unswitch-level</code><dd>The maximum number of branches unswitched in a single loop.

          <br><dt><code>lim-expensive</code><dd>The minimum cost of an expensive expression in the loop invariant motion.

          <br><dt><code>iv-consider-all-candidates-bound</code><dd>Bound on number of candidates for induction variables below that
all candidates are considered for each use in induction variable
optimizations.  Only the most relevant candidates are considered
if there are more candidates, to avoid quadratic time complexity.

          <br><dt><code>iv-max-considered-uses</code><dd>The induction variable optimizations give up on loops that contain more
induction variable uses.

          <br><dt><code>iv-always-prune-cand-set-bound</code><dd>If number of candidates in the set is smaller than this value,
we always try to remove unnecessary ivs from the set during its
optimization when a new iv is added to the set.

          <br><dt><code>scev-max-expr-size</code><dd>Bound on size of expressions used in the scalar evolutions analyzer. 
Large expressions slow the analyzer.

          <br><dt><code>max-iterations-to-track</code><dd>
The maximum number of iterations of a loop the brute force algorithm
for analysis of # of iterations of the loop tries to evaluate.

          <br><dt><code>hot-bb-count-fraction</code><dd>Select fraction of the maximal count of repetitions of basic block in program
given basic block needs to have to be considered hot.

          <br><dt><code>hot-bb-frequency-fraction</code><dd>Select fraction of the maximal frequency of executions of basic block in
function given basic block needs to have to be considered hot

          <br><dt><code>tracer-dynamic-coverage</code><dt><code>tracer-dynamic-coverage-feedback</code><dd>
This value is used to limit superblock formation once the given percentage of
executed instructions is covered.  This limits unnecessary code size
expansion.

          <p>The <samp><span class="option">tracer-dynamic-coverage-feedback</span></samp> is used only when profile
feedback is available.  The real profiles (as opposed to statically estimated
ones) are much less balanced allowing the threshold to be larger value.

          <br><dt><code>tracer-max-code-growth</code><dd>Stop tail duplication once code growth has reached given percentage.  This is
rather hokey argument, as most of the duplicates will be eliminated later in
cross jumping, so it may be set to much higher values than is the desired code
growth.

          <br><dt><code>tracer-min-branch-ratio</code><dd>
Stop reverse growth when the reverse probability of best edge is less than this
threshold (in percent).

          <br><dt><code>tracer-min-branch-ratio</code><dt><code>tracer-min-branch-ratio-feedback</code><dd>
Stop forward growth if the best edge do have probability lower than this
threshold.

          <p>Similarly to <samp><span class="option">tracer-dynamic-coverage</span></samp> two values are present, one for
compilation for profile feedback and one for compilation without.  The value
for compilation with profile feedback needs to be more conservative (higher) in
order to make tracer effective.

          <br><dt><code>max-cse-path-length</code><dd>
Maximum number of basic blocks on path that cse considers.  The default is 10.

          <br><dt><code>global-var-threshold</code><dd>
Counts the number of function calls (<var>n</var>) and the number of
call-clobbered variables (<var>v</var>).  If <var>n</var>x<var>v</var> is larger than this limit, a
single artificial variable will be created to represent all the
call-clobbered variables at function call sites.  This artificial
variable will then be made to alias every call-clobbered variable. 
(done as <code>int * size_t</code> on the host machine; beware overflow).

          <br><dt><code>max-aliased-vops</code><dd>
Maximum number of virtual operands allowed to represent aliases
before triggering the alias grouping heuristic.  Alias grouping
reduces compile times and memory consumption needed for aliasing at
the expense of precision loss in alias information.

          <br><dt><code>ggc-min-expand</code><dd>
GCC uses a garbage collector to manage its own memory allocation.  This
parameter specifies the minimum percentage by which the garbage
collector's heap should be allowed to expand between collections. 
Tuning this may improve compilation speed; it has no effect on code
generation.

          <p>The default is 30% + 70% * (RAM/1GB) with an upper bound of 100% when
RAM &gt;= 1GB.  If <code>getrlimit</code> is available, the notion of "RAM" is
the smallest of actual RAM and <code>RLIMIT_DATA</code> or <code>RLIMIT_AS</code>.  If
GCC is not able to calculate RAM on a particular platform, the lower
bound of 30% is used.  Setting this parameter and
<samp><span class="option">ggc-min-heapsize</span></samp> to zero causes a full collection to occur at
every opportunity.  This is extremely slow, but can be useful for
debugging.

          <br><dt><code>ggc-min-heapsize</code><dd>
Minimum size of the garbage collector's heap before it begins bothering
to collect garbage.  The first collection occurs after the heap expands
by <samp><span class="option">ggc-min-expand</span></samp>% beyond <samp><span class="option">ggc-min-heapsize</span></samp>.  Again,
tuning this may improve compilation speed, and has no effect on code
generation.

          <p>The default is the smaller of RAM/8, RLIMIT_RSS, or a limit which
tries to ensure that RLIMIT_DATA or RLIMIT_AS are not exceeded, but
with a lower bound of 4096 (four megabytes) and an upper bound of
131072 (128 megabytes).  If GCC is not able to calculate RAM on a
particular platform, the lower bound is used.  Setting this parameter
very large effectively disables garbage collection.  Setting this
parameter and <samp><span class="option">ggc-min-expand</span></samp> to zero causes a full collection
to occur at every opportunity.

          <br><dt><code>max-reload-search-insns</code><dd>The maximum number of instruction reload should look backward for equivalent
register.  Increasing values mean more aggressive optimization, making the
compile time increase with probably slightly better performance.  The default
value is 100.

          <br><dt><code>max-cselib-memory-location</code><dd>The maximum number of memory locations cselib should take into acount. 
Increasing values mean more aggressive optimization, making the compile time
increase with probably slightly better performance.  The default value is 500.

          <br><dt><code>reorder-blocks-duplicate</code><dt><code>reorder-blocks-duplicate-feedback</code><dd>
Used by basic block reordering pass to decide whether to use unconditional
branch or duplicate the code on its destination.  Code is duplicated when its
estimated size is smaller than this value multiplied by the estimated size of
unconditional jump in the hot spots of the program.

          <p>The <samp><span class="option">reorder-block-duplicate-feedback</span></samp> is used only when profile
feedback is available and may be set to higher values than
<samp><span class="option">reorder-block-duplicate</span></samp> since information about the hot spots is more
accurate.

          <br><dt><code>max-sched-region-blocks</code><dd>The maximum number of blocks in a region to be considered for
interblock scheduling.  The default value is 10.

          <br><dt><code>max-sched-region-insns</code><dd>The maximum number of insns in a region to be considered for
interblock scheduling.  The default value is 100.

          <br><dt><code>max-last-value-rtl</code><dd>
The maximum size measured as number of RTLs that can be recorded in an expression
in combiner for a pseudo register as last known value of that register.  The default
is 10000.

          <br><dt><code>integer-share-limit</code><dd>Small integer constants can use a shared data structure, reducing the
compiler's memory usage and increasing its speed.  This sets the maximum
value of a shared integer constant's.  The default value is 256. 
<!-- APPLE LOCAL begin mainline -->
<br><dt><code>ssp-buffer-size</code><dd>The minimum size of buffers (i.e. arrays) that will receive stack smashing
protection when <samp><span class="option">-fstack-protection</span></samp> is used. 
<!-- APPLE LOCAL end mainline -->
</dl>
     </dl>

 </body></html>

