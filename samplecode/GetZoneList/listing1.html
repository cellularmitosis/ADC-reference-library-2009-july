<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GetZoneList - /GetZoneList.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">GetZoneList</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GetZoneList</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/GetZoneList.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/GetZoneList.c</option>
<option value="listing2.html">/GetZoneList.p</option>
<option value="listing3.html">/GetZoneList.r</option>
<option value="listing4.html">/UFailure.a</option>
<option value="listing5.html">/UFailure.h</option>
<option value="listing6.html">/UFailure.inc1.p</option>
<option value="listing7.html">/UFailure.p</option></select>
				</p>
				</form>
				<p><strong><a href="GetZoneList.zip">Download Sample</a></strong> (&#147;GetZoneList.zip&#148;, 47.2K)<BR>
<strong><a href="GetZoneList.dmg">Download Sample</a></strong> (&#147;GetZoneList.dmg&#148;, 104.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/* ------------------------------------------------------------------------------##  Apple Macintosh Developer Technical Support##  AppleTalk GetZoneList Sample Application##  GetZoneList##  GetZoneList.c  -  C Source##  Copyright &copy; 1988-90 Apple Computer, Inc.#  All rights reserved.##  Versions:  1.00        November 1988#        1.01        October 1989#        1.02        May 1990#        1.03        June 1992#        1.04        July 1992##  Components:  GetZoneList.c    May 1, 1990#        GetZoneList.p    May 1, 1990#        GetZoneList.r    May 1, 1990#        MakeFile      May 1, 1990#        UFailure.a      November 1, 1988#        UFailure.h      November 1, 1988#        UFailure.inc1.p    November 1, 1988#        UFailure.p      November 1, 1988##  GetZoneList is a sample application that uses#  AppleTalk ATP and ZIP to obtain a list of zones#  on an AppleTalk internet.##  GetZoneList also demonstrates using a signal, or#  failure-catching mechanism to recover from error#  situations.  Since C does not allow nested procedures#  a la Pascal, a few modifications were made to incorporate#  the failure handling and keep this sample fairly close in#  design to the Pascal sample.#  (Gee, thanks a lot M2 for using nested procs. - pvh)##  GetZoneList is based on DTS Sample.c. For more#  description and explanation of the non-example#  specific areas of this application, please refer to#  either Sample.p or TESample.c.#------------------------------------------------------------------------------ */#include &lt;Limits.h&gt;#include &lt;Types.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;Fonts.h&gt;#include &lt;Events.h&gt;#include &lt;Controls.h&gt;#include &lt;Windows.h&gt;#include &lt;Menus.h&gt;#include &lt;TextEdit.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Packages.h&gt;#include &lt;Menus.h&gt;#include &lt;Devices.h&gt;#include &lt;Events.h&gt;#include &lt;Scrap.h&gt;#include &lt;Lists.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;Memory.h&gt;#include &lt;SegLoad.h&gt;#include &lt;Errors.h&gt;#include &lt;Files.h&gt;#include &lt;OSUtils.h&gt;#include &lt;AppleTalk.h&gt;#include &lt;Traps.h&gt;#include &lt;DiskInit.h&gt;#include &lt;Script.h&gt;#include &lt;UFailure.h&gt;typedef XCallParam *XCallParamPtr;#define    kSysEnvironsVersion    1#define    kOSEvent        app4Evt    /* event used by Multifinder */#define    kSuspendResumeMessage  1      /* high byte of suspend/resume event message */#define    kResumeMask        1      /* bit of message field for resume vs. suspend */#define    kCR            13      /* carriage return character */#define    kENTER          3      /* enter character */#define    kScrollBarWidth      15      /* the width of the scrollbar in the list */#define    kListInset        -1      /* adjustment for list frame */#define    kATPTimeOutVal      3      /* re-try ATP SendRequest every 3 seconds */#define    kATPRetryCount      5      /* for five times */#define    kZonesSize        578      /* size of buffer for zone names */#define    kGZLCall        0x08000000  /* GetZoneList indicator */#define    kZIPSocket        6      /* the Zone Information Protocol socket */#define    kMoreZones        0xFF000000   /* mask to see if more zones to come */#define    kZoneCount        0x0000FFFF   /* mask to count zones in buffer */#define    kHilite          1      /* hilite value for button control */#define    kDeHilite        0      /* dehilite value for button control */#define    kHiliteDelay      8      /* time in ticks to leave button hilited */#define    kMinHeap        (29 * 1024)#define    kMinSpace        (20 * 1024)#define    sErrStrings        128      /* error string STR# */#define    eStandardErr      1#define    eWrongMachine      2#define    eSmallSize        3#define    eNoMemory        4#define    eAppleTalk        5#define    eNoZones        6#define    rAboutAlert        128      /* about alert */#define    rZoneDialog        129      /* zone list dialog */#define    dZoneList        2      /* user item that is zone list */#define    dDefault        3      /* user item that is default indicator */#define    rUserAlert        130      /* error alert */#define    rMenuBar        128      /* application's menu bar */#define    mApple          128      /* Apple menu */#define    iAbout          1#define    mFile          129      /* File menu */#define    iNew          1#define    iClose          4#define    iQuit          12#define    mEdit          130      /* Edit menu */#define    iUndo          1#define    iCut          3#define    iCopy          4#define    iPaste          5#define    iClear          6/* kDITop and kDILeft are used to locate the Disk Initialization dialogs. */#define    kDITop          0x0050#define    kDILeft          0x0070/* Globs */SysEnvRec      gMac;          /* set up by Initialize */Boolean        gHasWaitNextEvent;    /* set up by Initialize */Boolean        gInBackground;      /* maintained by Initialize and DoEvent */XCallParamPtr    gXPBPBPtr;        /* structure for Phase 2 NBP lookups       */                      /* needs to be global for failure handling */ListHandle  gList;          /* the list to be filled with zone names */extern void _DataInit();/*   globals added for C sample use as the Pascal  example used those horrid :-) nested procedures! */ATPPBPtr  gATPPBPtr;  /* the parameter block for GetZoneList call */Ptr      gZones;   /* the data buffer for GetZoneList call */DialogPtr  gErrDlg;  /* Dialog used for displaying zone list *//*  Check to see if a given trap is implemented. This is only used by the  Initialize routine in this program, so we put it in the Initialize segment.  The recommended approach to see if a trap is implemented is to see if  the address of the trap routine is the same as the address of the  Unimplemented trap. *//*  1.02 - Needs to be called after call to SysEnvirons so that it can check  if a ToolTrap is out of range of a pre-MacII ROM. */#pragma segment InitializeBoolean TrapAvailable(tNumber,tType)  short    tNumber;  TrapType  tType;{  if ( ( tType == (unsigned char) ToolTrap ) &amp;&amp;    ( gMac.machineType &gt; envMachUnknown ) &amp;&amp;    ( gMac.machineType &lt; envMacII ) ) {    /* it's a 512KE, Plus, or SE */    tNumber = tNumber &amp; 0x03FF;    if ( tNumber &gt; 0x01FF )          /* which means the tool traps */      tNumber = _Unimplemented;      /* only go to 0x01FF */  }  return NGetTrapAddress(tNumber, tType) != NGetTrapAddress(_Unimplemented, ToolTrap);} /*TrapAvailable*/#pragma segment Mainvoid FailOSErrMsg(result, message)  short  result;  short  message;{  if (result != noErr)    Failure(result, message);} /* SignalOSErrMsg */#pragma segment Mainvoid FailnilMsg(p, message)  Ptr    p;  short  message;{  if (p == nil)    Failure(memFullErr, message);} /* FailNILMsg */#pragma segment Mainvoid AlertUser(error, message)/* Display an alert to inform the user of an error. Message acts as an index into a STR# resource of error messages. if no message is given, i.e. = 0, then use a standard message. if error is not noErr then display it as well. */  short  error;  long  message;{  Str255  msg1, msg2;  short  itemHit;  if (message &lt;= 0L)  message = eStandardErr;  GetIndString(msg1, sErrStrings, message);  if (error == noErr)    msg2[0] = '';  else    NumToString(error, msg2);  ParamText(msg1, msg2, &quot;\p&quot;, &quot;\p&quot;);  itemHit = Alert(rUserAlert, nil);} /* AlertUser */#pragma segment MainBoolean IsDAWindow(window)  WindowPtr  window;{  if (window == nil)    return (false);  else  /* DA windows have negative windowKinds */    return ((WindowPeek) window)-&gt;windowKind &lt; 0;} /* IsDAWindow */#pragma segment MainBoolean IsAppWindow(window)  WindowPtr  window;{  short    windowKind;  if ( window == nil )    return false;  else {  /* application windows have windowKinds &gt;= userKind (8) or dialogKind (2) */    windowKind = ((WindowPeek) window)-&gt;windowKind;    return (windowKind &gt;= userKind) || (windowKind == dialogKind);  }} /* IsAppWindow */#pragma segment Mainvoid ZoneListCleanUp(){  if (gATPPBPtr != nil)    DisposePtr((Ptr)gATPPBPtr);      /* get rid of pb block */  if (gZones != nil)    DisposePtr(gZones);          /* and buffer */} /* ZoneListCleanUp */#pragma segment Mainpascal void HandleZoneListErr(short error, long message){  #pragma  unused (error, message)  ZoneListCleanUp();            /* get rid of allocated junk */} /* HandleZoneListErr */#pragma segment Mainvoid BuildZoneList()/* *  Create the list of zones on the network. Find a bridge to talk to , if one is *   present, then ask it for zone names. Add the names to the list in the dialog. */{  BDSElement  dBDS;        /* the BDS for GetZoneList call */  Ptr      dCurr;        /* the data buffer for GetZoneList call */  short    dIndex, dCount;  short    ignore;  Cell    cSize;  FailInfo  fi;  short    nodeNetAddress, bridgeNode;  gATPPBPtr = nil;                      /* init some important variables*/  gZones = nil;  CatchCFailures(&amp;fi, HandleZoneListErr);  gATPPBPtr = (ATPPBPtr)NewPtr(sizeof(ATPParamBlock));  FailnilMsg(gATPPBPtr, eNoMemory);  gZones = NewPtr(kZonesSize);  FailnilMsg(gZones, eNoMemory);  dBDS.buffSize = kZonesSize;                  /* set up BDS */  dBDS.buffPtr = gZones;  gATPPBPtr-&gt;ATPatpFlags = 0;  /*   *  get network address of node &amp; node ID of bridge (if any)   */  FailOSErrMsg(GetNodeAddress(&amp;ignore, &amp;nodeNetAddress), eAppleTalk);  bridgeNode = GetBridgeAddress();  /*   * test to see if bridge node fails.  If so, no internet.   */  if (bridgeNode == 0)    Failure(0, eNoZones);                  /* bail if no zones present */  gATPPBPtr-&gt;ATPaddrBlock.aNet = nodeNetAddress;  gATPPBPtr-&gt;ATPaddrBlock.aNode = bridgeNode;          /* get node of bridge */  gATPPBPtr-&gt;ATPaddrBlock.aSocket = kZIPSocket;        /* the socket we want */  gATPPBPtr-&gt;ATPreqLength = 0;  gATPPBPtr-&gt;ATPreqPointer = nil;  gATPPBPtr-&gt;ATPbdsPointer = (Ptr) &amp;dBDS;  gATPPBPtr-&gt;ATPnumOfBuffs = 1;  gATPPBPtr-&gt;ATPtimeOutVal = kATPTimeOutVal;  gATPPBPtr-&gt;ATPretryCount = kATPRetryCount;  dIndex = 1;  dCount = 0;  SetPt(&amp;cSize, 0, 0);                        /* we always stuff into first */  do {    gATPPBPtr-&gt;ATPuserData = kGZLCall + dIndex;            /* indicate GetZoneList request */    FailOSErrMsg(PSendRequest(gATPPBPtr, false), eAppleTalk);    /* send sync request */    dCount = dCount + dBDS.userBytes &amp; kZoneCount;          /* find out how many returned */    dCurr = gZones;                          /* put current pointer at start */    do {                              /* get each zone */      ignore = LAddRow(1, 0, gList);                /* create new cell at start */      LSetCell((Ptr)dCurr + 1L, (short) *dCurr, cSize, gList);  /* stuff in zone */      dCurr = (Ptr)(dCurr + *dCurr + 1 );              /* bump up current pointer */      dIndex = dIndex + 1;                    /* increment which zone */    } while(! (dIndex &gt; dCount));  } while ((dBDS.userBytes &amp; kMoreZones) == 0);        /*   keep going until none left */  ZoneListCleanUp();  Success(&amp;fi);} /* BuildZoneList */#pragma segment Mainvoid ZoneListCleanUpPhase2(){  if (gXPBPBPtr != nil)    DisposePtr((Ptr)gXPBPBPtr);      /* get rid of pb block */  if (gZones != nil)    DisposePtr(gZones);          /* and buffer */} /* ZoneListCleanUpPhase2 */#pragma segment Mainvoid BuildZoneListPhase2()/*   Create the list of zones on the network. Find a bridge to talk to , if one is   present, then ask it for zone names. Add the names to the list in the dialog.  */{  Ptr      dCurr;        /* the data buffer for GetZoneList call */  short    dIndex, dCount;  short    ignore;  Cell    cSize;  FailInfo  fi;  short    xppDriverRefNum;  gXPBPBPtr = nil;                      /* init some important variables*/  gZones = nil;  CatchCFailures(&amp;fi, HandleZoneListErr);  /* Get network address of bridge.  If zero, no internet. */  if (GetBridgeAddress() == 0)    Failure(0, eNoZones);                  /* bail if no zones present */  /* get a hold of the XPP driver reference number-this is the safest way */  FailOSErrMsg(OpenDriver(&quot;\p.XPP&quot;, &amp;xppDriverRefNum), eAppleTalk);  gXPBPBPtr = (XCallParamPtr)NewPtr(sizeof(XCallParam));  FailnilMsg(gXPBPBPtr, eNoMemory);  gZones = NewPtr(kZonesSize);  FailnilMsg(gZones, eNoMemory);  gXPBPBPtr-&gt;zipInfoField[0] = 0;  /* ALWAYS 0 on first call.  has state info on subsequent calls */  gXPBPBPtr-&gt;zipInfoField[1] = 0;  /* ALWAYS 0 on first call.  has state info on subsequent calls */  gXPBPBPtr-&gt;zipLastFlag = 0;  gXPBPBPtr-&gt;ioRefNum = xppDriverRefNum;  gXPBPBPtr-&gt;csCode = xCall;  gXPBPBPtr-&gt;xppSubCode = zipGetZoneList;  gXPBPBPtr-&gt;xppTimeout = kATPTimeOutVal;  gXPBPBPtr-&gt;xppRetry = kATPRetryCount;  gXPBPBPtr-&gt;zipBuffPtr = (Ptr) gZones;  dIndex = 1;  dCount = 0;  SetPt(&amp;cSize, 0, 0);                        /* we always stuff into first */  do {    FailOSErrMsg(PBControl((ParmBlkPtr) gXPBPBPtr, false), eAppleTalk);    /* send sync control call */    dCount = dCount + gXPBPBPtr-&gt;zipNumZones;            /* find out how many returned */    dCurr = gZones;                          /* put current pointer at start */    do {                              /* get each zone */      ignore = LAddRow(1, 0, gList);                /* create new cell at start */      LSetCell((Ptr)dCurr + 1L, (short) *dCurr, cSize, gList);  /* stuff in zone */      dCurr = (Ptr)(dCurr + *dCurr + 1 );              /* bump up current pointer */      dIndex = dIndex + 1;                    /* increment which zone */    } while(! (dIndex &gt; dCount));  } while (gXPBPBPtr-&gt;zipLastFlag == 0);        /*   keep going until none left */  ZoneListCleanUpPhase2();  Success(&amp;fi);} /* BuildZoneList */#pragma segment Mainpascal void ZoneListDraw(dlg, item)  DialogPtr  dlg;  short    item;{/* The user item void for the zone list user item and default box user item in the dialog. Draw the list and the frame that goes with it. Draw the default box around the OK button */  GrafPtr   port;  short    kind;  Handle    h;  Rect    r;  PenState  ps;  GetPort(&amp;port);                    /* save old port */  SetPort(dlg);                    /* make dialog port */  switch (item) {    case dZoneList:      LUpdate(dlg-&gt;visRgn, gList);        /* re-draw list */      GetDialogItem(dlg, dZoneList, &amp;kind, &amp;h, &amp;r);      InsetRect(&amp;r, kListInset, kListInset);      FrameRect(&amp;r);                /* re-draw frame */      break;    case dDefault:      GetDialogItem(dlg, dDefault, &amp;kind, &amp;h, &amp;r);      GetPenState(&amp;ps);      PenNormal();                /* always be on the defensive */      PenSize(3, 3);      InsetRect(&amp;r, -4, -4);      FrameRoundRect(&amp;r, 16, 16);          /* draw default box */      SetPenState(&amp;ps);      break;    }  SetPort(port);                    /* restore old port */} /* ZoneListDraw */#pragma segment Mainpascal Boolean ListFilter (dlg, event, item)  DialogPtr  dlg;  EventRecord  *event;  short    *item;{/*  Passed as parameter to ModalDialog. Handle key presses and mouse clicks     from the user. Do all the right default actions since we override them   by virtue of our existence.  */  GrafPtr    port;  Point    loc;  short    kind;  Handle    h;  Rect    r;  Boolean    ignore;  char    key;  long     finalTicks;  Boolean    returnValue;  returnValue = false;                      /*  always default false */  switch (event-&gt;what) {    case keyDown:                         /*  check for &lt;cr&gt; or &lt;enter&gt; */    case autoKey:      key = (char) event-&gt;message;      if (key == kCR || key == kENTER) {            /*  it was a &lt;cr&gt; or &lt;enter&gt; */        GetDialogItem(dlg, ok, &amp;kind, &amp;h, &amp;r);        HiliteControl((ControlHandle)h, kHilite);        Delay(kHiliteDelay, &amp;finalTicks);        HiliteControl((ControlHandle)h, kDeHilite);        returnValue = true;                  /*  so we handle it */        *item = 1;                      /*  and make the first item hit */        }      break;    case mouseDown:                       /*  we want mouseDowns */      GetPort(&amp;port);      SetPort(dlg);      loc = event-&gt;where;      GlobalToLocal(&amp;loc);                  /*  find where clicked */      GetDialogItem(dlg, dZoneList, &amp;kind, &amp;h, &amp;r);        /*  get rect for list */      if (PtInRect(loc, &amp;r)) {                /*  if clicked inside\xC9 */        returnValue = true;                  /*  we take care of it */        ignore = LClick(loc, event-&gt;modifiers, gList);    /*  by passing click to list */        }      SetPort(port);      break;    }  return (returnValue);} /* ListFilter */#pragma segment Mainvoid CleanUp_DoZoneList(){  if (gList != nil)    LDispose(gList);                  /*  get rid of list */  if (gErrDlg != nil)    DisposeDialog(gErrDlg);                /*  get rid of dialog */} /* CleanUp_DoZoneList */#pragma segment Mainpascal void HandleErr_DoZoneList(short error, long message){  #pragma  unused (error, message)  CleanUp_DoZoneList();                /*  release junk */} /* HandleErr_DoZoneList */#pragma segment Mainvoid DoZoneList()/*  Put up a modal dialog that shows a list of the zones on the net. Create the dialog and list, call BuildZoneList to fill it, then wait for the user to click OK. */{  DialogPtr  dlg;  short    item, kind;  Handle    h;  Rect    r, rView, dataBounds;  Cell    cSize;  FailInfo  fi;  short    hor, ver;  ModalFilterUPP mfUPP;  gList = nil;                      /*  init some important variables */  dlg = nil;  CatchCFailures(&amp;fi, HandleErr_DoZoneList);  dlg = GetNewDialog(rZoneDialog, nil, (WindowPtr)-1);      /*  create dialog */  SetPort(dlg);  gErrDlg = dlg;  FailnilMsg(dlg, eNoMemory);  /*  We center the dialog horizontally and position it vertically one-third the   distance from the menu bar to the bottom of the main device. We do not   check for the dialog extending past the bottom of the device because we   know the dialog is not that big. You may wish to make that check. */  hor = dlg-&gt;portRect.right - dlg-&gt;portRect.left;  ver = dlg-&gt;portRect.bottom - dlg-&gt;portRect.top;  hor = ((qd.screenBits.bounds.right - qd.screenBits.bounds.left) - hor) / 2;  ver = (((qd.screenBits.bounds.bottom - qd.screenBits.bounds.top) - ver - GetMBarHeight()) / 3) + GetMBarHeight();  MoveWindow(dlg, hor, ver, false);  GetDialogItem(dlg, dDefault, &amp;kind, &amp;h, &amp;r);  SetDialogItem(dlg, dDefault, kind, (Handle) ZoneListDraw, &amp;r);  GetDialogItem(dlg, dZoneList, &amp;kind, &amp;h, &amp;r);  SetDialogItem(dlg, dZoneList, kind, (Handle) ZoneListDraw, &amp;r);    /*  connect drawing void */  rView = r;  rView.right -= kScrollBarWidth;              /*  adjust rectangle for scroll */  SetRect(&amp;dataBounds, 0, 0, 1, 0);            /*  init to one-wide list */  SetPt(&amp;cSize, 0, 0);  gList = LNew(&amp;rView, &amp;dataBounds, cSize, 0, (WindowPtr)dlg,          false, false, false, true);        /*  create with vertical scroll */  FailnilMsg(gList, eNoMemory);  /* changes for Phase 2 - pvh 8/6/89 */  /* this is the easiest check for Phase 2's existence */  if(gMac.atDrvrVersNum &gt;= 53)    BuildZoneListPhase2();                  /*  put the stuff into the list */  else    BuildZoneList();                    /*  put the stuff into the list */  SetPt(&amp;cSize, 0, 0);  LSetSelect(true, cSize, gList);              /*  select the first guy */  LSetDrawingMode(true, gList);                  /*  turn on the list */  ShowWindow(dlg);                    /*  turn on the dialog */  mfUPP = NewModalFilterProc(ListFilter);  do {    ModalDialog(mfUPP, &amp;item);  /*  accept events */  } while (item != ok);                  /*  until he presses 'ok' */  DisposeRoutineDescriptor(mfUPP);  CleanUp_DoZoneList();  Success(&amp;fi);} /* DoZoneList */#pragma segment MainBoolean DoCloseWindow(window)  WindowPtr  window;{  Boolean   functionValue = true;  if (IsDAWindow(window))    CloseDeskAcc((short) ((WindowPeek)window)-&gt;windowKind);  if (IsAppWindow(window))    CloseWindow(window);  return(functionValue);} /* DoCloseWindow */#pragma segment Initializepascal void HandleErr_Initialize(error, message)  short  error;  long  message;{    if (error &gt; 0)      AlertUser(0, error);    else      AlertUser(error, message);    ExitToShell();} /* HandleErr_Initialize */#pragma segment Initializevoid Initialize(){  Handle      menuBar;  OSErr      ignoreError;  long      total, contig;  Boolean      ignoreResult;  EventRecord    event;  short      count;  FailInfo    fi;  gHasWaitNextEvent = TrapAvailable(_WaitNextEvent, ToolTrap);  gInBackground = false;  InitGraf(&amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(nil);  InitCursor();  /* get MultiFinder started */  for (count=1;count&lt;3;count++)    ignoreResult = EventAvail(everyEvent, &amp;event);  CatchCFailures(&amp;fi, HandleErr_Initialize);  FailOSErrMsg(MPPOpen(), eAppleTalk);  FailOSErrMsg(ATPLoad(), eAppleTalk);  ignoreError = SysEnvirons(kSysEnvironsVersion, &amp;gMac);  if (gMac.machineType &lt; 0)    Failure(0, eWrongMachine);  if (GetApplLimit() - ApplicationZone() &lt; kMinHeap)    Failure(0, eSmallSize);  PurgeSpace(&amp;total, &amp;contig);  if (total &lt; kMinSpace)    Failure(0, eNoMemory);  menuBar = GetNewMBar(rMenuBar);        /*  read menus into menu bar */  FailnilMsg(menuBar, eNoMemory);  SetMenuBar(menuBar);            /*  install menus */  DisposeHandle(menuBar);  AppendResMenu(GetMenuHandle(mApple), 'DRVR');    /*  add DA names to Apple menu */  DrawMenuBar();  Success(&amp;fi);} /* Initialize */#pragma segment Mainvoid Terminate(){  WindowPtr  aWindow;  Boolean    closed;  closed = true;  do {    aWindow = FrontWindow();        /*  get the current front window */    if (aWindow != nil)      closed = DoCloseWindow(aWindow);  /*  close this window */  } while ((closed) &amp;&amp; (aWindow != nil));    /*  do all windows */  if (closed)    ExitToShell();              /*  exit if no cancellation */} /* Terminate */#pragma segment Mainvoid AdjustMenus(){  WindowPtr  window;  MenuHandle  menu;  window = FrontWindow();  menu = GetMenuHandle(mFile);  if (IsDAWindow(window))            /*  we can allow desk accessories to be closed from the menu */    EnableItem(menu, iClose);  else    DisableItem(menu, iClose);        /*  but not our traffic light window */  menu = GetMenuHandle(mEdit);  if (IsDAWindow(window)) {          /*  a desk accessory might need the edit menu */    EnableItem(menu, iUndo);    EnableItem(menu, iCut);    EnableItem(menu, iCopy);    EnableItem(menu, iPaste);    EnableItem(menu, iClear);    }  else {                    /*  but we know we do not */    DisableItem(menu, iUndo);    DisableItem(menu, iCut);    DisableItem(menu, iCopy);    DisableItem(menu, iClear);    DisableItem(menu, iPaste);    }} /* AdjustMenus */pascal void HandleMenu(short error, long message){  #pragma  unused (error, message)  HiliteMenu(0);                /*  unhighlight what MenuSelect (or MenuKey) hilited */} /* HandleMenu */#pragma segment Mainvoid DoMenuCommand(menuResult)  long  menuResult;{  short    menuID;              /*  the resource ID of the selected menu */  short    menuItem;            /*  the item number of the selected menu */  short    itemHit;  Str255    daName;  short    daRefNum;  Boolean    handledByDA  ;  Boolean    ignore;  FailInfo  fi;  CatchCFailures(&amp;fi, (HandlerFuncPtr) HandleMenu);  menuID = HiWord(menuResult);              /*  use built-ins (for efficiency)... */  menuItem = LoWord(menuResult);            /*  to get menu item number and menu number */  switch (menuID) {    case mApple:      switch (menuItem) {        case iAbout:              /*  bring up alert for About */          itemHit = Alert(rAboutAlert, nil);          break;        default:                /*  all non-About items in this menu are DAs */          GetMenuItemText(GetMenuHandle(mApple), menuItem, daName);          daRefNum = OpenDeskAcc(daName);          break;        }      break;    case mFile:      switch (menuItem) {        case iNew:          DoZoneList();          break;        case iClose:          ignore = DoCloseWindow(FrontWindow());          break;        case iQuit:          Terminate();          break;        }      break;    case mEdit:                  /*  call SystemEdit for DA editing &amp; Multifinder */      handledByDA = SystemEdit(menuItem-1);  /*  since we don't do any editing */      break;    }  HiliteMenu(0);                  /*  cleanup */  Success(&amp;fi);} /* DoMenuCommand */#pragma segment Mainpascal void HandleErr_DoEvent(error, message)  short  error;  long  message;{  if (error &gt; 0)    AlertUser(0, error);  else    AlertUser(error, message);  ExitToShell();} /* HandleErr_DoEvent */#pragma segment Mainvoid DoEvent(event)  EventRecord  event;{  short    part;  WindowPtr  window;  char    key;  FailInfo  fi;  Point    aPoint;  OSErr    err;  CatchCFailures(&amp;fi, (HandlerFuncPtr) HandleErr_DoEvent);  switch (event.what) {    case mouseDown:      part = FindWindow(event.where, &amp;window);      switch (part) {        case inMenuBar:              /*  process the menu command */          AdjustMenus();          DoMenuCommand(MenuSelect(event.where));          break;        case inSysWindow:            /*  let the system handle the mouseDown */          SystemClick(&amp;event, window);          break;        case inContent:          break;        case inDrag:          break;        case inGrow:          break;        case inZoomIn:        case inZoomOut:          break;        }      break;    case keyDown:                   /*  check for menukey equivalents */    case autoKey:      key = event.message &amp; charCodeMask;      if (event.modifiers &amp; cmdKey) {        /*  Command key down */        if (event.what == keyDown) {          AdjustMenus();            /*  enable/disable/check menu items properly */          DoMenuCommand(MenuKey(key));          }        }      break;    /*  call DoActivate with the window and... */    case activateEvt:      break;    case updateEvt:      break;    /* It is not a bad idea to at least call DIBadMount in response     to a diskEvt, so that the user can format a floppy. */    case diskEvt:      if (HiWord(event.message) != noErr) {        SetPt(&amp;aPoint, kDILeft, kDITop);        err = DIBadMount(aPoint, event.message);      }    case kOSEvent:      switch ((event.message &gt;&gt; 24) &amp; 0x0FF) {   /* high byte of message */        case kSuspendResumeMessage:          gInBackground = event.message &amp; kResumeMask;          break;        }      break;    }  Success(&amp;fi);} /* DoEvent */#pragma segment Mainvoid EventLoop(){  RgnHandle  cursorRgn;  Boolean    gotEvent;  EventRecord  event;  cursorRgn = NewRgn();      /*  we'll pass WNE an empty region the 1st time thru */  do {    if (gHasWaitNextEvent)    /*  put us 'asleep' forever under Multifinder */      gotEvent = WaitNextEvent(everyEvent, &amp;event, LONG_MAX, cursorRgn);    else {      SystemTask();      /*  must be called if using GetNextEvent */      gotEvent = GetNextEvent(everyEvent, &amp;event);      }    if (gotEvent) {      DoEvent(event);      }  } while (true);          /*  loop forever; we quit through an ExitToShell */} /* EventLoop */#pragma segment Mainvoid main(){  UnloadSeg(_DataInit);      /*  note that _DataInit must not be in Main! */  MaxApplZone();          /*  expand the heap so code segments load at the top */  InitUFailure();  Initialize();          /* initialize the program */  UnloadSeg(Initialize);      /* note that Initialize must not be in Main! */  EventLoop();          /* call the main event loop */} /* main */</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/GetZoneList/listing1.html%3Fid%3DDTS10000237-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/GetZoneList/listing1.html%3Fid%3DDTS10000237-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/GetZoneList/listing1.html%3Fid%3DDTS10000237-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>