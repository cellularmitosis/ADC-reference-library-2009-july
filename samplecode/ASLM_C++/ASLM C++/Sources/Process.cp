/* _________________________________________________________________________________________________________ //  Copyright © 1992 Apple Computer, Inc. All rights reserved.  Macintosh Developer Technical Support.C++ Macintosh Toolbox Framework.  Date: Wednesday, June 10, 1992 22:37:30  Revision comments are at the end of this file.  ---  TProcess is a Process Manager class.  Process.cp contains the class body information for the TProcess class member functions.  _________________________________________________________________________________________________________ */// Include files#ifndef _PROCESS_#include "Process.h"#endif// _________________________________________________________________________________________________________ //// TRandom class member function implementations//	INITIATION ROUTINESvoid TProcess::Initialize(ProcessSerialNumber theNum)// Initialize the TProcess class with known values.{	OSErr anErr;	fFirstTime = true;							// signal that we are inside constructor	fLast = false;	fProcessID.highLongOfPSN = theNum.highLongOfPSN;			fProcessID.lowLongOfPSN  = theNum.lowLongOfPSN;	anErr = GetCurrentProcess(&fMyProcessID);	// always get our own PSN	this->IProcess();	fFirstPSN = fProcessID;						// define the first one	fFirstTime = false;							// signal this time is over}Boolean TProcess::IProcess()// We are using a special IProcess member function for initializing class fields to// known values.{	OSErr anErr;	// get our own PSN number	if (fFirstTime)								// our first PSN (our own)	{		anErr = GetNextProcess(&fProcessID);		if (anErr != noErr)			return false;		return true;	}	else		anErr = GetNextProcess(&fProcessID);	// fetch other PSNs	{		if (anErr != noErr)		{			fLast = true;			this->First();			return false;		}		else			return true;	}}//	 MAIN INTERFACESBoolean TProcess::KillApplication(ProcessSerialNumber* thePSN)// Quit the application which is defined by the PSN.{	OSErr anErr;	AEAddressDesc target;	AppleEvent theAE,  theAEReply;	theAE.dataHandle = theAEReply.dataHandle = target.dataHandle = NULL;	anErr = AECreateDesc(typeProcessSerialNumber, (Ptr)thePSN, sizeof(ProcessSerialNumber), &target);	if (anErr != noErr)		return false;	anErr = AECreateAppleEvent(kCoreEventClass, kAEQuitApplication, &target, kAutoGenerateReturnID, kAnyTransactionID, &theAE);	if (anErr != noErr)	{		AEDisposeDesc(&target);		return false;	}	anErr = AESend(&theAE, &theAEReply, kAENoReply, kAENormalPriority, kNoTimeOut, NULL, NULL);	AEDisposeDesc(&target);	AEDisposeDesc(&theAE);	if (anErr != noErr)		return false;	else		return true;}short TProcess::GetNumProcesses()// Get the amount of currently running processes.{	ProcessSerialNumber aPSN;	short num = 0;	aPSN.highLongOfPSN = 0;	aPSN.lowLongOfPSN = kNoProcess;	while (GetNextProcess(&aPSN) == noErr)		num++;	return num;}ProcessInfoRec TProcess::GetProcessInfoRec()// Return the full ProcInfoRec of specified process, NULL if we got into trouble.{	ProcessInfoRec theRec;	OSErr anErr;	theRec.processName = NULL;	theRec.processAppSpec = NULL;	theRec.processInfoLength = sizeof(theRec);	anErr = GetProcessInformation(&fProcessID, &theRec);	return theRec;}unsigned long TProcess::GetProcessSize()// Return size of process.{	ProcessInfoRec temp = this->GetProcessInfoRec();	return temp.processSize;}unsigned long TProcess::GetFreeMem()// Return the amount of free memory available for the process.{	ProcessInfoRec temp = this->GetProcessInfoRec();	return temp.processFreeMem;}unsigned long TProcess::GetLaunchDate()// Return in seconds the point when the application was launched.{	ProcessInfoRec temp = this->GetProcessInfoRec();	return temp.processLaunchDate;}Boolean TProcess::FindProcess(OSType signature)// Find process with the right signature, style 'MACS'.{	ProcessInfoRec theRec;	fProcessID.highLongOfPSN = 0;	fProcessID.lowLongOfPSN = kNoProcess;		// start from beginning	theRec.processName = NULL;	theRec.processAppSpec = NULL;	theRec.processInfoLength = sizeof(theRec);	while (GetNextProcess(&fProcessID) == noErr)	{		if (GetProcessInformation(&fProcessID, &theRec) == noErr)		{			if (theRec.processSignature == signature)				return true;					// we found it		}	}	return false;								// we didn't find the process, sigh}ProcessSerialNumber TProcess::GetMyProcessID() const// Return the Process ID of the process running.{	return fMyProcessID;}ProcessSerialNumber TProcess::GetProcessID() const// Return the Process ID of the currently inspected process. {	return fProcessID;}void TProcess::Next()// Return next process in the process list.{	this->IProcess();}Boolean TProcess::Last()// Return last process in the process list.{	return fLast;}void TProcess::First()// Return first process in the process list.{	fProcessID = fFirstPSN;}// _________________________________________________________________________________________________________ ///*	Change History (most recent last):  No		Init.	Date		Comment  1			khs		6/10/92		New file  2			khs		7/6/92		First decent working class*/