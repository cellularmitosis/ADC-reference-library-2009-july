<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>TypeServicesForUnicode - /More ATSUI/MoreATSUnicodeTextBox.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxHumanInterfaceToolbox-date.html">Human Interface Toolbox</a> &gt; <A HREF="javascript:location.replace('index.html');">TypeServicesForUnicode</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">TypeServicesForUnicode</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/More ATSUI/MoreATSUnicodeTextBox.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/HIATSUIView.c</option>
<option value="listing2.html">/HIATSUIView.h</option>
<option value="listing3.html">/main.c</option>
<option value="listing4.html">/More ATSUI/MoreATSUnicode.cp</option>
<option value="listing5.html">/More ATSUI/MoreATSUnicode.h</option>
<option value="listing6.html">/More ATSUI/MoreATSUnicodeTextBox.cp</option>
<option value="listing7.html">/TypeServicesForUnicode.c</option>
<option value="listing8.html">/TypeServicesForUnicode.h</option></select>
				</p>
				</form>
				<p><strong><a href="TypeServicesForUnicode.zip">Download Sample</a></strong> (&#147;TypeServicesForUnicode.zip&#148;, 1.14M)<BR>
<strong><a href="TypeServicesForUnicode.dmg">Download Sample</a></strong> (&#147;TypeServicesForUnicode.dmg&#148;, 1.44M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/**  File:    MoreATSUnicodeTextBox.cp of TypeServicesForUnicode* *  Contains:  Convenience Text Drawing in a box with ATSUI.*  *  Version:  2.0* *  Change History (most recent first):*           11/16/2004      Modernized for Mac OS X 10.3 and later*        10/14/1999      Macro names changed*                           Use ATSUGetGlyphBounds to compute line height*        7/27/1999       Updated for Metrowerks Codewarror Pro 2.1        *        7/01/1998       Created**  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.*        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your*        use, installation, modification or redistribution of this Apple software*        constitutes acceptance of these terms.  If you do not agree with these terms,*        please do not use, install, modify or redistribute this Apple software.**        In consideration of your agreement to abide by the following terms, and subject*        to these terms, Apple grants you a personal, non-exclusive license, under Apple&Otilde;s*        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,*        reproduce, modify and redistribute the Apple Software, with or without*        modifications, in source and/or binary forms; provided that if you redistribute*        the Apple Software in its entirety and without modifications, you must retain*        this notice and the following text and disclaimers in all such redistributions of*        the Apple Software.  Neither the name, trademarks, service marks or logos of*        Apple Computer, Inc. may be used to endorse or promote products derived from the*        Apple Software without specific prior written permission from Apple.  Except as*        expressly stated in this notice, no other rights or licenses, express or implied,*        are granted by Apple herein, including but not limited to any patent rights that*        may be infringed by your derivative works or by other works in which the Apple*        Software may be incorporated.**        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO*        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED*        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR*        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN*        COMBINATION WITH YOUR PRODUCTS.**        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR*        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE*        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)*        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION*        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT*        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN*        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.**  Copyright:  Copyright &copy; 2005 Apple Computer, Inc, All Rights Reserved*/#include &quot;MoreATSUnicode.h&quot;//   converts a TextEdit based alignment to //  an ATSUI flush factorstatic Fract atsuFlushFactorFromTEAlignment(short alignment){  Fract flushFactor = kATSUStartAlignment;    switch (alignment)  {    case teFlushRight:      flushFactor = kATSUEndAlignment;      break;          case teCenter:      flushFactor = kATSUCenterAlignment;      break;    case teFlushLeft:      flushFactor = kATSUStartAlignment;      break;    default:      // teFlushDefault      flushFactor = (GetSysDirection() == 0) ? kATSUStartAlignment : kATSUEndAlignment;      break;  }  return flushFactor;}enum {    kVerticalTextAngle = IntToFixed(-90)  };/*  Draw the text layout within the specified rect.*/OSStatus atsuDrawTextInBox(  ATSUTextLayout     iTextLayout,              const Rect *      iBox){  OSStatus       theStatus = noErr;  UniCharArrayOffset  textOffset = 0;  UniCharCount    textLength = 0;  UniCharArrayOffset*  lineEndOffsets = NULL;    require (iBox != NULL, EXIT);    // the the range of text to be drawn  theStatus = ATSUGetTextLocation (iTextLayout, NULL, NULL, &amp;textOffset, &amp;textLength, NULL);  if (theStatus == noErr) {    UniCharArrayOffset    lineStartOffset = textOffset;    UniCharArrayOffset    lineEndOffset = 0;        //  assume horizontal text values    ATSUTextMeasurement    xPos = IntToFixed(iBox-&gt;left);    ATSUTextMeasurement    yPos = IntToFixed(iBox-&gt;top);    ATSUTextMeasurement    lineStart = xPos;    ATSUTextMeasurement    lineEnd = IntToFixed(iBox-&gt;right);    ATSUTextMeasurement    lineWidth = 0;        Fixed          textAngle = 0;    ItemCount        lineCount = 0;    ItemCount        softBreakCount = 0;    ATSUTextMeasurement    maxAscent = 0, maxDescent = 0;        int ln = 0;    //  need to get the text rotation for drawing    theStatus = atsuGetLayoutRotation(iTextLayout, &amp;textAngle);    require(theStatus == noErr, EXIT);        // is the text not horizontal?    if (textAngle != 0) {      // if it is not horizontal, we only know how to draw vertical      require (textAngle == kVerticalTextAngle, EXIT);      xPos =   IntToFixed(iBox-&gt;right);      lineStart = yPos;      lineEnd = IntToFixed(iBox-&gt;bottom);    }    // check for linewidth set as a layout control    theStatus = atsuGetLayoutWidth(iTextLayout, &amp;lineWidth);    require(theStatus == noErr, EXIT);        //  if there is no layout control set for width    //  then set it using the box bounds    if (lineWidth == 0)      lineWidth = lineEnd - lineStart;        //  Break and measure each line to determine the max ascent and descent;    //  This is needed because things that end up on different lines    //  could interact to affect the line height when they're on the same line.    //  To get the best value we break the lines first, then measure each    //  line and find the max ascent and descent.    while (lineStartOffset &lt; textOffset + textLength) {      ATSUTextMeasurement    ascent = 0, descent = 0;            // set the soft breaks, we will use them later      theStatus = ATSUBreakLine(iTextLayout, lineStartOffset, lineWidth, true, &amp;lineEndOffset);      require(theStatus == noErr, EXIT);            // @@@ If you want leave lines that are terminated with a hard break unjustified, this is a      // good place to set the individual line control to do that.      // ATSUGetGlyphBounds is better than ATSUMeasureText if you've got any interesting feature      // such as justification turned on. The former will do the layout exactly as it will be drawn and cache      // the result, so things will be faster overall. ATSUMeasureText will turn off justification and end up doing      // an &quot;extra&quot; layout operation.      {        ATSTrapezoid  glyphBounds;  // one should be enough when we're asking for the whole line.                theStatus = ATSUGetGlyphBounds( iTextLayout, 0, 0, lineStartOffset, lineEndOffset - lineStartOffset, kATSUseFractionalOrigins,                        1, &amp;glyphBounds, NULL );        require(theStatus == noErr, EXIT);                // The top and bottom of the bounds should be parallel to the baseline. You might want to check that.        if (textAngle == 0) {          ascent = -glyphBounds.upperLeft.y;          descent = glyphBounds.lowerLeft.y;        } else {          // This looks strange, but the box you get is rotated, so &quot;upper left&quot; relative to the line is &quot;upper right&quot; in absolute terms.          ascent = glyphBounds.upperLeft.x;          descent = -glyphBounds.lowerLeft.x;        }      }      if (ascent &gt; maxAscent)        maxAscent = ascent;      if (descent &gt; maxDescent)        maxDescent = descent;              lineStartOffset = lineEndOffset;      lineCount++;    }        lineEndOffsets = (UniCharArrayOffset*) NewPtr(lineCount * sizeof(UniCharArrayOffset));        theStatus = MemError();    require(theStatus == noErr, EXIT);        theStatus = ATSUGetSoftLineBreaks(      iTextLayout, textOffset, textLength, lineCount, lineEndOffsets, &amp;softBreakCount);    //  assert that the number of soft breaks is always one less than the number of lines    //  since ATSUBreakLine does not insert a softbreak at the end of the text.    require((theStatus == noErr &amp;&amp; softBreakCount == lineCount - 1), EXIT);    lineEndOffsets[softBreakCount] = textOffset + textLength;    lineStartOffset = textOffset;    // @@@ If maxAscent or maxDescent are not integers, this code may produce uneven line spacing. It will also    // not necessarily match the line height used by ATSUI when highlighting. ATSUI highlighting uses    // FixedToInt( baseline - ascent ) for the top of the box and FixedToInt( baseline + descent ) for the bottom.    // Any other combination of reflection and rounding can result in one-pixel gaps and overlaps.        // If you're using ATSUGetGlyphBounds above, you could ask for kATSUseDeviceOrigins to have ATSUI do this transformation for you.        //  draw each line    for (ln = 0; ln &lt; lineCount; ln++) {      lineEndOffset = lineEndOffsets[ln];            // predecrement to account for the line height      if (textAngle == kVerticalTextAngle)        xPos -= maxAscent;      else        yPos += maxAscent;      theStatus = ATSUDrawText(iTextLayout, lineStartOffset, lineEndOffset - lineStartOffset, xPos,  yPos);      require(theStatus == noErr, EXIT);      lineStartOffset = lineEndOffset;            if (textAngle == kVerticalTextAngle)        xPos -= maxDescent;      else        yPos += maxDescent;    }  }  EXIT:  if (lineEndOffsets != NULL)     DisposePtr((char*)lineEndOffsets);    return theStatus;}/*  Draw the text layout within the specified rect.*/OSStatus atsuCompositedDrawTextInBox(  ATSUTextLayout     iTextLayout,              const Rect *      iBox){  OSStatus       theStatus = noErr;  UniCharArrayOffset  textOffset = 0;  UniCharCount    textLength = 0;  UniCharArrayOffset*  lineEndOffsets = NULL;    require (iBox != NULL, EXIT);    // the the range of text to be drawn  theStatus = ATSUGetTextLocation (iTextLayout, NULL, NULL, &amp;textOffset, &amp;textLength, NULL);  if (theStatus == noErr) {    UniCharArrayOffset    lineStartOffset = textOffset;    UniCharArrayOffset    lineEndOffset = 0;        //  assume horizontal text values    ATSUTextMeasurement    xPos = IntToFixed(iBox-&gt;left);    ATSUTextMeasurement    yPos = IntToFixed(iBox-&gt;bottom);    ATSUTextMeasurement    lineStart = IntToFixed(iBox-&gt;left);    ATSUTextMeasurement    lineEnd = IntToFixed(iBox-&gt;right);    ATSUTextMeasurement    lineWidth = 0;        Fixed          textAngle = 0;    ItemCount        lineCount = 0;    ItemCount        softBreakCount = 0;    ATSUTextMeasurement    maxAscent = 0, maxDescent = 0;        int ln = 0;    //  need to get the text rotation for drawing    theStatus = atsuGetLayoutRotation(iTextLayout, &amp;textAngle);    require(theStatus == noErr, EXIT);        // is the text not horizontal?    if (textAngle != 0) {      // if it is not horizontal, we only know how to draw vertical      require (textAngle == kVerticalTextAngle, EXIT);      xPos =   IntToFixed(iBox-&gt;right);      lineStart = IntToFixed(iBox-&gt;top);      lineEnd = IntToFixed(iBox-&gt;bottom);    }    // check for linewidth set as a layout control    theStatus = atsuGetLayoutWidth(iTextLayout, &amp;lineWidth);    require(theStatus == noErr, EXIT);        //  if there is no layout control set for width    //  then set it using the box bounds    if (lineWidth == 0)      lineWidth = lineEnd - lineStart;        //  Break and measure each line to determine the max ascent and descent;    //  This is needed because things that end up on different lines    //  could interact to affect the line height when they're on the same line.    //  To get the best value we break the lines first, then measure each    //  line and find the max ascent and descent.    while (lineStartOffset &lt; textOffset + textLength) {      ATSUTextMeasurement    ascent = 0, descent = 0;            // set the soft breaks, we will use them later      theStatus = ATSUBreakLine(iTextLayout, lineStartOffset, lineWidth, true, &amp;lineEndOffset);      if (theStatus == kATSULineBreakInWord) theStatus = noErr;      require_noerr(theStatus, EXIT);            // @@@ If you want leave lines that are terminated with a hard break unjustified, this is a      // good place to set the individual line control to do that.      // ATSUGetGlyphBounds is better than ATSUMeasureText if you've got any interesting feature      // such as justification turned on. The former will do the layout exactly as it will be drawn and cache      // the result, so things will be faster overall. ATSUMeasureText will turn off justification and end up doing      // an &quot;extra&quot; layout operation.      {        ATSTrapezoid  glyphBounds;  // one should be enough when we're asking for the whole line.                theStatus = ATSUGetGlyphBounds( iTextLayout, 0, 0, lineStartOffset, lineEndOffset - lineStartOffset, kATSUseFractionalOrigins,                        1, &amp;glyphBounds, NULL );        require(theStatus == noErr, EXIT);                // The top and bottom of the bounds should be parallel to the baseline. You might want to check that.        if (textAngle == 0) {          ascent = -glyphBounds.upperLeft.y;          descent = glyphBounds.lowerLeft.y;        } else {          // This looks strange, but the box you get is rotated, so &quot;upper left&quot; relative to the line is &quot;upper right&quot; in absolute terms.          ascent = glyphBounds.upperLeft.x;          descent = -glyphBounds.lowerLeft.x;        }      }      if (ascent &gt; maxAscent)        maxAscent = ascent;      if (descent &gt; maxDescent)        maxDescent = descent;              lineStartOffset = lineEndOffset;      lineCount++;    }        lineEndOffsets = (UniCharArrayOffset*) NewPtr(lineCount * sizeof(UniCharArrayOffset));        theStatus = MemError();    require(theStatus == noErr, EXIT);        theStatus = ATSUGetSoftLineBreaks(      iTextLayout, textOffset, textLength, lineCount, lineEndOffsets, &amp;softBreakCount);    //  assert that the number of soft breaks is always one less than the number of lines    //  since ATSUBreakLine does not insert a softbreak at the end of the text.    require((theStatus == noErr &amp;&amp; softBreakCount == lineCount - 1), EXIT);    lineEndOffsets[softBreakCount] = textOffset + textLength;    lineStartOffset = textOffset;    // @@@ If maxAscent or maxDescent are not integers, this code may produce uneven line spacing. It will also    // not necessarily match the line height used by ATSUI when highlighting. ATSUI highlighting uses    // FixedToInt( baseline - ascent ) for the top of the box and FixedToInt( baseline + descent ) for the bottom.    // Any other combination of reflection and rounding can result in one-pixel gaps and overlaps.        // If you're using ATSUGetGlyphBounds above, you could ask for kATSUseDeviceOrigins to have ATSUI do this transformation for you.        //  draw each line    for (ln = 0; ln &lt; lineCount; ln++) {      lineEndOffset = lineEndOffsets[ln];            // predecrement to account for the line height      if (textAngle == kVerticalTextAngle)        xPos -= maxAscent;      else        yPos -= maxAscent;      theStatus = ATSUDrawText(iTextLayout, lineStartOffset, lineEndOffset - lineStartOffset, xPos,  yPos);      require(theStatus == noErr, EXIT);      lineStartOffset = lineEndOffset;            if (textAngle == kVerticalTextAngle)        xPos -= maxDescent;      else        yPos -= maxDescent;    }  }  EXIT:  if (lineEndOffsets != NULL)     DisposePtr((char*)lineEndOffsets);    return theStatus;}/*  atsuTextBox expands the functionality of TETextBox by adding  justification and vertical text.    atsuTextBox first sets up a ATSUTextLayout. It then draws the text  using atsuDrawTextInBox  */enum {  kInitialStyleAllocation = 10  };OSStatus atsuTextBox(  ConstUniCharArrayPtr     iText,            UniCharCount         iTextLength,            const Rect *        iBox,            short             alignment,            Fract            justification,            short            textOrientation,            Boolean            useFontFallBacks){  OSStatus    theStatus = 0;  ATSUStyle    globalStyle = NULL;  ATSUTextLayout  txLayout = NULL;    int        substituteStyleCount = 0;  int        maxStyleCount = kInitialStyleAllocation;  ATSUStyle**    substituteStyles = NULL;    theStatus = ATSUCreateStyle(&amp;globalStyle);  if (theStatus == noErr)   {    //  Initialize the style with the current port attributes    theStatus = atsuSetStyleFromGrafPtr(globalStyle, NULL, false);    require(theStatus == noErr, EXIT);    //  Don't want to have hanging punctuation drawn outside of the rectangle,    //  so inhibit that feature. (It's allowed by default)    theStatus = atsuSetHangingInhibitFactor(globalStyle, ((Fract) 0x00000001L));        if (theStatus == noErr)     {          theStatus = ATSUCreateTextLayoutWithTextPtr( iText, 0, iTextLength, iTextLength,                          1, &amp;iTextLength, &amp;globalStyle,                          &amp;txLayout);                                if (theStatus == noErr) //  Set layout controls and draw      {        UniCharArrayOffset   replaceOffset = 0;        UniCharCount    replaceLength = iTextLength;                //  Could have had atsuTextBox use the ATSUI flushFactors directly        //  This is just to illustrate how to convert from the        //  TE equivalents        Fract  flushFactor = atsuFlushFactorFromTEAlignment(alignment);                //  a slight optimization since we know that this        //  text is display only        theStatus = atsuSetLayoutOptions(txLayout, kATSLineIsDisplayOnly);        require(theStatus == noErr, EXIT);        //  Set the flush and justification if they are other than the         //  default        if (flushFactor != kATSUStartAlignment || justification != kATSUNoJustification)        {          Fixed  lineWidth = IntToFixed(iBox-&gt;right-iBox-&gt;left);                    if (textOrientation == katsuVerticalText)            lineWidth = IntToFixed(iBox-&gt;bottom-iBox-&gt;top);                            //  line width must be set for flush and justification to work          theStatus = atsuSetLayoutWidth(txLayout, lineWidth);                  require(theStatus == noErr, EXIT);          theStatus = atsuSetLayoutFlushFactor(txLayout, flushFactor);              require(theStatus == noErr, EXIT);                        theStatus = atsuSetLayoutJustFactor(txLayout, justification);          require(theStatus == noErr, EXIT);                              // don't justify the last line          theStatus = atsuSetLayoutOptions(txLayout, kATSLineLastNoJustification);          require(theStatus == noErr, EXIT);        }                if (textOrientation == katsuVerticalText)        {          // set the character orientation          theStatus = atsuSetVerticalCharacter(globalStyle, kATSUStronglyVertical);          require(theStatus == noErr, EXIT);                    //  rotate the text          theStatus = atsuSetLayoutRotation(txLayout, kVerticalTextAngle);          require(theStatus == noErr, EXIT);        }        //  If the caller specifies useFontFallBacks        //  Check to see if there are any characters that can't be drawn        //  with the font that came in from the port.        //  Use ATSUMatchFontsToText to find problem subranges        //  Explicitly replacing the font will be less than the overhead        //  of setting transient font matching for the entire layout.        if (useFontFallBacks)        {          Boolean  needTransientMatching = false;          Boolean  doneWithSubstitution = false;                    while (!doneWithSubstitution)          {            ATSUFontID  replaceFont;                        theStatus = ATSUMatchFontsToText(                    txLayout, replaceOffset, replaceLength,                    &amp;replaceFont, &amp;replaceOffset, &amp;replaceLength);                                switch (theStatus)            {              case kATSUFontsMatched:              {                int      i = 0;                ATSUStyle  replacementStyle = NULL;                                //  &quot;kATSUFontsMatched&quot; means that some of the characters cannot                //  be drawn with the font, but a suitable subsitute font                //  is active in the system                                //  before we create a new style, see if we already have a style with this font                for (i = 0; i &lt; substituteStyleCount &amp;&amp; !replacementStyle; i++)                {                  ATSUFontID  thisFont;                  atsuGetFont((*substituteStyles)[i], &amp;thisFont);                  if (thisFont == replaceFont)                  {                    replacementStyle = (*substituteStyles)[i];                  }                }                                if (!replacementStyle)                {                  //  need to create a new one, cloning the global style                  theStatus = ATSUCreateAndCopyStyle(globalStyle, &amp;replacementStyle);                  require(theStatus == noErr, EXIT);                                    theStatus = atsuSetFont(replacementStyle, replaceFont);                  require(theStatus == noErr, EXIT);                                    //  add it to the list                  if (substituteStyles == NULL)                  {                    maxStyleCount = kInitialStyleAllocation;                    substituteStyles = (ATSUStyle**) NewHandle(maxStyleCount * sizeof(ATSUStyle));                    HLock((Handle) substituteStyles);                    require ((substituteStyles != NULL &amp;&amp; MemError() == noErr), EXIT);                  } else {                    // do we need to expand our array of styles?                    if (substituteStyleCount &gt; maxStyleCount)                    {                      maxStyleCount += kInitialStyleAllocation;                      HUnlock((Handle) substituteStyles);                      SetHandleSize((Handle) substituteStyles, maxStyleCount * sizeof(ATSUStyle));                      HLock((Handle) substituteStyles);                      theStatus = MemError();                      require(theStatus == noErr, EXIT);                    }                  }                  (*substituteStyles)[substituteStyleCount++] = replacementStyle;                }                theStatus = ATSUSetRunStyle(txLayout, replacementStyle, replaceOffset, replaceLength);                require (theStatus == noErr, EXIT);                break;              }              case kATSUFontsNotMatched:              {                //  kATSUFontsNotMatched&quot; means that some of the characters cannot                //  be drawn with any currently active font.                //  this will tell us to turn on transient font matching                 //  and pick up glyphs from the last resort font                 needTransientMatching = true;                break;              }              default:                //  done with any other status                doneWithSubstitution = true;                break;            }            replaceOffset += replaceLength;            replaceLength = iTextLength - replaceOffset;          }           require(theStatus == noErr, EXIT);                    if (needTransientMatching)          {            theStatus = ATSUSetTransientFontMatching(txLayout, true);            require(theStatus == noErr, EXIT);          }        }                //  Finally, this is where the drawing happens        theStatus = atsuDrawTextInBox(txLayout, iBox);      }    }  }EXIT:  if (globalStyle)  {    ATSUDisposeStyle(globalStyle);  }    if (substituteStyles)  {    int i;    for (i = 0; i &lt; substituteStyleCount; i++)    {      ATSUDisposeStyle((*substituteStyles)[i]);    }    HUnlock((Handle) substituteStyles);    DisposeHandle((Handle) substituteStyles);    }  if (txLayout) {    ATSUDisposeTextLayout(txLayout);  }  return theStatus;}OSStatus atsuCompositedTextBox(  ConstUniCharArrayPtr     iText,            UniCharCount         iTextLength,            const Rect *        iBox,            short             alignment,            Fract            justification,            short            textOrientation,            Boolean            useFontFallBacks,            CGContextRef context,            ATSUFontID fontID,            Fixed fontSize){  OSStatus    theStatus = 0;  ATSUStyle    globalStyle = NULL;  ATSUTextLayout  txLayout = NULL;    int        substituteStyleCount = 0;  int        maxStyleCount = kInitialStyleAllocation;  ATSUStyle**    substituteStyles = NULL;    theStatus = ATSUCreateStyle(&amp;globalStyle);  if (theStatus == noErr)   {    // We cannot get information about font, styles, size, etc. from the CGContext as we could in QuickDraw    // so we just comment out the following line. We keep the function around in case we can get information    // from the CGContext in a later system version//    theStatus = atsuSetStyleFromGrafPtr(globalStyle, NULL, false);//    require(theStatus == noErr, EXIT);    ATSUAttributeTag theTags[] = { kATSUFontTag, kATSUSizeTag };    ByteCount theSizes[] = { sizeof(ATSUFontID), sizeof(Fixed) };    ATSUAttributeValuePtr theValues[] = { &amp;fontID, &amp;fontSize };    theStatus = ATSUSetAttributes( globalStyle, sizeof(theTags) / sizeof(ATSUAttributeTag), theTags, theSizes, theValues );    require(theStatus == noErr, EXIT);    //  Don't want to have hanging punctuation drawn outside of the rectangle,    //  so inhibit that feature. (It's allowed by default)    theStatus = atsuSetHangingInhibitFactor(globalStyle, ((Fract) 0x00000001L));        if (theStatus == noErr)     {          theStatus = ATSUCreateTextLayoutWithTextPtr( iText, 0, iTextLength, iTextLength,                          1, &amp;iTextLength, &amp;globalStyle,                          &amp;txLayout);                                if (theStatus == noErr) //  Set layout controls and draw      {        UniCharArrayOffset   replaceOffset = 0;        UniCharCount    replaceLength = iTextLength;        // Letting ATSUI know that we draw in a CGContext instead of a QuickDraw port        ATSUAttributeTag tags[] = { kATSUCGContextTag };        ByteCount valueSizes[] = { sizeof(CGContextRef) };        ATSUAttributeValuePtr values[] = { &amp;context };        theStatus = ATSUSetLayoutControls(txLayout, 1, tags, valueSizes, values);        require_noerr(theStatus, EXIT);                //  Could have had atsuTextBox use the ATSUI flushFactors directly        //  This is just to illustrate how to convert from the        //  TE equivalents        Fract  flushFactor = atsuFlushFactorFromTEAlignment(alignment);                //  a slight optimization since we know that this        //  text is display only        theStatus = atsuSetLayoutOptions(txLayout, kATSLineIsDisplayOnly);        require(theStatus == noErr, EXIT);        //  Set the flush and justification if they are other than the         //  default        if (flushFactor != kATSUStartAlignment || justification != kATSUNoJustification)        {          Fixed  lineWidth = IntToFixed(iBox-&gt;right-iBox-&gt;left);                    if (textOrientation == katsuVerticalText)            lineWidth = IntToFixed(iBox-&gt;bottom-iBox-&gt;top);                            //  line width must be set for flush and justification to work          theStatus = atsuSetLayoutWidth(txLayout, lineWidth);                  require(theStatus == noErr, EXIT);          theStatus = atsuSetLayoutFlushFactor(txLayout, flushFactor);              require(theStatus == noErr, EXIT);                        theStatus = atsuSetLayoutJustFactor(txLayout, justification);          require(theStatus == noErr, EXIT);                              // don't justify the last line          theStatus = atsuSetLayoutOptions(txLayout, kATSLineLastNoJustification);          require(theStatus == noErr, EXIT);        }                if (textOrientation == katsuVerticalText)        {          // set the character orientation          theStatus = atsuSetVerticalCharacter(globalStyle, kATSUStronglyVertical);          require(theStatus == noErr, EXIT);                    //  rotate the text          theStatus = atsuSetLayoutRotation(txLayout, kVerticalTextAngle);          require(theStatus == noErr, EXIT);        }        //  If the caller specifies useFontFallBacks        //  Check to see if there are any characters that can't be drawn        //  with the font that came in from the port.        //  Use ATSUMatchFontsToText to find problem subranges        //  Explicitly replacing the font will be less than the overhead        //  of setting transient font matching for the entire layout.        if (useFontFallBacks)        {          Boolean  needTransientMatching = false;          Boolean  doneWithSubstitution = false;                    while (!doneWithSubstitution)          {            ATSUFontID  replaceFont;                        theStatus = ATSUMatchFontsToText(                    txLayout, replaceOffset, replaceLength,                    &amp;replaceFont, &amp;replaceOffset, &amp;replaceLength);                                switch (theStatus)            {              case kATSUFontsMatched:              {                int      i = 0;                ATSUStyle  replacementStyle = NULL;                                //  &quot;kATSUFontsMatched&quot; means that some of the characters cannot                //  be drawn with the font, but a suitable subsitute font                //  is active in the system                                //  before we create a new style, see if we already have a style with this font                for (i = 0; i &lt; substituteStyleCount &amp;&amp; !replacementStyle; i++)                {                  ATSUFontID  thisFont;                  atsuGetFont((*substituteStyles)[i], &amp;thisFont);                  if (thisFont == replaceFont)                  {                    replacementStyle = (*substituteStyles)[i];                  }                }                                if (!replacementStyle)                {                  //  need to create a new one, cloning the global style                  theStatus = ATSUCreateAndCopyStyle(globalStyle, &amp;replacementStyle);                  require(theStatus == noErr, EXIT);                                    theStatus = atsuSetFont(replacementStyle, replaceFont);                  require(theStatus == noErr, EXIT);                                    //  add it to the list                  if (substituteStyles == NULL)                  {                    maxStyleCount = kInitialStyleAllocation;                    substituteStyles = (ATSUStyle**) NewHandle(maxStyleCount * sizeof(ATSUStyle));                    HLock((Handle) substituteStyles);                    require ((substituteStyles != NULL &amp;&amp; MemError() == noErr), EXIT);                  } else {                    // do we need to expand our array of styles?                    if (substituteStyleCount &gt; maxStyleCount)                    {                      maxStyleCount += kInitialStyleAllocation;                      HUnlock((Handle) substituteStyles);                      SetHandleSize((Handle) substituteStyles, maxStyleCount * sizeof(ATSUStyle));                      HLock((Handle) substituteStyles);                      theStatus = MemError();                      require(theStatus == noErr, EXIT);                    }                  }                  (*substituteStyles)[substituteStyleCount++] = replacementStyle;                }                theStatus = ATSUSetRunStyle(txLayout, replacementStyle, replaceOffset, replaceLength);                require (theStatus == noErr, EXIT);                break;              }              case kATSUFontsNotMatched:              {                //  kATSUFontsNotMatched&quot; means that some of the characters cannot                //  be drawn with any currently active font.                //  this will tell us to turn on transient font matching                 //  and pick up glyphs from the last resort font                 needTransientMatching = true;                break;              }              default:                //  done with any other status                doneWithSubstitution = true;                break;            }            replaceOffset += replaceLength;            replaceLength = iTextLength - replaceOffset;          }           require(theStatus == noErr, EXIT);                    if (needTransientMatching)          {            theStatus = ATSUSetTransientFontMatching(txLayout, true);            require(theStatus == noErr, EXIT);          }        }                //  Finally, this is where the drawing happens        theStatus = atsuCompositedDrawTextInBox(txLayout, iBox);      }    }  }EXIT:  if (globalStyle)  {    ATSUDisposeStyle(globalStyle);  }    if (substituteStyles)  {    int i;    for (i = 0; i &lt; substituteStyleCount; i++)    {      ATSUDisposeStyle((*substituteStyles)[i]);    }    HUnlock((Handle) substituteStyles);    DisposeHandle((Handle) substituteStyles);    }  if (txLayout) {    ATSUDisposeTextLayout(txLayout);  }  return theStatus;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/TypeServicesForUnicode/listing6.html%3Fid%3DDTS10001097-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/TypeServicesForUnicode/listing6.html%3Fid%3DDTS10001097-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/TypeServicesForUnicode/listing6.html%3Fid%3DDTS10001097-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>