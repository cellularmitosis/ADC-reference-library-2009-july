<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Plug-in  - Attr - /NameAttrTest.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Plug-in  - Attr</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Plug-in  - Attr</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/NameAttrTest.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/NameAttribute.c</option>
<option value="listing2.html">/NameAttribute.h</option>
<option value="listing3.html">/NameAttrTest.c</option>
<option value="listing4.html">/QuickAttrTest.c</option></select>
				</p>
				</form>
				<p><strong><a href="Plug-in__-_Attr.zip">Download Sample</a></strong> (&#147;Plug-in__-_Attr.zip&#148;, 85.5K)<BR>
<strong><a href="Plug-in__-_Attr.dmg">Download Sample</a></strong> (&#147;Plug-in__-_Attr.dmg&#148;, 149.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/* this is box, modified to be a test for the name plug-in attribute */// NameAttrTest.c - QuickDraw 3d routines//// This is box, the QuickDraw 3D starter program.  Written for the// Getting started with QuickDraw 3D Develop article.  This app does not have // graceful error handling - it's purpose is to illustrate a very basic QuickDraw // 3D program.//// Nick Thompson, Robert Dierkes - April 24, 1997// // &copy;1994-97 Apple computer Inc., All Rights Reserved//// system headers#include &lt;Devices.h&gt;#include &lt;Dialogs.h&gt;#include &lt;DiskInit.h&gt;#include &lt;Fonts.h&gt;#include &lt;Menus.h&gt;#include &lt;PictUtils.h&gt;#include &lt;QDOffScreen.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;SegLoad.h&gt;#include &lt;StandardFile.h&gt;#include &lt;TextEdit.h&gt;#include &lt;strings.h&gt;#include &lt;string.h&gt;// for QuickDraw 3D#include &quot;QD3D.h&quot;#include &quot;QD3DAcceleration.h&quot;#include &quot;QD3DCamera.h&quot;#include &quot;QD3DDrawContext.h&quot;#include &quot;QD3DGeometry.h&quot;#include &quot;QD3DGroup.h&quot;#include &quot;QD3DLight.h&quot;#include &quot;QD3DMath.h&quot;#include &quot;QD3DPick.h&quot;#include &quot;QD3DRenderer.h&quot;#include &quot;QD3DSet.h&quot;#include &quot;QD3DShader.h&quot;#include &quot;QD3DTransform.h&quot;#include &quot;NameAttribute.h&quot;//-------------------------------------------------------------------------------------------struct _documentRecord {  TQ3ViewObject  fView ;          // the view for the scene  TQ3GroupObject  fModel ;        // object in the scene being modelled  TQ3StyleObject  fInterpolation ;    // interpolation style used when rendering  TQ3StyleObject  fBackFacing ;      // whether to draw shapes that face away from the camera  TQ3StyleObject  fFillStyle ;      // whether drawn as solid filled object or decomposed to components  TQ3Matrix4x4    fRotation;      // the transform for the model};typedef struct _documentRecord DocumentRec, *DocumentPtr, **DocumentHdl ;//-------------------------------------------------------------------------------------------// function prototypesvoid InitDocumentData(   DocumentPtr theDocument ) ;void DisposeDocumentData(   DocumentPtr theDocument ) ;void   SubmitDocumentData(   DocumentPtr theDocument ) ;TQ3Status DocumentDraw3DData(   DocumentPtr theDocument ) ;short HiWrd(  long aLong) ;short LoWrd(  long aLong ) ;void InitToolbox(  void ) ;void PickAndProcess(   WindowPtr   window,  DocumentPtr  theDocument,   Point     mouseLoc ) ;void ChangeObjectName(  TQ3GeometryObject  objectPicked,  TQ3AttributeSet    attribSet) ;void MainEventLoop(  void ) ;void HandleKeyPress(  EventRecord *event ) ;TQ3ViewObject MyNewView(  WindowPtr theWindow ) ;TQ3DrawContextObject MyNewDrawContext(  WindowPtr theWindow ) ;TQ3CameraObject MyNewCamera(  WindowPtr theWindow) ;TQ3GroupObject MyNewLights(  void ) ;void MyColorBoxFaces(   TQ3BoxData *myBoxData ) ;TQ3GroupPosition MyAddTransformedObjectToGroup(   TQ3GroupObject theGroup,   TQ3Object theObject,   TQ3Vector3D *translation ) ;TQ3GroupObject MyNewModel(  void ) ;//-------------------------------------------------------------------------------------------//Boolean     gQuitFlag     = false ;WindowPtr    gMainWindow    = nil ;DocumentRec    gDocument ;//-------------------------------------------------------------------------------------------// main()// entry point for the application, initialize the toolbox, initialize QuickDraw 3D// and enter the main event loop.  On exit from the main event loop, we want to call// the QuickDraw 3D exit function to clean up QuickDraw 3d.void main(void){  TQ3Status  myStatus;  Rect    rBounds = { 50, 50, 450, 450 } ;  Str255    title = &quot;\pName Attributes on Geometries&quot; ;  InitToolbox() ;  //  Initialize QuickDraw 3D, open a connection to the QuickDraw 3D library  myStatus = Q3Initialize();  if ( myStatus == kQ3Failure )  {    DebugStr(&quot;\pQ3Initialize returned failure.  Use QD3D debug version to find out why.&quot;);      ExitToShell() ;  }    // set up our globals  gQuitFlag = false ;  gMainWindow = NewCWindow(nil,&amp;rBounds,title,true,noGrowDocProc,(WindowPtr)-1,true,0) ;  InitDocumentData( &amp;gDocument ) ;    MainEventLoop();    DisposeDocumentData( &amp;gDocument ) ;    //  Close our connection to the QuickDraw 3D library  myStatus = Q3Exit();    if ( myStatus == kQ3Failure )    DebugStr(&quot;\pQ3Exit returned failure.  Use debug version to find out why&quot;);    ExitToShell() ;}//-------------------------------------------------------------------------------------------//void InitDocumentData( DocumentPtr theDocument ) {  // sets up the 3d data for the scene  // Create view for QuickDraw 3D.  theDocument-&gt;fView = MyNewView( (WindowPtr)gMainWindow ) ;  // the main display group:  theDocument-&gt;fModel = MyNewModel() ;  // the drawing styles:  theDocument-&gt;fInterpolation = Q3InterpolationStyle_New(kQ3InterpolationStyleNone) ;  theDocument-&gt;fBackFacing = Q3BackfacingStyle_New(kQ3BackfacingStyleBoth ) ;  theDocument-&gt;fFillStyle = Q3FillStyle_New(kQ3FillStyleFilled ) ;  // set the rotation matrix the identity matrix  Q3Matrix4x4_SetIdentity(&amp;theDocument-&gt;fRotation);}//-----------------------------------------------------------------------------// void DisposeDocumentData( DocumentPtr theDocument){  Q3Object_Dispose(theDocument-&gt;fView) ;        // the view for the scene  Q3Object_Dispose(theDocument-&gt;fModel) ;        // object in the scene being modelled  Q3Object_Dispose(theDocument-&gt;fInterpolation) ;    // interpolation style used when rendering  Q3Object_Dispose(theDocument-&gt;fBackFacing) ;    // whether to draw shapes that face away from the camera  Q3Object_Dispose(theDocument-&gt;fFillStyle) ;      // whether drawn as solid filled object or decomposed to components}//-----------------------------------------------------------------------------// void   SubmitDocumentData(   DocumentPtr theDocument ) {  Q3Style_Submit( theDocument-&gt;fInterpolation, theDocument-&gt;fView );  Q3Style_Submit( theDocument-&gt;fBackFacing, theDocument-&gt;fView );  Q3Style_Submit( theDocument-&gt;fFillStyle, theDocument-&gt;fView );  Q3MatrixTransform_Submit( &amp;theDocument-&gt;fRotation, theDocument-&gt;fView );  Q3DisplayGroup_Submit( theDocument-&gt;fModel, theDocument-&gt;fView );}//-----------------------------------------------------------------------------// TQ3Status DocumentDraw3DData( DocumentPtr theDocument ){    Q3View_StartRendering(theDocument-&gt;fView );  do {    SubmitDocumentData( theDocument ) ;  } while (Q3View_EndRendering(theDocument-&gt;fView) == kQ3ViewStatusRetraverse );  Q3View_Sync( theDocument-&gt;fView ) ;  return kQ3Success ;}//-------------------------------------------------------------------------------------------//short HiWrd(long aLong){  return  (((aLong) &gt;&gt; 16) &amp; 0xFFFF) ;}//-------------------------------------------------------------------------------------------//short LoWrd(long aLong){  return  ((aLong) &amp; 0xFFFF) ;}//-------------------------------------------------------------------------------------------//void InitToolbox(){  Handle    menuBar = nil;  MaxApplZone() ;  MoreMasters() ; MoreMasters() ; MoreMasters() ;     InitGraf( &amp;qd.thePort );  InitFonts();  InitWindows();  InitCursor();  FlushEvents( everyEvent, 0 ) ;    /* initialize application globals */  gQuitFlag = false;  }//-------------------------------------------------------------------------------------------//void PickAndProcess(   WindowPtr   window,  DocumentPtr  theDocument,   Point     mouseLoc ){  TQ3WindowPointPickData  myWindowPointPickData;  TQ3GeometryObject    objectPicked;  TQ3PickObject      pickObject = NULL ;  unsigned long      numPicked;  unsigned long      i;  TQ3AttributeSet     attribSet;  /* set up the picking data field */  myWindowPointPickData.data.sort = kQ3PickSortNearToFar;  myWindowPointPickData.data.mask = kQ3PickDetailMaskObject;  myWindowPointPickData.data.numHitsToReturn = kQ3ReturnAllHits;  /* get the point of the click in local (window) co-ordinates */  GlobalToLocal( &amp;mouseLoc ) ;  myWindowPointPickData.point.x = mouseLoc.h ;  myWindowPointPickData.point.y = mouseLoc.v  ;  myWindowPointPickData.vertexTolerance = 3.0 ;  myWindowPointPickData.edgeTolerance    = 3.0 ;  if ((pickObject = Q3WindowPointPick_New( &amp;myWindowPointPickData ))  != NULL) {    Q3View_StartPicking(theDocument-&gt;fView, pickObject);    do {      SubmitDocumentData(theDocument) ;    } while (Q3View_EndPicking(theDocument-&gt;fView) == kQ3ViewStatusRetraverse );  }  if (Q3Pick_GetNumHits(pickObject, &amp;numPicked) == kQ3Success) {    /* Get all geometries hit */    for (i = 0; i &lt; numPicked; i++) {      if (Q3Pick_GetPickDetailData(          pickObject,           i,           kQ3PickDetailMaskObject,           &amp;objectPicked) == kQ3Failure) {        break;      }      /* switch on/off highlighting for this object */      Q3Geometry_GetAttributeSet(objectPicked, &amp;attribSet);      if (!attribSet) {        attribSet = Q3AttributeSet_New();        Q3Geometry_SetAttributeSet(objectPicked, attribSet);      }      /* Set or get the name of the geometry hit */      ChangeObjectName(objectPicked, attribSet);      Q3Object_Dispose(attribSet);      Q3Object_Dispose(objectPicked);    }    DocumentDraw3DData( theDocument ) ;  }  Q3Object_Dispose(pickObject);   }//-------------------------------------------------------------------------------------------//void ChangeObjectName(  TQ3GeometryObject  objectPicked,  TQ3AttributeSet    attribSet){  DialogPtr  theDialog ;  Handle    itemHndl = nil;  Rect    itemRect ;  short    itemType ;  short    itemHit ;  TQ3Switch  highlightSwitch ;  char    nameString[255] ;  if ( NameAttribute_GetName( objectPicked, nameString) == kQ3Success &amp;&amp;     *nameString != '\0') {    c2pstr(nameString);    ParamText((unsigned char *)nameString, (unsigned char *)&quot;\0&quot;,  (unsigned char *)&quot;\0&quot;,  (unsigned char *)&quot;\0&quot; ) ;    Alert( 128, nil ) ;    /* add the hightlight attribute it's off now */    highlightSwitch = kQ3Off ;    Q3AttributeSet_Add(attribSet,                kQ3AttributeTypeHighlightState,               &amp;highlightSwitch);  }  else {    /* add the hightlight attribute it is on now*/    highlightSwitch = kQ3On ;    Q3AttributeSet_Add(attribSet,                kQ3AttributeTypeHighlightState,               &amp;highlightSwitch);    theDialog = GetNewDialog(128, nil, (WindowPtr)-1) ;    do {      ModalDialog(nil, &amp;itemHit);    } while( itemHit != 1 ) ;    GetDialogItem(theDialog, 4, &amp;itemType, (Handle*)&amp;itemHndl, &amp;itemRect);    GetDialogItemText(itemHndl, (StringPtr) nameString);    DisposeDialog( theDialog ) ;    if( itemHndl != nil &amp;&amp; objectPicked != nil )    {      p2cstr((StringPtr) nameString) ;      NameAttribute_SetName( objectPicked, (char *)nameString) ;    }               DisposeHandle( (Handle)itemHndl ) ;  }}//-------------------------------------------------------------------------------------------//void MainEventLoop(){  EventRecord   event;  WindowPtr     window;  short         thePart;  Rect          screenRect, updateRect;  Point      aPoint = {100, 100};  CGrafPtr    savedPort ;    while( !gQuitFlag )  {    if (WaitNextEvent( everyEvent, &amp;event, 10, nil ))    {      switch (event.what) {        case mouseDown:          thePart = FindWindow( event.where, &amp;window );          switch( thePart ) {            case inMenuBar:               break;            case inDrag:              screenRect = (**GetGrayRgn()).rgnBBox;              DragWindow( window, event.where, &amp;screenRect );              break ;            case inContent:              if (window != FrontWindow())                SelectWindow( window );              else                PickAndProcess( window, &amp;gDocument, event.where ) ;              break ;            case inGoAway:              if (TrackGoAway( window, event.where )) {                DisposeWindow ( window );                gQuitFlag = true;              }              break ;                          default:              break ;          }          break ;                                  case updateEvt:                  window = (WindowPtr)event.message;          updateRect = (**(window-&gt;visRgn)).rgnBBox;          SetPort( window ) ;          BeginUpdate( window );          DocumentDraw3DData( &amp;gDocument ) ;          EndUpdate( window );          break ;                  case keyDown:        case autoKey:          HandleKeyPress(&amp;event);          break;                  case diskEvt:          if ( HiWrd(event.message) != noErr )             (void) DIBadMount(aPoint, event.message);          break;                  case osEvt:        case activateEvt:          break;      }    }    else {      // we received a null event, rotate the cube      TQ3Matrix4x4  tmp;      Rect      theRect = ((GrafPtr)gMainWindow)-&gt;portRect ;            SetPort((GrafPtr)gMainWindow) ;      Q3Matrix4x4_SetRotate_XYZ(&amp;tmp, 0.1, 0.12, 0.08);      Q3Matrix4x4_Multiply(&amp;gDocument.fRotation, &amp;tmp, &amp;gDocument.fRotation);      InvalRect( &amp;theRect ) ;    }  }}//-------------------------------------------------------------------------------------------//void HandleKeyPress(  EventRecord *event){}//-------------------------------------------------------------------------------------------//TQ3ViewObject MyNewView(  WindowPtr theWindow){  TQ3Status        myStatus;  TQ3ViewObject      myView;  TQ3DrawContextObject    myDrawContext;  TQ3RendererObject    myRenderer;  TQ3CameraObject      myCamera;  TQ3GroupObject      myLights;    myView = Q3View_New();    //  Create and set draw context.  if ((myDrawContext = MyNewDrawContext(theWindow)) == nil )    goto bail;  if ((myStatus = Q3View_SetDrawContext(myView, myDrawContext)) == kQ3Failure )    goto bail;  Q3Object_Dispose( myDrawContext ) ;    //  Create and set renderer.        // this would use the wireframe renderer#if 0  myRenderer = Q3Renderer_NewFromType(kQ3RendererTypeWireFrame);  if ((myStatus = Q3View_SetRenderer(myView, myRenderer)) == kQ3Failure ) {    goto bail;  }  #else  // this would use the interactive software renderer  if ((myRenderer = Q3Renderer_NewFromType(kQ3RendererTypeInteractive)) != nil ) {    if ((myStatus = Q3View_SetRenderer(myView, myRenderer)) == kQ3Failure ) {      goto bail;    }    // these two lines set us up to use the best possible renderer,    // including  hardware if it is installed.    Q3InteractiveRenderer_SetDoubleBufferBypass (myRenderer, kQ3True);    Q3InteractiveRenderer_SetPreferences(myRenderer, kQAVendor_BestChoice, 0);  }  else {    goto bail;  }#endif  Q3Object_Dispose( myRenderer ) ;    //  Create and set camera.  if ( (myCamera = MyNewCamera(theWindow)) == nil )    goto bail;  if ((myStatus = Q3View_SetCamera(myView, myCamera)) == kQ3Failure )    goto bail;  Q3Object_Dispose( myCamera ) ;    //  Create and set lights.  if ((myLights = MyNewLights()) == nil )    goto bail;  if ((myStatus = Q3View_SetLightGroup(myView, myLights)) == kQ3Failure )    goto bail;  Q3Object_Dispose(myLights);  //  Done!!!  return ( myView );  bail:  //  If any of the above failed, then don't return a view.  return ( nil );}//----------------------------------------------------------------------------------TQ3DrawContextObject MyNewDrawContext(  WindowPtr theWindow ){  TQ3DrawContextData    myDrawContextData;  TQ3MacDrawContextData  myMacDrawContextData;  TQ3ColorARGB      ClearColor;  TQ3DrawContextObject  myDrawContext ;    //  Set the background color.  ClearColor.a = 1.0;  ClearColor.r = 1.0;  ClearColor.g = 1.0;  ClearColor.b = 1.0;    //  Fill in draw context data.  myDrawContextData.clearImageMethod = kQ3ClearMethodWithColor;  myDrawContextData.clearImageColor = ClearColor;  myDrawContextData.paneState = kQ3False;  myDrawContextData.maskState = kQ3False;  myDrawContextData.doubleBufferState = kQ3True;   myMacDrawContextData.drawContextData = myDrawContextData;    myMacDrawContextData.window = (CGrafPtr) theWindow;    // this is the window associated with the view  myMacDrawContextData.library = kQ3Mac2DLibraryNone;  myMacDrawContextData.viewPort = nil;  myMacDrawContextData.grafPort = nil;    //  Create draw context and return it, if it's nil the caller must handle  myDrawContext = Q3MacDrawContext_New(&amp;myMacDrawContextData) ;  return myDrawContext ;}//----------------------------------------------------------------------------------TQ3CameraObject MyNewCamera(  WindowPtr theWindow){  TQ3ViewAngleAspectCameraData  perspectiveData;  TQ3CameraObject        camera;    TQ3Point3D           from   = { 0.0, 0.0, 7.25 };  TQ3Point3D           to     = { 0.0, 0.0, 0.0 };  TQ3Vector3D         up     = { 0.0, 1.0, 0.0 };  float             fieldOfView = 1.0;  float             hither     = 0.1;  float             yon     = 10;    TQ3Status          returnVal = kQ3Failure ;  perspectiveData.cameraData.placement.cameraLocation   = from;  perspectiveData.cameraData.placement.pointOfInterest   = to;  perspectiveData.cameraData.placement.upVector       = up;  perspectiveData.cameraData.range.hither  = hither;  perspectiveData.cameraData.range.yon   = yon;  perspectiveData.cameraData.viewPort.origin.x = -1.0;  perspectiveData.cameraData.viewPort.origin.y = 1.0;  perspectiveData.cameraData.viewPort.width = 2.0;  perspectiveData.cameraData.viewPort.height = 2.0;    perspectiveData.fov        = fieldOfView;  perspectiveData.aspectRatioXToY  =    (float) (theWindow-&gt;portRect.right - theWindow-&gt;portRect.left) /     (float) (theWindow-&gt;portRect.bottom - theWindow-&gt;portRect.top);  camera = Q3ViewAngleAspectCamera_New(&amp;perspectiveData);  return camera ;}//----------------------------------------------------------------------------------TQ3GroupObject MyNewLights(  void ){  TQ3GroupPosition    myGroupPosition;  TQ3GroupObject      myLightList;  TQ3LightData      myLightData;  TQ3PointLightData    myPointLightData;  TQ3DirectionalLightData  myDirectionalLightData;  TQ3LightObject      myAmbientLight, myPointLight, myFillLight;  TQ3Point3D        pointLocation = { -10.0, 0.0, 10.0 };  TQ3Vector3D        fillDirection = { 10.0, 0.0, 10.0 };  TQ3ColorRGB        WhiteLight = { 1.0, 1.0, 1.0 };    //  Set up light data for ambient light.  This light data will be used for point and fill  //  light also.  myLightData.isOn = kQ3True;  myLightData.color = WhiteLight;    //  Create ambient light.  myLightData.brightness = .2;  myAmbientLight = Q3AmbientLight_New(&amp;myLightData);  if ( myAmbientLight == nil )    goto bail;    //  Create point light.  myLightData.brightness = 1.0;  myPointLightData.lightData = myLightData;  myPointLightData.castsShadows = kQ3False;  myPointLightData.attenuation = kQ3AttenuationTypeNone;  myPointLightData.location = pointLocation;  myPointLight = Q3PointLight_New(&amp;myPointLightData);  if ( myPointLight == nil )    goto bail;  //  Create fill light.  myLightData.brightness = .2;  myDirectionalLightData.lightData = myLightData;  myDirectionalLightData.castsShadows = kQ3False;  myDirectionalLightData.direction = fillDirection;  myFillLight = Q3DirectionalLight_New(&amp;myDirectionalLightData);  if ( myFillLight == nil )    goto bail;  //  Create light group and add each of the lights into the group.  myLightList = Q3LightGroup_New();  if ( myLightList == nil )    goto bail;  myGroupPosition = Q3Group_AddObject(myLightList, myAmbientLight);  if ( myGroupPosition == 0 )    goto bail;  myGroupPosition = Q3Group_AddObject(myLightList, myPointLight);  if ( myGroupPosition == 0 )    goto bail;  myGroupPosition = Q3Group_AddObject(myLightList, myFillLight);  if ( myGroupPosition == 0 )    goto bail;  Q3Object_Dispose( myAmbientLight ) ;  Q3Object_Dispose( myPointLight ) ;  Q3Object_Dispose( myFillLight ) ;  //  Done!  return ( myLightList );  bail:  //  If any of the above failed, then return nothing!  return ( nil );}void MyColorBoxFaces(   TQ3BoxData *myBoxData ){  TQ3ColorRGB        faceColor ;  short           face ;    // sanity check - you need to have set up   // the face attribute set for the box data   // before calling this.    if( myBoxData-&gt;faceAttributeSet == NULL )    return ;  // make each face of a box a different color    for( face = 0; face &lt; 6; face++) {    myBoxData-&gt;faceAttributeSet[face] = Q3AttributeSet_New();    switch( face ) {      case 0:        faceColor.r = 1.0;        faceColor.g = 0.0;        faceColor.b = 0.0;        break;      case 1:        faceColor.r = 0.0;        faceColor.g = 1.0;        faceColor.b = 0.0;        break;      case 2:        faceColor.r = 0.0;        faceColor.g = 0.0;        faceColor.b = 1.0;        break;      case 3:        faceColor.r = 1.0;        faceColor.g = 1.0;        faceColor.b = 0.0;        break;      case 4:        faceColor.r = 1.0;        faceColor.g = 0.0;        faceColor.b = 1.0;        break;      case 5:        faceColor.r = 0.0;        faceColor.g = 1.0;        faceColor.b = 1.0;        break;    }    Q3AttributeSet_Add(myBoxData-&gt;faceAttributeSet[face], kQ3AttributeTypeDiffuseColor, &amp;faceColor);  }}TQ3GroupPosition MyAddTransformedObjectToGroup(   TQ3GroupObject theGroup,   TQ3Object theObject,   TQ3Vector3D *translation ){  TQ3TransformObject  transform;  transform = Q3TranslateTransform_New(translation);  Q3Group_AddObject(theGroup, transform);    Q3Object_Dispose(transform);  return Q3Group_AddObject(theGroup, theObject);  }TQ3GroupObject MyNewModel(  void ){  TQ3GroupObject      myGroup = NULL;  TQ3GroupPosition    myGroupPosition;  TQ3ShaderObject      myIlluminationShader ;  TQ3BoxData        boxData;  TQ3ConeData        coneData;  TQ3CylinderData      cylinderData;  TQ3TorusData      torusData;  TQ3GeometryObject    boxGeo,              coneGeo,              cylinderGeo,              torusGeo;  short          face ;  TQ3SetObject      boxFaces[6] ;  TQ3ColorRGB        color;  TQ3Vector3D        translation;  // Create a group for the complete model.  // do not use Q3OrderedDisplayGroup_New since in this  // type of group all of the translations are applied before  // the objects in the group are drawn, in this instance we   // dont want this.  if ((myGroup = Q3DisplayGroup_New()) != NULL ) {    // Define a shading type for the group    // and add the shader to the group    myIlluminationShader = Q3PhongIllumination_New();    if (myIlluminationShader != NULL ) {      Q3Group_AddObject(myGroup, myIlluminationShader);      Q3Object_Dispose(myIlluminationShader);      }      // create the box    // set up the colored faces for the box data    boxData.faceAttributeSet = boxFaces;    boxData.boxAttributeSet = nil;    MyColorBoxFaces( &amp;boxData ) ;    Q3Point3D_Set(&amp;boxData.origin, 0, 0, 0);    Q3Vector3D_Set(&amp;boxData.orientation, 0, 1.25, 0);    Q3Vector3D_Set(&amp;boxData.majorAxis, 0, 0, 2);      Q3Vector3D_Set(&amp;boxData.minorAxis, 1.25, 0, 0);      boxGeo = Q3Box_New(&amp;boxData);    // create the cone    Q3Point3D_Set(&amp;coneData.origin, 0, 0, 0);    Q3Vector3D_Set(&amp;coneData.orientation, 0, 1.75, 0);    Q3Vector3D_Set(&amp;coneData.majorRadius, 0, 0, 0.75);      Q3Vector3D_Set(&amp;coneData.minorRadius, 0.75, 0, 0);    coneData.uMin = 0.0;    coneData.uMax = 1.0;    coneData.vMin = 0.0;    coneData.vMax = 1.0;    coneData.caps = kQ3EndCapMaskBottom;    coneData.interiorAttributeSet   = NULL;    coneData.faceAttributeSet     = NULL;    coneData.bottomAttributeSet    = NULL;    coneData.coneAttributeSet = Q3AttributeSet_New();    if (coneData.coneAttributeSet != NULL ) {      Q3ColorRGB_Set(&amp;color, 0.3, 0.9, 0.9);      Q3AttributeSet_Add(coneData.coneAttributeSet, kQ3AttributeTypeDiffuseColor, &amp;color);    }    coneGeo = Q3Cone_New(&amp;coneData);    // create the cylinder    Q3Point3D_Set(&amp;cylinderData.origin, 0, 0, 0);    Q3Vector3D_Set(&amp;cylinderData.orientation, 0, 1.25, 0);    Q3Vector3D_Set(&amp;cylinderData.majorRadius, 0, 0, 0.75);      Q3Vector3D_Set(&amp;cylinderData.minorRadius, 0.75, 0, 0);    cylinderData.uMin = 0.0;    cylinderData.uMax = 1.0;    cylinderData.vMin = 0.0;    cylinderData.vMax = 1.0;    cylinderData.caps = kQ3EndCapMaskTop | kQ3EndCapMaskBottom;    cylinderData.interiorAttributeSet   = NULL;    cylinderData.topAttributeSet     = NULL;    cylinderData.faceAttributeSet     = NULL;    cylinderData.bottomAttributeSet    = NULL;    cylinderData.cylinderAttributeSet = Q3AttributeSet_New();    if (cylinderData.cylinderAttributeSet != NULL ) {      Q3ColorRGB_Set(&amp;color, 0.9, 0.3, 0.9);      Q3AttributeSet_Add(cylinderData.cylinderAttributeSet, kQ3AttributeTypeDiffuseColor, &amp;color);    }    cylinderGeo = Q3Cylinder_New(&amp;cylinderData);    // create the torus    Q3Point3D_Set(&amp;torusData.origin, 0, 0.8, 0);    Q3Vector3D_Set(&amp;torusData.orientation, 0, 0.4, 0);    Q3Vector3D_Set(&amp;torusData.majorRadius, 0, 0, 0.75);      Q3Vector3D_Set(&amp;torusData.minorRadius, 0.75, 0, 0);    torusData.ratio = 1.0;    torusData.uMin = 0.0;    torusData.uMax = 1.0;    torusData.vMin = 0.0;    torusData.vMax = 1.0;    torusData.caps = kQ3EndCapNone;    torusData.interiorAttributeSet   = NULL;    torusData.torusAttributeSet = Q3AttributeSet_New();    if (torusData.torusAttributeSet != NULL ) {      Q3ColorRGB_Set(&amp;color, 1.0, 1.0, 0.0);      Q3AttributeSet_Add(torusData.torusAttributeSet, kQ3AttributeTypeDiffuseColor, &amp;color);    }    torusGeo = Q3Torus_New(&amp;torusData);    // add all geometries to group and translate them    Q3Vector3D_Set(&amp;translation, 0, 0, 0);    MyAddTransformedObjectToGroup( myGroup, boxGeo, &amp;translation ) ;    Q3Object_Dispose( boxGeo );    for( face = 0; face &lt; 6; face++) {      if( boxData.faceAttributeSet[face] != NULL )        Q3Object_Dispose(boxData.faceAttributeSet[face]);    }    Q3Vector3D_Set(&amp;translation, 2, 0, 0);    MyAddTransformedObjectToGroup( myGroup, coneGeo, &amp;translation ) ;    Q3Object_Dispose(coneGeo);    if (coneData.coneAttributeSet != NULL )      Q3Object_Dispose(coneData.coneAttributeSet);    Q3Vector3D_Set(&amp;translation, 0, 0, -2);    MyAddTransformedObjectToGroup( myGroup, cylinderGeo, &amp;translation ) ;    Q3Object_Dispose(cylinderGeo);    if (cylinderData.cylinderAttributeSet != NULL )      Q3Object_Dispose(cylinderData.cylinderAttributeSet);    Q3Vector3D_Set(&amp;translation, -2, 0, 0);    MyAddTransformedObjectToGroup( myGroup, torusGeo, &amp;translation ) ;    Q3Object_Dispose(torusGeo);    if (torusData.torusAttributeSet != NULL )      Q3Object_Dispose(torusData.torusAttributeSet);  }  return ( myGroup );}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Plug-in__-_Attr/listing3.html%3Fid%3DDTS10000119-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Plug-in__-_Attr/listing3.html%3Fid%3DDTS10000119-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Plug-in__-_Attr/listing3.html%3Fid%3DDTS10000119-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>