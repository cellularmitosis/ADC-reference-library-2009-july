<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Writing Resources (IM: MTb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING22></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MoreToolbox-21.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-23.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MoreToolbox-2.html"><B>More Macintosh Toolbox</B></A> / <BR><DD><A HREF="MoreToolbox-9.html"><B>Chapter 1 - Resource Manager</B></A> / <A HREF="MoreToolbox-16.html"><B>Using the Resource Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING22-0></A>
<H2><A NAME=MARKER-9-178></A>Writing Resources</H2>
 <A NAME=MARKER-2-179></A>After opening a resource fork (as described in <A HREF=MoreToolbox-20.html#MARKER-9-150>"Creating and Opening a Resource Fork" beginning on page 1-19</A>), you can write resources to it. You can write resources only to the current resource file. To ensure that the current resource file is set to the appropriate resource fork, you can use <CODE>CurResFile</CODE> to save the file reference number of the <BR>current resource file, then <CODE>UseResFile</CODE> to set the current resource file to the desired resource fork. <P>
 To specify data for a new resource, you usually use the <CODE>AddResource</CODE> procedure, which creates a new entry for the resource in the resource map in memory and sets the entry's location to refer to the resource's data. Note that <CODE>AddResource</CODE> changes only the resource map in memory; it doesn't change anything on disk. Use the <CODE>UpdateResFile</CODE> or <CODE>WriteResource</CODE> procedure to write the resource to disk. The <CODE>AddResource</CODE> procedure always adds the resource to the resource map in memory that corresponds to the current resource file. For this reason, you usually need to set the current resource file to the desired file before calling <CODE>AddResource</CODE>.<P>
 If you change a resource that is referenced through the resource map in memory, you use the <CODE>ChangedResource</CODE> procedure to set the <CODE>resChanged</CODE> attribute of that resource's entry. You should then immediately call the <CODE>UpdateResFile</CODE> or <CODE>WriteResource</CODE> procedure to write the changed resource data to disk. Note that although the <CODE>UpdateResFile</CODE> procedure writes only those resources that have been added or changed to disk, it also writes the entire resource map to disk (overwriting its previous contents). The <CODE>WriteResource</CODE> procedure writes only the resource data of a single resource to disk; it does not update the resource's entry in the resource map on disk.<P>
 The <CODE>ChangedResource</CODE> procedure reserves enough disk space to contain the changed resource. It does this every time it's called, but the actual writing of the resource does not take place until a call to <CODE>WriteResource</CODE> or <CODE>UpdateResFile</CODE>. Thus, if you call <CODE>ChangedResource</CODE> several times on a large resource before the resource is actually written, you may unexpectedly run out of disk space, because many times the amount of space actually needed is reserved. When the resource is actually written, the file's end-of-file (<CODE>EOF</CODE>) is set correctly, and the next call to <CODE>ChangedResource</CODE> will work as expected.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>If your application frequently changes the contents of resources (especially large resources), you should call <CODE>WriteResource</CODE> or <CODE>UpdateResFile</CODE> immediately after calling <CODE>ChangedResource</CODE>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To ensure that the Resource Manager does not purge a purgeable resource while your application is in the process of changing it, use the Memory Manager procedures <CODE>HGetState</CODE>, <CODE>HNoPurge</CODE>, and <CODE>HSetState</CODE>. First call <CODE>HGetState</CODE> and <CODE>HNoPurge</CODE>, then change the resource as necessary. To make a change to a resource permanent, use the <CODE>ChangedResource</CODE> and <CODE>WriteResource</CODE> (or <CODE>UpdateResFile</CODE>) procedures; then call <CODE>HSetState</CODE> when you're finished. (See <A HREF=MoreToolbox-18.html#MARKER-9-134>Listing 1-2 on page 1-16</A> for an example of this technique.) However, most applications do not make resources purgeable and therefore don't need to take this precaution.<P>
 Here's an example of a situation in which an application might need to write a resource. As previously described, the SurfWriter application always saves the last position of a document window when the user saves the document, storing this information in a resource that it has defined for this purpose. SurfWriter defines a resource with resource type <CODE>rWinState</CODE> and resource ID <CODE>kLastWinStateID</CODE> to store the window state (its position and state, that is, either the user or the standard state). SurfWriter's window state resource has this format, defined by a record of type <CODE>MyWindowState</CODE>:<P>
<PRE>
TYPE MyWindowState =
   RECORD
      userStateRect: Rect;    {user state rectangle}
      zoomState:     Boolean; {window state: TRUE = standard; }
                              {              FALSE = user}
   END;
MyWindowStatePtr = ^MyWindowState;
MyWindowStateHnd = ^MyWindowStatePtr;
</PRE>
 <A HREF=#MARKER-9-180>Listing 1-11</A> shows SurfWriter's application-defined routine for saving the last position of a window in a window state resource in a document's resource fork.<P>
<B>Listing 1-11  <A NAME=MARKER-9-180></A>Saving a resource to a resource fork</B><P>
<PRE>
PROCEDURE MySaveWindowPosition (myWindow: WindowPtr;
                                myResFileRefNum: Integer);
VAR
   lastWindowState:  MyWindowState;
   myStateHandle:    MyWindowStateHnd;
   curResRefNum:     Integer;
BEGIN
   {set user state provisionally and determine whether window is zoomed}
   lastWindowState.userStateRect := WindowPeek(myWindow)^.contRgn^^.rgnBBox;
   lastWindowState.zoomState := EqualRect(lastWindowState.userStateRect,
                                           MyGetWindowStdState(myWindow));
   {if window is in standard state, then set the window's user state from }
   { the userStateRect field in the state data record}
   IF lastWindowState.zoomState THEN      {window was in standard state}
      lastWindowState.userStateRect := MyGetWindowUserState(myWindow);
   curResRefNum := CurResFile;   {save the refNum of current resource file}
   UseResFile(myResFileRefNum);  {set the current resource file}
   myStateHandle := MyWindowStateHnd(Get1Resource(rWinState,
                                                   kLastWinStateID));
   IF myStateHandle &lt;&gt; NIL THEN        {a state data resource already exists}
   BEGIN                               {update it}
      myStateHandle^^ := lastWindowState;
      ChangedResource(Handle(myStateHandle));
      IF ResError &lt;&gt; noErr THEN
         DoError;
   END
   ELSE                                {no state data has yet been saved}
   BEGIN                               {add state data resource}
      myStateHandle := MyWindowStateHnd(NewHandle(SizeOf(MyWindowState)));
      IF myStateHandle &lt;&gt; NIL THEN
      BEGIN
         myStateHandle^^ := lastWindowState;
         AddResource(Handle(myStateHandle), rWinState, kLastWinStateID,
                     'last window state');
      END;
   END;


   IF myStateHandle &lt;&gt; NIL THEN
   BEGIN
      UpdateResFile(myResFileRefNum);
      ReleaseResource(Handle(myStateHandle));
   END;
   UseResFile(curResRefNum);
END;
</PRE>
 The <CODE>MySaveWindowPosition</CODE> procedure first sets the <CODE>userStateRect</CODE> field of the window state record to the bounds of the current content region of the window. It also sets the <CODE>zoomState</CODE> field of the record to a Boolean value that indicates whether the window is currently in the user state or standard state. If the window is in the standard state, the procedure sets the <CODE>userStateRect</CODE> field of the window state record to the user state of the window. (SurfWriter always saves the user state and the last state of the window. When it opens a document, it sets the user state to its previous state, verifies that this position is still valid, then calculates the window's standard state.)<P>
 The <CODE>MySaveWindowPosition</CODE> procedure then saves the file reference number of the current resource file and sets the current resource file to the document displayed in <BR>the current window. The procedure then uses the <CODE>Get1Resource</CODE> function to determine whether the resource file of the document already contains a window state resource. If so, the procedure changes the resource data, then calls <CODE>ChangedResource</CODE> to set the <CODE>resChanged</CODE> attribute of the resource's entry of the resource map in memory. If the resource doesn't yet exist, the procedure simply adds the new resource using the <CODE>AddResource</CODE> procedure. <P>
 Note that when a Resource Manager routine returns a handle to a resource, it returns the resource using the <CODE>Handle</CODE> data type. You usually define a data type (such as <CODE>MyWindowState</CODE>) to access the resource's data. If you also define a handle to your defined data type (such as <CODE>MyWindowStateHnd</CODE>), you need to coerce the returned handle to the appropriate type, as shown in this line from <A HREF=#MARKER-9-180>Listing 1-11</A>: <A NAME=MARKER-9-134></A><P>
<PRE>
myStateHandle := MyWindowStateHnd(Get1Resource(rWinState, kLastWinStateID));
</PRE>
 If you use this method, you also need to coerce your defined handle back to a handle of type <CODE>Handle</CODE> when you use other Resource Manager routines, as shown in this line from <A HREF=#MARKER-9-180>Listing 1-11</A>:<P>
<PRE>
AddResource(Handle(myStateHandle), rWinState, kLastWinStateID,
            'last window state');
</PRE>
 After <CODE>MySaveWindowPosition</CODE> changes or adds the resource (affecting only the resource map and resource data in memory), the <CODE>MySaveWindowPosition</CODE> procedure makes the change permanent by calling <CODE>UpdateResFile</CODE> and specifying the file reference number of the resource fork to update on disk. The <CODE>UpdateResFile</CODE> procedure writes the entire resource map in memory to disk and updates the resource data of any resource whose <CODE>resChanged</CODE> attribute is set in the resource map in memory. (If you want to update only the resource that was just changed or added, you can use <CODE>WriteResource</CODE> instead of <CODE>UpdateResFile</CODE>.)<P>
<DL>
<DT><B>Note</B>
<DD><A HREF=#MARKER-9-180>Listing 1-11</A> assumes the window state resource is not purgeable. If it were, <CODE>MySaveWindowPosition</CODE> would need to call <CODE>HGetState</CODE> and <CODE>HNoPurge</CODE> before changing the resource.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 When done with the resource, <CODE>MySaveWindowPosition</CODE> uses <CODE>ReleaseResource</CODE>, which releases the memory allocated to the resource's data (and at the same time sets the master pointer of the resource's handle in the resource map in memory to <CODE>NIL</CODE>). Then MySaveWindowPosition restores the current resource file to its previous setting. <A NAME=MARKER-2-182></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MoreToolbox-21.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-23.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MoreToolbox-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>   
