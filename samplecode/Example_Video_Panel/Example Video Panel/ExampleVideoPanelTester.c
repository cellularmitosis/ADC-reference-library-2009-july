/*	File:		ExampleVideoPanelTester.c	Contains:	Example video panel component tester routines.	Written by:	Gary Woodcock	Copyright:	© 1992 by Apple Computer, Inc., all rights reserved.	Change History (most recent first):*///-----------------------------------------------------------------------// Includes#include "ExampleVideoPanelPrivate.h"#include <Menus.h>#include <Windows.h>#include <QuickDraw.h>#include <OSEvents.h>#include <Resources.h>#include <Desk.h>#include <Fonts.h>#include <ToolUtils.h>#ifndef THINK_C	#include <Packages.h>#endif THINK_C// Make sure the debug flag in this file is set appropriately#include "DebugFlags.h"	//-----------------------------------------------------------------------// Constants// Menu barenum{	kMenuBarID = 128};// Menusenum{	kAppleID = 128,	kFileID,	kEditID};// Apple menu itemsenum{	kAboutItem = 1};// File menu itemsenum{	kVideoSettings = 1,	kQuitItem = 3};// Edit menu itemsenum{	kUndoItem = 1,	kCutItem = 3,	kCopyItem,	kPasteItem,	kClearItem};enum{	kAboutDialogID = 128};// Common DITL itemsenum{	kAboutOKButton = 1,	kAboutOKButtonOutline};//-----------------------------------------------------------------------// GlobalsMenuHandle			gAppleMenu;MenuHandle			gFileMenu;MenuHandle			gEditMenu;EventRecord			gTheEvent;Component			gExampleVideoPanelComponentID;GrafPtr				gSavedPort;Boolean				gQuitFlag;SeqGrabComponent	gSeqGrabber;SGChannel			gVideoChannel;WindowPtr			gMonitor;//-----------------------------------------------------------------------// Prototypesstatic voidDoInit (void);static voidDoMenuSetup (void);static voidHandleEvent (void);static voidHandleMouseDown	(void);static voidAdjustMenus (void);static voidEnable (Handle menu, short item, Boolean ok);static voidHandleMenu (long menu);static voidDoAboutDialog (void);static voidDoQuit (void);pascal voidTesterDrawProc (DialogPtr theDialog, short theItemNum);extern voidRegisterExampleVideoPanel (void);//-----------------------------------------------------------------------main (void){	// Init	DoInit();	DoMenuSetup();		// Eat events until done	do	{		HandleEvent();	}	while (!gQuitFlag);		// Take off, eh?	ExitToShell();}//-----------------------------------------------------------------------static voidDoInit (void){	ComponentDescription	theDesc;	ComponentResult			result = noErr;	Component				sgCompID = 0L;		// Set up quit flag	gQuitFlag = false;		// MacMantraª	MaxApplZone();	InitGraf (&qd.thePort);	InitFonts();	FlushEvents (everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs (0L);	InitCursor();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();		// Register example video panel component	#ifdef DEBUG_IT		RegisterExampleVideoPanel();	#endif 		// Find the example video panel component  	theDesc.componentType = SeqGrabPanelType;  	theDesc.componentSubType = 'vide';  	theDesc.componentManufacturer = 'xmpl';  	theDesc.componentFlags = 0L;  	theDesc.componentFlagsMask = 0L;	gExampleVideoPanelComponentID = FindNextComponent (nil, &theDesc);		// Find and open a sequence grabber	theDesc.componentType = SeqGrabComponentType;	theDesc.componentSubType = 0L;	theDesc.componentManufacturer = 'appl';	theDesc.componentFlags = 0L;	theDesc.componentFlagsMask = 0L;		sgCompID = FindNextComponent (nil, &theDesc);	if (sgCompID != 0L)	{		gSeqGrabber = OpenComponent (sgCompID);	}		// If we got a sequence grabber, set it up	if (gSeqGrabber != 0L)	{		Rect	boundsRect = {60, 20, 180, 180};				// Hope you do better error checking than me!		gMonitor = NewCWindow (nil, &boundsRect, "\pMonitor", true, movableDBoxProc,			(WindowPtr) -1L, false, 0L);		if (gMonitor != nil)		{			result = SGInitialize (gSeqGrabber);			if (result == noErr)			{				result = SGSetGWorld (gSeqGrabber, (CGrafPtr) gMonitor, nil);				if (result == noErr)				{					result = SGNewChannel (gSeqGrabber, VideoMediaType, &gVideoChannel);					if ((gVideoChannel != nil) && (result == noErr))					{						result = SGSetChannelUsage (gVideoChannel, seqGrabPreview);						boundsRect = gMonitor->portRect;						result = SGSetChannelBounds (gVideoChannel, &boundsRect);					}					result = SGPrepare (gSeqGrabber, true, false);					result = SGStartPreview (gSeqGrabber);				}			}		}		else		{			DoQuit();		}	}}//-----------------------------------------------------------------------static voidDoMenuSetup (void){		Handle	theMenuBar = GetNewMBar (kMenuBarID);		// Set up our menus	SetMenuBar (theMenuBar);	gAppleMenu = GetMHandle (kAppleID);	gFileMenu = GetMHandle (kFileID);	gEditMenu = GetMHandle (kEditID);	AddResMenu (gAppleMenu, 'DRVR');	DrawMenuBar();}//-----------------------------------------------------------------------static voidHandleEvent (void){	ComponentResult	result = noErr;	// Do system stuff	HiliteMenu (0);	SystemTask();		// Give some time to the sequence grabber	if (gSeqGrabber != 0L)		result = SGIdle (gSeqGrabber);		// Suck an event	if (WaitNextEvent (everyEvent, &gTheEvent, 0, 0))	{		// What was it?		switch (gTheEvent.what)		{			case mouseDown:			{				HandleMouseDown();				break;			}			case keyDown:			case autoKey:			{				char	theChar = gTheEvent.message & charCodeMask;				long	theMenu = MenuKey (theChar);				HandleMenu (theMenu);								break;			}			default:	// We don't really care about any other events			{				break;			}		}	}}//-----------------------------------------------------------------------static voidHandleMouseDown (void){		WindowPtr	theWindow;	short		windowCode = FindWindow (gTheEvent.where, &theWindow);		// Where was the mouse down?    switch (windowCode)	{		case inSysWindow:		{ 			SystemClick (&gTheEvent, theWindow);		    break;	    }		case inMenuBar:		{			AdjustMenus();			HandleMenu (0L);			break;		}		case inDrag:		{			// Was it the monitor?			if (theWindow == gMonitor)			{				Rect			limitRect;				RgnHandle		grayRgn = GetGrayRgn();				ComponentResult	result = noErr;								// Pause the sequence grabber				result = SGPause (gSeqGrabber, true);								// Find bounds				if (grayRgn != nil)				{					limitRect = (*grayRgn)->rgnBBox;				}				else				{					limitRect = qd.screenBits.bounds;				}								// Drag it				DragWindow (theWindow, gTheEvent.where, &limitRect);								// Start up the sequence grabber				result = SGPause (gSeqGrabber, false);			}			break;		}	    case inGoAway:	    default:	    {	    	break;	    }	}}//-----------------------------------------------------------------------static voidAdjustMenus (void){	register WindowPeek		wp = nil;	short					kind = 0;	Boolean					DA = false;	ComponentResult			result = noErr;		// What kind of window is frontmost?	wp = (WindowPeek) FrontWindow();	kind = wp ? wp->windowKind : 0;	DA = kind < 0;		// Set our menu item states appropriately		// Apple menu	Enable ((Handle) gAppleMenu, kAboutItem, true);			// File menu	Enable ((Handle) gFileMenu, kVideoSettings, true);	Enable ((Handle) gFileMenu, kQuitItem, true);	// Edit menu	Enable ((Handle) gEditMenu, 1, DA);	Enable ((Handle) gEditMenu, 3, DA);	Enable ((Handle) gEditMenu, 4, DA);	Enable ((Handle) gEditMenu, 5, DA);	Enable ((Handle) gEditMenu, 6, DA);		DrawMenuBar();}//-----------------------------------------------------------------------static voidEnable (Handle menu, short item, Boolean ok){	// Utility routine to enable and disable menu items	if (ok)	{		EnableItem ((MenuHandle) menu, item);	}	else	{		DisableItem ((MenuHandle) menu, item);	}}//-----------------------------------------------------------------------static voidHandleMenu (long theMenu){		long			mSelect;	short			menuID;	short			menuItem;	ComponentResult	result = noErr;		Str255			menuItemStr;		// Did we get a menu?	if (theMenu == 0L)	{		// Nope, get it from menu select		mSelect = MenuSelect (gTheEvent.where);	}	else	{		// Yep, use it		mSelect = theMenu;	}		// Decode it	menuID = HiWord (mSelect);	menuItem = LoWord (mSelect);		// Which menu is it?	switch (menuID)	{		case kAppleID:		{			if (menuItem == kAboutItem)			{				DoAboutDialog();			}			else	// It's a DA			{				Str255	name;								// Open the DA				GetPort (&gSavedPort);				GetItem (gAppleMenu, menuItem, name);				OpenDeskAcc (name);				SetPort (gSavedPort);			}			break;		}		case kFileID:		{			ComponentResult	result = noErr;						switch (menuItem)			{				case kVideoSettings:				{					if (gSeqGrabber != 0L)					{						// Do the dialog thang						result = SGSettingsDialog (gSeqGrabber, gVideoChannel, 0, 							nil, 0L, nil, 0L);					}					break;				}				case kQuitItem:				{					DoQuit();					break;				}			}			break;		}		case kEditID:		{			if (!SystemEdit (menuItem - 1))			{				// We don't really do anything here - feel free to implement 				// something yourself if you want				SysBeep(5);			}			break;		}		default:		{			break;		}	}}//-----------------------------------------------------------------------static voidDoAboutDialog (void){	short		itemHit;	short		itemType;	Handle		itemHandle;	Rect		itemRect;	DialogPtr	aboutDialog = GetNewDialog (kAboutDialogID, nil, (WindowPtr)-1L);	// Do the boring about dialog	GetDItem (aboutDialog, kAboutOKButtonOutline, &itemType, &itemHandle, &itemRect);	SetDItem (aboutDialog, kAboutOKButtonOutline, itemType, 		(Handle) TesterDrawProc, &itemRect);	ShowWindow (aboutDialog);	do	{		ModalDialog (nil, &itemHit);	}	while (itemHit != kAboutOKButton);	DisposDialog (aboutDialog);}//-----------------------------------------------------------------------pascal voidTesterDrawProc (DialogPtr theDialog, short theItemNum){	PenState	thePenState;	OSErr		result = noErr;	Rect		itemRect;	Handle		itemHandle;	short		itemType;		// Set up the pen	GetPenState (&thePenState);		GetDItem (theDialog, theItemNum, &itemType, &itemHandle, &itemRect);		// What item do we need to draw?	switch (theItemNum)	{		case kAboutOKButtonOutline:			PenNormal();			PenMode (patCopy);			PenSize (3, 3);			InsetRect (&itemRect, -4, -4);			FrameRoundRect (&itemRect, 16, 16);			break;		default:			break;	}		// Restore the pen	SetPenState (&thePenState);}//-----------------------------------------------------------------------static voidDoQuit (void){	ComponentResult	result = noErr;		// Clean up	if (gSeqGrabber != 0L)	{		result = CloseComponent (gSeqGrabber);		gSeqGrabber = 0L;	}		if (gMonitor != nil)	{		DisposeWindow (gMonitor);	}		// Set quit flag	gQuitFlag = true;}//-----------------------------------------------------------------------