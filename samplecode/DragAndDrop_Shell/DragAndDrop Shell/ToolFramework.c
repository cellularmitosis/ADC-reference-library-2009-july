/*	File:		ToolFramework.c	Contains:	Simple AE framework for QuickTime related tools.	Written by: 		Copyright:	Copyright © 1995-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/28/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				*/#include <Fonts.h>// INCLUDES#include "ToolFramework.h"#include "DTSQTUtilities.h"#include "TestFunction.h"// GLOBALS AND CONSTANTSBoolean gOneShot = true;			// Will we trigger this application just once, or is it OK to keep the app open (need 												// a later quit AE message then.Boolean gDone = false;unsigned long gWNEsleep = 0;		Boolean gHasAppleEvents = false;// ______________________________________________________________________// MAINvoid main(void){		OSErr anErr;			InitMacEnvironment(10L);			if (!InitializeAppleEvents())		ExitToShell();			if( !QTUIsQuickTimeInstalled() )		ExitToShell();#if powerc		if( !QTUIsQuickTimeCFMInstalled() )		ExitToShell();								#endif 	anErr = EnterMovies(); DebugAssert(anErr == noErr);	if(anErr != noErr)		ExitToShell();	MainEventLoop();}// ______________________________________________________________________pascal void InitMacEnvironment(long nMasters){	long	i;	MaxApplZone();		for(i = 0; i <nMasters; i++)		MoreMasters();		InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	FlushEvents(everyEvent, 0);	TEInit();	InitCursor();	InitDialogs(NULL);}// ______________________________________________________________________pascal Boolean InitializeAppleEvents(void){	OSErr 	anErr;	long		aVersion;		anErr = Gestalt(gestaltAppleEventsAttr, &aVersion); DebugAssert(anErr == noErr);	if(anErr != noErr)		return false;		// Apple Event Manager is not present on the system.			if( !(aVersion & (1L << gestaltAppleEventsPresent)))		return false;		// The current configuration does not support Apple Events.			// Continue installing our core event handlers.	gHasAppleEvents = true;	anErr = AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, 													NewAEEventHandlerProc(AEOpenHandler), 0, false);	DebugAssert(anErr == noErr);	if(anErr)		return false;	anErr = AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, 													NewAEEventHandlerProc(AEOpenDocHandler), 0, false);	DebugAssert(anErr == noErr);	if(anErr)		return false;	anErr = AEInstallEventHandler(kCoreEventClass, kAEQuitApplication,													 NewAEEventHandlerProc(AEQuitHandler), 0, false);	DebugAssert(anErr == noErr);	if(anErr)		return false;	anErr = AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments, 													NewAEEventHandlerProc(AEPrintHandler), 0, false);	DebugAssert(anErr == noErr);	if(anErr)		return false;				return true;}// ______________________________________________________________________pascal void MainEventLoop(void){	EventRecord anEvent;		while(!gDone)	{		SystemTask();		WaitNextEvent(everyEvent, &anEvent, gWNEsleep, NULL);				switch(anEvent.what)		{		// We are only interested in high level events.			case kHighLevelEvent:				if(gHasAppleEvents)					AEProcessAppleEvent(&anEvent);					break;						default:				DebugAssert("we should not get any events here");				break;		}	}}// ______________________________________________________________________// THE AE HANDLERS// ______________________________________________________________________pascal OSErr AEOpenHandler(AppleEvent *theMessage, AppleEvent *theReply, long refCon){	#pragma unused(theMessage,theReply,refCon)// We are calling a stub function that supposedly will handle the open case (usually creating a new entity)// Default we do nothing.	return errAEEventNotHandled;}// ______________________________________________________________________pascal OSErr AEOpenDocHandler(AppleEvent *theMessage, AppleEvent *theReply, long refCon){	#pragma unused(theReply,refCon)// Parse the incoming entries (could be more than one, and call a specific function for each incoming entry.	OSErr 			anErr;	AEDescList	aDocumentList;	AEKeyword	aKeyword;	DescType		aTypeCode;	Size				actualSize;	long				nDocuments, index;	FSSpec			anFSSpec;		anErr = AEGetParamDesc(theMessage, keyDirectObject, typeAEList, &aDocumentList); DebugAssert(anErr == noErr);	if(anErr != noErr) return anErr;		anErr = CheckForRequiredAEParams(theMessage); DebugAssert(anErr == noErr);	if(anErr != noErr)	{		anErr = AEDisposeDesc(&aDocumentList); DebugAssert(anErr == noErr);		 return anErr;	}	anErr = AECountItems(&aDocumentList, &nDocuments); DebugAssert(anErr == noErr);	if(anErr != noErr) 	{		anErr = AEDisposeDesc(&aDocumentList); DebugAssert(anErr == noErr);		return anErr;	}		for(index = 1; index <= nDocuments; index++)	{		anErr = AEGetNthPtr(&aDocumentList, index, typeFSS, &aKeyword, &aTypeCode,(Ptr)&anFSSpec,											sizeof(FSSpec), &actualSize); DebugAssert(anErr == noErr);		if(anErr != noErr)			return anErr;				// @@@ IF YOU NEED TO DO ANYTHING PER EACH FILE PASSED, DO IT HERE.		anErr = TestFunction(&anFSSpec); DebugAssert(anErr == noErr);		if(anErr != noErr)			return anErr;	}		if(gOneShot)		gDone = true;		anErr = AEDisposeDesc(&aDocumentList); DebugAssert(anErr == noErr);		return noErr;}// ______________________________________________________________________pascal OSErr AEPrintHandler(AppleEvent *theMessage, AppleEvent *theReply, long refCon){	#pragma unused(theMessage,theReply,refCon)// We are calling a stub function that supposedly will handle the print case (usually printing a known entity)// Default we do nothing.	return errAEEventNotHandled;}// ______________________________________________________________________pascal OSErr AEQuitHandler(AppleEvent *theMessage, AppleEvent *theReply, long refCon){	#pragma unused(theMessage,theReply,refCon)// If we need to do any cleanup when quit:ing, do it here.	gDone = true;		return noErr;}// ______________________________________________________________________// ADDITIONAL AE FUNCTIONS// ______________________________________________________________________pascal OSErr CheckForRequiredAEParams(AppleEvent *theEvent){	DescType	returnedType;	Size			actualSize;	OSErr		anErr;		anErr = AEGetAttributePtr(theEvent, keyMissedKeywordAttr, typeWildCard, &returnedType, 												NULL, 0, &actualSize); 	if(anErr == errAEDescNotFound)	// all the parameters were there!		return noErr;	else		if(anErr == noErr)						// missed parameters			return errAEParamMissed;		else			return anErr;						// the call to AEGetAttributePtr failed}