<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DisplayVideo - /DisplayVideo.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">DisplayVideo</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxGraphicsImaging-date.html" target="_blank">Carbon > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DisplayVideo</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/DisplayVideo.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/DisplayVideo.c</option>
<option value="listing2.html">/DisplayVideo.h</option></select>
				</p>
				</form>
				<p><strong><a href="DisplayVideo.zip">Download Sample</a></strong> (&#147;DisplayVideo.zip&#148;, 36.4K)<BR>
<strong><a href="DisplayVideo.dmg">Download Sample</a></strong> (&#147;DisplayVideo.dmg&#148;, 97.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    DisplayVideo.c    Description:DisplayVideo will display all info about all video modes supported        by each installed video card with their attached monitor. The purpose        of this code is to provide a sample of how developers can discover the        bit depths and timings of multisync displays.  Author:    EWA  Copyright:   Copyright: &copy; 1995-1999 by Apple Computer, Inc.        all rights reserved.    Disclaimer:  You may incorporate this sample code into your applications without        restriction, though the sample code has been provided &quot;AS IS&quot; and the        responsibility for its operation is 100% yours.  However, what you are        not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;        after having made changes. If you're going to re-distribute the source,        we require that you make it clear in the source that the code was        descended from Apple Sample Code, but that you've made changes.    Change History (most recent first):        6/24/99  Updated for Metrowerks Codewarror Pro 2.1(KG)        1/28/97  Updated source for Metrowerks CodeWarrior 11 Fixed up             formatting and generally made things nicer(EWA)        5/24/95  New today(EWA)*/#include &lt;Dialogs.h&gt;#include &lt;Devices.h&gt;#include &lt;Displays.h&gt;#include &lt;Errors.h&gt;#include &lt;FixMath.h&gt;#include &lt;fp.h&gt;#include &lt;Gestalt.h&gt;#include &lt;Memory.h&gt;#include &lt;Palettes.h&gt;#include &lt;PLStringFuncs.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;ROMDefs.h&gt;#include &lt;Slots.h&gt;#include &lt;StdIO.h&gt;#include &lt;Video.h&gt;#include &lt;TextUtils.h&gt;#include &lt;Strings.h&gt;#include &lt;DriverServices.h&gt;#include &lt;stdlib.h&gt;//--------------------------------------------------------------//// Internal defines, structs, typedefs, and routine declarations////--------------------------------------------------------------struct DepthInfo {  VDSwitchInfoRec      depthSwitchInfo;      // This is the switch mode to choose this timing/depth  VPBlock          depthVPBlock;        // VPBlock (including size, depth and format)};typedef struct DepthInfo DepthInfo;struct ListIteratorDataRec {  unsigned long      displayModeFlags;      //   VDSwitchInfoRec      displayModeSwitchInfo;    //  VDResolutionInfoRec    displayModeResolutionInfo;  //  VDTimingInfoRec      displayModeTimingInfo;    // Contains timing flags and such  unsigned long      depthBlockCount;      // How many depths available for a particular timing  DepthInfo        *depthBlocks;        // Array of DepthInfo  Str255          displayModeName;      // name of the timing mode};typedef struct ListIteratorDataRec ListIteratorDataRec;void PrintCurrentVideoSetting (GDHandle walkDevice);void DisplayVideoSettings (void);void PrintAvailableVideoSettingsDM1 (GDHandle walkDevice);void PrintAvailableVideoSettingsDM2 (GDHandle walkDevice,                DMDisplayModeListIteratorUPP myModeIteratorProc,                DMListIndexType theDisplayModeCount,                DMListType *theDisplayModeList);pascal void ModeListIterator (  void *userData,                DMListIndexType itemIndex,                DMDisplayModeListEntryPtr displaymodeInfo);// routine implementationsvoid main(void){  DisplayVideoSettings ();}//--------------------------------------------------------------//// Implementation of sample code////--------------------------------------------------------------void PrintCurrentVideoSetting (GDHandle walkDevice){  unsigned long    displayMgrVersion;  OSErr        error = paramErr;  CntrlParam      pBlock;  VDSwitchInfoRec    switchInfo;  AuxDCEHandle    theDCE;  VDSwitchInfoRec    videoMode;      Gestalt(gestaltDisplayMgrVers, (long*)&amp;displayMgrVersion);  if (displayMgrVersion &gt;= 0x00020000)  {  // get the info the DM 2.0 way    error = DMGetDisplayMode(walkDevice, &amp;switchInfo);    if (noErr == error)    {      printf (&quot;Current Settings DM2 - displayMode: %d, depthMode: %d\n&quot;, switchInfo.csData, switchInfo.csMode);    }    return;  }  else  {  // get the info the DM 1.0 way    videoMode.csMode = -1;    // init to bogus value    videoMode.csData = -1;    // init to bogus value          pBlock.ioNamePtr = nil;    pBlock.ioCRefNum = (*(walkDevice))-&gt;gdRefNum;    pBlock.csCode = cscGetCurMode;    *(Ptr *)&amp;pBlock.csParam[0] = (Ptr)&amp;videoMode;          error = PBStatusSync((ParmBlkPtr )&amp;pBlock);  // ask the driver first....since we trust it the most          if ( noErr == error &amp;&amp; ((-1 == videoMode.csMode) || (-1 == videoMode.csData)) )      error = statusErr;        if (noErr != error)  // if the driver has no clue fill it videoMode by hand as a last resort    {        theDCE = (AuxDCEHandle)GetDCtlEntry((*(walkDevice))-&gt;gdRefNum);            if( theDCE )      {        videoMode.csData = (unsigned char)(*theDCE)-&gt;dCtlSlotId;         videoMode.csMode = (*(walkDevice))-&gt;gdMode;        error = noErr;      }    }    if (noErr == error)    {      printf (&quot;Current Settings DM1 - displayMode: %d, depthMode: %d\n&quot;, videoMode.csData, videoMode.csMode);    }    return;  }}void DisplayVideoSettings (void){  Boolean              displayMgrPresent;  short              iCount = 0;          // just a counter of GDevices we have seen  DMDisplayModeListIteratorUPP  myModeIteratorProc = nil;  // for DM2.0 searches  SpBlock              spBlock;  Boolean              suppliedGDevice;    DisplayIDType          theDisplayID;        // for DM2.0 searches  DMListIndexType          theDisplayModeCount;    // for DM2.0 searches  DMListType            theDisplayModeList;      // for DM2.0 searches  long              value = 0;  GDHandle            walkDevice = nil;      // for everybody  Gestalt(gestaltDisplayMgrAttr,&amp;value);  displayMgrPresent=value&amp;(1&lt;&lt;gestaltDisplayMgrPresent);  displayMgrPresent=displayMgrPresent &amp;&amp; (SVersion(&amp;spBlock)==noErr);  // need slot manager  if (displayMgrPresent)                        // and Display Manager  {      walkDevice = DMGetFirstScreenDevice (dmOnlyActiveDisplays);      // for everybody    suppliedGDevice = false;        myModeIteratorProc = NewDMDisplayModeListIteratorProc(ModeListIterator);  // for DM2.0 searches      // Note that we are hosed if somebody changes the gdevice list behind our backs while we are iterating....    // ...now do the loop if we can start    if( walkDevice &amp;&amp; myModeIteratorProc) do // start the search    {      iCount++;    // GDevice we are looking at (just a counter)      printf(&quot;=================================================\n&quot;);      printf(&quot;GDevice #%d (0x%X) at location (%d,%d).\n&quot;,iCount, *walkDevice, (long )(*walkDevice)-&gt;gdRect.left, (long )(*walkDevice)-&gt;gdRect.top);      printf(&quot;=================================================\n\n&quot;);      PrintCurrentVideoSetting (walkDevice);            if( noErr == DMGetDisplayIDByGDevice( walkDevice, &amp;theDisplayID, false ) )  // DM1.0 does not need this, but it fits in the loop      {        theDisplayModeCount = 0;  // for DM2.0 searches        if (noErr == DMNewDisplayModeList(theDisplayID, 0, 0, &amp;theDisplayModeCount, &amp;theDisplayModeList) )        {          // search NuBus &amp; PCI the new kool way through Display Manager 2.0        //  printf(&quot;\nAvailable Video Settings DM2.0 way\n&quot;);          PrintAvailableVideoSettingsDM2 (walkDevice, myModeIteratorProc, theDisplayModeCount, &amp;theDisplayModeList);          DMDisposeList(theDisplayModeList);  // now toss the lists for this gdevice and go on to the next one        }        else        {          // search NuBus only the old disgusting way through the slot manager          printf(&quot;\nAvailable Video Settings DM1.0 way\n&quot;);          PrintAvailableVideoSettingsDM1 (walkDevice);        }      }      printf(&quot;\n\n\n&quot;);    } while ( !suppliedGDevice &amp;&amp; nil != (walkDevice = DMGetNextScreenDevice ( walkDevice, dmOnlyActiveDisplays )) );  // go until no more gdevices    if( myModeIteratorProc )      DisposeRoutineDescriptor(myModeIteratorProc);    return;  }}void PrintAvailableVideoSettingsDM1 (GDHandle walkDevice){  AuxDCEHandle myAuxDCEHandle;  unsigned long  depthMode;  unsigned long  displayMode;  OSErr      error;  OSErr      errorEndOfTimings;  short      height;  short      jCount = 0;  Boolean      modeOk;  SpBlock      spAuxBlock;  SpBlock      spBlock;  unsigned long  switchFlags;  VPBlock      *vpData;  short      width;  myAuxDCEHandle = (AuxDCEHandle) GetDCtlEntry((**walkDevice).gdRefNum);    spBlock.spSlot = (**myAuxDCEHandle).dCtlSlot;  spBlock.spID = (**myAuxDCEHandle).dCtlSlotId;  spBlock.spExtDev = (**myAuxDCEHandle).dCtlExtDev;  spBlock.spHwDev = 0;                // we are going to get this pup  spBlock.spParamData = 1&lt;&lt;foneslot;          // this slot, enabled, and it better be here.  spBlock.spTBMask = 3;                // don't have constants for this yet  errorEndOfTimings = SGetSRsrc(&amp;spBlock);      // get the spDrvrHW so we know the ID of this puppy. This is important                            // since some video cards support more than one display, and the spDrvrHW                            // ID can, and will, be used to differentiate them.    if ( noErr == errorEndOfTimings )  {    // reinit the param block for the SGetTypeSRsrc loop, keep the spDrvrHW we just got    spBlock.spID = 0;                // start at zero,     spBlock.spTBMask = 2;              // 0b0010 - ignore DrvrSW - why ignore the SW side? Is it not important for video?    spBlock.spParamData = (1&lt;&lt;fall) + (1&lt;&lt;foneslot) + (1&lt;&lt;fnext);  // 0b0111 - this slot, enabled or disabled, so we even get 640x399 on Blackbird    spBlock.spCategory=catDisplay;    spBlock.spCType=typeVideo;    errorEndOfTimings = SGetTypeSRsrc(&amp;spBlock);  // but only on 7.0 systems, not a problem since we require DM1.0        // now, loop through all the timings for this GDevice    if ( noErr == errorEndOfTimings ) do    {      // now, loop through all possible depth modes for this timing mode      displayMode = (unsigned char)spBlock.spID;  // &quot;timing mode, ie:resource ref number&quot;      for (jCount = firstVidMode; jCount&lt;= sixthVidMode; jCount++)      {        depthMode = jCount;    // vid mode        error = DMCheckDisplayMode(walkDevice,displayMode,depthMode,&amp;switchFlags,0,&amp;modeOk);          // only if the mode okay        if (noErr == error &amp;&amp; modeOk)        {          // have a good displayMode/depthMode combo - now lets look inside          spAuxBlock = spBlock;        // don't ruin the iteration spBlock!!          spAuxBlock.spID = depthMode;    // vid mode          error=SFindStruct(&amp;spAuxBlock);    // get back a new spsPointer          if (noErr == error)          // keep going if no error\xC9          {            spAuxBlock.spID = 0x01;      // mVidParams request            error=SGetBlock (&amp;spAuxBlock);  // use the new spPointer and get back...a NewPtr'ed spResult            if (noErr == error)        // \xC9keep going if no error\xC9            {                // We have data! lets have a look              vpData = (VPBlock*)spAuxBlock.spResult;              height = vpData-&gt;vpBounds.bottom;  // left and top are usually zero              width = vpData-&gt;vpBounds.right;                            // print screen data              printf(&quot;\nTiming Mode: %d\n&quot;, displayMode);              printf(&quot;Depth Mode: %d, Depth: %d, Resolution: %dH x %dV\n&quot;,                depthMode,                vpData-&gt;vpPixelSize,                vpData-&gt;vpBounds.right,                vpData-&gt;vpBounds.bottom);              printf(&quot;Components per Pixel: %d, bits per Component: %d\n&quot;,                vpData-&gt;vpCmpCount,                vpData-&gt;vpCmpSize);              printf(&quot;Switch flags:\n&quot;);              if (switchFlags &amp; 1&lt;&lt;kNoSwitchConfirmBit)                printf(&quot;      Confirmation not required,\n&quot;);              else                printf(&quot;      Confirmation required,\n&quot;);              if (switchFlags &amp; 1&lt;&lt;kDepthNotAvailableBit)                printf(&quot;      Current depth not available in this mode,\n&quot;);              else                printf(&quot;      Current depth available in this mode,\n&quot;);              if (switchFlags &amp; 1&lt;&lt;kShowModeBit)                printf(&quot;      Always shown,\n&quot;);              else                printf(&quot;      Not always shown,\n&quot;);              if (switchFlags &amp; 1&lt;&lt;kModeNotResizeBit)                printf(&quot;      Not resizeable,\n&quot;);              else                printf(&quot;      Resizeable\n&quot;);              if (spAuxBlock.spResult) DisposePtr ((Ptr)spAuxBlock.spResult);  // toss this puppy when done            }          }        }      }      // go around again, looking for timing modes for this GDevice      spBlock.spTBMask = 2;    // ignore DrvrSW      spBlock.spParamData =  (1&lt;&lt;fall) + (1&lt;&lt;foneslot) + (1&lt;&lt;fnext);  // next resource, this slot, whether enabled or disabled      errorEndOfTimings = SGetTypeSRsrc(&amp;spBlock);  // and get the next timing mode    } while ( noErr == errorEndOfTimings );  // until the end of this GDevice  }}pascal void ModeListIterator(void *userData, DMListIndexType, DMDisplayModeListEntryPtr displaymodeInfo){  unsigned long      depthCount;  short          iCount;  ListIteratorDataRec    *myIterateData    = (ListIteratorDataRec*) userData;  DepthInfo        *myDepthInfo;  // printf (&quot;\n now in ModeListIterator\n&quot;);  // set display data in a round about way  // Set the basics  myIterateData-&gt;displayModeFlags        = displaymodeInfo-&gt;displayModeFlags;    // Info on this particular display mode  myIterateData-&gt;displayModeSwitchInfo    = *displaymodeInfo-&gt;displayModeSwitchInfo;  // not needed - depth info has this per depth  myIterateData-&gt;displayModeResolutionInfo  = *displaymodeInfo-&gt;displayModeResolutionInfo;  // refresh rate, pixels/lines at max depth   myIterateData-&gt;displayModeTimingInfo    = *displaymodeInfo-&gt;displayModeTimingInfo;  // to get the flags on timing mode  PStrCopy ((StringPtr)&amp;myIterateData-&gt;displayModeName, (ConstStr255Param)*displaymodeInfo-&gt;displayModeName);  // the name of the mode    // now get the DMDepthInfo into memory we own  depthCount = displaymodeInfo-&gt;displayModeDepthBlockInfo-&gt;depthBlockCount;  myDepthInfo = (DepthInfo*)NewPtrClear(depthCount * sizeof(DepthInfo));  // set the info for the caller  myIterateData-&gt;depthBlockCount = depthCount;  myIterateData-&gt;depthBlocks = myDepthInfo;  // and fill out all the entries  if (depthCount) for (iCount=0; iCount &lt; depthCount; iCount++)  {    myDepthInfo[iCount].depthSwitchInfo =       *displaymodeInfo-&gt;displayModeDepthBlockInfo-&gt;depthVPBlock[iCount].depthSwitchInfo;    myDepthInfo[iCount].depthVPBlock =       *displaymodeInfo-&gt;displayModeDepthBlockInfo-&gt;depthVPBlock[iCount].depthVPBlock;  }}void PrintAvailableVideoSettingsDM2 (GDHandle walkDevice,              DMDisplayModeListIteratorUPP myModeIteratorProc,              DMListIndexType theDisplayModeCount,              DMListType *theDisplayModeList){  short          jCount;  short          kCount;  ListIteratorDataRec    searchData;  double_t        refreshRate;  unsigned long      switchFlags;  Boolean          modeOk;  OSErr          error;  searchData.depthBlocks = nil;  // get the mode lists for this GDevice// printf (&quot;\n about to start DMGetIndexedDisplayModeFromList loop\n&quot;);  for (jCount=0; jCount&lt;theDisplayModeCount; jCount++)    // get info on all the resolution timings  {    DMGetIndexedDisplayModeFromList(*theDisplayModeList, jCount, 0, myModeIteratorProc, &amp;searchData);// printf (&quot;\n just did a DMGetIndexedDisplayModeFromList\n&quot;);        // only if the mode is valid//    if  (searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeValid)    {      // for all the depths for this resolution timing (mode)...      printf(&quot;\nTiming mode: %d (or  0x%X) named &quot;%s&quot;\n&quot;,            searchData.depthBlocks[0].depthSwitchInfo.csData,            searchData.depthBlocks[0].depthSwitchInfo.csData,            P2CStr(searchData.displayModeName));          refreshRate = Fix2X (searchData.displayModeResolutionInfo.csRefreshRate);      refreshRate = round (refreshRate);      if (refreshRate == 0)        printf (&quot;Refresh rate: 0 (not defined in displayModeResolutionInfo.csRefreshRate)\n&quot;);      else        printf (&quot;Refresh rate: %g\n&quot;, refreshRate);            if (searchData.displayModeResolutionInfo.csResolutionFlags &amp; 1&lt;&lt;kResolutionHasMultipleDepthSizes)        printf(&quot;DisplayMode has different H&amp;V per bit depth\n&quot;);      else        printf(&quot;DisplayMode does not have different H&amp;V per bit depth\n&quot;);      {        char    tempArr[6];        ResType*  tempPtr = (ResType* )&amp;tempArr[0];          // Make a convenient ptr to assign the restype        *tempPtr = searchData.displayModeTimingInfo.csTimingFormat;    // contents of string are the resType        tempArr[4] = 0;                          // null temp the string        printf(&quot;Timing format: &quot;%s&quot;. Timing csData %d\n&quot;, tempArr, searchData.displayModeTimingInfo.csTimingData);      }            printf(&quot;Available depths:\n&quot;);      if (searchData.depthBlockCount) for (kCount = 0; kCount &lt; searchData.depthBlockCount; kCount++)      {        // print all the timing information         printf(&quot;  Depth: %d, Depth mode: 0x%X, Resolution: %dH x %dV\n&quot;,          searchData.depthBlocks[kCount].depthVPBlock.vpPixelSize,          searchData.depthBlocks[kCount].depthSwitchInfo.csMode,          searchData.depthBlocks[kCount].depthVPBlock.vpBounds.right,          searchData.depthBlocks[kCount].depthVPBlock.vpBounds.bottom);    //    printf(&quot;Components per Pixel: %d, bits per Component: %d\n&quot;,    //      searchData.depthBlocks[kCount].depthVPBlock.vpCmpCount,    //      searchData.depthBlocks[kCount].depthVPBlock.vpCmpSize);                }            error = DMCheckDisplayMode(walkDevice,            searchData.depthBlocks[0].depthSwitchInfo.csData,            searchData.depthBlocks[0].depthSwitchInfo.csMode,            &amp;switchFlags,            0,            &amp;modeOk);                  if (noErr == error &amp;&amp; modeOk)      {        printf(&quot;Switch flags = 0x%X\n&quot;, switchFlags);        if (switchFlags &amp; 1&lt;&lt;kNoSwitchConfirmBit)          printf(&quot;      Confirmation not required,\n&quot;);        else          printf(&quot;      Confirmation required,\n&quot;);        if (switchFlags &amp; 1&lt;&lt;kDepthNotAvailableBit)          printf(&quot;      Current depth not available in this mode,\n&quot;);        else          printf(&quot;      Current depth available in this mode,\n&quot;);        if (switchFlags &amp; 1&lt;&lt;kShowModeBit)          printf(&quot;      Always shown,\n&quot;);        else          printf(&quot;      Not always shown,\n&quot;);        if (switchFlags &amp; 1&lt;&lt;kModeNotResizeBit)          printf(&quot;      Not resizeable,\n&quot;);        else          printf(&quot;      Resizeable\n&quot;);      }      // timing flags      printf(&quot;Timing flags = 0x%X\n&quot;,searchData.displayModeTimingInfo.csTimingFlags);      if (searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeValid)        printf(&quot;      Valid,\n&quot;,searchData.displayModeTimingInfo.csTimingFlags);      else        printf(&quot;      Invalid,\n&quot;,searchData.displayModeTimingInfo.csTimingFlags);      if (searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeSafe)        printf(&quot;      Safe,\n&quot;);      else        printf(&quot;      Unsafe,\n&quot;);          if (searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeDefault)        printf(&quot;      Default,\n&quot;);      else        printf(&quot;      Not default,\n&quot;);          if (searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeShowNow)        printf(&quot;      Always shown,\n&quot;);      else        printf(&quot;      Not always shown,\n&quot;);      if (searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeNotResize)        printf(&quot;      Not resizeable,\n&quot;);      else        printf(&quot;      Resizeable,\n&quot;);      if (searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeRequiresPan)        printf(&quot;      Requires pan.\n&quot;);      else        printf(&quot;      No pan.\n&quot;);              // mode flags      printf(&quot;Mode flags = 0x%X\n&quot;,searchData.displayModeFlags);      if (searchData.displayModeFlags &amp; 1&lt;&lt;0)        printf(&quot;      Stripped,\n&quot;);      else        printf(&quot;      Not Stripped,\n&quot;);    }    if (searchData.depthBlocks)    {      DisposePtr ((Ptr)searchData.depthBlocks);  // toss for this timing mode of this gdevice      searchData.depthBlocks = nil;        // init it just so we know    }  }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DisplayVideo/listing1.html%3Fid%3DDTS10000435-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DisplayVideo/listing1.html%3Fid%3DDTS10000435-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DisplayVideo/listing1.html%3Fid%3DDTS10000435-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>