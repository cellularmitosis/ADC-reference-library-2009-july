
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Jul 18 01:51:29 PDT 2002 -->
<TITLE>
Java 2 Platform SE v1.3.1: Class  MessageFormat
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/MessageFormat.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Std.&nbsp;Ed. v1.3.1</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/text/Format.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../java/text/NumberFormat.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MessageFormat.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.text</FONT>
<BR>
Class  MessageFormat</H2>
<PRE>
<A HREF="../../java/lang/Object.html">java.lang.Object</A>
  |
  +--<A HREF="../../java/text/Format.html">java.text.Format</A>
        |
        +--<B>java.text.MessageFormat</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../java/lang/Cloneable.html">Cloneable</A>, <A HREF="../../java/io/Serializable.html">Serializable</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>MessageFormat</B><DT>extends <A HREF="../../java/text/Format.html">Format</A></DL>

<P>
<code>MessageFormat</code> provides a means to produce concatenated
 messages in language-neutral way. Use this to construct messages
 displayed for end users.

 <p>
 <code>MessageFormat</code> takes a set of objects, formats them, then
 inserts the formatted strings into the pattern at the appropriate places.

 <p>
 <strong>Note:</strong>
 <code>MessageFormat</code> differs from the other <code>Format</code>
 classes in that you create a <code>MessageFormat</code> object with one
 of its constructors (not with a <code>getInstance</code> style factory
 method). The factory methods aren't necessary because <code>MessageFormat</code>
 doesn't require any complex setup for a given locale. In fact,
 <code>MessageFormat</code> doesn't implement any locale specific behavior
 at all. It just needs to be set up on a sentence by sentence basis.

 <p>
 Here are some examples of usage:
 <blockquote>
 <pre>
 Object[] arguments = {
     new Integer(7),
     new Date(System.currentTimeMillis()),
     "a disturbance in the Force"
 };

 String result = MessageFormat.format(
     "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.",
     arguments);

 <em>output</em>: At 12:30 PM on Jul 3, 2053, there was a disturbance
           in the Force on planet 7.

 </pre>
 </blockquote>
 Typically, the message format will come from resources, and the
 arguments will be dynamically set at runtime.

 <p>
 Example 2:
 <blockquote>
 <pre>
 Object[] testArgs = {new Long(3), "MyDisk"};

 MessageFormat form = new MessageFormat(
     "The disk \"{1}\" contains {0} file(s).");

 System.out.println(form.format(testArgs));

 // output, with different testArgs
 <em>output</em>: The disk "MyDisk" contains 0 file(s).
 <em>output</em>: The disk "MyDisk" contains 1 file(s).
 <em>output</em>: The disk "MyDisk" contains 1,273 file(s).
 </pre>
 </blockquote>

 <p>
 The pattern is of the form:
 <blockquote>
 <pre>
 messageFormatPattern := string ( "{" messageFormatElement "}" string )*

 messageFormatElement := argument { "," elementFormat }

 elementFormat := "time" { "," datetimeStyle }
                | "date" { "," datetimeStyle }
                | "number" { "," numberStyle }
                | "choice" { "," choiceStyle }

 datetimeStyle := "short"
                  | "medium"
                  | "long"
                  | "full"
                  | dateFormatPattern

 numberStyle := "currency"
               | "percent"
               | "integer"
               | numberFormatPattern

 choiceStyle := choiceFormatPattern
 </pre>
 </blockquote>
 If there is no <code>elementFormat</code>,
 then the argument must be a string, which is substituted. If there is
 no <code>dateTimeStyle</code> or <code>numberStyle</code>, then the
 default format is used (for example, <code>NumberFormat.getInstance</code>,
 <code>DateFormat.getTimeInstance</code>, or <code>DateFormat.getInstance</code>).

 <p>
 In strings, single quotes can be used to quote the "{"
 (curly brace) if necessary. A real single quote is represented by ''.
 Inside a <code>messageFormatElement</code>, quotes are <strong>not</strong>
 removed. For example, {1,number,$'#',##} will produce a number format
 with the pound-sign quoted, with a result such as: "$#31,45".

 <p>
 If a pattern is used, then unquoted braces in the pattern, if any, must match:
 that is, "ab {0} de" and "ab '}' de" are ok, but "ab {0'}' de" and "ab } de" are
 not.

 <p>
 The argument is a number from 0 to 9, which corresponds to the
 arguments presented in an array to be formatted.

 <p>
 It is ok to have unused arguments in the array.
 With missing arguments or arguments that are not of the right class for
 the specified format, a <code>ParseException</code> is thrown.
 First, <code>format</code> checks to see if a <code>Format</code> object has been
 specified for the argument with the <code>setFormats</code> method.
 If so, then <code>format</code> uses that <code>Format</code> object to format the
 argument. Otherwise, the argument is formatted based on the object's
 type. If the argument is a <code>Number</code>, then <code>format</code>
 uses <code>NumberFormat.getInstance</code> to format the argument; if the
 argument is a <code>Date</code>, then <code>format</code> uses
 <code>DateFormat.getDateTimeInstance</code> to format the argument.
 Otherwise, it uses the <code>toString</code> method.

 <p>
 For more sophisticated patterns, you can use a <code>ChoiceFormat</code> to get
 output such as:
 <blockquote>
 <pre>
 MessageFormat form = new MessageFormat("The disk \"{1}\" contains {0}.");
 double[] filelimits = {0,1,2};
 String[] filepart = {"no files","one file","{0,number} files"};
 ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
 form.setFormat(1,fileform); // NOT zero, see below

 Object[] testArgs = {new Long(12373), "MyDisk"};

 System.out.println(form.format(testArgs));

 // output, with different testArgs
 output: The disk "MyDisk" contains no files.
 output: The disk "MyDisk" contains one file.
 output: The disk "MyDisk" contains 1,273 files.
 </pre>
 </blockquote>
 You can either do this programmatically, as in the above example,
 or by using a pattern (see
 <A HREF="../../java/text/ChoiceFormat.html"><CODE>ChoiceFormat</CODE></A>
 for more information) as in:
 <blockquote>
 <pre>
 form.applyPattern(
    "There {0,choice,0#are no files|1#is one file|1#are {0,number,integer} files}.");
 </pre>
 </blockquote>
 <p>
 <strong>Note:</strong> As we see above, the string produced
 by a <code>ChoiceFormat</code> in <code>MessageFormat</code> is treated specially;
 occurances of '{' are used to indicated subformats, and cause recursion.
 If you create both a <code>MessageFormat</code> and <code>ChoiceFormat</code>
 programmatically (instead of using the string patterns), then be careful not to
 produce a format that recurses on itself, which will cause an infinite loop.
 <p>
 <strong>Note:</strong> formats are numbered by order of
 variable in the string.
 This is <strong>not</strong> the same as the argument numbering!
 For example: with "abc{2}def{3}ghi{0}...",
 <ul>
 <li>format0 affects the first variable {2}
 <li>format1 affects the second variable {3}
 <li>format2 affects the second variable {0}
 <li>and so on.
 </ul>
 <p>
 When a single argument is parsed more than once in the string, the last match
 will be the final result of the parsing.  For example,
 <pre>
 MessageFormat mf = new MessageFormat("{0,number,#.##}, {0,number,#.#}");
 Object[] objs = {new Double(3.1415)};
 String result = mf.format( objs );
 // result now equals "3.14, 3.1"
 objs = null;
 objs = mf.parse(result, new ParsePosition(0));
 // objs now equals {new Double(3.1)}
 </pre>
 <p>
 Likewise, parsing with a MessageFormat object using patterns containing
 multiple occurances of the same argument would return the last match.  For
 example,
 <pre>
 MessageFormat mf = new MessageFormat("{0}, {0}, {0}");
 String forParsing = "x, y, z";
 Object[] objs = mf.parse(forParsing, new ParsePosition(0));
 // result now equals {new String("z")}
 </pre>
 <p>
 You can use <code>setLocale</code> followed by <code>applyPattern</code>
 (and then possibly <code>setFormat</code>) to re-initialize a
 <code>MessageFormat</code> with a different locale.
<P>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../java/util/Locale.html"><CODE>Locale</CODE></A>, 
<A HREF="../../java/text/Format.html"><CODE>Format</CODE></A>, 
<A HREF="../../java/text/NumberFormat.html"><CODE>NumberFormat</CODE></A>, 
<A HREF="../../java/text/DecimalFormat.html"><CODE>DecimalFormat</CODE></A>, 
<A HREF="../../java/text/ChoiceFormat.html"><CODE>ChoiceFormat</CODE></A>, <A HREF="../../serialized-form.html#java.text.MessageFormat">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#MessageFormat(java.lang.String)">MessageFormat</A></B>(<A HREF="../../java/lang/String.html">String</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs with the specified pattern.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#applyPattern(java.lang.String)">applyPattern</A></B>(<A HREF="../../java/lang/String.html">String</A>&nbsp;newPattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#clone()">clone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overrides Cloneable</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#equals(java.lang.Object)">equals</A></B>(<A HREF="../../java/lang/Object.html">Object</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equality comparision between two message format objects</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/StringBuffer.html">StringBuffer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition)">format</A></B>(<A HREF="../../java/lang/Object.html">Object</A>[]&nbsp;source,
       <A HREF="../../java/lang/StringBuffer.html">StringBuffer</A>&nbsp;result,
       <A HREF="../../java/text/FieldPosition.html">FieldPosition</A>&nbsp;ignore)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns pattern with formatted objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/StringBuffer.html">StringBuffer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)">format</A></B>(<A HREF="../../java/lang/Object.html">Object</A>&nbsp;source,
       <A HREF="../../java/lang/StringBuffer.html">StringBuffer</A>&nbsp;result,
       <A HREF="../../java/text/FieldPosition.html">FieldPosition</A>&nbsp;ignore)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns pattern with formatted objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#format(java.lang.String, java.lang.Object[])">format</A></B>(<A HREF="../../java/lang/String.html">String</A>&nbsp;pattern,
       <A HREF="../../java/lang/Object.html">Object</A>[]&nbsp;arguments)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience routine.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/text/Format.html">Format</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#getFormats()">getFormats</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets formats that were set with setFormats.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/util/Locale.html">Locale</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#getLocale()">getLocale</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the locale.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#hashCode()">hashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generates a hash code for the message format object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html">Object</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#parse(java.lang.String)">parse</A></B>(<A HREF="../../java/lang/String.html">String</A>&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses the string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html">Object</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#parse(java.lang.String, java.text.ParsePosition)">parse</A></B>(<A HREF="../../java/lang/String.html">String</A>&nbsp;source,
      <A HREF="../../java/text/ParsePosition.html">ParsePosition</A>&nbsp;status)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses the string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#parseObject(java.lang.String, java.text.ParsePosition)">parseObject</A></B>(<A HREF="../../java/lang/String.html">String</A>&nbsp;text,
            <A HREF="../../java/text/ParsePosition.html">ParsePosition</A>&nbsp;status)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses the string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#setFormat(int, java.text.Format)">setFormat</A></B>(int&nbsp;variable,
          <A HREF="../../java/text/Format.html">Format</A>&nbsp;newFormat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set a format to be used on a variable in the pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#setFormats(java.text.Format[])">setFormats</A></B>(<A HREF="../../java/text/Format.html">Format</A>[]&nbsp;newFormats)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets formats to use on parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#setLocale(java.util.Locale)">setLocale</A></B>(<A HREF="../../java/util/Locale.html">Locale</A>&nbsp;theLocale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs with the specified pattern and formats for the
 arguments in that pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/MessageFormat.html#toPattern()">toPattern</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the pattern.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.text.Format"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.text.<A HREF="../../java/text/Format.html">Format</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/text/Format.html#format(java.lang.Object)">format</A>, <A HREF="../../java/text/Format.html#parseObject(java.lang.String)">parseObject</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="../../java/lang/Object.html">Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="MessageFormat(java.lang.String)"><!-- --></A><H3>
MessageFormat</H3>
<PRE>
public <B>MessageFormat</B>(<A HREF="../../java/lang/String.html">String</A>&nbsp;pattern)</PRE>
<DL>
<DD>Constructs with the specified pattern.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../../java/text/MessageFormat.html#applyPattern(java.lang.String)"><CODE>applyPattern(java.lang.String)</CODE></A></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="setLocale(java.util.Locale)"><!-- --></A><H3>
setLocale</H3>
<PRE>
public void <B>setLocale</B>(<A HREF="../../java/util/Locale.html">Locale</A>&nbsp;theLocale)</PRE>
<DL>
<DD>Constructs with the specified pattern and formats for the
 arguments in that pattern.</DL>
<HR>

<A NAME="getLocale()"><!-- --></A><H3>
getLocale</H3>
<PRE>
public <A HREF="../../java/util/Locale.html">Locale</A> <B>getLocale</B>()</PRE>
<DL>
<DD>Gets the locale. This locale is used for fetching default number or date
 format information.</DL>
<HR>

<A NAME="applyPattern(java.lang.String)"><!-- --></A><H3>
applyPattern</H3>
<PRE>
public void <B>applyPattern</B>(<A HREF="../../java/lang/String.html">String</A>&nbsp;newPattern)</PRE>
<DL>
<DD>Sets the pattern. See the class description.</DL>
<HR>

<A NAME="toPattern()"><!-- --></A><H3>
toPattern</H3>
<PRE>
public <A HREF="../../java/lang/String.html">String</A> <B>toPattern</B>()</PRE>
<DL>
<DD>Gets the pattern. See the class description.</DL>
<HR>

<A NAME="setFormats(java.text.Format[])"><!-- --></A><H3>
setFormats</H3>
<PRE>
public void <B>setFormats</B>(<A HREF="../../java/text/Format.html">Format</A>[]&nbsp;newFormats)</PRE>
<DL>
<DD>Sets formats to use on parameters.
 See the class description about format numbering.</DL>
<HR>

<A NAME="setFormat(int, java.text.Format)"><!-- --></A><H3>
setFormat</H3>
<PRE>
public void <B>setFormat</B>(int&nbsp;variable,
                      <A HREF="../../java/text/Format.html">Format</A>&nbsp;newFormat)</PRE>
<DL>
<DD>Set a format to be used on a variable in the pattern.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>variable</CODE> - the zero-based number of the variable in the format.
 This is <em>not</em> the argument number. If <code>variable</code>
 is out of range, an <code>ArrayIndexOutOfBoundsException</code> is
 thrown.<DD><CODE>newFormat</CODE> - the format to use for the specified variable</DL>
</DD>
</DL>
<HR>

<A NAME="getFormats()"><!-- --></A><H3>
getFormats</H3>
<PRE>
public <A HREF="../../java/text/Format.html">Format</A>[] <B>getFormats</B>()</PRE>
<DL>
<DD>Gets formats that were set with setFormats.
 See the class description about format numbering.</DL>
<HR>

<A NAME="format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition)"><!-- --></A><H3>
format</H3>
<PRE>
public final <A HREF="../../java/lang/StringBuffer.html">StringBuffer</A> <B>format</B>(<A HREF="../../java/lang/Object.html">Object</A>[]&nbsp;source,
                                 <A HREF="../../java/lang/StringBuffer.html">StringBuffer</A>&nbsp;result,
                                 <A HREF="../../java/text/FieldPosition.html">FieldPosition</A>&nbsp;ignore)</PRE>
<DL>
<DD>Returns pattern with formatted objects.  If source is null, the
 original pattern is returned, if source contains null objects, the
 formatted result will substitute each argument with the string "null".<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - an array of objects to be formatted & substituted.<DD><CODE>result</CODE> - where text is appended.<DD><CODE>ignore</CODE> - no useful status is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="format(java.lang.String, java.lang.Object[])"><!-- --></A><H3>
format</H3>
<PRE>
public static <A HREF="../../java/lang/String.html">String</A> <B>format</B>(<A HREF="../../java/lang/String.html">String</A>&nbsp;pattern,
                            <A HREF="../../java/lang/Object.html">Object</A>[]&nbsp;arguments)</PRE>
<DL>
<DD>Convenience routine.
 Avoids explicit creation of MessageFormat,
 but doesn't allow future optimizations.</DL>
<HR>

<A NAME="format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)"><!-- --></A><H3>
format</H3>
<PRE>
public final <A HREF="../../java/lang/StringBuffer.html">StringBuffer</A> <B>format</B>(<A HREF="../../java/lang/Object.html">Object</A>&nbsp;source,
                                 <A HREF="../../java/lang/StringBuffer.html">StringBuffer</A>&nbsp;result,
                                 <A HREF="../../java/text/FieldPosition.html">FieldPosition</A>&nbsp;ignore)</PRE>
<DL>
<DD>Returns pattern with formatted objects.  If source is null, the
 original pattern is returned, if source contains null objects, the
 formatted result will substitute each argument with the string "null".<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../java/text/Format.html#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)">format</A></CODE> in class <CODE><A HREF="../../java/text/Format.html">Format</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - an array of objects to be formatted & substituted.<DD><CODE>result</CODE> - where text is appended.<DD><CODE>ignore</CODE> - no useful status is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="parse(java.lang.String, java.text.ParsePosition)"><!-- --></A><H3>
parse</H3>
<PRE>
public <A HREF="../../java/lang/Object.html">Object</A>[] <B>parse</B>(<A HREF="../../java/lang/String.html">String</A>&nbsp;source,
                      <A HREF="../../java/text/ParsePosition.html">ParsePosition</A>&nbsp;status)</PRE>
<DL>
<DD>Parses the string.

 <p>Caveats: The parse may fail in a number of circumstances.
 For example:
 <ul>
 <li>If one of the arguments does not occur in the pattern.
 <li>If the format of an argument loses information, such as
     with a choice format where a large number formats to "many".
 <li>Does not yet handle recursion (where
     the substituted strings contain {n} references.)
 <li>Will not always find a match (or the correct match)
     if some part of the parse is ambiguous.
     For example, if the pattern "{1},{2}" is used with the
     string arguments {"a,b", "c"}, it will format as "a,b,c".
     When the result is parsed, it will return {"a", "b,c"}.
 <li>If a single argument is parsed more than once in the string,
     then the later parse wins.
 </ul>
 When the parse fails, use ParsePosition.getErrorIndex() to find out
 where in the string did the parsing failed.  The returned error
 index is the starting offset of the sub-patterns that the string
 is comparing with.  For example, if the parsing string "AAA {0} BBB"
 is comparing against the pattern "AAD {0} BBB", the error index is
 0. When an error occurs, the call to this method will return null.
 If the soruce is null, return an empty array.</DL>
<HR>

<A NAME="parse(java.lang.String)"><!-- --></A><H3>
parse</H3>
<PRE>
public <A HREF="../../java/lang/Object.html">Object</A>[] <B>parse</B>(<A HREF="../../java/lang/String.html">String</A>&nbsp;source)
               throws <A HREF="../../java/text/ParseException.html">ParseException</A></PRE>
<DL>
<DD>Parses the string. Does not yet handle recursion (where
 the substituted strings contain {n} references.)<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../java/text/ParseException.html">ParseException</A></CODE> - if the string can't be parsed.</DL>
</DD>
</DL>
<HR>

<A NAME="parseObject(java.lang.String, java.text.ParsePosition)"><!-- --></A><H3>
parseObject</H3>
<PRE>
public <A HREF="../../java/lang/Object.html">Object</A> <B>parseObject</B>(<A HREF="../../java/lang/String.html">String</A>&nbsp;text,
                          <A HREF="../../java/text/ParsePosition.html">ParsePosition</A>&nbsp;status)</PRE>
<DL>
<DD>Parses the string. Does not yet handle recursion (where
 the substituted strings contain %n references.)<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../java/text/Format.html#parseObject(java.lang.String, java.text.ParsePosition)">parseObject</A></CODE> in class <CODE><A HREF="../../java/text/Format.html">Format</A></CODE></DL>
</DD>
<DD>Following copied from class: <CODE>java.text.Format</CODE></DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>status</CODE> - Input-Output parameter.
 <p>Before calling, set status.index to the offset you want to start
 parsing at in the source.
 After calling, status.index is the end of the text you parsed.
 If error occurs, index is unchanged.
 <p>When parsing, leading whitespace is discarded
 (with successful parse),
 while trailing whitespace is left as is.
 <p>Example:
 Parsing "_12_xy" (where _ represents a space) for a number,
 with index == 0 will result in
 the number 12, with status.index updated to 3
 (just before the second space).
 Parsing a second time will result in a ParseException
 since "xy" is not a number, and leave index at 3.
 <p>Subclasses will typically supply specific parse methods that
 return different types of values. Since methods can't overload on
 return types, these will typically be named "parse", while this
 polymorphic method will always be called parseObject.
 Any parse method that does not take a status should
 throw ParseException when no text in the required format is at
 the start position.<DT><B>Returns:</B><DD>Object parsed from string. In case of error, returns null.<DT><B>See Also: </B><DD><A HREF="../../java/text/ParsePosition.html"><CODE>ParsePosition</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="clone()"><!-- --></A><H3>
clone</H3>
<PRE>
public <A HREF="../../java/lang/Object.html">Object</A> <B>clone</B>()</PRE>
<DL>
<DD>Overrides Cloneable<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../java/text/Format.html#clone()">clone</A></CODE> in class <CODE><A HREF="../../java/text/Format.html">Format</A></CODE></DL>
</DD>
<DD>Following copied from class: <CODE>java.lang.Object</CODE></DD>
<DD><DL>
<DT><B>Returns:</B><DD>a clone of this instance.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/lang/CloneNotSupportedException.html">CloneNotSupportedException</A></CODE> - if the object's class does not
               support the <code>Cloneable</code> interface. Subclasses
               that override the <code>clone</code> method can also
               throw this exception to indicate that an instance cannot
               be cloned.<DD><CODE><A HREF="../../java/lang/OutOfMemoryError.html">OutOfMemoryError</A></CODE> - if there is not enough memory.<DT><B>See Also: </B><DD><A HREF="../../java/lang/Cloneable.html"><CODE>Cloneable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../java/lang/Object.html">Object</A>&nbsp;obj)</PRE>
<DL>
<DD>Equality comparision between two message format objects<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A></CODE> in class <CODE><A HREF="../../java/lang/Object.html">Object</A></CODE></DL>
</DD>
<DD>Following copied from class: <CODE>java.lang.Object</CODE></DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the reference object with which to compare.<DT><B>Returns:</B><DD><code>true</code> if this object is the same as the obj
          argument; <code>false</code> otherwise.<DT><B>See Also: </B><DD><A HREF="../../java/lang/Boolean.html#hashCode()"><CODE>Boolean.hashCode()</CODE></A>, 
<A HREF="../../java/util/Hashtable.html"><CODE>Hashtable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>Generates a hash code for the message format object.<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../java/lang/Object.html#hashCode()">hashCode</A></CODE> in class <CODE><A HREF="../../java/lang/Object.html">Object</A></CODE></DL>
</DD>
<DD>Following copied from class: <CODE>java.lang.Object</CODE></DD>
<DD><DL>
<DT><B>Returns:</B><DD>a hash code value for this object.<DT><B>See Also: </B><DD><A HREF="../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals(java.lang.Object)</CODE></A>, 
<A HREF="../../java/util/Hashtable.html"><CODE>Hashtable</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/MessageFormat.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Std.&nbsp;Ed. v1.3.1</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/text/Format.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../java/text/NumberFormat.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MessageFormat.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">Submit a bug or feature</a><br>For further API reference and developer documentation, see <a href="http://java.sun.com/j2se/1.3/index.jsp">Java 2 SDK SE Developer Documentation</a>. That documentation  contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples. <p>Java, Java 2D, and JDBC are trademarks or registered trademarks of Sun Microsystems, Inc. in the US and other countries.<br>Copyright 1993-2001 Sun Microsystems, Inc. 901 San Antonio Road<br>Palo Alto, California, 94303, U.S.A.  All Rights Reserved.</font>
</BODY>
</HTML>
