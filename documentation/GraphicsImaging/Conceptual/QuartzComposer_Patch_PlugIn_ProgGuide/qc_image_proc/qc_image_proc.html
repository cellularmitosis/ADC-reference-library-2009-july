<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Quartz Composer Custom Patch Programming Guide: Writing Image Processing Patches</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Writing Image Processing Patches"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40004787-CH7" title="Writing Image Processing Patches"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../Quartz-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000559" target="_top">Quartz</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40004787-CH1-DontLinkElementID_14">Quartz Composer Custom Patch Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WritingProcessorPatches/WritingProcessorPatches.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../WritingConsumerPatches/WritingConsumerPatches.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40004787-CH7-SW1" title="Writing Image Processing Patches"></a><h1>Writing Image Processing Patches</h1><p>The Quartz Composer framework defines protocols for getting image data from input ports and providing image data to output ports. These protocols eliminate the need to use explicit image data types such as <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIImage_Class/Reference/Reference.html#//apple_ref/occ/cl/CIImage" target="_top">CIImage</a></code> or <code>CGImage</code> objects. Using protocols ensures there won’t be any impedance mismatches between the image output port of one patch and the image input port of another.</p><p>This chapter describes how to implement the <code><a href="../../../../Cocoa/Reference/QCPlugInInputImageSource_Protocol/Reference/Reference.html#//apple_ref/occ/intf/QCPlugInInputImageSource" target="_top">QCPlugInInputImageSource</a></code> and <code>QCPlugInOutputImageProvider</code> protocols. Then it provides step-by-step instructions for creating a custom image processing patch that uses two image input ports and one image output port.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="qc_image_proc.html#//apple_ref/doc/uid/TP40004787-CH7-SW3">Getting Images From an Input Port</a>
				
			<br/>
			
        
			
			
				<a href="qc_image_proc.html#//apple_ref/doc/uid/TP40004787-CH7-DontLinkElementID_13">Providing Images for an Output Port</a>
				
			<br/>
			
        
			
			
				<a href="qc_image_proc.html#//apple_ref/doc/uid/TP40004787-CH7-SW2">Histogram Operation: Modifying Color in an Image</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40004787-CH7-SW3" title="Getting Images From an Input Port"></a><h2>Getting Images From an Input Port</h2><p>The <code><a href="../../../../Cocoa/Reference/QCPlugInInputImageSource_Protocol/Reference/Reference.html#//apple_ref/occ/intf/QCPlugInInputImageSource" target="_top">QCPlugInInputImageSource</a></code> protocol converts an input image from whatever format it’s in to either a memory buffer or OpenGL texture representation. When you need to access the pixels in an image, you simply convert the image to a representation (texture or buffer) using one of the methods defined by the protocol. Use a texture representation to process image data  on the GPU. Use a buffer representation to process image data on the CPU.</p><p> To create an image input port as an Objective-C 2.0 property, declare it as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>@property(dynamic) id&lt;QCPlugInInputImageSource> inputImage;<span></span></pre></td></tr></table></div><p>To create an image input port dynamically, use the type <code>QCPortTypeImage</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>[self addInputPortWithType:QCPortTypeImage<span></span></pre></td></tr><tr><td scope="row"><pre>                    forKey:@"inputImage"<span></span></pre></td></tr><tr><td scope="row"><pre>            withAttributes:nil];<span></span></pre></td></tr></table></div><p></p><p>You convert input images to textures only when you plan to use OpenGL to process the data, as OpenGL is the software interface to the GPU. To use input images as textures you need to perform these steps:</p><ol class="ol"><li class="li"><p>Lock the texture representation using <code>lockTextureRepresentationWithColorSpace:forBounds:</code>. This method creates a read-only OpenGL texture  from a subregion of the input image.</p></li><li class="li"><p>Bind the texture to a texture unit. You can perform this step entirely with OpenGL commands, but it is much easier to use the convenience method  <code>bindTextureRepresentationToCGLContext:textureUnit:normalizeCoordinates:</code> which binds the texture to the provided texture  unit (<code>GL_TEXTURE0</code>, and so on). It also loads the texture matrix onto the texture stack, scaling and flipping the coordinates if necessary, as long as you pass <code>YES</code> as the <code>normalizeCoordinates</code> argument.</p></li><li class="li"><p>Use the texture in whatever way is appropriate for your application. </p></li><li class="li"><p>When you no longer need the texture, unbind it from its texture unit. If you used the binding convenience method in step 2, then you must call the <code>unbindTextureRepresentationFromCGLContext:textureUnit</code> convenience method.</p></li><li class="li"><p>Release  the OpenGL texture representation of the input image by calling the <code><a href="../../../../Cocoa/Reference/QCPlugInInputImageSource_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/QCPlugInInputImageSource/unlockTextureRepresentation" target="_top">unlockTextureRepresentation</a></code> method.</p></li></ol><p>In addition to these steps, there are other tasks you should perform when using OpenGL. <span class="content_text"><a href="../WritingConsumerPatches/WritingConsumerPatches.html#//apple_ref/doc/uid/TP40004787-CH5-SW1">“Writing Consumer Patches”</a></span> provides tips for using OpenGL in a custom patch and shows how to bind a texture and render it to a destination.</p><p>You convert images to a buffer representation only if your custom patch manipulates input images on the CPU. To use input image data in a buffer you need to perform these steps:</p><ol class="ol"><li class="li"><p>Create and lock a buffer representation of the image using the <code><a href="../../../../Cocoa/Reference/QCPlugInInputImageSource_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/QCPlugInInputImageSource/lockBufferRepresentationWithPixelFormat:colorSpace:forBounds:" target="_top">lockBufferRepresentationWithPixelFormat:colorSpace:forBounds:</a></code> method, which creates a read-only memory buffer from a subregion of the input image. The pixel format and color space must be compatible.</p></li><li class="li"><p>Use the image data. You can get the base address of the image buffer with the <code><a href="../../../../Cocoa/Reference/QCPlugInInputImageSource_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/QCPlugInInputImageSource/bufferBaseAddress" target="_top">bufferBaseAddress</a></code> method and the number of bytes per row with the <code><a href="../../../../Cocoa/Reference/QCPlugInInputImageSource_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/QCPlugInInputImageSource/bufferBytesPerRow" target="_top">bufferBytesPerRow</a></code> method.</p></li><li class="li"><p>When you no longer need the image buffer, call the <code><a href="../../../../Cocoa/Reference/QCPlugInInputImageSource_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/QCPlugInInputImageSource/unlockBufferRepresentation" target="_top">unlockBufferRepresentation</a></code> to release it.</p></li></ol><p><em><a href="../../../../Cocoa/Reference/QCPlugInInputImageSource_Protocol/index.html#//apple_ref/doc/uid/TP40004799" target="_top">QCPlugInInputImageSource Protocol Reference</a></em> provides more information on these methods as well as the methods that retrieve texture and image buffer information—such as the bounds, height, width, and color space. <span class="content_text"><a href="qc_image_proc.html#//apple_ref/doc/uid/TP40004787-CH7-SW2">“Histogram Operation: Modifying Color in an Image”</a></span> shows how to convert an input image to an image buffer.</p><a name="//apple_ref/doc/uid/TP40004787-CH7-DontLinkElementID_13" title="Providing Images for an Output Port"></a><h2>Providing Images for an Output Port</h2><p>The <code>QCPlugInOutputImageProvider</code> protocol defines methods for rendering image data to an image buffer or to a texture. Quartz Composer calls the methods you implement only when the output image is needed. This “lazy” approach to supplying the output image is efficient and ensures the best performance possible.</p><p>If your custom patch has an image output port, you need to implement the appropriate methods for rendering image data and to supply information about the rendering destination and the image bounds.</p><p>To create an image output port as an Objective-C 2.0 property, declare it as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>@property(assign) id&lt;QCPlugInOutputImageProvider> outputImage;<span></span></pre></td></tr></table></div><p>To create an image input port dynamically use the type <code>QCPortTypeImage</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>[self addOutputPortWithType:QCPortTypeImage<span></span></pre></td></tr><tr><td scope="row"><pre>                    forKey:@"outputImage"<span></span></pre></td></tr><tr><td scope="row"><pre>           withAttributes:nil];<span></span></pre></td></tr></table></div><p>To write images to that port, you need to perform these steps:</p><ol class="ol"><li class="li"><p>Create an internal class that represents the output image.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyOutputImageProvider : NSObject &lt;QCPlugInOutputImageProvider><span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  // Declare instance variables, as appropriate<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Implement the methods that provide information about the image—<code><a href="../../../../Cocoa/Reference/QCPlugInOutputImageProvider_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/QCPlugInOutputImageProvider/imageBounds" target="_top">imageBounds</a></code> <code><a href="../../../../Cocoa/Reference/QCPlugInOutputImageProvider_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/QCPlugInOutputImageProvider/imageColorSpace" target="_top">imageColorSpace</a></code>.</p></li><li class="li"><p>Implement the methods that provide information about the rendering destination. If your custom patch renders to an image buffer, you must implement the<code><a href="../../../../Cocoa/Reference/QCPlugInOutputImageProvider_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/QCPlugInOutputImageProvider/supportedBufferPixelFormats" target="_top">supportedBufferPixelFormats</a></code> method. If it renders to a texture, you must implement the<code><!--a target="_top" -->supportedDrawablePixelFormats<!--/a--></code> and <code><a href="../../../../Cocoa/Reference/QCPlugInOutputImageProvider_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/QCPlugInOutputImageProvider/canRenderWithCGLContext:" target="_top">canRenderWithCGLContext:</a></code> methods.</p></li><li class="li"><p>Implement one of the methods for rendering to a destination. If your custom patch renders to an image buffer, you must implement the <code><a href="../../../../Cocoa/Reference/QCPlugInOutputImageProvider_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/QCPlugInOutputImageProvider/renderToBuffer:withBytesPerRow:pixelFormat:forBounds:" target="_top">renderToBuffer:withBytesPerRow:pixelFormat:forBounds:</a></code> method. If your custom patch renders to a texture, you must implement the <code><!--a target="_top" -->renderWithCGLContext:toDrawableWithPixelFormat:forBounds:<!--/a--></code> method. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004787-CH7-DontLinkElementID_27" title="Note"></a><p><strong>Note:</strong>&nbsp;If you are using textures  and you want to render to a framebuffer object or create a texture to use in an intermediate processing step, you can also implement the <code><!--a target="_top" -->createRenderedTextureWithCGLContext:forBounds:<!--/a--></code> method.  If this method returns [0], Quartz Composer calls the <code><!--a target="_top" -->renderWithCGLContext:toDrawableWithPixelFormat:forBounds:<!--/a--></code> method.</p></div></li></ol><p>See <em><a href="../../../../Cocoa/Reference/QCPlugInOutputImageProvider_Protocol/index.html#//apple_ref/doc/uid/TP40004800" target="_top">QCPlugInOutputImageProvider Protocol Reference</a></em> for additional details on these methods.</p><p>When Quartz Composer calls <code><a href="../../../../Cocoa/Reference/QCPlugInOutputImageProvider_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/QCPlugInOutputImageProvider/renderToBuffer:withBytesPerRow:pixelFormat:forBounds:" target="_top">renderToBuffer:withBytesPerRow:pixelFormat:forBounds:</a></code>, it passes your method a base address, the number of row bytes, the pixel format of the image data, and the bounds of the subregion. Your method then writes pixels to the supplied image buffer. <span class="content_text"><a href="qc_image_proc.html#//apple_ref/doc/uid/TP40004787-CH7-SW2">“Histogram Operation: Modifying Color in an Image”</a></span> provides an example of how to implement this method.</p><p>When Quartz Composer calls <code><!--a target="_top" -->renderWithCGLContext:toDrawableWithPixelFormat:forBounds:<!--/a--></code>, it automatically sets the viewport to the dimensions of the image, and the projection and modelview matrices to the identity matrix.  Prior to rendering, you must save all the OpenGL states that you plan  to change  except the ones defined by <code>GL_CURRENT_BIT</code>. When you are done rendering, you must restore the saved OpenGL states. </p><a name="//apple_ref/doc/uid/TP40004787-CH7-SW2" title="Histogram Operation: Modifying Color in an Image"></a><h2>Histogram Operation: Modifying Color in an Image</h2><p>This section shows how to write a custom patch that has two image input ports and one image output port. The patch computes a histogram for one of the input images, and uses that histogram to modify the colors in the other input image. It outputs  the color-modified image. This patch is a bit more complex than those described in the rest of the book. Before following the instructions in this section, make sure that you’ve read <span class="content_text"><a href="../WritingProcessorPatches/WritingProcessorPatches.html#//apple_ref/doc/uid/TP40004787-CH4-SW1">“Writing Processor Patches”</a></span> and are familiar with the basic tasks for setting up and creating a custom patch.</p><p>The Histogram Operation custom patch described in this section is similar to, but not exactly like, the Histogram Operation sample project provided with the Developer Tools for Mac OS X v10.5 in:</p><p><code>/Developer/Examples/Quartz Composer/Plugins</code></p><p>You might also want to take a look at that sample project.</p><p>An RGBA histogram is a count of the values at each intensity level, for each pixel component (red, green, blue, and alpha). For an image with a bit depth of 8 bits, each component can have a value from 0 to 255. <span class="content_text">Figure 3-1</span> shows an RGB histogram for a daisy image. The intensity values are plotted on the x-axis and the number of pixels are on the y-axis. The image is opaque, so there is no need to show the alpha component in this figure.</p><br/><div><a name="//apple_ref/doc/uid/TP40004787-CH7-SW11" title="Figure 3-1An RGB histogram for an image of a daisy"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>An RGB histogram for an image of a daisy</p><img src = "../art/histogram.jpg" alt = "An RGB histogram for an image of a daisy" ></div><br/><p>The image data for this patch is processed using the CPU, so you’ll see how to create an image buffer representation and render to an image buffer by defining a custom output image provider. (You can find out how to create a texture representation by reading <span class="content_text"><a href="../WritingConsumerPatches/WritingConsumerPatches.html#//apple_ref/doc/uid/TP40004787-CH5-SW1">“Writing Consumer Patches.”</a></span>) You’ll also see how to use the Accelerate framework to compute a histogram. </p><p><span class="content_text">Figure 3-2</span> shows a composition that uses the Histogram Operation custom patch. By looking at the thumbnail images, you can get an idea of how the patch modifies the source image using the histogram image.</p><br/><div><a name="//apple_ref/doc/uid/TP40004787-CH7-SW12" title="Figure 3-2A Quartz composition that uses the Histogram Operation custom patch"></a><p><strong>Figure 3-2&nbsp;&nbsp;</strong>A Quartz composition that uses the Histogram Operation custom patch</p><img src = "../art/histogram_operation.jpg" alt = "A Quartz composition that uses the Histogram Operation custom patch" ></div><br/><p>The Accelerate framework is a high-performance vector-accelerated library of routines. It’s ideal to use for custom patches that perform intensive computations. You’ll use the framework’s vImage library to compute a histogram. The function <code><a href="../../../../Performance/Reference/vImage_histogram/Reference/reference.html#//apple_ref/c/func/vImageHistogramCalculation_ARGB8888" target="_top">vImageHistogramCalculation_ARGB8888</a></code> calculates histograms  for the alpha, red, green, and blue channels (see <span class="content_text">Listing 3-1</span>). It takes an image buffer, an array to store histogram data, and a flag  to indicate whether to turn off vImage internal tiling routines . (See <em><a href="../../../Reference/vImageRefCollecton/index.html#//apple_ref/doc/uid/TP40005536" target="_top">vImage Reference Collection</a></em>.)</p><a name="//apple_ref/doc/uid/TP40004787-CH7-SW4" title="Listing 3-1Prototype for the vImage histogram function"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>Prototype for the vImage histogram function</p><div class="codesample"><table><tr><td scope="row"><pre>vImage_Error vImageHistogramCalculation_ARGB8888 (<span></span></pre></td></tr><tr><td scope="row"><pre>                      const vImage_Buffer *src,<span></span></pre></td></tr><tr><td scope="row"><pre>                      vImagePixelCount *histogram[4],<span></span></pre></td></tr><tr><td scope="row"><pre>                      vImage_Flags flags<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div><p>The steps for creating the Histogram Operation custom patch are in these sections:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="qc_image_proc.html#//apple_ref/doc/uid/TP40004787-CH7-SW5">“Create the Xcode Project”</a></span></p></li><li class="li"><p><span class="content_text"><a href="qc_image_proc.html#//apple_ref/doc/uid/TP40004787-CH7-SW6">“Create the Interface”</a></span></p></li><li class="li"><p><span class="content_text"><a href="qc_image_proc.html#//apple_ref/doc/uid/TP40004787-CH7-SW7">“Modify the Methods for the PlugIn Class”</a></span></p></li><li class="li"><p><span class="content_text"><a href="qc_image_proc.html#//apple_ref/doc/uid/TP40004787-CH7-SW8">“Implement the Methods for the Histogram Object”</a></span></p></li><li class="li"><p><span class="content_text"><a href="qc_image_proc.html#//apple_ref/doc/uid/TP40004787-CH7-SW9">“Write Methods for the Output Image Provider”</a></span></p></li><li class="li"><p><span class="content_text"><a href="qc_image_proc.html#//apple_ref/doc/uid/TP40004787-CH7-SW10">“Write the Execution Methods for the Plug-in Class”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP40004787-CH7-SW5" title="Create the Xcode Project"></a><h3>Create the Xcode Project</h3><p>To create the Histogram Operation Xcode project, follow these steps.:</p><ol class="ol"><li class="li"><p>Open Xcode and choose File > New Project.</p></li><li class="li"><p>In the New Project window, choose Standard Apple Plug-ins > Quartz Composer Plug-in and click Next.</p></li><li class="li"><p>Enter <code>HistogramOperation</code> in the Project Name text field and click Finish.</p></li><li class="li"><p>Choose Project > Add to Project, navigate to the Accelerate Framework, and click Add. </p><p>This framework is in <code>System/Library/Frameworks</code>.</p></li><li class="li"><p>In the sheet that appears, click Add.</p></li></ol><a name="//apple_ref/doc/uid/TP40004787-CH7-SW6" title="Create the Interface"></a><h3>Create the Interface</h3><p>If you created the custom patches in <span class="content_text"><a href="../WritingProcessorPatches/WritingProcessorPatches.html#//apple_ref/doc/uid/TP40004787-CH4-SW1">“Writing Processor Patches,”</a></span> most of the steps in this section should be familiar to you.</p><ol class="ol"><li class="li"><p>Open the <code>HistogramOperationPlugin.h</code> file.</p></li><li class="li"><p>Add a statement to import the Accelerate framework.</p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;Accelerate/Accelerate.h><span></span></pre></td></tr></table></div></li><li class="li"><p>Declare two properties for image input ports—one for the source image that the custom patch modifies and another for an image used for the histogram. Declare a property for the output image port. Your code should look as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;Quartz/Quartz.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Accelerate/Accelerate.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface HistogramOperationPlugIn : QCPlugIn<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property(assign) id&lt;QCPlugInInputImageSource> inputSourceImage;<span></span></pre></td></tr><tr><td scope="row"><pre>@property(assign) id&lt;QCPlugInInputImageSource> inputHistogramImage;<span></span></pre></td></tr><tr><td scope="row"><pre>@property(assign) id&lt;QCPlugInOutputImageProvider> outputResultImage;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div></li><li class="li"><p>Add the interface for a class that computes an RGBA histogram from an image.</p><p>The <code>Histogram</code> object holds the image source from which you’ll compute a histogram. In addition to an image source instance variable, you need to create four instance variables to store a count of the color component and alpha values—red, green, blue, and alpha. </p><p>You  need to write a method that initializes the image instance variable. You’ll need another method to compute the histogram values. Declare these methods now; you’ll write them later.</p><p>Your code should look similar to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Histogram : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    id&lt;QCPlugInInputImageSource>    _image;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    vImagePixelCount                _histogramA[256];<span></span></pre></td></tr><tr><td scope="row"><pre>    vImagePixelCount                _histogramR[256];<span></span></pre></td></tr><tr><td scope="row"><pre>    vImagePixelCount                _histogramG[256];<span></span></pre></td></tr><tr><td scope="row"><pre>    vImagePixelCount                _histogramB[256];<span></span></pre></td></tr><tr><td scope="row"><pre>    CGColorSpaceRef                 _colorSpace;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (id) initWithImageSource:(id&lt;QCPlugInInputImageSource>)image colorSpace:(CGColorSpaceRef)colorSpace;<span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL) getRGBAHistograms:(vImagePixelCount**)histograms;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div></li><li class="li"><p>In the interface for the <code>HistogramOperationPlugIn</code> class, add an instance variable for a <code>Histogram</code> object. You’ll use this to cache the image histogram. </p><p>The interface should look like this: </p><div class="codesample"><table><tr><td scope="row"><pre>@interface HistogramOperationPlugIn : QCPlugIn<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Histogram*                        _cachedHistogram;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Note that the interface for the <code>Histogram</code> class must either be specified before the <code>HistogramOperationPlugIn</code> class or the class must be declared using:</p><p><code>@class Histogram;</code></p></li><li class="li"><p>Add the interface for an internal class for the image provider, to represent the output image produced by the custom patch. </p><p>This class has two instance variable—the input image used to create a histogram, and the <code>Histogram</code> object that you’ll use to modify the source image. You also need to declare a method to initialize the image instance variable. You’ll write the <code>initWithImageSource:histogram:</code> method later. When done, your code should look like this:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface HistogramImageProvider : NSObject &lt;QCPlugInOutputImageProvider><span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    id&lt;QCPlugInInputImageSource>    _image;<span></span></pre></td></tr><tr><td scope="row"><pre>    Histogram*                      _histogram;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (id) initWithImageSource:(id&lt;QCPlugInInputImageSource>)image<span></span></pre></td></tr><tr><td scope="row"><pre>                 histogram:(Histogram*)histogram;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div></li><li class="li"><p>Close the <code>HistogramOperationPlugIn.h</code> file.</p></li></ol><a name="//apple_ref/doc/uid/TP40004787-CH7-SW7" title="Modify the Methods for the PlugIn Class"></a><h3>Modify the Methods for the PlugIn Class</h3><p>Next you’ll modify the methods needed to implement the <code>HistogramOperationPlugIn</code> class. </p><ol class="ol"><li class="li"><p>Open the <code>HistogramOperationPlugIn.m</code> file. </p></li><li class="li"><p>Just after the implementation statement for <code>HistogramOperationPlugin</code>, declare the input and output properties as dynamic. Quartz Composer will handle their implementation.</p><div class="codesample"><table><tr><td scope="row"><pre>@dynamic inputSourceImage, inputHistogramImage, outputResultImage;<span></span></pre></td></tr></table></div></li><li class="li"><p>Modify the description and name for the custom patch.</p><div class="codesample"><table><tr><td scope="row"><pre>#define    kQCPlugIn_Name  @"Histogram Operation"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kQCPlugIn_Description @"Alters a source image according to the histogram of another image."<span></span></pre></td></tr></table></div></li><li class="li"><p>You do not need to modify the default <code>attributes</code> method supplied in the template, which should look as follows: </p><div class="codesample"><table><tr><td scope="row"><pre>+ (NSDictionary*) attributes<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>                kQCPlugIn_Name,QCPlugInAttributeNameKey,<span></span></pre></td></tr><tr><td scope="row"><pre>                kQCPlugIn_Description,QCPlugInAttributeDescriptionKey,<span></span></pre></td></tr><tr><td scope="row"><pre>                nil];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Modify the <code><a href="../../../../Cocoa/Reference/QCPlugIn_Class/Introduction/Introduction.html#//apple_ref/occ/clm/QCPlugIn/attributesForPropertyPortWithKey:" target="_top">attributesForPropertyPortWithKey:</a></code> so that it returns a dictionary for each input and output parameter. </p><div class="codesample"><table><tr><td scope="row"><pre>+ (NSDictionary*) attributesForPropertyPortWithKey:(NSString*)key<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>  if([key isEqualToString:@"inputSourceImage"])<span></span></pre></td></tr><tr><td scope="row"><pre>    return [NSDictionary dictionaryWithObjectsAndKeys:@"Source Image",<span></span></pre></td></tr><tr><td scope="row"><pre>                         QCPortAttributeNameKey, nil];<span></span></pre></td></tr><tr><td scope="row"><pre>  if([key isEqualToString:@"inputHistogramImage"])<span></span></pre></td></tr><tr><td scope="row"><pre>    return [NSDictionary dictionaryWithObjectsAndKeys:@"Histogram Image",<span></span></pre></td></tr><tr><td scope="row"><pre>                          QCPortAttributeNameKey, nil];<span></span></pre></td></tr><tr><td scope="row"><pre>  if([key isEqualToString:@"outputResultImage"])<span></span></pre></td></tr><tr><td scope="row"><pre>    return [NSDictionary dictionaryWithObjectsAndKeys:@"Result Image",<span></span></pre></td></tr><tr><td scope="row"><pre>                          QCPortAttributeNameKey, nil];<span></span></pre></td></tr><tr><td scope="row"><pre>  return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Make sure the <code><a href="../../../../Cocoa/Reference/QCPlugIn_Class/Introduction/Introduction.html#//apple_ref/occ/clm/QCPlugIn/executionMode" target="_top">executionMode</a></code>  method returns  <code>kQCPlugInExecutionModeProcessor</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>+ (QCPlugInExecutionMode) executionMode<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return kQCPlugInExecutionModeProcessor;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Make sure the <code><a href="../../../../Cocoa/Reference/QCPlugIn_Class/Introduction/Introduction.html#//apple_ref/occ/clm/QCPlugIn/timeMode" target="_top">timeMode</a></code> method returns <code>kQCPlugInTimeModeNone</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>+ (QCPlugInTimeMode) timeMode<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return kQCPlugInTimeModeNone;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li></ol><a name="//apple_ref/doc/uid/TP40004787-CH7-SW8" title="Implement the Methods for the Histogram Object"></a><h3>Implement the Methods for the Histogram Object</h3><p>Before you implement the execution methods for <code>HistogramOperationPlugIn</code>, you’ll implement the methods needed for the <code>Histogram</code> class—one to initialize the object with an image, a method to release the image when it is no longer needed, and another method that creates an image buffer from an input image and uses vImage to compute a histogram.</p><p>You need to add the code in this section between these statements:</p><div class="codesample"><table><tr><td scope="row"><pre>@implementation Histogram<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><ol class="ol"><li class="li"><p>Write an initialize method that retains the image used to calculate the histogram.</p><div class="codesample"><table><tr><td scope="row"><pre>- (id) initWithImageSource:(id&lt;QCPlugInInputImageSource>)image colorSpace:(CGColorSpaceRef)colorSpace<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>   // Make sure there is an image.<span></span></pre></td></tr><tr><td scope="row"><pre>  if(!image) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self release];<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Keep the image and the processing color space around.<span></span></pre></td></tr><tr><td scope="row"><pre>    if(self = [super init]){<span></span></pre></td></tr><tr><td scope="row"><pre>       _image = [(id)image retain];<span></span></pre></td></tr><tr><td scope="row"><pre>       _colorSpace = CGColorSpaceRetain(colorSpace);<span></span></pre></td></tr><tr><td scope="row"><pre>     }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Write a method that releases the histogram image when it’s no longer needed.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void) dealloc<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [(id)_image release];<span></span></pre></td></tr><tr><td scope="row"><pre>    CGColorSpaceRelease(_colorSpace);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Write a method that gets and stores histogram data for each pixel component.</p><p>In this method, you need to get a buffer representation of the image on the histogram image input port.</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL) getRGBAHistograms:(vImagePixelCount**)histograms<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    vImage_Buffer                    buffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    vImage_Error                    error;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if(_image) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Get a buffer representation from the image<span></span></pre></td></tr><tr><td scope="row"><pre>        if(![_image  lockBufferRepresentationWithPixelFormat:QCPlugInPixelFormatARGB8<span></span></pre></td></tr><tr><td scope="row"><pre>                     colorSpace:[_image imageColorSpace]<span></span></pre></td></tr><tr><td scope="row"><pre>                     forBounds:[_image imageBounds]])<span></span></pre></td></tr><tr><td scope="row"><pre>            return NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Set up the vImage buffer<span></span></pre></td></tr><tr><td scope="row"><pre>        buffer.data = (void*)[_image bufferBaseAddress];<span></span></pre></td></tr><tr><td scope="row"><pre>        buffer.rowBytes = [_image bufferBytesPerRow];<span></span></pre></td></tr><tr><td scope="row"><pre>        buffer.width = [_image bufferPixelsWide];<span></span></pre></td></tr><tr><td scope="row"><pre>        buffer.height = [_image bufferPixelsHigh];<span></span></pre></td></tr><tr><td scope="row"><pre>        // Set up the vImage histogram array<span></span></pre></td></tr><tr><td scope="row"><pre>        histograms[0] = _histogramA;<span></span></pre></td></tr><tr><td scope="row"><pre>        histograms[1] = _histogramR;<span></span></pre></td></tr><tr><td scope="row"><pre>        histograms[2] = _histogramG;<span></span></pre></td></tr><tr><td scope="row"><pre>        histograms[3] = _histogramB;<span></span></pre></td></tr><tr><td scope="row"><pre>        // Call the vImage function to compute the histograms for the image data<span></span></pre></td></tr><tr><td scope="row"><pre>        error = vImageHistogramCalculation_ARGB8888(&amp;buffer, histograms, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Now that you have the histogram, you can release the buffer<span></span></pre></td></tr><tr><td scope="row"><pre>        [_image unlockBufferRepresentation];<span></span></pre></td></tr><tr><td scope="row"><pre>        // Handle errors, if there are any<span></span></pre></td></tr><tr><td scope="row"><pre>        if(error != kvImageNoError)<span></span></pre></td></tr><tr><td scope="row"><pre>            return NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // You no longer need the histogram image, so release it<span></span></pre></td></tr><tr><td scope="row"><pre>        [(id)_image release];<span></span></pre></td></tr><tr><td scope="row"><pre>        _image = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Reverse the histogram data<span></span></pre></td></tr><tr><td scope="row"><pre>    histograms[0] = _histogramR;<span></span></pre></td></tr><tr><td scope="row"><pre>    histograms[1] = _histogramG;<span></span></pre></td></tr><tr><td scope="row"><pre>    histograms[2] = _histogramB;<span></span></pre></td></tr><tr><td scope="row"><pre>    histograms[3] = _histogramA;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li></ol><a name="//apple_ref/doc/uid/TP40004787-CH7-SW10" title="Write the Execution Methods for the Plug-in Class"></a><h3>Write the Execution Methods for the Plug-in Class</h3><p>To make the code more readable, place the code in this section between these statements:</p><div class="codesample"><table><tr><td scope="row"><pre>@implementation HistogramOperationPlugIn (Execution)<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><ol class="ol"><li class="li"><p>Write the execute method for the plug-in class.</p><p>This method is invoked by Quartz Composer whenever either of the input ports change. The method updates the histogram image if it changed and creates a <code>HistogramImageProvider</code> object from the source image and the cached histogram.</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL) execute:(id&lt;QCPlugInContext>)context atTime:(NSTimeInterval)time withArguments:(NSDictionary*)arguments<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    id&lt;QCPlugInInputImageSource>    image;<span></span></pre></td></tr><tr><td scope="row"><pre>    HistogramImageProvider*         provider;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGColorSpaceRef                 colorSpace;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If the histogram input image changes, update the cached histogram.<span></span></pre></td></tr><tr><td scope="row"><pre>    if([self didValueForInputKeyChange:@"inputHistogramImage"]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [_cachedHistogram release];<span></span></pre></td></tr><tr><td scope="row"><pre>        if(image = self.inputHistogramImage) {<span></span></pre></td></tr><tr><td scope="row"><pre>           colorSpace = (CGColorSpaceGetModel([image imageColorSpace]) == kCGColorSpaceModelRGB ?<span></span></pre></td></tr><tr><td scope="row"><pre>               [image imageColorSpace] : [context colorSpace]);<span></span></pre></td></tr><tr><td scope="row"><pre>           _cachedHistogram = [[Histogram alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                    initWithImageSource:self.inputHistogramImage<span></span></pre></td></tr><tr><td scope="row"><pre>                    colorSpace:colorSpace];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>            _cachedHistogram = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Check for a histogram and a source image, if they both exist,<span></span></pre></td></tr><tr><td scope="row"><pre>    // create the provider and initialize it with the source image and histogram<span></span></pre></td></tr><tr><td scope="row"><pre>    if(_cachedHistogram &amp;&amp; (image = self.inputSourceImage)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        provider = [[HistogramImageProvider alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                        initWithImageSource:sourceImage<span></span></pre></td></tr><tr><td scope="row"><pre>                        histogram:_cachedHistogram];<span></span></pre></td></tr><tr><td scope="row"><pre>        // Bail out if the provider doesn't exist<span></span></pre></td></tr><tr><td scope="row"><pre>        if(provider == nil)<span></span></pre></td></tr><tr><td scope="row"><pre>          return NO;<span></span></pre></td></tr><tr><td scope="row"><pre>        // Otherwise, set the output image to the provider<span></span></pre></td></tr><tr><td scope="row"><pre>        self.outputResultImage = provider;<span></span></pre></td></tr><tr><td scope="row"><pre>        // Release the provider<span></span></pre></td></tr><tr><td scope="row"><pre>        [provider release];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>       // If the histogram and source image don't both exist,<span></span></pre></td></tr><tr><td scope="row"><pre>       // set the output image to nil<span></span></pre></td></tr><tr><td scope="row"><pre>       self.outputResultImage = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Implement the stop execution method.</p><p>This method is optional. But, for this custom patch, you need to release the cached histogram when the custom patch stops executing. So you must implement it.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void) stopExecution:(id&lt;QCPlugInContext>)context<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [_cachedHistogram release];<span></span></pre></td></tr><tr><td scope="row"><pre>    _cachedHistogram = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li></ol><a name="//apple_ref/doc/uid/TP40004787-CH7-SW9" title="Write Methods for the Output Image Provider"></a><h3>Write Methods for the Output Image Provider</h3><p>All of the code in this section needs to be added between these statements:</p><div class="codesample"><table><tr><td scope="row"><pre>@implementation HistogramImageProvider<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>The output image provider does all the work to render the image. Recall that Quartz Composer invokes your render method only when an output image is needed, thereby avoiding unnecessary computations.</p><ol class="ol"><li class="li"><p>Write a method that initializes the image provider with a source image an a previously computed histogram.</p><div class="codesample"><table><tr><td scope="row"><pre>- (id) initWithImageSource:(id&lt;QCPlugInInputImageSource>)image histogram:(Histogram*)histogram<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Check to make sure  an image and a histogram exists.<span></span></pre></td></tr><tr><td scope="row"><pre>    if(!image || !histogram) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self release];<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Keep the image and histogram around.<span></span></pre></td></tr><tr><td scope="row"><pre>    if(self = [super init]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        _image = [(id)image retain];<span></span></pre></td></tr><tr><td scope="row"><pre>        _histogram = [histogram retain];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Implement a <code>dealloc</code> method that releases the image and the histogram.</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void) dealloc<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [(id)_image release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [_histogram release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Implement a method to inform Quartz Composer of the bounds of the image. </p><div class="codesample"><table><tr><td scope="row"><pre>- (NSRect) imageBounds<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // This image has the same bounds as the source image.<span></span></pre></td></tr><tr><td scope="row"><pre>    return [_image imageBounds];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Implement a method to inform Quartz Composer of the color space used by the image. </p><div class="codesample"><table><tr><td scope="row"><pre>- (CGColorSpaceRef) imageColorSpace<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Preserve the original image color space.<span></span></pre></td></tr><tr><td scope="row"><pre>    return [_image imageColorSpace];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Implement a method to inform Quartz Composer of the supported pixel formats. </p><p>You need to support ARGB8, BGRA8 and RGBAf. Use the constants supplied in the Quartz Composer framework.</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSArray*) supportedBufferPixelFormats<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Support for only ARGB8, BGRA8 and RGBAf */<span></span></pre></td></tr><tr><td scope="row"><pre>    return [NSArray arrayWithObjects:QCPlugInPixelFormatARGB8,<span></span></pre></td></tr><tr><td scope="row"><pre>                                      QCPlugInPixelFormatBGRA8,<span></span></pre></td></tr><tr><td scope="row"><pre>                                      QCPlugInPixelFormatRGBAf,<span></span></pre></td></tr><tr><td scope="row"><pre>                                      nil];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Implement the render to buffer method.</p><p>Quartz Composer invokes this method whenever your custom patch needs to produce an output image. This happens when the image output port is connected to an image input port and when one of the input images change.</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL) renderToBuffer:(void*)baseAddress<span></span></pre></td></tr><tr><td scope="row"><pre>        withBytesPerRow:(NSUInteger)rowBytes<span></span></pre></td></tr><tr><td scope="row"><pre>            pixelFormat:(NSString*)format<span></span></pre></td></tr><tr><td scope="row"><pre>              forBounds:(NSRect)bounds<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    vImage_Buffer        inBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                         outBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    vImage_Error         error;<span></span></pre></td></tr><tr><td scope="row"><pre>    const vImagePixelCount*     histograms[4];<span></span></pre></td></tr><tr><td scope="row"><pre>    const vImagePixelCount*     temp;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Retrieve histogram data. This triggers computation of the<span></span></pre></td></tr><tr><td scope="row"><pre>    // histogram if necessary.<span></span></pre></td></tr><tr><td scope="row"><pre>    if(![_histogram getRGBAHistograms:(vImagePixelCount**)histograms])<span></span></pre></td></tr><tr><td scope="row"><pre>         return NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get a buffer representation for the source image.<span></span></pre></td></tr><tr><td scope="row"><pre>    if(![_image lockBufferRepresentationWithPixelFormat:format<span></span></pre></td></tr><tr><td scope="row"><pre>                                             colorSpace:[_image imageColorSpace]<span></span></pre></td></tr><tr><td scope="row"><pre>                                              forBounds:bounds])<span></span></pre></td></tr><tr><td scope="row"><pre>         // Bail out if the buffer representation fails<span></span></pre></td></tr><tr><td scope="row"><pre>         return NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Apply the previously computed histogram to the source image and<span></span></pre></td></tr><tr><td scope="row"><pre>    // render the result to the output buffer<span></span></pre></td></tr><tr><td scope="row"><pre>    inBuffer.data = (void*)[_image bufferBaseAddress];<span></span></pre></td></tr><tr><td scope="row"><pre>    inBuffer.rowBytes = [_image bufferBytesPerRow];<span></span></pre></td></tr><tr><td scope="row"><pre>    inBuffer.width = [_image bufferPixelsWide];<span></span></pre></td></tr><tr><td scope="row"><pre>    inBuffer.height = [_image bufferPixelsHigh];<span></span></pre></td></tr><tr><td scope="row"><pre>    outBuffer.data = baseAddress;<span></span></pre></td></tr><tr><td scope="row"><pre>    outBuffer.rowBytes = rowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>    outBuffer.width = [_image bufferPixelsWide];<span></span></pre></td></tr><tr><td scope="row"><pre>    outBuffer.height = [_image bufferPixelsHigh];<span></span></pre></td></tr><tr><td scope="row"><pre>    // Call the vImage histogram function that's appropriate<span></span></pre></td></tr><tr><td scope="row"><pre>    // for the pixel format.<span></span></pre></td></tr><tr><td scope="row"><pre>    if([format isEqualToString:QCPlugInPixelFormatRGBAf])<span></span></pre></td></tr><tr><td scope="row"><pre>        error = vImageHistogramSpecification_ARGBFFFF(&amp;inBuffer, &amp;outBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                        NULL, histograms,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                        256, 0.0, 1.0, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    else if([format isEqualToString:QCPlugInPixelFormatARGB8]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // You need to convert the histogram from RGBA to ARGB<span></span></pre></td></tr><tr><td scope="row"><pre>        temp = histograms[3];<span></span></pre></td></tr><tr><td scope="row"><pre>        histograms[3] = histograms[2];<span></span></pre></td></tr><tr><td scope="row"><pre>        histograms[2] = histograms[1];<span></span></pre></td></tr><tr><td scope="row"><pre>        histograms[1] = histograms[0];<span></span></pre></td></tr><tr><td scope="row"><pre>        histograms[0] = temp;<span></span></pre></td></tr><tr><td scope="row"><pre>        error = vImageHistogramSpecification_ARGB8888(&amp;inBuffer, &amp;outBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                      histograms, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else if([format isEqualToString:QCPlugInPixelFormatBGRA8]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // You need to convert the histogram from RGBA to BGRA<span></span></pre></td></tr><tr><td scope="row"><pre>        temp = histograms[0];<span></span></pre></td></tr><tr><td scope="row"><pre>        histograms[0] = histograms[2];<span></span></pre></td></tr><tr><td scope="row"><pre>        histograms[2] = temp;<span></span></pre></td></tr><tr><td scope="row"><pre>        error = vImageHistogramSpecification_ARGB8888(&amp;inBuffer, &amp;outBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                      histograms, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        // This should never happen.<span></span></pre></td></tr><tr><td scope="row"><pre>        error = -1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Release the buffer representation.<span></span></pre></td></tr><tr><td scope="row"><pre>    [_image unlockBufferRepresentation];<span></span></pre></td></tr><tr><td scope="row"><pre>    // Check for vImage errors.<span></span></pre></td></tr><tr><td scope="row"><pre>    if(error != kvImageNoError)<span></span></pre></td></tr><tr><td scope="row"><pre>          return NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    // Success!<span></span></pre></td></tr><tr><td scope="row"><pre>    return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li></ol>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WritingProcessorPatches/WritingProcessorPatches.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../WritingConsumerPatches/WritingConsumerPatches.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-12-11<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/QuartzComposer_Patch_PlugIn_ProgGuide/qc_image_proc/qc_image_proc.html%3Fid%3DTP40004787-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/QuartzComposer_Patch_PlugIn_ProgGuide/qc_image_proc/qc_image_proc.html%3Fid%3DTP40004787-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/QuartzComposer_Patch_PlugIn_ProgGuide/qc_image_proc/qc_image_proc.html%3Fid%3DTP40004787-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>