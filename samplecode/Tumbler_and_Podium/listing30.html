<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Tumbler and Podium - /TumblerSource/Tumbler_podium.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Tumbler and Podium</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Tumbler and Podium</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/TumblerSource/Tumbler_podium.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/TumblerSource/Tumbler_AEVT.c</option>
<option value="listing2.html">/TumblerSource/Tumbler_AEVT.h</option>
<option value="listing3.html">/TumblerSource/Tumbler_camera.c</option>
<option value="listing4.html">/TumblerSource/Tumbler_camera.h</option>
<option value="listing5.html">/TumblerSource/Tumbler_cursor.c</option>
<option value="listing6.html">/TumblerSource/Tumbler_cursor.h</option>
<option value="listing7.html">/TumblerSource/Tumbler_document.c</option>
<option value="listing8.html">/TumblerSource/Tumbler_document.h</option>
<option value="listing9.html">/TumblerSource/Tumbler_drag.c</option>
<option value="listing10.html">/TumblerSource/Tumbler_drag.h</option>
<option value="listing11.html">/TumblerSource/Tumbler_ErrorHandler.c</option>
<option value="listing12.html">/TumblerSource/Tumbler_ErrorHandler.h</option>
<option value="listing13.html">/TumblerSource/Tumbler_event.c</option>
<option value="listing14.html">/TumblerSource/Tumbler_event.h</option>
<option value="listing15.html">/TumblerSource/Tumbler_file.c</option>
<option value="listing16.html">/TumblerSource/Tumbler_file.h</option>
<option value="listing17.html">/TumblerSource/Tumbler_globals.h</option>
<option value="listing18.html">/TumblerSource/Tumbler_HideMenuBar.c</option>
<option value="listing19.html">/TumblerSource/Tumbler_HideMenuBar.h</option>
<option value="listing20.html">/TumblerSource/Tumbler_initialize.c</option>
<option value="listing21.html">/TumblerSource/Tumbler_initialize.h</option>
<option value="listing22.html">/TumblerSource/Tumbler_main.c</option>
<option value="listing23.html">/TumblerSource/Tumbler_main.h</option>
<option value="listing24.html">/TumblerSource/Tumbler_menus.c</option>
<option value="listing25.html">/TumblerSource/Tumbler_menus.h</option>
<option value="listing26.html">/TumblerSource/Tumbler_offscreen.c</option>
<option value="listing27.html">/TumblerSource/Tumbler_offscreen.h</option>
<option value="listing28.html">/TumblerSource/Tumbler_PICTImport.c</option>
<option value="listing29.html">/TumblerSource/Tumbler_PICTImport.h</option>
<option value="listing30.html">/TumblerSource/Tumbler_podium.c</option>
<option value="listing31.html">/TumblerSource/Tumbler_podium.h</option>
<option value="listing32.html">/TumblerSource/Tumbler_prototypes.h</option>
<option value="listing33.html">/TumblerSource/Tumbler_resources.h</option>
<option value="listing34.html">/TumblerSource/Tumbler_teutilities.c</option>
<option value="listing35.html">/TumblerSource/Tumbler_teutilities.h</option>
<option value="listing36.html">/TumblerSource/Tumbler_traps.c</option>
<option value="listing37.html">/TumblerSource/Tumbler_traps.h</option>
<option value="listing38.html">/TumblerSource/Tumbler_utility.c</option>
<option value="listing39.html">/TumblerSource/Tumbler_utility.h</option>
<option value="listing40.html">/TumblerSource/Tumbler_windows.c</option>
<option value="listing41.html">/TumblerSource/Tumbler_windows.h</option></select>
				</p>
				</form>
				<p><strong><a href="Tumbler_and_Podium.zip">Download Sample</a></strong> (&#147;Tumbler_and_Podium.zip&#148;, 1.07M)<BR>
<strong><a href="Tumbler_and_Podium.dmg">Download Sample</a></strong> (&#147;Tumbler_and_Podium.dmg&#148;, 1.15M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">// tumbler_podium.c -- this contains the podium specific routines for the tumbler app////#ifdef PODIUM_APP#include &quot;QD3D.h&quot;#include &lt;Drag.h&gt;#include &lt;Events.h&gt;#include &lt;Controls.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;Windows.h&gt;#include &quot;QD3DView.h&quot;#include &quot;QD3DDrawContext.h&quot;#include &quot;QD3DDrawContext.h&quot;#include &quot;QD3DPick.h&quot;#include &quot;QD3DGroup.h&quot;#include &quot;QD3DTransform.h&quot;#include &quot;QD3DLight.h&quot;#include &quot;QD3DMath.h&quot;#include &lt;QuickDraw.h&gt;#include &lt;QDOffscreen.h&gt;#include &quot;tumbler_Document.h&quot;#include &quot;tumbler_Camera.h&quot;#include &quot;tumbler_podium.h&quot;#include &quot;tumbler_offscreen.h&quot;#include &quot;tumbler_drag.h&quot;static CursHandle    objectCursor, zoomInCursor, zoomOutCursor, handCursor;static TQ3Object DoHitTest(DocumentPtr  theDocument);static short PointInRect(Point *point, Rect *rect);// Used in Tumber_AEVT.cvoid Podium_UpdateDrawContextFromDropRect( DocumentPtr theDocument ) ;//------------------------------------------------------------------------------------void Podium_UpdateDrawContextFromDropRect( DocumentPtr theDocument ){  Rect          frameRect ;    frameRect = theDocument-&gt;dropArea ;     // if the drop area for the doc is the same as the GWorld's rect  // then we don't need to do anything, if they have changes we need  // to update the drawcontext    if(!EqualRect(&amp;frameRect,&amp;theDocument-&gt;geometriesOffscreen-&gt;portRect)) {    TQ3DrawContextObject  theDrawContext ;    OSErr        theErr ;        if((theErr = UpdateGWorld( &amp;theDocument-&gt;geometriesOffscreen, 32, &amp;frameRect, nil, nil, 0L )) == noErr//      &amp;&amp; (theErr = UpdateGWorld( &amp;theDocument-&gt;maskOffscreen, 1, &amp;frameRect, nil, nil, 0L )) == noErr      ) {                    theDrawContext = TumblerDocument_NewPixmapDrawContext( theDocument ) ;      Q3View_SetDrawContext(theDocument-&gt;theView, theDrawContext);      Q3Object_Dispose(theDrawContext);            AdjustCamera(theDocument,        theDocument-&gt;geometriesOffscreen-&gt;portRect.right - theDocument-&gt;geometriesOffscreen-&gt;portRect.left,        theDocument-&gt;geometriesOffscreen-&gt;portRect.bottom - theDocument-&gt;geometriesOffscreen-&gt;portRect.top);    }  }}    static void MouseMoved(  DocumentPtr  theDocument,  long  oldX,   long  oldY,  long  newX,   long  newY){  float        scaleFactor = 256.0;  unsigned long    winWidth, winHeight;  TQ3Matrix4x4    tmp;  TQ3BoundingBox     viewBBox;  TQ3Point3D      modelCenter;    /*   *  Find the bounding box for the group.   *  We'll use the center of the box as the point about which to rotate   *  (the old method always rotated about the world-space origin).   */  /*   *  Get the width and height of the *current* window.   *  This is done so that mouse motion in a window has an effect   *  relative to the size of the window.    */  winWidth  = theDocument-&gt;theWindow-&gt;portRect.right - theDocument-&gt;theWindow-&gt;portRect.left;  winHeight = theDocument-&gt;theWindow-&gt;portRect.bottom - theDocument-&gt;theWindow-&gt;portRect.top;  GetGroupBBox(theDocument-&gt;theView, theDocument-&gt;documentGroup, NULL, &amp;viewBBox);    /*   *  The &quot;to&quot; point is the center of the view bounding box   */  {    float    weights[2] = { 0.5, 0.5 };    TQ3Point3D  points[2];        points[0] = viewBBox.min;    points[1] = viewBBox.max;        Q3Point3D_AffineComb(points, weights, 2, &amp;modelCenter);  }        /*   *  Make a new rotation matrix, rotating about the center of the view   *  bbox.   */        {    float  xRot, yRot, zRot;        xRot = yRot = zRot = 0.0;        xRot = Q3Math_DegreesToRadians((float)(newY - oldY) / winHeight * scaleFactor);    yRot = Q3Math_DegreesToRadians((float)(newX - oldX) / winWidth * scaleFactor);    if ((xRot != 0.0) || (yRot != 0.0)){      Q3Matrix4x4_SetRotateAboutPoint(&amp;tmp, &amp;modelCenter, xRot, yRot, zRot);      Q3Matrix4x4_Multiply(&amp;theDocument-&gt;modelRotation, &amp;tmp, &amp;theDocument-&gt;modelRotation);    }  }}static short PointInRect(Point *point, Rect *rect){  if( point-&gt;h &gt; rect-&gt;left &amp;&amp; point-&gt;h &lt; rect-&gt;right ) {    if( point-&gt;v &gt; rect-&gt;top &amp;&amp; point-&gt;v &lt; rect-&gt;bottom ) {      return(1);    } else {      return(0);    }  } else {    return(0);  }}static Boolean PtOnHandles(Point *newMouse, Rect *location, short *whichHandle){  Rect  handlesRect;    handlesRect.left = location-&gt;left - 4;  handlesRect.top = location-&gt;top - 4;  handlesRect.right = location-&gt;left;  handlesRect.bottom = location-&gt;top;    if( PointInRect(newMouse, &amp;handlesRect) ) {    *whichHandle = LeftTopHandle;    return(true);  }    handlesRect.left = location-&gt;right;  handlesRect.right = location-&gt;right + 4;    if( PointInRect(newMouse, &amp;handlesRect) ) {    *whichHandle = RightTopHandle;    return(true);  }    handlesRect.left = location-&gt;right;  handlesRect.right = location-&gt;right + 4;  handlesRect.top = location-&gt;bottom;  handlesRect.bottom = location-&gt;bottom + 4;    if( PointInRect(newMouse, &amp;handlesRect) ) {    *whichHandle = RightBottomHandle;    return(true);  }    handlesRect.left = location-&gt;left - 4;  handlesRect.right = location-&gt;left;    if( PointInRect(newMouse, &amp;handlesRect) ) {    *whichHandle = LeftBottomHandle;    return(true);  }  return(false);}static void DrawHandles(Rect *location){  Rect  handlesRect;    handlesRect.left = location-&gt;left - 4;  handlesRect.top = location-&gt;top - 4;  handlesRect.right = location-&gt;left;  handlesRect.bottom = location-&gt;top;    PaintRect(&amp;handlesRect);    handlesRect.left = location-&gt;right;  handlesRect.right = location-&gt;right + 4;    PaintRect(&amp;handlesRect);    handlesRect.left = location-&gt;right;  handlesRect.right = location-&gt;right + 4;  handlesRect.top = location-&gt;bottom;  handlesRect.bottom = location-&gt;bottom + 4;    PaintRect(&amp;handlesRect);    handlesRect.left = location-&gt;left - 4;  handlesRect.right = location-&gt;left;    PaintRect(&amp;handlesRect);    PenSize(2,2);  MoveTo(location-&gt;left - 2, location-&gt;top - 2);  LineTo(location-&gt;right, location-&gt;top - 2);  LineTo(location-&gt;right, location-&gt;bottom);  LineTo(location-&gt;left - 2, location-&gt;bottom);  LineTo(location-&gt;left - 2, location-&gt;top - 2);  //FrameRect(location);}/* *  hit test a click in the document. */static TQ3Object DoHitTest(DocumentPtr  theDocument){  TQ3WindowPointPickData  withData;  unsigned long    numPicked;  TQ3PickObject    pickObject;  withData.data.sort       =  kQ3PickSortNone;  withData.data.numHitsToReturn=  1;  withData.data.mask       =  kQ3PickDetailMaskObject;                    withData.point.x = theDocument-&gt;mouseLocation.h - theDocument-&gt;dropArea.left;  withData.point.y = theDocument-&gt;mouseLocation.v - theDocument-&gt;dropArea.top;  withData.vertexTolerance = withData.edgeTolerance = 3;  pickObject = Q3WindowPointPick_New(&amp;withData);  if (pickObject == NULL) {    return NULL;  }  Q3View_StartPicking(theDocument-&gt;theView, pickObject );  do {    Q3DisplayGroup_Submit(theDocument-&gt;documentGroup, theDocument-&gt;theView);  } while (Q3View_EndPicking(theDocument-&gt;theView) == kQ3ViewStatusRetraverse);      if (Q3Pick_GetNumHits(pickObject, &amp;numPicked) == kQ3Success &amp;&amp; (numPicked != 0)) {    TQ3Object      object;    TQ3PickDetail    validMask;    unsigned long    hitIndex = 1;    object = NULL;/*    TQ3HitData hitData;        // used to be: ErPick_GetFirstHit(pickObject, &amp;hitData);    Q3Pick_GetHitData( pickObject, 1, &amp;hitData );    Q3Object_Dispose(pickObject);    return(hitData.object);*/    if (Q3Pick_GetPickDetailValidMask(pickObject, hitIndex, &amp;validMask) == kQ3Success) {      /* Quick check to see if the hit contains an object and shape part */      if (validMask &amp; kQ3PickDetailMaskObject) {        /* Get reference to geometry object hit */        Q3Pick_GetPickDetailData(  pickObject,                      hitIndex,                      kQ3PickDetailMaskObject,                      &amp;object);      }    }    Q3Object_Dispose(pickObject);    return(object);  } else {    Q3Object_Dispose(pickObject);    return(NULL);  }}/* *  DoContent handles mouseDown events in the content region of a document window. * *  (1)  If the mouseDown is on a control, handle the click by calling TrackControl. * *  (2)  If the mouseDown is on a draggable object (the document's hiliteRgn) and a *    successful drag occurs, no further processing is necessary. * *  (3)  If the mouseDown is on a draggable object and the mouse is released without *    dragging, set the insertion point to the original mouseDown location by calling *    TEClick with the mouseDown information. * *  (4)  If the mouseDown is not on a draggable object and within the viewRect of the *    TextEdit field, call TEClick to handle the mouseDown. */void Podium_DoContent(DocumentPtr  theDocument, EventRecord *theEvent){  Point      thePoint;  SetPort(theDocument-&gt;theWindow);  thePoint = theEvent-&gt;where;  if( theDocument-&gt;documentGroup ) {    Point   newMouse, offset;    short  whichHandle;        GetMouse(&amp;newMouse);    theDocument-&gt;mouseLocation = newMouse;        /* First check for resize */    if( theDocument-&gt;currentlySelectedObject &amp;&amp; PtOnHandles(&amp;newMouse, &amp;theDocument-&gt;dropArea, &amp;whichHandle) ) {        Rect  previousRect;        Rect  frameRect;        Point   oldMouse;        TQ3Boolean  needRedraw;                PenMode(srcXor);        PenSize(2,2);        frameRect = previousRect = theDocument-&gt;dropArea;                oldMouse = theDocument-&gt;mouseLocation;        switch( whichHandle ){          case LeftTopHandle:                        offset.h = newMouse.h - frameRect.left;            offset.v = newMouse.v - frameRect.top;            while (WaitMouseUp()) {              GetMouse(&amp;newMouse);              if (newMouse.h &gt;= oldMouse.h +  2 || newMouse.h &lt;= oldMouse.h - 2 ||                  newMouse.v &gt;= oldMouse.v +  2 || newMouse.v &lt;= oldMouse.v - 2) {                    needRedraw = kQ3True;                  frameRect.left = newMouse.h - offset.h;                  frameRect.top = newMouse.v - offset.v;                  DrawHandles(&amp;previousRect);                  DrawHandles(&amp;frameRect);                  previousRect = frameRect;              }            }          break;          case RightTopHandle:                        offset.h = newMouse.h - frameRect.right;            offset.v = newMouse.v - frameRect.top;            while (WaitMouseUp()) {              GetMouse(&amp;newMouse);              if (newMouse.h &gt;= oldMouse.h +  2 || newMouse.h &lt;= oldMouse.h - 2 ||                  newMouse.v &gt;= oldMouse.v +  2 || newMouse.v &lt;= oldMouse.v - 2) {                    needRedraw = kQ3True;                  frameRect.right = newMouse.h - offset.h;                  frameRect.top = newMouse.v - offset.v;                  DrawHandles(&amp;previousRect);                  DrawHandles(&amp;frameRect);                  previousRect = frameRect;              }            }          break;          case LeftBottomHandle:                        offset.h = newMouse.h - frameRect.left;            offset.v = newMouse.v - frameRect.bottom;            while (WaitMouseUp()) {              GetMouse(&amp;newMouse);              if (newMouse.h &gt;= oldMouse.h +  2 || newMouse.h &lt;= oldMouse.h - 2 ||                  newMouse.v &gt;= oldMouse.v +  2 || newMouse.v &lt;= oldMouse.v - 2) {                    needRedraw = kQ3True;                  frameRect.left = newMouse.h - offset.h;                  frameRect.bottom = newMouse.v - offset.v;                  DrawHandles(&amp;previousRect);                  DrawHandles(&amp;frameRect);                  previousRect = frameRect;              }            }          break;          case RightBottomHandle:                        offset.h = newMouse.h - frameRect.right;            offset.v = newMouse.v - frameRect.bottom;            while (WaitMouseUp()) {              GetMouse(&amp;newMouse);              if (newMouse.h &gt;= oldMouse.h +  2 || newMouse.h &lt;= oldMouse.h - 2 ||                  newMouse.v &gt;= oldMouse.v +  2 || newMouse.v &lt;= oldMouse.v - 2) {                    needRedraw = kQ3True;                  frameRect.right = newMouse.h - offset.h;                  frameRect.bottom = newMouse.v - offset.v;                  DrawHandles(&amp;previousRect);                  DrawHandles(&amp;frameRect);                  previousRect = frameRect;              }            }          break;        }          theDocument-&gt;dropArea = frameRect;                if( needRedraw == kQ3True ) {          Podium_UpdateDrawContextFromDropRect( theDocument ) ;          DrawOffscreen(theDocument);          DrawOnscreen(theDocument);                  }                    PenMode(srcXor);        PenSize(2,2);        PenPat(&amp;qd.black);        DrawHandles(&amp;frameRect);    /* is it in content */    } else if( PtInRect(newMouse, &amp;theDocument-&gt;dropArea) ) {//      TQ3Object  newPick;//    if(( newPick = DoHitTest(theDocument)) != NULL) {      if( theDocument-&gt;selected == kQ3False) {        PenMode(srcXor);        PenSize(2,2);        PenPat(&amp;qd.black);        DrawHandles(&amp;theDocument-&gt;dropArea);      }            theDocument-&gt;currentlySelectedObject = theDocument-&gt;documentGroup ;            if( theEvent-&gt;modifiers &amp; shiftKey )        SetCursor(*zoomInCursor);      else if( theEvent-&gt;modifiers &amp; cmdKey )        SetCursor(*zoomOutCursor);      else        SetCursor(*objectCursor);          if( theEvent-&gt;modifiers &amp; shiftKey ) {        TQ3Matrix4x4  tmp;                Q3Matrix4x4_SetScale(&amp;tmp, 1.2, 1.2, 1.2);        while (WaitMouseUp()) {          Q3Matrix4x4_Multiply(&amp;tmp, &amp;theDocument-&gt;modelRotation, &amp;theDocument-&gt;modelRotation);          DrawOffscreen( theDocument ) ;          DrawOnscreen( theDocument ) ;        }      } else if( theEvent-&gt;modifiers &amp; cmdKey ) {        TQ3Matrix4x4  tmp;                Q3Matrix4x4_SetScale(&amp;tmp, 0.83333, 0.83333, 0.83333);        while (WaitMouseUp()) {          Q3Matrix4x4_Multiply(&amp;tmp, &amp;theDocument-&gt;modelRotation, &amp;theDocument-&gt;modelRotation);          DrawOffscreen(theDocument);          DrawOnscreen( theDocument ) ;        }      } else if( theEvent-&gt;modifiers &amp; controlKey ) {              Point   newMouse;        long   mouseChanged = 0;        long  dx, dy, oldX, oldY;        float  width, height;        float  xRot, yRot;                    SetCursor(*handCursor);        GetMouse(&amp;newMouse);    // get the mouse in local co-ordinates,                         // local to the  current GrafPort            oldX = newMouse.h;        oldY = newMouse.v;                width = theDocument-&gt;geometriesOffscreen-&gt;portRect.right - theDocument-&gt;geometriesOffscreen-&gt;portRect.left;        height =  theDocument-&gt;geometriesOffscreen-&gt;portRect.bottom - theDocument-&gt;geometriesOffscreen-&gt;portRect.top;          while (WaitMouseUp()) {                  GetMouse(&amp;newMouse);    // get the mouse in local co-ordinates,                         // local to the  current GrafPort            dx = newMouse.v - oldY;          dy = newMouse.h - oldX;                    if ((dx != 0) || (dy != 0)) {            TQ3Matrix4x4    tempMatrix;                        xRot = ((float) dx * kQ3Pi) / width;            yRot = ((float) dy * kQ3Pi) / height;                  if ((xRot != 0.0) || (yRot != 0.0)) {              Q3Matrix4x4_SetRotate_XYZ(&amp;tempMatrix, xRot, yRot, 0.0);              Q3Matrix4x4_Multiply(&amp;theDocument-&gt;modelRotation, &amp;tempMatrix, &amp;theDocument-&gt;modelRotation);                mouseChanged = 1;              DrawOffscreen(theDocument);              DrawOnscreen( theDocument ) ;            }          }          oldX = newMouse.h; oldY = newMouse.v;        }                if( mouseChanged ) {          theDocument-&gt;rotationDir.x = xRot;          theDocument-&gt;rotationDir.y = yRot;        }      } else {        Rect  previousRect;        Rect  frameRect;        Point   oldMouse;        TQ3Boolean  needRedraw;        long  height, width;                PenMode(srcXor);        PenSize(2,2);        frameRect = previousRect = theDocument-&gt;dropArea;        height = frameRect.bottom - frameRect.top;        width = frameRect.right - frameRect.left;                offset.h = newMouse.h - frameRect.left;        offset.v = newMouse.v - frameRect.top;                oldMouse = theDocument-&gt;mouseLocation;        while (WaitMouseUp()) {          GetMouse(&amp;newMouse);          if (newMouse.h &gt;= oldMouse.h +  2 || newMouse.h &lt;= oldMouse.h - 2 ||              newMouse.v &gt;= oldMouse.v +  2 || newMouse.v &lt;= oldMouse.v - 2) {                needRedraw = kQ3True;              frameRect.left = newMouse.h - offset.h;              frameRect.top = newMouse.v - offset.v;              frameRect.right = frameRect.left + width;              frameRect.bottom = frameRect.top + height;              DrawHandles(&amp;previousRect);              DrawHandles(&amp;frameRect);              previousRect = frameRect;          }        }          theDocument-&gt;dropArea = frameRect;                if( needRedraw == kQ3True ) {          Podium_UpdateDrawContextFromDropRect( theDocument ) ;          DrawOffscreen(theDocument);          DrawOnscreen(theDocument);                    }        PenMode(srcXor);        PenSize(2,2);        PenPat(&amp;qd.black);        DrawHandles(&amp;frameRect);      }    } else {      if( theDocument-&gt;selected == kQ3True) {        theDocument-&gt;currentlySelectedObject = NULL;        theDocument-&gt;selected = kQ3False;        PenMode(srcXor);        PenSize(2,2);        PenPat(&amp;qd.black);        DrawHandles(&amp;theDocument-&gt;dropArea);      }      SetCursor(&amp;qd.arrow);    }  }   else  {      if( theDocument-&gt;currentlySelectedObject ) {      theDocument-&gt;currentlySelectedObject = NULL;      PenMode(srcXor);      PenSize(2,2);      DrawHandles(&amp;theDocument-&gt;dropArea);      SetCursor(&amp;qd.arrow);    }  }}/* *  DoBackgroundContent handles mouseDown events in the content region of a document window *  when the window is not frontmost. The following bullet items describe how this background *  mouseDown event is handled: * *  (1)  If the mouseDown is not in a draggable object (not in the document's hiliteRgn) call *    SelectWindow to bring the window to the front as usual. * *  (2)  If the mouseDown is in a draggable object and the mouse is released without *    dragging, call SelectWindow when the mouse is released. * *  (3)  If the mouseDown is in a draggable object and a successful drag occurs, SelectWindow *    should only be called if the drop occurred in the same window (the DragText function *    calls SelectWindow in this case). */ void Podium_DoBackgroundContent(DocumentPtr  theDocument, EventRecord *theEvent){  Point      thePoint;  RgnHandle    tempRgn = NewRgn();  // Nick this needs to be the BBox of the group  SetPort(theDocument-&gt;theWindow);  thePoint = theEvent-&gt;where;  GlobalToLocal(&amp;thePoint);  RectRgn(tempRgn, &amp;theDocument-&gt;geometriesOffscreen-&gt;portRect);  if (PtInRgn(thePoint,tempRgn)) {    if (! DoDragObjects(theDocument, theEvent, tempRgn)) {      SelectWindow(theDocument-&gt;theWindow);    }  }   else {    SelectWindow(theDocument-&gt;theWindow);  }    DisposeRgn(tempRgn);}/* *  DoIdle get called repetitively while the application is not doing *  anything. */void Podium_DoIdle(EventRecord *theEvent){  WindowPtr    theWindow;  DocumentPtr  theDocument;  if ((theWindow = FrontWindow()) != nil) {    if ((theDocument = GetDocumentFromWindow(theWindow)) != nil) {      SetPort(theDocument-&gt;theWindow);      if( theDocument-&gt;documentGroup ) {        Point   mouseLocation;                GetMouse(&amp;mouseLocation);         theDocument-&gt;mouseLocation = mouseLocation;                  if( PointInRect(&amp;theDocument-&gt;mouseLocation, &amp;theDocument-&gt;dropArea) ) {          if(/*DoHitTest(theDocument)*/1) {            if( theEvent-&gt;modifiers &amp; shiftKey) {              SetCursor(*zoomInCursor);            } else if( theEvent-&gt;modifiers &amp; cmdKey) {              SetCursor(*zoomOutCursor);            } else if( theEvent-&gt;modifiers &amp; controlKey) {              SetCursor(*handCursor);            } else {              SetCursor(*objectCursor);            }          } else {            SetCursor(&amp;qd.arrow);          }        } else {          SetCursor(&amp;qd.arrow);        }                if( theDocument-&gt;animateModel == kQ3True) {          TQ3Matrix4x4  tmp;                    if( theDocument-&gt;rotationDir.x == 0.0 &amp;&amp; theDocument-&gt;rotationDir.y == 0.0 ) {            Q3Matrix4x4_SetRotate_XYZ(&amp;tmp, 0.03, 0.08, 0.0);            Q3Matrix4x4_Multiply(&amp;theDocument-&gt;modelRotation, &amp;tmp, &amp;theDocument-&gt;modelRotation);          } else {            Q3Matrix4x4_SetRotate_XYZ(&amp;tmp, theDocument-&gt;rotationDir.x, theDocument-&gt;rotationDir.y, 0.0);            Q3Matrix4x4_Multiply(&amp;theDocument-&gt;modelRotation, &amp;tmp, &amp;theDocument-&gt;modelRotation);          }          DrawOffscreen(theDocument);          DrawOnscreen(theDocument);        }      }    }  }}void Podium_Init(void){  objectCursor = GetCursor(132);  zoomInCursor = GetCursor(133);  zoomOutCursor = GetCursor(134);  handCursor = GetCursor(130);}#endif /* PODIUM_APP */</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Tumbler_and_Podium/listing30.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Tumbler_and_Podium/listing30.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Tumbler_and_Podium/listing30.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>