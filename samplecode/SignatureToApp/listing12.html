<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SignatureToApp - /MoreFiles Bits/Sources/MoreDesktopMgr.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxFileManagement-date.html">File Management</a> &gt; <A HREF="javascript:location.replace('index.html');">SignatureToApp</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxFileManagement-date.html" target="_blank">Carbon > File Management</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SignatureToApp</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MoreFiles Bits/Sources/MoreDesktopMgr.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CarbonPrefix.h</option>
<option value="listing2.html">/Launch.c</option>
<option value="listing3.html">/MoreFiles Bits/CHeaders/DirectoryCopy.h</option>
<option value="listing4.html">/MoreFiles Bits/CHeaders/FileCopy.h</option>
<option value="listing5.html">/MoreFiles Bits/CHeaders/FSpCompat.h</option>
<option value="listing6.html">/MoreFiles Bits/CHeaders/FullPath.h</option>
<option value="listing7.html">/MoreFiles Bits/CHeaders/IterateDirectory.h</option>
<option value="listing8.html">/MoreFiles Bits/CHeaders/MoreDesktopMgr.h</option>
<option value="listing9.html">/MoreFiles Bits/CHeaders/MoreFiles.h</option>
<option value="listing10.html">/MoreFiles Bits/CHeaders/MoreFilesExtras.h</option>
<option value="listing11.html">/MoreFiles Bits/CHeaders/Search.h</option>
<option value="listing12.html">/MoreFiles Bits/Sources/MoreDesktopMgr.c</option>
<option value="listing13.html">/MoreFiles Bits/Sources/MoreFiles.c</option>
<option value="listing14.html">/MoreFiles Bits/Sources/MoreFilesExtras.c</option>
<option value="listing15.html">/MoreFiles Bits/Sources/Optimization.h</option>
<option value="listing16.html">/MoreFiles Bits/Sources/OptimizationEnd.h</option>
<option value="listing17.html">/MoreFiles Bits/Sources/Search.c</option>
<option value="listing18.html">/SignatureToApp.c</option>
<option value="listing19.html">/SignatureToApp.h</option>
<option value="listing20.html">/Standard.r</option></select>
				</p>
				</form>
				<p><strong><a href="SignatureToApp.zip">Download Sample</a></strong> (&#147;SignatureToApp.zip&#148;, 188.2K)<BR>
<strong><a href="SignatureToApp.dmg">Download Sample</a></strong> (&#147;SignatureToApp.dmg&#148;, 267.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    MoreDesktopMgr.c  Contains:  A collection of useful high-level Desktop Manager routines.        If the Desktop Manager is not available, use the Desktop file        for 'read' operations.  Version:  MoreFiles  Copyright:  &copy; 1992-2001 by Apple Computer, Inc., all rights reserved.  You may incorporate this sample code into your applications without  restriction, though the sample code has been provided &quot;AS IS&quot; and the  responsibility for its operation is 100% yours.  However, what you are  not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;  after having made changes. If you're going to re-distribute the source,  we require that you make it clear in the source that the code was  descended from Apple Sample Code, but that you've made changes.  File Ownership:    DRI:        Apple Macintosh Developer Technical Support    Other Contact:    Apple Macintosh Developer Technical Support              &lt;http://developer.apple.com/bugreporter/&gt;    Technology:      DTS Sample Code  Writers:    (JL)  Jim Luther    (NG)  Nitin Ganatra  Change History (most recent first):     &lt;2&gt;    2/7/01  JL    Added standard header. Updated names of includes. Updated                  various routines to use new calling convention of the                  MoreFilesExtras accessor functions.    &lt;1&gt;    12/06/99  JL    MoreFiles 1.5.*/#include &lt;MacTypes.h&gt;#include &lt;MacErrors.h&gt;#include &lt;MacMemory.h&gt;#include &lt;Files.h&gt;#include &lt;Resources.h&gt;#include &lt;Icons.h&gt;#define  __COMPILINGMOREFILES#include &quot;MoreFiles.h&quot;#include &quot;MoreFilesExtras.h&quot;#include &quot;Search.h&quot;#include &quot;MoreDesktopMgr.h&quot;/*****************************************************************************//*  Desktop file notes:****  *  The Desktop file is owned by the Finder and is normally open by the**    Finder. That means that we only have read-only access to the Desktop**    file.**  *  Since the Resource Manager doesn't support shared access to resource**    files and we're using read-only access, we don't ever leave the**    Desktop file open.  We open a path to it, get the data we want out**    of it, and then close the open path. This is the only safe way to**    open a resource file with read-only access since some other program**    could have it open with write access.**  *  The bundle related resources in the Desktop file are normally**    purgable, so when we're looking through them, we don't bother to**    release resources we're done looking at - closing the resource file**    (which we always do) will release them.**  *  Since we can't assume the Desktop file is named &quot;Desktop&quot;**    (it probably is everywhere but France), we get the Desktop**    file's name by searching the volume's root directory for a file**    with fileType == 'FNDR' and creator == 'ERIK'. The only problem with**    this scheme is that someone could create another file with that type**    and creator in the root directory and we'd find the wrong file.**    The chances of this are very slim.*//*****************************************************************************//* local defines */enum{  kBNDLResType  = 'BNDL',  kFREFResType  = 'FREF',  kIconFamResType  = 'ICN#',  kFCMTResType  = 'FCMT',  kAPPLResType  = 'APPL'};/*****************************************************************************//* local data structures */#if PRAGMA_STRUCT_ALIGN#pragma options align=mac68k#endifstruct IDRec{  short    localID;  short    rsrcID;};typedef struct IDRec IDRec;typedef  IDRec *IDRecPtr;struct BundleType{  OSType    type;      /* 'ICN#' or 'FREF' */  short    count;      /* number of IDRecs - 1 */  IDRec    idArray[1];};typedef struct BundleType BundleType;typedef BundleType *BundleTypePtr;struct BNDLRec{  OSType    signature;    /* creator type signature */  short    versionID;    /* version - should always be 0 */  short    numTypes;    /* number of elements in typeArray - 1 */  BundleType  typeArray[1];};typedef struct BNDLRec BNDLRec;typedef BNDLRec **BNDLRecHandle;struct FREFRec{  OSType    fileType;    /* file type */  short    iconID;      /* icon local ID */  Str255    fileName;    /* file name */};typedef struct FREFRec FREFRec;typedef FREFRec **FREFRecHandle;struct APPLRec{  OSType    creator;    /* creator type signature */  long    parID;      /* parent directory ID */  Str255    applName;    /* application name */};typedef struct APPLRec APPLRec;typedef APPLRec *APPLRecPtr;#if PRAGMA_STRUCT_ALIGN#pragma options align=reset#endif/*****************************************************************************//* static prototypes */static  OSErr  GetDesktopFileName(short vRefNum,                   Str255 desktopName);static  OSErr  GetAPPLFromDesktopFile(ConstStr255Param volName,                     short vRefNum,                     OSType creator,                     short *applVRefNum,                     long *applParID,                     Str255 applName);static  OSErr  FindBundleGivenCreator(OSType creator,                     BNDLRecHandle *returnBndl);                     static  OSErr  FindTypeInBundle(OSType typeToFind,                 BNDLRecHandle theBndl,                 BundleTypePtr *returnBundleType);                     static  OSErr  GetLocalIDFromFREF(BundleTypePtr theBundleType,                   OSType fileType,                   short *iconLocalID);static  OSErr  GetIconRsrcIDFromLocalID(BundleTypePtr theBundleType,                     short iconLocalID,                     short *iconRsrcID);static  OSType  DTIconToResIcon(short iconType);static  OSErr  GetIconFromDesktopFile(ConstStr255Param volName,                     short vRefNum,                     short iconType,                     OSType fileCreator,                     OSType fileType,                     Handle *iconHandle);static  OSErr  GetCommentID(short vRefNum,               long dirID,               ConstStr255Param name,               short *commentID);static  OSErr  GetCommentFromDesktopFile(short vRefNum,                      long dirID,                      ConstStr255Param name,                      Str255 comment);/*****************************************************************************//***  GetDesktopFileName****  Get the name of the Desktop file.*/static  OSErr  GetDesktopFileName(short vRefNum,                   Str255 desktopName){  OSErr      error;  HParamBlockRec  pb;  short      index;  Boolean      found;    pb.fileParam.ioNamePtr = desktopName;  pb.fileParam.ioVRefNum = vRefNum;  pb.fileParam.ioFVersNum = 0;  index = 1;  found = false;  do  {    pb.fileParam.ioDirID = fsRtDirID;    pb.fileParam.ioFDirIndex = index;    error = PBHGetFInfoSync(&amp;pb);    if ( error == noErr )    {      if ( (pb.fileParam.ioFlFndrInfo.fdType == 'FNDR') &amp;&amp;         (pb.fileParam.ioFlFndrInfo.fdCreator == 'ERIK') )      {        found = true;      }    }    ++index;  } while ( (error == noErr) &amp;&amp; !found );    return ( error );}/*****************************************************************************/pascal  OSErr  DTOpen(ConstStr255Param volName,             short vRefNum,             short *dtRefNum,             Boolean *newDTDatabase){  OSErr error;  GetVolParmsInfoBuffer volParmsInfo;  long infoSize;  DTPBRec pb;    /* Check for volume Desktop Manager support before calling */  infoSize = sizeof(GetVolParmsInfoBuffer);  error = HGetVolParms(volName, vRefNum, &amp;volParmsInfo, &amp;infoSize);  if ( error == noErr )  {    if ( hasDesktopMgr(&amp;volParmsInfo) )    {      pb.ioNamePtr = (StringPtr)volName;      pb.ioVRefNum = vRefNum;      error = PBDTOpenInform(&amp;pb);      /* PBDTOpenInform informs us if the desktop was just created */      /* by leaving the low bit of ioTagInfo clear (0) */      *newDTDatabase = ((pb.ioTagInfo &amp; 1L) == 0);      if ( error == paramErr )      {        error = PBDTGetPath(&amp;pb);        /* PBDTGetPath doesn't tell us if the database is new */        /* so assume it is not new */        *newDTDatabase = false;      }      *dtRefNum = pb.ioDTRefNum;    }    else    {      error = paramErr;    }  }  return ( error );}/*****************************************************************************//***  GetAPPLFromDesktopFile****  Get a application's location from the**  Desktop file's 'APPL' resources.*/static  OSErr  GetAPPLFromDesktopFile(ConstStr255Param volName,                     short vRefNum,                     OSType creator,                     short *applVRefNum,                     long *applParID,                     Str255 applName){  OSErr error;  short realVRefNum;  Str255 desktopName;  short savedResFile;  short dfRefNum;  Handle applResHandle;  Boolean foundCreator;  Ptr applPtr;  long applSize;    error = DetermineVRefNum(volName, vRefNum, &amp;realVRefNum);  if ( error == noErr )  {    error = GetDesktopFileName(realVRefNum, desktopName);    if ( error == noErr )    {      savedResFile = CurResFile();      /*      **  Open the 'Desktop' file in the root directory. (because      **  opening the resource file could preload unwanted resources,      **  bracket the call with SetResLoad(s))      */      SetResLoad(false);      dfRefNum = HOpenResFile(realVRefNum, fsRtDirID, desktopName, fsRdPerm);      SetResLoad(true);            if ( dfRefNum != -1)      {        /* Get 'APPL' resource ID 0 */        applResHandle = Get1Resource(kAPPLResType, 0);        if ( applResHandle != NULL )        {          applSize = GetHandleSize((Handle)applResHandle);          if ( applSize != 0 )  /* make sure the APPL resource isn't empty */          {            foundCreator = false;            applPtr = *applResHandle;                        /* APPL's don't have a count so I have to use the size as the bounds */            while ( (foundCreator == false) &amp;&amp;                (applPtr &lt; (*applResHandle + applSize)) )            {              if ( ((APPLRecPtr)applPtr)-&gt;creator == creator )              {                foundCreator = true;              }              else              {                /* fun with pointer math... */                applPtr += sizeof(OSType) +                       sizeof(long) +                       ((APPLRecPtr)applPtr)-&gt;applName[0] + 1;                /* application mappings are word aligned within the resource */                if ( ((unsigned long)applPtr % 2) != 0 )                {                  applPtr += 1;                }              }            }            if ( foundCreator == true )            {              *applVRefNum = realVRefNum;              *applParID = ((APPLRecPtr)applPtr)-&gt;parID;              BlockMoveData(((APPLRecPtr)applPtr)-&gt;applName,                      applName,                      ((APPLRecPtr)applPtr)-&gt;applName[0] + 1);              /* error is already noErr */            }            else            {              error = afpItemNotFound;  /* didn't find a creator match */            }          }          else          {            error = afpItemNotFound;  /* no APPL mapping available */          }        }        else        {          error = afpItemNotFound;  /* no APPL mapping available */        }                /* restore the resource chain and close the Desktop file */        UseResFile(savedResFile);        CloseResFile(dfRefNum);      }      else      {        error = afpItemNotFound;      }    }  }    return ( error );}/*****************************************************************************/pascal  OSErr  DTXGetAPPL(ConstStr255Param volName,               short vRefNum,               OSType creator,               Boolean searchCatalog,               short *applVRefNum,               long *applParID,               Str255 applName){  OSErr error;  UniversalFMPB pb;  short dtRefNum;  Boolean newDTDatabase;  short realVRefNum;  short index;  Boolean applFound;  FSSpec spec;  long actMatchCount;    /* get the real vRefNum */  error = DetermineVRefNum(volName, vRefNum, &amp;realVRefNum);  if ( error == noErr )  {    error = DTOpen(volName, vRefNum, &amp;dtRefNum, &amp;newDTDatabase);    if ( error == noErr )    {      if ( !newDTDatabase )      {        index = 0;        applFound = false;        do        {          pb.dtPB.ioNamePtr = applName;          pb.dtPB.ioDTRefNum = dtRefNum;          pb.dtPB.ioIndex = index;          pb.dtPB.ioFileCreator = creator;          error = PBDTGetAPPLSync(&amp;pb.dtPB);          if ( error == noErr )          {            /* got a match - see if it is valid */                        *applVRefNum = realVRefNum; /* get the vRefNum now */            *applParID = pb.dtPB.ioAPPLParID; /* get the parent ID now */              /* pb.hPB.fileParam.ioNamePtr is already set */            pb.hPB.fileParam.ioVRefNum = realVRefNum;            pb.hPB.fileParam.ioFVersNum = 0;            pb.hPB.fileParam.ioDirID = *applParID;            pb.hPB.fileParam.ioFDirIndex = 0;  /* use ioNamePtr and ioDirID */            if ( PBHGetFInfoSync(&amp;pb.hPB) == noErr )            {              if ( (pb.hPB.fileParam.ioFlFndrInfo.fdCreator == creator) &amp;&amp;                 (pb.hPB.fileParam.ioFlFndrInfo.fdType == 'APPL') )              {                applFound = true;              }            }          }          ++index;        } while ( (error == noErr) &amp;&amp; !applFound );        if ( error != noErr )        {          error = afpItemNotFound;        }      }      else      {        /* Desktop database is empty (new), set error to try CatSearch */        error = afpItemNotFound;      }    }    /* acceptable errors from Desktop Manager to continue are paramErr or afpItemNotFound */    if ( error == paramErr )    {      /* if paramErr, the volume didn't support the Desktop Manager */      /* try the Desktop file */            error = GetAPPLFromDesktopFile(volName, vRefNum, creator,                      applVRefNum, applParID, applName);      if ( error == noErr )      {        /* got a match - see if it is valid */                pb.hPB.fileParam.ioNamePtr = applName;        pb.hPB.fileParam.ioVRefNum = *applVRefNum;        pb.hPB.fileParam.ioFVersNum = 0;        pb.hPB.fileParam.ioDirID = *applParID;        pb.hPB.fileParam.ioFDirIndex = 0;  /* use ioNamePtr and ioDirID */        if ( PBHGetFInfoSync(&amp;pb.hPB) == noErr )        {          if ( (pb.hPB.fileParam.ioFlFndrInfo.fdCreator != creator) ||             (pb.hPB.fileParam.ioFlFndrInfo.fdType != 'APPL') )          {            error = afpItemNotFound;          }        }        else if ( error == fnfErr )        {          error = afpItemNotFound;        }      }    }    /* acceptable error from DesktopFile code to continue is afpItemNotFound */    if ( (error == afpItemNotFound) &amp;&amp; searchCatalog)    {      /* Couldn't be found in the Desktop file either, */      /* try searching with CatSearch if requested */            error = CreatorTypeFileSearch(NULL, realVRefNum, creator, kAPPLResType, &amp;spec, 1,                      &amp;actMatchCount, true);      if ( (error == noErr) || (error == eofErr) )      {        if ( actMatchCount &gt; 0 )        {          *applVRefNum = spec.vRefNum;          *applParID = spec.parID;          BlockMoveData(spec.name, applName, spec.name[0] + 1);        }        else        {          error = afpItemNotFound;        }      }    }  }    return ( error );}/*****************************************************************************/pascal  OSErr  FSpDTXGetAPPL(ConstStr255Param volName,                short vRefNum,                OSType creator,                Boolean searchCatalog,                FSSpec *spec){  return ( DTXGetAPPL(volName, vRefNum, creator, searchCatalog,            &amp;(spec-&gt;vRefNum), &amp;(spec-&gt;parID), spec-&gt;name) );}/*****************************************************************************/pascal  OSErr  DTGetAPPL(ConstStr255Param volName,              short vRefNum,              OSType creator,              short *applVRefNum,              long *applParID,              Str255 applName){  /* Call DTXGetAPPL with the &quot;searchCatalog&quot; parameter true */   return ( DTXGetAPPL(volName, vRefNum, creator, true,            applVRefNum, applParID, applName) );}/*****************************************************************************/pascal  OSErr  FSpDTGetAPPL(ConstStr255Param volName,               short vRefNum,               OSType creator,               FSSpec *spec){  /* Call DTXGetAPPL with the &quot;searchCatalog&quot; parameter true */   return ( DTXGetAPPL(volName, vRefNum, creator, true,            &amp;(spec-&gt;vRefNum), &amp;(spec-&gt;parID), spec-&gt;name) );}/*****************************************************************************//***  FindBundleGivenCreator****  Search the current resource file for the 'BNDL' resource with the given**  creator and return a handle to it.*/static  OSErr  FindBundleGivenCreator(OSType creator,                     BNDLRecHandle *returnBndl){  OSErr      error;  short      numOfBundles;  short      index;  BNDLRecHandle  theBndl;    error = afpItemNotFound;  /* default to not found */    /* Search each BNDL resource until we find the one with a matching creator. */    numOfBundles = Count1Resources(kBNDLResType);  index = 1;  *returnBndl = NULL;    while ( (index &lt;= numOfBundles) &amp;&amp; (*returnBndl == NULL) )  {    theBndl = (BNDLRecHandle)Get1IndResource(kBNDLResType, index);        if ( theBndl != NULL )    {      if ( (*theBndl)-&gt;signature == creator )      {        /* numTypes and typeArray-&gt;count will always be the actual count minus 1, */        /* so 0 in both fields is valid. */        if ( ((*theBndl)-&gt;numTypes &gt;= 0) &amp;&amp; ((*theBndl)-&gt;typeArray-&gt;count &gt;= 0) )        {          /* got it */          *returnBndl = theBndl;          error = noErr;        }      }    }          index ++;  }    return ( error );}/*****************************************************************************//***  FindTypeInBundle****  Given a Handle to a BNDL return a pointer to the desired type**  in it. If the type is not found, or if the type's count &lt; 0,**  return afpItemNotFound.*/static  OSErr  FindTypeInBundle(OSType typeToFind,                 BNDLRecHandle theBndl,                 BundleTypePtr *returnBundleType){  OSErr      error;  short      index;  Ptr        ptrIterator;  /* use a Ptr so we can do ugly pointer math */    error = afpItemNotFound;  /* default to not found */    ptrIterator = (Ptr)((*theBndl)-&gt;typeArray);  index = 0;  *returnBundleType = NULL;  while ( (index &lt; ((*theBndl)-&gt;numTypes + 1)) &amp;&amp;      (*returnBundleType == NULL) )  {    if ( (((BundleTypePtr)ptrIterator)-&gt;type == typeToFind) &amp;&amp;       (((BundleTypePtr)ptrIterator)-&gt;count &gt;= 0) )    {        *returnBundleType = (BundleTypePtr)ptrIterator;        error = noErr;    }    else    {      ptrIterator += ( sizeof(OSType) +               sizeof(short) +               ( sizeof(IDRec) * (((BundleTypePtr)ptrIterator)-&gt;count + 1) ) );      ++index;    }  }      return ( error );}/*****************************************************************************//***  GetLocalIDFromFREF****  Given a pointer to a 'FREF' BundleType record, load each 'FREF' resource**  looking for a matching fileType. If a matching fileType is found, return**  its icon local ID. If no match is found, return afpItemNotFound as the**  function result.*/static  OSErr  GetLocalIDFromFREF(BundleTypePtr theBundleType,                   OSType fileType,                   short *iconLocalID){  OSErr      error;  short      index;  IDRecPtr    idIterator;  FREFRecHandle  theFref;    error = afpItemNotFound;  /* default to not found */    /* For each localID in this type, get the FREF resource looking for fileType */  index = 0;  idIterator = &amp;theBundleType-&gt;idArray[0];  *iconLocalID = 0;    while ( (index &lt;= theBundleType-&gt;count) &amp;&amp; (*iconLocalID == 0) )  {    theFref = (FREFRecHandle)Get1Resource(kFREFResType, idIterator-&gt;rsrcID);    if ( theFref != NULL )    {      if ( (*theFref)-&gt;fileType == fileType )      {        *iconLocalID = (*theFref)-&gt;iconID;        error = noErr;      }    }        ++idIterator;    ++index;  }    return ( error );}/*****************************************************************************//***  GetIconRsrcIDFromLocalID****  Given a pointer to a 'ICN#' BundleType record, look for the IDRec with**  the localID that matches iconLocalID. If a matching IDRec is found,**  return the IDRec's rsrcID field value. If no match is found, return**  afpItemNotFound as the function result.*/static  OSErr  GetIconRsrcIDFromLocalID(BundleTypePtr theBundleType,                     short iconLocalID,                     short *iconRsrcID){  OSErr    error;  short    index;  IDRecPtr  idIterator;    error = afpItemNotFound;  /* default to not found */    /* Find the rsrcID of the icon family type, given the localID */  index = 0;  idIterator = &amp;theBundleType-&gt;idArray[0];  *iconRsrcID = 0;    while ( (index &lt;= theBundleType-&gt;count) &amp;&amp; (*iconRsrcID == 0) )  {    if ( idIterator-&gt;localID == iconLocalID )    {      *iconRsrcID = idIterator-&gt;rsrcID;      error = noErr;    }        idIterator ++;    index ++;  }    return ( error );}/*****************************************************************************//***  DTIconToResIcon****  Map a Desktop Manager icon type to the corresponding resource type.**  Return (OSType)0 if there is no corresponding resource type.*/static  OSType  DTIconToResIcon(short iconType){  OSType  resType;    switch ( iconType )  {    case kLargeIcon:      resType = large1BitMask;      break;    case kLarge4BitIcon:      resType = large4BitData;      break;    case kLarge8BitIcon:      resType = large8BitData;      break;    case kSmallIcon:      resType = small1BitMask;      break;    case kSmall4BitIcon:      resType = small4BitData;      break;    case kSmall8BitIcon:      resType = small8BitData;      break;    default:      resType = (OSType)0;      break;  }    return ( resType );}/*****************************************************************************//***  GetIconFromDesktopFile****  INPUT a pointer to a non-existent Handle, because we'll allocate one****  search each BNDL resource for the right fileCreator and once we get it**    find the 'FREF' type in BNDL**    for each localID in the type, open the FREF resource**      if the FREF is the desired fileType**        get its icon localID**        get the ICN# type in BNDL**        get the icon resource number from the icon localID**        get the icon resource type from the desktop mgr's iconType**        get the icon of that type and number*/static  OSErr  GetIconFromDesktopFile(ConstStr255Param volName,                     short vRefNum,                     short iconType,                     OSType fileCreator,                     OSType fileType,                     Handle *iconHandle){  OSErr      error;  short      realVRefNum;  Str255      desktopName;  short      savedResFile;  short      dfRefNum;  BNDLRecHandle  theBndl = NULL;  BundleTypePtr  theBundleType;  short      iconLocalID;  short      iconRsrcID;  OSType      iconRsrcType;  Handle      returnIconHandle;    char      bndlState;    *iconHandle = NULL;    error = DetermineVRefNum(volName, vRefNum, &amp;realVRefNum);  if ( error == noErr )  {    error = GetDesktopFileName(realVRefNum, desktopName);    if ( error == noErr )    {      savedResFile = CurResFile();          /*      **  Open the 'Desktop' file in the root directory. (because      **  opening the resource file could preload unwanted resources,      **  bracket the call with SetResLoad(s))      */      SetResLoad(false);      dfRefNum = HOpenResFile(realVRefNum, fsRtDirID, desktopName, fsRdPerm);      SetResLoad(true);          if ( dfRefNum != -1 )      {        /*        **  Find the BNDL resource with the specified creator.        */        error = FindBundleGivenCreator(fileCreator, &amp;theBndl);        if ( error == noErr )        {          /* Lock the BNDL resource so it won't be purged when other resources are loaded */          bndlState = HGetState((Handle)theBndl);          HLock((Handle)theBndl);                    /* Find the 'FREF' BundleType record in the BNDL resource. */          error = FindTypeInBundle(kFREFResType, theBndl, &amp;theBundleType);          if ( error == noErr )          {            /* Find the local ID in the 'FREF' resource with the specified fileType */            error = GetLocalIDFromFREF(theBundleType, fileType, &amp;iconLocalID);            if ( error == noErr )            {              /* Find the 'ICN#' BundleType record in the BNDL resource. */              error = FindTypeInBundle(kIconFamResType, theBndl, &amp;theBundleType);              if ( error == noErr )              {                /* Find the icon's resource ID in the 'ICN#' BundleType record */                error = GetIconRsrcIDFromLocalID(theBundleType, iconLocalID, &amp;iconRsrcID);                if ( error == noErr )                {                  /* Map Desktop Manager icon type to resource type */                  iconRsrcType = DTIconToResIcon(iconType);                                    if ( iconRsrcType != (OSType)0 )                  {                    /* Load the icon */                    returnIconHandle = Get1Resource(iconRsrcType, iconRsrcID);                    if ( returnIconHandle != NULL )                    {                      /* Copy the resource handle, and return the copy */                      HandToHand(&amp;returnIconHandle);                      if ( MemError() == noErr )                      {                        *iconHandle = returnIconHandle;                      }                      else                      {                        error = afpItemNotFound;                      }                    }                    else                    {                      error = afpItemNotFound;                    }                  }                }              }            }          }          /* Restore the state of the BNDL resource */           HSetState((Handle)theBndl, bndlState);        }        /* Restore the resource chain and close the Desktop file */        UseResFile(savedResFile);        CloseResFile(dfRefNum);      }      else      {        error = ResError(); /* could not open Desktop file */      }    }    if ( (error != noErr) &amp;&amp; (error != memFullErr) )    {      error = afpItemNotFound;  /* force an error we should return */    }  }    return ( error );}/*****************************************************************************/pascal  OSErr  DTGetIcon(ConstStr255Param volName,              short vRefNum,              short iconType,              OSType fileCreator,              OSType fileType,              Handle *iconHandle){  OSErr error;  DTPBRec pb;  short dtRefNum;  Boolean newDTDatabase;  Size bufferSize;    *iconHandle = NULL;  error = DTOpen(volName, vRefNum, &amp;dtRefNum, &amp;newDTDatabase);  if ( error == noErr )  {    /* there was a desktop database and it's now open */        if ( !newDTDatabase )  /* don't bother to look in a new (empty) database */    {      /* get the buffer size for the requested icon type */      switch ( iconType )      {        case kLargeIcon:          bufferSize = kLargeIconSize;          break;        case kLarge4BitIcon:          bufferSize = kLarge4BitIconSize;          break;        case kLarge8BitIcon:          bufferSize = kLarge8BitIconSize;          break;        case kSmallIcon:          bufferSize = kSmallIconSize;          break;        case kSmall4BitIcon:          bufferSize = kSmall4BitIconSize;          break;        case kSmall8BitIcon:          bufferSize = kSmall8BitIconSize;          break;        default:          iconType = 0;          bufferSize = 0;          break;      }      if ( bufferSize != 0 )      {        *iconHandle = NewHandle(bufferSize);        if ( *iconHandle != NULL )        {          HLock(*iconHandle);              pb.ioDTRefNum = dtRefNum;          pb.ioTagInfo = 0;          pb.ioDTBuffer = **iconHandle;          pb.ioDTReqCount = bufferSize;          pb.ioIconType = iconType;          pb.ioFileCreator = fileCreator;          pb.ioFileType = fileType;          error = PBDTGetIconSync(&amp;pb);            HUnlock(*iconHandle);                    if ( error != noErr )          {            DisposeHandle(*iconHandle);  /* dispose of the allocated memory */            *iconHandle = NULL;          }        }        else        {          error = memFullErr;  /* handle could not be allocated */        }      }      else      {        error = paramErr;  /* unknown icon type requested */      }    }    else    {      error = afpItemNotFound;  /* the desktop database was empty - nothing to return */    }  }  else  {    /* There is no desktop database - try the Desktop file */        error = GetIconFromDesktopFile(volName, vRefNum, iconType,                    fileCreator, fileType, iconHandle);  }    return ( error );}/*****************************************************************************/pascal  OSErr  DTSetComment(short vRefNum,               long dirID,               ConstStr255Param name,               ConstStr255Param comment){  DTPBRec pb;  OSErr error;  short dtRefNum;  Boolean newDTDatabase;  error = DTOpen(name, vRefNum, &amp;dtRefNum, &amp;newDTDatabase);  if ( error == noErr )  {    pb.ioDTRefNum = dtRefNum;    pb.ioNamePtr = (StringPtr)name;    pb.ioDirID = dirID;    pb.ioDTBuffer = (Ptr)&amp;comment[1];    /* Truncate the comment to 200 characters just in case */    /* some file system doesn't range check */    if ( comment[0] &lt;= 200 )    {      pb.ioDTReqCount = comment[0];    }    else    {      pb.ioDTReqCount = 200;    }    error = PBDTSetCommentSync(&amp;pb);  }  return (error);}/*****************************************************************************/pascal  OSErr  FSpDTSetComment(const FSSpec *spec,                ConstStr255Param comment){  return (DTSetComment(spec-&gt;vRefNum, spec-&gt;parID, spec-&gt;name, comment));}/*****************************************************************************//***  GetCommentID****  Get the comment ID number for the Desktop file's 'FCMT' resource ID from**  the file or folders fdComment (frComment) field.*/static  OSErr  GetCommentID(short vRefNum,               long dirID,               ConstStr255Param name,               short *commentID){  CInfoPBRec pb;  OSErr error;  error = GetCatInfoNoName(vRefNum, dirID, name, &amp;pb);  *commentID = pb.hFileInfo.ioFlXFndrInfo.fdComment;  return ( error );}/*****************************************************************************//***  GetCommentFromDesktopFile****  Get a file or directory's Finder comment field (if any) from the**  Desktop file's 'FCMT' resources.*/static  OSErr  GetCommentFromDesktopFile(short vRefNum,                      long dirID,                      ConstStr255Param name,                      Str255 comment){  OSErr error;  short commentID;  short realVRefNum;  Str255 desktopName;  short savedResFile;  short dfRefNum;  StringHandle commentHandle;    /* Get the comment ID number */  error = GetCommentID(vRefNum, dirID, name, &amp;commentID);  if ( error == noErr )  {    if ( commentID != 0 )  /* commentID == 0 means there's no comment */    {      error = DetermineVRefNum(name, vRefNum, &amp;realVRefNum);      if ( error == noErr )      {        error = GetDesktopFileName(realVRefNum, desktopName);        if ( error == noErr )        {          savedResFile = CurResFile();          /*          **  Open the 'Desktop' file in the root directory. (because          **  opening the resource file could preload unwanted resources,          **  bracket the call with SetResLoad(s))          */          SetResLoad(false);          dfRefNum = HOpenResFile(realVRefNum, fsRtDirID, desktopName, fsRdPerm);          SetResLoad(true);                    if ( dfRefNum != -1)          {            /* Get the comment resource */            commentHandle = (StringHandle)Get1Resource(kFCMTResType,commentID);            if ( commentHandle != NULL )            {              if ( GetHandleSize((Handle)commentHandle) &gt; 0 )              {                BlockMoveData(*commentHandle, comment, *commentHandle[0] + 1);              }              else              {                error = afpItemNotFound;  /* no comment available */              }            }            else            {              error = afpItemNotFound;  /* no comment available */            }                        /* restore the resource chain and close the Desktop file */            UseResFile(savedResFile);            CloseResFile(dfRefNum);          }          else          {            error = afpItemNotFound;          }        }        else        {          error = afpItemNotFound;        }      }    }    else    {      error = afpItemNotFound;  /* no comment available */    }  }    return ( error );}/*****************************************************************************/pascal  OSErr  DTGetComment(short vRefNum,               long dirID,               ConstStr255Param name,               Str255 comment){  DTPBRec pb;  OSErr error;  short dtRefNum;  Boolean newDTDatabase;  if (comment != NULL)  {    comment[0] = 0;  /* return nothing by default */        /* attempt to open the desktop database */    error = DTOpen(name, vRefNum, &amp;dtRefNum, &amp;newDTDatabase);    if ( error == noErr )    {      /* There was a desktop database and it's now open */            if ( !newDTDatabase )      {        pb.ioDTRefNum = dtRefNum;        pb.ioNamePtr = (StringPtr)name;        pb.ioDirID = dirID;        pb.ioDTBuffer = (Ptr)&amp;comment[1];        /*        **  IMPORTANT NOTE #1: Inside Macintosh says that comments        **  are up to 200 characters. While that may be correct for        **  the HFS file system's Desktop Manager, other file        **  systems (such as Apple Photo Access) return up to        **  255 characters. Make sure the comment buffer is a Str255        **  or you'll regret it.        **        **  IMPORTANT NOTE #2: Although Inside Macintosh doesn't        **  mention it, ioDTReqCount is a input field to        **  PBDTGetCommentSync. Some file systems (like HFS) ignore        **  ioDTReqCount and always return the full comment --        **  others (like AppleShare) respect ioDTReqCount and only        **  return up to ioDTReqCount characters of the comment.        */        pb.ioDTReqCount = sizeof(Str255) - 1;        error = PBDTGetCommentSync(&amp;pb);        if (error == noErr)        {          comment[0] = (unsigned char)pb.ioDTActCount;        }      }    }    else    {      /* There is no desktop database - try the Desktop file */      error = GetCommentFromDesktopFile(vRefNum, dirID, name, comment);      if ( error != noErr )      {        error = afpItemNotFound;  /* return an expected error */      }    }  }  else  {    error = paramErr;  }    return (error);}/*****************************************************************************/pascal  OSErr  FSpDTGetComment(const FSSpec *spec,                Str255 comment){  return (DTGetComment(spec-&gt;vRefNum, spec-&gt;parID, spec-&gt;name, comment));}/*****************************************************************************/pascal  OSErr  DTCopyComment(short srcVRefNum,                long srcDirID,                ConstStr255Param srcName,                short dstVRefNum,                long dstDirID,                ConstStr255Param dstName)/* The destination volume must support the Desktop Manager for this to work */{  OSErr error;  Str255 comment;  error = DTGetComment(srcVRefNum, srcDirID, srcName, comment);  if ( (error == noErr) &amp;&amp; (comment[0] &gt; 0) )  {    error = DTSetComment(dstVRefNum, dstDirID, dstName, comment);  }  return (error);}/*****************************************************************************/pascal  OSErr  FSpDTCopyComment(const FSSpec *srcSpec,                 const FSSpec *dstSpec)/* The destination volume must support the Desktop Manager for this to work */{  return (DTCopyComment(srcSpec-&gt;vRefNum, srcSpec-&gt;parID, srcSpec-&gt;name,            dstSpec-&gt;vRefNum, dstSpec-&gt;parID, dstSpec-&gt;name));}/*****************************************************************************/</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SignatureToApp/listing12.html%3Fid%3DDTS10000755-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SignatureToApp/listing12.html%3Fid%3DDTS10000755-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SignatureToApp/listing12.html%3Fid%3DDTS10000755-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>