<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Shark User Guide: Other Profiling and Tracing Techniques</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Other Profiling and Tracing Techniques"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005233-CH6" title="Other Profiling and Tracing Techniques"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../Performance-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000901" target="_top">Performance</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40005233-CH1-DontLinkElementID_6">Shark User Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../SystemTracing/SystemTracing.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../SelectingExecutiontoSampleorTrace/SelectingExecutiontoSampleorTrace.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005233-CH6-SW17" title="Other Profiling and Tracing Techniques"></a><h1>Other Profiling and Tracing Techniques</h1><p>Not every performance problem stems from computation in a program or a program’s interaction with the operating system. For these other types of problems, Shark provides a number of profiling and tracing configurations that focus on individual types of performance problems. Any of them may be chosen using the configuration list in the main Shark window before pressing “Start.”</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW18">Time Profile (All Thread States)</a>
				
			<br/>
			
        
			
			
				<a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW16">Malloc Trace</a>
				
			<br/>
			
        
			
			
				<a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW19">Static Analysis</a>
				
			<br/>
			
        
			
			
				<a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW20">Using Shark with Java Programs</a>
				
			<br/>
			
        
			
			
				<a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW21">Event Counting and Profiling Overview</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005233-CH6-SW18" title="Time Profile (All Thread States)"></a><h2>Time Profile (All Thread States)</h2><p>When doing certain types of operations, a program can temporarily stop running while it waits on some other event to finish. This is commonly referred to as <em>blocking</em>. Blocking can be the source of many performance problems. Portions of programs, such as startup routines, making heavy use of library calls can accidentally waste a significant amount of time blocked at various points within those calls. In heavily multithreaded programs, time spent blocking at locks and barriers is another serious source of performance loss.</p><p>Since a program is not running while it is blocked, <em>Time Profile</em> will not take many samples in routines that spend large amounts of time being blocked. To provide some insight into blocking, Shark offers the <em>Time Profile (All Thread States)</em> configuration. This configuration is similar to <em>Time Profile</em>, but with one key difference: it takes samples of <em>all</em> threads, whether they are blocked or running. With this information, you can get a good idea about how often your threads are blocked, and where in your code the blocking calls are being made.</p><p>Like <em>Time Profile</em>, <em>Time Profile (All Thread States)</em> can be used to look at blocking behavior of a single application or the whole system by selecting the appropriate option in the target list in Shark’s main window. While the default settings for this configuration are often sufficient, you can also select many useful options in the mini-configuration editor (see <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW10">“Mini Configuration Editors”</a></span>), as shown in <span class="content_text">Figure 4-1</span>. Here is a list of options:</p><ol class="ol"><li class="li"><p><strong>Start Delay</strong>— Amount of time to wait after the user selects “Start” before data collection actually begins.</p></li><li class="li"><p><strong>Sample Interval</strong>— Determine the trigger for taking a sample. The interval is a time period (10 ms default).</p></li><li class="li"><p><strong>Time Limit</strong>— The maximum amount of time to record samples. This is ignored if Sample Limit is enabled and reached before the time limit expires.</p></li><li class="li"><p><strong>Sample Limit </strong>— The maximum number of samples to record. Specifying a maximum of <em>N</em> samples will result in at most <em>N</em> samples being taken, even on a multi-processor system, so this should be scaled up as larger systems are sampled. When the sample limit is reached, data collection automatically stops. This is ignored if the <em>Time Limit </em> is enabled and expires first.</p></li><li class="li"><p><strong>Prefer User Callstacks</strong>— When enabled, Shark will ignore and discard any samples from threads running exclusively in the kernel. This can eliminate spurious samples from places such as idle threads and interrupt handlers, if your program is not affected by these.</p></li><li class="li"><p><strong>Trim Supervisor Callstacks</strong>— When enabled, Shark will automatically trim the recorded callstacks for threads calling into the kernel down to the kernel entry points, and discarding the parts of the stack from within the kernel itself. These shortened stacks are usually sufficient, since most performance problems in your programs can be debugged without knowing about how the kernel is running internally. You just need to know how and when your code is blocking, and not how Mac OS X is actually processing the blocking operation itself.</p></li></ol><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW8" title="Figure 4-1Time Profile (All Thread States) mini configuration editor"></a><p><strong>Figure 4-1&nbsp;&nbsp;</strong>Time Profile (All Thread States) mini configuration editor</p><img src = "../Art/TPATS_miniconfig.jpg" alt = "Time Profile (All Thread States) mini configuration editor" ></div><br/><p>After you record a <em>Time Profile (All Thread States)</em> session, you will be presented with a profile browser window that looks almost exactly like one you might see after recording a conventional <em>Time Profile</em>. However, there are some subtle differences, as you can see in the profile of “Safari” while idle in <span class="content_text">Figure 4-2</span> and <span class="content_text">Figure 4-3</span>.</p><p>All threads have exactly the same number of samples, since Shark recorded samples for them whether they were running or not. With 9 threads, as we have in this example, all threads have exactly 1/9 of the samples, or 11.1%. This “even-division-of-samples” rule will always hold true for <em>Time Profile (All Thread States)</em> sessions, unless you happen to sample an application that is actively creating and destroying threads while it is being measured, because <em>Time Profile (All Thread States)</em> always records samples for all threads at each sample point, whether they are blocking or not. This trend can be less obvious if your threads are actively calling many different routines over the course of the measurement, but it generally holds. This kind of behavior is much less common in conventional <em>Time Profile</em>s, because almost all threads block occasionally during the time that Shark samples them.</p><p>With “Heavy” view, as shown in <span class="content_text">Figure 4-2</span>, you will mostly see Mac OS X’s primitive blocking routines like <code>pthread_mutex_lock</code>, <code>pthread_cond_wait</code>, <code>mach_msg_trap</code>, <code>semaphore_timedwait_signal_trap</code>, <code>select</code>, and similar functions popping up to the top of the browser window. This view is mostly useful for showing you how much time your threads are blocked and how often they are running. As a result, it is a good “sanity check” technique to make sure that threads that are supposed to be CPU-bound are not accidentally wasting time blocked, and that threads that are supposed to be blocked really are idle.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW10" title="Figure 4-2Time Profile (All Thread States) session, heavy view"></a><p><strong>Figure 4-2&nbsp;&nbsp;</strong>Time Profile (All Thread States) session, heavy view</p><img src = "../Art/TPATS_Heavy.jpg" alt = "Time Profile (All Thread States) session, heavy view" ></div><br/><p>Unfortunately, this does not tell you the most important information: why <em>your</em> code is calling these routines and hence blocking. It is possible to get this information by opening up disclosure triangles in “Heavy” view, but generally “Tree” view, as shown in <span class="content_text">Figure 4-3</span>, is the best way to track down this information. By flicking a few disclosure triangles open, this view lets you logically follow your code paths until you reach a point where they call blocking library routines. At that point, and possibly with the help of a code browser, you should be able to get a good idea of which parts of your code are blocking, and how frequently this blocking is occurring.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW9" title="Figure 4-3Time Profile (All Thread States) session, tree view"></a><p><strong>Figure 4-3&nbsp;&nbsp;</strong>Time Profile (All Thread States) session, tree view</p><img src = "../Art/TPATS_Tree.jpg" alt = "Time Profile (All Thread States) session, tree view" ></div><br/><p><em>Time Profile (All Thread States)</em> can often allow you to track down and solve multithreaded blocking problems in your applications by itself. However, it also works well in conjunction with <em>System Trace</em>. After you identify <em>which</em> code that is blocking too often with <em>Time Profile (All Thread States)</em>, if you cannot determine <em>why</em> the code is blocking, then the precise recording of blocking timing provided by <em>System Trace</em> can often help by letting you see the precise timing of blocks as multiple threads compete for resources. Conversely, using <em>System Trace</em> without <em>Time Profile (All Thread States)</em> can often be difficult, because it is fairly easy to get overwhelmed with data while examining a <em>System Trace</em>. Performing a <em>Time Profile (All Thread States)</em> first can be very helpful, since it can let you know <em>which</em> bits of blocking code are the most important before you look for them in a <em>System Trace</em>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005233-CH6-DontLinkElementID_8" title="Note regarding launched target processes"></a><p><strong>Note regarding launched target processes:</strong>&nbsp;When launching a process (as described in <span class="content_text"><a href="../SelectingExecutiontoSampleorTrace/SelectingExecutiontoSampleorTrace.html#//apple_ref/doc/uid/TP40005233-CH13-SW13">“Process Launch”</a></span>) with <em>Time Profile (All Thread States)</em>, you may notice samples in <code>_dyld_start</code>.  Since Shark starts sampling the process before the launched process begins executing, some samples will fall in this method.  When profiling launch time in this way, you will want to make sure that you skip past all these samples before paying attention to the results or use data mining to remove all callstacks with this symbol.</p></div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW16" title="Malloc Trace"></a><h2>Malloc Trace</h2><p>In today’s large and complex software applications, it is often informative to understand the scope and pattern of memory allocations and deallocations. If you understand how your software objects are being created and destroyed, you can often improve the overall performance of your application significantly, since memory allocation is a very expensive operation in Mac OS X, especially for large blocks of memory. If your program suffers from memory leaks, <em>Malloc Trace</em> is also a good way to identify locations in your program that may be the culprits.</p><p>To collect an exact trace of memory allocation and freeing function calls, select <em>Malloc Trace</em> in the configuration list. Unlike with most configurations in Shark, you <em>must</em> choose a particular process to examine with this configuration. In its mini configuration editor (see <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW10">“Mini Configuration Editors”</a></span>), shown in <span class="content_text">Figure 4-4</span>, <em>Malloc Trace</em> offers the following tuning options to help refine the memory events that are collected:</p><ol class="ol"><li class="li"><p><strong>Record Only Active Blocks</strong>— Collect only memory allocations that were not released during the collection period (the default). It is most useful for catching memory leaks. If turned off, any allocation or deallocation that takes place is recorded, an option that is more useful when you are just attempting to reduce the overall number of allocations that occur.</p></li><li class="li"><p><strong>Time Limit</strong>— Specify a maximum length of time to collect a profile. After this amount of time has elapsed since the start of collection, Shark will automatically stop collecting the profile.</p></li><li class="li"><p><strong>Start Delay</strong>— Specify a length of time that Shark should wait after being told to start collecting a profile before the collection begins. If the program action to be profiled requires a sequence of actions to start, this option can be used to delay the start until after the setup actions have been completed.</p></li></ol><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW12" title="Figure 4-4Malloc Trace mini configuration editor"></a><p><strong>Figure 4-4&nbsp;&nbsp;</strong>Malloc Trace mini configuration editor</p><img src = "../Art/MallocTrace_miniconfig.jpg" alt = "Malloc Trace mini configuration editor" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH6-SW11" title="Using a Malloc Trace"></a><h3>Using a Malloc Trace</h3><p>Once you have recorded a <em>Malloc Trace</em>, there are several ways that you can analyze the resulting trace, which comes up in a window that superficially resembles a standard time profile. Here are a few of the most common techniques:</p><ul class="spaceabove"><li class="li"><p><strong>Profile Browser: Get an Overview</strong>— The profile browser from a <em>Malloc Trace</em>, as shown in <span class="content_text">“Using a Malloc Trace,”</span> looks a lot like what you might obtain with a normal <em>Time Profile</em>, but it contains an extra column listing the amount of memory allocated. In addition, the “Self” and “Total” columns are based on the number of allocations made using that call instead of execution time. These figures are highlighted in the figure. By sorting on the “Total” or “Alloc Size” columns in a “Heavy” view, you can see which routines in your program either make the largest number of allocations or allocate the most memory at a glance. It is often a good idea to look over the routines near the top of this list and make sure that both the routines allocating memory are the ones you <em>think</em> should be allocating memory, and that the amount of memory allocated by each routine makes sense.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH6-SW14" title="Figure 4-5Malloc Trace session, profile browser"></a><p><strong>Figure 4-5&nbsp;&nbsp;</strong>Malloc Trace session, profile browser</p><img src = "../Art/MallocTraceProfile.jpg" alt = "Malloc Trace session, profile browser" ></div></li><li class="li"><p><strong>Code Browsers: Locate Allocating Code</strong>— If you see a potentially troublesome routine, double-clicking it will bring it up in a code browser window. Unlike the code browsers associated with <em>Time Profile</em> sessions, lines in a <em>Malloc Trace</em> session are colored based on how many memory allocations they perform. With this feedback, you can see <em>exactly</em> which lines of code were the cause of memory allocation. Often these lines will be fairly obvious, but with object-oriented languages like Objective-C and C++ it is surprisingly easy to accidently allocate and free memory implicitly, as a side effect of object method calls. Using a code browser from a <em>Malloc Trace</em> session can allow you to identify which method calls are performing memory allocation and focus your optimization efforts on these. In addition, knowing what code is performing memory allocation implicitly can help you track down memory leaks, as these allocations are easy to forget about when one is cleaning up and freeing memory allocations.</p></li><li class="li"><p><strong>Chart View: Look for Patterns</strong>— The chronological view of allocations presented by the extra memory allocation graph added below the usual callstack plot in <em>Chart</em> view can easily reveal unexpected repetitive allocation and deallocation activity in your software, like the pattern shown in the highlighted part of <span class="content_text">Figure 4-5</span>. When you see patterns like this, it can be helpful to try and adjust your code to move memory allocation and deallocation operations outside of loops, so that you can reuse the same memory buffers repeatedly without reallocating them each time through the loop. Similarly, if you see repetitive allocation without matching deallocations, then you are most likely seeing a major memory leak in progress!</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH6-SW26" title="Figure 4-6Malloc Trace session, chart view"></a><p><strong>Figure 4-6&nbsp;&nbsp;</strong>Malloc Trace session, chart view</p><img src = "../Art/MallocTraceChart.jpg" alt = "Malloc Trace session, chart view" ></div></li></ul><p>Using techniques like these, you can identify and isolate memory allocation locations and patterns within your code. This is the first step to actually eliminating these memory problems from your code, and hopefully improving performance in the process.</p><a name="//apple_ref/doc/uid/TP40005233-CH6-SW27" title="Advanced Display Options"></a><h3>Advanced Display Options</h3><p>Each Malloc Trace records a few additional pieces of information at each allocation event. These are not displayed by default, but can be useful in some situations. Display of these values can be enabled by using the “Performance Counter Data Mining” pane in the Advanced Settings Drawer of the session window (see <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW9">“Advanced Settings Drawer”</a></span>), as shown below in <span class="content_text">Figure 4-7</span>, and then clicking on the check boxes in the “eye” column of each row to show that data element.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW29" title="Figure 4-7Enabling Malloc Trace Advanced Options"></a><p><strong>Figure 4-7&nbsp;&nbsp;</strong>Enabling Malloc Trace Advanced Options</p><img src = "../Art/MallocTraceOptions.jpg" alt = "Enabling Malloc Trace Advanced Options" ></div><br/><p>Five different types of information can be enabled or disabled in this manner:</p><ul class="spaceabove"><li class="li"><p><em>Alloc Size</em>— The size in bytes of each memory allocation. This is enabled by default, as it is almost always useful.</p></li><li class="li"><p><em>Heap Delta</em>— The change in size of the heap since the start of the trace. This is sometimes useful for spotting memory leaks, which can be seen when the heap grows but never shrinks. Note that it is also possible to get this data by using the “summation” option (as described in <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW46">“Perf Count Data Mining”</a></span>) with <em>Alloc Size</em>.</p></li><li class="li"><p><em>Lifetime</em>— The number of allocation/deallocation events between matched allocation and deallocation pairs. This option is only useful if you disabled the “Record Only Active Blocks” option before taking your Malloc Trace, because otherwise that option automatically screens out all matched pairs from the trace and leaves no interesting lifetimes remaining in the trace.</p></li><li class="li"><p><em>Address</em>— The address of the memory block allocated or freed. For performance analysis purposes, this is only rarely helpful, but it can sometimes be useful during debugging of memory allocation behavior.</p></li><li class="li"><p><em>Is allocation?</em>— This binary value records a 1 for allocations and 0 for frees.</p></li></ul><p>When you enable display of a particular type of data, it will appear in several places. First, columns displaying it will appear in the Profile Browser (as shown previously in <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW14">Figure 4-5</a></span>), although this type of display is really only meaningful for <em>Alloc Size</em>. Raw values are displayed in the list of samples at the bottom of the Chart View (as shown in <span class="content_text">Figure 4-8</span>), and all types of displays are useful here. Finally, charts appear in the main part of the chart view displaying all of the sample values graphically for your inspection. These are useful with <em>Alloc Size</em> (enabled by default), <em>Heap Delta</em>, and <em>Lifetime</em>.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW28" title="Figure 4-8Additional Malloc Trace Charts"></a><p><strong>Figure 4-8&nbsp;&nbsp;</strong>Additional Malloc Trace Charts</p><img src = "../Art/MallocTraceChartView.jpg" alt = "Additional Malloc Trace Charts" ></div><br/><p>The rest of the “Performance Counter Data Mining” pane, which is described more fully in the context of performance counter analysis in the section <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW46">“Perf Count Data Mining,”</a></span> also has other features that can be useful.  For example, if a Malloc Trace contains allocations of wildly varying size, use of these options may be necessary in order to make the allocation size chart readable, as no means for vertical scaling or scrolling are provided by Shark. A particularly quick way of focusing the view on allocations of particular sizes is to use the “remove !=,” “remove &lt;,” or “remove >” screening options to chop off most allocations that are vastly different in size from the ones that you are trying to examine.</p><p>All other features accessible through the Advanced Settings Drawer work just like they do for Time Profiling (see <span class="content_text"><a href="../TimeProfiling/TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW22">“Profile Display Preferences”</a></span> for the “Profile Analysis” pane and <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW1">“Data Mining”</a></span> for the “Callstack Data Mining” pane).</p><a name="//apple_ref/doc/uid/TP40005233-CH6-SW19" title="Static Analysis"></a><h2>Static Analysis</h2><p>Most of Shark’s profiling methods limit their code analysis to those functions that appear dynamically in functions that are executed during the profiling. Dead or otherwise unused code is not analyzed or presented for optimization precisely because it has very little effect on the measured performance. However, it can sometimes be useful to statically analyze and examine infrequently used code paths in a piece of code to look for problems that might crop up if those code paths <em>do</em> become important at some point, such as with a different input data set.</p><p>Shark is capable of statically analyzing either a running process or a binary file with the <em>Static Analysis</em> configuration, but not your entire system. To analyze a running application, select <em>Process</em> in the target list and then select the process you wish to analyze in the process list. To analyze an executable file, select <em>File</em> in the target list and then select the file in file selection window.</p><p><em>Static Analysis</em>’ mini config editor (see <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW10">“Mini Configuration Editors”</a></span>), shown in <span class="content_text">Figure 4-9</span>, offers a number of tuning options to refine what types of problems to look for and where in the program to look for them. The available options are:</p><ol class="ol"><li class="li"><p><strong>Target Selection</strong>— These options allow you to narrow down the area of memory examined by Shark.</p><ul class="ul"><li class="li"><p><em>Application</em>— Looks for potential performance issues in the main text segment of the target process</p></li><li class="li"><p><em>Frameworks</em>— Looks for potential performance issues in the frameworks that are dynamically loaded by the target 
process.</p></li><li class="li"><p><em>Dyld Stubs</em>— Looks for any potential performance or behavior anomalies in the glue code inserted into the binary by the link phase of application building.</p></li></ul></li><li class="li"><p><strong>Analysis Options</strong>— These allow you to enable or disable analysis.</p><ul class="ul"><li class="li"><p><em>Browse Functions</em>— Gives each function in the text image of a process a reference count of one. This allows you to browse all of the functions of a given process with Shark’s code browser. No analysis (or problem weighting) is performed.</p></li><li class="li"><p><em>Look For Problems </em>— search all functions in the text image of a process for problems of at least the level of severity specified by the Problem Severity slider. Any address with a problem instruction or code is given a reference count equivalent to its severity.</p></li></ul></li><li class="li"><p><strong>Problem Severity Slider</strong>— This slider acts as a filter, adjusting the minimum “importance” of problems to report using a predefined problem weighting built into Shark. The further to the right the slider, the less output is generated, as more and more potential problems are ignored because their “importance” is not high enough.</p></li><li class="li"><p><strong>Processor Settings</strong>— Shark needs to know which model of processor is your target before it can examine code and find potential problems. Separate menus are provided for PowerPC and Intel processors because it can analyze for one model of each processor family simultaneously.</p><ul class="ul"><li class="li"><p><em>PowerPC Model</em>— Selects the PowerPC model to use when searching for and assigning problem severities .</p></li><li class="li"><p><em>Intel Model</em>— Selects the Intel model to use when searching for and assigning problem severities .</p></li></ul></li></ol><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW13" title="Figure 4-9Static Analysis mini configuration editor"></a><p><strong>Figure 4-9&nbsp;&nbsp;</strong>Static Analysis mini configuration editor</p><img src = "../Art/StaticAnalysis_miniconfig.jpg" alt = "Static Analysis mini configuration editor" ></div><br/><p>Once you have created a <em>Static Analysis</em> session, you can examine it to see Shark’s optimization suggestions for your program. Both the profile browser and code browser views offer optimization hints similar to those you can see after a normal <em>Time Profile</em> run, and they can be used to help you analyze your application in much the same manner.</p><a name="//apple_ref/doc/uid/TP40005233-CH6-SW20" title="Using Shark with Java Programs"></a><h2>Using Shark with Java Programs</h2><p>Shark’s profiling and tracing techniques will work just fine with programs written in virtually any compiled language. Your compiler processes your source code in these languages and creates binary files where the various instructions in the binary are PowerPC or x86 instructions that correspond closely with your original source code operations. Shark records program counters and callstacks from the native machine execution as it profiles, and can use this information to reference back to your source code. Because Mac OS X imposes requirements on how its binaries are formatted, compilers for any language use the same techniques to record which machine instructions correspond with which source files, making it possible for Shark to show you symbol information and source code in languages as disparate as C and Fortran.</p><p>This system breaks down when your source code is written in a compiled language that runs within a runtime virtual machine, such as Java, or interpreted scripting languages. In these cases, Shark’s samples will only tell you what code is executing <em>within</em> the virtual machine or interpreter, which will not help you optimize <em>your</em> programs. For Shark to return useful information, it must move “up” a level in the software hierarchy (as shown in <span class="content_text">Figure 4-10</span>) and record the location within the virtual machine code or script that is executing, instead. While support for recording this information is unavailable with most script interpreters, recent versions of Sun’s Java virtual machine included with Mac OS X <em>do</em> provide an interface that Shark can use. As a result, Shark includes some special, Java-only configurations that use this interface to allow you to usefully profile your Java applications.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW15" title="Figure 4-10How Shark-for-Java differs from regular Shark configurations"></a><p><strong>Figure 4-10&nbsp;&nbsp;</strong>How Shark-for-Java differs from regular Shark configurations</p><img src = "../Art/JavaLayers.jpg" alt = "How Shark-for-Java differs from regular Shark configurations" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH6-SW22" title="Java Tracing Techniques"></a><h3>Java Tracing Techniques</h3><p>Shark supports three different techniques for examining your Java applications:</p><ul class="spaceabove"><li class="li"><p><strong>Java Time Profile:</strong> This is the Java version of <em>Time Profile</em>. The targeted Java program is periodically interrupted and Shark records the method that was running and the callstack of method calls leading up to the current method. You may examine the results using browsers that are almost identical to the normal <em>Time Profile</em> ones described in <span class="content_text"><a href="../TimeProfiling/TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW19">“Profile Browser,”</a></span> except that they only list Java methods and libraries. Note that, because a fair amount of code must be executed to communicate with the JVM, overhead requirements for a Java Time Profile are somewhat higher than for a conventional time profile. Using the mini-config editor (see <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW10">“Mini Configuration Editors”</a></span>), you can adjust the sampling rate at the millisecond level.</p></li><li class="li"><p><strong>Java Call Trace:</strong> This is the Java analog to the separate Saturn program. Java Call Trace records each call into and exit from <em>every</em> Java method during the execution of your program. As a result, it records an <em>exact</em> trace of all the method calls, much like a normal <em>System Trace</em> records an exact trace of all system calls. The amount of time spent in each method is also recorded. While this provides very exact and detailed information about the execution of your program, with no potential for sampling error, it also incurs a significant amount of system overhead due to the frequent interruptions of your code to pass information back to Shark. As a result, Shark’s overhead may distort the timing of your program to a certain extent, and this factor should be considered if you have code that is sensitive to external timing adjustments. Also, due to the large amount of data that can be collected very quickly, you probably want to limit the use of this to relatively short timespans. When complete, Shark presents the information that it has collected in a browser virtually identical to one produced by a Java Time Profile.</p></li><li class="li"><p><strong>Java Alloc Trace:</strong> This records memory allocations and the sizes of the objects allocated, and is analogous to a regular <em>Malloc Trace</em> (<span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW16">“Malloc Trace”</a></span>). Not surprisingly, the resulting session window produced by Shark is very similar to one produced by <em>Malloc Trace</em>. As with <em>Malloc Trace</em>, the display is just that of a <em>Time Profile</em> — albeit a Java Time Profile, in this case — with an added “allocation size” column. As with the previous two techniques, the overhead imposed by the Shark while doing a Java Alloc Trace is large enough that it may affect some programs that are very sensitive to external timing adjustments. Also, due to the large amount of data that can be collected very quickly, you probably want to limit the use of this to relatively short timespans.</p></li></ul><a name="//apple_ref/doc/uid/TP40005233-CH6-SW23" title="Linking Shark with the Java Virtual Machine"></a><h3>Linking Shark with the Java Virtual Machine</h3><p>In order to let Shark connect to your JVM and access its internals, to get the detailed information used by all of the techniques described earlier, the Java Virtual Machine first needs to load the “Shark for Java” extension. The method for doing this varies, depending upon which version of the JVM you’re using (use the command <code>java -version</code> to see which one you are running):</p><ul class="spaceabove"><li class="li"><p><strong>JVM 1.3 or earlier:</strong> Shark will not work with these, as they do not have the necessary external debugging support.</p></li><li class="li"><p><strong>JVM 1.4:</strong> Add the following flag to your Java VM command line options: <code>–XrunShark</code>.</p></li><li class="li"><p><strong>JVM 1.5 or later:</strong> Add the following flag to your Java VM command line options: <code>-agentlib:Shark</code>.</p></li></ul><p>If you are using Xcode to build your Java application, edit the program’s target. Under the <em>Info.plist Entries</em>, select <em>Pure Java Specific</em>. In the <em>Additional VM Options</em> field, add <code>-XrunShark</code> or <code>-agentlib:Shark</code> as appropriate.</p><p>When you run a Java program with Shark for Java, the program will output to the shell (or console for a double-clickable target) a message similar to the following:</p><p><code>2004-06-27 03:33:24 java[4489] Shark for Java is enabled...</code></p><p>As soon as you see this message you can begin sampling with Shark. When you choose one of the Java tracing configurations in Shark’s main window, the process list will change to only display Java processes that are running with Shark for Java loaded. Non-Java processes and Java processes that have been started without Shark support will both be eliminated.</p><p>To use source navigation, the program’s source must be on disk in package hierarchy structure. Shark does <em>not</em> support inspection within jar files.  If you have a jar such as <code>/System/Library/Frameworks/JavaVM.framework/Home/src.jar</code>, you will need to extract it into a directory hierarchy (<code>jar -xvf src.jar</code> for the example). When adding a path to the <em>Source Search Path</em> (see <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW5">“Shark Preferences”</a></span>), add only the path to the root of the source tree.</p><a name="//apple_ref/doc/uid/TP40005233-CH6-SW21" title="Event Counting and Profiling Overview"></a><h2>Event Counting and Profiling Overview</h2><p>After analyzing an application using a <em>Time Profile</em>, you may find it informative to count system events or even sample based on system events in order to understand why your application spends time where it does. The best way to do this is to take advantage of the performance counters built into your Mac’s processors (usually called PMCs) and Mac OS X itself. Shark provides built-in configurations to help you access this information in meaningful ways:</p><ul class="ul"><li class="li"><p><em>Processor Bandwidth</em> (x86) or <em>Memory Bandwidth</em> (PowerPC): These configurations track off-chip memory traffic over time. Because of differences in the implementation of the counters, the PowerPC version measures memory bandwidth only, while the x86 version measures processor bus bandwidth, including traffic to memory, I/O, and other processors.</p></li><li class="li"><p><em>L2 (Data) Cache Miss Profile:</em> This configuration provides an event-driven profile of L2 cache misses. As each L2 cache miss causes the processor to stall for a significant amount of time while it accesses main memory, algorithms that arrange accesses to memory in ways that minimize these misses will tend to run faster than ones that do not.</p></li></ul><p>The rest of this section attempts to describe how you can use these default configurations to get useful information about your system with Shark, and learn about performance counters in the process. However, the default configurations only scratch the surface of what Shark’s counter recording mechanisms can do. Using the mini-configuration editor (see <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW10">“Mini Configuration Editors”</a></span>) associated with each of these configurations, you can adjust the same parameters used with a normal <em>Time Profile</em> mini-config editor (see <span class="content_text"><a href="../TimeProfiling/TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW23">“Taking a Time Profile”</a></span>) to control things like sampling rate, time limit, and the like. Beyond this, using the full <em>Configuration Editor</em>, you can set up a variety of other configurations to count or sample a variety of hardware or software events, such as instruction stalls or page misses. See <span class="content_text"><a href="../CustomConfigurations/CustomConfigurations.html#//apple_ref/doc/uid/TP40005233-CH8-SW1">“Custom Configurations”</a></span> and <span class="content_text"><a href="../AdvancedHardwareCounterConfiguration/AdvancedHardwareCounterConfiguration.html#//apple_ref/doc/uid/TP40005233-CH10-SW1">“Hardware Counter Configuration”</a></span> for more information.</p><a name="//apple_ref/doc/uid/TP40005233-CH6-SW7" title="Timed Counters: The Performance Counter Spreadsheet"></a><h3>Timed Counters: The Performance Counter Spreadsheet</h3><p>This section uses the built-in <em>Processor Bandwidth</em> and <em>Memory Bandwidth</em> configurations as an example of how to use Shark’s Performance Counter Spreadsheet, its mechanism for analyzing and displaying sessions that record performance counters in a regular, timed fashion.</p><p>After you perform sampling with one of these configurations, you will be presented with a session window containing a <em>Performance Counter Spreadsheet</em> like the one shown in <span class="content_text">Figure 4-11</span>. This window contains many features:</p><ol class="ol"><li class="li"><p><strong>Column Control Table</strong>— This optional table lists the columns in the Results and PMC Summary tables to the right, providing longer names and allowing you to hide columns. It may be hidden or exposed using the window splitter on its right edge or a checkbox in the <em>Advanced Settings</em> drawer (see <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW4">“Performance Counter Spreadsheet Advanced Settings”</a></span>). Selecting rows in this list also selects the corresponding columns in the counter table, graphing them. Use <em>Command-clicks</em> (for discontiguous selection) and/or <em>Shift-clicks</em> (for contiguous selection) to select multiple rows simultaneously.</p><ol class="ol"><li class="ol ol"><p><em>“Eye” Column</em>— Uncheck the checkboxes in this column to hide columns in the results table(s). This is very helpful if you have a large number of columns.</p></li><li class="ol ol"><p><em>Term Column</em>— Contains the short names for the columns, which can be used as terms in “shortcut equations,” as described below.</p></li><li class="ol ol"><p><em>Description Column</em>— Contains the long names for the columns, for your reference. This can be useful when you have many columns with long names that do not fit into the name cells at the tops of the columns.</p></li></ol></li><li class="li"><p><strong>Results Table</strong>— This table shows the actual results from performance counters and any derived results calculated from them. You can Control-click (or right click) anywhere on this table to bring up the <em>Counters</em> menu, described in <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW6">“The Counters Menu.”</a></span></p><ol class="ol"><li class="ol ol"><p><em>Column Names</em>— These provide a brief description of the contents of the column. If you find a name too terse, then you may want to open up the <em>Column Control Table</em> and see the longer description there. In addition, clicking on these names selects one or more columns of data to be graphed below in the <em>Results Chart</em>. Use <em>Command-clicks</em> (for discontiguous selection) and/or <em>Shift-clicks</em> (for contiguous selection) to select multiple columns simultaneously. By default, the first performance counter column (“M/C Read/write request beats,” in this example) is automatically selected and graphed when the window is first opened. Finally, you can resize any columns by clicking-and-dragging on the lines separating these cells from each other.</p></li><li class="ol ol"><p><em>Index Column</em>— Lists an integer value associated with each sample, counting from 1 on up, for your reference. This column can be hidden from display using the appropriate checkbox in the <em>Advanced Settings</em> drawer (see <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW4">“Performance Counter Spreadsheet Advanced Settings”</a></span>). This column may not be selected or graphed.</p></li><li class="ol ol"><p><em>Timebase Column(s)</em>— Contains the time between each sample, with one column for each processor in the system. Normally, these should be essentially constant, but you may see occasional glitches where a sample took slightly longer than normal to record due to interrupt contention on a processor. The first and/or last samples may also show some timing variation. In addition, you will see significant variation here if you choose to view results from an event-driven counter run (see <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW5">“Event-Driven Counters: Correlating Events with Your Code”</a></span>) using the counter “spreadsheet.” These columns may be shown or hidden using checkboxes in the <em>Column Control Table</em> to the left.</p></li><li class="ol ol"><p><em>Counter Result Column(s)</em>— These columns show the “raw” results recorded from performance counters, one column per active counter. These columns may be shown or hidden using checkboxes in the <em>Column Control Table</em> to the left.</p></li><li class="ol ol"><p><em>Shortcut Result Column(s)</em>— These columns show the performance counter results after they have been processed by the math in any “shortcut” equations. These columns may be shown or hidden using checkboxes in the <em>Column Control Table</em> to the left, and the “shortcut” equations may be viewed or edited using the controls in the <em>Advanced Settings</em> drawer (see <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW4">“Performance Counter Spreadsheet Advanced Settings”</a></span> and <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW2">“Adding Shortcut Equations”</a></span>).</p></li></ol></li><li class="li"><p><strong>PMC Summary Table</strong>— This window pane extends the <em>Results Table</em> with additional rows that list the total, average (arithmetic mean), geometric mean, minimum, and maximum values for each column. This pane can be hidden from display using the appropriate checkbox in the <em>Advanced Settings</em> drawer (see <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW4">“Performance Counter Spreadsheet Advanced Settings”</a></span>) or the window splitter at the top of the pane.</p></li><li class="li"><p><strong>Results Chart</strong>— This graph charts the values in the selected column(s) in the Results Table. There are many options for controlling this graph in the <em>Advanced Settings</em> drawer (see <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW4">“Performance Counter Spreadsheet Advanced Settings”</a></span>). The chart starts out scaled so that it fits entirely within the window allocated, but you can also magnify the chart and the scroll to any part of the magnified chart using the magnifier sliders and scroll bars along both the right side and bottom. In addition, you can print the contents of this graph using a command in the <em>Counters</em> menu (see <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW6">“The Counters Menu”</a></span>) and vary the percentage of the window’s space allocated to the chart using the window splitter at its top edge.</p></li><li class="li"><p><strong>Session Summary</strong>— This line of text summarizes key facts about the session, including the number of processors, the number of samples taken, and the total time that elapsed during counter sampling.</p></li></ol><p>In <span class="content_text">Figure 4-11</span>, the last two columns have been selected and their contents displayed together in the chart. These last two columns are not actual event counts, but the results of “Shortcut Equations.” These equations are simple mathematical combinations of the “raw” counts recorded by Shark. Shortcut equations can be added to the configuration before a profile is taken, or just as easily be added to a session afterwards. In this session, the “Read MB/s,” and “Write MB/s” columns were generated by performing some simple arithmetic on the entries in the two “M/C Read/write request beat” columns (reads to left, writes to right). Every counter sample is multiplied by 16 (bytes per beat), multiplied by 100 (samples per second) and divided by 2<sup>20</sup> (bytes per megabyte), which yields MB/s in each new column. For a brief introduction to adding equations to your sessions, see <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW2">“Adding Shortcut Equations,”</a></span> below. For a complete description of how to write performance counter equations, including how to add them permanently to your configurations, see <span class="content_text"><a href="../CustomConfigurations/CustomConfigurations.html#//apple_ref/doc/uid/TP40005233-CH8-SW18">“Counter Spreadsheet Analysis PlugIn Editor.”</a></span></p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW1" title="Figure 4-11Performance Counter Spreadsheet"></a><p><strong>Figure 4-11&nbsp;&nbsp;</strong>Performance Counter Spreadsheet</p><img src = "../Art/SpreadsheetWindow.jpg" alt = "Performance Counter Spreadsheet" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH6-SW6" title="The Counters Menu"></a><h4>The Counters Menu</h4><p>When you switch to the <em>Counters</em> tab in a session made with timed performance counters, a <em>Counters</em> menu will appear in the menu bar. You can also access this menu by control-clicking (or right-clicking, with a 2-button mouse) in the <em>Results table</em>, as shown in <span class="content_text">Figure 4-12</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW3" title="Figure 4-12Counters Menu"></a><p><strong>Figure 4-12&nbsp;&nbsp;</strong>Counters Menu</p><img src = "../Art/CounterMenu.jpg" alt = "Counters Menu" ></div><br/><p>This menu contains several commands that allow you to work with the performance results:</p><ul class="spaceabove"><li class="li"><p><strong>Number Formatting</strong>— This submenu lets you adjust how the (often quite large) numbers are displayed in the <em>Results Table</em>: </p><ul class="nested"><li class="nested li"><p><em>Show 1000’s Separator</em>— Add thousands separators (typically commas) to the values. You can also choose this using the keyboard shortcut <em>Command-/</em>.</p></li><li class="nested li"><p><em>Use Scientific Notation</em>— Toggles between standard (e.g. 100) and scientific (1.0E2) notation. You can also choose this using the keyboard shortcut <em>Command-^</em>.</p></li><li class="nested li"><p><em>Increase Decimal Places</em>— Increases the number of digits of precision used to display floating-point values by one decimal place. Because performance event counts are integers, this normally only affects shortcut equation results and timebase columns. You can also choose this using the keyboard shortcut <em>Command-←</em>.</p></li><li class="nested li"><p><em>Decrease Decimal Places</em>— Decreases the number of digits of precision used to display floating point values by one decimal place. Because performance event counts are integers, this normally only affects shortcut equation results and timebase columns. You can also choose this using the keyboard shortcut <em>Command-→</em>.</p></li></ul></li><li class="li"><p><strong>Print Chart…</strong>— Allows you to print the currently displayed chart, using a standard Mac <em>Print</em> dialog box.</p></li><li class="li"><p><strong>Save Text File…</strong>— Exports the current <em>Results Table</em> values as a comma-separated value (CSV) format text file. This resulting text can be imported into an application like Excel for further analysis.</p></li></ul><a name="//apple_ref/doc/uid/TP40005233-CH6-SW4" title="Performance Counter Spreadsheet Advanced Settings"></a><h4>Performance Counter Spreadsheet Advanced Settings</h4><p>With the session window in the foreground, select <em>Window</em>→<em>Show Advanced Settings</em> (<em>Command-Shift-M</em>), as we described earlier in <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW9">“Advanced Settings Drawer.”</a></span> The palette of advanced controls will appear (<span class="content_text">“Performance Counter Spreadsheet Advanced Settings”</span>).</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW24" title="Figure 4-13Performance Counter Spreadsheet: Advanced Settings"></a><p><strong>Figure 4-13&nbsp;&nbsp;</strong>Performance Counter Spreadsheet: Advanced Settings</p><img src = "../Art/SpreadsheetAdvanced.jpg" alt = "Performance Counter Spreadsheet: Advanced Settings" ></div><br/><p>This drawer contains three main panels, each with many different controls that affect the presentation of results:</p><ol class="ol"><li class="li"><p><strong>Counter Shortcut Equations</strong>— This table displays the “Shortcut Equations” used to generate each of the computed results columns in the <em>Results Table</em>, one equation per row. Both equations that were included right in the configuration and ones that you add yourself after the session has been recorded are listed here, and you can freely edit any of them here. The table consists of a few fairly straightforward parts:</p><ol class="ol"><li class="ol ol"><p><em>Term column</em>— This column lists the “term” name for this equation (usually eq01, eq02, etc.). This is the shorthand name that you can use to include the results of this equation in a subsequent, dependent equation. These “term” names, plus the “term” names for the original performance counter data, are also listed in the <em>Column Control Table</em> described previously in <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW7">“Timed Counters: The Performance Counter Spreadsheet.”</a></span></p></li><li class="ol ol"><p><em>Name column</em>— Here is where you may edit the label that will appear as the column header for this shortcut equation’s results.</p></li><li class="ol ol"><p><em>Equation column</em>— You can define or edit the equation used to calculate the entries in the shortcut column here, using the techniques described below in <span class="content_text"><a href="OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW2">“Adding Shortcut Equations.”</a></span></p></li><li class="ol ol"><p><em>Add button</em>— Creates a new “shortcut equation” and a <em>Results Table</em> column for it..</p></li><li class="ol ol"><p><em>Delete button</em>— Removes the selected shortcut(s) and their associated columns from the <em>Results Table</em>.</p></li></ol></li><li class="li"><p><strong>Counter Table Settings</strong>— This section of the drawer lets you adjust the appearance of the tables within the counter spreadsheet window.</p><ol class="ol"><li class="ol ol"><p><em>Show Column Control Table</em>— Toggles display of the <em>Column Control Table</em> to the left side of the <em>Results Table</em>.</p></li><li class="ol ol"><p><em>Show Index Column</em>— Toggles view of the index column in the <em>Results Table</em>.</p></li><li class="ol ol"><p><em>Show PMC Summary Table</em>— Toggles display of the <em>PMC Summary Table</em> below the <em>Results Table</em>.</p></li><li class="ol ol"><p><em>Timebase Units popup</em>— Allows you to change the units used in the time base column(s) to something more appropriate. Selections are listed in order of increasing size: CPU cycles, bus cycles, microseconds, milliseconds (default), and seconds.</p></li></ol></li><li class="li"><p><strong>Counter Chart Settings</strong>— This section of the drawer lets you adjust the appearance of the chart within the counter spreadsheet window.</p><ol class="ol"><li class="ol ol"><p><em>Multiple Data Set Chart Mode</em>— These buttons select how you would like the chart to display when multiple columns are selected:</p><ul class="ul"><li class="li"><p>One combined chart for all selected result columns</p></li><li class="li"><p>Separate charts for each selected column</p></li></ul></li><li class="ol ol"><p><em>Chart Type</em>— Selects the type of chart that will be displayed:</p><ul class="ul"><li class="li"><p><em>Lines</em>— Display results as line charts. There are several sub-options for displaying these charts, which can be selected using the two menus below.</p></li><li class="li"><p><em>Bars</em>— Display results using a vertical bar chart. Bars from multiple selected columns will be superimposed over one another.</p></li><li class="li"><p><em>Stacks of Bars</em>— Display results as stacked vertical bar charts, with the values from all selected columns added together at each sample point. This chart is identical to the standard bar chart if only one column is selected</p></li></ul></li><li class="ol ol"><p><em>Line Chart Subtype</em>— This menu fine-tunes line charts by controlling the display of symbols at data points on the line charts:</p><ul class="ul"><li class="li"><p><em>Lines and Markers</em>— Display both symbols at each data point and lines to join them up.</p></li><li class="li"><p><em>Lines</em>— (default) Only displays lines joining the data points together.</p></li><li class="li"><p><em>Markers</em>— Only displays symbols at each data point.</p></li><li class="li"><p><em>Small Markers</em>— Same as previous, but the symbols are significantly smaller.</p></li></ul></li><li class="ol ol"><p><em>Line Chart Data Compression</em>— This menu lets you apply filters to smooth out the data plotted using a line chart. These filtering options are not allowed with bar and stacked bar charts.</p><ul class="ul"><li class="li"><p><em>Average</em>— Applies a moving average (FIR) filter to the data in order to smooth it out.</p></li><li class="li"><p><em>IIR Filter</em>— Applies an IIR averaging filter to the data to smooth it out.</p></li><li class="li"><p><em>None</em>— (default) No smoothing applied, so you see only actual values.</p></li></ul></li><li class="ol ol"><p><em>Enable Data Point Tool Tips</em>— When enabled, hovering the mouse pointer over a data point in a data set shows the x- and y-values for that point in a pop-up window.</p></li><li class="ol ol"><p><em>X-Axis Units</em>— The horizontal scale can be plotted in two ways:</p><ul class="ul"><li class="li"><p><em>Elapsed Time</em>— The elapsed time since the beginning of the session, in the units specified with the <em>Timebase Units popup</em> above.</p></li><li class="li"><p><em>Sample count</em>— The sample index, or values from the index column.</p></li></ul></li><li class="ol ol"><p><em>Y-Axis Scale</em>— Data can be plotted vertically on a linear or logarithmic (base 10) scale.</p></li><li class="ol ol"><p><em>Show Grid Lines</em>— This lets you control the display of grid lines within the chart. You can toggle all grid lines together or independently toggle major grid lines, minor grid lines, x-axis (all vertical) grid lines, and y-axis (all horizontal) grid lines.</p></li><li class="ol ol"><p><em>Show Legend</em>— Toggles whether or not to show a legend, displaying color-to-data column associations, along with the chart. When enabled, you can select the position of the legend for the chart — above, to the right, or below — using the popup menu just below.</p></li><li class="ol ol"><p><em>Show/Hide Separate Chart View...</em>— This opens or closes a separate window for the chart view, freeing it from its normal position below the <em>Results Table</em>. While it does not enable any new functionality, this option can be useful if you have a widescreen display, and want to position the <em>Results Table</em> and <em>Results Chart</em> side-by-side instead of top-and-bottom, or if you have multiple monitors attached to your Macintosh and would like to put the <em>Results Table</em> and <em>Results Chart</em> on different screens.</p></li></ol></li></ol><a name="//apple_ref/doc/uid/TP40005233-CH6-SW2" title="Adding Shortcut Equations"></a><h4>Adding Shortcut Equations</h4><p>This section gives a brief summary of how to add new “shortcut equation” results columns to your performance counter spreadsheet. For a full description of all the capabilities of shortcut equations, see <span class="content_text"><a href="../CustomConfigurations/CustomConfigurations.html#//apple_ref/doc/uid/TP40005233-CH8-SW14">“Using the Editor.”</a></span></p><ol class="ol"><li class="li"><p>Open up the <em>Advanced Settings</em> drawer, if you do not already have it open.</p></li><li class="li"><p>Click the “Add” button, in the <em>Counter Shortcut Equations</em> palette, and enter a name for your new equation.</p></li><li class="li"><p>Double-click on the “Equation” field in the row for your new equation, and enter your equation. You may use any terms from previous columns (using the short names in the term list from the <em>Column Control Table</em>) and numeric constants, combined using simple 4-function arithmetic — addition (+), subtraction (-), multiplication (*), and division (/).</p></li><li class="li"><p>Press <em>Enter</em> when you are done editing your equation. A new column will immediately appear in the Results Table with the results from your computation. You may then examine, graph, or use the numbers in that column in subsequent equations, just as if they had been there from the start.</p></li></ol><a name="//apple_ref/doc/uid/TP40005233-CH6-SW5" title="Event-Driven Counters: Correlating Events with Your Code"></a><h3>Event-Driven Counters: Correlating Events with Your Code</h3><p>Like Time Profiling, using performance counters in “timed counter” mode only performs timed sampling of the various counters, giving you a set of samples with a statistical view of how your application works. However, you may want record more exact information, more like what you can record using System Trace. This is possible using <em>event sampling</em>, which is used by the default <em>L2 Cache Miss Profile</em> configurations. In this case, you set up a performance counter to interrupt the processor and record a new sample after it has counted a predetermined number of events. Because hardware events happen quickly, you will usually want to have this be a fairly large number, but with some lower-frequency counters it is possible to set the value as low as 1, allowing you to get an exact event trace.</p><p>When complete, a standard profile browser will appear, which looks much like the ones created for <em>Time Profiling</em> (see <span class="content_text"><a href="../TimeProfiling/TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW19">“Profile Browser”</a></span>). However, the results must be interpreted quite differently. Because of the unusual way that sampling is triggered, the sample percentages (or counts) do not represent <em>time</em> percentages, but instead show <em>event</em> percentages. This distinction is <em>not</em> clearly marked on the columns, so you must be careful when reading and interpreting the results. With these results presented in this way, you can get a good idea about which routines and even which lines of code are responsible for causing the largest number of performance-draining events, such as L2 cache misses, in a manner that is completely analogous to interpreting a conventional <em>Time Profile</em>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005233-CH6-DontLinkElementID_9" title="Note"></a><p><strong>Note:</strong>&nbsp;The built-in L2 cache miss profile configuration is a great way to find lines in your code that access memory in ways that cause very slow L2 cache misses, events which can significantly slow down processors like the ones in modern Macs. Optimizing this code to reduce the number of cache misses by adjusting your algorithms and/or memory access patterns can be a very helpful way to improve performance significantly.</p></div><p>Event sampling can only be triggered by a single PMC at a time, so you can only trigger on a single event type (such as L2 misses or off-chip data movement) per session. The value of other counters can be recorded at the same time, but they cannot be used as triggers. While this can be a serious disadvantage, it is balanced out by the fact that you are able to capture your program’s callstack <em>exactly</em> where the event is occuring, allowing you to see exactly which lines of code are causing the events, instead of the approximate locations returned by “counter” mode profiling. In general, if you need to visualize system-wide or process-wide performance events over time without associating performance events to a specific piece of code, the timed counter method is appropriate. On the other hand, if you need to associate performance events precisely with source code that is causing the event to occur, then event sampling is the better choice. These various pros and cons are summarized below:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p></p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Timer Sampling</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Event Sampling</p></th></tr><tr><td  scope="row"><p>Pros</p></td><td ><ul class="threeHead"><li class="li"><p>Measure multiple performance events over time.</p></li><li class="li"><p>Produce meaningful system and process level chart of performance events.</p></li><li class="li"><p>Works with any processor.</p></li><li class="li"><p>Results are easy to interpret on multiprocessors.</p></li></ul></td><td ><ul class="threeHead"><li class="li"><p>Very precise; can relate performance events to a small window of instructions.</p></li></ul></td></tr><tr><td  scope="row"><p>Cons</p></td><td ><ul class="threeHead"><li class="li"><p>Normally no correlation with your code.</p></li><li class="li"><p>With callstack recording enabled (see below), event-code correlation is very approximate.</p></li></ul></td><td ><ul class="threeHead"><li class="li"><p>Trigger on only a single performance event per session.</p></li><li class="li"><p>No chart of performance events.</p></li><li class="li"><p>It is harder to interpret results on multiprocessors, since events do not occur simultaneously on all processors.</p></li><li class="li"><p> Not available on older PowerPC processors (G3 and G4).</p></li></ul></td></tr></table></div><p>While none of the default configurations use this capability, it is also possible to essentially record callstacks like a <em>Time Profile</em> simultaneously with timed counter information, giving you timed counter recording with a way to approximately correlate results with your code, by building your own custom configuration. In this case, the chart view adds new graphs that allow you to look for correlations between performance monitor counts and what code was running at the time a sample was taken, merging elements of the Counters viewer in with the standard <em>Time Profile</em> chart view. An example of using the Chart view with PMCs in counter mode (raw values graphed over time) is shown in <span class="content_text">Figure 4-14</span>. With these graphs, you can click on them at any point to see the callstacks that correspond with that part of the profile. However, be aware that the callstack locations only record <em>approximately</em> what code was executing at the time the counts were recorded, and may not be representative if the sampling rate is significantly lower than the rate at which your program calls functions. This potential defect is the reason why none of the default configurations use this technique, even though it can sometimes be useful if used judiciously.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH6-SW25" title="Figure 4-14Chart View with additional timed counter graphs"></a><p><strong>Figure 4-14&nbsp;&nbsp;</strong>Chart View with additional timed counter graphs</p><img src = "../Art/figure7-2.jpg" alt = "Timer Sampling with PMCs in Counter Mode" ></div><br/>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../SystemTracing/SystemTracing.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../SelectingExecutiontoSampleorTrace/SelectingExecutiontoSampleorTrace.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-04-14<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/SharkUserGuide/OtherProfilingandTracingTechniques/OtherProfilingandTracingTechniques.html%3Fid%3DTP40005233-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/SharkUserGuide/OtherProfilingandTracingTechniques/OtherProfilingandTracingTechniques.html%3Fid%3DTP40005233-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/SharkUserGuide/OtherProfilingandTracingTechniques/OtherProfilingandTracingTechniques.html%3Fid%3DTP40005233-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>