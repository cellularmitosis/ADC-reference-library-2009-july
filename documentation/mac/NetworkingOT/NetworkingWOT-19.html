<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Specifying an Address</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING19></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-18.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-20.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-10.html"><B>Part 1 - Open Transport Essentials</B></A><BR><DD><A HREF="NetworkingWOT-16.html"><B>Chapter 2 - Getting Started With Open Transport</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING19-0></A>
<H1>Specifying an Address</H1>
 This section explains the format of Open Transport addresses and the structure used to specify an address. This section also introduces helper routines that can do some of the work in creating these structures for you.<P>
<A NAME=HEADING19-2></A>
<H2><A NAME=MARKER-9-45></A>Addressing in Open Transport</H2>
 Addresses in Open Transport all begin with a common structure that is followed by protocol-specific fields. The common structure is defined by the <CODE>OTAddress</CODE> type:<P>
<PRE>
<A NAME=MARKER-0-95></A>struct OTAddress
   {
      OTAddressType fAddressType;
      UInt8       fAddress[1];
   };
typedef struct OTAddress OTaddress;
</PRE>
 The <CODE>OTAddress</CODE> type itself is abstract. You would not declare a structure of this type because it does not contain any address information. However, address formats defined by Open Transport protocols all use the <CODE>fAddressType</CODE> field to describe the format of the fields to follow, which do contain address information. For example, the <CODE>DDPAddress</CODE> type is an address format used by the AppleTalk protocol:<P>
<PRE>
<A NAME=MARKER-0-95></A>struct DDPAddress
   {
      OTAddressType  fAddressType; /* must be AF_ATALK_DDP */
      UInt16         fNetwork;
      UInt8          fNodeID;
      UInt8          fSocket;
      UInt8          fDDPType;
      UInt8          fpad;
   };
</PRE>
 Open Transport recognizes this address as a DDP address because the first field of the address is <CODE>AF_ATALK_DDP</CODE>.<P>
 Address formats are protocol-specific. The protocol you choose determines the address format that the endpoint you connect to or listen from will accept. For example, if you're using an AppleTalk protocol, you have the choice of using a DDP, an NBP, or a DDP/NBP address format. When you use TCP/IP, you have the choice of the InetAddress format or the DNS address format.<P>
<A NAME=HEADING19-9></A>
<H2>Using TNetBuf Structures</H2>
 Most provider functions that transfer data pass a parameter of type <A NAME=MARKER-13-27></A><CODE>TNetbuf</CODE> that specifies the size and location of the data. Such data is usually an address, option information, or the actual data that you want to transfer. You can think of the <CODE>TNetbuf</CODE> structure as Open Transport's universal bucket, used to pass and receive different kinds of information. <A HREF=#MARKER-9-49>Figure 2-1</A> shows how the <CODE>TNetbuf</CODE> structure refers to data in memory.<P>
<B>Figure 2-1  <A NAME=MARKER-9-49></A>The <CODE>TNetbuf</CODE> structure </B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/OTPR-L-01.gif"><P>
 The structure is composed of three fields: the <CODE>buf</CODE> field, the <CODE>len</CODE> field, and the <CODE>maxlen</CODE> field. The <CODE>buf</CODE> field contains the beginning address of the data; the <CODE>len</CODE> field specifies the size of the data; and the <CODE>maxlen</CODE> field specifies the maximum amount of data that can be stored in the buffer. How you use this structure depends on whether the structure specifies an input or output parameter:<A NAME=MARKER-13-50></A><P>
<UL>
<P><LI> If you are sending information (the structure is used to specify an input parameter), you must allocate a buffer and initialize it to contain the data you want to send. Then you must set the <CODE>buf</CODE> field to point to the buffer and set the <CODE>len</CODE> field to specify the size of the data. <P>
You may always allocate <CODE>TNetbuf</CODE> structures for input parameters on the stack.
<P><LI>If you are receiving information (the structure is used to specify an output parameter), you must allocate a buffer into which the function can place the information when it returns. Then you must set the <CODE>buf</CODE> field to point to the buffer and set the <CODE>maxlen</CODE> field to specify the maximum size of the data that could be placed in the buffer. When the function returns, it sets the <CODE>len</CODE> field to the actual size of the data.<P>
If you are making asynchronous calls that use <CODE>TNetbuf</CODE> structures as output parameters, you should allocate the <CODE>TNetBuf</CODE> structures (and the buffers they point to) such that they persist until the operation completes. Typically, this means that <CODE>TNetbuf</CODE> structures for output parameters should only be allocated on the stack if the call is synchronous.<P>
</UL>
 There are two situations in which you would not use a <CODE>TNetBuf</CODE> structure to store data: when sending noncontiguous data, or when doing a no-copy receive. For additional information about how you should handle these situations, see "Advanced Topics<A HREF=NetworkingWOT-46.html#MARKER-9-19></A>."<P>
<A NAME=HEADING19-19></A>
<H2><A NAME=MARKER-9-51></A>Storing an Address in a TNetBuf Structure</H2>
 When you pass an address to Open Transport, you use a <CODE>TNetBuf</CODE> structure. <A HREF=#MARKER-9-52>Listing 2-1</A> shows how you might initialize that structure. The listing initializes a DDP address, stores the address in a <CODE>TNetBuf</CODE> structure, and then passes that address in the <CODE>connectCall</CODE> parameter to the <CODE>OTConnect</CODE> function to connect to a remote peer. Note that the <CODE>addr</CODE> field is also a <CODE>TNetBuf</CODE> structure.<P>
<B>Listing 2-1  <A NAME=MARKER-9-52></A>Using a TNetBuf structure to store an address</B><P>
<PRE>
<A NAME=MARKER-0-95></A>void OSStatus MyConnectDDP (EndpointRef ep, UInt16 connectNetworkNumber, 
UInt8 connectNodeID, UInt8 connectSockID)
{
   OSStatus err;
   TCall connectCall;
   DDPAddress connectAddr;
   /* initialize the DDP address to connect to */

   connectAddr.fAddressType = AF_ATALK_DDP;
   connectAddr.fNetwork = connectNetworkNumber;
   connectAddr.fNodeID = connectNodeID;
   connectAddr.fSocket = connectSockID;
   connectAddr.fDDPType = 0;

   /* initialize the TNetBuf that contains the address */
   OTMemzero(connectCall, sizeof(TCall));
   connectCall.addr.buf = (UInt8 *) &amp;connectAddr;
   connectCall.addr.len = sizeof(DDPAddress);

   /* now pass the address to Open Transport */
    err = OTConnect(ep, &amp;connectCall, nil);
   return err;
}
</PRE>
<A NAME=HEADING19-23></A>
<H2>Using Helper Routines to Initialize an Address</H2>
 Some Open Transport protocols export routines that make the job of initializing addresses simpler. For example, <A HREF=#MARKER-9-54>Listing 2-2</A> shows how you can use the function <CODE>OTInitDDPAddress</CODE> to simplify some the work done in <A HREF=#MARKER-9-52>Listing 2-1</A>.<P>
<B>Listing 2-2  <A NAME=MARKER-9-54></A>Using Helper Routines to Initialize an Address</B><P>
<PRE>
<A NAME=MARKER-0-95></A>void OSStatus MyConnectDDP (EndpointRef ep, UInt16 connectNetworkNumber, 
UInt8 connectNodeID, UInt8 connectSockID)
{
   OSStatus err;
   TCall connectCall;
   DDPAddress connectAddr;

   /* initialize the DDP address to connect to */
   OTInitDDPAddress(&amp;connectAddr, connectNetworkNumber, connectNodeID,
                  connectSockID, 0);

   /* initialize the TNetBuf that contains the address */
   OTMemzero(connectCall, sizeof(TCall));
   connectCall.addr.buf = (UInt8 *) &amp;connectAddr;
   connectCall.addr.len = sizeof(DDPAddress);

   /* now pass the address to Open Transport */
   err = OTConnect(ep, &amp;connectCall, nil);
   return err;
}
</PRE>
 These helper routines are especially important when an address has a variable length. For example, a DNS address, used by the TCP/IP protocol, is defined as follows:<P>
<PRE>
<A NAME=MARKER-0-95></A>struct DNSAddress
   {
      OTAddressTYpe  fAddressType; /* always AF_DNS */
      InetDomainName fName;
   };
typedef struct DNSAddress DNSAddress;
</PRE>
 The <CODE>fName</CODE> field of this structure can vary in length. You must pass a DNS address in a <CODE>TNetBuf</CODE> structure that gives the correct length of the entire address. The helper routine, <CODE>OTInitDNSAddress</CODE>, not only fills in the fields of the <CODE>DNSAddress</CODE> structure but also returns the correct length for the <CODE>TNetBuf.len</CODE> field. This technique is shown in <A HREF=NetworkingWOT-22.html#MARKER-9-67>Listing 2-4 </A>.<P>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="NetworkingWOT-19.html#HEADING19-2">Addressing in Open Transport</A>
<DD>
<DT><A HREF="NetworkingWOT-19.html#HEADING19-9">Using TNetBuf Structures</A>
<DD>
<DT><A HREF="NetworkingWOT-19.html#HEADING19-19">Storing an Address in a TNetBuf Structure</A>
<DD>
<DT><A HREF="NetworkingWOT-19.html#HEADING19-23">Using Helper Routines to Initialize an Address</A>
<DD>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="NetworkingWOT-18.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-20.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
