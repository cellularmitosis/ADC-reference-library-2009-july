<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Q&amp;A QA1188: GetProcAdress and OpenGL Entry Points</title><meta name="keywords" content="OpenGL, GetProcAddress, NSGLGetProcAddress, aglGetProcAddress,function pointers, CFM, MachO,"><meta name="Description" content="Technical Q&amp;A QA1188: Technique for finding function pointersfor OpenGLentry points in Cocoa and Carbon"><meta name="categories" content="OpenGL"><meta name="week-posted" content="Nov 25, 2002 - Nov 29, 2002"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10001717" title="GetProcAdress and OpenGL Entry Points"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalqas/index.html">Technical Q&As</a> &gt; <a href="../../technicalqas/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../technicalqas/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Q&amp;A QA1188</div>
<div id="pageheadsub">GetProcAdress and OpenGL Entry Points</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600> <TR> <td align="left"><!-- begin_content --><hr width=500 align=center>                  <P id=p2>Q:      <B>How can I get function pointers to OpenGL entry points?</B></p>                  <P id=p4>A:      Getting function pointers to OpenGL entry points is a simple      procedure from either Cocoa or Carbon.  In the Cocoa or Carbon      Mach-O you can use the existing NSLookupAndBindSymbol to get the      address of an OpenGL entry point.  Things are just slightly more      complicated in Carbon CFM where you need to find the OpenGL      Framework bundle and use the CFBundleGetFunctionPointerForName      function to retrieve the actual function.  The Carbon procedure      works for both Mach-O and CFM binary formats without      modification.</p><P id=p4>      OpenGL has an expanding set of entry      points, all of which are not exported by every version of Mac OS      X. This technique of using function pointers, when combined with      proper extension string and OpenGL version checking, allows      developers to deploy across multiple Mac OS X versions whether      or not the entry point is supported at link and/or runtime.       Additionally, many developers coming from Windows or Linux have      code which is designed to use functions like wglGetProcAddress      to get function pointers to OpenGL entry points.  This Q&A      provides a solution to both these problems which makes using      functions pointers on Mac OS X simple.  Cocoa and Carbon      versions of GetProcAddress for both Mach-O and CFM applications      are shown in the listings below.</p><P id=p4>      NSGLGetProcAddress is detailed in listing 1.  The code first      modifies the requested symbol name for standard name mangling      conventions, then ensures the symbol is defined, and finally      looks up the symbol and returns the appropriate pointer.       Developers should ensure the pointer is valid (non-zero) prior      to using it.  Note, since the NSSymbol functions are part of the      system framework and not part of Cocoa, NSGLGetProcAddress can be      used for Mach-O Carbon applications as well as Cocoa ones.</p><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> #import &lt;mach-o/dyld.h&gt; #import &lt;stdlib.h&gt; #import &lt;string.h&gt;void *NSGLGetProcAddress(const char *name){    NSSymbol symbol;    char *symbolName;    // Prepend a '_' for the Unix C symbol mangling convention    symbolName = malloc (strlen (name) + 2);    strcpy(symbolName + 1, name);    symbolName[0] = '_';    symbol = NULL;    if (NSIsSymbolNameDefined (symbolName))        symbol = NSLookupAndBindSymbol (symbolName);    free (symbolName);    return symbol ? NSAddressOfSymbol (symbol) : NULL;}</pre></TD></TR><TR><td align="left"><P><B>Listing 1</B>.       NSGLGetProcAddress</P></TD></TR></TABLE></CENTER><BR><BR><P id=p4>      aglGetProcAddress, shown in listing 2, has three functions.       The first, aglInitEntryPoints, sets up the bundle reference,      the second, aglDellocEntryPoints, cleans up the bundle by      releasing the reference and the third is the actual aglGetProcAddress      function.  Looking at aglInitEntryPoints, we see an initial      setup, followed by a look up and work to find the Frameworks folder      and to turn it into a CFURL, and finally creating      the bundle and loading the executable.  Once this is complete      one can call aglGetProcAddress for any entry existing in      the OpenGL Framework.  On exit, the application should always      de-allocate the bundle by calling aglDellocEntryPoints which      unloads the bundle and releases the reference to it.  This code      requires Carbon and is designed for use with Mach-O and CFM Carbon      applications.</p><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> #include &lt;Carbon/Carbon.h&gt;CFBundleRef gBundleRefOpenGL = NULL;// -------------------------OSStatus aglInitEntryPoints (void){    OSStatus err = noErr;    const Str255 frameworkName = "\pOpenGL.framework";    FSRefParam fileRefParam;    FSRef fileRef;    CFURLRef bundleURLOpenGL;    memset(&amp;fileRefParam, 0, sizeof(fileRefParam));    memset(&amp;fileRef, 0, sizeof(fileRef));    fileRefParam.ioNamePtr  = frameworkName;    fileRefParam.newRef = &amp;fileRef;    // Frameworks directory/folder    err = FindFolder (kSystemDomain, kFrameworksFolderType, false,                      &amp;fileRefParam.ioVRefNum, &amp;fileRefParam.ioDirID);    if (noErr != err) {        DebugStr ("\pCould not find frameworks folder");        return err;    }    err = PBMakeFSRefSync (&amp;fileRefParam); // make FSRef for folder    if (noErr != err) {        DebugStr ("\pCould make FSref to frameworks folder");        return err;    }    // create URL to folder    bundleURLOpenGL = CFURLCreateFromFSRef (kCFAllocatorDefault,                                            &amp;fileRef);    if (!bundleURLOpenGL) {        DebugStr ("\pCould create OpenGL Framework bundle URL");        return paramErr;    }    // create ref to GL's bundle    gBundleRefOpenGL = CFBundleCreate (kCFAllocatorDefault,                                       bundleURLOpenGL);    if (!gBundleRefOpenGL) {        DebugStr ("\pCould not create OpenGL Framework bundle");        return paramErr;    }    CFRelease (bundleURLOpenGL); // release created bundle    // if the code was successfully loaded, look for our function.    if (!CFBundleLoadExecutable (gBundleRefOpenGL)) {        DebugStr ("\pCould not load MachO executable");        return paramErr;    }    return err;}// -------------------------void aglDellocEntryPoints (void){    if (gBundleRefOpenGL != NULL) {        // unload the bundle's code.        CFBundleUnloadExecutable (gBundleRefOpenGL);        CFRelease (gBundleRefOpenGL);        gBundleRefOpenGL = NULL;    }}// -------------------------void * aglGetProcAddress (char * pszProc){    return CFBundleGetFunctionPointerForName (gBundleRefOpenGL,                CFStringCreateWithCStringNoCopy (NULL,                     pszProc, CFStringGetSystemEncoding (), NULL));}</pre></TD></TR><TR><td align="left"><P><B>Listing 2</B>.       aglGetProcAddress</P></TD></TR></TABLE></CENTER><BR><BR><P id=p4>      Listings 3 and 4 show two code snippets which demonstrate      the use of aglGetProcAddress and NSGLGetProcAddress for a few      OpenGL entry points. Note both snippets are very similar, with      aglGetProcAddress requiring the call to aglInitEntryPoints, to      load the bundle, prior to retrieving a function pointer and then      the call to aglDellocEntryPoints, to unload the bundle, prior to      exiting the application.  Otherwise these code examples are      almost identical.</p><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#import "NSGLGetProcAddress.h" // header for get proc addr func in listing 1static void InitEntryPoints (void);static void DeallocEntryPoints (void);// function pointer typedefs    typedef void (*glBlendColorProcPtr)(GLclampf red,                                        GLclampf green,                                        GLclampf blue,                                        GLclampf alpha);    typedef void (*glBlendEquationProcPtr)(GLenum mode);    typedef void (*glDrawRangeElementsProcPtr)(GLenum mode,                                               GLuint start,                                               GLuint end,                                               GLsizei count,                                               GLenum type,                                               const GLvoid *indices);// function pointer declarations// Note: One should not use the exact function names//       pfXXX is chosen to represent 'pointer to function'    glBlendColorProcPtr pfglBlendColor = NULL;    glBlendEquationProcPtr pfglBlendEquation = NULL;    glDrawRangeElementsProcPtr pfglDrawRangeElements  = NULL;// ==========================static void InitEntryPoints (void){    pfglBlendColor = (glBlendColorProcPtr)                         NSGLGetProcAddress ("glBlendColor");    pfglBlendEquation = (glBlendEquationProcPtr)                            NSGLGetProcAddress ("glBlendEquation");    pfglDrawRangeElements = (glDrawRangeElementsProcPtr)                                NSGLGetProcAddress ("glDrawRangeElements");}// -------------------------static void DeallocEntryPoints (void){    pfglBlendColor = NULL;    pfglBlendEquation = NULL;    pfglDrawRangeElements = NULL;;}</pre></TD></TR><TR><td align="left"><P><B>Listing 3</B>.       NSGLGetProcAddress Sample Usage</P></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#include "aglGetProcAddress.h" // header for get proc addr funcs in listing 2static OSStatus InitEntryPoints (void);static void DeallocEntryPoints (void);// function pointer typedefs    typedef void (*glBlendColorProcPtr)(GLclampf red,                                        GLclampf green,                                        GLclampf blue,                                        GLclampf alpha);    typedef void (*glBlendEquationProcPtr)(GLenum mode);    typedef void (*glDrawRangeElementsProcPtr)(GLenum mode,                                               GLuint start,                                               GLuint end,                                               GLsizei count,                                               GLenum type,                                               const GLvoid *indices);// function pointer declarations// Note: One should not use the exact function names//       pfXXX is chosen to represent 'pointer to function'    glBlendColorProcPtr pfglBlendColor = NULL;    glBlendEquationProcPtr pfglBlendEquation = NULL;    glDrawRangeElementsProcPtr pfglDrawRangeElements  = NULL;// ==========================static OSStatus InitEntryPoints (void){    OSStatus err = aglInitEntryPoints (); //init bundle    if (noErr == err) {        pfglBlendColor = (glBlendColorProcPtr)                            aglGetProcAddress ("glBlendColor");        pfglBlendEquation = (glBlendEquationProcPtr)                                aglGetProcAddress ("glBlendEquation");        pfglDrawRangeElements = (glDrawRangeElementsProcPtr)                                    aglGetProcAddress ("glDrawRangeElements");    }    return err;}// -------------------------static void DeallocEntryPoints (void){    pfglBlendColor = NULL;    pfglBlendEquation = NULL;    pfglDrawRangeElements = NULL;;    aglDellocEntryPoints (); // dump bundle}</pre></TD></TR><TR><td align="left"><P><B>Listing 4</B>.       aglGetProcAddress Sample Usage</P></TD></TR></TABLE></CENTER><BR><BR><P id=p4>      One additional note on the use of function pointers      for OpenGL entry points is worth understanding.  Having a valid      function pointer just means the entry point is exported by the      OpenGL Framework, it has no bearing on whether that particular      routine is supported and valid to call within an application.      OpenGL applications should always check the current renderer      extension string and/or OpenGL version number to confirm whether      a particular feature is supported or not, prior to calling any      OpenGL entry point (whether dynamically loaded or not).  In      summary, existence of the link time or runtime entry point is      not an indication of specific feature support within a specific      renderer</p><P id=p4>      In summary, when deploying across multiple OS versions      it is recommended CFM applications either weak link against      the OpenGL stub libraries or use function pointers and MachO      applications use function pointers for entry points that may not      exist on all targeted OS versions to avoid launch time failures      for undefined entry points.</p><hr width=500 align=center> <!-- begin_date --><H4 ALIGN=center>[Nov 25 2002]</H4><!-- end_date --></TD> </TR> </TABLE></CENTER><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/qa/qa2001/qa1188.html%3Fid%3DDTS10001717-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/qa/qa2001/qa1188.html%3Fid%3DDTS10001717-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/qa/qa2001/qa1188.html%3Fid%3DDTS10001717-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>