<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Summary of Color QuickDraw (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING269></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-268.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-270.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-197.html"><B>Chapter 4 - Color QuickDraw</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING269-0></A>
<H1>Summary of Color QuickDraw</H1>
<A NAME=HEADING269-1></A>
<H2><A NAME=MARKER-21-638></A>Pascal Summary</H2>
<A NAME=HEADING269-2></A>
<H3>Constants</H3>
<PRE>
CONST
   {checking for Color QuickDraw and its features}
   gestaltQuickdrawVersion = 'qd  ';   {Gestalt selector for Color QuickDraw}
   gestalt8BitQD     = $100;  {8-bit Color QD}
   gestalt32BitQD    = $200;  {32-bit Color QD}
   gestalt32BitQD11  = $210;  {32-bit Color QDv1.1}
   gestalt32BitQD12  = $220;  {32-bit Color QDv1.2}
   gestalt32BitQD13  = $230;  {System 7: 32-bit Color QDv1.3}
   gestaltQuickdrawFeatures   = 'qdrw';   {Gestalt selector for Color }
                                          { QuickDraw features}
   gestaltHasColor         = 0;  {Color QuickDraw is present}
   gestaltHasDeepGWorlds   = 1;  {GWorlds deeper than 1 bit}
   gestaltHasDirectPixMaps = 2;  {PixMaps can be direct--16 or 32 bit}
   gestaltHasGrayishTextOr = 3;  {supports text mode grayishTextOr}
                  {source modes for color graphics ports}
   srcCopy     = 0;  {determine how close the color of the source pixel is }
                     { to black, and assign this relative amount of }
                     { foreground color to the destination pixel; determine }
                     { how close the color of the source pixel is to white, }
                     { and assign this relative amount of background }
                     { color to the destination pixel}
   srcOr       = 1;  {determine how close the color of the source pixel is }
                     { to black, and assign this relative amount of }
                     { foreground color to the destination pixel}
   srcXor      = 2;  {where source pixel is black, invert the destination }
                     { pixel--for a colored destination pixel, use the }
                     { complement of its color if the pixel is direct, }
                     { invert its index if the pixel is indexed}
   srcBic      = 3;  {determine how close the color of the source pixel is }
                     { to black, and assign this relative amount of }
                     { background color to the destination pixel}

   notSrcCopy  = 4;  {determine how close the color of the source pixel is }
                     { to black, and assign this relative amount of }
                     { background color to the destination pixel; determine }
                     { how close the color of the source pixel is to white, }
                     { and assign this relative amount of foreground color }
                     { to the destination pixel}
   notSrcOr    = 5;  {determine how close the color of the source pixel is }
                     { to white, and assign this relative amount of }
                     { foreground color to the destination pixel}
   notSrcXor   = 6;  {where source pixel is white, invert the destination }
                     { pixel--for a colored destination pixel, use the }
                     { complement of its color if the pixel is direct, }
                     { invert its index if the pixel is indexed}
   notSrcBic   = 7;  {determine how close the color of the source pixel is }
                     { to white, and assign this relative amount of }
                     { background color to the destination pixel}
{special text transfer mode}
   grayishTextOr = 49;
{arithmetic transfer modes available in Color QuickDraw}
   blend       = 32; {replace destination pixel with a blend of the source }
                     { and destination pixel colors; if the destination is }
                     { a bitmap or 1-bit pixel map, revert to srcCopy mode}
   addPin      = 33; {replace destination pixel with the sum of the source }
                     { and destination pixel colors--up to a maximum }
                     { allowable value; if the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcBic mode}
   addOver     = 34; {replace destination pixel with the sum of the source }
                     { and destination pixel colors--but if the value of }
                     { the red, green, or blue component exceeds 65,536, }
                     { then subtract 65,536 from that value; if the }
                     { destination is a bitmap or 1-bit pixel map, revert }
                     { to srcXor mode}
   subPin      = 35; {replace destination pixel with the difference of the }
                     { source and destination pixel colors--but not less }
                     { than a minimum allowable value; if the destination }
                     { is a bitmap or 1-bit pixel map, revert to srcOr mode}
   addMax      = 37; {compare the source and destination pixels, and }
                     { replace the destination pixel with the color }
                     { containing the greater saturation of each of the RGB }
                     { components; if the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcBic mode}

   subOver     = 38; {replace destination pixel with the difference of the }
                     { source and destination pixel colors--but if the }
                     { value of the red, green, or blue component is less }
                     { than 0, add the negative result to 65,536; if the }
                     { destination is a bitmap or 1-bit pixel map, revert }
                     { to srcXor mode}
   adMin       = 39; {compare the source and destination pixels, and }
                     { replace the destination pixel with the color }
                     { containing the lesser saturation of each of the RGB }
                     { components; if the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcOr mode}
{transparent mode constant}
   transparent = 36; {replace the destination pixel with the source pixel }
                     { if the source pixel isn't equal to the background }
                     { color}
hilite      = 50; {add to source or pattern mode for highlighting}
   hiliteBit   = 7;  {flag bit in HiliteMode (lowMem flag)}
   pHiliteBit  = 0;  {flag bit in HiliteMode used with BitClr procedure}
defQDColors = 127;   {resource ID of 'clut' for default QDColors}
{pixel type}
   RGBDirect = 16;      {16 &amp; 32 bits per pixel pixelType value}
{pmVersion values}
   baseAddr32 = 4;    {pixmap base address is 32-bit address}
</PRE>
<A NAME=HEADING269-11></A>
<H3>Data Types</H3>
<PRE>
TYPE  PixMap      = 
RECORD
   baseAddr:      Ptr;        {pixel image}
   rowBytes:      Integer;    {flags, and row width}
   bounds:        Rect;       {boundary rectangle}
   pmVersion:     Integer;    {PixMap record version number}
   packType:      Integer;    {packing format}
   packSize:      LongInt;    {size of data in packed state}
   hRes:          Fixed;      {horizontal resolution (dpi)}
   vRes:          Fixed;      {vertical resolution (dpi)}
   pixelType:     Integer;    {format of pixel image}
   pixelSize:     Integer;    {physical bits per pixel}
   cmpCount:      Integer;    {logical components per pixel}
   cmpSize:       Integer;    {logical bits per component}
   planeBytes:    LongInt;    {offset to next plane}
   pmTable:       CTabHandle; {handle to color table for this image}
   pmReserved:    LongInt;    {reserved for future expansion}
END;
CGrafPtr       =\xDD^CGrafPort;
CGrafPort      = 
RECORD
   device:        Integer;       {device ID for font selection}
   portPixMap:    PixMapHandle;  {handle to PixMap record}
   portVersion:   Integer;       {highest 2 bits always set}
   grafVars:      Handle;        {handle to GrafVars record}
   chExtra:       Integer;       {added width for nonspace characters}
   pnLocHFrac:    Integer;       {pen fraction}
   portRect:      Rect;          {port rectangle}
   visRgn:        RgnHandle;     {visible region}
   clipRgn:       RgnHandle;     {clipping region}
   bkPixPat:      PixPatHandle;  {background pattern}
   rgbFgColor:    RGBColor;      {requested foreground color}
   rgbBkColor:    RGBColor;      {requested background color}
   pnLoc:         Point;         {pen location}
   pnSize:        Point;         {pen size}
   pnMode:        Integer;       {pattern mode}
   pnPixPat:      PixPatHandle;  {pen pattern}
   fillPixPat:    PixPatHandle;  {fill pattern}
   pnVis:         Integer;       {pen visibility}
   txFont:        Integer;       {font number for text}
   txFace:        Style;         {text's font style}
   txMode:        Integer;       {source mode for text}
   txSize:        Integer;       {font size for text}
   spExtra:       Fixed;         {added width for space characters}
   fgColor:       LongInt;       {actual foreground color}
   bkColor:       LongInt;       {actual background color}
   colrBit:       Integer;       {plane being drawn}
   patStretch:    Integer;       {used internally}
   picSave:       Handle;        {picture being saved, used internally}
   rgnSave:       Handle;        {region being saved, used internally}
   polySave:      Handle;        {polygon being saved, used internally}
   grafProcs:     CQDProcsPtr;   {low-level drawing routines}
END;
RGBColor       = 
RECORD
   red:     Integer;    {red\xDDcomponent}
   green:   Integer;    {green\xDDcomponent}
   blue:    Integer;    {blue\xDDcomponent}
END;
ColorSpec      = 
RECORD
   value:   Integer;    {index or other value}
   rgb:     RGBColor;   {true color}
END;
cSpecArray : ARRAY[0..0] OF ColorSpec;
CTabHandle     =\xDD^CTabPtr;
CTabPtr        =\xDD^ColorTable;
ColorTable     =\xDD
RECORD
   ctSeed:  LongInt;    {unique identifier from table}
   ctFlags: Integer;    {contains flags describing the ctTable field; }
                        { clear for a PixMap record}
   ctSize:\xDD Integer;    {number\xDDof\xDDentries\xDDin\xDDthe next field minus 1}
   ctTable: cSpecArray; {an array of ColorSpec records}
END;
MatchRec       = 
RECORD
   red:        Integer; {red component of seed}
   green:      Integer; {green component of seed}
   blue:       Integer; {blue component of seed}
   matchData:  LongInt; {value in matchData parameter of }
                        { SeedCFill or CalcCMask}
END;
PixPatHandle   = ^PixPatPtr;
PixPatPtr      = ^PixPat;
PixPat         = 
RECORD
   patType:    Integer;       {pattern type}
   patMap:     PixMapHandle;  {PixMap record for pattern}
   patData:    Handle;        {pixel image defining pattern}
   patXData:   Handle;        {expanded pixel image}
   patXValid:  Integer;       {flags for expanded pattern data}
   patXMap:    Handle;        {handle to expanded pattern data}
   pat1Data:   Pattern;       {bit pattern for a GrafPort record}
END;
CQDProcsPtr       = ^CQDProcs
CQDProcs          = 
RECORD
   textProc:      Ptr;  {text drawing}
   lineProc:      Ptr;  {line drawing}
   rectProc:      Ptr;  {rectangle drawing}
   rRectProc:     Ptr;  {rounded rectangle drawing}
   ovalProc:      Ptr;  {oval drawing}
   arcProc:       Ptr;  {arc and wedge drawing}
   polyProc:      Ptr;  {polygon drawing}
   rgnProc:       Ptr;  {region drawing}
   bitsProc:      Ptr;  {bit transfer}
   commentProc:   Ptr;  {picture comment processing}
   txMeasProc:    Ptr;  {text width measurement}
   getPicProc:    Ptr;  {picture retrieval}
   putPicProc:    Ptr;  {picture saving}
   opcodeProc:    Ptr;  {reserved for future use}
   newProc1:      Ptr;  {reserved for future use}
   newProc2:      Ptr;  {reserved for future use}
   newProc3:      Ptr;  {reserved for future use}
   newProc4:      Ptr;  {reserved for future use}
   newProc5:      Ptr;  {reserved for future use}
   newProc6:      Ptr;  {reserved for future use}
END;
GrafVars       = 
RECORD
   rgbOpColor:       RGBColor;   {color for addPin, subPin, and blend}
   rgbHiliteColor:   RGBColor;   {color for highlighting}
   pmFgColor:        Handle;     {palette handle for foreground color}
   pmFgIndex:        Integer;    {index value for foreground}
   pmBkColor:        Handle;     {palette handle for background color}
   pmBkIndex:        Integer;    {index value for background}
   pmFlags:          Integer;    {flags for Palette Manager}
END;
</PRE>
<A NAME=HEADING269-22></A>
<H3>Color QuickDraw Routines</H3>
<A NAME=HEADING269-23></A>
<H4>Opening and Closing Color Graphics Ports</H4>
<PRE>
PROCEDURE OpenCPort        (port: CGrafPtr);
PROCEDURE InitCPort        (port: CGrafPtr); 
PROCEDURE CloseCPort       (port: CGrafPtr); 
</PRE>
<A NAME=HEADING269-27></A>
<H4>Managing a Color Graphics Pen</H4>
<PRE>
PROCEDURE PenPixPat        (ppat: PixPatHandle);
</PRE>
<A NAME=HEADING269-29></A>
<H4>Changing the Background Pixel Pattern</H4>
<PRE>
PROCEDURE BackPixPat       (ppat: PixPatHandle);
</PRE>
<A NAME=HEADING269-31></A>
<H4>Drawing With Color QuickDraw Colors</H4>
<PRE>
PROCEDURE RGBForeColor     (color: RGBColor);
PROCEDURE RGBBackColor     (color: RGBColor);
PROCEDURE SetCPixel        (h,v: Integer; cPix: RGBColor);
PROCEDURE FillCRect        (r: Rect; ppat: PixPatHandle);
PROCEDURE FillCRoundRect   (r: Rect; ovalWidth,ovalHeight: Integer; 
                            ppat: PixPatHandle);
PROCEDURE FillCOval        (r: Rect; ppat: PixPatHandle);
PROCEDURE FillCArc         (r: Rect; startAngle,arcAngle: Integer; 
                            ppat: PixPatHandle);
PROCEDURE FillCPoly        (poly: PolyHandle; ppat: PixPatHandle);
PROCEDURE FillCRgn         (rgn: RgnHandle; ppat: PixPatHandle);
PROCEDURE OpColor          (color: RGBColor);
PROCEDURE HiliteColor      (color: RGBColor);
</PRE>
<A NAME=HEADING269-43></A>
<H4>Determining Current Colors and Best Intermediate Colors</H4>
<PRE>
PROCEDURE GetForeColor     (VAR color: RGBColor);
PROCEDURE GetBackColor     (VAR color: RGBColor);
PROCEDURE GetCPixel        (h,v: Integer; VAR cPix: RGBColor);
FUNCTION GetGray           (device: GDHandle; backGround: RGBColor; 
                            VAR foreGround: RGBColor): Boolean;
</PRE>
<A NAME=HEADING269-48></A>
<H4>Calculating Color Fills</H4>
<PRE>
PROCEDURE SeedCFill        (srcBits,dstBits: BitMap; 
                            srcRect,dstRect: Rect; seedH,seedV: Integer; 
                            matchProc: ProcPtr; matchData: LongInt);
PROCEDURE CalcCMask        (srcBits,dstBits: BitMap; 
                            srcRect,dstRect: Rect; seedRGB: RGBColor; 
                            matchProc: ProcPtr; matchData: LongInt);
</PRE>
<A NAME=HEADING269-51></A>
<H4>Creating, Setting, and Disposing of Pixel Maps</H4>
<PRE>
{DisposePixMap is also spelled as DisposPixMap}
FUNCTION NewPixMap : PixMapHandle;
PROCEDURE CopyPixMap       (srcPM,dstPM: PixMapHandle);
PROCEDURE SetPortPix       (pm: PixMapHandle);
PROCEDURE DisposePixMap    (pm: PixMapHandle);
</PRE>
<A NAME=HEADING269-57></A>
<H4>Creating and Disposing of Pixel Patterns</H4>
<PRE>
{DisposePixPat is also spelled as DisposPixPat}
FUNCTION GetPixPat         (patID: Integer): PixPatHandle;
                            FUNCTION NewPixPat : PixPatHandle;
PROCEDURE CopyPixPat       (srcPP,dstPP: PixPatHandle);
PROCEDURE MakeRGBPat       (ppat: PixPatHandle; myColor: RGBColor);
PROCEDURE DisposePixPat    (ppat: PixPatHandle);
</PRE>
<A NAME=HEADING269-64></A>
<H4>Creating and Disposing of Color Tables</H4>
<PRE>
{DisposeCTable is also spelled as DisposCTable}
FUNCTION GetCTable         (ctID: Integer): CTabHandle;
PROCEDURE DisposeCTable    (cTable: CTabHandle);
</PRE>
<A NAME=HEADING269-68></A>
<H4>Retrieving Color QuickDraw Result Codes</H4>
<PRE>
FUNCTION QDError: Integer;
</PRE>
<A NAME=HEADING269-70></A>
<H4>Customizing Color QuickDraw Operations</H4>
<PRE>
PROCEDURE SetStdCProcs     (VAR cProcs: CQDProcs);
</PRE>
<A NAME=HEADING269-72></A>
<H4>Reporting Data Structure Changes to QuickDraw</H4>
<PRE>
PROCEDURE CTabChanged      (ctab: CTabHandle);
PROCEDURE PixPatChanged    (ppat: PixPatHandle);
PROCEDURE PortChanged      (port: GrafPtr);
PROCEDURE GDeviceChanged   (gdh: GDHandle);
</PRE>
<A NAME=HEADING269-77></A>
<H3>Application-Defined Routine</H3>
<PRE>
FUNCTION MyColorSearch     (rgb: RGBColor; position: LongInt): Boolean;
</PRE>
<A NAME=HEADING269-79></A>
<H2>C Summary</H2>
<A NAME=HEADING269-80></A>
<H3>Constants</H3>
<PRE>
enum {
   /* checking for Color QuickDraw and its features */
   gestaltQuickdrawVersion = 'qd  ',   /* Gestalt selector for Color
                                          QuickDraw */
   gestalt8BitQD     = 0x100, /* 8-bit Color QD */
   gestalt32BitQD    = 0x200, /* 32-bit Color QD */
   gestalt32BitQD11  = 0x210, /* 32-bit Color QDv1.1 */
   gestalt32BitQD12  = 0x220, /* 32-bit Color QDv1.2 */
   gestalt32BitQD13  = 0x230, /* System 7: 32-bit Color QDv1.3 */
   gestaltQuickdrawFeatures
                     = 'qdrw',   /* Gestalt selector for Color QuickDraw 
                                    features */
   gestaltHasColor         = 0,  /* Color QuickDraw is present */
   gestaltHasDeepGWorlds   = 1,  /* GWorlds deeper than 1 bit */
   gestaltHasDirectPixMaps = 2,  /* PixMaps can be direct--16 or 32 bit */
   gestaltHasGrayishTextOr = 3,  /* supports text mode grayishTextOr */

   /* source modes for color graphics ports */
   srcCopy     = 0,  /* determine how close the color of the source pixel is
                        to black, and assign this relative amount of
                        foreground color to the destination pixel; determine
                        how close the color of the source pixel is to white, 
                        and assign this relative amount of background color
                        to the destination pixel */
   srcOr       = 1,  /* determine how close the color of the source pixel is
                        to black, and assign this relative amount of
                        foreground color to the destination pixel */
   srcXor      = 2,  /* where source pixel is black, invert the destination
                        pixel--for a colored destination pixel, use the 
                        complement of its color if the pixel is direct,
                        invert its index if the pixel is indexed */
   srcBic      = 3,  /* determine how close the color of the source pixel is
                        to black, and assign this relative amount of
                        background color to the destination pixel */
   notSrcCopy  = 4,  /* determine how close the color of the source pixel is
                        to black, and assign this relative amount of
                        background color to the destination pixel; determine
                        how close the color of the source pixel is to white,
                        and assign this relative amount of foreground color
                        to the destination pixel */
   notSrcOr    = 5,  /* determine how close the color of the source pixel is
                        to white, and assign this relative amount of
                        foreground color to the destination pixel */
   notSrcXor   = 6,  /* where source pixel is white, invert destination
                        pixel--for a colored destination pixel, use the 
                        complement of its color if the pixel is direct, 
                        invert its index if the pixel is indexed */
   notSrcBic   = 7,  /* determine how close the color of the source pixel is
                        to white, and assign this relative amount of
                        background color to the destination pixel */

   /* special text transfer mode */
   grayishTextOr  = 49,
/* arithmetic transfer modes available in Color QuickDraw */
   blend       = 32, /* replace destination pixel with a blend of the source
                        and destination pixel colors; if the destination is a
                        bitmap or 1-bit pixel map, revert to srcCopy mode */
   addPin      = 33, /* replace destination pixel with the sum of the source
                        and destination pixel colors--up to a maximum
                        allowable value; if the destination is a bitmap or 
                        1-bit pixel map, revert to srcBic mode */
   addOver     = 34, /* replace destination pixel with the sum of the source
                        and destination pixel colors--but if the value of
                        the red, green, or blue component exceeds 65,536, 
                        subtract 65,536 from that value; if the destination
                        is a bitmap or 1-bit pixel map, revert to srcXor
                        mode */
   subPin      = 35, /* replace destination pixel with the difference of the
                        source and destination pixel colors--but not less
                        than a minimum allowable value; if the destination is
                        a bitmap or 1-bit pixel map, revert to srcOr mode */
   addMax      = 37, /* compare the source and destination pixels, and
                        replace the destination pixel with the color 
                        containing the greater saturation of each of the RGB
                        components; if the destination is a bitmap or 1-bit 
                        pixel map, revert to srcBic mode */
   subOver     = 38, /* replace destination pixel with the difference of the
                        source and destination pixel colors--but if the value
                        of the red, green, or blue component is less than 0,
                        add the negative result to 65,536; if the destination
                        is a bitmap or 1-bit pixel map, revert to 
                        srcXor mode */
   adMin       = 39, /* compare the source and destination pixels, and 
                        replace the destination pixel with the color 
                        containing the lesser saturation of each of the RGB 
                        components; if the destination is a bitmap or 1-bit 
                        pixel map, revert to srcOr mode */
/* transparent mode constant */
   transparent = 36, /* replace the destination pixel with the source pixel 
                        if the source pixel isn't equal to the background
                        color */
hilite      = 50, /* add to source or pattern mode for highlighting */
   hiliteBit   = 7,  /* flag bit in highlight mode (lowMem flag) */
   pHiliteBit  = 0,  /* flag bit in highlight mode used with BitClr
                        procedure */
defQDColors    = 127,   /* resource ID of 'clut' for default QDColors */
/* pixel type */
   RGBDirect = 16,          /* 16 &amp; 32 bits/pixel pixelType value */
/* pmVersion values */
   baseAddr32 = 4,         /* pixel map base address is 32-bit address */
};
</PRE>
<A NAME=HEADING269-89></A>
<H3>Data Types</H3>
<PRE>
struct PixMap {
   Ptr         baseAddr;      /* pixel image */
   short       rowBytes;      /* flags, and row width */
   Rect        bounds;        /* boundary rectangle */
   short       pmVersion;     /* PixMap version number */
   short       packType;      /* packing format */
   long        packSize;      /* size of data in packed state */
   Fixed       hRes;          /* horizontal resolution (dpi) */
   Fixed       vRes;          /* vertical resolution (dpi) */
   short       pixelType;     /* format of pixel image */
   short       pixelSize;     /* physical bits per pixel */
   short       cmpCount;      /* logical components per pixel */
   short       cmpSize;       /* logical bits per component */
   long        planeBytes;    /* offset to next plane */
   CTabHandle  pmTable;       /* handle to the ColorTable struct */
   long        pmReserved;    /* reserved for future expansion; must be 0 */
};
typedef struct PixMap PixMap;
typedef PixMap *PixMapPtr, **PixMapHandle;
typedef unsigned char PixelType;
struct CGrafPort {
   short          device;     /* device ID for font selection */
   PixMapHandle   portPixMap; /* handle to PixMap struct */
   short          portVersion;/* highest 2 bits always set */
   Handle         grafVars;   /* handle to a GrafVars struct */
   short          chExtra;    /* added width for nonspace characters */
   short          pnLocHFrac; /* pen fraction */
   Rect           portRect;   /* port rectangle */
   RgnHandle      visRgn;     /* visible region */
   RgnHandle      clipRgn;    /* clipping region */
   PixPatHandle   bkPixPat;   /* background pattern */
   RGBColor       rgbFgColor; /* requested foreground color */
   RGBColor       rgbBkColor; /* requested background color */
   Point          pnLoc;      /* pen location */
   Point          pnSize;     /* pen size */
   short          pnMode;     /* pattern mode */
   PixPatHandle   pnPixPat;   /* pen pattern */
   PixPatHandle   fillPixPat; /* fill pattern */
   short          pnVis;      /* pen visibility */
   short          txFont;     /* font number for text */
   Style          txFace;     /* text's font style */
   char           filler;     
   short          txMode;     /* source mode for text */
   short          txSize;     /* font size for text */
   Fixed          spExtra;    /* added width for space characters */
   long           fgColor;    /* actual foreground color */
   long           bkColor;    /* actual background color */
   short          colrBit;    /* plane being drawn */
   short          patStretch; /* used internally */
   Handle         picSave;    /* picture being saved, used internally */
   Handle         rgnSave;    /* region being saved, used internally */
   Handle         polySave;   /* polygon being saved, used internally */
   CQDProcsPtr    grafProcs;  /* low-level drawing routines */
};
typedef struct CGrafPort CGrafPort;
typedef CGrafPort *CGrafPtr;
typedef CGrafPtr CWindowPtr;
struct RGBColor {
   unsigned short red;     /* magnitude of red component */
   unsigned short green;   /* magnitude of green component */
   unsigned short blue;    /* magnitude of blue component */
};
typedef struct RGBColor RGBColor;
struct ColorSpec {
   short       value;   /* index or other value */
   RGBColor    rgb;     /* true color */
};
typedef struct ColorSpec ColorSpec;
typedef ColorSpec *ColorSpecPtr;
typedef ColorSpec CSpecArray[1];
struct ColorTable {
   long        ctSeed;     /* unique identifier for table */
   short       ctFlags;    /* high bit: 0 = PixMap; 1 = device */
   short       ctSize;     /* number of entries in next field */
   CSpecArray  ctTable;    /* array[0..0] of ColorSpec records */
};
typedef struct ColorTable ColorTable;
typedef ColorTable *CTabPtr, **CTabHandle;
struct MatchRec {
   unsigned short red;        /* red component of seed */
   unsigned short green;      /* green component of seed */
   unsigned short blue;       /* blue component of seed */
   long matchData;            /* value in matchData parameter of 
                                 SeedCFill or CalcCMask */
};
typedef struct MatchRec MatchRec;
struct PixPat {
   short          patType;    /* pattern type */
   PixMapHandle   patMap;     /* PixMap structure for pattern */
   Handle         patData;    /* pixel-image defining pattern */
   Handle         patXData;   /* expanded pattern image */
   short          patXValid;  /* for expanded pattern data */
   Handle         patXMap;    /* handle to expanded pattern data */
   Pattern        pat1Data;   /* a bit pattern for a GrafPort structure */
};
typedef struct PixPat PixPat;
typedef PixPat *PixPatPtr, **PixPatHandle;
struct CQDProcs {
   Ptr textProc;     /* text drawing */
   Ptr lineProc;     /* line drawing */
   Ptr rectProc;     /* rectangle drawing */
   Ptr rRectProc;    /* rounded rectangle drawing */
   Ptr ovalProc;     /* oval drawing */
   Ptr arcProc;      /* arc/wedge drawing */
   Ptr polyProc;     /* polygon drawing */
   Ptr rgnProc;      /* region drawing */
   Ptr bitsProc;     /* bit transfer */
   Ptr commentProc;  /* picture comment processing */
   Ptr txMeasProc;   /* text width measurement */
   Ptr getPicProc;   /* picture retrieval */
   Ptr putPicProc;   /* picture saving */
   Ptr opcodeProc;   /* reserved for future use */
   Ptr newProc1;     /* reserved for future use */
   Ptr newProc2;     /* reserved for future use */
   Ptr newProc3;     /* reserved for future use */
   Ptr newProc4;     /* reserved for future use */
   Ptr newProc5;     /* reserved for future use */
   Ptr newProc6;     /* reserved for future use */
};
typedef struct CQDProcs CQDProcs;
typedef CQDProcs *CQDProcsPtr;
struct GrafVars {
   RGBColor    rgbOpColor;       /* color for addPin,subPin,and blend */
   RGBColor    rgbHiliteColor;   /* color for highlighting */
   Handle      pmFgColor;        /* palette handle for foreground color */
   short       pmFgIndex;        /* index value for foreground */
   Handle      pmBkColor;        /* palette handle for background color */
   short       pmBkIndex;        /* index value for background */
   short       pmFlags;          /* flags for Palette Manager */
};
typedef struct GrafVars GrafVars;
typedef GrafVars *GVarPtr, **GVarHandle;
</PRE>
<A NAME=HEADING269-101></A>
<H3>Color QuickDraw Functions</H3>
<A NAME=HEADING269-102></A>
<H4>Opening and Closing Color Graphics Ports</H4>
<PRE>
pascal void OpenCPort       (CGrafPtr port); 
pascal void InitCPort       (CGrafPtr port); 
pascal void CloseCPort      (CGrafPtr port); 
</PRE>
<A NAME=HEADING269-106></A>
<H4>Managing a Color Graphics Pen</H4>
<PRE>
pascal void PenPixPat       (PixPatHandle pp); 
</PRE>
<A NAME=HEADING269-108></A>
<H4>Changing the Background Pixel Pattern</H4>
<PRE>
pascal void BackPixPat      (PixPatHandle pp); 
</PRE>
<A NAME=HEADING269-110></A>
<H4>Drawing With Color QuickDraw Colors</H4>
<PRE>
pascal void RGBForeColor    (const RGBColor *color); 
pascal void RGBBackColor    (const RGBColor *color); 
pascal void SetCPixel       (short h, short v, const RGBColor *cPix); 
pascal void FillCRect       (const Rect *r, PixPatHandle pp); 
pascal void FillCRoundRect  (const Rect *r, short ovalWidth, 
                             short ovalHeight, PixPatHandle pp); 
pascal void FillCOval       (const Rect *r, PixPatHandle pp); 
pascal void FillCArc        (const Rect *r, short startAngle,
                             short arcAngle, PixPatHandle pp); 
pascal void FillCPoly       (PolyHandle poly, PixPatHandle pp); 
pascal void FillCRgn        (RgnHandle rgn, PixPatHandle pp); 
pascal void OpColor         (const RGBColor *color); 
pascal void HiliteColor     (const RGBColor *color); 
</PRE>
<A NAME=HEADING269-122></A>
<H4>Determining Current Colors and Best Intermediate Colors</H4>
<PRE>
pascal void GetForeColor    (RGBColor *color); 
pascal void GetBackColor    (RGBColor *color); 
pascal void GetCPixel       (short h, short v, RGBColor *cPix);
pascal Boolean GetGray      (GDHandle device, const RGBColor *backGround, 
                             RGBColor *foreGround); 
</PRE>
<A NAME=HEADING269-127></A>
<H4>Calculating Color Fills</H4>
<PRE>
pascal void SeedCFill       (const BitMap *srcBits, const BitMap *dstBits, 
                             const Rect *srcRect, const Rect *dstRect, 
                             short seedH, short seedV, 
                             ColorSearchProcPtr matchProc, long matchData); 
pascal void CalcCMask       (const BitMap *srcBits, const BitMap *dstBits, 
                             const Rect *srcRect, const Rect *dstRect, 
                             const RGBColor *seedRGB, 
                             ColorSearchProcPtr matchProc, long matchData); 
</PRE>
<A NAME=HEADING269-130></A>
<H4>Creating, Setting, and Disposing of Pixel Maps</H4>
<PRE>
/* DisposePixMap is also spelled as DisposPixMap */
pascal PixMapHandle NewPixMap
                            (void); 
pascal void CopyPixMap      (PixMapHandle srcPM, PixMapHandle dstPM); 
pascal void SetPortPix      (PixMapHandle pm); 
pascal void DisposePixMap   (PixMapHandle pm); 
</PRE>
<A NAME=HEADING269-137></A>
<H4>Creating and Disposing of Pixel Patterns</H4>
<PRE>
/* DisposePixPat is also spelled as DisposPixPat */
pascal PixPatHandle GetPixPat
                            (short patID); 
pascal PixPatHandle NewPixPat
                            (void);
pascal void CopyPixPat      (PixPatHandle srcPP, PixPatHandle dstPP); 
pascal void MakeRGBPat      (PixPatHandle pp, const RGBColor *myColor); 
pascal void DisposePixPat   (PixPatHandle pp); 
</PRE>
<A NAME=HEADING269-146></A>
<H4>Creating and Disposing of Color Tables</H4>
<PRE>
/* DisposeCTable is also spelled as DisposCTable */
pascal CTabHandle GetCTable
                            (short ctID); 
pascal void DisposeCTable   (CTabHandle cTable); 
</PRE>
<A NAME=HEADING269-151></A>
<H4>Retrieving Color QuickDraw Result Codes</H4>
<PRE>
pascal short QDError        (void);
</PRE>
<A NAME=HEADING269-153></A>
<H4>Customizing Color QuickDraw Operations</H4>
<PRE>
pascal void SetStdCProcs    (CQDProcs *procs); 
</PRE>
<A NAME=HEADING269-155></A>
<H4>Reporting Data Structure Changes to QuickDraw</H4>
<PRE>
pascal void CTabChanged     (CTabHandle ctab);
pascal void PixPatChanged   (PixPatHandle ppat);
pascal void PortChanged     (GrafPtr port);
pascal void GDeviceChanged  (GDHandle gdh);
</PRE>
<A NAME=HEADING269-160></A>
<H3>Application-Defined Function</H3>
<PRE>
pascal Boolean MyColorSearch(rgb RGBColor, position LongInt);
</PRE>
<A NAME=HEADING269-162></A>
<H2>Assembly-Language Summary</H2>
<A NAME=HEADING269-163></A>
<H3>Data Structures</H3>
<A NAME=HEADING269-164></A>
<H4>PixMap Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>pmBaseAddr<TD>long<TD>pixel image <TR>
<TD>4<TD>pmRowBytes<TD>word<TD>flags, and row width<TR>
<TD>6<TD>pmBounds<TD>8 bytes<TD>boundary rectangle<TR>
<TD>14<TD>pmVersion<TD>word<TD><CODE>PixMap</CODE> version number<TR>
<TD>16<TD>pmPackType<TD>word<TD>packing format<TR>
<TD>18<TD>pmPackSize<TD>long<TD>size of data in packed state<TR>
<TD>22<TD>pmHRes<TD>long<TD>horizontal resolution (dpi)<TR>
<TD>26<TD>pmVRes<TD>long<TD>vertical resolution (dpi)<TR>
<TD>30<TD>pmPixelType<TD>word<TD>format of pixel image<TR>
<TD>32<TD>pmPixelSize<TD>word<TD>physical bits per pixel<TR>
<TD>34<TD>pmCmpCount<TD>word<TD>logical components per pixel<TR>
<TD>36<TD>pmCmpSize<TD>word<TD>logical bits per component<TR>
<TD>38<TD>pmPlaneBytes<TD>long<TD>offset to next plane<TR>
<TD>42<TD>pmTable<TD>long<TD>handle to next <CODE>ColorTable</CODE> record<TR>
<TD>46<TD>pmReserved<TD>long<TD>reserved; must be 0</TABLE>
</H4>
<A NAME=HEADING269-165></A>
<H4>CGrafPort Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>device<TD>short<TD>device ID for font selection<TR>
<TD>2<TD>portPixMap<TD>long<TD>handle to <CODE>PixMap</CODE> record<TR>
<TD>6<TD>portVersion<TD>short<TD>highest 2 bits always set<TR>
<TD>8<TD>grafVars<TD>long<TD>handle to <CODE>GrafVars</CODE> record<TR>
<TD>12<TD>chExtra<TD>short<TD>added width for nonspace characters<TR>
<TD>14<TD>pnLocHFrac<TD>short<TD>pen fraction<TR>
<TD>16<TD>portRect<TD>8 bytes<TD>port rectangle<TR>
<TD>24<TD>visRgn<TD>long<TD>visible region<TR>
<TD>28<TD>clipRgn<TD>long<TD>clipping region<TR>
<TD>32<TD>bkPixPat<TD>long<TD>background pattern<TR>
<TD>36<TD>rgbForeColor<TD>6 bytes<TD>requested foreground color<TR>
<TD>42<TD>rgbBackColor<TD>6 bytes<TD>requested background color<TR>
<TD>48<TD>pnLoc<TD>long<TD>pen location<TR>
<TD>52<TD>pnSize<TD>long<TD>pen size<TR>
<TD>56<TD>pnMode<TD>word<TD>pattern mode<TR>
<TD>58<TD>pnPixPat<TD>long<TD>pen pattern<TR>
<TD>62<TD>fillPixPat<TD>long<TD>fill pattern<TR>
<TD>66<TD>pnVis<TD>word<TD>pen visibility<TR>
<TD>68<TD>txFont<TD>word<TD>font number for text<TR>
<TD>70<TD>txFace<TD>word<TD>text's font style<TR>
<TD>72<TD>txMode<TD>word<TD>source mode for text<TR>
<TD>74<TD>txSize<TD>word<TD>font size for text<TR>
<TD>76<TD>spExtra<TD>long<TD>added width for space characters<TR>
<TD>80<TD>fgColor<TD>long<TD>actual foreground color <TR>
<TD>84<TD>bkColor<TD>long<TD>actual background color <TR>
<TD>88<TD>colrBit<TD>word<TD>plane being drawn<TR>
<TD>90<TD>patStretch<TD>word<TD>used internally<TR>
<TD>92<TD>picSave<TD>long<TD>picture being saved, used internally<TR>
<TD>96<TD>rgnSave<TD>long<TD>region being saved, used internally<TR>
<TD>100<TD>polySave<TD>long<TD>polygon being saved, used internally<TR>
<TD>104<TD>grafProcs<TD>long<TD>low-level drawing routines</TABLE>
</H4>
<A NAME=HEADING269-166></A>
<H4>Relative Offsets of Additional Fields in a CGrafPort Record
<TABLE BORDER="0" CELLPADDING=3><TD>portBits<TD>portPixMap<TD>long<TD>handle to <CODE>PixMap</CODE> record<TR>
<TD>portPixMap+4<TD>portVersion<TD>word<TD>highest 2 bits always set<TR>
<TD>portVersion+2<TD>grafVars<TD>long<TD>handle to a <CODE>GrafVars</CODE> record<TR>
<TD>grafVars+4<TD>chExtra<TD>word<TD>added width for nonspace characters<TR>
<TD>chExtra+2<TD>pnLocHFrac<TD>word<TD>pen fraction<TR>
<TD>bkPat<TD>bkPixPat<TD>long<TD>background pattern<TR>
<TD>bkPixPat+4<TD>rgbFgColor<TD>6 bytes<TD>requested foreground color<TR>
<TD>rgbFgColor+6<TD>rgbBkColor<TD>6 bytes<TD>requested background color<TR>
<TD>pnPat<TD>pnPixPat<TD>long<TD>pen pattern<TR>
<TD>pnPixPat+4<TD>fillPixPat<TD>long<TD>fill pattern</TABLE>
</H4>
<A NAME=HEADING269-167></A>
<H4>RGBColor Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>red<TD>short<TD>magnitude of red component <TR>
<TD>2<TD>green<TD>short<TD>magnitude of green component<TR>
<TD>4<TD><CODE>blue</CODE><TD>short<TD>magnitude of blue component</TABLE>
</H4>
<A NAME=HEADING269-168></A>
<H4>ColorSpec Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>value<TD>short<TD>index or other value<TR>
<TD>2<TD>rgb<TD>6 bytes<TD>true color</TABLE>
</H4>
<A NAME=HEADING269-169></A>
<H4>ColorTable Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>ctSeed<TD>long<TD>unique identifier for table<TR>
<TD>4<TD>transIndex<TD>word<TD>index of transparent pixel (obsolete)<TR>
<TD>8<TD>ctFlags<TD>word<TD>high bit: 0 = pixel map; 1 = device<TR>
<TD>10<TD>ctSize<TD>word<TD>number of entries in next field<TR>
<TD>12<TD>ctTable<TD>variable<TD>array of <CODE>ColorSpec</CODE> records</TABLE>
</H4>
<A NAME=HEADING269-170></A>
<H4>MatchRec Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>red<TD>word<TD>red component of seed<TR>
<TD>2<TD>green<TD>word<TD>green component of seed<TR>
<TD>4<TD>blue<TD>word<TD>blue component of seed<TR>
<TD>6<TD><CODE>matchData</CODE><TD>long<TD>value in <CODE>matchData</CODE> parameter of <CODE>SeedCFill</CODE> or <CODE>CalcCMask</CODE> </TABLE>
</H4>
<A NAME=HEADING269-171></A>
<H4>PixPat Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>patType<TD>word<TD>pattern type <TR>
<TD>2<TD>patMap<TD>long<TD>handle to <CODE>PixMap</CODE> record for pattern<TR>
<TD>6<TD>patData<TD>long<TD>pixel-image defining pattern<TR>
<TD>10<TD>patXData<TD>long<TD>expanded pattern data<TR>
<TD>14<TD>patXValid<TD>word<TD>for expanded pattern data<TR>
<TD>16<TD>patXMap<TD>long<TD>handle to expanded pattern data<TR>
<TD>20<TD>pat1Data<TD>8 bytes<TD>a bit pattern for a <CODE>GrafPort</CODE> record<TR>
<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;</TABLE>
</H4>
<A NAME=HEADING269-172></A>
<H4>CQDProcs Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>textProc<TD>long<TD>pointer to text-drawing routine<TR>
<TD>4<TD>lineProc<TD>long<TD>pointer to line-drawing routine<TR>
<TD>8<TD>rectProc<TD>long<TD>pointer to rectangle-drawing routine<TR>
<TD>12<TD>rRectProc<TD>long<TD>pointer to rounded rectangle-drawing routine<TR>
<TD>16<TD>ovalProc<TD>long<TD>pointer to oval-drawing routine<TR>
<TD>20<TD>arcProc<TD>long<TD>pointer to arc/wedge-drawing routine<TR>
<TD>24<TD>polyProc<TD>long<TD>pointer to polygon-drawing routine<TR>
<TD>28<TD>rgnProc<TD>long<TD>pointer to region-drawing routine<TR>
<TD>32<TD>bitsProc<TD>long<TD>pointer to bit transfer routine<TR>
<TD>36<TD>commentProc<TD>long<TD>pointer to picture comment-processing routine<TR>
<TD>40<TD>txMeasProc<TD>long<TD>pointer to text-width measurement routine<TR>
<TD>44<TD>getPicProc<TD>long<TD>pointer to picture retrieval routine<TR>
<TD>48<TD>putPicProc<TD>long<TD>pointer to picture-saving routine<TR>
<TD>52<TD>opcodeProc<TD>long<TD>reserved for future use<TR>
<TD>56<TD>newProc1<TD>long<TD>reserved for future use<TR>
<TD>60<TD>newProc2<TD>long<TD>reserved for future use<TR>
<TD>64<TD>newProc3<TD>long<TD>reserved for future use<TR>
<TD>68<TD>newProc4<TD>long<TD>reserved for future use<TR>
<TD>72<TD>newProc5<TD>long<TD>reserved for future use<TR>
<TD>76<TD>newProc6<TD>long<TD>reserved for future use</TABLE>
</H4>
<A NAME=HEADING269-173></A>
<H4>GrafVars Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>rgbOpColor<TD>6 bytes<TD>color for <CODE>addPin</CODE>, <CODE>subPin</CODE>, and <CODE>blend</CODE><TR>
<TD>6<TD>rgbHiliteColor<TD>6 bytes<TD>color for highlighting<TR>
<TD>12<TD>pmFgColor<TD>long<TD>palette handle for foreground color<TR>
<TD>16<TD>pmFgIndex<TD>short<TD>index value for foreground color<TR>
<TD>18<TD>pmBkColor<TD>long<TD>palette handle for background color<TR>
<TD>22<TD>pmBkIndex<TD>short<TD>index value for background color<TR>
<TD>24<TD>pmFlags<TD>short<TD>flags for Palette Manager</TABLE>
</H4>
<A NAME=HEADING269-174></A>
<H4>Trap Macros Requiring Routine Selectors</H4>
<PRE>
_QDExtensions<CODE>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Selector<TH>Routine<TR>
<TD>$00040007<TD>CTabChanged<TR>
<TD>$00040008<TD>PixPatChanged<TR>
<TD>$00040009<TD>PortChanged<TR>
<TD>$0004000A<TD>GDeviceChanged</TABLE>
</CODE>
</PRE>
<A NAME=HEADING269-176></A>
<H2>Result Codes
<TABLE BORDER="0" CELLPADDING=3><TD>noErr<TD>0<TD>No error<TR>
<TD>paramErr<TD>-50<TD>Illegal parameter to <CODE>NewGWorld</CODE><TR>
<TD>&nbsp;<TD>-143<TD><CODE>CopyBits</CODE> couldn't allocate required temporary memory<TR>
<TD>&nbsp;<TD>-144<TD>Ran out of stack space while drawing polygon<TR>
<TD>noMemForPictPlaybackErr<TD>-145<TD>Insufficient memory for drawing the picture<TR>
<TD>regionTooBigError<TD>-147<TD>Region too big or complex<TR>
<TD>pixmapTooDeepErr<TD>-148<TD>Pixel map is deeper than 1 bit per pixel<TR>
<TD>nsStackErr<TD>-149<TD>Insufficient stack<TR>
<TD>cMatchErr<TD>-150<TD><CODE>Color2Index</CODE> failed to find an index<TR>
<TD>cTempMemErr<TD>-151<TD>Failed to allocate memory for temporary structures<TR>
<TD>cNoMemErr<TD>-152<TD>Failed to allocate memory for structure<TR>
<TD>cRangeErr<TD>-153<TD>Range error on color table request<TR>
<TD>cProtectErr<TD>-154<TD><CODE>ColorTable</CODE> record entry protection violation<TR>
<TD>cDevErr<TD>-155<TD>Invalid type of graphics device<TR>
<TD>cResErr<TD>-156<TD>Invalid resolution for <CODE>MakeITable</CODE><TR>
<TD>cDepthErr<TD>-157<TD>Invalid pixel depth specified to <CODE>NewGWorld</CODE><TR>
<TD>rgnTooBigErr<TD>-500<TD>Bitmap would convert to a region greater than 64 KB</TABLE>
</H2>
</BLOCKQUOTE><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-268.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-270.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
