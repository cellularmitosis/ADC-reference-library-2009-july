<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> Interrupt Model</TITLE></HEAD><BODY BGCOLOR="#ffffff"><DIV><a name="top"></a><!-- start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!-- start of path --><font face="Geneva,Helvetica,Arial" size="1"><b><br>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Documentation</a> &gt; <!-- a href="" target="_top" -->Hardware<!-- /a -->  <b>&gt; </b><a href="../../devicemgrs.html" target="_top">Device Managers and Drivers</a> <b>&gt; </b><a href="../pci_srvcs.html" target="_top">PCI Card Services</a> <b>&gt; </b>Designing PCI Cards and Drivers for Power Macintosh Computers</font><br><br><!-- end of path --><A HREF="PCI_BOOK.16b.html"><img src="images/up.gif" border="0" width="36" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.16c.html"><img src="images/previous.gif" border="0" width="66" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.16e.html"><img src="images/next.gif" border="0" width="49" height="16"></A><!-- insert Show/Hide frames --><a href="javascript:testFrame()"><script><!--document.write(frameLink);//--></script><!-- end Show/Hide frames --></A><HR></DIV><H1 CLASS="H2.Heading2"><A NAME="pgfId=4166"> </A>Interrupt Model</H1><P CLASS="T1.Text1"><A NAME="pgfId=4167"> </A>Interrupt dispatching and control hardware may be designed in a variety of styles and capabilities. In some hardware systems, software must do most of the work of determining which devices that generate interrupts need to be serviced and in what order the system must service them. Other hardware systems may contain specific vectorization and priority schemes that force the software to respond in predetermined ways. </P><P CLASS="T1.Text1"><A NAME="pgfId=4168"> </A>Designing a driver so that it can respond to the details of every interrupt mechanism in every hardware system limits the driver's portability and increases its complexity. As a result, the native driver interrupt model for PCI-based Macintosh computers was introduced and replaces the traditional interrupt-handling mechanisms used in previous Macintosh computers without a PCI bus. This new model provides a more standardized execution environment for interrupt processing by using two key strategies:</P><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=4169"> </A>The native driver model formalizes the concept of hardware and secondary interrupt levels for processing interrupts. Hardware interrupt level execution happens as a direct result of a hardware interrupt request. Secondary interrupt level provides a way to defer noncritical interrupt processing until after all hardware interrupts have been serviced, thereby reducing hardware interrupt latency.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=4170"> </A>The control and propagation of hardware interrupts are abstracted from the driver software. An interrupt source for a device is represented by a node in a hierarchical tree, called an<B CLASS="bold"> interrupt source tree (IST).</B><A NAME="marker=4171"> </A> Generally the leaf nodes of the tree represent interrupt sources for devices and the parent nodes represent dispatching or demultiplexing points. This removes the need for drivers to respond in detail to hardware interrupt mechanisms; they need only contain interrupt-handling code specific to the devices they control. Driver writers no longer need to know how interrupts are multiplexed by a particular hardware platform (such as through versatile interface adapters [VIAs), or handle CPU-specific low memory interrupt vectors.</LI></UL><DIV><blockquote><p CLASS="ImportantHead"><b><A NAME="pgfId=19136"> </A>IMPORTANT</b></p><P CLASS="I.Important"><A NAME="pgfId=4172"> </A>A consequence of abstracting the interrupt-handling process from its hardware implementation is that interrupt service routines (ISRs) may be called when their devices did not cause the interrupt. To minimize processing overhead, each interrupt service routine must quickly determine if it is needed and return immediately if it is not. </P></blockquote><P CLASS="T1.Text1"><A NAME="pgfId=4176"> </A>A rule that native drivers can follow to minimize interrupt processing overhead is as follows: When a driver determines that its associated device did not generate an interrupt, return <TT CLASS="cv">kIsrIsNotComplete</TT>. If a driver does not know if its device generated an interrupt, return <TT CLASS="cv">kIsrIsComplete</TT>. The interrupt dispatch handler will determine if the device is still issuing and interrupt and continue searching until is finds a match to service the interrupt. A discussion about how <TT CLASS="cv">kIsrIsComplete</TT> and <TT CLASS="cv">kIsrIsNotComplete</TT> are used can be found in <A HREF="PCI_BOOK.171.html#25712" CLASS="XRef">Interrupt Dispatching</A>.</P><P CLASS="T1.Text1"><A NAME="pgfId=7076"> </A>A more detailed description of interrupt concepts follows. </P></DIV><HR>&#169 1999 Apple Computer, Inc. &#150 (Last Updated 26 March 99)<P><A HREF="PCI_BOOK.16b.html"><img src="images/up.gif" border="0" width="36" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.16c.html"><img src="images/previous.gif" border="0" width="66" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.16e.html"><img src="images/next.gif" border="0" width="49" height="16"></A><!-- insert Show/Hide frames --><a href="javascript:testFrame()"><script><!--document.write(frameLink);//--></script><!-- end Show/Hide frames --></A><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></body></HTML>