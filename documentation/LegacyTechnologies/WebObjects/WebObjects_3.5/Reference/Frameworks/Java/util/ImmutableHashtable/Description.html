<html>

<body bgcolor="#FFFFFF">

<CENTER><H1>Class next.util.ImmutableHashtable</H1></CENTER>

<a name="description"></a><CENTER><H2>CLASS DESCRIPTION</H2></CENTER>

<!-- extends:next.util.NextObject -->

<DL>

<DT><B>Extends:</B></DT><DD>next.util.NextObject</DD>

</DL>

<P>

<DL>

<DT><B>Implements:</B></DT>

<!-- implements:next/util/Coding  -->

<DD>next/util/Coding </DD><BR>

</DL>

<P>

The ImmutableHashtable class declares the programmatic interface to objects that manage immutable associations of keys and values. ImmutableHashtable three primitive methods-<B>size</B>, <B>get</B>, and <B>keys</B>-provide the basis for all of the other methods in its interface. The <B>size</B> method returns the number of entries in the ImmutableHashtable. <B>get</B> returns the value associated with a given key. <B>keys</B> returns an object that lets you iterate through each of the keys in the ImmutableHashtable.
<P>
The other methods declared here operate by invoking one or more of these primitives. The non-primitive methods provide convenient ways of accessing multiple entries at once. <!-- The description... and writeToFile:atomically: methods cause a ImmutableHashtable to write a representation of itself to a string or to a file, respectively. 
-->
A key-value pair within an ImmutableHashtable is called an <I>entry</I>. Each entry consists of one object that represents the key, and a second object which is that key's value. Within an ImmutableHashtable, the keys are unique. That is, no two keys in a single ImmutableHashtable are equal. <!-- (as determined by isEqual:). 
-->
<P>
You establish an ImmutableHashtable's entries when it's created, and thereafter the entries can't be modified. A mutable hashtable allows the addition and deletion of entries at any time, automatically allocating memory as needed. 
<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- constructors -->

<a name="constructors"><CENTER><H2>CONSTRUCTORS</H2></CENTER></a>

<!-- consKey:ImmutableHashtable(public) cons:ImmutableHashtable descr:<TT>public  <B>ImmutableHashtable</B>(java.lang.Object[] <I>objects</I>, java.lang.Object[] <I>objects</I>)</TT>:<TT>public  <B>ImmutableHashtable</B>(java.util.Hashtable <I>aHashtable</I>)</TT>:<TT>public  <B>ImmutableHashtable</B>()</TT>:<TT>public  <B>ImmutableHashtable</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="ImmutableHashtable(public)">ImmutableHashtable</a></H3>

<TT>public  <B>ImmutableHashtable</B>()</TT><br>

<TT>public  <B>ImmutableHashtable</B>(java.lang.Object[] <I>keys</I>, java.lang.Object[] <I>objects</I>)</TT><br>

<TT>public  <B>ImmutableHashtable</B>(java.lang.String <I>path</I>)</TT><br>

<TT>public  <B>ImmutableHashtable</B>(java.util.Hashtable <I>aHashtable</I>)</TT>

<P>

Creates and returns an ImmutableHashtable.
<P>
If no parameters are supplied, the returned hashtable will be empty. This is used primarily by mutable subclasses of ImmutableHashtable.
<P>
If you supply both <I>keys</I> and <I>objects</I>, the returned ImmutableHashtable is initialized with entries constructed from the contents of the <I>keys</I> and <I>objects</I> arrays. This method steps through the <I>keys</I> and <I>objects</I> arrays, creating entries in the new ImmutableHashtable as it goes. <!-- Each value object receives a retain message before being added to the dictionary. In contrast, each key object is copied (using copyWithZone:), and the copy is added to the dictionary. --> An <!-- NSInvalidArgumentException --> exception is raised if the objects and keys arrays do not have the same number of elements.
<P>
If you supply <I>path</I>. the returned dictionary contains the keys and values found in the file specified by <I>path</I>. <I>path</I> can be a full or relative pathname; the file that it names must contain a string representation of an ImmutableHashtable. <!-- , such as that produced by the writeToFile:atomically: method. -->
<B>nil</B> is returned if there's a file error or if the contents of the file is an invalid representation of a ImmutableHashtable.
<P>
If you supply <I>aHashtable</I>, the returned ImmutableHashtable will be initialized with the contents of the specified Java Hashtable.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- methods -->

<a name="methods"><CENTER><H2>METHODS</H2></CENTER></a>

<!-- methKey:allKeysForObject(public) meth:allKeysForObject descr:<TT>public next.util.ImmutableVector <B>allKeysForObject</B>(java.lang.Object <I>anObject</I>)</TT> -->

<H3><a name="allKeysForObject(public)">allKeysForObject</a></H3>

<TT>public next.util.ImmutableVector <B>allKeysForObject</B>(java.lang.Object <I>anObject</I>)</TT>

<P>

Finds all occurrences of the value <I>anObject</I> in the ImmutableHashtable and returns a new vector with the corresponding keys. <!-- Each object in the dictionary is sent an isEqual: message to determine if it's equal to anObject. --> If no object matching <I>anObject</I> is found, this method returns <B>nil</B>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:contains(public) meth:contains descr:<TT>public boolean <B>contains</B>(java.lang.Object <I>anObject</I>)</TT> -->

<H3><a name="contains(public)">contains</a></H3>

<TT>public boolean <B>contains</B>(java.lang.Object <I>anObject</I>)</TT>

<P>

Returns whether the ImmutableHashtable contains at least key-value pair where the value is equal to <I>anObject</I>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:containsKey(public) meth:containsKey descr:<TT>public boolean <B>containsKey</B>(java.lang.Object <I>anObject</I>)</TT> -->

<H3><a name="containsKey(public)">containsKey</a></H3>

<TT>public boolean <B>containsKey</B>(java.lang.Object <I>aKey</I>)</TT>

<P>

Returns whether the ImmutableHashtable contains a least key-value pair where the key is equal to <I>aKey</I>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:elements(public) meth:elements descr:<TT>public java.util.Enumeration <B>elements</B>()</TT> -->

<H3><a name="elements(public)">elements</a></H3>

<TT>public java.util.Enumeration <B>elements</B>()</TT>

<P>

Returns an enumerator object that lets you access each value in the ImmutableHashtable. 
<!-- :
NSEnumerator *enumerator = [myDictionary objectEnumerator];
id value;

while ((value = [enumerator nextObject])) {
    /* code that acts on the dictionary's values */ 
}
-->
When this method is used with mutable hashtables, your code shouldn't modify the entries during enumeration. If you intend to modify the entries, use the <B>elements</B> method to create a "snapshot" of the hashtable's values. Work from this snapshot to modify the values.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:encodeWithCoder(public) meth:encodeWithCoder descr:<TT>public void <B>encodeWithCoder</B>(next.util.Coder <I>aCoder</I>)</TT> -->

<H3><a name="encodeWithCoder(public)">encodeWithCoder</a></H3>

<TT>public void <B>encodeWithCoder</B>(next.util.Coder <I>aCoder</I>)</TT>

<P>

Encodes the receiver using <I>aCoder</I>. See the Coding interface description for more information.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:get(public) meth:get descr:<TT>public java.lang.Object <B>get</B>(java.lang.Object <I>anObject</I>)</TT> -->

<H3><a name="get(public)">get</a></H3>

<TT>public java.lang.Object <B>get</B>(java.lang.Object <I>aKey</I>)</TT>

<P>

Returns an entry's value given its key, or <B>nil</B> if no value is associated with <I>aKey</I>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:getKeys(protected) meth:getKeys descr:<TT>protected void <B>getKeys</B>(java.lang.Object[] <I>objects</I>)</TT> -->

<H3><a name="getKeys(protected)">getKeys</a></H3>

<TT>protected void <B>getKeys</B>(java.lang.Object[] <I>keys</I>)</TT>

<P>

Returns the ImmutableHashtable's keys in <I>keys</I>. The order of the elements in the array isn't defined.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:getObjects(protected) meth:getObjects descr:<TT>protected void <B>getObjects</B>(java.lang.Object[] <I>objects</I>)</TT> -->

<H3><a name="getObjects(protected)">getObjects</a></H3>

<TT>protected void <B>getObjects</B>(java.lang.Object[] <I>objects</I>)</TT>

<P>

Returns the ImmutableHashtable's values in <I>objects</I>. The order of the elements in the array isn't defined.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:hashtable(public) meth:hashtable descr:<TT>public java.util.Hashtable <B>hashtable</B>()</TT> -->

<H3><a name="hashtable(public)">hashtable</a></H3>

<TT>public java.util.Hashtable <B>hashtable</B>()</TT>

<P>

Returns a Java hashtable containing the receiver's key-value pairs.

<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:initWithKeysAndObjects(protected) meth:initWithKeysAndObjects descr:<TT>protected void <B>initWithKeysAndObjects</B>(java.lang.Object[] <I>objects</I>, java.lang.Object[] <I>objects</I>)</TT> -->

<H3><a name="initWithKeysAndObjects(protected)">initWithKeysAndObjects</a></H3>

<TT>protected void <B>initWithKeysAndObjects</B>(java.lang.Object[] <I>keys</I>, java.lang.Object[] <I>objects</I>)</TT>

<P>

Initializes the receiver with entries constructed from the contents of the <I>keys</I> and <I>objects</I> arrays. This method steps through the <I>keys</I> and <I>objects</I> arrays, creating entries in the new ImmutableHashtable as it goes. <!-- Each value object receives a retain message before being added to the dictionary. In contrast, each key object is copied (using copyWithZone:), and the copy is added to the dictionary. --> An <!-- NSInvalidArgumentException --> exception is raised if the objects and keys arrays do not have the same number of elements.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:isEmpty(public) meth:isEmpty descr:<TT>public boolean <B>isEmpty</B>()</TT> -->

<H3><a name="isEmpty(public)">isEmpty</a></H3>

<TT>public boolean <B>isEmpty</B>()</TT>

<P>

Returns <B>true</B> if the receiver has no entries.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:keys(public) meth:keys descr:<TT>public java.util.Enumeration <B>keys</B>()</TT> -->

<H3><a name="keys(public)">keys</a></H3>

<TT>public java.util.Enumeration <B>keys</B>()</TT>

<P>

Returns an enumerator object that lets you access each key in the ImmutableHashtable. <!-- :
NSEnumerator *enumerator = [myDictionary keyEnumerator];
id key;

while ((key = [enumerator nextObject])) {
    /* code that uses the returned key */ 
}
-->
When this method is used with mutable subclasses of ImmutableHashtable, your code shouldn't modify the entries during enumeration. If you intend to modify the entries, use the <B>elements</B> method to create a "snapshot" of the Hashtable's keys. Then use this snapshot to traverse the entries, modifying them along the way.
<P>
Note that the <B>elements</B> method provides a convenient way to access each value in the ImmutableHashtable.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:size(public) meth:size descr:<TT>public int <B>size</B>()</TT> -->

<H3><a name="size(public)">size</a></H3>

<TT>public int <B>size</B>()</TT>

<P>

Returns the number of entries in the ImmutableHashtable.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html>