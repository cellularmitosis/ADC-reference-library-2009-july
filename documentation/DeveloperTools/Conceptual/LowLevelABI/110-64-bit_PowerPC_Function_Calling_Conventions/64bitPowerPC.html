<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Mac OS X ABI Function Call Guide: 64-bit PowerPC Function Calling Conventions</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="64-bit PowerPC Function Calling Conventions"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002471" title="64-bit PowerPC Function Calling Conventions"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../CompilersDebuggers-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30001025" target="_top">Compiling &amp; Debugging</a> &gt; <a href="../index.html" target="_top">Mac OS X ABI Function Call Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../100-32-bit_PowerPC_Function_Calling_Conventions/32bitPowerPC.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../130-IA-32_Function_Calling_Conventions/IA32.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40002471-SW14" title="64-bit PowerPC Function Calling Conventions"></a><hr /><H1>64-bit PowerPC Function Calling Conventions</H1><p>When functions (routines) call other functions (subroutines), they may need to pass arguments to them. These subroutines access those arguments as <strong>parameters</strong>. Conversely, some functions pass a <strong>result</strong> or return value to their callers. Both arguments and results can be passed using the 64-bit PowerPC architecture registers or the runtime stack, depending on the data type of the values involved. For the successful and efficient passing of values between routines and subroutines, GCC follows strict rules when it generates a program’s object code.</p><p>This article describes the data types that can be used to manipulate the arguments and results of function calls, how routines pass arguments to the subroutines they call, and how functions pass results to their callers. It also lists the registers available in the 64-bit PowerPC architecture and whether their value is preserved after a function call.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="64bitPowerPC.html#//apple_ref/doc/uid/TP40002471-SW24">Data Types and Data Alignment</a>
				
			<br/>
			
        
			
			
				<a href="64bitPowerPC.html#//apple_ref/doc/uid/TP40002471-SW10">Function Calls</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002471-SW24" title="Data Types and Data Alignment"></a><h2>Data Types and Data Alignment</h2><p>Using the correct data types for your variables and setting the appropriate <strong>data alignment</strong> for your data can maximize the performance and portability of your programs. Data alignment<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_109"></a> specifies how data is laid out in memory.</p><p><span class="content_text">Table 1</span> lists the ANSI C scalar<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_110"></a> data types and their sizes and natural<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_111"></a> alignment in this environment.</p><a name="//apple_ref/doc/uid/TP40002471-SW9" title="Table 1Size and natural alignment of the scalar data types"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1&nbsp;&nbsp;</strong>Size and natural alignment of the scalar data types</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Data type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Size and natural alignment (in bytes)</p></th></tr><tr><td  scope="row"><p><code>_Bool</code>, <code>bool</code></p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>unsigned char</code></p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>char</code>, <code>signed char</code></p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>unsigned short</code></p></td><td ><p>2</p></td></tr><tr><td  scope="row"><p><code>signed short</code></p></td><td ><p>2</p></td></tr><tr><td  scope="row"><p><code>unsigned int</code></p></td><td ><p>4</p></td></tr><tr><td  scope="row"><p><code>signed int</code></p></td><td ><p>4</p></td></tr><tr><td  scope="row"><p><code>unsigned long</code></p></td><td ><p>8</p></td></tr><tr><td  scope="row"><p><code>signed long</code></p></td><td ><p>8</p></td></tr><tr><td  scope="row"><p><code>unsigned long long</code></p></td><td ><p>8</p></td></tr><tr><td  scope="row"><p><code>signed long long</code></p></td><td ><p>8</p></td></tr><tr><td  scope="row"><p><code>float</code></p></td><td ><p>4</p></td></tr><tr><td  scope="row"><p><code>double</code></p></td><td ><p>8</p></td></tr><tr><td  scope="row"><p><code>long double</code></p></td><td ><p>16</p></td></tr><tr><td  scope="row"><p>pointer</p></td><td ><p>8</p></td></tr></table></div><p>These are some important details about the 64-bit PowerPC environment:</p><ul class="ul"><li class="li"><p>A byte<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_112"></a> is 8 bits long.</p></li><li class="li"><p>A null pointer<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_113"></a> has a value of 0.</p></li><li class="li"><p>This environment uses the big-endian byte ordering<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_114"></a> scheme to store numeric and pointer data types. That is, the most significant bytes go first, followed by the least significant bytes.</p></li><li class="li"><p>This environment uses the two’s-complement binary representation<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_115"></a> for signed integer data types.</p></li><li class="li"><p>The <code>float</code> and <code>double</code> data types conform to the IEEE-754 standard representation<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_116"></a>. For the value range and precise format of floating-point data types, see <em>PowerPC Numerics</em> in Performance Documentation.</p></li></ul><p>This environment supports multiple data alignment modes. Alignment of data types falls into two categories:</p><ul class="ul"><li class="li"><p><strong>Natural alignment.</strong><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_117"></a> The alignment of a data type when allocated in memory or assigned a memory address.</p><p>The natural alignment of a data type is its size. <span class="content_text"><a href="64bitPowerPC.html#//apple_ref/doc/uid/TP40002471-SW9">Table 1</a></span> shows the natural alignment of each data type supported by this environment.</p></li><li class="li"><p><strong>Embedding alignment.</strong><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_118"></a> The alignment of a data type within a composite data structure.</p></li></ul><p>For example, the alignment of an <code>unsigned short</code> variable on the stack may differ from that of an <code>unsigned short</code> data item embedded in a data structure.</p><p>The embedding alignment for data structures varies depending on the alignment mode selected. Generally, you can set the alignment mode using compiler options or <code>#pragma</code> statements. You should consider the compatibility and performance issues described later in this section when choosing a particular alignment mode.</p><p>These are the embedding alignment modes available in the 64-bit PowerPC environment:</p><ul class="ul"><li class="li"><p><strong>Power alignment mode</strong><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_119"></a> is derived from the alignment rules used by the IBM XLC compiler for the AIX operating system. It is the default alignment mode for the PowerPC-architecture version of GCC used on AIX and Mac OS X. Because this mode is most likely to be compatible between PowerPC-architecture compilers from different vendors, it’s typically used with data structures that are shared<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_120"></a> between different programs.</p><p>The rules for power alignment are:</p><ul class="nested"><li class="nested li"><p>The embedding alignment of the first element in a data structure is equal to the element’s natural alignment.</p></li><li class="nested li"><p>For subsequent elements with a natural alignment less than 4 bytes, the embedding alignment of each element is equal to its natural alignment.</p></li><li class="nested li"><p>For subsequent elements that have a natural alignment greater than 4 bytes, the embedding alignment is 4, unless the element is a <code>vector</code>.</p></li><li class="nested li"><p>The embedding alignment for <code>vector</code> elements is always 16 bytes.</p></li><li class="nested li"><p>The embedding alignment of a composite data type (array or data structure) is determined by the largest embedding alignment of its members.</p></li><li class="nested li"><p>The total size of a composite type is rounded up to a multiple of its embedding alignment, and is padded with null bytes.</p></li></ul><p>Because the natural alignment of  <code>double</code> and <code>long long</code> data types is greater than 4 bytes, they may not be appropriately aligned in power-alignment mode. Any misalignment impairs performance when such data members are accessed. When you use these data types for any element after the first element, the compiler pads the structure to align the elements to their natural alignment.</p></li><li class="li"><p><strong>Natural alignment mode</strong><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_121"></a> uses the natural alignment of each data type as its embedding alignment. Use this alignment mode to obtain the highest performance<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_122"></a> when using <code>double</code>, <code>long</code>, <code>long long</code>, and <code>long double</code> data types.</p></li><li class="li"><p><strong>Packed alignment mode</strong><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_123"></a> contains no alignment padding between elements (the alignment for all data types is 1 byte). Use this alignment mode when you need a data structure to use as little<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_124"></a> memory as possible. Note, however, that packed alignment can significantly lower the performance of your application.</p></li></ul><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_125"></a><div class="notebox"><a name="//apple_ref/doc/uid/TP40002471-SW25" title="Note"></a><p><strong>Note:</strong>&nbsp;Data items passed as parameters in a subroutine call have special alignment rules. See <span class="content_text"><a href="64bitPowerPC.html#//apple_ref/doc/uid/TP40002471-SW12">“Stack Structure”</a></span> for more information.</p></div><p><span class="content_text">Table 2</span> lists the alignment for structure fields of the fundamental data types and composite data types in the supported alignment modes.</p><a name="//apple_ref/doc/uid/TP40002471-SW1" title="Table 2Alignment for structure fields"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2&nbsp;&nbsp;</strong>Alignment for structure fields</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Data type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Natural alignment</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Power alignment</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Packed alignment</p></th></tr><tr><td  scope="row"><p><code>_Bool</code>, <code>bool</code></p></td><td ><p>1</p></td><td ><p>1</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>char</code></p></td><td ><p>1</p></td><td ><p>1</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>short</code></p></td><td ><p>2</p></td><td ><p>2</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>int</code></p></td><td ><p>4</p></td><td ><p>4</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>long</code></p></td><td ><p>8</p></td><td ><p>4</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>long long</code></p></td><td ><p>8</p></td><td ><p>4</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>float</code></p></td><td ><p>4</p></td><td ><p>4</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>double</code></p></td><td ><p>8</p></td><td ><p>4 or 8</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>long double</code></p></td><td ><p>8</p></td><td ><p>8</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>vector</code></p></td><td ><p>16</p></td><td ><p>16</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p>Composite (data structure or array)</p></td><td ><p>1, 2, 4, 8, or 16</p></td><td ><p>4, 8, or 16</p></td><td ><p>1</p></td></tr></table></div><p>With GCC you can control data-structure alignment by adding <code>#pragma</code><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_126"></a> statements to your source code or by using command-line options. The power alignment mode is used if you do not specify otherwise.</p><p>To set the alignment mode, use the <code>gcc</code> flags <code>-malign-power</code> and <code>-malign-natural</code>. To use a specific alignment mode in a data structure, add this statement just before the data-structure declaration:</p><div class="codesample"><table><tr><td scope="row"><pre>#pragma option align=&lt;mode><span></span></pre></td></tr></table></div><p>Replace <code>&lt;mode></code> with <code>power</code>, <code>natural</code>, or <code>packed</code>. To restore the previous alignment mode, use <code>reset</code> as the alignment mode in a <code>#pragma</code> statement:</p><div class="codesample"><table><tr><td scope="row"><pre>#pragma option align=reset<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002471-SW10" title="Function Calls"></a><h2>Function Calls</h2><p>This section details the process of calling a subroutine and passing arguments to it, and how functions return values to their callers.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002471-SW26" title="Note"></a><p><strong>Note:</strong>&nbsp;These parameter-passing conventions are part of the Apple standard for procedural programming interfaces. Object-oriented languages may use different rules for their own method calls. For example, the conventions for C++ virtual function calls may be different from those for C functions.</p></div><a name="//apple_ref/doc/uid/TP40002471-SW12" title="Stack Structure"></a><h3>Stack Structure</h3><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_127"></a><p>This environment uses a stack that grows downward and contains linkage information, local variables, and a subroutine’s parameter information, as shown in <span class="content_text">Figure 1</span>. (To help prevent the execution of malicious code on the stack, GCC protects the stack against execution.)</p><br/><div><a name="//apple_ref/doc/uid/TP40002471-SW18" title="Figure 1Stack layout"></a><p><strong>Figure 1&nbsp;&nbsp;</strong>Stack layout</p><img src = "../art/calling_stack.jpg" alt = "" ></div><br/><p>The <strong>stack pointer</strong> (SP)<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_128"></a> points to the bottom of the stack. The stack has a fixed frame size, which is known at compile time.</p><p>The calling routine’s stack frame includes a <strong>parameter area</strong><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_129"></a> and some linkage information. The parameter area has the arguments the caller passes to the called subroutine or space for them, depending on the type of each parameter and the availability of registers (see <span class="content_text"><a href="64bitPowerPC.html#//apple_ref/doc/uid/TP40002471-SW6">“Passing Arguments”</a></span> for details). Since the calling routine may call several subroutines, the parameter area must be large enough to accommodate the largest argument list of all the subroutines the caller calls. It is the calling routine’s responsibility to set up the parameter area before each function call. The called function is responsible for accessing the arguments placed in the parameter area.</p><p>Bytes 48 through 112 of the parameter area correspond to the general-purpose registers<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_130"></a> GPR3 through GPR10. When data is placed in a general-purpose register and not duplicated in the parameter area, the corresponding section in the parameter area is reserved in case the called subroutine needs to copy the value in the register to the stack. <span class="content_text">Table 3</span> shows the correspondence of parameter-area locations to the general-purpose registers that can be used to pass parameters.</p><a name="//apple_ref/doc/uid/TP40002471-SW19" title="Table 3Parameter area to general-purpose register mapping"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3&nbsp;&nbsp;</strong>Parameter area to general-purpose register mapping</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Stack frame location</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Register</p></th></tr><tr><td  scope="row"><p><code>SP+48</code></p></td><td ><p>GPR3</p></td></tr><tr><td  scope="row"><p><code>SP+56</code></p></td><td ><p>GPR4</p></td></tr><tr><td  scope="row"><p><code>SP+64</code></p></td><td ><p>GPR5</p></td></tr><tr><td  scope="row"><p><code>SP+72</code></p></td><td ><p>GPR6</p></td></tr><tr><td  scope="row"><p><code>SP+80</code></p></td><td ><p>GPR7</p></td></tr><tr><td  scope="row"><p><code>SP+88</code></p></td><td ><p>GPR8</p></td></tr><tr><td  scope="row"><p><code>SP+96</code></p></td><td ><p>GPR9</p></td></tr><tr><td  scope="row"><p><code>SP+104</code></p></td><td ><p>GPR10</p></td></tr></table></div><p>When space is allocated for a parameter in the parameter area, the space allocated may be larger than the parameter’s type. In this case, the parameter is “promoted” to a larger data type. Each parameter’s address is the address of the previous parameter plus the size of the previous parameter’s promoted type.</p><p>These are the promotion<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_131"></a> and alignment<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_132"></a> rules followed when parameters are placed in the parameter area<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_133"></a> or in general-purpose registers<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_134"></a>:</p><ol class="ol"><li class="li"><p>Integers<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_135"></a> are promoted to <code>long</code>. For example, <code>short</code> elements are sign-extended to 64-bits, and <code>unsigned int</code> elements are zero-padded on the left to 64-bits.</p></li><li class="li"><p>Floating-point<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_136"></a> elements are promoted to <code>double</code>.</p></li><li class="li"><p>Composite arguments (arrays and structures) are processed this way:</p><ol class="ol"><li class="ol ol"><p>The aligned size is computed by adding necessary padding to make it a multiple of the alignment.</p></li><li class="ol ol"><p>If the aligned size is 1, 2 or 4, the argument is preceded by padding to 4 bytes.</p></li><li class="ol ol"><p>Otherwise, the argument is followed by padding to make its size a multiple of 4 bytes, with the padding bytes being undefined. (GCC pads with <code>0</code>.</p></li></ol></li><li class="li"><p>Parameters with a 16-byte natural alignment (for example, vectors or structures containing a vector), are 16-byte aligned.</p></li></ol><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_137"></a><p>For example, assume the function <code>foo</code><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_138"></a> is declared like this:</p><div class="codesample"><table><tr><td scope="row"><pre>int foo(int i, float f, long l, vector int v,<span></span></pre></td></tr><tr><td scope="row"><pre>        double d, void* p, char c, short s);<span></span></pre></td></tr></table></div><p>The layout of the parameter area would be as shown in <span class="content_text">Table 4</span>.</p><a name="//apple_ref/doc/uid/TP40002471-SW7" title="Table 4Parameter area layout for the foo call"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 4&nbsp;&nbsp;</strong>Parameter area layout for the <code>foo</code> call</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Parameter</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Declared type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Promoted type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Location</p></th></tr><tr><td  scope="row"><p><code>i</code></p></td><td ><p><code>int</code></p></td><td ><p><code>long</code></p></td><td ><p><code>SP+48</code>: Start of the parameter area.</p></td></tr><tr><td  scope="row"><p><code>f</code></p></td><td ><p><code>float</code></p></td><td ><p><code>double</code></p></td><td ><p><code>SP+56</code>: <code>56 = 48 + sizeof(long)</code></p></td></tr><tr><td  scope="row"><p><code>l</code></p></td><td ><p><code>long</code></p></td><td ><p><code>long</code></p></td><td ><p><code>SP+64</code>: <code>64 = 56 + sizeof(double)</code></p></td></tr><tr><td  scope="row"><p><code>v</code></p></td><td ><p><code>vector</code></p></td><td ><p><code>vector</code></p></td><td ><p><code>SP+80</code>: <code>80 = align16(64 + sizeof(long))</code></p></td></tr><tr><td  scope="row"><p><code>d</code></p></td><td ><p><code>double</code></p></td><td ><p><code>double</code></p></td><td ><p><code>SP+96</code>: <code>96 = 80 + sizeof(vector)</code></p></td></tr><tr><td  scope="row"><p><code>p</code></p></td><td ><p><code>void*</code></p></td><td ><p><code>void*</code></p></td><td ><p><code>SP+104</code>: <code>104 = 96 + sizeof(double)</code></p></td></tr><tr><td  scope="row"><p><code>c</code></p></td><td ><p><code>char</code></p></td><td ><p><code>long</code></p></td><td ><p><code>SP+112</code>: <code>112 = 104 + sizeof(void*)</code></p></td></tr><tr><td  scope="row"><p><code>s</code></p></td><td ><p><code>short</code></p></td><td ><p><code>long</code></p></td><td ><p><code>SP+120</code>: <code>120 = 112 + sizeof(long)</code></p></td></tr></table></div><p>The calling routine’s <strong>linkage area</strong><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_139"></a> holds a number of values, some of which are saved by the calling routine and some by the called subroutine. The elements within the linkage area are:</p><ul class="spaceabove"><li class="li"><p><strong>The link register (LR).</strong><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_140"></a> It’s value is saved at <code>16(SP)</code> by the called function if it chooses to do so. The link register holds the return address of the instruction that follows a branch and link instruction.</p></li><li class="li"><p><strong>The condition register (CR).<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_141"></a></strong> It’s value may be saved at <code>8(SP)</code> by the called function. The condition register holds the results of comparison operations. As with the link register, the called subroutine is not required to save this value. Because the condition register is a 32-bit register, bytes 12 through 15 of the stack frame are unused but reserved.</p></li><li class="li"><p><strong>The stack pointer (SP).</strong><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_142"></a> It’s value may be saved at <code>0(SP)</code> by the called function as part of its stack frame. <strong>Leaf subroutines</strong> are not required to save the the stack pointer. A leaf function is a routine that does not call any other function.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002471-SW27" title="Note"></a><p><strong>Note:</strong>&nbsp;The space in the linkage area from <code>24(SP)</code> to <code>47(SP)</code> is reserved.</p></div><p>The linkage area is at the top of the stack frame, adjacent to the stack pointer. This positioning is necessary so the calling routine can find and restore the values stored there and also allow the called subroutine to find the caller’s parameter area. This placement means that a routine cannot push and pop parameters from the stack once the stack frame is set up.</p><p>The stack frame also includes space for the called function’s local variables. However, some registers are available for use by the called function; see <span class="content_text"><a href="64bitPowerPC.html#//apple_ref/doc/uid/TP40002471-SW11">“Register Preservation”</a></span> for details. If the subroutine contains more local variables than would fit in the registers, it uses additional space on the stack. The size of the local-variable area is determined at compile time. Once a stack frame is allocated, the size of the local-variable area cannot change.</p><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_143"></a><a name="//apple_ref/doc/uid/TP40002471-SW28" title="Prologs and Epilogs"></a><h3>Prologs and Epilogs</h3><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_144"></a><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_145"></a><p>The called function is responsible for allocating<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_146"></a> its own stack frame, making sure to preserve 16-byte alignment in the stack. This operation is accomplished by a section of code called the <strong>prolog</strong>, which the compiler places before the body of the subroutine. After the body of the subroutine, the compiler places an <strong>epilog</strong> to restore the processor to the state it was prior to the subroutine call.</p><p>The compiler-generated prolog code does the following:</p><ol class="ol"><li class="li"><p>Decrements the stack pointer<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_147"></a> to account for the new<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_148"></a> stack frame and writes the previous value of the stack pointer into its own linkage area, which ensures the stack can be restored to its original state after returning from the call.</p><p>It is important that the decrement and update tasks happen atomically (for example, with <code>stwu</code>, <code>stwux</code>, <code>stdu</code>, or <code>stdux</code>) so that the stack pointer and back-link are in a consistent state. Otherwise, asynchronous signals or interrupts could corrupt the stack.</p></li><li class="li"><p>Saves all nonvolatile general-purpose<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_149"></a> and floating-point<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_150"></a> registers into the saved-registers area. Note that if the called function does not change a particular nonvolatile register, it does not save it.</p></li><li class="li"><p>Saves the link-register<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_151"></a> and condition-register<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_152"></a> values in the caller’s linkage area, if needed.</p></li></ol><p><span class="content_text">Listing 1</span> shows an example of a routine prolog. Notice that the order of these actions differs from the order previously described.</p><a name="//apple_ref/doc/uid/TP40002471-SW20" title="Listing 1Example prolog"></a><p class="codesample"><strong>Listing 1&nbsp;&nbsp;</strong>Example prolog</p><div class="codesample"><table><tr><td scope="row"><pre>linkageArea = 48                                           ; size in 64-bit PowerPC ABI<span></span></pre></td></tr><tr><td scope="row"><pre>params = 64                                                ; callee parameter area<span></span></pre></td></tr><tr><td scope="row"><pre>localVars = 0                                              ; callee local variables<span></span></pre></td></tr><tr><td scope="row"><pre>numGPRs = 0                                                ; volatile GPRs used by callee<span></span></pre></td></tr><tr><td scope="row"><pre>numFPRs = 0                                                ; volatile FPRs used by callee<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>spaceToSave = linkageArea + params + localVars + 8*numGPRs + 8*numFPRs<span></span></pre></td></tr><tr><td scope="row"><pre>spaceToSaveAligned = ((spaceToSave+15) &amp; (-16))            ; 16-byte-aligned stack<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>_functionName:                                             ; PROLOG<span></span></pre></td></tr><tr><td scope="row"><pre>    mflr        r0                                         ; extract return address<span></span></pre></td></tr><tr><td scope="row"><pre>    std         r0, 16(SP)                                 ; save the return address<span></span></pre></td></tr><tr><td scope="row"><pre>    stdu        SP, -spaceToSaveAligned(SP)                ; skip over caller save area<span></span></pre></td></tr></table></div>	<p>At the end of the function, the compiler-generated epilog does the following:</p><ol class="ol"><li class="li"><p>Restores the nonvolatile general-purpose<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_153"></a> and floating-point<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_154"></a> registers that were saved in the stack frame.</p><p>Nonvolatile registers are saved in the new stack frame before the stack pointer is updated only when they fit within the space beneath the stack pointer, where a new stack frame would normally be allocated, also known as the <strong>red zone</strong>. The red zone is by definition large enough to hold all nonvolatile general-purpose and floating-point registers  but not the nonvolatile vector registers. See <span class="content_text"><a href="64bitPowerPC.html#//apple_ref/doc/uid/TP40002471-SW17">“The Red Zone”</a></span> for details.</p></li><li class="li"><p>Restores the condition-register<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_155"></a> and link-register<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_156"></a> values that were stored in the linkage area.</p></li><li class="li"><p>Restores the stack pointer<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_157"></a> to its previous value.</p></li><li class="li"><p>Returns control to the calling routine using the address stored in the link register<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_158"></a>.</p></li></ol><p><span class="content_text">Listing 2</span> shows an example epilog.</p><a name="//apple_ref/doc/uid/TP40002471-SW21" title="Listing 2Example epilog"></a><p class="codesample"><strong>Listing 2&nbsp;&nbsp;</strong>Example epilog</p><div class="codesample"><table><tr><td scope="row"><pre>                                                    ; EPILOG<span></span></pre></td></tr><tr><td scope="row"><pre>ld             r0, spaceToSaveAligned + 16(SP)      ; get the return address<span></span></pre></td></tr><tr><td scope="row"><pre>mtlr           r0                                   ;    into the link register<span></span></pre></td></tr><tr><td scope="row"><pre>addi           SP, SP, spaceToSaveAligned           ; restore stack pointer<span></span></pre></td></tr><tr><td scope="row"><pre>blr                                                 ; and branch to the return address<span></span></pre></td></tr></table></div>	<p>The VRSAVE<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_159"></a> register is used to specify which vector registers must be saved during a thread or process context switch.<span class="content_text">Listing 3</span> shows an example prolog that sets up VRSAVE so that vector registers V0 through V2 are saved. <span class="content_text">Listing 3</span> also includes the epilog that restores VRSAVE to its previous state.</p><a name="//apple_ref/doc/uid/TP40002471-SW22" title="Listing 3Example usage of the VRSAVE register"></a><p class="codesample"><strong>Listing 3&nbsp;&nbsp;</strong>Example usage of the VRSAVE register</p><div class="codesample"><table><tr><td scope="row"><pre>#define VRSAVE 256                           //  VRSAVE IS SPR# 256<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    _functionName:<span></span></pre></td></tr><tr><td scope="row"><pre>        mfspr    r2, VRSAVE                  ; get vector of live VRs<span></span></pre></td></tr><tr><td scope="row"><pre>        oris         r0, r2, 0xE000          ; set bits 0-2 since we use V0..V2<span></span></pre></td></tr><tr><td scope="row"><pre>        mtspr    VRSAVE, r0                  ; update live VR vector before using any VRs<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        ; Now, V0..V2 can be safely used.<span></span></pre></td></tr><tr><td scope="row"><pre>        ; Function body goes here.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        mtspr    VRSAVE, r2                  ; restore VRSAVE<span></span></pre></td></tr><tr><td scope="row"><pre>        blr                                  ; return to caller<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_160"></a><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_161"></a><a name="//apple_ref/doc/uid/TP40002471-SW17" title="The Red Zone"></a><h3>The Red Zone</h3><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_162"></a><p>The space beneath the stack pointer, where a new stack frame would normally be allocated by a subroutine, is called the <strong>red zone</strong>. The red zone, shown in <span class="content_text">Figure 2</span>, is considered part of the topmost (current) stack frame. This area is not modified by asynchronous<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_163"></a> pushes, such as signals<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_164"></a> or interrupt<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_165"></a> handlers. Therefore, the red zone may be used for any purpose as long as a new<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_166"></a> stack frame does not need to be added to the stack. However, the contents of the red zone are assumed to be destroyed by any synchronous<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_167"></a> call.</p><br/><div><a name="//apple_ref/doc/uid/TP40002471-SW23" title="Figure 2The red zone"></a><p><strong>Figure 2&nbsp;&nbsp;</strong>The red zone</p><img src = "../art/calling_redzone.jpg" alt = "" ></div><br/><p>For example, because a leaf function does not call any other functions—and, therefore, does not allocate a parameter area on the stack—it can use the red zone. Furthermore, such a function does not need to use the stack to store local variables; it needs to save only the nonvolatile registers that it uses for local variables. Since by definition no more than one leaf function is active at any time within a thread, there is no possibility of multiple leaf functions competing for the same red zone space.</p><p>A leaf function<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_168"></a> may or may not allocate a stack frame and decrement the stack pointer. When it doesn’t allocate a stack frame, a leaf function stores the link register and condition register values in the linkage area of the routine that calls it (if necessary) and stores the values of any nonvolatile registers it uses in the red zone. This streamlining means that a leaf function’s prolog and epilog do minimal work; they do not have to set up and take down a stack frame.</p><p>The size of the red zone is 288 bytes, which is enough space to store the values of nineteen 64-bit general-purpose registers and eighteen 64-bit floating-point registers, rounded up to the nearest 16-byte boundary. If a leaf function’s red zone usage would exceed the red zone size, it must set up a stack frame, just as functions that call other functions do.</p><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_169"></a><a name="//apple_ref/doc/uid/TP40002471-SW6" title="Passing Arguments"></a><h3>Passing Arguments</h3><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_170"></a><p>In the C language, functions can declare their parameters using one of three conventions:</p><ul class="spaceabove"><li class="li"><p>The types of all parameters is specified in the function’s prototype. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>int foo(int, short);<span></span></pre></td></tr></table></div><p>In this case, the type of all the function’s parameters is known at compile time.</p></li><li class="li"><p>The function’s prototype declares some fixed parameters and some nonfixed parameters. The group of nonfixed parameters is also called a <strong>variable argument list</strong><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_171"></a>. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>int foo(int, ...);<span></span></pre></td></tr></table></div><p>In this case, the type of one of the function’s parameters in known at compile time. The type of the nonfixed parameters is not known.</p></li><li class="li"><p>The function has no prototype or uses a pre–ANSI C declaration. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>int foo();<span></span></pre></td></tr></table></div><p>In this case, the type of all the function’s parameters is unknown at compile time.</p></li></ul><p>When the compiler generates the prolog for a function call, it uses the information from the function’s declaration to decide how to pass arguments to the function. When the compiler knows the type of a parameter, it passes it in the most efficient way possible. But when the type is unknown, it passes the parameter using the safest approach, which may involve placing data both in registers and in the parameter area. For called functions to access their parameters correctly, it’s important that they know when parameters are passed in the stack or in registers.</p><p>Arguments are passed in the stack or in registers depending on their types and the availability of registers. There are three types of registers: general purpose, floating point, and vector. General-purpose<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_172"></a> registers (GPRs) are 64-bit registers that can manipulate integral values and pointers. Floating-point<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_173"></a> registers (FPRs) are 64-bit registers that can manipulate single-precision and double-precision floating-point values. Vector<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_174"></a> registers are 128-bit registers that can manipulate 4 through 16 chunks of data in parallel.</p><p>The registers that can be used to pass arguments to called functions are the general-purpose registers GPR3 through GPR10, the floating-point registers FPR1 through FPR13, and the vector registers V2 through V13 (see <span class="content_text"><a href="64bitPowerPC.html#//apple_ref/doc/uid/TP40002471-SW11">“Register Preservation”</a></span> for details). These registers are also known as <strong>parameter registers</strong>.</p><p>The compiler uses the following rules when passing arguments to subroutines:</p><ul class="spaceabove"><li class="li"><p>Parameters whose promoted type is known at compile time are processed using these rules (see <span class="content_text"><a href="64bitPowerPC.html#//apple_ref/doc/uid/TP40002471-SW12">“Stack Structure”</a></span> for details on a parameter’s promoted type):</p><ol class="ol"><li class="li"><p>The caller places floating-point<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_175"></a> elements (except <code>long double</code> elements) in floating-point registers FPR1 through FPR13. As each floating-point register is used, the caller skips the next available general-purpose register. When floating-point registers are exhausted, the caller places these elements in the parameter area.</p></li><li class="li"><p>The caller places <code>long double</code><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_176"></a> elements—which use a pair of <code>float</code> elements—in two floating-point registers. As each pair of floating-point registers is used, the caller skips the next two available general-purpose registers. When floating-point registers are exhausted, the caller places these elements in the parameter area<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_177"></a>.</p></li><li class="li"><p>The caller places <code>vector</code><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_178"></a> elements in vector registers V2 through V13. Vector-register usage doesn’t affect the availability of general-purpose registers. That is, no general-purpose registers are skipped as a result of using a vector register. When vector registers are exhausted, the caller places these elements in the parameter area<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_179"></a>.</p></li><li class="li"><p>The caller places elements of all other data types<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_180"></a>—including <code>complex</code> (defined in <code>complex.h</code>)—in general-purpose registers GPR3 through GPR10, when available. When general-purpose registers are exhausted, the caller places these elements in the parameter area<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_181"></a>.</p><p>Structures that are 16 bytes in size are handled as if they were a pair of 64-bit integers. Therefore, they are placed in two general-purpose registers. Examples of structures that meet this criterion include a structure containing four <code>float</code> fields and a structure containing two <code>double</code> fields. Structures that contain three <code>float</code> fields, for example, are be processed using rule 5.</p></li><li class="li"><p>The caller recursively processes the members of structures<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_182"></a> passed by value and containing no unions:</p><ul class="ul"><li class="li"><p>Floating-point<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_183"></a> fields are processed using rule 1 or rule 2, depending on their type.</p></li><li class="li"><p>Vector<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_184"></a> fields are processed using rule 3.</p></li><li class="li"><p>Fields of all other types—including arrays—are processed using rule 4.</p></li></ul></li></ol></li><li class="li"><p>Arguments to a pre–ANSI C<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_185"></a>–declared function are processed as follows:</p><ol class="ol"><li class="li"><p>The caller places floating-point<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_186"></a> elements in floating-point registers and general-purpose registers, when available. Otherwise, the caller places them in the parameter area<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_187"></a>.</p></li><li class="li"><p>The caller places <code>vector</code><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_188"></a> elements in vector registers and general-purpose registers, when available. Otherwise, the caller places them in the parameter area<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_189"></a>.</p></li><li class="li"><p>The caller places elements of all other types<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_190"></a><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_191"></a> in general-purpose registers, when available. Otherwise, the caller places them in the parameter area<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_192"></a>.</p></li></ol></li><li class="li"><p>Arguments that are part of a variable argument list are placed in general-purpose registers, when available. Otherwise, the caller places them in the parameter area.</p></li></ul><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_6" title="Important:"></a><p><strong>Important:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_193"></a>When the return value of the called function would not be passed in registers, if it were passed as a parameter in a function call, the caller passes a pointer in GPR3 as an implicit first parameter of the called function. Therefore, the function’s declared parameters start at GPR4. The pointer points to a section of memory large enough to hold the return value. See <span class="content_text"><a href="64bitPowerPC.html#//apple_ref/doc/uid/TP40002471-SW13">“Returning Results”</a></span> for more information.</p><p></p></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40002471-SW29" title="Note"></a><p><strong>Note:</strong>&nbsp;Floating-point and vector elements passed by value are placed in floating-point registers and vector registers, respectively, which may differ from how they are passed in other binary interfaces.</p></div><a name="//apple_ref/doc/uid/TP40002471-SW30" title="Using ANSI C Prototypes"></a><h4>Using ANSI C Prototypes</h4><p>When the types of all the parameters of a subroutine are known at compile time, placing arguments into registers is straightforward.</p><p>For example, assume a routine calls the function <code>foo_ansi</code><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_194"></a> declared like this:</p><div class="codesample"><table><tr><td scope="row"><pre>int foo_ansi(int i, float f, long l, vector int v,<span></span></pre></td></tr><tr><td scope="row"><pre>             double d, void* p, char c, short s);<span></span></pre></td></tr></table></div><p>The caller places the arguments to the function as shown in <span class="content_text">Table 5</span>.</p><a name="//apple_ref/doc/uid/TP40002471-SW2" title="Table 5Passing arguments to a function that declares all the types of its parameters"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 5&nbsp;&nbsp;</strong>Passing arguments to a function that declares all the types of its parameters</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Argument</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Placed in</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Reason</p></th></tr><tr><td  scope="row"><p>i</p></td><td ><p><code>int</code></p></td><td ><p>GPR3</p></td><td ><p>Not a floating-point or vector element.</p></td></tr><tr><td  scope="row"><p>f</p></td><td ><p><code>float</code></p></td><td ><p>FPR1</p></td><td ><p>First floating-point element, so it goes in the first floating-point register. GPR4 is skipped.</p></td></tr><tr><td  scope="row"><p>l</p></td><td ><p><code>long</code></p></td><td ><p>GPR5</p></td><td ><p>Not a floating-point or vector element.</p></td></tr><tr><td  scope="row"><p>v</p></td><td ><p><code>vector int</code></p></td><td ><p>V2</p></td><td ><p>First vector element, so it goes in the first vector register. No general-purpose register is skipped.</p></td></tr><tr><td  scope="row"><p>d</p></td><td ><p><code>double</code></p></td><td ><p>FPR2</p></td><td ><p>Second floating-point element, so it goes in the next floating-point register available. GPR6 is skipped.</p></td></tr><tr><td  scope="row"><p>p</p></td><td ><p><code>void*</code></p></td><td ><p>GPR7</p></td><td ><p>Not a floating-point or vector element.</p></td></tr><tr><td  scope="row"><p>c</p></td><td ><p><code>char</code></p></td><td ><p>GPR8</p></td><td ><p>Not a floating-point or vector element.</p></td></tr><tr><td  scope="row"><p>s</p></td><td ><p><code>short</code></p></td><td ><p>GPR9</p></td><td ><p>Not a floating-point or vector element.</p></td></tr></table></div><p><span class="content_text">Figure 3</span> illustrates the placement of arguments in registers and the parameter area.</p><br/><div><a name="//apple_ref/doc/uid/TP40002471-SW3" title="Figure 3Argument assignment when all parameter types are known "></a><p><strong>Figure 3&nbsp;&nbsp;</strong>Argument assignment when all parameter types are known </p><img src = "../art/calling_parameterlayout64.jpg" alt = "" ></div><br/><a name="//apple_ref/doc/uid/TP40002471-SW31" title="Using Structures"></a><h4>Using Structures</h4><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_195"></a><p>Assume the structure <code>data</code> and the function <code>bar</code><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_196"></a> are declared like this:</p><div class="codesample"><table><tr><td scope="row"><pre>struct data {<span></span></pre></td></tr><tr><td scope="row"><pre>    float f;<span></span></pre></td></tr><tr><td scope="row"><pre>    int i;<span></span></pre></td></tr><tr><td scope="row"><pre>    double d;<span></span></pre></td></tr><tr><td scope="row"><pre>    vector float v;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>int bar(int a, struct data b, void* c);<span></span></pre></td></tr></table></div><p><span class="content_text">Table 6</span> shows the register assignment when a routine calls <code>bar</code>.</p><a name="//apple_ref/doc/uid/TP40002471-SW4" title="Table 6Passing arguments to a function with a struct parameter"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 6&nbsp;&nbsp;</strong>Passing arguments to a function with a <code>struct</code> parameter</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Argument</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Placed in</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Reason</p></th></tr><tr><td  scope="row"><p><code>a</code></p></td><td ><p><code>int</code></p></td><td ><p>GPR3</p></td><td ><p>Not a floating-point or vector element.</p></td></tr><tr><td  scope="row"><p><code>b.f</code></p></td><td ><p><code>float</code></p></td><td ><p>FPR1</p></td><td ><p>First floating-point element, so it goes in the first floating-point register. GPR4 is skipped. Because the <code>b</code> structure contains a <code>vector</code>, the entire <code>struct</code> needs 16-byte alignment in the parameter area.</p></td></tr><tr><td  scope="row"><p><code>b.i</code></p></td><td ><p><code>int</code></p></td><td ><p>GPR5 (low half)</p></td><td ><p>Not a floating-point or vector element.</p></td></tr><tr><td  scope="row"><p><code>b.d</code></p></td><td ><p><code>double</code></p></td><td ><p>FPR2</p></td><td ><p>Second floating-point element, so it goes in the next floating-point register available.</p></td></tr><tr><td  scope="row"><p><code>b.v</code></p></td><td ><p><code>vector float</code></p></td><td ><p>V2</p></td><td ><p>First vector element, so it goes in the first vector register.</p></td></tr><tr><td  scope="row"><p><code>c</code></p></td><td ><p><code>void*</code></p></td><td ><p>GPR9</p></td><td ><p>Not a floating-point or vector element.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002471-SW32" title="Using Variable Argument Lists"></a><h4>Using Variable Argument Lists</h4><p>Assume the structure <code>numbers</code> and the function <code>var</code> are declared like this:</p><div class="codesample"><table><tr><td scope="row"><pre>struct numbers {<span></span></pre></td></tr><tr><td scope="row"><pre>    float f;<span></span></pre></td></tr><tr><td scope="row"><pre>    int i;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>extern void var(int a, float b, vector float c, struct numbers n, ...);<span></span></pre></td></tr></table></div><p>Also assume a routine contains the following code:</p><div class="codesample"><table><tr><td scope="row"><pre>int i1, i2;<span></span></pre></td></tr><tr><td scope="row"><pre>float f1, f2;<span></span></pre></td></tr><tr><td scope="row"><pre>vector float v1, v2;<span></span></pre></td></tr><tr><td scope="row"><pre>struct numbers n1, n2;<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>var(i1, f1, v1, n1, i2, f2, v2, n2);<span></span></pre></td></tr></table></div><p>The caller assigns the arguments to <code>var</code> as shown in <span class="content_text">Table 7</span>.</p><a name="//apple_ref/doc/uid/TP40002471-SW15" title="Table 7Passing arguments to a function with a variable argument list"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 7&nbsp;&nbsp;</strong>Passing arguments to a function with a variable argument list</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Argument</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Placed in</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Reason</p></th></tr><tr><td  scope="row"><p><code>i1</code></p></td><td ><p><code>int</code></p></td><td ><p>GPR3</p></td><td ><p>Not a floating-point or vector element.</p></td></tr><tr><td  scope="row"><p><code>f1</code></p></td><td ><p><code>float</code></p></td><td ><p>FPR1</p></td><td ><p>First floating-point element, so it goes in the first floating-point register.</p></td></tr><tr><td  scope="row"><p><code>v1</code></p></td><td ><p><code>vector float</code></p></td><td ><p>V2</p></td><td ><p>First vector element, so it goes in the first vector register.</p></td></tr><tr><td  scope="row"><p><code>n1.f</code></p></td><td ><p><code>float</code></p></td><td ><p>FPR2</p></td><td ><p>Second floating-point element, so it goes in the next floating-point register available.</p></td></tr><tr><td  scope="row"><p><code>n1.i</code></p></td><td ><p><code>int</code></p></td><td ><p>GPR7 (low half)</p></td><td ><p>Not a floating-point or vector element.</p></td></tr><tr><td  scope="row"><p><code>i2</code></p></td><td ><p><code>int</code> (unknown at compile time)</p></td><td ><p>GPR8</p></td><td ><p>A variable argument list element.</p></td></tr><tr><td  scope="row"><p><code>f2</code></p></td><td ><p><code>float</code> (unknown at compile time)</p></td><td ><p>GPR9</p></td><td ><p>A variable argument list element.</p></td></tr><tr><td  scope="row"><p><code>v2</code></p></td><td ><p><code>vector float</code> (unknown at compile time)</p></td><td ><p><code>SP+112</code> (16 bytes)</p></td><td ><p>A variable argument list element and a vector. Must be 16-byte aligned; cannot use GPR10.</p></td></tr><tr><td  scope="row"><p><code>n2.f</code></p></td><td ><p><code>float</code> (unknown at compile time)</p></td><td ><p><code>SP+128</code> (4 bytes)</p></td><td ><p>A variable argument list element. No general-purpose registers available.</p></td></tr><tr><td  scope="row"><p><code>n2.i</code></p></td><td ><p><code>int</code> (unknown at compile time)</p></td><td ><p><code>SP+132</code> (4 bytes)</p></td><td ><p>A variable argument list element. No general-purpose registers available.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002471-SW33" title="Using pre&acirc;&#128;&#147;ANSI C Prototypes"></a><h4>Using pre–ANSI C Prototypes</h4><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_197"></a><p>Assume the structure <code>numbers</code> and the function <code>foo_pre_ansi</code><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_198"></a> are declared like this:</p><div class="codesample"><table><tr><td scope="row"><pre>struct numbers {<span></span></pre></td></tr><tr><td scope="row"><pre>    float f;<span></span></pre></td></tr><tr><td scope="row"><pre>    int i;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>void foo_pre_ansi();<span></span></pre></td></tr></table></div><p>Also assume a routine contains the following code:</p><div class="codesample"><table><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>int i;<span></span></pre></td></tr><tr><td scope="row"><pre>float f;<span></span></pre></td></tr><tr><td scope="row"><pre>vector float v;<span></span></pre></td></tr><tr><td scope="row"><pre>struct numbers n;<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>foo_pre_ansi(i, f, v, n);<span></span></pre></td></tr></table></div><p>The caller assigns the arguments to <code>foo_pre_ansi</code> as shown in <span class="content_text">Table 8</span>.</p><a name="//apple_ref/doc/uid/TP40002471-SW5" title="Table 8Passing arguments to a function with a pre&acirc;&#128;&#147;ANSI C prototype"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 8&nbsp;&nbsp;</strong>Passing arguments to a function with a pre–ANSI C prototype</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Argument</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Placed in</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Reason</p></th></tr><tr><td  scope="row"><p><code>i</code></p></td><td ><p><code>int</code> (unknown at compile time)</p></td><td ><p>GPR3</p></td><td ><p>Not a floating-point or vector element.</p></td></tr><tr><td  scope="row"><p><code>f</code></p></td><td ><p><code>float</code> (unknown at compile time)</p></td><td ><p>FPR1, GPR4</p></td><td ><p>First floating-point element, so it goes in the first floating-point register and the next available general-purpose register.</p></td></tr><tr><td  scope="row"><p><code>v</code></p></td><td ><p><code>vector float</code> (unknown at compile time)</p></td><td ><p>V2, GPR5–GPR6</p></td><td ><p>First vector element, so it goes in the first vector register and next two general-purpose registers available.</p></td></tr><tr><td  scope="row"><p><code>n.f</code></p></td><td ><p><code>float</code> (unknown at compile time)</p></td><td ><p>FPR2, GPR7 (high half)</p></td><td ><p>Second floating-point element, so it goes in the next floating-point register available and the next general-purpose register available.</p></td></tr><tr><td  scope="row"><p><code>n.i</code></p></td><td ><p><code>int</code> (unknown at compile time)</p></td><td ><p>GPR7 (low half)</p></td><td ><p>Not a floating-point or vector element, so it goes in the next general-purpose register available.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002471-SW13" title="Returning Results"></a><h3>Returning Results</h3><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_199"></a><p>A function result can be returned in registers or in memory, depending on the data type of the function’s return value. When the return value of the called function would be passed in registers, if it were passed as a parameter in a function call, the called function places its return value in the same registers. Otherwise, the function places its result at the location pointed to by GPR3. See <span class="content_text"><a href="64bitPowerPC.html#//apple_ref/doc/uid/TP40002471-SW6">“Passing Arguments”</a></span> for more information.</p><p><span class="content_text">Table 9</span> lists some examples of how return values can be passed to a calling routine.</p><a name="//apple_ref/doc/uid/TP40002471-SW8" title="Table 9Examples of passing results to callers"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 9&nbsp;&nbsp;</strong>Examples of passing results to callers</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Return type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Returned in</p></th></tr><tr><td  scope="row"><p><code>int</code></p></td><td ><p>GPR3 (sign extended).</p></td></tr><tr><td  scope="row"><p><code>unsigned short</code></p></td><td ><p>GPR3 (zero filled).</p></td></tr><tr><td  scope="row"><p><code>long</code></p></td><td ><p>GPR3.</p></td></tr><tr><td  scope="row"><p><code>long long</code></p></td><td ><p>GPR3.</p></td></tr><tr><td  scope="row"><p><code>float</code></p></td><td ><p>FPR1.</p></td></tr><tr><td  scope="row"><p><code>double</code></p></td><td ><p>FPR1.</p></td></tr><tr><td  scope="row"><p><code>long double</code></p></td><td ><p>FPR1–FPR2.</p></td></tr><tr><td  scope="row"><p><code>struct { float, float }</code></p></td><td ><p>FPR1, FPR2.</p></td></tr><tr><td  scope="row"><p><code>struct { double, double }</code></p></td><td ><p>FPR1, FPR2.</p></td></tr><tr><td  scope="row"><p><code>struct { long, long }</code></p></td><td ><p>GPR3, GPR4.</p></td></tr><tr><td  scope="row"><p><code>struct { long[8] }</code></p></td><td ><p>GPR3, GPR4, ... GPR10.</p></td></tr><tr><td  scope="row"><p><code>struct { long[10] }</code></p></td><td ><p>Memory location pointed to by GPR3, which is made up of 80 bytes of storage.</p></td></tr><tr><td  scope="row"><p><code>vector float</code></p></td><td ><p>V2.</p></td></tr><tr><td  scope="row"><p><code>complex float</code></p></td><td ><p>FPR1 (real number), FPR2 (imaginary number).</p></td></tr><tr><td  scope="row"><p><code>complex double</code></p></td><td ><p>FPR1 (real number), FPR2 (imaginary number).</p></td></tr><tr><td  scope="row"><p><code>complex long double</code></p></td><td ><p>FPR1–FPR2 (real number), FPR3–FPR4 (imaginary number).</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_200"></a><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_201"></a><a name="//apple_ref/doc/uid/TP40002471-SW11" title="Register Preservation"></a><h3>Register Preservation</h3><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_202"></a><p><span class="content_text">Table 10</span> lists the 64-bit PowerPC architecture registers used in this environment and their volatility in subroutine calls. Registers that must preserve their value after a function call are called <strong>nonvolatile</strong>.</p><a name="//apple_ref/doc/uid/TP40002471-SW16" title="Table 10Processor registers in the 64-bit PowerPC architecture"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 10&nbsp;&nbsp;</strong>Processor registers in the 64-bit PowerPC architecture</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Name</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Preserved</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Notes</p></th></tr><tr><td  scope="row"><p>General-purpose register</p></td><td ><p>GPR0</p></td><td ><p>No</p></td><td ><p></p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR1</p></td><td ><p>Yes</p></td><td ><p>Used as the stack pointer to store parameters and other temporary data items.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR2</p></td><td ><p>No</p></td><td ><p>Available for general use.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR3</p></td><td ><p>No</p></td><td ><p>The caller passes arguments to the called subroutine in GPR3 through GPR10. The caller may also pass the address to storage where the callee places its return value in this register.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR4–GPR10</p></td><td ><p>No</p></td><td ><p>Used by callers to pass arguments to the called subroutine (see notes for GPR3).</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR11</p></td><td ><p>Yes in nested functions. No in leaf functions.</p></td><td ><p>In nested functions, the caller passes its stack frame to the nested function in this register. In leaf subroutines, the register is available. For details on nested functions, see the GCC documentation. This register is also used by lazy stubs in dynamic code generation to point to the lazy pointer.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR12</p></td><td ><p>No</p></td><td ><p>Set to the address of the branch target before an indirect call for dynamic code generation. This register is not set for a subroutine that has been called directly, so subroutines that may be called directly should not depend on this register being set up correctly. See <em><a href="../../MachOTopics/index.html#//apple_ref/doc/uid/TP40001519" target="_top">Mach-O Programming Topics</a></em> for more information.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR13</p></td><td ><p>Yes</p></td><td ><p>Reserved for thread-specific storage.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR14–GPR31</p></td><td ><p>Yes</p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Floating-point register</p></td><td ><p>FPR0</p></td><td ><p>No</p></td><td ><p></p></td></tr><tr><td  scope="row"><p></p></td><td ><p>FPR1–FPR13</p></td><td ><p>No</p></td><td ><p>Used by callers to pass floating-point arguments to the called subroutine. Floating-point results are passed in FPR1.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>FPR14–FPR31</p></td><td ><p>Yes</p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Vector register</p></td><td ><p>V0–V19</p></td><td ><p>No</p></td><td ><p>Callers use V2 through V13 to pass vector arguments to the called subroutine. Vector results are passed in V2.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>V20–V31</p></td><td ><p>Yes</p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Special-purpose vector register</p></td><td ><p>VRSAVE</p></td><td ><p>Yes</p></td><td ><p>32-bit special-purpose register. Each bit in this register indicates whether the corresponding vector register must be saved during a thread or process context switch.</p></td></tr><tr><td  scope="row"><p>Link register</p></td><td ><p>LR</p></td><td ><p>No</p></td><td ><p>Stores the return address of the calling routine that called the current subroutine.</p></td></tr><tr><td  scope="row"><p>Count register</p></td><td ><p>CTR</p></td><td ><p>No</p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Fixed-point exception register</p></td><td ><p>XER</p></td><td ><p>No</p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Condition register fields</p></td><td ><p>CR0, CR1</p></td><td ><p>No</p></td><td ><p></p></td></tr><tr><td  scope="row"><p></p></td><td ><p>CR2–CR4</p></td><td ><p>Yes</p></td><td ><p></p></td></tr><tr><td  scope="row"><p></p></td><td ><p>CR5–CR7</p></td><td ><p>No</p></td><td ><p></p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002471-DontLinkElementID_203"></a>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../100-32-bit_PowerPC_Function_Calling_Conventions/32bitPowerPC.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../130-IA-32_Function_Calling_Conventions/IA32.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/LowLevelABI/110-64-bit_PowerPC_Function_Calling_Conventions/64bitPowerPC.html%3Fid%3DTP40002521-2.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/LowLevelABI/110-64-bit_PowerPC_Function_Calling_Conventions/64bitPowerPC.html%3Fid%3DTP40002521-2.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/LowLevelABI/110-64-bit_PowerPC_Function_Calling_Conventions/64bitPowerPC.html%3Fid%3DTP40002521-2.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
