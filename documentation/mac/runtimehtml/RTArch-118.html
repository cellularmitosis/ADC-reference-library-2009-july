<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>The Jump Table</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING118></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="RTArch-117.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-119.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="RTArch-2.html"><B>Mac OS Runtime Architectures</B></A> / <BR><DD><A HREF="RTArch-115.html"><B>Chapter 10 - Classic 68K Runtime Architecture</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING118-0></A>
<H1>The Jump Table</H1>
 <A NAME=MARKER-2-28></A>The loading and unloading of segments are controlled by the linker and the Segment Manager through the use of the jump table (<CODE>'CODE'0</CODE>), a data structure created by the linker. The jump table is always located at a fixed offset above A5 as shown previously in <A HREF=RTArch-116.html#MARKER-9-22>Figure 10-1</A>.<P>
 The jump table is used to track the state (loaded or unloaded) and the location of <CODE>'CODE'</CODE> resources. The jump table keeps track of the location of each <CODE>'CODE'</CODE> resource and the offset of each routine inside each segment. <A NAME=MARKER-2-29></A><P>
<UL>
<LI>If one routine needs to call another routine in a different segment <B>(intersegment reference),</B> it must go through the jump table to determine the address where the other routine starts. If the segment containing the externally referenced routine is unloaded, it must be loaded before jumping to the routine address.
<LI>If a routine calls another routine in its own segment <B>(intrasegment reference),</B> it does not need the jump table. Although <CODE>'CODE'</CODE> resources move in the heap, their contents are constant, so the routines always keep a constant distance apart and can be accessed using a self-relative (that is, a <DFN>PC-relative)</DFN> branch. <A NAME=MARKER-2-30></A><A NAME=MARKER-2-31></A><P>
</UL>
 <A HREF=#MARKER-9-32>Figure 10-2</A> shows a call that goes through the jump table and a call that uses self-relative branching. <P>
<B>Figure 10-2  <A NAME=MARKER-9-32></A>Using the jump table and using self-relative branching</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-24.jpg"> <P>
 When procedure A calls procedure B, procedure A must go through the jump table because the procedures are in different segments. But procedure C can call procedure B without going through the jump table because the procedures are in the same segment.<P>
 If you trace through code and see an instruction such as<P>
<PRE>
JSR   60(A5)
</PRE>
 you are looking at a call to a routine in another code segment--that is, a call that must go through the jump table. Remember that A5 is used to reference the application's global variables and the jump table. Negative offsets from A5 reference global variables, while positive offsets that are greater than 32 refer to jump-table entries. <A NAME=MARKER-2-33></A><P>
 <A NAME=MARKER-2-34></A>The jump table is created by the linker when you build your application, and it is stored in the <CODE>'CODE'0</CODE> resource (sometimes called segment 0). The structure of the <CODE>'CODE'0</CODE> resource is shown in <A HREF=#MARKER-9-35>Figure 10-3</A>.<P>
<B>Figure 10-3  <A NAME=MARKER-9-35></A>The <CODE>'CODE'0</CODE> resource </B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-02.jpg"> <P>
 The elements of the <CODE>'CODE'0</CODE> resource are as follows:<P>
<UL>
<LI>Above A5 size. The size (in bytes) from the location pointed to by A5 to the upper end of the application space.
<LI>Below A5 size. The size (in bytes) of the application's global variables plus the QuickDraw global variables. 
<LI>Jump table size. The size of the jump table. The jump table contains one 8-byte entry for each externally referenced routine. 
<LI>Jump table offset. The offset (in bytes) of the jump table from the location pointed to by A5. This offset is stored in the global variable <CODE>CurJTOffset</CODE>.
<LI>Jump table. A contiguous list of jump table entries. <P>
</UL>
<DL>
<DT><B>Note</B>
<DD>For all applications, the offset to the jump table from the location pointed to by A5 is 32. The number of bytes above A5 is 32 plus the length of the jump table.<EM></EM><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 When the application is launched, the Segment Manager uses this information to place the jump table in the A5 world. <P>
 <A NAME=MARKER-2-36></A>The linker creates a jump table entry for every routine that is called by a routine from a different segment. All entries for a particular segment are stored contiguously in the jump table. The structure of the entry varies depending on whether the referenced routine is in a loaded or unloaded segment. If the segment has not been loaded into memory, the jump table entry has the structure shown in <A HREF=#MARKER-9-37>Figure 10-4</A>.<P>
<B>Figure 10-4  <A NAME=MARKER-9-37></A>An unloaded jump table entry</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-03.jpg"> <P>
<DL>
<DT><B>Note</B>
<DD>The jump table structure for unloaded segments is different if you are building with the <CODE>-model far</CODE> option. See <A HREF=RTArch-127.html#MARKER-9-65>"The Far Model Jump Table" (page 10-20)</A> for more details.<EM></EM><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 A call that goes through the jump table has the form <P>
 <CODE>JSR </CODE>offset<CODE> (A5)</CODE><P>
 where offset is the offset of the jump table entry for the routine from A5 plus 2 bytes. This results in the execution of the <CODE>MOVE.W #</CODE>n<CODE>, -SP</CODE> instruction, which places the number of the segment containing the routine on the stack. (The jump table refers to segments by the segment numbers assigned by the linker.)<P>
 The next instruction invokes the <CODE>_LoadSeg</CODE> trap, which loads the specified segment into memory. Then the Segment Manager can transform all the jump table entries for the segment into their loaded states as follows:<P>
<OL>
<LI>The Segment Manager loads the segment, locks it, double-dereferences it, and adds the offset, which is stored in the first word of the unloaded entry. This results in the actual address of the routine.
<LI>The Segment Manager then builds the loaded entry format: it stores the segment number in the entry's first 2 bytes, and it stores a <CODE>JMP</CODE> instruction to the address it has calculated in the entry's last 6 bytes.<P>
</OL>
 <A HREF=#MARKER-9-38>Figure 10-5</A> shows the structure of a loaded jump table entry. <P>
<B>Figure 10-5  <A NAME=MARKER-9-38></A>A loaded jump table entry</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-04.jpg"> <P>
 After transforming the jump table entries, the Segment Manager then calls the actual routine by executing the instruction in the last 6 bytes of the (now loaded) jump table entry. Any subsequent calls to the routine also execute this instruction.<P>
 Note that the last 6 bytes of the jump table entry are executed whether the segment is loaded or not. The effect of the instruction depends on the state of the entry at the time. <P>
 The jump table entries remain in their loaded state unless you call the <CODE>_UnloadSeg</CODE> routine, which restores them to their unloaded state. <A NAME=MARKER-2-39></A><P>
 Note that to set all the jump table entries for a segment to their loaded or unloaded state, the Segment Manager needs to know where in the jump table all the entries are located. It gets this information from the segment header. The segment header, which is 4 bytes long for the near model environment, contains the offset of the first routine's entry from the start of the jump table (2 bytes) and the number of entries for the segment (2 bytes). <A HREF=#MARKER-9-41>Figure 10-6</A> shows the segment header. <A NAME=MARKER-2-40></A><P>
<B>Figure 10-6  <A NAME=MARKER-9-41></A>Near model segment header</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-08.jpg"> <P>
<DL>
<DT><B>Note</B>
<DD>The segment header is different for the far model environment. See <A HREF=RTArch-128.html#MARKER-9-71>"The Far Model Segment Header Structure" (page 10-23)</A>, for more information.<EM></EM><EM> <A NAME=MARKER-2-42></A></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<HR>
<center>
<A HREF="RTArch-117.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-119.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="RTArch-3.html">&copy; Apple Computer, Inc.</A><br>11 MARCH 1997<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
