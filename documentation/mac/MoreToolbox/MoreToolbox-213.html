<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Working With List Selections (IM: MTb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING213></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MoreToolbox-212.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-214.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MoreToolbox-2.html"><B>More Macintosh Toolbox</B></A> / <BR><DD><A HREF="MoreToolbox-202.html"><B>Chapter 4 - List Manager</B></A> / <A HREF="MoreToolbox-209.html"><B>Using the List Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING213-0></A>
<H2><A NAME=MARKER-9-181></A>Working With List Selections</H2>
 The List Manager provides routines that make it easy to determine what the selection <BR>is or to change the selection, whether your list allows just one item to be selected at a time or allows many items to be selected. The List Manager also provides a routine that allows you to automatically scroll the first selected cell to the upper-left corner of the list's visible rectangle. In addition, you can write your own routine to scroll a list just enough so that a particular cell is visible.<A NAME=MARKER-2-182></A><A NAME=MARKER-9-164></A><P>
 Your application can use the <CODE>LGetSelect</CODE> function to determine whether a given cell is selected or to find the next selected cell. Your application can use the <CODE>LSetSelect</CODE> procedure to select or deselect a given cell. <P>
 <A HREF=#MARKER-9-184>Listing 4-7</A> shows an application-defined procedure that finds the first cell in a selection.<P>
<B>Listing 4-7  <A NAME=MARKER-9-184></A>Finding the first selected cell in a list<A NAME=MARKER-2-185></A></B><P>
<PRE>
FUNCTION MyGetFirstSelectedCell (theList: ListHandle;
                                 VAR theCell: Cell): Boolean;
BEGIN
   SetPt(theCell, 0, 0);
   MyGetFirstSelectedCell := LGetSelect(TRUE, theCell, theList);
END;
</PRE>
 The first parameter (<CODE>TRUE</CODE>) passed to the <CODE>LGetSelect</CODE> function indicates that <CODE>LGetSelect</CODE> should search the list (beginning with the cell specified in the second parameter) for the first selected cell. If you pass <CODE>TRUE</CODE> as the first parameter, <CODE>LGetSelect</CODE> sets the cell specified in the second parameter to the coordinates of the first selected cell that it finds, or it returns <CODE>FALSE</CODE> if no cells including or after the cell specified by the second parameter are selected. If you pass <CODE>FALSE</CODE> as the first parameter to <CODE>LGetSelect</CODE>, then the function returns <CODE>TRUE</CODE> only if the cell specified in the second parameter is selected. The <CODE>MyGetFirstSelectedCell</CODE> function defined in <A HREF=#MARKER-9-184>Listing 4-7</A> thus returns <CODE>TRUE</CODE> only if at least one cell is selected, in which case the second parameter to the function is set to the coordinates of that cell.<A NAME=MARKER-2-187></A><P>
 Finding the last selected cell in a list is slightly more complex. <A HREF=#MARKER-9-188>Listing 4-8</A> illustrates how this might be done.<P>
<B>Listing 4-8  <A NAME=MARKER-9-188></A>Finding the last selected cell in a list<A NAME=MARKER-2-189></A></B><P>
<PRE>
PROCEDURE MyGetLastSelectedCell (theList: ListHandle;
                                 VAR theCell: Cell);
VAR
   aCell:            Cell;
   moreCellsInList:  Boolean;
BEGIN
   IF MyGetFirstSelectedCell(theList, aCell) THEN
   REPEAT
      theCell := aCell;
      moreCellsInList := LNextCell(TRUE, TRUE, aCell, theList);
   UNTIL NOT LGetSelect(TRUE, aCell, theList);
END;
</PRE>
 The <CODE>MyGetLastSelectedCell</CODE> procedure goes from one selected cell to the next until there are no more selected cells. It calls the <CODE>LNextCell</CODE> function to move from one cell to the next cell in the list. If it did not do this, then the procedure would loop infinitely, since <CODE>LGetSelect</CODE> would repeatedly return <CODE>TRUE</CODE> for the first selected cell. The first two parameters to <CODE>LNextCell</CODE> indicate whether the function should return the next cell in the current row, the next cell in the current column, or, if both are set to <CODE>TRUE</CODE>, the next cell regardless of location.<A NAME=MARKER-2-199></A><P>
 Your application can use the <CODE>LSetSelect</CODE> procedure to set or deselect a cell by passing <CODE>TRUE</CODE> or <CODE>FALSE</CODE>, respectively, as the first parameter to the routine. <A HREF=#MARKER-9-192>Listing 4-9</A> illustrates a useful procedure that uses <CODE>LSetSelect</CODE> and <CODE>LGetSelect</CODE> to select a single cell in a list while deselecting all other cells.<A NAME=MARKER-2-193></A><P>
<B>Listing 4-9  <A NAME=MARKER-9-192></A>Selecting a cell and deselecting other cells<A NAME=MARKER-2-193></A></B><P>
<PRE>
PROCEDURE MySelectOneCell (theList: ListHandle; theCell: Cell);
VAR
   nextSelectedCell:    Cell;
   moreCellsInList:     Boolean;
BEGIN
   IF MyGetFirstSelectedCell(theList, nextSelectedCell) THEN
   WHILE LGetSelect(TRUE, nextSelectedCell, theList) DO
   BEGIN                   {move to next selected cell...}
      IF (nextSelectedCell.h &lt;&gt; theCell.h) OR
            (nextSelectedCell.v &lt;&gt; theCell.v) THEN
                           {...and remove cell from selection}
         LSetSelect(FALSE, nextSelectedCell, theList)
      ELSE
         moreCellsInList := 
                           {move to next cell}
            LNextCell(TRUE, TRUE, nextSelectedCell, theList);
   END;
   LSetSelect(TRUE, theCell, theList);
END;
</PRE>
 The <CODE>MySelectOneCell</CODE> procedure defined in <A HREF=#MARKER-9-192>Listing 4-9</A> deselects each selected cell, except that if it encounters the cell that is ultimately to be selected, then it does not deselect that cell. This prevents an annoying flickering that would otherwise occur if you were to call <CODE>MySelectOneCell</CODE> to select a cell already selected.<P>
 <A NAME=MARKER-2-180></A>The List Manager provides the <CODE>LAutoScroll</CODE> procedure to enable your application to scroll the first selected cell to the upper-left corner of the list's visible rectangle--for example:<P>
<PRE>
LAutoScroll(myList);
</PRE>
 Sometimes, you might want your application to scroll a list just enough so that a certain cell (such as a cell the user has just selected using the keyboard) is visible. For example, this is how the Standard File Package responds if the user presses the Down Arrow key when the currently selected item is on the bottom of the list's visible rectangle. You can mimic this effect by calling the <CODE>LScroll</CODE> procedure, which requires that your application indicate how many columns and rows to scroll. Negative numbers indicate scrolling up or to the left. Positive numbers indicate scrolling down or to the right. <A HREF=#MARKER-9-195>Listing 4-10</A> illustrates the use of the <CODE>LScroll</CODE> procedure.<P>
<B>Listing 4-10  <A NAME=MARKER-9-195></A>Scrolling so that a particular cell is visible<A NAME=MARKER-2-196></A></B><P>
<PRE>
PROCEDURE MyMakeCellVisible (theList: ListHandle; theCell: Cell);
VAR
   visibleRect:      Rect;    {rectangle enclosing visible cells}
   dCols, dRows:     Integer; {number of rows to scroll}
BEGIN
   visibleRect := theList^^.visible;
   IF NOT PtInRect(theCell, visibleRect) THEN
   BEGIN                      {cell is not already visible}
      WITH theCell, visibleRect DO
      BEGIN
         IF h &gt; right - 1 THEN
            dCols := h - right + 1     {move to left}
         ELSE IF h &lt; left THEN
            dCols := h - left;         {move to right}
         IF v &gt; bottom - 1 THEN
            dRows := v - bottom + 1    {move up}
         ELSE IF v &lt; top THEN
            dRows := v - top;          {move down}
      END;
      LScroll(dCols, dRows, theList);
   END;
END;
</PRE>
 The <CODE>MyMakeCellVisible</CODE> procedure defined in <A HREF=#MARKER-9-195>Listing 4-10</A> simply computes the number of cells between the last visible row and column and the selected cell. Note that the last visible column for a list is equal to <CODE>theList^^.visible.right - 1</CODE>, and the last visible row is <CODE>theList^^.visible.bottom - 1</CODE>.<A NAME=MARKER-2-136></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MoreToolbox-212.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-214.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MoreToolbox-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>   
