<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>HTMLUserPane - /HTMLControl.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxUserExperience-date.html">User Experience</a> &gt; <A HREF="javascript:location.replace('index.html');">HTMLUserPane</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxUserExperience-date.html" target="_blank">Carbon > User Experience</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">HTMLUserPane</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/HTMLControl.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/docs/display.html</option>
<option value="listing2.html">/docs/drawing.html</option>
<option value="listing3.html">/docs/generalroutines.html</option>
<option value="listing4.html">/docs/index.html</option>
<option value="listing5.html">/docs/intro.html</option>
<option value="listing6.html">/docs/types.html</option>
<option value="listing7.html">/docs/userdefined.html</option>
<option value="listing8.html">/docs/utilities.html</option>
<option value="listing9.html">/HTMLControl.c</option>
<option value="listing10.html">/HTMLControl.h</option>
<option value="listing11.html">/HTMLUserPane.c</option>
<option value="listing12.html">/HTMLUserPane.h</option>
<option value="listing13.html">/HTMLUserPane.r</option></select>
				</p>
				</form>
				<p><strong><a href="HTMLUserPane.zip">Download Sample</a></strong> (&#147;HTMLUserPane.zip&#148;, 96.7K)<BR>
<strong><a href="HTMLUserPane.dmg">Download Sample</a></strong> (&#147;HTMLUserPane.dmg&#148;, 155.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*    File: HTMLControl.c        Description:        HTMLControl implementation.    Copyright:        &copy; Copyright 2000 Apple Computer, Inc. All rights reserved.        Disclaimer:        IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your        use, installation, modification or redistribution of this Apple software        constitutes acceptance of these terms.  If you do not agree with these terms,        please do not use, install, modify or redistribute this Apple software.        In consideration of your agreement to abide by the following terms, and subject        to these terms, Apple grants you a personal, non-exclusive license, under Apple's        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,        reproduce, modify and redistribute the Apple Software, with or without        modifications, in source and/or binary forms; provided that if you redistribute        the Apple Software in its entirety and without modifications, you must retain        this notice and the following text and disclaimers in all such redistributions of        the Apple Software.  Neither the name, trademarks, service marks or logos of        Apple Computer, Inc. may be used to endorse or promote products derived from the        Apple Software without specific prior written permission from Apple.  Except as        expressly stated in this notice, no other rights or licenses, express or implied,        are granted by Apple herein, including but not limited to any patent rights that        may be infringed by your derivative works or by other works in which the Apple        Software may be incorporated.        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN        COMBINATION WITH YOUR PRODUCTS.        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    Change History (most recent first):        Fri, Jan 28, 2000 -- created*/#ifdef __APPLE_CC__#include &lt;Carbon/Carbon.h&gt;#else#include &lt;Carbon.h&gt;#endif#include &quot;HTMLControl.h&quot;enum {  kShiftKeyCode = 56};/* kUserClickedToFocusPart is a part code we pass to the SetKeyboardFocus  routine.  In our focus switching routine this part code is understood  as meaning 'the user has clicked in the control and we need to switch  the current focus to ourselves before we can continue'. */#define kUserClickedToFocusPart 100/* kHTMLClickScrollDelayTicks is a time measurement in ticks used to  slow the speed of 'auto scrolling' inside of our clickloop routine.  This value prevents the text from wizzzzzing by while the mouse  is being held down inside of the text area. */#define kHTMLClickScrollDelayTicks 3#define kNavButtonHeight 22#define kNavButtonWidth 44#define kNavButtonSpacing 5/* STPTextPaneVars is a structure used for storing the the HTML Control's  internal variables and state information.  A handle to this record is  stored in the pane control's reference value field using the  SetControlReference routine. */typedef struct {    /* OS records referenced */  HRReference fHTMLRec; /* the txn record */  ControlHandle fUserPaneRec;  /* handle to the user pane control */  WindowPtr fOwner; /* window containing control */  CGrafPtr fDrawingEnvironment; /* grafport where control is drawn */    /* flags */  Boolean fInFocus; /* true while the focus rect is drawn around the control */  Boolean fIsActive; /* true while the control is drawn in the active state */  Boolean fTEActive; /* reflects the activation state of the text edit record */   Boolean fInDialogWindow; /* true if displayed in a dialog window */     /* calculated locations */  Rect fRCachedBounds; /* area where the text is drawn */  Rect fRHTMLArea; /* area where the text is drawn */  Rect fRFocusOutline;  /* rectangle used to draw the focus box */  Rect fRTextOutline; /* rectangle used to draw the border */  RgnHandle fTextBackgroundRgn; /* background region for the text, erased before calling TEUpdate */} STPTextPaneVars;/* Univeral Procedure Pointer variables used by the  HTML Control.  These variables are set up  the first time that HTMLOpenControl is called. */ControlUserPaneDrawUPP gTPDrawProc = NULL;ControlUserPaneHitTestUPP gTPHitProc = NULL;ControlUserPaneTrackingUPP gTPTrackProc = NULL;ControlUserPaneIdleUPP gTPIdleProc = NULL;ControlUserPaneKeyDownUPP gTPKeyProc = NULL;ControlUserPaneActivateUPP gTPActivateProc = NULL;ControlUserPaneFocusUPP gTPFocusProc = NULL;static void CalculateHTMLControlRectangles(STPTextPaneVars **tpvars, Rect *bounds) {  STPTextPaneVars *varsp;  char state;    /* set up our globals */  state = HGetState((Handle) tpvars);  HLock((Handle) tpvars);  varsp = *tpvars;    /* basic outline and general areas */  varsp-&gt;fRHTMLArea = varsp-&gt;fRTextOutline = *bounds;  varsp-&gt;fRFocusOutline = varsp-&gt;fRCachedBounds = *bounds;  RectRgn(varsp-&gt;fTextBackgroundRgn, &amp;varsp-&gt;fRHTMLArea);    /* restore state */  HSetState((Handle) tpvars, state);}/* TPActivatePaneText activates or deactivates the text edit record  according to the value of setActive.  The primary purpose of this  routine is to ensure each call is only made once. */static void TPActivatePaneText(STPTextPaneVars **tpvars, Boolean setActive) {  STPTextPaneVars *varsp;  varsp = *tpvars;  if (varsp-&gt;fTEActive != setActive) {    varsp-&gt;fTEActive = setActive;    if (setActive)      HRActivate(varsp-&gt;fHTMLRec);    else HRDeactivate(varsp-&gt;fHTMLRec);  }}/* TPFocusPaneText set the focus state for the text record. */static void TPFocusPaneText(STPTextPaneVars **tpvars, Boolean setFocus) {  STPTextPaneVars *varsp;  varsp = *tpvars;  if (varsp-&gt;fInFocus != setFocus) {    varsp-&gt;fInFocus = setFocus;    /* no special processing for HTML structures */  }}/* TPPaneDrawProc is called to redraw the control and for update events  referring to the control.  This routine erases the text area's background,  and redraws the text.  This routine assumes the scroll bar has been  redrawn by a call to DrawControls. */static pascal void TPPaneDrawProc(ControlRef theControl, ControlPartCode thePart) {  STPTextPaneVars **tpvars, *varsp;  char state;  Rect bounds;    /* set up our globals */  tpvars = (STPTextPaneVars **) GetControlReference(theControl);  if (tpvars != NULL) {    RgnHandle clipSave;    state = HGetState((Handle) tpvars);    HLock((Handle) tpvars);    varsp = *tpvars;            /* save the drawing state */    SetPort((**tpvars).fDrawingEnvironment);          /* verify our boundary */    GetControlBounds(theControl, &amp;bounds);    if ( ! EqualRect(&amp;bounds, &amp;varsp-&gt;fRCachedBounds) ) {      CalculateHTMLControlRectangles(tpvars, &amp;bounds);      HRSetRenderingRect( varsp-&gt;fHTMLRec, &amp;varsp-&gt;fRHTMLArea);    } else {      HRSetRenderingRect( varsp-&gt;fHTMLRec, &amp;varsp-&gt;fRHTMLArea);    }                /* update the navigation controls */    SetPort((**tpvars).fDrawingEnvironment);    GetClip((clipSave = NewRgn()));    ClipRect(&amp;varsp-&gt;fRHTMLArea);      /* update the text region */    EraseRgn(varsp-&gt;fTextBackgroundRgn);    HRDraw( varsp-&gt;fHTMLRec, varsp-&gt;fTextBackgroundRgn);      /* restore the drawing environment */    SetClip(clipSave);    DisposeRgn(clipSave);      /* draw the text frame and focus frame (if necessary) */    DrawThemeEditTextFrame(&amp;varsp-&gt;fRTextOutline, varsp-&gt;fIsActive ? kThemeStateActive: kThemeStateInactive);    if ((**tpvars).fIsActive &amp;&amp; varsp-&gt;fInFocus) DrawThemeFocusRect(&amp;varsp-&gt;fRFocusOutline, true);      /* release our globals */    HSetState((Handle) tpvars, state);  }}/* TPPaneHitTestProc is called when the control manager would  like to determine what part of the control the mouse resides over.  We also call this routine from our tracking proc to determine how  to handle mouse clicks. */static pascal ControlPartCode TPPaneHitTestProc(ControlHandle theControl, Point where) {  STPTextPaneVars **tpvars;  ControlPartCode result;  char state;    /* set up our locals and lock down our globals*/  result = 0;  tpvars = (STPTextPaneVars **) GetControlReference(theControl);  if (tpvars != NULL) {    state = HGetState((Handle) tpvars);    HLock((Handle) tpvars);      /* find the region where we clicked */    if (PtInRect(where, &amp;(**tpvars).fRHTMLArea)) {      result = kHTMLTextPart;    } else result = 0;      /* release oure globals */    HSetState((Handle) tpvars, state);  }  return result;}/* TPPaneTrackingProc is called when the mouse is being held down  over our control.  This routine handles clicks in the text area  and in the scroll bar. */static pascal ControlPartCode TPPaneTrackingProc(ControlHandle theControl, Point startPt, ControlActionUPP actionProc) {  STPTextPaneVars **tpvars, *varsp;  char state;  ControlPartCode partCodeResult;    /* make sure we have some variables... */  partCodeResult = 0;  tpvars = (STPTextPaneVars **) GetControlReference(theControl);  if (tpvars != NULL) {      /* lock 'em down */    state = HGetState((Handle) tpvars);    HLock((Handle) tpvars);    varsp = *tpvars;      /* we don't do any of these functions unless we're in focus */    if ( ! varsp-&gt;fInFocus) {      WindowPtr owner;      owner = GetControlOwner(theControl);      ClearKeyboardFocus(owner);      SetKeyboardFocus(owner, theControl, kUserClickedToFocusPart);    }      /* find the location for the click */    switch (TPPaneHitTestProc(theControl, startPt)) {                /* handle clicks in the text part */      case kHTMLTextPart:        {  EventRecord ev;          SetPort((**tpvars).fDrawingEnvironment);          ev.what = mouseDown;          ev.message = 0;          ev.when = TickCount();          GetMouse(&amp;ev.where);          LocalToGlobal(&amp;ev.where);          ev.modifiers = 0;          HRIsHREvent(&amp;ev);        }        break;          }        HSetState((Handle) tpvars, state);  }  return partCodeResult;}/* TPPaneIdleProc is our user pane idle routine.  When our text field  is active and in focus, we use this routine to set the cursor. */static pascal void TPPaneIdleProc(ControlHandle theControl) {  STPTextPaneVars **tpvars, *varsp;    /* set up locals */  tpvars = (STPTextPaneVars **) GetControlReference(theControl);  if (tpvars != NULL) {      /* if we're not active, then we have nothing to say about the cursor */    if ((**tpvars).fIsActive) {      char state;      EventRecord ev;        /* lock down the globals */      state = HGetState((Handle) tpvars);      HLock((Handle) tpvars);      varsp = *tpvars;        /* set up our port */      SetPort(GetWindowPort(GetControlOwner(theControl)));        /* fake a null event */      ev.what = nullEvent;      ev.message = 0;      ev.when = TickCount();      GetMouse(&amp;ev.where);      LocalToGlobal(&amp;ev.where);      ev.modifiers = 0;      HRIsHREvent(&amp;ev);              /* clean up */      HSetState((Handle) tpvars, state);    }  }}/* TPPaneKeyDownProc is called whenever a keydown event is directed  at our control.  Here, we direct the keydown event to the text  edit record and redraw the scroll bar and text field as appropriate. */static pascal ControlPartCode TPPaneKeyDownProc(ControlHandle theControl,              SInt16 keyCode, SInt16 charCode, SInt16 modifiers) {  STPTextPaneVars **tpvars;  tpvars = (STPTextPaneVars **) GetControlReference(theControl);  if (tpvars != NULL) {    if ((**tpvars).fInFocus) {        /* turn autoscrolling on and send the key event to text edit */      SetPort((**tpvars).fDrawingEnvironment);            /* no operation here, but it would be cool tu use the arrow      keys and the page up and page down keys for scrolling... */    }  }  return kControlEntireControl;}/* TPPaneActivateProc is called when the window containing  the user pane control receives activate events. Here, we redraw  the control and it's text as necessary for the activation state. */static pascal void TPPaneActivateProc(ControlHandle theControl, Boolean activating) {  Rect bounds;  STPTextPaneVars **tpvars, *varsp;  char state;    /* set up locals */  tpvars = (STPTextPaneVars **) GetControlReference(theControl);  if (tpvars != NULL) {    state = HGetState((Handle) tpvars);    HLock((Handle) tpvars);    varsp = *tpvars;      /* de/activate the text edit record */    SetPort((**tpvars).fDrawingEnvironment);      GetControlBounds(theControl, &amp;bounds);      varsp-&gt;fIsActive = activating;      TPActivatePaneText(tpvars, varsp-&gt;fIsActive /* &amp;&amp; varsp-&gt;fInFocus */ );      /* redraw the frame */    DrawThemeEditTextFrame(&amp;varsp-&gt;fRTextOutline, varsp-&gt;fIsActive ? kThemeStateActive: kThemeStateInactive);    if (varsp-&gt;fInFocus) DrawThemeFocusRect(&amp;varsp-&gt;fRFocusOutline, varsp-&gt;fIsActive);    HSetState((Handle) tpvars, state);  }}/* TPPaneFocusProc is called when every the focus changes to or  from our control.  Herein, switch the focus appropriately  according to the parameters and redraw the control as  necessary.  */static pascal ControlPartCode TPPaneFocusProc(ControlHandle theControl, ControlFocusPart action) {  ControlPartCode focusResult;  STPTextPaneVars **tpvars, *varsp;  char state;    /* set up locals */  focusResult = kControlFocusNoPart;  tpvars = (STPTextPaneVars **) GetControlReference(theControl);  if (tpvars != NULL) {    state = HGetState((Handle) tpvars);    HLock((Handle) tpvars);    varsp = *tpvars;      /* if kControlFocusPrevPart and kControlFocusNextPart are received when the user is      tabbing forwards (or shift tabbing backwards) through the items in the dialog,      and kControlFocusNextPart will be received.  When the user clicks in our field      and it is not the current focus, then the constant kUserClickedToFocusPart will      be received.  The constant kControlFocusNoPart will be received when our control      is the current focus and the user clicks in another control.  In your focus routine,      you should respond to these codes as follows:      kControlFocusNoPart - turn off focus and return kControlFocusNoPart.  redraw        the control and the focus rectangle as necessary.      kControlFocusPrevPart or kControlFocusNextPart - toggle focus on or off        depending on its current state.  redraw the control and the focus rectangle        as appropriate for the new focus state.  If the focus state is 'off', return the constant        kControlFocusNoPart, otherwise return a non-zero part code.      kUserClickedToFocusPart - is a constant defined for this example.  You should        define your own value for handling click-to-focus type events. */      /* save the drawing state */    SetPort((**tpvars).fDrawingEnvironment);      /* calculate the next highlight state */    switch (action) {      default:      case kControlFocusNoPart:        TPFocusPaneText(tpvars, false);        focusResult = kControlFocusNoPart;        break;      case kUserClickedToFocusPart:        TPFocusPaneText(tpvars, true);        focusResult = 1;        break;      case kControlFocusPrevPart:      case kControlFocusNextPart:        TPFocusPaneText(tpvars, ( ! varsp-&gt;fInFocus));        focusResult = varsp-&gt;fInFocus ? 1 : kControlFocusNoPart;        break;    }      TPActivatePaneText(tpvars, varsp-&gt;fIsActive /* &amp;&amp; varsp-&gt;fInFocus */ );      /* redraw the text fram and focus rectangle to indicate the      new focus state */    DrawThemeEditTextFrame(&amp;varsp-&gt;fRTextOutline, varsp-&gt;fIsActive ? kThemeStateActive: kThemeStateInactive);    DrawThemeFocusRect(&amp;varsp-&gt;fRFocusOutline, varsp-&gt;fIsActive &amp;&amp; varsp-&gt;fInFocus);      /* done */    HSetState((Handle) tpvars, state);  }  return focusResult;}/* HTMLOpenControl initializes a user pane control so it will be drawn  and will behave as a scrolling text edit field inside of a window.  This routine performs all of the initialization steps necessary,  except it does not create the user pane control itself.  theControl  should refer to a user pane control that you have either created  yourself or extracted from a dialog's control heirarchy using  the GetDialogItemAsControl routine.  */OSStatus HTMLOpenControl(ControlHandle theControl) {  Rect bounds;  WindowPtr theWindow;  STPTextPaneVars **tpvars, *varsp;  OSStatus err;    if ( ! HRHTMLRenderingLibAvailable()) return paramErr;      /* set up our globals */  if (gTPDrawProc == NULL) gTPDrawProc = NewControlUserPaneDrawUPP(TPPaneDrawProc);  if (gTPHitProc == NULL) gTPHitProc = NewControlUserPaneHitTestUPP(TPPaneHitTestProc);  if (gTPTrackProc == NULL) gTPTrackProc = NewControlUserPaneTrackingUPP(TPPaneTrackingProc);  if (gTPIdleProc == NULL) gTPIdleProc = NewControlUserPaneIdleUPP(TPPaneIdleProc);  if (gTPKeyProc == NULL) gTPKeyProc = NewControlUserPaneKeyDownUPP(TPPaneKeyDownProc);  if (gTPActivateProc == NULL) gTPActivateProc = NewControlUserPaneActivateUPP(TPPaneActivateProc);  if (gTPFocusProc == NULL) gTPFocusProc = NewControlUserPaneFocusUPP(TPPaneFocusProc);        /* allocate our private storage */  tpvars = (STPTextPaneVars **) NewHandleClear(sizeof(STPTextPaneVars));  SetControlReference(theControl, (long) tpvars);  HLock((Handle) tpvars);  varsp = *tpvars;    /* set the initial settings for our private data */  varsp-&gt;fInFocus = false;  varsp-&gt;fIsActive = true;  varsp-&gt;fTEActive = false;  varsp-&gt;fUserPaneRec = theControl;  theWindow = varsp-&gt;fOwner = GetControlOwner(theControl);  varsp-&gt;fDrawingEnvironment = GetWindowPort(varsp-&gt;fOwner);  SetPort(varsp-&gt;fDrawingEnvironment);  varsp-&gt;fInDialogWindow = ( GetWindowKind(varsp-&gt;fOwner) == kDialogWindowKind );  varsp-&gt;fTextBackgroundRgn = NewRgn();    /* set up the user pane procedures */  SetControlData(theControl, kControlEntireControl, kControlUserPaneDrawProcTag, sizeof(gTPDrawProc), &amp;gTPDrawProc);  SetControlData(theControl, kControlEntireControl, kControlUserPaneHitTestProcTag, sizeof(gTPHitProc), &amp;gTPHitProc);  SetControlData(theControl, kControlEntireControl, kControlUserPaneTrackingProcTag, sizeof(gTPTrackProc), &amp;gTPTrackProc);  SetControlData(theControl, kControlEntireControl, kControlUserPaneIdleProcTag, sizeof(gTPIdleProc), &amp;gTPIdleProc);  SetControlData(theControl, kControlEntireControl, kControlUserPaneKeyDownProcTag, sizeof(gTPKeyProc), &amp;gTPKeyProc);  SetControlData(theControl, kControlEntireControl, kControlUserPaneActivateProcTag, sizeof(gTPActivateProc), &amp;gTPActivateProc);  SetControlData(theControl, kControlEntireControl, kControlUserPaneFocusProcTag, sizeof(gTPFocusProc), &amp;gTPFocusProc);    /* calculate the rectangles used by the control */  GetControlBounds(theControl, &amp;bounds);  CalculateHTMLControlRectangles(tpvars, &amp;bounds);        /* create the new edit field */  err = HRNewReference( &amp;varsp-&gt;fHTMLRec, kHRRendererHTML32Type, varsp-&gt;fDrawingEnvironment);  if (err == NULL) goto bail;  HRSetRenderingRect( varsp-&gt;fHTMLRec, &amp;varsp-&gt;fRHTMLArea);    /* unlock our storage */  HUnlock((Handle) tpvars);      /* perform final activations and setup for our text field.  Here,    we assume that the window is going to be the 'active' window. */  TPActivatePaneText(tpvars, varsp-&gt;fIsActive /* &amp;&amp; varsp-&gt;fInFocus */ );    /* all done */  return noErr;bail:  return err;}/* HTMLCloseControl deallocates all of the structures allocated  by HTMLOpenControl.  */OSStatus HTMLCloseControl(ControlHandle theControl) {  STPTextPaneVars **tpvars;    /* set up locals */  tpvars = (STPTextPaneVars **) GetControlReference(theControl);    /* release our sub records */  HRDisposeReference((**tpvars).fHTMLRec);    /* delete our private storage */  DisposeHandle((Handle) tpvars);    /* zero the control reference */  SetControlReference(theControl, 0);  return noErr;}/* STUPCreateControl creates a new user pane control and then it passes it  to STUPOpenControl to initialize it as a scrolling text user pane control. */OSStatus HTMLCreateControl(WindowPtr theWindow, Rect *bounds, ControlHandle *theControl) {  short featurSet;    /* the following feature set can be specified in CNTL resources by using    the value 1214.  When creating a user pane control, we pass this value    in the 'value' parameter. */  featurSet = kControlSupportsEmbedding | kControlSupportsFocus | kControlWantsIdle      | kControlWantsActivate | kControlHandlesTracking | kControlHasSpecialBackground      | kControlGetsFocusOnClick | kControlSupportsLiveFeedback;    /* create the control */  *theControl = NewControl(theWindow, bounds, &quot;\p&quot;, true, featurSet, 0, featurSet, kControlUserPaneProc, 0);    /* set up the STUP specific features and data */  HTMLOpenControl(*theControl);    /* all done.... */  return noErr;}/* STUPDisposeControl calls STUPCloseControl and then it calls DisposeControl. */OSStatus HTMLDisposeControl(ControlHandle theControl) {    /* deallocate the STUP specific data */  HTMLCloseControl(theControl);    /* deallocate the user pane control itself */  DisposeControl(theControl);  return noErr;}/* HTMLGotoURL displays HTML file referred to by the url in the  rendering control.  if addToHistory is true, then the window  will be added to the window's history list. */OSStatus HTMLDisplayFile(ControlHandle theControl, FSSpec *theFile) {  STPTextPaneVars **tpvars;    /* set up locals */  tpvars = (STPTextPaneVars **) GetControlReference(theControl);    /* display the file */  return HRGoToFile( (**tpvars).fHTMLRec, theFile, true, true);}  /* HTMLDisplayBuffer displays the HTML described by the buffer. */OSStatus HTMLDisplayBuffer(ControlHandle theControl, char *buffer, long bytecount) {  STPTextPaneVars **tpvars;    /* set up locals */  tpvars = (STPTextPaneVars **) GetControlReference(theControl);    /* display the file */  return HRGoToPtr(  (**tpvars).fHTMLRec, buffer, bytecount, false, true);}  /* HTMLDisplayHandle displays the HTML in the handle htmlData. */OSStatus HTMLDisplayHandle(ControlHandle theControl, Handle htmlData) {  STPTextPaneVars **tpvars;  char state;  OSStatus err;    /* set up locals, verify parameters */  if (htmlData == NULL || theControl == NULL) return paramErr;  tpvars = (STPTextPaneVars **) GetControlReference(theControl);    /* display the file */  state = HGetState(htmlData);  HLock(htmlData);  err = HRGoToPtr(  (**tpvars).fHTMLRec, (char*) (*htmlData), GetHandleSize(htmlData), false, true);  HSetState(htmlData, state);  return err;}/* IsHTMLControl returns true if theControl is not NULL  and theControl refers to a HTML Control.  */Boolean IsHTMLControl(ControlHandle theControl) {  Size theSize;  ControlUserPaneFocusUPP localFocusProc;    /* a NULL control is not a mUP control */  if (theControl == NULL) return false;    /* check if the control is using our focus procedure */  theSize = sizeof(localFocusProc);  if (GetControlData(theControl, kControlEntireControl, kControlUserPaneFocusProcTag,    sizeof(localFocusProc), &amp;localFocusProc, &amp;theSize) != noErr) return false;  if (localFocusProc != gTPFocusProc) return false;    /* all tests passed, it's a mUP control */  return true;}  /* HTMLDisplayHandle displays the HTML in the handle htmlData. */OSStatus HTMLDisplayURL(ControlHandle theControl, char const* url) {  STPTextPaneVars **tpvars;  OSStatus err;    /* set up locals, verify parameters */  if (url == NULL || theControl == NULL) return paramErr;  tpvars = (STPTextPaneVars **) GetControlReference(theControl);      /* display the file */  err = HRGoToURL( (**tpvars).fHTMLRec, url, true, true);  return err;}#if 0/* RWGotoURL displays HTML file referred to by the url in the  rendering window.  if addToHistory is true, then the window  will be added to the window's history list. */OSStatus RWGotoURL(WindowPtr rWin, char* url, Boolean addToHistory) {  RWindowHandle rwv;  OSStatus err;  Point origin = {0, 0};  Rect donedrawingbox;    /* set up locals */  rwv = (RWindowHandle) GetWRefCon(rWin);    /* if the URL does not contain an anchor, then scroll    the HTML view to the origin. */  if ( ! URLContainsAnchor(url)) {    err = HRScrollToLocation((**rwv).renderer, &amp;origin);    if (err != noErr) goto bail;  }    /* ask the rendering object to display the HTML page    referred to by the URL.  note, we pass the addToHistory to    this routine which in turn passes it to our MyNewURLProc    routine. */  err = HRGoToURL((**rwv).renderer, url, addToHistory, false);  if (err != noErr) goto bail;      /* draw the new page */  err = HRDraw((**rwv).renderer, NULL);  if (err != noErr) goto bail;      /* if addToHistory is false, then we would not    have re-drawn the buttons inside of our MyNewURLProc    routine so we should draw them here. */  if ( ! addToHistory)    RedrawWindowButtons(rwv);        /* we validate the areas that were drawn by this    routine.  This is to avoid unnecessary redraws when    the window is first opened.  When the window is opened,    an update event will be posted for its entire contents.    These calls prevent the areas we have just drawn from    being re-drawn when the update event is processed. */  SetRect(&amp;donedrawingbox, 0, 0, 32*3, 32);  ValidWindowRect(rWin, &amp;donedrawingbox);  GetPortBounds(GetWindowPort((**rwv).rwindow), &amp;donedrawingbox);  donedrawingbox.top += 33;  ValidWindowRect(rWin, &amp;donedrawingbox);    /* done */  return noErr;bail:  return err;}/* GetApplicationFolder returns the volume reference number and  directory id of the folder containing the application. */OSStatus GetApplicationFolder(FSSpec *spec) {  OSStatus err;  FCBPBRec fcpb;  Str255 name;  CInfoPBRec cat;  Handle h;    h = GetResource('vTeZ', 0);  if (h == NULL) return resNotFound;    BlockZero(&amp;fcpb, 0);  fcpb.ioVRefNum = 0;  fcpb.ioNamePtr = name;  fcpb.ioFCBParID = 0;  fcpb.ioRefNum = HomeResFile(h);  fcpb.ioFCBIndx = 0;  if ((err = PBGetFCBInfoSync(&amp;fcpb)) != noErr) return err;    BlockZero(&amp;cat, 0);  cat.dirInfo.ioNamePtr = name;  cat.dirInfo.ioVRefNum = fcpb.ioFCBVRefNum;  cat.dirInfo.ioFDirIndex = -1;  cat.dirInfo.ioDrDirID = fcpb.ioFCBParID;  err = PBGetCatInfoSync(&amp;cat);  if (err != noErr) return err;    err = FSMakeFSSpec(fcpb.ioFCBVRefNum, cat.dirInfo.ioDrParID, name, spec);  if (err != noErr) return err;    return noErr;}/* GetApplicationFolder returns a URL referring to the folder  containing the application.  If successful, *url is set  to a new handle containing the URL.  It is the caller's  responsibility to dispose of this handle. */OSStatus GetApplicationFolderURL(Handle *url) {  OSStatus err;  FSSpec spec;  Handle theURL;    /* set up locals to a known state */  theURL = NULL;    /* find the application's folder */   err = GetApplicationFolder(&amp;spec);  if (err != noErr) goto bail;    /* create a new handle for storing the URL */  theURL = NewHandle(0);  if (theURL == NULL) { err = memFullErr; goto bail; }    /* ask the HTML rendering library to convert    the FSSpec into a URL */  err = HRUtilGetURLFromFSSpec(&amp;spec, theURL);  if (err != noErr) goto bail;      /* add a slash at the end of the name, if one is not there */  if ( (*theURL)[GetHandleSize(theURL) - 2] != '/')    Munger(theURL, (GetHandleSize(theURL) - 1), NULL, 0, &quot;/&quot;, 1);    /* return the URL */  *url = theURL;  return noErr;bail:  if (theURL != NULL) DisposeHandle(theURL);  return err;}/* RWGotoAppRelLink displays HTML file referred to by the application  relative link in the rendering window.  if addToHistory is true, then  the window will be added to the window's history list. */OSStatus RWGotoAppRelLink(WindowPtr rWin, char* linkstr, Boolean addToHistory) {  OSStatus err;  Handle rootURL, fullURL;    /* set up our locals */  rootURL = fullURL = NULL;    /* get the URL for the application's folder */  err = GetApplicationFolderURL(&amp;rootURL);  if (err != noErr) goto bail;    /* allocate a handle for storing the full URL */  fullURL = NewHandle(0);  if (fullURL == NULL) { err = memFullErr; goto bail; }    /* ask the HTML rendering library to combine    the url and the link to make a complete URL */  HLock(rootURL);  err = HRUtilCreateFullURL(*rootURL, linkstr, fullURL);  if (err != noErr) goto bail;  HUnlock(rootURL);    /* call the RWGotoURL to bring the HTML file into view. */  MoveHHi(fullURL);  HLock(fullURL);  err = RWGotoURL(rWin, *fullURL, addToHistory);  if (err != noErr) goto bail;      /* clean up our locals */  DisposeHandle(rootURL);  DisposeHandle(fullURL);    /* done */  return noErr;bail:    /* on error, clean up and return the error. */  if (rootURL != NULL) DisposeHandle(rootURL);  if (fullURL != NULL) DisposeHandle(fullURL);  return err;}#endif</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/HTMLUserPane/listing9.html%3Fid%3DDTS10000580-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/HTMLUserPane/listing9.html%3Fid%3DDTS10000580-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/HTMLUserPane/listing9.html%3Fid%3DDTS10000580-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>