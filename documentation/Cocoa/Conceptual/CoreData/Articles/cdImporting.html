<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Core Data Programming Guide: Efficiently Importing Data</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Efficiently Importing Data"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40003174" title="Efficiently Importing Data"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../index.html" target="_top">Core Data Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="cdTroubleshooting.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="cdZ104UsingMOs.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40003174-SW1" title="Efficiently Importing Data"></a><hr /><H1>Efficiently Importing Data</H1><p>This article describes how you can efficiently import data into a Core Data application and turn the data into managed objects to save to a persistent store. It discusses some of the fundamental Cocoa patterns you should follow, and patterns that are specific to Core Data.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="cdImporting.html#//apple_ref/doc/uid/TP40003174-SW3">Cocoa Fundamentals</a>
				
			<br/>
			
        
			
			
				<a href="cdImporting.html#//apple_ref/doc/uid/TP40003174-SW2">Reducing Peak Memory Footprint</a>
				
			<br/>
			
        
			
			
				<a href="cdImporting.html#//apple_ref/doc/uid/TP40003174-SW4">Implementing Find-or-Create Efficiently</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40003174-SW3" title="Cocoa Fundamentals"></a><h2>Cocoa Fundamentals</h2><p>In common with many other situations, when you use Core Data to import a data file it is important to remember "normal rules" of Cocoa application development apply, particularly if you are using a managed memory environment (as opposed to garbage collection). If you import a data file that you have to parse in some way, it is likely you will create a large number of autoreleased objects. These can take up a lot of memory and lead to paging. Just as you would with a non-Core Data application, you can use local autorelease pools to put a bound on how many additional objects reside in memory (for example, if you create a loop to iterate over data you can use an inner autorelease pool that you release and re-create every few times through your main loop). You can also create objects using <code>alloc</code> and <code>init</code> and then <code>release</code> them when you no longer need them—this avoids putting them in an autorelease pool in the first place. For more about the interaction between Core Data and memory management, see <span class="content_text"><a href="cdPerformance.html#//apple_ref/doc/uid/TP40003468-SW4">“Reducing Memory Overhead.”</a></span></p><p>You should also avoid repeating work unnecessarily. One subtle case lies in creating a predicate containing a variable. If you create the predicate as shown in the following example, you are not only creating a predicate every time through your loop, you are <em>parsing</em> one.</p><div class="codesample"><table><tr><td scope="row"><pre>// loop over employeeIDs<span></span></pre></td></tr><tr><td scope="row"><pre>// anID = ... each employeeID in turn<span></span></pre></td></tr><tr><td scope="row"><pre>// within body of loop<span></span></pre></td></tr><tr><td scope="row"><pre>NSString *predicateString = [NSString stringWithFormat:<span></span></pre></td></tr><tr><td scope="row"><pre>        @"employeeID == %@", anID];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>NSPredicate *predicate = [NSPredicate predicateWithFormat:predicateString];<span></span></pre></td></tr></table></div><p>To create a predicate from a formatted string, the framework must parse the string and create instances of predicate and expression objects. If you are using the same form of a predicate many times over but changing the value of one of the constant value expressions on each use, it is more efficient to create a predicate once and then use variable substitution (see <span class="content_text"><a href="../../Predicates/Articles/pCreating.html#//apple_ref/doc/uid/TP40001793" target="_top">Creating Predicates</a></span>). This technique is illustrated in the following example.</p><div class="codesample"><table><tr><td scope="row"><pre>// before loop<span></span></pre></td></tr><tr><td scope="row"><pre>NSString *predicateString = [NSString stringWithFormat<span></span></pre></td></tr><tr><td scope="row"><pre>        @"employeeID == $EMPLOYEE_ID"];<span></span></pre></td></tr><tr><td scope="row"><pre>NSPredicate *predicate = [NSPredicate predicateWithFormat:predicateString];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// within body of loop<span></span></pre></td></tr><tr><td scope="row"><pre>NSDictionary *variables = [NSDictionary dictionaryWithObject:anID<span></span></pre></td></tr><tr><td scope="row"><pre>        forKey:@"EMPLOYEE_ID"];<span></span></pre></td></tr><tr><td scope="row"><pre>NSPredicate *localPredicate = [predicate predicateWithSubstitutionVariables:variables];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40003174-SW2" title="Reducing Peak Memory Footprint"></a><h2>Reducing Peak Memory Footprint</h2><p>If you import a large amount of data into a Core Data application, you should make sure you keep your application’s peak memory footprint low by importing the data in batches and purging the Core Data stack between batches. The relevant issues and techniques are discussed in <span class="content_text"><a href="cdPerformance.html#//apple_ref/doc/uid/TP40003468-SW1">“Core Data Performance”</a></span> (particularly <span class="content_text"><a href="cdPerformance.html#//apple_ref/doc/uid/TP40003468-SW4">“Reducing Memory Overhead”</a></span>) and <span class="content_text"><a href="cdMemory.html#//apple_ref/doc/uid/TP40001860-SW1">“Memory Management Using Core Data,”</a></span> but they’re summarized here for convenience.</p><a name="//apple_ref/doc/uid/TP40003174-SW5" title="Importing in batches"></a><h3>Importing in batches</h3><p>First, you should typically create a separate managed object context for the import, and set its undo manager to <code>nil</code>. (Contexts are not particularly expensive to create, so if you cache your persistent store coordinator you can use different contexts for different working sets or distinct operations.)</p><div class="codesample"><table><tr><td scope="row"><pre>NSManagedObjectContext *importContext = [[NSManagedObjectContext alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>NSPersistentStoreCoordinator *coordinator = /* retrieve the coordinator */ ;<span></span></pre></td></tr><tr><td scope="row"><pre>[importContext setPersistentStoreCoordinator:coordinator];<span></span></pre></td></tr><tr><td scope="row"><pre>[importContext setUndoManager:nil];<span></span></pre></td></tr></table></div><p>(If you have an existing Core Data stack, you can get the persistent store coordinator from another managed object context.) Setting the undo manager to <code>nil</code> means that:</p><ol class="ol"><li class="li"><p>You don’t waste effort recording undo actions for changes (such as insertions) that will not be undone;</p></li><li class="li"><p>The undo manager doesn’t maintain strong references to changed objects and so prevent them from being deallocated (see <span class="content_text"><a href="cdMemory.html#//apple_ref/doc/uid/TP40001860-SW2">“Change and Undo Management”</a></span>).</p></li></ol><p>You should import data and create corresponding managed objects in batches (the optimum size of the batch will depend on how much data is associated with each record and how low you want to keep the memory footprint). At the beginning of each batch you create a new autorelease pool. At the end of each batch you need to save the managed object context (using <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/save:" target="_top">save:</a></code>) and then drain the pool. (Until you save, the context needs to retain all the pending changes you've made to the inserted objects.) </p><p>The process is illustrated in the following example, although note that you would typically include suitable error-checking.</p><div class="codesample"><table><tr><td scope="row"><pre>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>NSUInteger count = 0, LOOP_LIMIT = 1000;<span></span></pre></td></tr><tr><td scope="row"><pre>NSDictionary *newRecord;<span></span></pre></td></tr><tr><td scope="row"><pre>NSManagedObject *newMO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// assume a method 'nextRecord' that returns a dictionary representing the next<span></span></pre></td></tr><tr><td scope="row"><pre>// set of data to be imported from the file<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>while (newRecord = [self nextRecord])<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // create managed object(s) from newRecord<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    count++;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (count == LOOP_LIMIT)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [importContext save:outError];<span></span></pre></td></tr><tr><td scope="row"><pre>        [importContext reset];<span></span></pre></td></tr><tr><td scope="row"><pre>        [pool drain];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        pool = [[NSAutoreleasePool alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>        count = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40003174-SW6" title="Dealing with retain cycles"></a><h3>Dealing with retain cycles</h3><p>There is an additional issue that complicates matters in a managed memory environment (it doesn’t affect applications that use garbage collection).  Managed objects with relationships nearly always create unreclaimable retain cycles. If during the import you create relationships between objects, you need to break the retain cycles so that the objects can be deallocated when they’re no longer needed. To do this, you can either turn the objects into faults, or reset the whole context. For a complete discussion, see <span class="content_text"><a href="cdMemory.html#//apple_ref/doc/uid/TP40001860-SW3">“Breaking Relationship Retain Cycles.”</a></span></p><a name="//apple_ref/doc/uid/TP40003174-SW7" title="Document-based example"></a><h3>Document-based example</h3><p>The following example illustrates how you could implement a subclass of <code>NSDocumentController</code> to allow your application to open a legacy file format and import the data into a new Core Data store. It assumes three additional methods: <code>openURLForReadingLegacyData:error:</code> to open the legacy file, <code>nextRecord</code> that returns a dictionary containing the data from the next record in the file, and <code>closeLegacyFile</code> to close the legacy file. As a further simplification, it assumes that the legacy file contains data for only one entity.</p><div class="codesample"><table><tr><td scope="row"><pre>NSString *CORE_DATA_DOCUMENT_TYPE = @"CoreDataStoreDocumentType";<span></span></pre></td></tr><tr><td scope="row"><pre>NSString *ENTITY_NAME = @"MyEntity";<span></span></pre></td></tr><tr><td scope="row"><pre>NSUInteger LOOP_LIMIT = 5000;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyDocumentController<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (id)openDocumentWithContentsOfURL:(NSURL *)absoluteURL<span></span></pre></td></tr><tr><td scope="row"><pre>      display:(BOOL)displayDocument error:(NSError **)outError<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *filePath = [absoluteURL relativePath];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *fileExtension = [filePath pathExtension];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *type = [self typeFromFileExtension:fileExtension];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ([type isEqualToString:CORE_DATA_DOCUMENT_TYPE])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        return [super openDocumentWithContentsOfURL:absoluteURL<span></span></pre></td></tr><tr><td scope="row"><pre>                      display:displayDocument error:outError];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL ok = [self openURLForReadingLegacyData:absoluteURL error:outError];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!ok)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *extension = [[self fileExtensionsFromType:CORE_DATA_DOCUMENT_TYPE]<span></span></pre></td></tr><tr><td scope="row"><pre>                                     objectAtIndex:0];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *storePath = [[filePath stringByDeletingPathExtension]<span></span></pre></td></tr><tr><td scope="row"><pre>                                     stringByAppendingPathExtension:extension];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSFileManager *fm = [NSFileManager defaultManager];<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([fm fileExistsAtPath:storePath])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        ok = [fm removeItemAtPath:storePath error:outError];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!ok)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSURL *storeURL = [NSURL fileURLWithPath:storePath];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *modelPath = [[NSBundle mainBundle] pathForResource:@"MyDocument"<span></span></pre></td></tr><tr><td scope="row"><pre>                                                 ofType:@"mom"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSURL *modelURL = [NSURL fileURLWithPath:modelPath];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSManagedObjectModel *model = [[[NSManagedObjectModel alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>            initWithContentsOfURL:modelURL] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSPersistentStoreCoordinator *psc = [[[NSPersistentStoreCoordinator alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>            initWithManagedObjectModel:model] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSPersistentStore *store = [psc addPersistentStoreWithType:NSSQLiteStoreType<span></span></pre></td></tr><tr><td scope="row"><pre>            configuration:nil URL:storeURL options:0 error:outError];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (store == nil)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSManagedObjectContext *importContext = [[NSManagedObjectContext alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    [importContext setPersistentStoreCoordinator:psc];<span></span></pre></td></tr><tr><td scope="row"><pre>    [importContext setUndoManager:nil];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSEntityDescription *entity = [NSEntityDescription entityForName:ENTITY_NAME<span></span></pre></td></tr><tr><td scope="row"><pre>            inManagedObjectContext:importContext];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSUInteger count = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSDictionary *newRecord;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSManagedObject *newMO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while (newRecord = [self nextRecord])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /*<span></span></pre></td></tr><tr><td scope="row"><pre>         It is more efficient to cache the entity and use initWithEntity:<span></span></pre></td></tr><tr><td scope="row"><pre>         insertIntoManagedObjectContext: than to use the typically-more-convenient<span></span></pre></td></tr><tr><td scope="row"><pre>         NSEntityDescription method insertNewObjectForEntityForName:inManagedObjectContext:.<span></span></pre></td></tr><tr><td scope="row"><pre>         It is also more efficient to release the new managed object than it is to add it<span></span></pre></td></tr><tr><td scope="row"><pre>         to the autorelease pool.  It can safely be released here since, because<span></span></pre></td></tr><tr><td scope="row"><pre>         it's a newly-inserted object, the managed object context retains it.<span></span></pre></td></tr><tr><td scope="row"><pre>         */<span></span></pre></td></tr><tr><td scope="row"><pre>        newMO = [[NSManagedObject alloc] initWithEntity:entity<span></span></pre></td></tr><tr><td scope="row"><pre>                       insertIntoManagedObjectContext:importContext];<span></span></pre></td></tr><tr><td scope="row"><pre>;<span></span></pre></td></tr><tr><td scope="row"><pre>        [newMO setValuesForKeysWithDictionary:newRecord];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        [newMO release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        count++;<span></span></pre></td></tr><tr><td scope="row"><pre>        if (count == LOOP_LIMIT)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            ok = [importContext save:outError];<span></span></pre></td></tr><tr><td scope="row"><pre>            if (!ok)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                [importContext release];<span></span></pre></td></tr><tr><td scope="row"><pre>                [pool drain];<span></span></pre></td></tr><tr><td scope="row"><pre>                [self closeLegacyFile];<span></span></pre></td></tr><tr><td scope="row"><pre>                return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            /*<span></span></pre></td></tr><tr><td scope="row"><pre>             reset is not actually needed in this example since we're not creating<span></span></pre></td></tr><tr><td scope="row"><pre>             any relationships but this would be one place to put it if we were<span></span></pre></td></tr><tr><td scope="row"><pre>             [importContext reset];<span></span></pre></td></tr><tr><td scope="row"><pre>             or:<span></span></pre></td></tr><tr><td scope="row"><pre>             for (NSManagedObject* mo in [importContext registeredObjects])<span></span></pre></td></tr><tr><td scope="row"><pre>             {<span></span></pre></td></tr><tr><td scope="row"><pre>                 [importContext refreshObject:mo mergeChanges:NO];<span></span></pre></td></tr><tr><td scope="row"><pre>             }<span></span></pre></td></tr><tr><td scope="row"><pre>             */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            [pool drain];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            pool = [[NSAutoreleasePool alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>            count = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ok = [importContext save:outError];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self closeLegacyFile];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [importContext release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [pool drain];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!ok)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return [super openDocumentWithContentsOfURL:storeURL<span></span></pre></td></tr><tr><td scope="row"><pre>                  display:displayDocument error:outError];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP40003174-SW4" title="Implementing Find-or-Create Efficiently"></a><h2>Implementing Find-or-Create Efficiently</h2><p>A common technique when importing data is to follow a "find-or-create" pattern, where you set up some data from which to create a managed object, determine whether the managed object already exists, and create it if it does not.</p><p>There are many situations where you may need to find existing objects (objects already saved in a store) for a set of discrete input values. A simple solution is to create a loop, then for each value in turn execute a fetch to determine whether there is a matching persisted object and so on. This pattern does not scale well. If you profile your application with this pattern, you typically find the fetch to be one of the more expensive operations in the loop (compared to just iterating over a collection of items). Even worse, this pattern turns an <code>O(n)</code> problem into an <code>O(n^2)</code> problem.</p><p>It is much more efficient—when possible—to create all the managed objects in a single pass, and then fix up any relationships in a second pass. For example, if you import data that you know you does not contain any duplicates (say because your initial data set is empty), you can just create managed objects to represent your data and not do any searches at all. Or if you import "flat" data with no relationships, you can create managed objects for the entire set and weed out (delete) any duplicates before save using a single large <code>IN</code> predicate.</p><p>If you do need to follow a find-or-create pattern—say because you're importing heterogeneous data where relationship information is mixed in with attribute information—you can optimize how you find existing objects by reducing to a minimum the number of fetches you execute. How to accomplish this depends on the amount of reference data you have to work with. If you are importing 100 potential new objects, and only have 2000 in your database, fetching all of the existing and caching them may not represent a significant penalty (especially if you have to perform the operation more than once). However, if you have 100,000 items in your database, the memory pressure of keeping those cached may be prohibitive.</p><p>You can use a combination of an <code>IN</code> predicate and sorting to reduce your use of Core Data to a single fetch request. Suppose, for example, you want to take a list of employee IDs (as strings) and create Employee records for all those not already in the database. Consider this code, where Employee is an entity with a <code>name</code> attribute, and <code>listOfIDsAsString</code> is the list of IDs for which you want to add objects if they do not already exist in a store.</p><p>First, separate and sort the IDs (strings) of interest.</p><div class="codesample"><table><tr><td scope="row"><pre>// get the names to parse in sorted order<span></span></pre></td></tr><tr><td scope="row"><pre>NSArray *employeeIDs = [[listOfIDsAsString componentsSeparatedByString:@"\n"]<span></span></pre></td></tr><tr><td scope="row"><pre>        sortedArrayUsingSelector: @selector(compare:)];<span></span></pre></td></tr></table></div><p>Next, create a predicate using <code>IN</code> with the array of name strings, and a sort descriptor which ensures the results are returned with the same sorting as the array of name strings.  (The <code>IN</code> is equivalent to an SQL <code>IN</code> operation, where the left-hand side must appear in the collection specified by the right-hand side.)</p><div class="codesample"><table><tr><td scope="row"><pre>// create the fetch request to get all Employees matching the IDs<span></span></pre></td></tr><tr><td scope="row"><pre>NSFetchRequest *fetchRequest = [[[NSFetchRequest alloc] init] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>[fetchRequest setEntity:<span></span></pre></td></tr><tr><td scope="row"><pre>        [NSEntityDescription entityForName:@"Employee" inManagedObjectContext:aMOC]];<span></span></pre></td></tr><tr><td scope="row"><pre>[fetchRequest setPredicate: [NSPredicate predicateWithFormat: @"(employeeID IN %@)", employeeIDs]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// make sure the results are sorted as well<span></span></pre></td></tr><tr><td scope="row"><pre>[fetchRequest setSortDescriptors: [NSArray arrayWithObject:<span></span></pre></td></tr><tr><td scope="row"><pre>        [[[NSSortDescriptor alloc] initWithKey: @"employeeID"<span></span></pre></td></tr><tr><td scope="row"><pre>                ascending:YES] autorelease]]];<span></span></pre></td></tr></table></div><p>Finally, execute the fetch.</p><div class="codesample"><table><tr><td scope="row"><pre>NSError *error;<span></span></pre></td></tr><tr><td scope="row"><pre>NSArray *employeesMatchingNames = [aMOC<span></span></pre></td></tr><tr><td scope="row"><pre>        executeFetchRequest:fetchRequest error:&amp;error];<span></span></pre></td></tr></table></div><p>You end up with two sorted arrays—one with the employee IDs passed into the fetch request, and one with the managed objects that matched them. To process them, you walk the sorted lists following these steps:</p><ol class="ol"><li class="li"><p>Get the next ID and Employee. If the ID doesn't match the Employee ID, create a new Employee for that ID.</p></li><li class="li"><p>Get the next Employee: if the IDs match, move to the next ID and Employee.</p></li></ol><p>Regardless of how many IDs you pass in, you only execute a single fetch, and the rest is just walking the result set.</p><p>The listing below shows the complete code for the example in the previous section.</p><div class="codesample"><table><tr><td scope="row"><pre>// get the names to parse in sorted order<span></span></pre></td></tr><tr><td scope="row"><pre>NSArray *employeeIDs = [[listOfIDsAsString componentsSeparatedByString:@"\n"]<span></span></pre></td></tr><tr><td scope="row"><pre>        sortedArrayUsingSelector: @selector(compare:)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// create the fetch request to get all Employees matching the IDs<span></span></pre></td></tr><tr><td scope="row"><pre>NSFetchRequest *fetchRequest = [[[NSFetchRequest alloc] init] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>[fetchRequest setEntity:<span></span></pre></td></tr><tr><td scope="row"><pre>        [NSEntityDescription entityForName:@"Employee" inManagedObjectContext:aMOC]];<span></span></pre></td></tr><tr><td scope="row"><pre>[fetchRequest setPredicate: [NSPredicate predicateWithFormat: @"(employeeID IN %@)", employeeIDs]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// make sure the results are sorted as well<span></span></pre></td></tr><tr><td scope="row"><pre>[fetchRequest setSortDescriptors: [NSArray arrayWithObject:<span></span></pre></td></tr><tr><td scope="row"><pre>        [[[NSSortDescriptor alloc] initWithKey: @"employeeID"<span></span></pre></td></tr><tr><td scope="row"><pre>                ascending:YES] autorelease]]];<span></span></pre></td></tr><tr><td scope="row"><pre>// Execute the fetch<span></span></pre></td></tr><tr><td scope="row"><pre>NSError *error;<span></span></pre></td></tr><tr><td scope="row"><pre>NSArray *employeesMatchingNames = [aMOC<span></span></pre></td></tr><tr><td scope="row"><pre>        executeFetchRequest:fetchRequest error:&amp;error];<span></span></pre></td></tr></table></div>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="cdTroubleshooting.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="cdZ104UsingMOs.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdImporting.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdImporting.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdImporting.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
