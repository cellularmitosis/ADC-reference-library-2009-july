<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=HTML">
<title>IONetworkController</title>
<meta name="generator" content="HeaderDoc">
<style><!--
#tocMenu {
		display: block;
		position:fixed;
		top:0px;
		left:0px;
		width:210px;
		height:100%;
		background:transparent;
}
#bodyText {
		margin-left: 210px;
}
--></style>
<meta id="toc-file" name="toc-file" content="toc.html">
<script language="JavaScript" src="../../../../../../Resources/JavaScript/page.js" type="text/javascript"></script><link rel="stylesheet" type="text/css" href="../../../../../../Resources/CSS/frameset_styles.css">
<style type="text/css"><!--.keyword {background:#ffffff; color:#761550;}.template {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.function {background:#ffffff; color:#000000;}.string {background: #ffffff; color:#891315;}.preprocessor {background:#ffffff; color:#236e25}.comment {background:#ffffff; color:#236e25}.char {background: #ffffff; color:#0000ff;}.var {background:#ffffff; color:#000000;}.type {background:#ffffff; color:#761550;}.param {background:#ffffff; color:#000000;}.graybox {         border-top: 1px solid #919699;         border-left: 1px solid #919699;         margin-bottom: 10px;         }  .graybox th {         padding: 4px 8px 4px 8px;         background: #E2E2E2;         font-size: 12px;         font-weight: bold;         border-bottom: 1px solid #919699;         border-right: 1px solid #919699;         }  .graybox td {         padding: 8px;         font-size: 12px;         text-align: left;         vertical-align: top;         border-bottom: 1px solid #919699;         border-right: 1px solid #919699;         }  --></style>
</head>
<body bgcolor="#ffffff" onload="initialize_page();">
<noscript>
<div id="tocMenu">
<iframe id="toc_content" name="toc_content" src="toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
</div>
</noscript>
<div id="bodyText">
<!-- start of header -->

<!-- start of header -->
<!--#include virtual="/includes/framesetheader"-->
<!-- end of header -->

<table width="600"><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <a href="../../../../../../../reference/HardwareDrivers/index.html#//apple_ref/doc/uid/TP30001281-TP40003576" target="_top">Hardware & Drivers</a> <b>&gt;</b> <a href="../../../index.html#//apple_ref/doc/framework/iokit_fw" target="_top">I/O Kit Framework Reference</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header --><a name="top"></a>
<hr>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h1><a name="IONetworkController">IONetworkController</a></h1>
</td></tr></table>
<div class="spec_sheet_info_box"><table cellspacing="0" class="specbox">
<tr>
<td scope="row"><b>Inherits from:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text">
<a href="../../../../KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top">IOService</a>
</div></div></td>
</tr>
<tr>
<td scope="row"><b>Declared In:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text"><a href="../../index.html" target="_top">IONetworkController.h</a></div></div></td>
</tr>
</table></div>
<h2>Overview</h2>
<p><!-- begin abstract --></p>
<p>Implements the framework for a generic 
network controller.
<!-- end abstract --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A subclass of IONetworkController must provide
additional functionality specific for a particular networking type.
In addition, the driver must implement (override) a basic set of 
hardware dependent methods to create a working driver.
</p>
<p>IONetworkController attaches itself to the data link layer (DLIL) via
an IONetworkInterface object. A controller object without a companion
interface is not accessible to the networking system. The controller
interacts with DLIL by calling methods defined by the interface object.
And conversely, DLIL will issue commands and packets to the controller
through the interface object.
</p>
<p>IONetworkController will create an IOCommandGate and attach this
event source to an IOWorkLoop object. All commands sent from the
interface object are handled through the IOCommandGate object,
which will serialize access to the controller. Outbound packets sent
from the interface to the controller have no implicit serialization. 
Drivers must implement an output function that is thread safe, or use
an IOOutputQueue object which will provide a serialization model.
</p>
<p>Note: IONetworkController internally uses some private messaging constants
in the sys_iokit | sub_iokit_networking range defined in 
"IONetworkControllerPrivate.h".	If you create a client for your controller
(for example an IOUserClient), and it overrides the IOService::message 
method, your client may receive these messages.  It should ignore these 
messages and pass them to super::message() 	
<!-- end discussion -->
</p>
<hr>
<br><h2>Functions</h2>
<a name="HeaderDoc_functions"></a>
<dl>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/allocatePacket/mbuf_t/(UInt32)" target="_top">allocatePacket</a></tt></dt>
<dd><p>Allocates a packet with a data buffer that is larger than
or equal to the size specified.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/attachDebuggerClient/bool/(IOKernelDebugger**)" target="_top">attachDebuggerClient</a></tt></dt>
<dd><p>Attaches a new IOKernelDebugger client object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/attachInterface/bool/(IONetworkInterface**,bool)" target="_top">attachInterface</a></tt></dt>
<dd><p>Attaches a new interface client object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/configureInterface/bool/(IONetworkInterface*)" target="_top">configureInterface</a></tt></dt>
<dd><p>Configures a newly created network interface object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/copyMediumDictionary/OSDictionary*/()" target="_top">copyMediumDictionary</a></tt></dt>
<dd><p>Returns a copy of the medium dictionary published by the
driver.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/copyPacket/mbuf_t/(constmbuf_t,UInt32)" target="_top">copyPacket</a></tt></dt>
<dd><p>Allocates a new packet, containing data copied from an
existing source packet.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/createInterface/IONetworkInterface*/()" target="_top">createInterface</a></tt></dt>
<dd><p>Creates a new network interface object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/createOutputQueue/IOOutputQueue*/()" target="_top">createOutputQueue</a></tt></dt>
<dd><p>Creates an IOOutputQueue to handle output packet queueing,
and also to resolve contention for the controller's transmitter from
multiple client threads.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/createWorkLoop/bool/()" target="_top">createWorkLoop</a></tt></dt>
<dd><p>Method called by IONetworkController prior to the initial
getWorkLoop() call.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/detachDebuggerClient/void/(IOKernelDebugger*)" target="_top">detachDebuggerClient</a></tt></dt>
<dd><p>Detaches an IOKernelDebugger client object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/detachInterface/void/(IONetworkInterface*,bool)" target="_top">detachInterface</a></tt></dt>
<dd><p>Detaches an interface client object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/disable/IOReturn/(IOKernelDebugger*)" target="_top">disable</a></tt></dt>
<dd><p>A disable request from an IOKernelDebugger client.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/disable/IOReturn/(IONetworkInterface*)" target="_top">disable(IONetworkInterface *)</a></tt></dt>
<dd><p>A request from an interface client to disable the controller.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/disable/IOReturn/(IOService*)" target="_top">disable(IOService *)</a></tt></dt>
<dd><p>Handles a disable request from a client.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/disablePacketFilter/IOReturn/(constOSSymbol*,UInt32,UInt32,IOOptionBits)" target="_top">disablePacketFilter</a></tt></dt>
<dd><p>Disables a packet filter that is currently enabled from the
given filter group.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/doDisable/IOReturn/(IOService*)" target="_top">doDisable</a></tt></dt>
<dd><p>Makes a synchronized call to disable() through executeCommand().
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/doEnable/IOReturn/(IOService*)" target="_top">doEnable</a></tt></dt>
<dd><p>Makes a synchronized call to enable() through executeCommand().
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/enable/IOReturn/(IOKernelDebugger*)" target="_top">enable</a></tt></dt>
<dd><p>An enable request from an IOKernelDebugger client.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/enable/IOReturn/(IONetworkInterface*)" target="_top">enable(IONetworkInterface *)</a></tt></dt>
<dd><p>A request from an interface client to enable the controller.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/enable/IOReturn/(IOService*)" target="_top">enable(IOService *)</a></tt></dt>
<dd><p>Handles an enable request from a client.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/enablePacketFilter/IOReturn/(constOSSymbol*,UInt32,UInt32,IOOptionBits)" target="_top">enablePacketFilter</a></tt></dt>
<dd><p>Enables one of the supported packet filters from the
given filter group.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/executeCommand/IOReturn/(OSObject*,Action,void*,void*,void*,void*,void*)" target="_top">executeCommand</a></tt></dt>
<dd><p>Makes a C function call through the command gate.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/free/void/()" target="_top">free</a></tt></dt>
<dd><p>Frees the IONetworkController object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/freePacket/void/(mbuf_t,IOOptionBits)" target="_top">freePacket</a></tt></dt>
<dd><p>Releases the packet given back to the free pool.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getChecksumDemand/void/(constmbuf_t,UInt32,UInt32*,void*,void*)" target="_top">getChecksumDemand</a></tt></dt>
<dd><p>Fetches the demand for hardware checksum computation and insertion
for the given packet before it is transmitted on the network.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getChecksumSupport/IOReturn/(UInt32*,UInt32,bool)" target="_top">getChecksumSupport</a></tt></dt>
<dd><p>Gets checksums that are supported by the network controller for
the given checksum family.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getCommandClient/OSObject*/()" target="_top">getCommandClient</a></tt></dt>
<dd><p>Gets the command client object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getCommandGate/IOCommandGate*/()" target="_top">getCommandGate</a></tt></dt>
<dd><p>Gets the IOCommandGate object created by IONetworkController.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getFeatures/UInt32/()" target="_top">getFeatures</a></tt></dt>
<dd><p>Reports generic features supported by the controller and/or
the driver.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getHardwareAddress/IOReturn/(void*,UInt32*)" target="_top">getHardwareAddress</a></tt></dt>
<dd><p>Gets the network controller's permanent hardware/station
address. 
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getMaxPacketSize/IOReturn/(UInt32*)" target="_top">getMaxPacketSize</a></tt></dt>
<dd><p>Gets the maximum packet size supported by the controller.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getMediumDictionary/constOSDictionary*/()" target="_top">getMediumDictionary</a></tt></dt>
<dd><p>Returns the medium dictionary published by the driver.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getMinPacketSize/IOReturn/(UInt32*)" target="_top">getMinPacketSize</a></tt></dt>
<dd><p>Gets the minimum packet size supported by the controller.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getOutputHandler/IOOutputAction/()" target="_top">getOutputHandler</a></tt></dt>
<dd><p>Gets the address of the method designated to handle output 
packets for the network controller.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getOutputQueue/IOOutputQueue*/()" target="_top">getOutputQueue</a></tt></dt>
<dd><p>Gets the IOOutputQueue object created by createOutputQueue().
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getPacketBufferConstraints/void/(IOPacketBufferConstraints*)" target="_top">getPacketBufferConstraints</a></tt></dt>
<dd><p>Gets the controller's packet buffer constraints.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getPacketFilters/IOReturn/(constOSSymbol*,UInt32*)" target="_top">getPacketFilters</a></tt></dt>
<dd><p>Gets the set of packet filters supported by the network 
controller for the given filter group.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/getSelectedMedium/constIONetworkMedium*/()" target="_top">getSelectedMedium</a></tt></dt>
<dd><p>Gets the current selected medium.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/handleClose/void/(IOService*,IOOptionBits)" target="_top">handleClose</a></tt></dt>
<dd><p>Handles a client close.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/handleIsOpen/bool/(constIOService*)" target="_top">handleIsOpen</a></tt></dt>
<dd><p>Queries whether a client has an open on the controller.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/handleOpen/bool/(IOService*,IOOptionBits,void*)" target="_top">handleOpen</a></tt></dt>
<dd><p>Handles a client open.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/init/bool/(OSDictionary*)" target="_top">init</a></tt></dt>
<dd><p>Initializes the IONetworkController object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/newModelString/constOSString*/()" target="_top">newModelString</a></tt></dt>
<dd></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/newRevisionString/constOSString*/()" target="_top">newRevisionString</a></tt></dt>
<dd></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/newVendorString/constOSString*/()" target="_top">newVendorString</a></tt></dt>
<dd></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/outputPacket/UInt32/(mbuf_t,void*)" target="_top">outputPacket</a></tt></dt>
<dd><p>Transmits an output packet.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/prepare/IOReturn/()" target="_top">prepare</a></tt></dt>
<dd><p>Prepares the controller before an IOService is created and
attached as a client.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/publishMediumDictionary/bool/(constOSDictionary*)" target="_top">publishMediumDictionary</a></tt></dt>
<dd><p>Publishes a dictionary of IONetworkMedium objects to
advertise the media selection supported by the network controller.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/publishProperties/bool/()" target="_top">publishProperties</a></tt></dt>
<dd><p>Publishes controller properties and capabilities.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/receivePacket/void/(void*,UInt32*,UInt32)" target="_top">receivePacket</a></tt></dt>
<dd><p>Debugger polled-mode receive handler.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/registerWithPolicyMaker/IOReturn/(IOService*)" target="_top">registerWithPolicyMaker</a></tt></dt>
<dd><p>Implemented by controller drivers to register with
the power management policy-maker.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/releaseDebuggerLock/void/()" target="_top">releaseDebuggerLock</a></tt></dt>
<dd><p>Releases the global debugger lock.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/releaseFreePackets/UInt32/()" target="_top">releaseFreePackets</a></tt></dt>
<dd><p>Releases all packets held in the free packet queue.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/replaceOrCopyPacket/mbuf_t/(mbuf_t*,UInt32,bool*)" target="_top">replaceOrCopyPacket</a></tt></dt>
<dd><p>A helper method that combines the functionality of
copyPacket() and replacePacket() to process a packet containing
a received frame.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/replacePacket/mbuf_t/(mbuf_t*,UInt32)" target="_top">replacePacket</a></tt></dt>
<dd><p>Allocates a new packet to replace an existing packet, the
existing packet is then returned.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/reserveDebuggerLock/void/()" target="_top">reserveDebuggerLock</a></tt></dt>
<dd><p>Takes the global debugger lock.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/selectMedium/IOReturn/(constIONetworkMedium*)" target="_top">selectMedium</a></tt></dt>
<dd><p>A client request to change the medium selection.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/selectMediumWithName/IOReturn/(constOSSymbol*)" target="_top">selectMediumWithName</a></tt></dt>
<dd><p>A client request to change the medium selection.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/sendPacket/void/(void*,UInt32)" target="_top">sendPacket</a></tt></dt>
<dd><p>Debugger polled-mode transmit handler.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/setChecksumResult/bool/(mbuf_t,UInt32,UInt32,UInt32,UInt32,UInt32)" target="_top">setChecksumResult</a></tt></dt>
<dd><p>Encodes a received packet with the checksum result reported
by the hardware.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/setHardwareAddress/IOReturn/(constvoid*,UInt32)" target="_top">setHardwareAddress</a></tt></dt>
<dd><p>Sets or changes the station address used by the network
controller. 
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/setLinkStatus/bool/(UInt32,constIONetworkMedium*,UInt64,OSData*)" target="_top">setLinkStatus</a></tt></dt>
<dd><p>Reports the link status and the active medium.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/setMaxPacketSize/IOReturn/(UInt32)" target="_top">setMaxPacketSize</a></tt></dt>
<dd><p>A client request to change the maximum packet size.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/setSelectedMedium/bool/(constIONetworkMedium*)" target="_top">setSelectedMedium</a></tt></dt>
<dd><p>Designates an entry in the published medium dictionary as
the current selected medium.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/start/bool/(IOService*)" target="_top">start</a></tt></dt>
<dd><p>Starts the network controller.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IONetworkController/stop/void/(IOService*)" target="_top">stop</a></tt></dt>
<dd><p>Stops the network controller.
</p></dd>
</dl>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/allocatePacket/mbuf_t/(UInt32);   name=IONetworkController::allocatePacket --><a name="//apple_ref/cpp/instm/IONetworkController/allocatePacket/mbuf_t/(UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="allocatePacket">allocatePacket</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Allocates a packet with a data buffer that is larger than
or equal to the size specified.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">mbuf_t</span><!-- /a --> <!-- a --><span class="function">allocatePacket</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">size</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>size</code></dt>
<dd><p>The minimum size of the data buffer for the mbuf
packet allocated.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns an mbuf packet, or 0 if allocation failed. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method will always return a single mbuf unless the
size requested (plus the alignment padding) is greater than MCLBYTES.
The data buffer for the mbuf (or an mbuf chain) returned is aligned
according to the constraints reported by getPacketBufferConstraints().
The length fields in each mbuf returned are set by this method, thus
allowing the mbuf to be passed directly to an IOMbufMemoryCursor object
in order to convert the mbuf to a physical address scatter-gather list.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/attachDebuggerClient/bool/(IOKernelDebugger**);   name=IONetworkController::attachDebuggerClient --><a name="//apple_ref/cpp/instm/IONetworkController/attachDebuggerClient/bool/(IOKernelDebugger**)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="attachDebuggerClient">attachDebuggerClient</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Attaches a new IOKernelDebugger client object.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">attachDebuggerClient</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOKernelDebugger_h/Classes/IOKernelDebugger/index.html#//apple_ref/cpp/cl/IOKernelDebugger" target="_top" class="type"><span class="type">IOKernelDebugger</span></a> <span class="type">*</span><span class="type">*</span><span class="param">debuggerP</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>debuggerP</code></dt>
<dd><p>A handle that will return the new
IOKernelDebugger object created.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true on success, false otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method allocates an IOKernelDebugger object and attaches it as
a client. Having a debugger client implies that the controller
supports kernel debugging, and therefore must implement the two
polled-mode methods that are called by the debugger client. See
sendPacket() and receivePacket(). Only a single debugger client
should be attached to each controller.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/attachInterface/bool/(IONetworkInterface**,bool);   name=IONetworkController::attachInterface --><a name="//apple_ref/cpp/instm/IONetworkController/attachInterface/bool/(IONetworkInterface**,bool)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="attachInterface">attachInterface</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Attaches a new interface client object.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">attachInterface</span><!-- /a -->(
    <a href="../../../IONetworkInterface_h/Classes/IONetworkInterface/index.html#//apple_ref/cpp/cl/IONetworkInterface" target="_top" class="type"><span class="type">IONetworkInterface</span></a> <span class="type">*</span><span class="type">*</span><span class="param">interface</span>, 
    <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="type">doRegister</span><!-- /a --> = <span class="keyword">true</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>interface</code></dt>
<dd><p>Upon success (return value is true), the
interface object will be written to the handle provided.</p></dd>
<dt><code>doRegister</code></dt>
<dd><p>If true, then registerService() is called to register
the interface, which will trigger the matching process, and will ultimately
cause the interface to become registered with the data link layer.
Drivers that wish to delay the registration can set doRegister to false,
and call registerService() on the interface object when the controller
becomes ready. This allows the driver to attach an interface without
making its services available to the rest of the system.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true on success, false otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method creates a new interface object and attaches it to the
controller. The createInterface() method is called to perform
the interface allocation and initialization, followed by a call to 
configureInterface() to configure it. Subclasses can override those
two methods to customize the interface client attached. Drivers will
usually call this method from start(), after they are ready to process
client requests. Since most drivers will have a single interface
client, this method will likely be called only once.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/configureInterface/bool/(IONetworkInterface*);   name=IONetworkController::configureInterface --><a name="//apple_ref/cpp/instm/IONetworkController/configureInterface/bool/(IONetworkInterface*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="configureInterface">configureInterface</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Configures a newly created network interface object.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">configureInterface</span><!-- /a -->(
    <a href="../../../IONetworkInterface_h/Classes/IONetworkInterface/index.html#//apple_ref/cpp/cl/IONetworkInterface" target="_top" class="type"><span class="type">IONetworkInterface</span></a> <span class="type">*</span><span class="param">interface</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>interface</code></dt>
<dd><p>The interface object to be configured.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if the operation was successful, false otherwise
(this will cause attachInterface() to fail and return 0). 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method configures an interface object that was created by
createInterface(). Subclasses can override this method to customize
and examine the interface object that will be attached to the
controller as a client.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/copyMediumDictionary/OSDictionary*/();   name=IONetworkController::copyMediumDictionary --><a name="//apple_ref/cpp/instm/IONetworkController/copyMediumDictionary/OSDictionary*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="copyMediumDictionary">copyMediumDictionary</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns a copy of the medium dictionary published by the
driver.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../KernelIOKitFramework/OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span> <!-- a --><span class="function">copyMediumDictionary</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns a copy of the medium dictionary, or 0 if the driver has not
published a medium dictionary through publishMediumDictionary().

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The caller is responsible for releasing the dictionary
object returned. Use getMediumDictionary() to get a reference to the
published medium dictionary instead of creating a copy.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/copyPacket/mbuf_t/(constmbuf_t,UInt32);   name=IONetworkController::copyPacket --><a name="//apple_ref/cpp/instm/IONetworkController/copyPacket/mbuf_t/(constmbuf_t,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="copyPacket">copyPacket</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Allocates a new packet, containing data copied from an
existing source packet.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">mbuf_t</span><!-- /a --> <!-- a --><span class="function">copyPacket</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">mbuf_t</span><!-- /a --> <!-- a --><span class="var">m</span><!-- /a -->,
    <!-- a --><span class="var">UInt32</span><!-- /a --> <!-- a --><span class="var">size</span><!-- /a --> = <span class="number">0</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>m</code></dt>
<dd><p>The source packet.</p></dd>
<dt><code>size</code></dt>
<dd><p>The number of bytes to copy. If set to 0, then the
entire data buffer from the source packet is copied.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns a new packet containing the same data as the source packet. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The source packet is not modified by this method.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/createInterface/IONetworkInterface*/();   name=IONetworkController::createInterface --><a name="//apple_ref/cpp/instm/IONetworkController/createInterface/IONetworkInterface*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="createInterface">createInterface</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates a new network interface object.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../IONetworkInterface_h/Classes/IONetworkInterface/index.html#//apple_ref/cpp/cl/IONetworkInterface" target="_top" class="type"><span class="type">IONetworkInterface</span></a> <span class="type">*</span> <!-- a --><span class="function">createInterface</span><!-- /a -->() = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns a newly allocated and initialized interface object. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method is called by attachInterface() to perform
allocation and initialization of a new interface object. A subclass of
IONetworkController must implement this method and return a matching
interface object. For example, IOEthernetController's implementation
will return an IOEthernetInterface object when createInterface() is
called.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/createOutputQueue/IOOutputQueue*/();   name=IONetworkController::createOutputQueue --><a name="//apple_ref/cpp/instm/IONetworkController/createOutputQueue/IOOutputQueue*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="createOutputQueue">createOutputQueue</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates an IOOutputQueue to handle output packet queueing,
and also to resolve contention for the controller's transmitter from
multiple client threads.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../../KernelIOKitFramework/IOOutputQueue_h/Classes/IOOutputQueue/index.html#//apple_ref/cpp/cl/IOOutputQueue" target="_top" class="type"><span class="type">IOOutputQueue</span></a> <span class="type">*</span> <!-- a --><span class="function">createOutputQueue</span><!-- /a -->(); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns a newly allocated and initialized IOOutputQueue object. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method is called by start() to create an IOOutputQueue object to
handle output packet queueing. The default implementation will always
return 0, hence no output queue will be created. A driver may override
this method and return a subclass of IOOutputQueue. IONetworkController
will keep a reference to the queue created, and will release this
object when IONetworkController is freed. Also see getOutputQueue().
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/createWorkLoop/bool/();   name=IONetworkController::createWorkLoop --><a name="//apple_ref/cpp/instm/IONetworkController/createWorkLoop/bool/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="createWorkLoop">createWorkLoop</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Method called by IONetworkController prior to the initial
getWorkLoop() call.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">createWorkLoop</span><!-- /a -->(); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true to indicate success, false otherwise. Returning false
will fail IONetworkController::start(). 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Before IONetworkController calls getWorkLoop() in its
start() method, it will call createWorkLoop() to make sure that a
subclass that wants to create a workloop, will do so before its
first use.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/detachDebuggerClient/void/(IOKernelDebugger*);   name=IONetworkController::detachDebuggerClient --><a name="//apple_ref/cpp/instm/IONetworkController/detachDebuggerClient/void/(IOKernelDebugger*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="detachDebuggerClient">detachDebuggerClient</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Detaches an IOKernelDebugger client object.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">detachDebuggerClient</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOKernelDebugger_h/Classes/IOKernelDebugger/index.html#//apple_ref/cpp/cl/IOKernelDebugger" target="_top" class="type"><span class="type">IOKernelDebugger</span></a> <span class="type">*</span><span class="param">debugger</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>debugger</code></dt>
<dd><p>The IOKernelDebugger object to be detached and
terminated. If the argument provided is NULL or is not an
IOKernelDebugger, this method will return immediately.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method detaches and terminates the IOKernelDebugger client object
provided. A synchronous termination is issued, and this method will
return after the debugger client has been terminated. The debugger
client should be released following this call.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/detachInterface/void/(IONetworkInterface*,bool);   name=IONetworkController::detachInterface --><a name="//apple_ref/cpp/instm/IONetworkController/detachInterface/void/(IONetworkInterface*,bool)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="detachInterface">detachInterface</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Detaches an interface client object.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">detachInterface</span><!-- /a -->(
    <a href="../../../IONetworkInterface_h/Classes/IONetworkInterface/index.html#//apple_ref/cpp/cl/IONetworkInterface" target="_top" class="type"><span class="type">IONetworkInterface</span></a> <span class="type">*</span><span class="param">interface</span>, 
    <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="type">sync</span><!-- /a --> = <span class="keyword">false</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>interface</code></dt>
<dd><p>An interface object to be detached and terminated.</p></dd>
<dt><code>sync</code></dt>
<dd><p>If true, the interface is terminated synchronously.
This may cause this method to block for an indeterminate
amount of time.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method will verify that the object provided is indeed
an IONetworkInterface instance, and then call its terminate() method.
Note that an interface object will close and detach from its 
controller after the data link layer has removed all references to 
all data structures exposed by the interface. The interface object
should be released following this call.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/disable/IOReturn/(IOKernelDebugger*);   name=IONetworkController::disable --><a name="//apple_ref/cpp/instm/IONetworkController/disable/IOReturn/(IOKernelDebugger*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="disable">disable</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>A disable request from an IOKernelDebugger client.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">disable</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOKernelDebugger_h/Classes/IOKernelDebugger/index.html#//apple_ref/cpp/cl/IOKernelDebugger" target="_top" class="type"><span class="type">IOKernelDebugger</span></a> <span class="type">*</span><span class="param">debugger</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>debugger</code></dt>
<dd><p>The IOKernelDebugger client requesting the disable.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnSuccess. Drivers must return kIOReturnSuccess
on success, or an error otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Drivers that provide debugging support may either override
this method to disable support for the polled-mode send and receive
methods, or override the base enable() and disable() methods that
take an IOService argument.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/disable/IOReturn/(IONetworkInterface*);   name=IONetworkController::disable --><a name="//apple_ref/cpp/instm/IONetworkController/disable/IOReturn/(IONetworkInterface*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="disable(IONetworkInterface*)">disable(IONetworkInterface *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>A request from an interface client to disable the controller.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">disable</span><!-- /a -->(
    <a href="../../../IONetworkInterface_h/Classes/IONetworkInterface/index.html#//apple_ref/cpp/cl/IONetworkInterface" target="_top" class="type"><span class="type">IONetworkInterface</span></a> <span class="type">*</span><span class="param">interface</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>interface</code></dt>
<dd><p>The interface object that requested the disable.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->kIOReturnUnsupported. Drivers that override this method must
return Returns kIOReturnSuccess on success, or an error code otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method is called by an interface client to disable the controller.
This method should stop the hardware and disable hardware interrupt
sources. Any resources allocated by enable() should also be deallocated.
This method call is synchronized by the workloop's gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/disable/IOReturn/(IOService*);   name=IONetworkController::disable --><a name="//apple_ref/cpp/instm/IONetworkController/disable/IOReturn/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="disable(IOService*)">disable(IOService *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Handles a disable request from a client.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">disable</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">client</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>client</code></dt>
<dd><p>The client object requesting the disable.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the return from the overloaded disable() method, or
kIOReturnBadArgument if the client type is unknown.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method handles a disable request from a client. A client will call
disable if it has previously enabled the controller, and it no longer
needs to transport packets or perform I/O using the controller.
The client object is typecasted using OSDynamicCast, and depending on
whether the client is an IOKernelDebugger or an IONetworkInterface,
then an overloaded disable method that takes a more specific argument
type is called. If the client matches neither type, then
kIOReturnBadArgument is returned. A driver has the option of overriding
this base disable method, or the overloaded form. This method call is
synchronized by the workloop's gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/disablePacketFilter/IOReturn/(constOSSymbol*,UInt32,UInt32,IOOptionBits);   name=IONetworkController::disablePacketFilter --><a name="//apple_ref/cpp/instm/IONetworkController/disablePacketFilter/IOReturn/(constOSSymbol*,UInt32,UInt32,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="disablePacketFilter">disablePacketFilter</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Disables a packet filter that is currently enabled from the
given filter group.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">disablePacketFilter</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">group</span><!-- /a -->, 
    <!-- a --><span class="var">UInt32</span><!-- /a --> <!-- a --><span class="var">aFilter</span><!-- /a -->, 
    <!-- a --><span class="var">UInt32</span><!-- /a --> <!-- a --><span class="var">enabledFilters</span><!-- /a -->, 
    <!-- a --><span class="var">IOOptionBits</span><!-- /a --> <!-- a --><span class="var">options</span><!-- /a --> = <span class="number">0</span>) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>group</code></dt>
<dd><p>The name of the filter group containing the filter to be
disabled.</p></dd>
<dt><code>aFilter</code></dt>
<dd><p>The filter to disable.</p></dd>
<dt><code>enabledFilters</code></dt>
<dd><p>All filters currently enabled by the client.</p></dd>
<dt><code>options</code></dt>
<dd><p>Optional flags for the disable request.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnSuccess on success, or an error otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>After a supported filter has been successfully enabled,
a client can call this method to disable that filter. This method call
is synchronized by the workloop's gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/doDisable/IOReturn/(IOService*);   name=IONetworkController::doDisable --><a name="//apple_ref/cpp/instm/IONetworkController/doDisable/IOReturn/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="doDisable">doDisable</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Makes a synchronized call to disable() through executeCommand().
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">doDisable</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">client</span>); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Do not use this method, it may be removed in the future.
See disable(). 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/doEnable/IOReturn/(IOService*);   name=IONetworkController::doEnable --><a name="//apple_ref/cpp/instm/IONetworkController/doEnable/IOReturn/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="doEnable">doEnable</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Makes a synchronized call to enable() through executeCommand().
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">doEnable</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">client</span>); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Do not use this method, it may be removed in the future.
See enable(). 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/enable/IOReturn/(IOKernelDebugger*);   name=IONetworkController::enable --><a name="//apple_ref/cpp/instm/IONetworkController/enable/IOReturn/(IOKernelDebugger*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="enable">enable</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>An enable request from an IOKernelDebugger client.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">enable</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOKernelDebugger_h/Classes/IOKernelDebugger/index.html#//apple_ref/cpp/cl/IOKernelDebugger" target="_top" class="type"><span class="type">IOKernelDebugger</span></a> <span class="type">*</span><span class="param">debugger</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>debugger</code></dt>
<dd><p>The IOKernelDebugger client requesting the enable.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnSuccess. Drivers must return kIOReturnSuccess
on success, or an error otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Drivers that provide debugging support may either override
this method and set up the hardware to support the polled-mode send and
receive methods, receivePacket() and sendPacket(), or override the base
enable() and disable() methods that take an IOService argument.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/enable/IOReturn/(IONetworkInterface*);   name=IONetworkController::enable --><a name="//apple_ref/cpp/instm/IONetworkController/enable/IOReturn/(IONetworkInterface*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="enable(IONetworkInterface*)">enable(IONetworkInterface *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>A request from an interface client to enable the controller.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">enable</span><!-- /a -->(
    <a href="../../../IONetworkInterface_h/Classes/IONetworkInterface/index.html#//apple_ref/cpp/cl/IONetworkInterface" target="_top" class="type"><span class="type">IONetworkInterface</span></a> <span class="type">*</span><span class="param">interface</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>interface</code></dt>
<dd><p>The interface client object that requested the enable.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnUnsupported. Drivers that override this method must
return kIOReturnSuccess on success, or an error code otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method is called by an interface client to enable the controller.
Upon receiving this command, the controller driver must bring up the
hardware and become ready to transmit and receive packets. A driver
should also delay the allocation of most runtime resources until this
method is called in order to conserve system resources. This method call
is synchronized by the workloop's gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/enable/IOReturn/(IOService*);   name=IONetworkController::enable --><a name="//apple_ref/cpp/instm/IONetworkController/enable/IOReturn/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="enable(IOService*)">enable(IOService *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Handles an enable request from a client.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">enable</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">client</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>client</code></dt>
<dd><p>The client object requesting the enable.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the return value from the overloaded enable() method, or
kIOReturnBadArgument if the client type is unknown. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method handles an enable request from a client. A client will call
enable after it has opened the controller, and before it starts to use
the controller to send and to receive packets over the network. The
client object provided is typecasted using OSDynamicCast, and depending
on whether the client is an IOKernelDebugger or an IONetworkInterface,
then an overloaded enable method that takes a more specific argument
type is called. If the client matches neither type, then
kIOReturnBadArgument is returned. A driver has the option of overriding
this base enable method, or the overloaded form. This method call is
synchronized by the workloop's gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/enablePacketFilter/IOReturn/(constOSSymbol*,UInt32,UInt32,IOOptionBits);   name=IONetworkController::enablePacketFilter --><a name="//apple_ref/cpp/instm/IONetworkController/enablePacketFilter/IOReturn/(constOSSymbol*,UInt32,UInt32,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="enablePacketFilter">enablePacketFilter</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Enables one of the supported packet filters from the
given filter group.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">enablePacketFilter</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">group</span><!-- /a -->, 
    <!-- a --><span class="var">UInt32</span><!-- /a --> <!-- a --><span class="var">aFilter</span><!-- /a -->, 
    <!-- a --><span class="var">UInt32</span><!-- /a --> <!-- a --><span class="var">enabledFilters</span><!-- /a -->, 
    <!-- a --><span class="var">IOOptionBits</span><!-- /a --> <!-- a --><span class="var">options</span><!-- /a --> = <span class="number">0</span>) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>group</code></dt>
<dd><p>The name of the filter group containing the filter to be
enabled.</p></dd>
<dt><code>aFilter</code></dt>
<dd><p>The filter to enable.</p></dd>
<dt><code>enabledFilters</code></dt>
<dd><p>All filters currently enabled by the client.</p></dd>
<dt><code>options</code></dt>
<dd><p>Optional flags for the enable request.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnSuccess on success, or an error otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A client will call this method to enable a supported filter
from the filter group specified. If the client wishes to enable more
than one filter, it must call this method multiple times to enable the
desired set of filters. This method call is synchronized by the
workloop's gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/executeCommand/IOReturn/(OSObject*,Action,void*,void*,void*,void*,void*);   name=IONetworkController::executeCommand --><a name="//apple_ref/cpp/instm/IONetworkController/executeCommand/IOReturn/(OSObject*,Action,void*,void*,void*,void*,void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="executeCommand">executeCommand</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Makes a C function call through the command gate.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">executeCommand</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/OSObject_h/Classes/OSObject/index.html#//apple_ref/cpp/cl/OSObject" target="_top" class="type"><span class="type">OSObject</span></a> <span class="type">*</span><span class="param">client</span>, 
    <!-- a --><span class="type">Action</span><!-- /a --> <span class="param">action</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">target</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">param0</span><!-- /a --> = <span class="number">0</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">param1</span><!-- /a --> = <span class="number">0</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">param2</span><!-- /a --> = <span class="number">0</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">param3</span><!-- /a --> = <span class="number">0</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>client</code></dt>
<dd><p>The client requesting the action. This parameter is not
passed to the function.</p></dd>
<dt><code>action</code></dt>
<dd><p>Pointer to a C function to be executed.</p></dd>
<dt><code>target</code></dt>
<dd><p>The first parameter in the action callout.</p></dd>
<dt><code>param0</code></dt>
<dd><p>Action parameter 0.</p></dd>
<dt><code>param1</code></dt>
<dd><p>Action parameter 1.</p></dd>
<dt><code>param2</code></dt>
<dd><p>Action parameter 2.</p></dd>
<dt><code>param3</code></dt>
<dd><p>Action parameter 3.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the value returned by the action. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method makes a call to a C function that will be synchronized 
with the workloop thread, and any other threads that are called
with the workloop's gate closed.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/free/void/();   name=IONetworkController::free --><a name="//apple_ref/cpp/instm/IONetworkController/free/void/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="free">free</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Frees the IONetworkController object.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">free</span><!-- /a -->(); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Frees the IONetworkController object by releasing all
allocated resources, followed by a call to super::free(). 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/freePacket/void/(mbuf_t,IOOptionBits);   name=IONetworkController::freePacket --><a name="//apple_ref/cpp/instm/IONetworkController/freePacket/void/(mbuf_t,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="freePacket">freePacket</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Releases the packet given back to the free pool.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">freePacket</span><!-- /a -->(
    <span class="param">mbuf_t</span>,
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <!-- a --><span class="type">options</span><!-- /a --> = <span class="number">0</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>m</code></dt>
<dd><p>The packet to be freed.</p></dd>
<dt><code>options</code></dt>
<dd><p>When kDelayFree option is set, then the packet
provided to this function will be queued on the free packet queue.
A subsequent call to releaseFreePackets() will release all queued
packets by making a single BSD function call. Without the kDelayFree
option, the packet provided will be released immediately.</p></dd>
</dl>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getChecksumDemand/void/(constmbuf_t,UInt32,UInt32*,void*,void*);   name=IONetworkController::getChecksumDemand --><a name="//apple_ref/cpp/instm/IONetworkController/getChecksumDemand/void/(constmbuf_t,UInt32,UInt32*,void*,void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getChecksumDemand">getChecksumDemand</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Fetches the demand for hardware checksum computation and insertion
for the given packet before it is transmitted on the network.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">getChecksumDemand</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">mbuf_t</span><!-- /a --> <!-- a --><span class="var">packet</span><!-- /a -->, 
    <!-- a --><span class="var">UInt32</span><!-- /a --> <!-- a --><span class="var">checksumFamily</span><!-- /a -->, 
    <!-- a --><span class="var">UInt32</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">demandMask</span><!-- /a -->, 
    <!-- a --><span class="var">void</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">param0</span><!-- /a --> = <span class="number">0</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">param1</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>packet</code></dt>
<dd><p>An mbuf containing a packet that may be missing one or more
checksums in the specified checksum family.</p></dd>
<dt><code>checksumFamily</code></dt>
<dd><p>A value that specifies the checksum family.</p></dd>
<dt><code>demandMask</code></dt>
<dd><p>A mask of all checksums that the hardware must compute
and insert into the appropriate checksum fields in the packet.</p></dd>
<dt><code>param0</code></dt>
<dd><p>Optional parameter 0, defaults to 0.</p></dd>
<dt><code>param1</code></dt>
<dd><p>Optional parameter 1, defaults to 0.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A network controller that can insert a checksum for output
packets must call this method to obtain the set of checksums that it must
compute, and insert into the appropriate fields in the given output packet.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getChecksumSupport/IOReturn/(UInt32*,UInt32,bool);   name=IONetworkController::getChecksumSupport --><a name="//apple_ref/cpp/instm/IONetworkController/getChecksumSupport/IOReturn/(UInt32*,UInt32,bool)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getChecksumSupport">getChecksumSupport</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Gets checksums that are supported by the network controller for
the given checksum family.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getChecksumSupport</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">checksumMask</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">checksumFamily</span>, 
    <!-- a --><span class="type">bool</span><!-- /a --> <span class="param">isOutput</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>checksumMask</code></dt>
<dd><p>A pointer to the mask of supported checksums returned
by this method.</p></dd>
<dt><code>checksumFamily</code></dt>
<dd><p>A value that specifies the checksum family.</p></dd>
<dt><code>isOutput</code></dt>
<dd><p>Set to true to query the support for checksum insertion on
output packets, or false to query the support for checksum verification
on input packets. Controllers that have symmetric hardware checksum support 
can return a fixed checksum mask value, and ignore this argument.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Default return is kIOReturnUnsupported. Controllers that override
this method must return kIOReturnSuccess. Any other return value will be
interpretated as a lack of checksum support, regardless of the value
returned through the first argument. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A network controller that is capable of inserting and verifying
checksums on output and input packets, should override this method and
advertise its capability in order to assist or offload the software checksum
calculations performed by the protocol stacks.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getCommandClient/OSObject*/();   name=IONetworkController::getCommandClient --><a name="//apple_ref/cpp/instm/IONetworkController/getCommandClient/OSObject*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getCommandClient">getCommandClient</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Gets the command client object.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../../KernelIOKitFramework/OSObject_h/Classes/OSObject/index.html#//apple_ref/cpp/cl/OSObject" target="_top" class="type"><span class="type">OSObject</span></a> <span class="type">*</span> <!-- a --><span class="function">getCommandClient</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the command client. If the caller is not running on the
workloop thread, or if the thread does not have the workloop's gate
closed, then 0 is returned. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Methods called on the workloop context to service a
client request can call this method to get the client object that
initiated the command.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getCommandGate/IOCommandGate*/();   name=IONetworkController::getCommandGate --><a name="//apple_ref/cpp/instm/IONetworkController/getCommandGate/IOCommandGate*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getCommandGate">getCommandGate</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Gets the IOCommandGate object created by IONetworkController.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../KernelIOKitFramework/IOCommandGate_h/Classes/IOCommandGate/index.html#//apple_ref/cpp/cl/IOCommandGate" target="_top" class="type"><span class="type">IOCommandGate</span></a> <span class="type">*</span> <!-- a --><span class="function">getCommandGate</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the IOCommandGate object created by IONetworkController. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>When IONetworkController is started, an IOCommandGate object
is instantiated and attached to the workloop returned by getWorkLoop().
This IOCommandGate object is used internally to synchronize client
commands handled through executeCommand(). Subclasses that need an
IOCommandGate should try to reuse the object returned by this method,
rather than creating a new instance. See IOCommandGate documentation.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getFeatures/UInt32/();   name=IONetworkController::getFeatures --><a name="//apple_ref/cpp/instm/IONetworkController/getFeatures/UInt32/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getFeatures">getFeatures</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Reports generic features supported by the controller and/or
the driver.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="function">getFeatures</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->This method will always return 0. Subclasses may override
this method and return a bit mask of all supported features. 
<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getHardwareAddress/IOReturn/(void*,UInt32*);   name=IONetworkController::getHardwareAddress --><a name="//apple_ref/cpp/instm/IONetworkController/getHardwareAddress/IOReturn/(void*,UInt32*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getHardwareAddress">getHardwareAddress</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Gets the network controller's permanent hardware/station
address. 
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getHardwareAddress</span><!-- /a -->(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">addr</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">inOutAddrBytes</span>) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>addr</code></dt>
<dd><p>The buffer where the controller's hardware address should
be stored.</p></dd>
<dt><code>inOutAddrBytes</code></dt>
<dd><p>The size of the address buffer provided by the
client, and replaced by this method with the actual size of
the hardware address in bytes.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnSuccess on success, or an error otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method call is synchronized by the workloop's gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getMaxPacketSize/IOReturn/(UInt32*);   name=IONetworkController::getMaxPacketSize --><a name="//apple_ref/cpp/instm/IONetworkController/getMaxPacketSize/IOReturn/(UInt32*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getMaxPacketSize">getMaxPacketSize</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Gets the maximum packet size supported by the controller.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getMaxPacketSize</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">maxSize</span>) <span class="keyword">const</span> = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>maxSize</code></dt>
<dd><p>Pointer to the return value.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnSuccess on success, or an error code otherwise. 

<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getMediumDictionary/constOSDictionary*/();   name=IONetworkController::getMediumDictionary --><a name="//apple_ref/cpp/instm/IONetworkController/getMediumDictionary/constOSDictionary*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getMediumDictionary">getMediumDictionary</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the medium dictionary published by the driver.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a --><span class="var">OSDictionary</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">getMediumDictionary</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the published medium dictionary, or 0 if the driver has not
yet published a medium dictionary through publishMediumDictionary(). 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Returns the medium dictionary published by the driver
through publishMediumDictionary(). Use copyMediumDictionary() to
create and get a copy of the medium dictionary.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getMinPacketSize/IOReturn/(UInt32*);   name=IONetworkController::getMinPacketSize --><a name="//apple_ref/cpp/instm/IONetworkController/getMinPacketSize/IOReturn/(UInt32*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getMinPacketSize">getMinPacketSize</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Gets the minimum packet size supported by the controller.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getMinPacketSize</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">minSize</span>) <span class="keyword">const</span> = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>minSize</code></dt>
<dd><p>Pointer to the return value.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnSuccess on success, or an error code otherwise. 

<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getOutputHandler/IOOutputAction/();   name=IONetworkController::getOutputHandler --><a name="//apple_ref/cpp/instm/IONetworkController/getOutputHandler/IOOutputAction/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getOutputHandler">getOutputHandler</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Gets the address of the method designated to handle output 
packets for the network controller.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IONetworkInterface_h/index.html#//apple_ref/c/tdef/IOOutputAction" target="_top" class="type"><span class="type">IOOutputAction</span></a> <!-- a --><span class="function">getOutputHandler</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns a pointer to the outputPacket() method. 

<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getOutputQueue/IOOutputQueue*/();   name=IONetworkController::getOutputQueue --><a name="//apple_ref/cpp/instm/IONetworkController/getOutputQueue/IOOutputQueue*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getOutputQueue">getOutputQueue</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Gets the IOOutputQueue object created by createOutputQueue().
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../KernelIOKitFramework/IOOutputQueue_h/Classes/IOOutputQueue/index.html#//apple_ref/cpp/cl/IOOutputQueue" target="_top" class="type"><span class="type">IOOutputQueue</span></a> <span class="type">*</span> <!-- a --><span class="function">getOutputQueue</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns a reference to the output queue object created by
createOutputQueue(). 

<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getPacketBufferConstraints/void/(IOPacketBufferConstraints*);   name=IONetworkController::getPacketBufferConstraints --><a name="//apple_ref/cpp/instm/IONetworkController/getPacketBufferConstraints/void/(IOPacketBufferConstraints*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getPacketBufferConstraints">getPacketBufferConstraints</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Gets the controller's packet buffer constraints.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">getPacketBufferConstraints</span><!-- /a -->( 
    <a href="../../index.html#//apple_ref/c/tdef/IOPacketBufferConstraints" target="_top" class="type"><span class="type">IOPacketBufferConstraints</span></a> <span class="type">*</span><span class="param">constraints</span>) <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>constraints</code></dt>
<dd><p>A pointer to an IOPacketBufferConstraints
structure that this method is expected to initialize.
See IOPacketBufferConstraints structure definition.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Called by start() to obtain the constraints on the
memory buffer for each mbuf packet allocated through allocatePacket().
Drivers can override this method to specify the buffer constraints
imposed by their bus master hardware. Note that outbound packets,
those that originate from the network stack, are not currently
subject to the constraints reported here.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getPacketFilters/IOReturn/(constOSSymbol*,UInt32*);   name=IONetworkController::getPacketFilters --><a name="//apple_ref/cpp/instm/IONetworkController/getPacketFilters/IOReturn/(constOSSymbol*,UInt32*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getPacketFilters">getPacketFilters</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Gets the set of packet filters supported by the network 
controller for the given filter group.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getPacketFilters</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">group</span><!-- /a -->, 
    <!-- a --><span class="var">UInt32</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">filters</span><!-- /a -->) <span class="keyword">const</span> = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>group</code></dt>
<dd><p>The name of the filter group.</p></dd>
<dt><code>filters</code></dt>
<dd><p>Pointer to the mask of supported filters returned by
this method.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnSuccess on success, or an error to indicate a
failure to discover the set of supported filters. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A subclass must implement this method and report the
set of filters that are supported for the given filter group.
This method call is synchronized by the workloop's gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/getSelectedMedium/constIONetworkMedium*/();   name=IONetworkController::getSelectedMedium --><a name="//apple_ref/cpp/instm/IONetworkController/getSelectedMedium/constIONetworkMedium*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getSelectedMedium">getSelectedMedium</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Gets the current selected medium.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a --><span class="var">IONetworkMedium</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">getSelectedMedium</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the current selected medium, the default medium, or 0. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>If the driver has previously called setSelectedMedium() 
to indicate its current media selection, then this method will return
that medium object. Otherwise, the driver's property table is
consulted and a default medium property is examined, and the
corresponding entry in the medium dictionary is returned.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/handleClose/void/(IOService*,IOOptionBits);   name=IONetworkController::handleClose --><a name="//apple_ref/cpp/instm/IONetworkController/handleClose/void/(IOService*,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="handleClose">handleClose</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Handles a client close.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">handleClose</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">client</span>,
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>client</code></dt>
<dd><p>The client that is closing the controller.</p></dd>
<dt><code>options</code></dt>
<dd><p>Not used. See IOService.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method handles a close from one of the client objects. IOService
calls this method with the arbitration lock held. Subclasses
should not override this method.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/handleIsOpen/bool/(constIOService*);   name=IONetworkController::handleIsOpen --><a name="//apple_ref/cpp/instm/IONetworkController/handleIsOpen/bool/(constIOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="handleIsOpen">handleIsOpen</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Queries whether a client has an open on the controller.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">handleIsOpen</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">IOService</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">client</span><!-- /a -->) <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if the specified client, or any client if none (0) is
specified, presently has an open on this object. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method is always called by IOService with the
arbitration lock held. Subclasses should not override this method.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/handleOpen/bool/(IOService*,IOOptionBits,void*);   name=IONetworkController::handleOpen --><a name="//apple_ref/cpp/instm/IONetworkController/handleOpen/bool/(IOService*,IOOptionBits,void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="handleOpen">handleOpen</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Handles a client open.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">handleOpen</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">client</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">argument</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>client</code></dt>
<dd><p>The client that is attempting to open the controller.</p></dd>
<dt><code>options</code></dt>
<dd><p>Not used. See IOService.</p></dd>
<dt><code>argument</code></dt>
<dd><p>Not used. See IOService.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true to accept the client open, false to refuse it. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method handles a client open on the controller object. IOService
calls this method with the arbitration lock held. Subclasses
should not override this method.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/init/bool/(OSDictionary*);   name=IONetworkController::init --><a name="//apple_ref/cpp/instm/IONetworkController/init/bool/(OSDictionary*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="init">init</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Initializes the IONetworkController object.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <a href="../../../../KernelIOKitFramework/IOFWPhysicalAddressSpace_h/index.html#//apple_ref/c/func/init" target="_top" class="function"><span class="function">init</span></a>(
    <a href="../../../../KernelIOKitFramework/OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span><span class="param">properties</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>properties</code></dt>
<dd><p>A dictionary object containing a property table
associated with this instance.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true on success, false otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Instance variables are initialized, then super::init()
is called.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/newModelString/constOSString*/();   name=IONetworkController::newModelString --><a name="//apple_ref/cpp/instm/IONetworkController/newModelString/constOSString*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="newModelString">newModelString</a></h3>
</td></tr></table>
<hr>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a --><span class="var">OSString</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">newModelString</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns a string describing the model of the network controller.
The caller is responsible for releasing the string object returned. 
<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/newRevisionString/constOSString*/();   name=IONetworkController::newRevisionString --><a name="//apple_ref/cpp/instm/IONetworkController/newRevisionString/constOSString*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="newRevisionString">newRevisionString</a></h3>
</td></tr></table>
<hr>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a --><span class="var">OSString</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">newRevisionString</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns a string describing the hardware revision of the
network controller. The caller is responsible for releasing the
string object returned. 
<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/newVendorString/constOSString*/();   name=IONetworkController::newVendorString --><a name="//apple_ref/cpp/instm/IONetworkController/newVendorString/constOSString*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="newVendorString">newVendorString</a></h3>
</td></tr></table>
<hr>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a --><span class="var">OSString</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">newVendorString</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns a string describing the vendor of the network controller.
The caller is responsible for releasing the string object returned. 
<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/outputPacket/UInt32/(mbuf_t,void*);   name=IONetworkController::outputPacket --><a name="//apple_ref/cpp/instm/IONetworkController/outputPacket/UInt32/(mbuf_t,void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="outputPacket">outputPacket</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Transmits an output packet.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="function">outputPacket</span><!-- /a -->(
    <span class="param">mbuf_t</span>,
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">param</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>packet</code></dt>
<dd><p>An mbuf chain containing the output packet to be sent on
the network.</p></dd>
<dt><code>param</code></dt>
<dd><p>A parameter provided by the caller.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns a return code defined by the caller. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>If an IOOutputQueue was created by createOutputQueue(),
then this method will be called by the output queue object.
Otherwise, an interface object will call this method directly when
it receives an output packet from the data link layer.
</p>
<p>There is no upper limit on the number of mbufs, hence the number of
memory fragments, in the mbuf chain provided. Drivers must be able to
handle cases when the mbuf count might exceed the limit supported by their
DMA engines, and perform coalescing to copy the various memory fragments
into a lesser number of fragments. This complexity can be hidden from
the driver when an IOMbufMemoryCursor is used, which is able to convert
an mbuf chain into a physical address scatter-gather list that will not
exceed a specified number of physically contiguous memory segments.
See IOMbufMemoryCursor.
</p>
<p>The implementation in IONetworkController performs no useful action
and will drop all packets. A driver must override this method and
process the output packet provided. The implementation in the driver
must not block, since this may cause the network stack to be reentered
from an unsafe point.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/prepare/IOReturn/();   name=IONetworkController::prepare --><a name="//apple_ref/cpp/instm/IONetworkController/prepare/IOReturn/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="prepare">prepare</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Prepares the controller before an IOService is created and
attached as a client.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <a href="../../../../KernelIOKitFramework/IOFWPhysicalAddressSpace_h/index.html#//apple_ref/c/func/prepare" target="_top" class="function"><span class="function">prepare</span></a>(); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnSuccess on success, or an error code otherwise.
Returning an error will fail the client attach. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method is called by attachInterface() or
attachDebuggerClient() to prepare the controller before the new client
object is attached. This method will call publishProperties() to publish
controller capabilities and properties that may be used by client objects.
However, publishProperties() will be called only once, even if prepare()
is called multiple times. This method call is synchronized by the
workloop's gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/publishMediumDictionary/bool/(constOSDictionary*);   name=IONetworkController::publishMediumDictionary --><a name="//apple_ref/cpp/instm/IONetworkController/publishMediumDictionary/bool/(constOSDictionary*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="publishMediumDictionary">publishMediumDictionary</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Publishes a dictionary of IONetworkMedium objects to
advertise the media selection supported by the network controller.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">publishMediumDictionary</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">OSDictionary</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">mediumDict</span><!-- /a -->); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>mediumDict</code></dt>
<dd><p>A dictionary of IONetworkMedium objects.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if the dictionary is valid, and was successfully
exported to the property table, false otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Called by drivers to publish their medium dictionary.
Each entry in the dictionary is an IONetworkMedium object that
represents a single medium that is supported by the controller.
This method will make a copy of the dictionary provided, then add
the copy to the driver's property table. The dictionary provided
can be released by the caller upon returning from this method.
It is permissible to call this method multiple times, which may be
necessary if the hardware's media capability changes dynamically.
However, if the capability is static, which is often the case,
then a driver will typically call this method only once from
its start() method.
</p>
<p>Several methods depend on the presence of a medium dictionary.
They should be called after the medium dictionary has been
published. Those methods are:
setSelectedMedium()
getSelectedMedium()
getMediumDictionary()
copyMediumDictionary()
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/publishProperties/bool/();   name=IONetworkController::publishProperties --><a name="//apple_ref/cpp/instm/IONetworkController/publishProperties/bool/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="publishProperties">publishProperties</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Publishes controller properties and capabilities.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">publishProperties</span><!-- /a -->(); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if all properties were discovered and published
successfully, false otherwise. Returning false will prevent client
objects from attaching to the controller, since a property that
a client relies upon may be missing. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Called by IONetworkController to discover controller
properties, and publish them to the property table in the I/O Kit
Registry. This method is called once by prepare().
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/receivePacket/void/(void*,UInt32*,UInt32);   name=IONetworkController::receivePacket --><a name="//apple_ref/cpp/instm/IONetworkController/receivePacket/void/(void*,UInt32*,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="receivePacket">receivePacket</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Debugger polled-mode receive handler.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">receivePacket</span><!-- /a -->(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">pkt</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">pktSize</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">timeout</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>pkt</code></dt>
<dd><p>Address of a receive buffer where the received packet should
be stored. This buffer has room for 1518 bytes.</p></dd>
<dt><code>pktSize</code></dt>
<dd><p>Address where the number of bytes received must be
recorded. Set this to zero if no packets were received during
the timeout interval.</p></dd>
<dt><code>timeout</code></dt>
<dd><p>The maximum amount of time in milliseconds to poll for
a packet to arrive before this method must return.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method must be implemented by a driver that supports
kernel debugging. After a debugger client has been attached through
attachDebuggerClient(), this method will be called by the debugger
client to poll for an incoming packet when the kernel debugger is active.
This method may be called from the primary interrupt context, and the
implementation must avoid any memory allocation, and must never block.
The receivePacket() method in IONetworkController is used as a placeholder,
it performs no useful action, and should not be called. A driver that
attaches a debugger client must override this method.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/registerWithPolicyMaker/IOReturn/(IOService*);   name=IONetworkController::registerWithPolicyMaker --><a name="//apple_ref/cpp/instm/IONetworkController/registerWithPolicyMaker/IOReturn/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="registerWithPolicyMaker">registerWithPolicyMaker</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Implemented by controller drivers to register with
the power management policy-maker.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">registerWithPolicyMaker</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">policyMaker</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>policyMaker</code></dt>
<dd><p>The policy-maker chosen to manage power for
this network controller.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnSuccess on success, kIOReturnUnsupported if the
driver does not support power management, or an appropriate error
return code. The default return is kIOReturnUnsupported. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Drivers that are able to power manage their hardware
should override this method and register with the policy-maker
provided by calling IOService::registerPowerDriver().
IONetworkController will call this method before the initial
attempt is made to attach a client.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/releaseDebuggerLock/void/();   name=IONetworkController::releaseDebuggerLock --><a name="//apple_ref/cpp/instm/IONetworkController/releaseDebuggerLock/void/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="releaseDebuggerLock">releaseDebuggerLock</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Releases the global debugger lock.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">releaseDebuggerLock</span><!-- /a -->(); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method should not be used. Instead, call the
unlock() method provided by IOKernelDebugger. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/releaseFreePackets/UInt32/();   name=IONetworkController::releaseFreePackets --><a name="//apple_ref/cpp/instm/IONetworkController/releaseFreePackets/UInt32/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="releaseFreePackets">releaseFreePackets</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Releases all packets held in the free packet queue.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="function">releaseFreePackets</span><!-- /a -->(); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the number of packets queued and released. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The free packet queue is not protected by a lock. This
function must be called in a single-threaded manner with respect to
all calls to freePacket() with the kDelayFree option set.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/replaceOrCopyPacket/mbuf_t/(mbuf_t*,UInt32,bool*);   name=IONetworkController::replaceOrCopyPacket --><a name="//apple_ref/cpp/instm/IONetworkController/replaceOrCopyPacket/mbuf_t/(mbuf_t*,UInt32,bool*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="replaceOrCopyPacket">replaceOrCopyPacket</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>A helper method that combines the functionality of
copyPacket() and replacePacket() to process a packet containing
a received frame.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">mbuf_t</span><!-- /a --> <!-- a --><span class="function">replaceOrCopyPacket</span><!-- /a -->(
    <!-- a --><span class="type">mbuf_t</span><!-- /a --> <span class="type">*</span><span class="param">mp</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">length</span>, 
    <!-- a --><span class="type">bool</span><!-- /a --> <span class="type">*</span><span class="param">replaced</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>mp</code></dt>
<dd><p>A handle to the existing packet that may be replaced.</p></dd>
<dt><code>length</code></dt>
<dd><p>The number of bytes received held in the packet.
Must be greater than zero.</p></dd>
<dt><code>replaced</code></dt>
<dd><p>Pointer to a return value that is set to true to indicate
that the existing packet was replaced, or false to indicate that the
existing packet was not replaced, and a copy was created.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns a replacement or a copy of the existing packet, or 0 if packet
allocation failed. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method will either make a copy or replace the existing
packet, whichever is more time efficient. Packets containing small frames
are copied, otherwise they are replaced. If replaced, then the existing
packet is returned, and a new packet with the same buffer size is created
to take its place. If copied, the existing packet is left intact, while a
copy is returned that will hold a copy of the data from the source packet.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/replacePacket/mbuf_t/(mbuf_t*,UInt32);   name=IONetworkController::replacePacket --><a name="//apple_ref/cpp/instm/IONetworkController/replacePacket/mbuf_t/(mbuf_t*,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="replacePacket">replacePacket</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Allocates a new packet to replace an existing packet, the
existing packet is then returned.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">mbuf_t</span><!-- /a --> <!-- a --><span class="function">replacePacket</span><!-- /a -->(
    <!-- a --><span class="type">mbuf_t</span><!-- /a --> <span class="type">*</span><span class="param">mp</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="type">size</span><!-- /a --> = <span class="number">0</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>mp</code></dt>
<dd><p>A handle to the existing packet.</p></dd>
<dt><code>size</code></dt>
<dd><p>If size is 0, then the new packet shall have the same buffer
size as the original packet that is being replaced. Otherwise, the new
packet shall have the buffer size specified by this value.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->If packet allocation was successful, then a replacement will
take place and the original packet will be returned. Otherwise, 0
is returned, and the original packet will be left untouched.

<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/reserveDebuggerLock/void/();   name=IONetworkController::reserveDebuggerLock --><a name="//apple_ref/cpp/instm/IONetworkController/reserveDebuggerLock/void/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="reserveDebuggerLock">reserveDebuggerLock</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Takes the global debugger lock.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">reserveDebuggerLock</span><!-- /a -->(); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method should not be used. Instead, call the
lock() method provided by IOKernelDebugger. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/selectMedium/IOReturn/(constIONetworkMedium*);   name=IONetworkController::selectMedium --><a name="//apple_ref/cpp/instm/IONetworkController/selectMedium/IOReturn/(constIONetworkMedium*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="selectMedium">selectMedium</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>A client request to change the medium selection.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">selectMedium</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">IONetworkMedium</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">medium</span><!-- /a -->); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>medium</code></dt>
<dd><p>An entry from the published medium dictionary that
represents the selection chosen by the client.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnUnsupported. Drivers may override this method and
return kIOReturnSuccess if the selection was successful,
or an error code otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method is called when a client issues a command
for the controller to change its current medium selection.
The implementation must call setSelectedMedium() after the change
has occurred. This method call is synchronized by the workloop's
gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/selectMediumWithName/IOReturn/(constOSSymbol*);   name=IONetworkController::selectMediumWithName --><a name="//apple_ref/cpp/instm/IONetworkController/selectMediumWithName/IOReturn/(constOSSymbol*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="selectMediumWithName">selectMediumWithName</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>A client request to change the medium selection.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">selectMediumWithName</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">mediumName</span><!-- /a -->); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>mediumName</code></dt>
<dd><p>An OSSymbol object that describes the name of the
new medium selected by the client.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the return from selectMedium() if a matching entry was found
from the medium dictionary. Returns kIOReturnUnsupported if a medium
dictionary does not exist, or kIOReturnBadArgument if the name given
does not match any entry in the medium dictionary. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method is called when a client issues a command
for the controller to change its current medium selection.
This implementation will look for an entry in the medium
dictionary published by the driver that is associated with the
key given. If a match is found, then selectMedium() is called to
perform the selection, otherwise an error is reported back to the
client. Subclasses should override selectMedium() and not this
method. This method call is synchronized by the workloop's gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/sendPacket/void/(void*,UInt32);   name=IONetworkController::sendPacket --><a name="//apple_ref/cpp/instm/IONetworkController/sendPacket/void/(void*,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="sendPacket">sendPacket</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Debugger polled-mode transmit handler.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">sendPacket</span><!-- /a -->(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">pkt</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">pktSize</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>pkt</code></dt>
<dd><p>Pointer to a transmit buffer containing the packet to be
sent on the network.</p></dd>
<dt><code>pktSize</code></dt>
<dd><p>The size of the transmit buffer in bytes.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method must be implemented by a driver that supports
kernel debugging. After a debugger client has been attached through
attachDebuggerClient(), this method will be called by the debugger
to send an outbound packet only when the kernel debugger is active.
This method may be called from the primary interrupt context, and the
implementation must avoid any memory allocation, and must never block.
The sendPacket() method in IONetworkController is used as a placeholder,
it performs no useful action, and should not be called. A driver that
attaches a debugger client must override this method.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/setChecksumResult/bool/(mbuf_t,UInt32,UInt32,UInt32,UInt32,UInt32);   name=IONetworkController::setChecksumResult --><a name="//apple_ref/cpp/instm/IONetworkController/setChecksumResult/bool/(mbuf_t,UInt32,UInt32,UInt32,UInt32,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setChecksumResult">setChecksumResult</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Encodes a received packet with the checksum result reported
by the hardware.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">setChecksumResult</span><!-- /a -->(
    <!-- a --><span class="type">mbuf_t</span><!-- /a --> <span class="param">packet</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">checksumFamily</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">resultMask</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">validMask</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="type">param0</span><!-- /a --> = <span class="number">0</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="type">param1</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>packet</code></dt>
<dd><p>An mbuf containing a packet that has been checksummed by
the hardware.</p></dd>
<dt><code>checksumFamily</code></dt>
<dd><p>A value that specifies the checksum family.</p></dd>
<dt><code>resultMask</code></dt>
<dd><p>A mask of all checksums that were checked or computed.
Setting a bit implies that the driver is able to report the result of
the checksum computation, by asserting the validity of the checksum,
or by returning a partial checksum value.</p></dd>
<dt><code>validMask</code></dt>
<dd><p>A mask of all checksums are were computed and verified
by the hardware as valid. Certain types of checksum performed by the
hardware are inheritely incomplete, and therefore should never be marked
as valid. A checksum cannot be marked valid unless it has also been
checked.</p></dd>
<dt><code>param0</code></dt>
<dd><p>Optional parameter 0, defaults to 0.</p></dd>
<dt><code>param1</code></dt>
<dd><p>Optional parameter 1, defaults to 0.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if the checksum family is valid and the packet has been
encoded with the checksum result provided, false otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A network controller that can verify the checksum(s) for a
received packet, should call this method to encode the result on the
packet, before passing it up towards the protocol stacks.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/setHardwareAddress/IOReturn/(constvoid*,UInt32);   name=IONetworkController::setHardwareAddress --><a name="//apple_ref/cpp/instm/IONetworkController/setHardwareAddress/IOReturn/(constvoid*,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setHardwareAddress">setHardwareAddress</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Sets or changes the station address used by the network
controller. 
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setHardwareAddress</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">void</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">addr</span><!-- /a -->, 
    <!-- a --><span class="var">UInt32</span><!-- /a --> <!-- a --><span class="var">addrBytes</span><!-- /a -->) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>buffer</code></dt>
<dd><p>The buffer containing the hardware address provided by
the client.</p></dd>
<dt><code>addrBytes</code></dt>
<dd><p>The size of the address buffer provided by the
client in bytes.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnSuccess on success, or an error otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method call is synchronized by the workloop's gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/setLinkStatus/bool/(UInt32,constIONetworkMedium*,UInt64,OSData*);   name=IONetworkController::setLinkStatus --><a name="//apple_ref/cpp/instm/IONetworkController/setLinkStatus/bool/(UInt32,constIONetworkMedium*,UInt64,OSData*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setLinkStatus">setLinkStatus</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Reports the link status and the active medium.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">setLinkStatus</span><!-- /a -->( 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">status</span>, 
    <span class="keyword">const</span> <!-- a --><span class="var">IONetworkMedium</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">activeMedium</span><!-- /a --> = <span class="number">0</span>, 
    <!-- a --><span class="type">UInt64</span><!-- /a --> <!-- a --><span class="type">speed</span><!-- /a --> = <span class="number">0</span>, 
    <a href="../../../../KernelIOKitFramework/OSData_h/Classes/OSData/index.html#//apple_ref/cpp/cl/OSData" target="_top" class="type"><span class="type">OSData</span></a> <span class="type">*</span><!-- a --><span class="type">data</span><!-- /a --> = <span class="number">0</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>status</code></dt>
<dd><p>Link status bits.
See IONetworkMedium for the definition of the link status bits.</p></dd>
<dt><code>activeMedium</code></dt>
<dd><p>An object in the published medium dictionary
that represents the active medium. This may not be the same as
the selected medium. Set this to 0 if the link is inactive.</p></dd>
<dt><code>speed</code></dt>
<dd><p>Link speed in units of bits per second. If zero, then
the link speed is taken from the medium object provided.</p></dd>
<dt><code>data</code></dt>
<dd><p>An OSData containing any additional link parameter that
the driver wishes to publish to the registry.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if all link properties were successfully updated,
false otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Drivers must call this method when a link change is
detected. IONetworkController will update the link status properties
in the registry, and generate an event to inform the upper layers
about the change.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/setMaxPacketSize/IOReturn/(UInt32);   name=IONetworkController::setMaxPacketSize --><a name="//apple_ref/cpp/instm/IONetworkController/setMaxPacketSize/IOReturn/(UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setMaxPacketSize">setMaxPacketSize</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>A client request to change the maximum packet size.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setMaxPacketSize</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">maxSize</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>maxSize</code></dt>
<dd><p>The new maximum packet size.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns kIOReturnUnsupported. Drivers may override this method
and return either kIOReturnSuccess to indicate that the new size
was accepted and is in effect, or an error code to indicate failure. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method call is synchronized by the workloop's gate.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/setSelectedMedium/bool/(constIONetworkMedium*);   name=IONetworkController::setSelectedMedium --><a name="//apple_ref/cpp/instm/IONetworkController/setSelectedMedium/bool/(constIONetworkMedium*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setSelectedMedium">setSelectedMedium</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Designates an entry in the published medium dictionary as
the current selected medium.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">setSelectedMedium</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">IONetworkMedium</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">medium</span><!-- /a -->); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>medium</code></dt>
<dd><p>A medium object representing the current selection.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if the property table update was successful,
false if the update failed, or if the medium provided does not match
any entry from the published medium dictionary. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>After the driver has configured the hardware to select
one of its supported media types, it must call this method to inform
its parent about the change that has occurred. IONetworkController
will update a property in the registry to reflect the current selection.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/start/bool/(IOService*);   name=IONetworkController::start --><a name="//apple_ref/cpp/instm/IONetworkController/start/bool/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="start">start</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Starts the network controller.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">start</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">provider</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>provider</code></dt>
<dd><p>The provider that the controller was matched
(and attached) to.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true on success, false otherwise. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>After the controller driver has successfully matched
to a provider, this method is called to start the network controller. 
IONetworkController will allocate resources and gather controller
properties in its implementation. No I/O will be performed until
the subclass tries to attach a client object. A driver must override
this method, and call super::start() at the beginning of its own
implementation. Then check the return value to make sure that its
superclass was started successfully before proceeding. Tasks that
are usually performed by a driver's start method are: resource
allocation, hardware initialization, allocation of IOEventSources
and attaching them to a workloop, publishing a medium dictionary,
and finally, attaching an interface object when it is ready to
handle client requests.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IONetworkController/stop/void/(IOService*);   name=IONetworkController::stop --><a name="//apple_ref/cpp/instm/IONetworkController/stop/void/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="stop">stop</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Stops the network controller.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">stop</span><!-- /a -->(
    <a href="../../../../KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">provider</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>provider</code></dt>
<dd><p>The provider that the controller was matched
(and attached) to.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The counterpart of start(). The controller has been
instructed to stop running. The stop() method should release
resources and undo actions performed by the start() method.
Subclasses must override this method and call super::stop()
at the end of its implementation.
<!-- end discussion -->
</p>
<p></p>
<h2>Typedefs</h2>
<hr>
<!-- headerDoc=tdef;  uid=//apple_ref/cpp/tdef/IONetworkController/Action;   name=IONetworkController::Action --><a name="//apple_ref/cpp/tdef/IONetworkController/Action"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="Action">Action</a></h3>
</td></tr></table>
<hr>
<p></p>
<b>See Also:</b><blockquote><dl>
<dt>
<a href="index.html#//apple_ref/doc/title:tdef/IONetworkController/IONetworkController::Action" target="_top"><p>IONetworkController::Action</p></a>
</dt>
<dd></dd>
</dl></blockquote>
<pre><tt>public</tt>
<br><span class="keyword">typedef</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> ( <span class="type">*</span><!-- a --><span class="function">Action</span><!-- /a -->)(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">target</span>,
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">param0</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">param1</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">param2</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">param3</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Fields</font></h5>
<dl>
<dt><code>target</code></dt>
<dd><p>The first argument passed to action.</p></dd>
<dt><code>param0</code></dt>
<dd><p>Action parameter 0.</p></dd>
<dt><code>param1</code></dt>
<dd><p>Action parameter 1.</p></dd>
<dt><code>param2</code></dt>
<dd><p>Action parameter 2.</p></dd>
<dt><code>param3</code></dt>
<dd><p>Action parameter 3.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Definition of a C function that can be called
through executeCommand().
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=title:tdef;  uid=//apple_ref/doc/title:tdef/IONetworkController/IONetworkController::Action;   name=IONetworkController::IONetworkController::Action --><a name="//apple_ref/doc/title:tdef/IONetworkController/IONetworkController::Action"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="IONetworkController::Action">IONetworkController::Action</a></h3>
</td></tr></table>
<hr>
<p></p>
<b>See Also:</b><blockquote><dl>
<dt>
<a href="index.html#//apple_ref/cpp/tdef/IONetworkController/Action" target="_top"><p>Action</p></a>
</dt>
<dd></dd>
</dl></blockquote>
<pre><tt>public</tt>
<br><span class="keyword">typedef</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> ( <span class="type">*</span><!-- a --><span class="function">Action</span><!-- /a -->)(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">target</span>,
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">param0</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">param1</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">param2</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">param3</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Fields</font></h5>
<dl>
<dt><code>target</code></dt>
<dd><p>The first argument passed to action.</p></dd>
<dt><code>param0</code></dt>
<dd><p>Action parameter 0.</p></dd>
<dt><code>param1</code></dt>
<dd><p>Action parameter 1.</p></dd>
<dt><code>param2</code></dt>
<dd><p>Action parameter 2.</p></dd>
<dt><code>param3</code></dt>
<dd><p>Action parameter 3.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Definition of a C function that can be called
through executeCommand().
<!-- end discussion -->
</p>
<p></p>
<h2>Member Data</h2>
<hr>
<!-- headerDoc=data;  uid=//apple_ref/cpp/data/IONetworkController/_reserved;   name=IONetworkController::_reserved --><a name="//apple_ref/cpp/data/IONetworkController/_reserved"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="_reserved">_reserved</a></h3>
</td></tr></table>
<hr>
<p></p>
<b>See Also:</b><blockquote><dl>
<dt>
<a href="index.html#//apple_ref/doc/title:data/IONetworkController/reserved" target="_top"><p>reserved</p></a>
</dt>
<dd></dd>
</dl></blockquote>
<pre><tt>private</tt>
<br><a href="../../../../KernelIOKitFramework/IOFWAddressSpace_h/index.html#//apple_ref/c/tag/ExpansionData" target="_top" class="type"><span class="type">ExpansionData</span></a> <span class="type">*</span> <a href="../../../../KernelIOKitFramework/IOHIDElement_h/index.html#//apple_ref/c/data/_reserved" target="_top" class="var"><span class="var">_reserved</span></a>; </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Reserved for future use.  (Internal use only)<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=title:data;  uid=//apple_ref/doc/title:data/IONetworkController/reserved;   name=IONetworkController::reserved --><a name="//apple_ref/doc/title:data/IONetworkController/reserved"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="reserved">reserved</a></h3>
</td></tr></table>
<hr>
<p></p>
<b>See Also:</b><blockquote><dl>
<dt>
<a href="index.html#//apple_ref/cpp/data/IONetworkController/_reserved" target="_top"><p>_reserved</p></a>
</dt>
<dd></dd>
</dl></blockquote>
<pre><tt>private</tt>
<br><a href="../../../../KernelIOKitFramework/IOFWAddressSpace_h/index.html#//apple_ref/c/tag/ExpansionData" target="_top" class="type"><span class="type">ExpansionData</span></a> <span class="type">*</span> <a href="../../../../KernelIOKitFramework/IOHIDElement_h/index.html#//apple_ref/c/data/_reserved" target="_top" class="var"><span class="var">_reserved</span></a>; </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Reserved for future use.  (Internal use only)<!-- end discussion -->
</p>
<p></p>
<h2>Enumerations</h2>
<hr>
<!-- headerDoc=title:tag;  uid=//apple_ref/doc/title:tag/IONetworkController/TCP/IPChecksums;   name=IONetworkController::TCP/IPChecksums --><a name="//apple_ref/doc/title:tag/IONetworkController/TCP/IPChecksums"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="TCP/IPChecksums">TCP/IPChecksums</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>TCP/IP checksums that may be supported by the
hardware.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">enum</span> { 
    <!-- a --><span class="var">kChecksumFamilyTCPIP</span><!-- /a --> = <span class="number">0x00000001</span>, 
    <!-- a --><span class="var">kChecksumIP</span><!-- /a --> = <span class="number">0x0001</span>, 
    <!-- a --><span class="var">kChecksumTCP</span><!-- /a --> = <span class="number">0x0002</span>, 
    <!-- a --><span class="var">kChecksumUDP</span><!-- /a --> = <span class="number">0x0004</span>, 
    <!-- a --><span class="var">kChecksumTCPNoPseudoHeader</span><!-- /a --> = <span class="number">0x0100</span>, 
    <!-- a --><span class="var">kChecksumUDPNoPseudoHeader</span><!-- /a --> = <span class="number">0x0200</span>, 
    <!-- a --><span class="var">kChecksumTCPSum16</span><!-- /a --> = <span class="number">0x1000</span> 
}; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Constants</font></h5>
<blockquote>
<dl>
<dt><code>kChecksumFamilyTCPIP</code></dt>
<dd><p>A value that describes the collection
of TCP/IP checksums.</p></dd>
<dt><code>kChecksumIP</code></dt>
<dd><p>An IP header checksum.</p></dd>
<dt><code>kChecksumTCP</code></dt>
<dd><p>A TCP checksum that covers the TCP header and TCP
data.</p></dd>
<dt><code>kChecksumUDP</code></dt>
<dd><p>A UDP checksum that covers the UDP header and UDP
data.</p></dd>
<dt><code>kChecksumTCPNoPseudoHeader</code></dt>
<dd><p>A TCP checksum that covers the TCP
header and the TCP data, but the pseudo header is not included in the
checksum computation. A partial 16-bit checksum value must be provided
to allow the protocol stacks to calculate and verify the final checksum.
This type of checksum is not currently supported on the output path.</p></dd>
<dt><code>kChecksumUDPNoPseudoHeader</code></dt>
<dd><p>A UDP checksum that covers the UDP
header and the UDP data, but the pseudo header is not included in the
checksum computation. A partial 16-bit checksum value must be provided
to allow the protocol stacks to calculate and verify the final checksum.
This type of checksum is not currently supported on the output path.</p></dd>
<dt><code>kChecksumTCPSum16</code></dt>
<dd><p>The hardware has a simple checksum engine
that can perform a TCP style ones complement sum of 16-bit words over 
a certain range of bytes in a packet. The hardware does not have the
ability to scan for IP or TCP headers, and the driver must pass/get
additional parameter(s) to or from the protocol stack to coordinate
the checksumming effort.</p></dd>
</dl>
</blockquote>
<p></p>
<p><!-- start of footer -->

<!-- start of footer --> 
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/IOKit/IONetworkController_h/Classes/IONetworkController/index.html%3Fid%3DTP30000815-5.4&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/IOKit/IONetworkController_h/Classes/IONetworkController/index.html%3Fid%3DTP30000815-5.4&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/IOKit/IONetworkController_h/Classes/IONetworkController/index.html%3Fid%3DTP30000815-5.4&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</p>
<p>&nbsp;</p>
<!--#include virtual="/footer"-->
<!-- end of footer -->


<!-- end of footer -->
Last Updated: 2009-02-23
</div>
<!-- headerDoc=cl; uid=//apple_ref/cpp/cl/IONetworkController;  name=IONetworkController--><a name="//apple_ref/cpp/cl/IONetworkController"></a>
</body>
</html>
