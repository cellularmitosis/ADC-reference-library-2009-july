<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>OpenGL Programming Guide for Mac OS X: Techniques for Working with Vertex Data</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Techniques for Working with Vertex Data"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001987-CH406" title="Techniques for Working with Vertex Data"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../OpenGL-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000549" target="_top">OpenGL</a> &gt; <a href="../opengl_intro/opengl_intro.html#//apple_ref/doc/uid/TP40001987-CH207-TP9">OpenGL Programming Guide for Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_pixelformats/opengl_pixelformats.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_texturedata/opengl_texturedata.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001987-CH406-SW3" title="Techniques for Working with Vertex Data"></a><h1>Techniques for Working with Vertex Data</h1><p>Complex shapes and detailed 3D models require large amounts of vertex data to describe them in OpenGL. Moving vertex data from your application to the graphics hardware incurs a performance cost that can be quite large depending on the size of the data set. Applications that use large vertex data sets can adopt one or more strategies to optimize how the data flows to OpenGL.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH406-SW7" title="Figure 8-1Vertex data sets can be quite large"></a><p><strong>Figure 8-1&nbsp;&nbsp;</strong>Vertex data sets can be quite large</p><img src = "../art/vertex_data.jpg" alt = "Vertex data sets can be quite large" ></div><br/><p>This chapter provides best practices for working with vertex data, describes how to use extensions to optimize performance, shows how to use a fence command to test for completion of OpenGL commands, and discusses how to set up double buffers.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW16">Best Practices for Working with Vertex Data</a>
				
			<br/>
			
        
			
			
				<a href="opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW5">Using Extensions to Improve Performance</a>
				
			<br/>
			
        
			
			
				<a href="opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW10">Double Buffering Vertex Data</a>
				
			<br/>
			
        
			
			
				<a href="opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW19">See Also</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001987-CH406-SW16" title="Best Practices for Working with Vertex Data"></a><h2>Best Practices for Working with Vertex Data</h2><p>Understanding how vertex data flows through an OpenGL program is important to choosing strategies for handling the data. Vertex data can travel through OpenGL in two ways, as shown in <span class="content_text">Figure 8-2</span>. The first way, from vertex data to per-vertex operations, is as part of an OpenGL command sequence that is issued by the application and executed immediately (immediate mode). The second is packaged as a named display list that can be preprocessed ahead of time and used later in the program.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH406-SW4" title="Figure 8-2Vertex data path"></a><p><strong>Figure 8-2&nbsp;&nbsp;</strong>Vertex data path</p><img src = "../art/vertex_pipeline.jpg" alt = "Vertex data path" ></div><br/><p><span class="content_text">Figure 8-3</span> provides a closer look at the vertex data path when using immediate mode. Without any optimizations, your vertex data can be copied at various points in the data path. OpenGL is required to capture the current vertex state when you use immediate mode. If your code uses functions that operate on vertex arrays,  you can eliminate the command buffer copy shown in <span class="content_text">Figure 8-3</span>.  The OpenGL commands <code>glDrawRangeElements</code>, <code>glDrawElements</code>, and <code>glDrawArrays</code> render multiple geometric primitives from array data, using very few subroutine calls. It's best to use <code>glDrawRangeElements</code>, with <code>glDrawElements</code> the second choice, and <code>glDrawArrays</code> the third.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH406-SW12" title="Figure 8-3Immediate mode requires a copy of the current vertex data"></a><p><strong>Figure 8-3&nbsp;&nbsp;</strong>Immediate mode requires a copy of the current vertex data</p><img src = "../art/vertexdata_copy_required.jpg" alt = "Immediate mode requires a copy of the current vertex data" ></div><br/><p>In addition to using functions that operate on vertex arrays, there are a number of other strategies that you can adopt to optimize the flow of vertex data in your application:</p><ul class="ul"><li class="li"><p>Minimize data type conversions by supplying OpenGL data types for vertex data. Use <code>GLfloat</code>, <code>GLshort</code>, or <code>GLubyte</code> data types because most graphics processors handle these types natively. If you use some other type, then OpenGL may need to perform a costly data conversion.</p></li><li class="li"><p>The most desirable way to handle vertex data is to use the <code>GL_APPLE_vertex_array_range</code> or <code>GL_ARB_vertex_buffer_object</code> extensions. (See <span class="content_text"><a href="opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW5">“Using Extensions to Improve Performance.”</a></span>) If you can't use these extensions, then make sure you use vertex arrays and display lists. Avoid using immediate mode. But if your code must use immediate mode, maximize the number of vertices per draw command or within a begin-end code block.</p></li><li class="li"><p>Use vertex programs to perform computations on vertex data instead of using the CPU to perform the computations.</p></li><li class="li"><p>If your code must use immediate mode, use CGL macros (for Cocoa or Carbon) or AGL macros (Carbon only). Macros use the function call dispatch table directly, which can dramatically reduce function call overhead. See <span class="content_text"><a href="../opengl_performance/opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW7">“Use OpenGL Macros.”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP40001987-CH406-SW5" title="Using Extensions to Improve Performance"></a><h2>Using Extensions to Improve Performance</h2><p>The vertex array range  (<code>GL_APPLE_vertex_array_range</code>) and vertex  buffer object (<code>GL_ARB_vertex_buffer_object</code>) extensions were created to help streamline the vertex data path. Although both can improve application performance, the vertex buffer object extension should be your first choice and the vertex array range extension your second. The vertex array range extension provides the GPU with direct access to your data. When your data is dynamic, the burden is on your application to synchronize access to that data. Vertex buffer objects, on the other hand, don't require your application to synchronize data access, which is the primary reason why they are preferred. You'll read more about each extension in the sections that follow.</p><p>For dynamic vertex array data, these extensions set up DMA from the application to the GPU, as shown in <span class="content_text">Figure 8-4</span>. Notice that copies of the vertex data are not maintained in VRAM. This means that each time the data is drawn, it gets moved from the application to the GPU. It's important to ensure that this happens asynchronously.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH406-SW13" title="Figure 8-4Extensions allow dynamic data to use DMA"></a><p><strong>Figure 8-4&nbsp;&nbsp;</strong>Extensions allow dynamic data to use DMA</p><img src = "../art/vertexdata_dma.jpg" alt = "Extensions allow dynamic data to use DMA" ></div><br/><p>For static vertex data, you can use these extensions to cache the data in VRAM, which allows the data to utilize the full bandwidth of the graphics processor bus, as shown in <span class="content_text">Figure 8-5</span>. Data needs to be copied to VRAM only once.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH406-SW14" title="Figure 8-5Extensions allow static vertex data to use VRAM storage"></a><p><strong>Figure 8-5&nbsp;&nbsp;</strong>Extensions allow static vertex data to use VRAM storage</p><img src = "../art/vertexdata_vram_storage.jpg" alt = "Extensions cause static vertex data to use VRAM storage" ></div><br/><p>The next sections describe  these extensions in more detail as well as the Apple fence extension (<code>GL_APPLE_fence</code>), which is used to synchronize drawing commands.</p><a name="//apple_ref/doc/uid/TP40001987-CH406-SW17" title="Vertex Array Range Extension"></a><h3>Vertex Array Range Extension</h3><p>The vertex array range extension (<code>APPLE_vertex_array_range</code>) lets you define a region of memory for your vertex data. This allows the OpenGL driver to optimize memory usage by creating a single memory mapping for your vertex data. You can also provide a hint as to how the data should be stored: cached or shared. The cached option specifies to cache vertex data in video memory. The shared option indicates that data should be mapped into a region of memory that allows the GPU to access the vertex data directly using DMA transfer. This option is best for dynamic data.  If you use shared memory, you'll need to double buffer your data. See <span class="content_text"><a href="opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW10">“Double Buffering Vertex Data.”</a></span></p><p>You can set up and use the vertex array range extension by following these steps:</p><ol class="ol"><li class="li"><p>Enable the extension by calling <code><!--a-->glEnableClientState<!--/a--></code> and supplying the <code>GL_VERTEX_ARRAY_RANGE_APPLE</code> constant.</p></li><li class="li"><p>Allocate storage for the vertex data. You are responsible for  maintaining storage for the data.</p></li><li class="li"><p>Define an array of vertex data by calling a function such as <code><!--a-->glVertexPointer<!--/a--></code>. You need to supply a pointer to your data.</p></li><li class="li"><p>Optionally set up a hint  about handling the storage of the array data by calling the function <code><!--a-->glVertexArrayParameteriAPPLE<!--/a--></code>. </p><div class="codesample"><table><tr><td scope="row"><pre>GLvoid glVertexArrayParameteriAPPLE(GLenum pname, GLint param);<span></span></pre></td></tr></table></div><p><code>pname</code> must be <code>VERTEX_ARRAY_STORAGE_HINT_APPLE</code>.</p><p><code>param</code> is a hint that specifies how your application expects to use the data. OpenGL uses this hint to optimize performance. You can supply either <code>STORAGE_SHARED_APPLE</code> or <code>STORAGE_CACHED_APPLE</code>. The default value is <code>STORAGE_SHARED_APPLE</code>, which indicates that the vertex data is dynamic and that OpenGL should use optimization and flushing techniques suitable for this kind of data.  If you expect the data to be static supply, <code>STORAGE_CACHED_APPLE</code> so that OpenGL uses  VRAM caching and other techniques to optimize memory bandwidth.</p></li><li class="li"><p>Call the OpenGL function <code><!--a-->glVertexArrayRangeAPPLE<!--/a--></code> to establish the data set.</p><div class="codesample"><table><tr><td scope="row"><pre>void glVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer);<span></span></pre></td></tr></table></div><p><code>length</code> specifies the length of the vertex array range. The length is typically the number of unsigned bytes.</p><p><code>*pointer</code> points to the base of the vertex array range. </p></li><li class="li"><p>Draw with the vertex data using standard OpenGL vertex array commands.</p></li><li class="li"><p>Call <code><!--a-->glFlushVertexArrayRangeAPPLE<!--/a--></code>.</p><div class="codesample"><table><tr><td scope="row"><pre>void glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer);<span></span></pre></td></tr></table></div><p><code>length</code> specifies the length of the vertex array range, in bytes.</p><p><code>*pointer</code> points to the base of the vertex array range. </p><p>For dynamic data, each time you change the data, you need to maintain synchronicity by calling <code><!--a-->glFlushVertexArrayRangeAPPLE<!--/a--></code>. You supply as parameters an array size and a pointer to an array, which can be a subset of the data, as long as it includes all of the data that changed. Contrary to the name of the function, <code><!--a-->glFlushVertexArrayRangeAPPLE<!--/a--></code> doesn't actually flush data like the OpenGL function <code>glFlush</code> does. It simply makes OpenGL aware that the data has changed. </p><p>To make sure that your data is fully coherent, in addition to calling <code><!--a-->glFlushVertexArrayRangeAPPLE<!--/a--></code> after drawing and prior to modifying the data, you need either to call <code><!--a-->glFinish<!--/a--></code> or to set up a fence. The <code>APPLE_fence</code> extension lets you set up selective synchronization. See <span class="content_text"><a href="opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW1">“Fence Extension”</a></span> and <span class="content_text"><a href="opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW10">“Double Buffering Vertex Data.”</a></span></p></li></ol><p><span class="content_text">Listing 8-1</span> shows code that sets up and uses the vertex array range extension with dynamic data. It overwrites all of the vertex data during each iteration through the drawing loop. The call to the <code>glFinishFenceAPPLE</code> command guarantees that the CPU and the GPU don't access the data at the same time. Although this example calls the <code>glFinishFenceAPPLE</code> function almost immediately after setting the fence, in reality you need to separate these calls to allow  parallel operation of the GPU and CPU.  To see how that's done, read <span class="content_text"><a href="opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW10">“Double Buffering Vertex Data.”</a></span>  </p><a name="//apple_ref/doc/uid/TP40001987-CH406-SW2" title="Listing 8-1Using the vertex array range extension with dynamic data"></a><p class="codesample"><strong>Listing 8-1&nbsp;&nbsp;</strong>Using the vertex array range extension with dynamic data</p><div class="codesample"><table><tr><td scope="row"><pre>//  To set up the vertex array range extension<span></span></pre></td></tr><tr><td scope="row"><pre>glVertexArrayParameteriAPPLE(GL_VERTEX_ARRAY_STORAGE_HINT_APPLE, GL_STORAGE_SHARED_APPLE);<span></span></pre></td></tr><tr><td scope="row"><pre>glVertexArrayRangeAPPLE(buffer_size, my_vertex_pointer);<span></span></pre></td></tr><tr><td scope="row"><pre>glEnableClientState(GL_VERTEX_ARRAY_RANGE_APPLE);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>glEnableClientState(GL_VERTEX_ARRAY);<span></span></pre></td></tr><tr><td scope="row"><pre>glVertexPointer(3, GL_FLOAT, 0, my_vertex_pointer);<span></span></pre></td></tr><tr><td scope="row"><pre>glSetFenceAPPLE(my_fence);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//  When you want to draw using the vertex data<span></span></pre></td></tr><tr><td scope="row"><pre>draw_loop {<span></span></pre></td></tr><tr><td scope="row"><pre>    glFinishFenceAPPLE(my_fence);<span></span></pre></td></tr><tr><td scope="row"><pre>    GenerateMyDynamicVertexData(my_vertex_pointer);<span></span></pre></td></tr><tr><td scope="row"><pre>    glFlushVertexArrayRangeAPPLE(buffer_size, my_vertex_pointer);<span></span></pre></td></tr><tr><td scope="row"><pre>    PerformDrawing();<span></span></pre></td></tr><tr><td scope="row"><pre>    glSetFenceAPPLE(my_fence);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 8-2</span> shows code that uses the vertex array range extension with static data. Unlike the setup for dynamic data, the setup for static data includes using the hint for cached data. Because the data is static, it's unnecessary to set a fence.</p><a name="//apple_ref/doc/uid/TP40001987-CH406-SW6" title="Listing 8-2Using the vertex array range extension with static data"></a><p class="codesample"><strong>Listing 8-2&nbsp;&nbsp;</strong>Using the vertex array range extension with static data</p><div class="codesample"><table><tr><td scope="row"><pre>//  To set up the vertex array range extension<span></span></pre></td></tr><tr><td scope="row"><pre>GenerateMyStaticVertexData(my_vertex_pointer);<span></span></pre></td></tr><tr><td scope="row"><pre>glVertexArrayParameteriAPPLE(GL_VERTEX_ARRAY_STORAGE_HINT_APPLE, GL_STORAGE_CACHED_APPLE);<span></span></pre></td></tr><tr><td scope="row"><pre>glVertexArrayRangeAPPLE(array_size, my_vertex_pointer);<span></span></pre></td></tr><tr><td scope="row"><pre>glEnableClientState(GL_VERTEX_ARRAY_RANGE_APPLE);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>glEnableClientState(GL_VERTEX_ARRAY);<span></span></pre></td></tr><tr><td scope="row"><pre>glVertexPointer(3, GL_FLOAT, stride, my_vertex_pointer);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//  When you want to draw using the vertex data<span></span></pre></td></tr><tr><td scope="row"><pre>draw_loop {<span></span></pre></td></tr><tr><td scope="row"><pre>    PerformDrawing();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For detailed information on this extension, see the <span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/APPLE/vertex_array_range.txt" target="_blank">OpenGL specification for the vertex array range extension</a></span>.</p><a name="//apple_ref/doc/uid/TP40001987-CH406-SW18" title="Vertex Buffer Object Extension"></a><h3>Vertex Buffer Object Extension</h3><p>The vertex buffer object extension  (<code>GL_ARB_vertex_buffer_object</code>) can be used along with vertex arrays to improve the throughput of static or dynamic vertex data in your application. A buffer object is a chunk of memory. You can read and write directly to this memory using OpenGL calls such as <code><!--a-->glBufferData<!--/a--></code>, <code><!--a-->glBufferSubData<!--/a--></code>, and <code><!--a-->glGetBufferSubData<!--/a--></code>  or you can access memory through a pointer, an operation referred to as <em>mapping a buffer</em>. </p><p>You can set up and use the vertex buffer object extension by following these steps:</p><ol class="ol"><li class="li"><p>Call the function <code><!--a-->glBindBufferARB<!--/a--></code> to bind an unused name to a buffer object. After this call, the newly created buffer object is initialized with a memory buffer of size zero and a default state. (For the default setting, see the  <span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/ARB/vertex_buffer_object.txt" target="_blank">OpenGL specification for ARB_vertex_buffer_object</a></span>.)</p><div class="codesample"><table><tr><td scope="row"><pre>void glBindBufferARB(GLenum target, GLuint buffer);<span></span></pre></td></tr></table></div><p><code>target</code> must be set to <code>GL_ARRAY_BUFFER_ARB</code>.</p><p><code>buffer</code> specifies the unique name for the buffer object.</p></li><li class="li"><p>So that you can use vertex arrays with the vertex buffer object, enable the vertex array by calling <code><!--a-->glEnableClientState<!--/a--></code> and supplying the <code>GL_VERTEX_ARRAY</code> constant. </p></li><li class="li"><p>Define an array of vertex data by calling a function such as <code><!--a-->glVertexPointer<!--/a--></code>. You need to supply an offset into your data buffer. </p></li><li class="li"><p>Create and initialize the data store of the buffer object by calling the function <code>glBufferDataARB</code>. Essentially, this call uploads your data to the GPU. </p><div class="codesample"><table><tr><td scope="row"><pre>void glBufferDataARB(GLenum target, sizeiptrARB size,<span></span></pre></td></tr><tr><td scope="row"><pre>            const GLvoid *data, GLenum usage);<span></span></pre></td></tr></table></div><p><code>target</code> must be set to <code>GL_ARRAY_BUFFER_ARB</code>.</p><p><code>size</code> specifies the size of the data store.</p><p><code>*data</code> points to the source data. If this is not <code>NULL</code>, the source data is copied to the data store of the buffer object. If <code>NULL</code>, the contents of the data store are undefined.</p><p><code>usage</code> is a constant that provides a hint as to how your application plans to use the data store. You can supply any of nine constants defined by the OpenGL specification. OpenGL uses the hint to optimize performance, not to constrain your use of the data. You'll see two of these constants in the examples that follow: <code>GL_STREAM_DRAW_ARB</code>, which indicates that the application plans to draw with the data repeatedly and to modify the data, and <code>GL_STATIC_DRAW_ARB</code>, which indicates that the application will define the data once but use it to draw many times.</p></li><li class="li"><p>Map the data store of the buffer object to your application address space by calling the function  <code>glMapBufferARB</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>void *glMapBufferARB(GLenum target, GLenum access);<span></span></pre></td></tr></table></div><p><code>target</code> must be set to  <code>GL_ARRAY_BUFFER_ARB</code>.</p><p><code>access</code> indicates the operations you plan to perform on the data. You can supply <code>READ_ONLY_ARB</code>, <code>WRITE_ONLY_ARB</code>, or <code>READ_WRITE_ARB</code>.</p></li><li class="li"><p>Write the vertex data to its destination.</p></li><li class="li"><p>When you no longer need the vertex data, call the function <code>glUnmapBufferARB</code>. You must supply <code>GL_ARRAY_BUFFER_ARB</code> as the parameter to this function.</p></li></ol><p><span class="content_text">Listing 8-3</span> shows code that uses the vertex buffer object extension for dynamic data. This example  overwrites all of the vertex data during every draw operation. </p><a name="//apple_ref/doc/uid/TP40001987-CH406-SW9" title="Listing 8-3Using the vertex buffer object extension with dynamic data"></a><p class="codesample"><strong>Listing 8-3&nbsp;&nbsp;</strong>Using the vertex buffer object extension with dynamic data</p><div class="codesample"><table><tr><td scope="row"><pre>//  To set up the vertex buffer object extension<span></span></pre></td></tr><tr><td scope="row"><pre>#define BUFFER_OFFSET(i) ((char*)NULL + (i))<span></span></pre></td></tr><tr><td scope="row"><pre>glBindBufferARB(GL_ARRAY_BUFFER_ARB, myBufferName);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>glEnableClientState(GL_VERTEX_ARRAY);<span></span></pre></td></tr><tr><td scope="row"><pre>glVertexPointer(3, GL_FLOAT, stride, BUFFER_OFFSET(0));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//  When you want to draw using the vertex data<span></span></pre></td></tr><tr><td scope="row"><pre>draw_loop {<span></span></pre></td></tr><tr><td scope="row"><pre>    glBufferDataARB(GL_ARRAY_BUFFER_ARB, bufferSize, NULL, GL_STREAM_DRAW_ARB);<span></span></pre></td></tr><tr><td scope="row"><pre>    my_vertex_pointer = glMapBufferARB(GL_ARRAY_BUFFER_ARB, GL_WRITE_ONLY_ARB);<span></span></pre></td></tr><tr><td scope="row"><pre>    GenerateMyDynamicVertexData(my_vertex_pointer);<span></span></pre></td></tr><tr><td scope="row"><pre>    glUnmapBufferARB(GL_ARRAY_BUFFER_ARB);<span></span></pre></td></tr><tr><td scope="row"><pre>    PerformDrawing();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 8-4</span> shows codes that uses the vertex buffer object extension with static data.</p><a name="//apple_ref/doc/uid/TP40001987-CH406-SW8" title="Listing 8-4 Using the vertex buffer object extension with static data"></a><p class="codesample"><strong>Listing 8-4&nbsp;&nbsp;</strong> Using the vertex buffer object extension with static data</p><div class="codesample"><table><tr><td scope="row"><pre>//  To set up the vertex buffer object extension<span></span></pre></td></tr><tr><td scope="row"><pre>#define BUFFER_OFFSET(i) ((char*)NULL + (i))<span></span></pre></td></tr><tr><td scope="row"><pre>glBindBufferARB(GL_ARRAY_BUFFER_ARB, myBufferName);<span></span></pre></td></tr><tr><td scope="row"><pre>glBufferDataARB(GL_ARRAY_BUFFER_ARB, bufferSize, NULL, GL_STATIC_DRAW_ARB);<span></span></pre></td></tr><tr><td scope="row"><pre>GLvoid* my_vertex_pointer = glMapBufferARB(GL_ARRAY_BUFFER_ARB, GL_WRITE_ONLY_ARB);<span></span></pre></td></tr><tr><td scope="row"><pre>GenerateMyStaticVertexData(my_vertex_pointer);<span></span></pre></td></tr><tr><td scope="row"><pre>glUnmapBufferARB(GL_ARRAY_BUFFER_ARB);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>glEnableClientState(GL_VERTEX_ARRAY);<span></span></pre></td></tr><tr><td scope="row"><pre>glVertexPointer(3, GL_FLOAT, stride, BUFFER_OFFSET(0));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//  When you want to draw using the vertex data<span></span></pre></td></tr><tr><td scope="row"><pre>draw_loop {<span></span></pre></td></tr><tr><td scope="row"><pre>    PerformDrawing();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For detailed information on this extension, see the <span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/ARB/vertex_buffer_object.txt" target="_blank">OpenGL specification for the vertex buffer object extension</a></span>.</p><a name="//apple_ref/doc/uid/TP40001987-CH406-SW1" title="Fence Extension"></a><h3>Fence Extension</h3><p>The fence extension (<code>APPLE_fence</code>) is designed to synchronize drawing commands with modifications that you make to vertex data. A <strong>fence</strong> is a token used to mark the current point in the command stream. When used correctly, it allows you to ensure that drawing with a range of vertex array data (whether it's the entire set or a subset) is complete before you modify the data. When you use the fence you must synchronize the data. </p><p>This extension was created because the OpenGL commands <code>glFlush</code> and <code>glFinish</code> don't offer the level of granularity that is often needed to synchronize drawing and data modifications. A fence can help you coordinate activity between the  CPU and the GPU when they are using the same resources. You'll want to use a fence when you are using the vertex array range extension for dynamic data. You do not need to use a fence for vertex buffer objects, but you do need to use a fence when you use the vertex array range extension and the shared memory hint.</p><p>Follow these steps to set up and use a fence:</p><ol class="ol"><li class="li"><p>Set up the fence by calling the function <code>glSetFenceApple</code>. This function inserts a token into the command stream and sets the fence state to <code>false</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>void glSetFenceAPPLE(GLuint fence);<span></span></pre></td></tr></table></div><p><code>fence</code> specifies the token to insert. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>GLint myFence = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>glSetFenceAPPLE(myFence);<span></span></pre></td></tr></table></div></li><li class="li"><p>Wait for all OpenGL commands issued prior to the fence to complete by calling the function <code>glFinishFenceApple</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>void glFinishFenceAPPLE(GLuint fence);<span></span></pre></td></tr></table></div><p><code>fence</code> specifies the token that was inserted previously. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>glFinishFenceAPPLE(myFence);<span></span></pre></td></tr></table></div></li></ol><p>There is an art to determining where to insert a fence in the command stream. If you insert a fence for too few drawing commands, you risk having your application stall while it waits for drawing to complete. You'll want to set a fence so your application operates as asynchronously as possible without stalling. </p><p>The fence extension also lets you synchronize  buffer updates for objects such as vertex arrays and textures. For that you call the function <code>glFinishObjectAPPLE</code>, supplying an object name along with the token.</p><p>For detailed information on this extension, see the <span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/APPLE/fence.txt" target="_blank">OpenGL specification for the Apple fence extension</a></span>.</p><a name="//apple_ref/doc/uid/TP40001987-CH406-SW10" title="Double Buffering Vertex Data"></a><h2>Double Buffering Vertex Data</h2><p>When you use the vertex array range extension and the shared memory hint, the GPU reads data directly from memory managed by your application. To avoid having the GPU and your application access the data at the same time, you'll need to synchronize access. A simple approach is for your application to operate  on the vertex array data, flush  it to the GPU, and wait  until the GPU is finished before working on the data again. This is what  <span class="content_text">Figure 8-6</span> shows.</p><p>To ensure that the GPU is finished executing commands before the CPU sends more data, you can insert a token into the command stream and use that to determine when the CPU can touch the data again, as described in <span class="content_text"><a href="opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW1">“Fence Extension.”</a></span> <span class="content_text">Figure 8-6</span> uses the fence extension command <code>glFinishObject</code> to synchronize buffer updates. Notice that when the CPU is processing data, the GPU is waiting. Similarly, when the GPU is processing data, the CPU is waiting. In other words, the application executes synchronously. A more efficient way is for the application to double buffer your data so that you can use the waiting time to process more data.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH406-SW15" title="Figure 8-6Single-buffered vertex array data"></a><p><strong>Figure 8-6&nbsp;&nbsp;</strong>Single-buffered vertex array data</p><img src = "../art/single_buffered_data.jpg" alt = "Single-buffered vertex array data" ></div><br/><p>To double buffer your data, you must supply two sets of data to work on. Notice in <span class="content_text">Figure 8-7</span>  that while the GPU is operating on one set of vertex array data, the CPU is processing the next. After the initial startup, neither processing unit is idle.  Using the <code>glFinishObject</code> function provided by the fence extension, as shown, ensures that buffer updates are synchronized</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH406-SW11" title="Figure 8-7Double-buffered vertex array data"></a><p><strong>Figure 8-7&nbsp;&nbsp;</strong>Double-buffered vertex array data</p><img src = "../art/double_buffered_data.jpg" alt = "Double-buffered vertex array data" ></div><br/><a name="//apple_ref/doc/uid/TP40001987-CH406-SW19" title="See Also"></a><h2>See Also</h2><p>OpenGL extension specifications:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/APPLE/vertex_array_range.txt" target="_blank">APPLE_vertex_array_range</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/ARB/vertex_buffer_object.txt" target="_blank">ARB_vertex_buffer_object</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/APPLE/fence.txt" target="_blank">APPLE_fence</a></span></p></li></ul><p>OpenGL sample code projects (<span class="content_text"><a href="../../../../../samplecode/GraphicsImaging/idxOpenGL-date.html#//apple_ref/doc/uid/TP30000925-TP30000424-TP30000549" target="_top">Sample Code > Graphics &amp; Imaging > OpenGL</a></span>):</p><ul class="ul"><li class="li"><p><em><a href="../../../../../samplecode/Vertex_Optimization/index.html#//apple_ref/doc/uid/DTS10000553" target="_top">Vertex Optimization</a></em> demonstrates different ways to optimize vertex programs.</p></li><li class="li"><p><em><a href="../../../../../samplecode/VertexPerformanceTest/index.html#//apple_ref/doc/uid/DTS10000554" target="_top">VertexPerformanceTest</a></em> shows slow and fast vertex data paths.</p></li><li class="li"><p><em><a href="../../../../../samplecode/VertexPerformanceDemo/index.html#//apple_ref/doc/uid/DTS10003726" target="_top">VertexPerformanceDemo</a></em> measures triangle throughput and compares different coding methods.</p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_pixelformats/opengl_pixelformats.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_texturedata/opengl_texturedata.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-06-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_vertexdata/opengl_vertexdata.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_vertexdata/opengl_vertexdata.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_vertexdata/opengl_vertexdata.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>