<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Outlining the Current List (IM: MTb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING218></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MoreToolbox-217.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-219.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MoreToolbox-2.html"><B>More Macintosh Toolbox</B></A> / <BR><DD><A HREF="MoreToolbox-202.html"><B>Chapter 4 - List Manager</B></A> / <A HREF="MoreToolbox-209.html"><B>Using the List Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING218-0></A>
<H2><A NAME=MARKER-9-312></A>Outlining the Current List<A NAME=MARKER-2-176></A><A NAME=MARKER-9-149></A></H2>
 If a window in your application contains two lists, or contains one list and an editable text item, then your application should place a 2-pixel outline around a list whenever the list is the current list and active, that is, whenever typing would affect the list. Your application should outline the current list so that the user knows that typing affects the list.<P>
 <A HREF=#MARKER-9-262>Listing 4-23</A> shows an application-defined procedure that checks whether a list is the current list. If it is both current and active, it draws a 2-pixel outline around the list. Otherwise, it draws in the background color of the dialog box to remove the outline.<P>
<B>Listing 4-23  <A NAME=MARKER-9-262></A>Drawing an outline around a list<A NAME=MARKER-2-263></A></B><P>
<PRE>
PROCEDURE MyDrawOutline (myList: ListHandle);
CONST
   kScrollBarWidth = 15;         {width of scroll bar}
VAR
   myOutlineRect:    Rect;       {rectangle for outline border}
   myPenState:       PenState;   {current status of pen}
BEGIN
   {get list's visible rectangle}
   myOutlineRect := myList^^.rView;
   {compensate for scroll bars}
   IF myList^^.vScroll &lt;&gt; NIL THEN
      myOutlineRect.right := myOutlineRect.right 
                              + kScrollBarWidth;
   IF myList^^.hScroll &lt;&gt; NIL THEN
      myOutlineRect.bottom := myOutlineRect.bottom 
                              + kScrollBarWidth;
   {draw 2-pixel outline 3 pixels from border}
   SetPort(myList^^.port);       {set port to list's port}
                                 {move out 4 pixels}
   InsetRect(myOutlineRect, -4, -4);
   GetPenState(myPenState);      {store pen state}
   IF (myList = gCurrentList) AND myList^^.lActive THEN
      PenPat(black)              {draw border}
   ELSE
      PenPat(white);             {remove border}
   PenSize(2, 2);                {use 2-pixel pen}
   FrameRect(myOutlineRect);     {draw outline}
   SetPenState(myPenState);      {restore old pen state}
END;
</PRE>
 The <CODE>MyDrawOutline</CODE> procedure defined in <A HREF=#MARKER-9-262>Listing 4-23</A> determines the rectangle to draw in by adjusting the list's visible rectangle to compensate for scroll bars and by then moving each side of the rectangle 4 pixels. (One pixel is already taken by the list border, an additional pixel is needed for space between the border and the outline, and the pen size for the outline is 2 pixels.) The list determines whether to draw or remove a list by comparing the list passed in with an an application-defined global variable, <CODE>gCurrentList</CODE>. If the variable indicates that a list is the current list, and the <CODE>MyDrawOutline</CODE> procedure determines that the list is active, then it draws the outline; otherwise, it removes it.<P>
 Your application can use the <CODE>refCon</CODE> field of the list record to create a linked ring list of all of the lists in a window to make it easier to support outlining. That is, the <CODE>refCon</CODE> field of the first list in a window contains a handle to the second list in a window; the <CODE>refCon</CODE> field of the second list in a window contains a handle to the third, and so on, until the <CODE>refCon</CODE> field of the last list in a window contains a handle to the first. <P>
 The advantage of implementing such a ring list is that it makes it easy to change which list is the current list. In response to a Tab-key event, your application need only find the next list in a window by looking at the current list's <CODE>refCon</CODE> field and setting the <CODE>gCurrentList</CODE> variable to the list referenced by that field. Without using such a strategy, your application would need to examine the <CODE>gCurrentList</CODE> variable, determine which of a window's lists the variable corresponded to, determine which list in the window is the next list, and then set the <CODE>gCurrentList</CODE> variable to this next list. <P>
 <A HREF=#MARKER-9-264>Listing 4-24</A> shows an application-defined procedure that adds a list to a ring being maintained for a particular window. <P>
<B>Listing 4-24  <A NAME=MARKER-9-264></A>Adding a list to the ring<A NAME=MARKER-2-265></A></B><P>
<PRE>
PROCEDURE MyTrackList (myList: ListHandle);
VAR
   aList:      ListHandle;
BEGIN
   aList := gCurrentList;
   IF aList = NIL THEN
      gCurrentList := myList     {first ListHandle to be tracked}
   ELSE
   BEGIN
      {look for last ListHandle in ring}
      WHILE (ListHandle(aList^^.refCon) &lt;&gt; gCurrentList) DO
         {move to next ListHandle in ring}
         aList^^.refCon := ListHandle(aList^^.refCon)^^.refCon;
      {insert myList into ring}
      ListHandle(aList^^.refCon) := myList;
   END;
   {add link from myList to current list}
   ListHandle(myList^^.refCon) := gCurrentList;
END;
</PRE>
 The SurfWriter application calls the <CODE>MyTrackList</CODE> procedure defined in <A HREF=#MARKER-9-264>Listing 4-24</A> once for each list in a window when it first opens that window. The first list added to the ring is automatically set to be the current list. SurfWriter initializes the <CODE>gCurrentList</CODE> variable to <CODE>NIL</CODE> before creating a ring for each window that uses multiple lists. In addition, SurfWriter stores the value of the <CODE>gCurrentList</CODE> variable whenever a window containing multiple lists is deactivated and then resets it when the window is activated again. That way, the <CODE>gCurrentList</CODE> variable always stores a handle to the current list of the active window.<P>
 Once all the lists in a window are linked in a ring, it is easy to write a routine that ensures that only the current list is outlined. <A HREF=#MARKER-9-266>Listing 4-25</A> illustrates such a routine.<P>
<B>Listing 4-25  <A NAME=MARKER-9-266></A>Updating the outline of all lists in a window<A NAME=MARKER-2-267></A></B><P>
<PRE>
PROCEDURE MyUpdateListOutlines;
VAR
   listToUpdate:     ListHandle;
BEGIN
   listToUpdate := gCurrentList;
   IF listToUpdate &lt;&gt; NIL THEN
   REPEAT
      {move to next list in ring}
      listToUpdate := ListHandle(listToUpdate^^.refCon);
      MyDrawOutline(listToUpdate);
   UNTIL listToUpdate = gCurrentList;
END;
</PRE>
 The <CODE>MyUpdateListOutlines</CODE> procedure defined in <A HREF=#MARKER-9-266>Listing 4-25</A> simply calls the <CODE>MyDrawOutline</CODE> procedure for each list in the active window's ring of lists. The SurfWriter application calls this procedure each time your application changes which list is current.<P>
 <A HREF=#MARKER-9-269>Listing 4-26</A> shows an application-defined procedure that responds to the user's pressing the Tab key when the Shift key is not also pressed. <A NAME=MARKER-2-257></A><P>
<B>Listing 4-26  <A NAME=MARKER-9-269></A>Moving the outline to the next list in a window<A NAME=MARKER-2-270></A></B><P>
<PRE>
PROCEDURE MyOutlineNextList;
BEGIN
   gCurrentList := ListHandle(gCurrentList^^.refCon);
   MyUpdateListOutlines;
END;
</PRE>
 If the user presses Shift-Tab, your application should respond by changing the current list to the previous list. <A HREF=#MARKER-9-271>Listing 4-27</A> shows an application-defined procedure that does this.<P>
<B>Listing 4-27  <A NAME=MARKER-9-271></A>Moving the outline to the previous list in a window<A NAME=MARKER-2-272></A></B><P>
<PRE>
PROCEDURE MyOutlinePreviousList;
VAR
   previousList:     ListHandle;
BEGIN
   {compute the coordinates of the list before the current list}
   previousList := gCurrentList;
   WHILE (ListHandle(previousList^^.refCon) &lt;&gt; gCurrentList) DO
      previousList := ListHandle(previousList^^.refCon);
   {now switch the outline to this list}
   gCurrentList := previousList;
   MyUpdateListOutlines;
END;
</PRE>
 The <CODE>MyOutlineNextList</CODE> and <CODE>MyOutlinePreviousList</CODE> procedures defined in <A HREF=#MARKER-9-269>Listing 4-26</A> and <A HREF=#MARKER-9-271>Listing 4-27</A> work the same if a window contains exactly two lists.<A NAME=MARKER-2-260></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MoreToolbox-217.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-219.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MoreToolbox-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>   
