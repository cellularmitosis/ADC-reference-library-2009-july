<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- BEGIN META TAG INFO --><link rel="home" href="http://developer.apple.com/">
<link rel="find" href="http://developer.apple.com/search/">
<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
<script language="JavaScript" type="text/javascript" src="../../documentation/js/busnav.js"></script><script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script><!-- END META TAG INFO --><!-- BEGIN TITLE --><title>Technical Note TN2178: Real world profiling with the OpenGL Profiler</title>
<!-- END TITLE --><style>
			.sourcecodebox {
				white-space: pre-wrap;
				white-space: -moz-pre-wrap !important;
				white-space: -pre-wrap;
				white-space: -o-pre-wrap;
				word-wrap: break-word;
			}
			</style>
</head>
<!-- BEGIN BODY OPEN --><body bgcolor="#ffffff"><a name="//apple_ref/doc/uid/DTS40007990" title="Real world profiling with the OpenGL Profiler"></a>
<!-- END BODY OPEN --><!-- START CENTER OPEN --><center>
<!-- END CENTER OPEN --><a name="top"></a><!-- BEGIN LOGO AND SEARCH --><!--#include virtual="/includes/adcnavbar" --><!-- END LOGO AND SEARCH --><!-- START BREADCRUMB --><div id="breadcrumb"><table width="680" border="0" cellpadding="0" cellspacing="0">
<tr>
<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
</tr>
<tr valign="middle"><td align="left" colspan="2">
<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/GraphicsImaging/index.html">Graphics &amp; Imaging</a> &gt; <a href="../../technicalnotes/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; </td></tr>
<tr><td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td></tr>
</table></div>
<!-- END BREADCRUMB --><!-- START MAIN CONTENT --><!-- START TITLE GRAPHIC AND INTRO --><table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td><h1>
<div id="pagehead">Technical Note TN2178</div>
<div id="pageheadsub">Real world profiling with the OpenGL Profiler</div>
</h1></td></tr></table>
<!-- END TITLE GRAPHIC AND INTRO --><!-- BEGIN WIDE COLUMN --><table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td align="left" width="680">
<!-- BEGIN CONTENTS --><table width="680" border="0" cellpadding="0" cellspacing="0">
<tr align="left" valign="top"><td><p>OpenGL Profiler is a very powerful tool for debugging and optimizing OpenGL in Mac OS X. This technote describes basic usage of OpenGL  Profiler as well as some real world techniques for application analysis and more advanced topics for more specific testing and profiling. The content of this document describes OpenGL Profiler v.4 which is included in Mac OS X Leopard but should help you use the previous versions as well.</p></td></tr>
<tr><td scope="row">
<img width="680" height="10" src="images/1dot.gif" alt=""><br><img width="680" height="1" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt="">
</td></tr>
</table>
<table width="680" border="0" cellpadding="0" cellspacing="0">
<tr align="left" valign="top"><td width="680"><ul>
<li><a href="#TNTAG1">Getting Started</a></li>
<ul>
<li><a href="#TNTAG12">The Main Window launch or attach</a></li>
<ul>
<li><a href="#TNTAG62">Launching an application with Profiler</a></li>
<li><a href="#TNTAG63">Attaching to a running application</a></li>
</ul>
<li><a href="#TNTAG8">Collecting an OpenGL call trace</a></li>
<ul><li><a href="#TNTAG60">Saving a Trace to a text file</a></li></ul>
<li><a href="#TNTAG65">Collecting OpenGL call statistics</a></li>
<ul><li><a href="#TNTAG59">Saving statistics to a text file</a></li></ul>
<li><a href="#TNTAG17">Checking the Pixel Format</a></li>
<li><a href="#TNTAG4">Setting breakpoints</a></li>
<li><a href="#TNTAG66">Controlling execution</a></li>
<li><a href="#TNTAG9">Inspecting OpenGL state</a></li>
<li><a href="#TNTAG7">Viewing Resources</a></li>
<ul>
<li><a href="#TNTAG78">Textures</a></li>
<li><a href="#TNTAG34">ARB Programs</a></li>
<li><a href="#TNTAG35">GLSL Shaders</a></li>
<li><a href="#TNTAG36">FBOs</a></li>
<li><a href="#TNTAG37">Renderbuffers</a></li>
<li><a href="#TNTAG38">VBOs</a></li>
<li><a href="#TNTAG39">VAOs</a></li>
</ul>
<li><a href="#TNTAG22">Buffer Views</a></li>
<ul>
<li><a href="#TNTAG42">Back bufffer</a></li>
<li><a href="#TNTAG43">Depth buffer</a></li>
<li><a href="#TNTAG44">Alpha buffer</a></li>
<li><a href="#TNTAG45">Stencil buffer</a></li>
</ul>
</ul>
<li><a href="#TNTAG13">Real World Techniques</a></li>
<ul>
<li><a href="#TNTAG67">Checking the Application for Errors</a></li>
<li><a href="#TNTAG11">Checking GPU or CPU execution of current state</a></li>
<li><a href="#TNTAG2">Collecting Trace and Statistics for a single frame</a></li>
<li><a href="#TNTAG3">Enabling Multithreaded execution of the OpenGL Framework</a></li>
<li><a href="#TNTAG14">Monitoring VRAM with Driver Monitor</a></li>
<li><a href="#TNTAG15">Editing shaders</a></li>
<li><a href="#TNTAG69">Disabling OpenGL Execution</a></li>
<li><a href="#TNTAG47">Attaching and running scripts at breakpoints</a></li>
<li><a href="#TNTAG55">Trace Filtering</a></li>
<li><a href="#TNTAG56">Launching with a custom pixel format </a></li>
</ul>
<li><a href="#TNTAG16">Programatic control of OpenGL Profiler</a></li>
<ul>
<li><a href="#TNTAG51">Controlling breakpoints</a></li>
<li><a href="#TNTAG71">Inserting comments in the Trace view</a></li>
<li><a href="#TNTAG33">Controlling the trace logging</a></li>
<li><a href="#TNTAG76">Controlling the collection of statistics</a></li>
</ul>
<li><a href="#TNTAG50">OpenGL Profiler Preferences</a></li>
<li><a href="#document_revision_summary">Document Revision History</a></li>
</ul></td></tr>
<tr><td colspan="3" scope="row">
<img width="680" height="10" src="images/1dot.gif" alt=""><br><img width="680" height="1" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt="">
</td></tr>
</table>
<a name="TNTAG1"></a><h2>Getting Started</h2>
<p>OpenGL Profiler is located at /Developer/Applications/Graphics Tools.</p>
<p>The first time you open OpenGL Profiler, it will give you a choice to enable attaching to running applications as shown in <a href="#TNTAG5">Figure 1</a>.</p>
<p>If you click enable Profiler will set the <code>GL_ENABLE_DEBUG_ATTACH</code> environment variable, which will take effect in the next login. Go ahead and enable it. </p>
<a name="TNTAG5"></a><p class="caption"><strong>Figure 1: </strong>Enabling Profiler Attaching.</p>
<p><img src="images/tn2178_EnableProfilerAttachWindow.png" width="465" height="264" alt="Figure 1, Enabling Profiler Attaching."></p>
<a name="TNTAG12"></a><h3>The Main Window launch or attach</h3>
<p>There are 2 ways to analyze an application, by attaching to a running instance or by launching within Profiler. </p>
<a name="TNTAG62"></a><h4>Launching an application with Profiler</h4>
<p>The main window with <strong> Launch application </strong>selected as shown in <a href="#TNTAG6">Figure 2</a> is where you can drag and drop your application bundle, or you can press the <strong>"+"</strong> button to add it in the open panel. Select the application name in the table, and press the <strong>Launch</strong> button to start the application. Also, you can click on the Launch Arguments field and add any arguments needed for the application prior to launching it.</p>
<p>Once running you can start to see the instant and peak <strong>Frame Rate</strong>. </p>
<p>The default update time of 5 secs for the frame rate display can be changed in the Preferences as shown in <a href="#TNTAG50">OpenGL Profiler Preferences</a>.</p>
<div class="notebox"><p><strong>Note: </strong>The frame rate field is updated by counting <code>CGLFlushDrawable</code> per unit of time, if your application is not double buffered this field might not display the correct information</p></div>
<a name="TNTAG6"></a><p class="caption"><strong>Figure 2: </strong>Launching an application within Profiler.</p>
<p><img src="images/tn2178_MainWindowLaunch.png" width="582" height="311" alt="Figure 2, Launching an application within Profiler."></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG63"></a><h4>Attaching to a running application</h4>
<p>There might be times when attaching to a running application is more convenient, and this can be done by selecting <strong>Attach to application </strong>, choosing the appropriate process and the clicking the <strong>Attach</strong> button as shown in <a href="#TNTAG10">Figure 3</a>.</p>
<a name="TNTAG10"></a><p class="caption"><strong>Figure 3: </strong>Attaching to a running application.</p>
<p><img src="images/tn2178_ProfilerMainWindowLaunch.png" width="582" height="311" alt="Figure 3, Attaching to a running application."></p>
<div class="notebox"><p><strong>Note: </strong>If an error as shown in <a href="#TNTAG58">Figure 4</a> is presented at this time, the most likely cause is that the environment variable <code>GL_ENABLE_DEBUG_ATTACH</code> is not set, or you have not logged out and logged back in after enabling the attach feature upon the very first launch of OpenGL Profiler. A similar message will be presented if trying to launch an application that is no longer at the provided path.</p></div>
<a name="TNTAG58"></a><p class="caption"><strong>Figure 4: </strong>Launch or attach error</p>
<p><img src="images/tn2178_AttachError.png" width="452" height="185" alt="Figure 4, Launch or attach error"></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG8"></a><h3>Collecting an OpenGL call trace</h3>
<p>Once you have launched or attached to an application, you can collect statistics and trace view of the OpenGL commands submitted by your application.</p>
<p>To collect an OpenGL trace simply select <strong>Trace</strong> under the <strong>Views</strong> menu or press <strong>Command-Option-T</strong>.</p>
<p>The trace view is very useful to analyze the sequence of operations as well as to identify redundant calls or state mishandling.</p>
<p><a href="#TNTAG61">Figure 5</a> shows a trace window with Lines #'s, Contexts and Timing information selected.</p>
<a name="TNTAG61"></a><p class="caption"><strong>Figure 5: </strong>Trace window.</p>
<p><img src="images/tn2178_TraceView.png" width="640" height="578" alt="Figure 5, Trace window."></p>
<p>You can also collect backtraces by selecting <strong>Include Backtraces</strong> on the Profiler's main window. </p>
<p>This will collect backtraces with function names, so you can see who is calling a particularly slow call by clicking on the function name as shown in <a href="#TNTAG64">Figure 6</a>. You may right click on it and choose to view the original image in a new window or tab.</p>
<a name="TNTAG64"></a><p class="caption"><strong>Figure 6: </strong>Trace view with call stack</p>
<p><img src="images/tn2178_TraceView_callstack.png" width="640" height="408" alt="Figure 6, Trace view with call stack"></p>
<a name="TNTAG60"></a><h4>Saving a Trace to a text file</h4>
<p>The call trace can be saved to a text file for post processing by clicking on <strong>Save As Text</strong></p>
<p>Traces can be long and might take some time to finish saving a text file which can get really large.</p>
<p>With Line #'s, Context and Timing selected the generated text file looks like: </p>
<pre class="sourcecodebox">1: 0x00a2d400     0.18 µs glBegin(GL_QUADS);
2: 0x00a2d400     0.08 µs glTexCoord2f(0.025, 0.025);
3: 0x00a2d400     0.08 µs glNormal3f(0, 0, 1);
4: 0x00a2d400     1.19 µs glVertex3f(0, 0.03, 3.15);
5: 0x00a2d400     0.10 µs glVertex3f(0.03, 0, 3.15);
6: 0x00a2d400     0.10 µs glVertex3f(0, -0.03, 3.15);
7: 0x00a2d400     0.08 µs glVertex3f(-0.03, 0, 3.15);
8: 0x00a2d400     0.07 µs glNormal3f(0, 0, -1);
9: 0x00a2d400     0.10 µs glVertex3f(-0.03, 0, 0);
10: 0x00a2d400     0.08 µs glVertex3f(0, -0.03, 0);
11: 0x00a2d400     0.08 µs glVertex3f(0.03, 0, 0);
12: 0x00a2d400     0.09 µs glVertex3f(0, 0.03, 0);</pre>
<p>For information on the <strong>Save Using Filter</strong> see section <a href="#TNTAG55">Trace Filtering</a></p>
<div class="notebox"><p><strong>Note: </strong>Collecting traces and backtraces is a very heavy operation and it will slow down your rendering, so this feature is designed to analyze relatively small portions of an application.</p></div>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG65"></a><h3>Collecting OpenGL call statistics</h3>
<p>To collect statistics simply select <strong>Statistics</strong> under the <strong>Views</strong> menu or press <strong>Command-Option-S</strong>.</p>
<p>The window presents a table of information that can be reordered by clicking on the column heading.</p>
<p>The statistics view is great to see the estimated % of time spent in GL as a total, the percentages of time spent in GL per call and the percentage of App time that a particular call is taking as well as how many times a function is being called.</p>
<p>The "% App Time" field shows an estimate of how much time the application spends in a particular function. This is calculated by timing the each GL call and diving the cummulative results by the total application running time. Managing the timing of the GL calls might skew the numbers a few percentage points but the results are still representative. Shark might give you a more accurate number. </p>
<p>The "% GL Time" is an estimate based on the time a particular function takes in relation to the total time spent inside OpenGL.</p>
<p>Also the statistics can be scrolled in different time slices by using the <strong>Show slice</strong> at the bottom of the window.</p>
<p><a href="#TNTAG32">Figure 7</a> shows the statistics window sorted by the largest <strong>Total Time </strong> spent in a function.</p>
<a name="TNTAG32"></a><p class="caption"><strong>Figure 7: </strong>Statistics window</p>
<p><img src="images/tn2178_StatisticsView.png" width="640" height="541" alt="Figure 7, Statistics window"></p>
<a name="TNTAG59"></a><h4>Saving statistics to a text file</h4>
<p>In the same way you can save a call trace to a text file, you can do the same for the statistics, and the text file takes the form:</p>
<pre class="sourcecodebox">GL Function;# of Calls;Total Time (µsec);Avg Time (µsec);% GL Time;% App Time
...</pre>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG17"></a><h3>Checking the Pixel Format</h3>
<p>Sometimes it is useful to examine the pixel format of a context and Profiler allows you to do just that in the <strong>Pixel Format </strong> selection under the <strong>Views </strong> menu or press <strong>Command-Option-P </strong></p>
<p>If there are multiple contexts, the one in black is the current context.</p>
<p>Among other things, this is where you look to see if an OpenGL context is double buffered, antialiased, etc.</p>
<p><a href="#TNTAG18">Figure 8</a> shows what the Pixel Format window looks like. </p>
<a name="TNTAG18"></a><p class="caption"><strong>Figure 8: </strong>Pixel Format View</p>
<p><img src="images/tn2178_PixelFormatView.png" width="422" height="772" alt="Figure 8, Pixel Format View"></p>
<p>There is also a way to override the pixel format that an application asks for with a custom temporary pixel format and this is shown in <a href="#TNTAG56">Launching with a custom pixel format </a></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG4"></a><h3>Setting breakpoints</h3>
<p>One of the most powerful features of OpenGL Profiler is the ability to set breakpoints at which resources (textures, ...), GL state, scripts can be run, the multithreaded engine can be enabled, or even see if the current setup is going to run in the CPU or GPU,.</p>
<p>Profiler also allows you to control the execution (or bypass) at the OpenGL function level.</p>
<p>You can set breakpoints by selecting the <strong>Breakpoints </strong> option of <strong>Views </strong>menu or you can press <strong>Command-Option-B </strong>.</p>
<p><a href="#TNTAG49">Figure 9</a> shows the breakpoints window.</p>
<p>Breakpoints can be set before or after executing a particular call, at a GL error, VAR error, thread conflict, and software fallback.</p>
<p>To set a breakpoint at a particular call, click under <strong>before </strong> or <strong>after </strong> on the line of the particular function of interest. To quickly scroll to a particular GL call you can type the first few letters of the particular function your are interested in.</p>
<p>To set a breakpoint in any GL errors simply click on the <strong>Break on Error </strong> button, similarly for <strong>Break on VAR error </strong>, <strong>Break on thread conflict </strong> and <strong>Break on SW fallback</strong>.</p>
<a name="TNTAG49"></a><p class="caption"><strong>Figure 9: </strong>Breakpoint window.</p>
<p><img src="images/tn2178_BreakpointsWindow.png" width="640" height="472" alt="Figure 9, Breakpoint window."></p>
<p>Once the application hits the breakpoint the call stack, context, <code>kCGLCPGPUFragmentProcessing</code> (fragment processing on the GPU), <code>kCGLCPGPUVertexProcessing</code> (vertex processing on the GPU) and <code>kCGLCPCurrentRendererID</code> (see /System/Library/Frameworks/OpenGL.framework/Headers/CGLRenderers.h) are presented. </p>
<p>In the event of a break for GL error, VAR error or thread conflict there is a useful status message at the bottom of the Call Stack view.</p>
<p>The <strong>Actions </strong> pop up allows you set and reset all breakpoints. It also allows you to attach scripts to execute at a breakpoint. This feature is discussed at <a href="#TNTAG47">Attaching and running scripts at breakpoints</a>.</p>
<p><a href="#TNTAG48">Figure 10</a> shows an application stopped at <code>CGLFlushDrawable</code> with everything running on the GPU at that point. </p>
<a name="TNTAG48"></a><p class="caption"><strong>Figure 10: </strong>Stopped at <code>CGLFlushDrawable</code>.</p>
<p><img src="images/tn2178_BreakPointAtCGLFlushDrawable.png" width="640" height="472" alt="Figure 10, Stopped at CGLFlushDrawable."></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG66"></a><h3>Controlling execution</h3>
<p>Execution of a particular call is done by the selection of <strong>Execute </strong> on the line of that particular call. By default all OpenGL calls are set to execute. The <strong>Actions </strong> pop up  allows you to set or reset global execution. </p>
<p>If a call is set to not execute, it becomes a noop and the consequences of this vary greatly depending on many factors. This functionality should only be used when the code, traces, etc are understood. </p>
<p>Sometimes is necessary to set breakpoints but ignore them for a period of time, this can be achieved by enabling the <strong>Ignore all breakpoints </strong> button.</p>
<p>To continue execution click on the <strong>Continue </strong>button at the lower right hand corner of the <strong>Breakpoints </strong> window.</p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG9"></a><h3>Inspecting OpenGL state</h3>
<p>The current OpenGL state can be checked at breakpoints by clicking on the <strong>State </strong> tab of the breakpoints window. </p>
<p>This is very useful when rendering anomalies are encountered, for state sorting ideas, etc.</p>
<p><a href="#TNTAG46">Figure 11</a> shows the state right before a <code>CGLFlushDrawable</code>, the blue highlighted state is the state that has changed <strong>From default state </strong>. </p>
<a name="TNTAG46"></a><p class="caption"><strong>Figure 11: </strong>Highlighted changes from default GL state.</p>
<p><img src="images/tn2178_BreakPointsView_GLState.png" width="640" height="472" alt="Figure 11, Highlighted changes from default GL state."></p>
<p>Although not pictured if <strong>Since last breakpoint </strong>is selected the GL state changes would be highlighted in red. if both the options are selected GL state highlighted in purple signifies changes from default and since last breakpoint.</p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG7"></a><h3>Viewing Resources</h3>
<p>While stopped at a breakpoint a variety of resources can then be examined. </p>
<p>The resource view can be opened by selecting <strong>Resources </strong> from the <strong>Views </strong>menu or you can press <strong>Command-Option-R</strong>.</p>
<a name="TNTAG78"></a><h4>Textures</h4>
<p>The <strong>Textures</strong> tab presents a list of textures objects sorted by their texture ID.</p>
<p>The ones highlighted in red are not loaded into Profiler yet, but a simple click on any of them should bring the texture out. </p>
<p>In this view, the textures can be examined, their target, internal format, source format, source type, and dimensions are shown. </p>
<p>The <strong> Mipmap Level </strong>slider at the bottom will let you select other mipmaps levels if defined, the <strong> Zoom Level </strong> slider allows to zoom in and out the texture in the view, the <strong> Source Blend Mode </strong> and <strong> Destination Blend Mode</strong> can be adjusted if necessary for proper viewing, the <strong> Background Color &amp; Opacity </strong> picker will let you select the color and opacity of the background and the <strong> Flip Texture </strong> button will flip the texture vertically.</p>
<p><a href="#TNTAG21">Figure 12</a> shows a texture resource view.</p>
<a name="TNTAG21"></a><p class="caption"><strong>Figure 12: </strong>Examining the textures in the resource view</p>
<p><img src="images/tn2178_ResourcesView_Textures.png" width="640" height="686" alt="Figure 12, Examining the textures in the resource view"></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG34"></a><h4>ARB Programs</h4>
<p>ARB Programs can be examined in the <strong> Resources </strong> window under the <strong> Programs </strong> tab. As with any resource make sure the application is at a break point.</p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG35"></a><h4>GLSL Shaders</h4>
<p>OpenGL Profiler is very useful for examining and even editing shaders in your application. To get there make sure to stop at a breakpoint, open the <strong> Resources </strong> in the <strong> View </strong> menu if you haven't already and select the <strong> Shaders </strong> tab. Here Profiler presents a list of shader and program objects to inspect. </p>
<p>For editing or tweaking shaders in your application this way see the section <a href="#TNTAG15">Editing shaders</a>.</p>
<p><a href="#TNTAG29">Figure 13</a> shows what a program object might look like.</p>
<a name="TNTAG29"></a><p class="caption"><strong>Figure 13: </strong>Program Object.</p>
<p><img src="images/tn2178_ResourcesView_ProgramObject.png" width="640" height="513" alt="Figure 13, Program Object."></p>
<p><a href="#TNTAG31">Figure 14</a> shows what a shader object with a vertex shader might look like.</p>
<a name="TNTAG31"></a><p class="caption"><strong>Figure 14: </strong>Vertex Shader</p>
<p><img src="images/tn2178_ResourcesView_VertexShader.png" width="640" height="513" alt="Figure 14, Vertex Shader"></p>
<p><a href="#TNTAG28">Figure 15</a> shows what a shader object with a fragment shader might look like.</p>
<a name="TNTAG28"></a><p class="caption"><strong>Figure 15: </strong>Fragment Shader.</p>
<p><img src="images/tn2178_ResourcesView_FragmentShader.png" width="640" height="513" alt="Figure 15, Fragment Shader."></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG36"></a><h4>FBOs</h4>
<p>Framebuffer Objects can be examined in the <strong> Resources </strong> window under the <strong> FBOs </strong> tab. As with any resource make sure the application is at a break point. Here Profiler presents a list of the FBOs it knows about. </p>
<p>Here you can identify the color, depth, and stencil attachments of an FBO and use the <strong> Texture </strong> or <strong> Renderbuffers </strong> tabs to inspect their contents.</p>
<p><a href="#TNTAG40">Figure 16</a> shows the structure and attachments of the FBO.</p>
<a name="TNTAG40"></a><p class="caption"><strong>Figure 16: </strong>FBO structure in the resource view</p>
<p><img src="images/tn2178_ResourceView_FBO.png" width="640" height="596" alt="Figure 16, FBO structure in the resource view"></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG37"></a><h4>Renderbuffers</h4>
<p>Renderbuffers can be examined in the <strong> Resources </strong> window under the <strong> Renderbuffers </strong> tab. As with any resource make sure the application is at a break point. </p>
<p>The functionality here is very similar to the Texture tab as described above. There are adjustments for zoom, source and destination blend, background color and opacity, and the ability to vertically flip the image.</p>
<p><a href="#TNTAG41">Figure 17</a> shows the contents of a Renderbuffer.</p>
<a name="TNTAG41"></a><p class="caption"><strong>Figure 17: </strong>Renderbuffer in the resource view.</p>
<p><img src="images/tn2178_ResourceView_renderbuffer.png" width="640" height="596" alt="Figure 17, Renderbuffer in the resource view."></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG38"></a><h4>VBOs</h4>
<p>Vertex Buffer Objects can be examined in the <strong> Resources </strong> window under the <strong> VBOs </strong> tab. As with any resource make sure the application is at a break point. </p>
<p>Profiler shows you the properties associated with a VBO. </p>
<p><a href="#TNTAG52">Figure 18</a> shows the contents of a Renderbuffer.</p>
<a name="TNTAG52"></a><p class="caption"><strong>Figure 18: </strong>Vertex Buffer Object view</p>
<p><img src="images/tn2178_ResourcesView_VBOs.png" width="640" height="516" alt="Figure 18, Vertex Buffer Object view"></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG39"></a><h4>VAOs</h4>
<p>Vertex Array Objects can be examined in the <strong> Resources </strong> window under the <strong> VAOs </strong> tab. As with any resource make sure the application is at a break point.</p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG22"></a><h3>Buffer Views</h3>
<p>Under the view menu, several buffers can be examined when stopped at a breakpoint. Below are some screen captures from a particle shader in the GLSLShowpiece example.</p>
<a name="TNTAG42"></a><h4>Back bufffer</h4>
<p class="caption"><strong>Figure 19: </strong>Current back buffer</p>
<p><img src="images/tn2178_BackBuffer.png" width="632" height="650" alt="Figure 19, Current back buffer"></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG43"></a><h4>Depth buffer</h4>
<p class="caption"><strong>Figure 20: </strong>Initial depth buffer view</p>
<p><img src="images/tn2178_DepthBufferView.png" width="632" height="665" alt="Figure 20, Initial depth buffer view"></p>
<p class="caption"><strong>Figure 21: </strong>Depth buffer view with max and min range</p>
<p><img src="images/tn2178_DepthBufferView_MaxMin.png" width="632" height="665" alt="Figure 21, Depth buffer view with max and min range"></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG44"></a><h4>Alpha buffer</h4>
<p class="caption"><strong>Figure 22: </strong>Alpha buffer</p>
<p><img src="images/tn2178_AlphaBuffer.png" width="632" height="650" alt="Figure 22, Alpha buffer"></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG45"></a><h4>Stencil buffer</h4>
<p class="caption"><strong>Figure 23: </strong>Stencil buffer</p>
<p><img src="images/tn2178_StencilBuffer.png" width="632" height="650" alt="Figure 23, Stencil buffer"></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG13"></a><h2>Real World Techniques</h2>
<a name="TNTAG67"></a><h3>Checking the Application for Errors</h3>
<p>OpenGL Profiler can help to quickly check an application for errors by setting breakpoints of GL errors, thread errors, etc. </p>
<ul>
<li><p>On the breakpoint window, set the appropriate breakpoint for GL errors</p></li>
<li><p>Launch or attach to the application if you have not done so</p></li>
<li><p>Monitor the breakpoint window to see if catches an error</p></li>
</ul>
<p><a href="#TNTAG68">Figure 24</a> shows Profiler catching an error.</p>
<a name="TNTAG68"></a><p class="caption"><strong>Figure 24: </strong>Break on error</p>
<p><img src="images/tn2178_BreakOnError.png" width="640" height="472" alt="Figure 24, Break on error"></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG11"></a><h3>Checking GPU or CPU execution of current state</h3>
<p>The easiest way to check in OpenGL Profiler if the application is indeed executing on the GPU is to let Profiler break on software fallbacks. </p>
<ul>
<li><p>On the breakpoint window, check the SW fallback option</p></li>
<li><p>Launch or attach to the application if you have not done so</p></li>
<li><p>Monitor the breakpoint window to see if catches a software callback</p></li>
</ul>
<p><a href="#TNTAG80">Figure 25</a> shows Profiler catching a software callback. Note that <code>kCGLCPGPUFragmentProcessing</code> and <code>kCGLCPGPUVertexProcessing</code> are both GL_FALSE at the point, indicating that fragment processing and vertex processing are currently handled by a software recovery mechanism. The value of <code>kCGLCPCurrentRendererID</code> also becomes distinct.</p>
<a name="TNTAG80"></a><p class="caption"><strong>Figure 25: </strong>Break on software fallback</p>
<p><img src="images/tn2178_BreakOnSW.png" width="640" height="472" alt="Figure 25, Break on software fallback"></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG2"></a><h3>Collecting Trace and Statistics for a single frame</h3>
<p>Collecting the trace and statistics of a single frame can give you a quick (if somewhat narrow) view of what the application is doing.</p>
<ul>
<li><p>Launch or attach to the application of interest</p></li>
<li><p>Navigate the application to the suspect area</p></li>
<li><p>Set a breakpoint in <code>CGLFlushDrawable</code> for double buffered contexts or glFlush for single buffered ones</p></li>
<li><p>Once stopped, open (or clear) the trace and statistics windows</p></li>
<li><p>Press Continue once at the bottom of the breakpoints window</p></li>
</ul>
<p>Here are a few things to consider in the trace:</p>
<p>Do you see any duplicate or redundant calls?</p>
<p>On this single frame look for state management, can it be improved by state sorting? </p>
<p>Do you see any single call taking significantly more time than the others? </p>
<p>Is the frame not done rendering? Maybe more than one <code>CGLFlushDrawable</code> / glFlush are being sent per frame. </p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG3"></a><h3>Enabling Multithreaded execution of the OpenGL Framework</h3>
<p>Some applications might benefit from enabling multithreaded execution of the OpenGL Framework. </p>
<p>OpenGL Profiler allows you to test this option without any coding. </p>
<ul>
<li><p>Launch or attach to the application of interest </p></li>
<li><p>Note the frame rate at somewhat repeatable point </p></li>
<li><p>Set any breakpoint. <code>CGLFlushDrawable</code> is common for double buffered contexts.</p></li>
<li><p>Once stopped select <strong> Force on </strong> in the <strong> Multi-thread control </strong></p></li>
<li><p>Clear the breakpoint and</p></li>
<li><p>Press Continue once at the bottom of the breakpoints window</p></li>
<li><p>Note the frame rate under multi-threaded execution</p></li>
</ul>
<div class="notebox"><p><strong>Note: </strong>Not all applications will benefit. See <a href="http://developer.apple.com/technotes/tn2006/tn2085.html">Enabling multi-threaded execution of the OpenGL framework</a></p></div>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG14"></a><h3>Monitoring VRAM with Driver Monitor</h3>
<p>Although a separate application from OpenGL Profiler, OpenGL Driver Monitor is another key tool when debugging and optimizing OpenGL applications. </p>
<p>There is a performance cliff when VRAM becomes full, so knowing how your application uses VRAM is essential. </p>
<ul>
<li><p>In OpenGL Profiler select <strong>Driver Monitor</strong> under the <strong>View</strong> menu to start OpenGL Driver Monitor </p></li>
<li><p>In OpenGL Driver Monitor select the appropriate driver. Usually this is accomplised by pressing Cmd-1 on machines with a single graphics card or you can select it under <strong>Driver Monitors</strong> in the <strong>Monitors</strong> menu</p></li>
<li><p>On the driver monitor window click <strong>Parameters</strong> and double click on <strong>Current Free Video Memory</strong></p></li>
</ul>
<p><strong> Page Offs </strong> and <strong>Page Ons</strong> of textures and surfaces are others you might want to monitor in relation to VRAM.</p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG15"></a><h3>Editing shaders</h3>
<p>With Mac OS X Leopard, OpenGL Profiler provides the ability to modify shaders on the fly. </p>
<ul>
<li><p>Launch or attach to the application of interest</p></li>
<li><p>Set a breakpoint and wait for the application to stop</p></li>
<li><p>Open the <strong>Resources View</strong> and select the <strong>Shaders</strong> tab</p></li>
<li><p>Select the desired shader object on the left. See <a href="#TNTAG31">Figure 14</a></p></li>
<li><p>Edit the shader in the <strong>Source</strong> tab and press <strong>Compile</strong> </p></li>
<li><p>If compilation failed you can use the <strong>Log</strong> tab. You can use the <strong>Revert</strong> button to return to the original code and then hit <strong>Compile</strong> again</p></li>
<li><p>if the compilation was succesful then release the breakpoint and hit <strong>Continue</strong> on the <strong> breakpoints</strong> view</p></li>
</ul>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG69"></a><h3>Disabling OpenGL Execution</h3>
<p>Under some circumstances you might want to disable procession of OpenGL functions. This is possible within Profiler by selecting <strong>Execute none</strong> under <strong>Actions</strong> in the <strong>Breakpoints</strong> view. To restore execution select <strong>Execute all</strong></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG47"></a><h3>Attaching and running scripts at breakpoints</h3>
<p>OpenGL Profiler allows you to insert (at a performance cost) small amounts of GL code or <strong>Scripts</strong> to be executed while stopped at a breakpoint. </p>
<p>First you must create the script. Open the <strong>Scripts</strong> view and click on the "+" button. This generates an empty script that you can rename. On right side you can edit the contents of the script as shown in <a href="#TNTAG53">Figure 26</a> . </p>
<a name="TNTAG53"></a><p class="caption"><strong>Figure 26: </strong>The scripts view</p>
<p><img src="images/tn2178_ScriptsView.png" width="636" height="631" alt="Figure 26, The scripts view"></p>
<p>Once created this script can be executed manually while stopped in a breakpoint. To automatically execute the script, attach it to a breakpoint by selecting <strong>Attach Script...</strong> under the <strong>Actions</strong> in the <strong>Breakpoints view</strong>. You can choose to execute the script before or after the break, and continue automatically or not after the execution, as shown in <a href="#TNTAG70">Figure 27</a>.</p>
<a name="TNTAG70"></a><p class="caption"><strong>Figure 27: </strong>Attaching a script to a breakpoint.</p>
<p><img src="images/tn2178_AttachingScripts.png" width="506" height="303" alt="Figure 27, Attaching a script to a breakpoint."></p>
<div class="notebox"><p><strong>Note: </strong>Keep in mind that running scripts automatically in a call that is used repeatedly is not a good way to measure performance differences since the execution and continue is a very expensive operation.</p></div>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG55"></a><h3>Trace Filtering</h3>
<p>OpenGL Profiler allows you to create a custom filter that takes stdin and put something to stdout to save your trace. </p>
<p>A possible example might be finding a the slowest calls. Consider the simple shell script at <a href="#TNTAG73">Listing 1</a> and the image at <a href="#TNTAG74">Figure 28</a>. </p>
<p>The script will generate a sorted (increasingly slower) output of the trace once you click the <strong>Filter</strong> button. Then you could use the line number of the output to trace back to the surroundings where the call actually took place. This will help in figuring out what particular frames might be slowing down your scene.</p>
<a name="TNTAG73"></a><p class="caption"><strong>Listing 1: </strong>sortedByTime.sh.</p>
<pre class="sourcecodebox">#!/bin/tcsh -f 
awk '{ print $3" "$0 }' | sort -n</pre>
<a name="TNTAG74"></a><p class="caption"><strong>Figure 28: </strong>Using sortedByTime.sh</p>
<p><img src="images/tn2178_TraceFilter.png" width="637" height="652" alt="Figure 28, Using sortedByTime.sh"></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG56"></a><h3>Launching with a custom pixel format </h3>
<p>OpenGL Profiler allows you to <strong>Launch</strong> an application with a custom pixel format. By selecting the <strong>Launch Settings</strong> in the main window as shown in <a href="#TNTAG20">Figure 29</a></p>
<p>Among other things, this allows you to try different antialising settings and quickly seeing the results without modifying the source code of the application.</p>
<a name="TNTAG20"></a><p class="caption"><strong>Figure 29: </strong>Custom Pixel format.</p>
<p><img src="images/tn2178_CustomPixelFormat.png" width="640" height="316" alt="Figure 29, Custom Pixel format."></p>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG16"></a><h2>Programatic control of OpenGL Profiler</h2>
<p>OpenGL Profiler also provides some programmatic control..</p>
<a name="TNTAG51"></a><h3>Controlling breakpoints</h3>
<p>This is a very powerful feature that allows your application to set and clear breakpoints when attached to OpenGL Profiler.</p>
<p>You can set a breakpoint by making an array with 3 GLints: </p>
<ul>
<li><p>Parameter 0: function ID (see CGLProfilerFunctionEnum.h) </p></li>
<li><p>Parameter 1: the logical OR of kCGLProfBreakBefore or kCGLProfBreakAfter, indicating how you want the breakpoint to stop: before entering OpenGL, on return from OpenGL, or both </p></li>
<li><p>Parameter 2: is used like a boolean which turns the breakpoint on or off</p></li>
</ul>
<p>and then passing this array to <code>CGLSetOption</code>().</p>
<p><a href="#TNTAG54">Listing 2</a> shows how to programmatically set a breakpoint at <code>CGLFlushDrawable</code>.</p>
<a name="TNTAG54"></a><p class="caption"><strong>Listing 2: </strong>Setting a breakpoint at <code>CGLFlushDrawable</code>.</p>
<pre class="sourcecodebox">#include "OpenGL/CGLProfiler.h"
#include "OpenGL/CGLProfilerFunctionEnum.h"
...
   GLint myBreakpoint[] = { kCGLFECGLFlushDrawable, kCGLProfBreakBefore, 1;}
   CGLSetOption( kCGLGOEnableBreakpoint, myBreakpoint );
...</pre>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG71"></a><h3>Inserting comments in the Trace view</h3>
<p>Comments can be printed out in the Trace window using the technique illustrated in <a href="#TNTAG72">Listing 3</a></p>
<a name="TNTAG72"></a><p class="caption"><strong>Listing 3: </strong>Inserting comments in the trace.</p>
<pre class="sourcecodebox">#include &lt;OpenGL/CGLProfiler.h&gt;
...
    CGLSetOption(kCGLGOComment, (long) "***** My Comment is here *****");
...</pre>
<p>The resulting comment looks like this in the trace:</p>
<pre class="sourcecodebox">21561: 0.00 µs /* ***** My Comment is here ***** */</pre>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG33"></a><h3>Controlling the trace logging</h3>
<p>You application can also control when to start/stop the trace logging as shown in <a href="#TNTAG75">Listing 4</a></p>
<p>This gives you fine grain control over what traces to collect in a specific section or time for example.</p>
<a name="TNTAG75"></a><p class="caption"><strong>Listing 4: </strong>Pass GL_TRUE to start and GL_FALSE to stop tracing.</p>
<pre class="sourcecodebox">#include &lt;OpenGL/CGLProfiler.h&gt;
...
    CGLSetOption(kCGLGOEnableFunctionTrace, GL_TRUE);
...</pre>
<p class="caption"><strong>Listing 5: </strong>Clearing the trace window.</p>
<pre class="sourcecodebox">#include &lt;OpenGL/CGLProfiler.h&gt;
...
    CGLSetOption(kCGLGOResetFunctionTrace, NULL);
...</pre>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG76"></a><h3>Controlling the collection of statistics</h3>
<p>You application can also control when to start/stop the collection of statistics as shown in <a href="#TNTAG77">Listing 6</a>.</p>
<p>Make sure to open the statistics window first. </p>
<a name="TNTAG77"></a><p class="caption"><strong>Listing 6: </strong>Controlling the statistics.</p>
<pre class="sourcecodebox">#include &lt;OpenGL/CGLProfiler.h&gt;
...
    // To start
    CGLSetOption(kCGLGOResetFunctionStatistics, NULL); // if you want to reset counters to zero
    CGLSetOption(kCGLGOEnableFunctionStatistics, GL_TRUE);
...
    // To stop the counters
    CGLSetOption(kCGLGOEnableFunctionStatistics, GL_FALSE);
...</pre>
<p style="margin-top:-10px"><a href="#top">Back to Top </a><a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p>
<a name="TNTAG50"></a><h2>OpenGL Profiler Preferences</h2>
<p class="caption"><strong>Figure 30: </strong>Preferences window</p>
<p><img src="images/tn2178_ProfilerPreferences.png" width="454" height="432" alt="Figure 30, Preferences window"></p>
<a name="document_revision_summary"></a><h2>Document Revision History</h2>
<table cellspacing="0" class="graybox" width="680">
<tr>
<th width="100">Date</th>
<th width="580">Notes</th>
</tr>
<tr>
<td scope="row">2008-09-16</td>
<td>First Version</td>
</tr>
</table>
<p><b>Posted: </b>2008-09-16</p>
<!-- END CONTENTS -->
</td></tr></table>
<!-- END WIDE COLUMN --><!-- END MAIN CONTENT --><!-- START BOTTOM APPLE NAVIGATION -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn2007/tn2178.html%3Fid%3DDTS40007990-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn2007/tn2178.html%3Fid%3DDTS40007990-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn2007/tn2178.html%3Fid%3DDTS40007990-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer" --><!-- END BOTTOM APPLE NAVIGATION --><!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->
</body>
</html>
