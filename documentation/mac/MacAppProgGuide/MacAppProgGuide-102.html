<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Recipes--Views (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING102></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-101.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-103.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-100.html"><B>Chapter 17 - Working With Views</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING102-0></A>
<H1><A NAME=MARKER-2-75></A>Recipes--Views</H1>
 The recipes and sample code in this section demonstrate how to perform a variety of operations with views and adorners.<P>
<A NAME=HEADING102-2></A>
<H2><A NAME=MARKER-2-76></A>Working With Views--A General Outline</H2>
 This outline describes the steps most MacApp applications take to work with views.<P>
<OL>
<LI>Your application can use view classes provided by MacApp or view classes you have defined based on MacApp's view classes.
<LI>If you use a view-editing application to define a <CODE>'View'</CODE> resource that describes a view or view hierarchy, use an <CODE>include</CODE> statement to include the resource into your application's resource file.
<LI>Use a <CODE>#include</CODE> statement to include a text resource file into your application's resource file.
<LI>Define a constructor method to initialize the fields of your view class to safe or default values.
<LI>Define an initialization method for your view class to allocate any storage needed by the class.
<LI>Define a destructor method to free any storage allocated in the initialization method and to do any other necessary cleanup when your object is deleted.
<LI>To ensure that your view class can be created from a resource, you register your view classes as described in <A HREF=MacAppProgGuide-23.html#MARKER-9-37>"Registering Class Information," beginning on page 30</A>.<A NAME=MARKER-2-77></A>
<LI>Override the <CODE>DoMakeViews</CODE> method of your document object class to create the views for your document. Your implementation of <CODE>DoMakeViews</CODE> must handle the cases of opening a document for Finder printing and opening a document for display (see following recipe).
<LI>Override the <CODE>DoPostCreate</CODE> method of your view object class to perform view initialization that can't be specified by your constructor or as part of a view resource definition.
<LI>Override the <CODE>Draw</CODE> method of your view object class to handle drawing in your view.
<LI>To recalculate the size of your view, override the <CODE>CalcMinFrame</CODE> method of your view object class.
<LI>To highlight in your view, override the <CODE>DoHighlightSelection</CODE> method.
<LI>To use an adorner with your view, you can either specify the adorner in your resource file or add it procedurally.<P>
</OL>
<A NAME=HEADING102-17></A>
<H2><A NAME=MARKER-2-78></A><A NAME=MARKER-9-79></A>Recipe--Creating Views for Displaying and Printing Versus Printing Only</H2>
 An application normally needs a complete view hierarchy, including a window, to display data. In some cases, however, the application may not need the full hierarchy for printing.<P>
<UL>
<LI>When a user opens a document, your application creates the full window hierarchy for displaying or printing. You can create the hierarchy by calling the <CODE>NewTemplateWindow</CODE> routine.
<LI>When a user prints your application's documents from the Finder, the application is launched to do the printing. To create a view hierarchy for printing, you don't normally need a window object. You can create a view hierarchy without a window by calling the <CODE>DoCreateViews</CODE> method of the <CODE>gViewServer</CODE> object.<P>
</UL>
<DL>
<DT><B>IMPORTANT</B>
<DD>It is a common source of error to attempt to create a window or view from a <CODE>'View'</CODE> resource without registering all view classes in the resource with the MA_REGISTER_CLASS macro.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The following code sample, from the <CODE>TIconDocument::<A NAME=MARKER-2-21></A>DoMakeViews</CODE> method in the IconEdit sample application, demonstrates how to create a different view for printing only:<P>
<PRE>
if (forPrinting)
{
   // If only for printing, need only the view.
   iconView = (TIconEditView *)gViewServer-&gt;DoCreateViews(
                  this, NULL, kIconEditViewId, gZeroVPt);
   FailNIL(iconView);
}
else
{  
   // Otherwise, need view and window.
   aWindow = gViewServer-&gt;NewTemplateWindow(kIconWindowId, this);
   FailNIL(aWindow);
   // Get reference to the view.
   iconView = (TIconEditView*)(aWindow-&gt;FindSubView('ICON'));
}
fIconView = iconView;
</PRE>
 The <CODE>NewTemplateWindow</CODE> method reads the resource specified by the kIconWindowId resource ID from the resource file, creates a window and view hierarchy, and returns a reference to the window. The <CODE>DoCreateViews</CODE> method performs a similar operation for the resource specified by the kIconEditViewId resource ID, which doesn't include a window.<P>
 This sample code calls the window object's <CODE>FindSubView</CODE> method to get a reference to a specific subview in the hierarchy, the icon view.<A NAME=MARKER-9-28></A><P>
<A NAME=HEADING102-26></A>
<H2><A NAME=MARKER-2-82></A>Recipe--Calculating the Size of a View</H2>
 Sometimes MacApp needs to know the current size of a view, such as when your application is printing or when the view has changed size and its scroll bars need to be adjusted. To determine the current size of a view, MacApp calls the <CODE>CalcMinFrame</CODE> method of the view object.<P>
 The default version of <CODE>CalcMinFrame</CODE>, defined in <CODE>TView</CODE>, computes the minimum frame based on the <CODE>fLocation</CODE> and <CODE>fSize</CODE> fields. This minimum size is sufficient for some view classes, but if your view has more complicated operations, you may need to override <CODE>CalcMinFrame</CODE>. The following version of <A NAME=MARKER-2-83></A>CalcMinFrame is from the <CODE>TIconEditView</CODE> class from the IconEdit application. In calculating the view's minimum size, this method takes into account the current zoom magnification and adds a couple of pixels for a border.<P>
<PRE>
void TIconEditView::CalcMinFrame(VRect&amp; minFrame) 
{
   minFrame = VRect (  
         0,
         0,
         kIconHBits * fMagnification + kBorder + kBorder,
         kIconVBits * fMagnification + kBorder + kBorder);
}
</PRE>
<A NAME=HEADING102-30></A>
<H2><A NAME=MARKER-2-84></A>Recipe--Using an Adorner With a View</H2>
 An adorner is a graphical object that knows how to draw in the view to which it is attached. Adorners are described in detail in <A HREF=MacAppProgGuide-65.html#MARKER-9-74>"Adorners," beginning on page 213</A>. Adorners can be used for many purposes, and MacApp defines adorner classes for erasing, framing, highlighting, and other drawing operations in views.<P>
 To use an adorner with a view, you perform these steps:<P>
<OL>
<LI>Create and initialize an instance of an adorner.
<LI>Call the <CODE>AddAdorner</CODE> method of the view.<P>
</OL>
 The sample code shown in this recipe is for a hypothetical application.<P>
<A NAME=HEADING102-36></A>
<H3>Create and Initialize an Instance of an Adorner</H3>
 Your adorner object may be based on one of MacApp's adorner classes or on a subclass you have defined. You can create an adorner by calling <CODE>new</CODE>:<P>
<PRE>
TMyAdorner * anAdorner = new TMyAdorner;
anAdorner-&gt;IMyAdorner();
</PRE>
 In the IMyAdorner initialization method for your adorner class, you call <CODE>IAdorner</CODE>, passing an IDType value to identify your adorner and a <CODE>Boolean</CODE> value indicating whether the adorner should be freed when the view it is attached to is deleted:<P>
<PRE>
IAdorner(kMyAdornerID, kFreeOnDeletion);
</PRE>
 You pass <CODE>kDontFreeOnDeletion</CODE> if you don't want the adorner freed with its view. This is often the case, since it is common to associate one instance of an adorner with many views. In this example, <CODE>kMyAdornerID</CODE> would have a definition something like the following:<P>
<PRE>
const IDType kMyAdornerID = 'MyAd';
</PRE>
<DL>
<DT><B>Note</B>
<DD>Instead of creating an adorner to add to a view, you can use one of MacApp's global adorner objects. These adorners are described in <A HREF=MacAppProgGuide-65.html#MARKER-9-77>"MacApp's Adorner Classes," beginning on page 213</A>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING102-44></A>
<H3>Call the AddAdorner Method</H3>
 To add an adorner object to a view, you simply call the view's <CODE>AddAdorner</CODE> method:<P>
<PRE>
myView-&gt;AddAdorner(anAdorner, kAdornLast, kInvalidate);
</PRE>
 In the AddAdorner call, you pass the adorner to add, a value indicating the drawing priority for the adorner, and a value indicating whether to invalidate the adorner's view, thus forcing it to be redrawn. MacApp's priority constants for adornment specify whether the adorner should be drawn last (as specified in this call), drawn after the view, drawn before the view, or drawn first. For more information, see <A HREF=MacAppProgGuide-65.html#MARKER-9-85>"Adorner Priorities," beginning on page 215</A>.<P>
 MacApp supplies the constants <CODE>kInvalidate</CODE> and <CODE>kDontInvalidate</CODE> to specify whether or not a view should be invalidated (forcing redrawing).<A NAME=MARKER-2-85></A><P>
<A NAME=HEADING102-49></A>
<H2><A NAME=MARKER-2-86></A><A NAME=MARKER-9-87></A>Recipe--Using a Document Class With a Text-Editing View</H2>
 To define a file-based document class that works with a text-editing view, you perform these steps:<P>
<OL>
<LI>Create a <CODE>'View'</CODE> resource with a text-editing view.
<LI>Call <CODE>InitUTEView</CODE> from your <CODE>main</CODE> routine.
<LI>Provide a document class definition.
<LI>Provide constructor and destructor methods.
<LI>Provide an initialization method.
<LI>Override the <CODE>FreeData</CODE> method.
<LI>Override the <CODE>DoMakeViews</CODE> method.
<LI>Override the <CODE>DoNeedDiskSpace</CODE> method.
<LI>Override the <CODE>DoWrite</CODE> method.
<LI>Override the <CODE>DoRead</CODE> method.
<LI>Override the application's <CODE>DoMakeDocument</CODE> method.
<LI>Make additional modifications.<P>
</OL>
 The sample code shown in this recipe is from the DemoText application. The <CODE>TTEDocument</CODE> class shown in this recipe implements the methods needed to edit text but is not intended as a complete text-editing solution.<P>
<A NAME=HEADING102-64></A>
<H3>Create a 'View' Resource With a Text-Editing View</H3>
 The easiest way to define a <CODE>'View'</CODE> resource containing a window with a view hierarchy is to use a view-editing application. The window should have a scroller view plus vertical and horizontal scroll-bar views. The scroller view serves as the superview for a text-editing view based MacApp's <CODE>TTEView</CODE> class. You can see a text version of this window and view hierarchy in the file <CODE>DemoText.r</CODE>. The scroll bars work with the scroller to let the user scroll text.<P>
 The DemoText application defines a window with resource ID number 1004, containing a <CODE>TTEView</CODE> class with view resource ID <CODE>'TEVW'</CODE>. To specify these resources in your application, you define constants such as the following:<P>
<PRE>
// 'View' resource ID for DemoText text-editing window.
const ResNumber kWindowRsrcID = 1004;
// Resource ID for TTEView within window view hierarchy.
const IDType kTTEViewSubView = 'TEVW';
</PRE>
<A NAME=HEADING102-68></A>
<H3>Call InitUTEView From Your Main Routine</H3>
 To use MacApp's <CODE>TTEView</CODE> class, you must call the <CODE>InitUTEView</CODE> initialization routine. You typically do so in your <CODE>main</CODE> routine, with a line like the following:<P>
<PRE>
InitUTEView();
</PRE>
<A NAME=HEADING102-71></A>
<H3>Provide a Document Class Definition</H3>
 You define a document class to work with a text-editing view. In the DemoText application, the document's parent class can be either <CODE>TFileBasedDocument</CODE> or, if the application is built to use PowerTalk mailers, <CODE>TMailableDocument</CODE> (a subclass of <CODE>TFileBasedDocument</CODE>). This recipe uses <CODE>TFileBasedDocument</CODE>. For a recipe that demonstrates the use of mailers, see <A HREF=MacAppProgGuide-141.html#MARKER-9-30>"Recipe--Adding Mailer Support to a Document Class," beginning on page 628</A>.<P>
<PRE>
class TTEDocument : public TFileBasedDocument
{
   MA_DECLARE_CLASS;          // Include MacApp's RTTI.
public:
   Handle      fDocText;      // The text owned by the document.
   TEStyleHandlefStyles;      // Style handle, if any.
   STHandle    fElements;     // Handle to element array, if any.
   TTEView*    fTEView;       // The view that displays the text.
   TextSpecs   fTextSpecs;    // Specifies properties of the text.
   ResNumber   fViewResourceID;// ID of 'View' resource for text view.
   // Initialization and freeing.
   TTEDocument();             // Constructor.
   virtual ~TTEDocument();    // Destructor.
   virtual void ITEDocument(  // Initialization.
                        TFile*itsFile,
                        const OSType itsScrapType,
                        ResNumber itsViewResourceID);
   virtual void DoInitialState();// Called when creating or reverting.

   // Disk operations.
   virtual void DoNeedDiskSpace(TFile* itsFile,
                           long&amp; dataForkBytes,
                           long&amp; rsrcForkBytes);

   virtual void DoRead(TFile* aFile, Boolean forPrinting);
   virtual void DoWrite(TFile* aFile, Boolean makingCopy);

   // Making views and windows.
   virtual void DoMakeViews(Boolean forPrinting);
   .
   .  // Some methods not shown.
   .
}  // End TTEDocument.
</PRE>
<A NAME=HEADING102-75></A>
<H3>Provide Constructor and Destructor Methods</H3>
 The constructor method puts all fields of the document into a default or safe state to ensure that freeing can take place correctly if there is an error during creation of the document.<P>
<PRE>
TTEDocument::TTEDocument()
{
   fDocText = NULL;
   fElements = NULL;
   fStyles = NULL;
   fTEView = NULL;
   fTextSpecs = gDefaultSpecs;
   fViewResourceID = kDefaultViewID;
}
</PRE>
 In this constructor, the <CODE>TTEDocument</CODE> class sets <CODE>fTextSpecs</CODE> (which specifies properties of the text, such as font name, size, and color) to refer to a global variable. The global variable <CODE>gDefaultSpecs</CODE> is initialized in the <CODE>IDemoTextApplication</CODE> method.<P>
 The constructor sets the fViewResourceID field to kDefaultViewID; this is the default <CODE>'View'</CODE> resource MacApp installs in a document. The initialization method, shown in the next section, sets the fViewResourceID field to the passed value.<P>
 The destructor method deletes any storage allocated by the document. For the <CODE>TTEDocument</CODE> class, it just disposes of the object's text handle.<P>
<PRE>
TTEDocument::~TTEDocument()
{
   fDocText = DisposeIfHandle(fDocText);
}
</PRE>
<A NAME=HEADING102-82></A>
<H3>Provide an Initialization Method</H3>
 The initialization method for the <CODE>TTEDocument</CODE> class calls IFileBasedDocument (the initialization method of its parent), creates a handle to store document text, and sets the fViewResourceID field to the passed view resource ID.<P>
<PRE>
void TTEDocument::ITEDocument(TFile* itsFile,
                            const OSType itsScrapType,
                            ResNumber itsViewResourceID)
{
   // Let parent classes perform their initialization.
   this-&gt;IFileBasedDocument(itsFile, itsScrapType);
   FailInfo fi;
   Try(fi)
   {
      // Allocate a handler for storing the document's text.
      fDocText = NewPermHandle(0);
      fi.Success();
   }
   else
   {
      this-&gt;Free();
      fi.ReSignal();
   }
   fViewResourceID = itsViewResourceID;
}
</PRE>
 If a failure occurs, ITEDocument calls <CODE>this-&gt;Free()</CODE> to free the document, then calls <CODE>ReSignal</CODE> to propagate the failure. Freeing the document causes its destructor method to be called, freeing the fDocText handle if it isn't <CODE>NULL</CODE>.<P>
 This approach to failure handling is simple but not robust, and it may not be appropriate for all applications. A safer implementation would be for ITEDocument to dispose of the handle directly, if necessary, then call <CODE>ReSignal</CODE>, allowing the calling routine (typically the application's <CODE>DoMakeDocument</CODE> method) to free the document object with its own failure handling.<P>
<A NAME=HEADING102-87></A>
<H3>Override the FreeData Method</H3>
 The <CODE>TFileBasedDocument::RevertDocument</CODE> method calls the <CODE>FreeData</CODE> method as part of reverting to a previous version of a document. The <CODE>TTEDocument</CODE> class overrides the <CODE>FreeData</CODE> method to free the text storage allocated in the initialization method.<P>
<A NAME=HEADING102-89></A>
<H3>Override the DoMakeViews Method</H3>
 A document class typically overrides the <CODE>DoMakeViews</CODE> method to create the kind of views it works with. In TTEDocument, the DoMakeViews method uses the global view server object to create a window and view hierarchy, gets a reference to the <CODE>TTEView</CODE> object in the hierarchy, creates a print handler to handle printing for the document, and calls the <CODE>ShowReverted</CODE> method as a means of setting up the window to display. (For more information on reverting, see <A HREF=MacAppProgGuide-60.html#MARKER-9-83>"Reverting to a Previous Version of a Document," beginning on page 176</A>.)<P>
<PRE>
void TTEDocument::DoMakeViews(Boolean /*forPrinting*/ ) 
{
   TWindow* aWindow;
   TStdPrintHandler* aHandler;
   aWindow = gViewServer-&gt;NewTemplateWindow(fViewResourceID, this);
   FailNIL(aWindow);
   // Next call uses a cast because FindSubView returns a TView.
   fTEView = (TTEView*) aWindow-&gt;FindSubView(kTTEViewSubView);
   aHandler = new TStdPrintHandler;
   aHandler-&gt;IStdPrintHandler(
               this,       // Its document.
               fTEView,    // Its view.
               !kSquareDots,// Does not have square dots.
               kFixedSize, // Horizontal page size is fixed.
               !kFixedSize);// Vertical page size is variable.
   // Use the show-reverted mechanism to set up the fTEView view object.
   this-&gt;ShowReverted();
}
</PRE>
<A NAME=HEADING102-92></A>
<H3>Override the DoNeedDiskSpace Method</H3>
 The <CODE>DoNeedDiskSpace</CODE> method determines how much disk space will be required to store the document's text. <P>
<PRE>
void TTEDocument::DoNeedDiskSpace(TFile*itsFile,
                           long&amp; dataForkBytes,
                           long&amp; rsrcForkBytes) // Override.
{
   TEStyleHandle styles;
   STHandle elements;

   dataForkBytes += GetHandleSize(fDocText);

   if (fPrintInfo)
      rsrcForkBytes += fPrintInfo-&gt;GetSize() + kRsrcTypeOverhead
                  + kRsrcOverhead;
   if ((fTEView-&gt;fStyleType == kWithStyle) &amp;&amp; (fTEView-&gt;fHTE))
   {
      fTEView-&gt;ExtractStyles(styles, elements);
      rsrcForkBytes += GetHandleSize((Handle)styles)
                  + kRsrcTypeOverhead + kRsrcOverhead
                  + GetHandleSize((Handle)elements)
                  + kRsrcTypeOverhead + kRsrcOverhead;
   }

   rsrcForkBytes += sizeof(TextSpecs) + kRsrcTypeOverhead
               + kRsrcOverhead;

   // Get resource file overhead. 
   Inherited::DoNeedDiskSpace(itsFile, dataForkBytes, rsrcForkBytes);
}
</PRE>
 This method gets the size of the text handle, then adds the size of the document's print info record. If the document contains style information, it adds the amount of space needed to write that information. It also calls <CODE>Inherited</CODE>, to determine any disk space needed by other classes in the document class hierarchy.<P>
<A NAME=HEADING102-96></A>
<H3>Override the DoWrite Method</H3>
 The <CODE>DoWrite</CODE> method writes the document's text and style data to disk.<P>
<PRE>
void TTEDocument::DoWrite(TFile* aFile,
                     Boolean makingCopy) // Override.
{
   long numChars;
   TextSpecsHdl hTextSpecs;

   // Write out the text. 
   numChars = GetHandleSize(fDocText);
   SignedByte savedState = LockHandleHigh(fDocText);// Lock handle.
   FailOSErr(aFile-&gt;WriteData(*fDocText, numChars));
   HSetState(fDocText, savedState);       // Restore state of handle.

   if (fTEView-&gt;fStyleType == kWithStyle)
   {
      TEStyleHandle styles;
      STHandle elements;

      fTEView-&gt;ExtractStyles(styles, elements);
      // NOTE: Ought to include failure handling to free new handles on error.
      PermHandToHand((Handle &amp;) styles);
      AddResource((Handle)styles, kTextStyleRsrcType, kStylesRsrcID, gEmptyString);
      FailResError();
      PermHandToHand((Handle &amp;) elements);
      AddResource((Handle)elements, kTextStyleRsrcType, kElementsRsrcID,
               gEmptyString);
      FailResError();
   }

   // Write the text specification resource, after converting it to a handle.
   hTextSpecs = (TextSpecsHdl)NewPermHandle(sizeof(TextSpecs));
   MABlockMove(&amp;fTextSpecs, *hTextSpecs, sizeof(TextSpecs));
   AddResource((Handle)hTextSpecs, kTextSpecsRsrcType, kTextSpecsRsrcID,
               gEmptyString);
   FailResError();
   
   Inherited::DoWrite(aFile, makingCopy);
}
</PRE>
 The <CODE>TTEDocument::DoWrite</CODE> method shown above performs these steps:<P>
<OL>
<LI>It writes the data from the document's text handle to the file.
<LI>If the document contains style data, <CODE>DoWrite</CODE> converts style and element data to resources and adds them to the document's resource map so that they will be saved with the file.
<LI>It adds the document's text specification resource to the resource map so that it will be saved with the file.
<LI>It calls <CODE>Inherited</CODE> to complete the writing process.<P>
</OL>
 The general case of writing a document is described in <A HREF=MacAppProgGuide-133.html#MARKER-9-19>Chapter 27, "Working With Streams."</A><P>
<A NAME=HEADING102-105></A>
<H3>Override the DoRead Method</H3>
 The <CODE>DoRead</CODE> method reads the document's text and style data from disk.<P>
<PRE>
void TTEDocument::DoRead(TFile* aFile,
                     Boolean forPrinting) // Override.
{
   long numChars;
   TextSpecsHdl hTextSpecs;
   Boolean oldTempAllocation;
   FailInfo fi;

   // Read in the text.
   FailOSErr(aFile-&gt;GetDataLength(numChars));

   // The file may have been created by someone else, so limit it to 32 KB!
   if (numChars &gt; kUnlimited) 
   {
      gApplication-&gt;ShowError(0, messageAlert + kFileTooBig);
      numChars = kUnlimited;
   }

   // Set size of handle to hold text we will read. Lock handle, and provide
   // failure handling to unlock it in case of an error.
   SetPermHandleSize(fDocText, numChars);
   SignedByte savedState = LockHandleHigh(fDocText);


   Try(fi)
   {
      FailOSErr(aFile-&gt;ReadData(*fDocText, numChars));
      HSetState(fDocText, savedState);
      fi.Success();
   }
   else
   {
      HSetState(fDocText, savedState);// Restore state of handle.
      fi.ReSignal();
   }
   // Read in TEStyleRec.
   fStyles = (TEStyleHandle)Get1Resource(kTextStyleRsrcType, kStylesRsrcID);
   if (fStyles)
      DetachResource((Handle)fStyles);

   // Read in the STElement array, using a permanent allocation.
   oldTempAllocation = TemporaryAllocation(FALSE);
   fElements = (STHandle)(Get1Resource(kTextStyleRsrcType, kElementsRsrcID));
   TemporaryAllocation(oldTempAllocation);
   
   if (fElements)
      DetachResource((Handle)fElements);

   // Read the text specs resource.
   hTextSpecs = (TextSpecsHdl)Get1Resource(kTextSpecsRsrcType, kTextSpecsRsrcID);
   if (hTextSpecs)
   {
      MABlockMove(*hTextSpecs, &amp;fTextSpecs, sizeof(TextSpecs));
      ReleaseResource((Handle)hTextSpecs);
   }
   else
      this-&gt;DoInitialState();

   Inherited::DoRead(aFile, forPrinting);
}
</PRE>
 The <CODE>TTEDocument::DoRead</CODE> method shown above performs these steps:<P>
<OL>
<LI>It determines the number of text characters to be read and limits it to a 32 KB maximum.
<LI>It sets the <CODE>fDocText</CODE> handle to the needed size and reads the text.
<LI>It reads the <CODE>TEStyleRec</CODE> resource.
<LI>It attempts to read a <CODE>STElement</CODE> array resource; if successful, it detaches the resource.
<LI>It attempts to set the <CODE>fTextSpecs</CODE> field by reading a resource; if unsuccessful, it calls <CODE>DoInitialState</CODE> to set the field to a default value.
<LI>It calls <CODE>Inherited</CODE> to complete the reading process.<P>
</OL>
 The general case of reading a document is described in <A HREF=MacAppProgGuide-133.html#MARKER-9-19>Chapter 27, "Working With Streams."</A><P>
<A NAME=HEADING102-116></A>
<H3>Override the Application's DoMakeDocument Method</H3>
 In your application class, you override the <CODE>DoMakeDocument</CODE> method to create and initialize a text-editing document object. The DoMakeDocument method of the TDemoTextApplication class calls ITEDocument, passing the kWindowRsrcID constant defined earlier. Remember that this ID specifies the <CODE>'View'</CODE> resource for a window hierarchy containing a scroller, scroll bars, and a <CODE>TTEView</CODE> object.<P>
<PRE>
TDocument* TDemoTextApplication::DoMakeDocument(
                           CommandNumber /* itsCommandNumber */,
                           TFile* itsFile)
{
   TTEDocument* aTEDocument = new TTEDocument;
   aTEDocument-&gt;ITEDocument(itsFile, kFileType, kWindowRsrcID); 
   return aTEDocument;
}
</PRE>
<A NAME=HEADING102-119></A>
<H3>Make Additional Modifications</H3>
 The <CODE>TTEDocument</CODE> class implements additional methods that are not included in the steps shown above:<P>
<DL>
<DT><CODE>DoSetupMenus</CODE>
<DD> Sets up various text-handling menus (supported in the DemoText application), which include menu items for changing the style, size, font, color, and justification of document text.
<DT><CODE>DoMenuCommand</CODE>
<DD> Handles the menu choices enabled in <CODE>DoSetupMenus</CODE>.
<DT><CODE>ShowReverted</CODE>
<DD> Helps set up the document's text before calling <CODE>Inherited</CODE> to complete showing of the document.
</DL>
 The <CODE>TTEDocument</CODE> class also includes methods to handle the text-editing menu choices it supplies. Your text-editing document class is likely to require additional methods as well.<A NAME=MARKER-2-88></A><A NAME=MARKER-2-89></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-101.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-103.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
