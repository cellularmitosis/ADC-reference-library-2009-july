<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>CPlusTESample - /Application.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">CPlusTESample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">CPlusTESample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Application.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AppLib.h</option>
<option value="listing2.html">/AppLib.r</option>
<option value="listing3.html">/Application.cp</option>
<option value="listing4.html">/Application.h</option>
<option value="listing5.html">/C.pipe.code.c</option>
<option value="listing6.html">/Document.cp</option>
<option value="listing7.html">/Document.h</option>
<option value="listing8.html">/Exceptions.cp</option>
<option value="listing9.html">/Exceptions.h</option>
<option value="listing10.html">/FlowCtlMacs.d</option>
<option value="listing11.html">/List.cp</option>
<option value="listing12.html">/List.h</option>
<option value="listing13.html">/ProgStrucMacs.d</option>
<option value="listing14.html">/TECommon.h</option>
<option value="listing15.html">/TEDocument.cp</option>
<option value="listing16.html">/TEDocument.h</option>
<option value="listing17.html">/TESample.cp</option>
<option value="listing18.html">/TESample.h</option>
<option value="listing19.html">/TESample.r</option>
<option value="listing20.html">/TESampleGlue.a</option>
<option value="listing21.html">/UMAFailure.a</option>
<option value="listing22.html">/UMAFailure.h</option>
<option value="listing23.html">/UMAFailure.inc1.p</option>
<option value="listing24.html">/UMAFailure.p</option></select>
				</p>
				</form>
				<p><strong><a href="CPlusTESample.zip">Download Sample</a></strong> (&#147;CPlusTESample.zip&#148;, 130.6K)<BR>
<strong><a href="CPlusTESample.dmg">Download Sample</a></strong> (&#147;CPlusTESample.dmg&#148;, 196.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*------------------------------------------------------------------------------------------  Program:  CPlusTESample 2.0  File:    Application.cp    Uses:       Application.h              Document.h  by Andrew Shebanow  of Apple Macintosh Developer Technical Support  Copyright &copy; 1989-1990 Apple Computer, Inc.  All rights reserved.------------------------------------------------------------------------------------------*/// Mac Includes#define OBSOLETE  // for ClrAppFiles(), CountAppFiles(), GetAppFiles() et. all.  #ifndef __TYPES__#include &lt;Types.h&gt;#endif#ifndef __QUICKDRAW__#include &lt;QuickDraw.h&gt;#endif#ifndef __FONTS__#include &lt;Fonts.h&gt;#endif#ifndef __EVENTS__#include &lt;Events.h&gt;#endif#ifndef __CONTROLS__#include &lt;Controls.h&gt;#endif#ifndef __WINDOWS__#include &lt;Windows.h&gt;#endif#ifndef __RESOURCES__#include &lt;Resources.h&gt;#endif#ifndef __MENUS__#include &lt;Menus.h&gt;#endif#ifndef __TEXTEDIT__#include &lt;TextEdit.h&gt;#endif#ifndef __DIALOGS__#include &lt;Dialogs.h&gt;#endif#ifndef __MENUS__#include &lt;Menus.h&gt;#endif#ifndef __DEVICES__#include &lt;Devices.h&gt;#endif#ifndef __EVENTS__#include &lt;Events.h&gt;#endif#ifndef __SCRAP__#include &lt;Scrap.h&gt;#endif#ifndef __TOOLUTILS__#include &lt;ToolUtils.h&gt;#endif#ifndef __MEMORY__#include &lt;Memory.h&gt;#endif#ifndef __SEGLOAD__#include &lt;SegLoad.h&gt;#endif#ifndef __FILES__#include &lt;Files.h&gt;#endif#ifndef __OSUTILS__#include &lt;OSUtils.h&gt;#endif#ifndef __TRAPS__#include &lt;Traps.h&gt;#endif#ifndef __APPLICATION__#include &quot;Application.h&quot;#endif#ifndef __DOCUMENT__#include &quot;Document.h&quot;#endif// OSEvent is the event number of the suspend/resume and mouse-moved events sent// by MultiFinder. Once we determine that an event is an osEvent, we look at the// high byte of the message sent to determine which kind it is. To differentiate// suspend and resume events we check the resumeMask bit.const short kOsEvent = app4Evt;        // event used by MultiFinderconst short kSuspendResumeMessage = 0x01;  // high byte of suspend/resume event messageconst short kClipConvertMask = 0x02;    // bit of message field clip conversionconst short kResumeMask = 0x01;        // bit of message field for resume vs. suspendconst short kMouseMovedMessage = 0xFA;    // high byte of mouse-moved event messageextern &quot;C&quot; {  // from MPW standard library  void _DataInit();        // sets up A5 globals};// useful state checking BooleanBoolean gHaveColorQD;// just as &quot;normal&quot; global variables that are declared extern in// header files must still be declared somewhere in order to reserve// space, static class variables must also be declared outside of// the class definition. The syntax is confusing, but then, thats// what makes C++ so ***interesting***.OSType TApplication::fCreator;TApplication::TApplication(OSType creator){  SysEnvRec envRec;  long stkNeeded;  long heapSize;  // initialize Mac Toolbox components  InitGraf((Ptr) &amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(NULL);  InitCursor();  // Unload data segment: note that _DataInit must not be in Main!  UnloadSeg((ProcPtr) _DataInit);  // ignore the error returned from SysEnvirons; even if an error occurred,  // the SysEnvirons glue will fill in the SysEnvRec  (void) SysEnvirons(curSysEnvVers, &amp;envRec);  // Are we running on a 128K ROM machine or better???  if (envRec.machineType &lt; 0)    BigBadError(kErrStrings,eWrongMachine);    // if not, alert &amp; quit  gHaveColorQD = envRec.hasColorQD;  // if we need more stack space, get it now  stkNeeded = StackNeeded();  if (stkNeeded &gt; StackSpace())    {    // new address is heap size + current stack - needed stack    SetApplLimit((Ptr) ((long) GetApplLimit() - stkNeeded + StackSpace()));    }  // Check for minimum heap size  heapSize = (long) GetApplLimit() - (long) ApplicationZone();  if (heapSize &lt; HeapNeeded())    BigBadError(kErrStrings,eSmallSize);  // expand the heap so new code segments load at the top  MaxApplZone();  // allocate an empty document list  fDocList = new TDocumentList;  // check to see if WaitNextEvent is implemented  fHaveWaitNextEvent = TrapAvailable(_WaitNextEvent, ToolTrap);  // initialize our class variables  fCurDoc = nil;  fDone = false;  fInBackground = false;  fMouseRgn = nil;  fWhichWindow = nil;  fCreator = creator;}void TApplication::EventLoop(){  int gotEvent;  EventRecord tEvt;  SetUp();          // call setup routine  DoIdle();          // do idle once  while (!fDone)    {    // always set up fWhichWindow before doing anything    fWhichWindow = FrontWindow();    if (fWhichWindow != nil)      {      // see if window belongs to a document      fCurDoc = fDocList-&gt;FindDoc(fWhichWindow);      // make sure we always draw into correct window      SetPort(fWhichWindow);      }    else fCurDoc = nil;    DoIdle();      // call idle time handler    if (fHaveWaitNextEvent)      gotEvent = WaitNextEvent(everyEvent, &amp;tEvt, SleepVal(), fMouseRgn);    else      {      SystemTask();      gotEvent = GetNextEvent(everyEvent, &amp;tEvt);      }    fTheEvent = tEvt;    // if we got a real event, process it    if (gotEvent)      ProcessEvent();    AdjustCursor();    }}void TApplication::ProcessEvent(){  // make sure alert is loaded in memory BEFORE we do any event  // processing. This is necessary since the alert for the case  // when we need to display an out of memory alert.  // CouldAlert(rUserAlert);  TRY    {    AdjustCursor();    switch (fTheEvent.what)      {      case mouseDown:        DoMouseDown();        break;      case mouseUp:        DoMouseUp();        break;      case keyDown:      case autoKey:        DoKeyDown();        break;      case updateEvt:        DoUpdateEvt();        break;      case diskEvt:        DoDiskEvt();        break;      case activateEvt:        DoActivateEvt();        break;      case kOsEvent:        DoOSEvent();        break;      default:        break;      }    }  RECOVER    {    AlertUser((short) gFailMessage, gFailError);    // don't let error bubble up any farther    goto doneEvent;    }  ENDTRYdoneEvent:  return;}void TApplication::DoKeyDown(){  char key;  long mResult;  key = (char) (fTheEvent.message &amp; charCodeMask);  if ((fTheEvent.modifiers &amp; cmdKey) &amp;&amp; (fTheEvent.what == keyDown))    {    // only do command keys if we are not autokeying    AdjustMenus();          // make sure menus are up to date    mResult = MenuKey(key);    if (mResult != 0)        // if it wasn't a menu key, pass it through      {      DoMenuCommand(HiWord(mResult), LoWord(mResult));      return;      }    }  if (fCurDoc != nil)    {    EventRecord tEvt;    // we copy event record so that we don't pass reference to object field    tEvt = fTheEvent;    fCurDoc-&gt;DoKeyDown(&amp;tEvt);    }}void TApplication::DoActivateEvt(){  // event record contains window ptr  fWhichWindow = (WindowPtr) fTheEvent.message;  // see if window belongs to a document  fCurDoc = fDocList-&gt;FindDoc(fWhichWindow);  SetPort(fWhichWindow);  if (fCurDoc != nil)    fCurDoc-&gt;DoActivate((fTheEvent.modifiers &amp; activeFlag) != 0);}void TApplication::DoUpdateEvt(){  // event record contains window ptr  fWhichWindow = (WindowPtr) fTheEvent.message;  // see if window belongs to a document  fCurDoc = fDocList-&gt;FindDoc(fWhichWindow);  SetPort(fWhichWindow);  if (fCurDoc != nil)    fCurDoc-&gt;DoUpdate();}// NOTE: we use an anonymous parameter here so that the compiler// doesn't warn us about it being unused. Since we give it a name// in the class definition, we still know what its used for.void TApplication::DoSuspend(Boolean){  if (fCurDoc != nil)    fCurDoc-&gt;DoActivate(!fInBackground);}void TApplication::DoResume(Boolean){  if (fCurDoc != nil)    fCurDoc-&gt;DoActivate(!fInBackground);}void TApplication::DoOSEvent(){  Boolean doConvert;  unsigned char evType;  // is it a multifinder event?  evType = (unsigned char) (fTheEvent.message &gt;&gt; 24) &amp; 0x00ff;  switch (evType) {   // high byte of message is type of event    case kMouseMovedMessage:      DoIdle();          // mouse-moved is also an idle event      break;    case kSuspendResumeMessage:      doConvert = (fTheEvent.message &amp; kClipConvertMask) != 0;      fInBackground = (fTheEvent.message &amp; kResumeMask) == 0;      if (fInBackground)        DoSuspend(doConvert);      else DoResume(doConvert);      break;  }}void TApplication::DoMouseDown(){  long mResult;  short partCode;  WindowPtr tWind;  EventRecord tEvt;  // gotta watch those object field dereferences  partCode = FindWindow(fTheEvent.where, &amp;tWind);  fWhichWindow = tWind;  tEvt = fTheEvent;  switch (partCode)    {    case inSysWindow:      DoMouseInSysWindow();      break;    case inMenuBar:      AdjustMenus();      mResult = MenuSelect(tEvt.where);      if (mResult != 0)        DoMenuCommand(HiWord(mResult),LoWord(mResult));      break;    case inGoAway:      DoGoAway();      break;    case inDrag:      DoDrag();      break;    case inGrow:      if (fCurDoc != nil)        fCurDoc-&gt;DoGrow(&amp;tEvt);      break;    case inZoomIn:    case inZoomOut:      if ((TrackBox(fWhichWindow, tEvt.where, partCode)) &amp;&amp;        (fCurDoc != nil))        fCurDoc-&gt;DoZoom(partCode);      break;    case inContent:      // If window is not in front, make it so      if ( fWhichWindow != FrontWindow() )        SelectWindow(fWhichWindow);      else if (fCurDoc != nil)        fCurDoc-&gt;DoContent(&amp;tEvt);      break;    }}void TApplication::DoDrag(){  DragWindow(fWhichWindow, fTheEvent.where, &amp;qd.screenBits.bounds);}void TApplication::DoGoAway(){  if (TrackGoAway(fWhichWindow, fTheEvent.where))    {    if (fCurDoc != nil)      {      if (fCurDoc-&gt;DoClose(true, yesResult, false) != cancelResult)        {        fDocList-&gt;RemoveDoc(fCurDoc);        delete fCurDoc;        }      }    else CloseDeskAcc(((WindowPeek) fWhichWindow)-&gt;windowKind);    // make sure our current document/window references are valid    fWhichWindow = FrontWindow();    if (fWhichWindow != nil)      {      fCurDoc = fDocList-&gt;FindDoc(fWhichWindow);      SetPort(fWhichWindow);      }    else fCurDoc = nil;    }}void TApplication::ProcessArgs(){  short message, numFiles, curFile;  AppFile fileInfo;  /* count the files */  CountAppFiles(&amp;message,&amp;numFiles);  if (numFiles == 0)    {    // create a single empty document    DoNew();    return;    }  for (curFile = 1; curFile &lt;= numFiles; curFile++)    {    /* get file info */    GetAppFiles(curFile,&amp;fileInfo);    /* open/print the file */    if (message != appPrint)      {      TRY        {        OpenADoc(fileInfo.vRefNum,0,fileInfo.fName,fileInfo.fType);        }      RECOVER        {        goto processNextFile;        }      ENDTRY      }processNextFile:    /* clear finder arg for this file */    ClrAppFiles(curFile);    }}void TApplication::DoQuit(Boolean askUser, YNCResult defaultResult){  while (true)    {    fWhichWindow = FrontWindow();    if (fWhichWindow == nil)      break;    fCurDoc = fDocList-&gt;FindDoc(fWhichWindow);    if (fCurDoc != nil)      {      // if the user cancels the quit      if (fCurDoc-&gt;DoClose(askUser, defaultResult, true) == cancelResult)        return;      else        {        fDocList-&gt;RemoveDoc(fCurDoc);        delete fCurDoc;        }      }    else CloseDeskAcc(((WindowPeek) fWhichWindow)-&gt;windowKind);    // make sure we aren't in an infinite loop. This could occur    // if the CloseDeskAcc was failing for some reason.    if (FrontWindow() == fWhichWindow)      {      // send the window to the back of the list.      // if the FrontWindow is still the same, we will exit      // the loop. Otherwise, we let the loop keep running so      // that we have a chance to close our other windows      // cleanly      SendBehind(fWhichWindow, nil);      if (FrontWindow() == fWhichWindow)        break;      }    }  fDone = true;  fWhichWindow = nil;  fCurDoc = nil;}Boolean TApplication::TrapAvailable(short tNumber,TrapType tType){  // Check and see if the trap exists. On 64K ROM machines, tType will be ignored.  return NGetTrapAddress(tNumber, tType) != NGetTrapAddress(_Unimplemented, ToolTrap);}void TApplication::WDToDirID(short wdRefNum, short&amp; vRefNum, long&amp; dirID){  const short kRootDirID = 2;  long junk;  OSErr err = GetWDInfo(wdRefNum,&amp;vRefNum,&amp;dirID,&amp;junk);  if (err != noErr)    {    vRefNum = wdRefNum;    // if GetVol doesn't return valid vRefNum/dirID pair,    dirID = kRootDirID;    // use wdRefNum as a vRefNum and use root for dirID    }}void AlertUser(short errResID, short errCode){  Str255 messageStr;  // if we have a hilited menu, turn it off before displaying alert  HiliteMenu(0);  if (errResID != 0)    {    GetIndString(messageStr, errResID, errCode);    ParamText(messageStr, &quot;\p&quot;, &quot;\p&quot;, &quot;\p&quot;);    }  else    {    // we need to lookup the error in our table    LookupErrorString(errCode,kSysErrStrings,messageStr);    ParamText(messageStr, &quot;\p&quot;, &quot;\p&quot;, &quot;\p&quot;);    }  SetCursor(&amp;qd.arrow);  (void) Alert(rUserAlert, (ModalFilterProcPtr) nil);}void BigBadError(short errResID, short errCode){  AlertUser(errResID,errCode);  ExitToShell();}Boolean LookupErrorString(short value, short resID, StringPtr str){  struct ErrRecord {    short lowErr;    short highErr;    short index;  };  typedef struct ErrRecord* ErrRecordPtr;  Handle      table;  ErrRecordPtr  pEntry;  unsigned long  tableOffset;  long      lenTab;  int        strID;  // start with an empty string  str[0] = 0;  table = GetResource('errs', resID);  if (!table)    {    lenTab = (long) (GetHandleSize((Handle) table) / sizeof(ErrRecord));    strID = 0;    tableOffset = 0;    for (long i = 1; i &lt;= lenTab; i++)      {      pEntry = (ErrRecordPtr) ((unsigned long) *table) + tableOffset;      if (pEntry-&gt;lowErr == 0)        strID = pEntry-&gt;index;      else if ((pEntry-&gt;lowErr &lt;= value) &amp;&amp; (value &lt;= pEntry-&gt;highErr))        {        if (pEntry-&gt;index &gt; 0)          GetIndString(str, strID, pEntry-&gt;index);        return true;        }      tableOffset += sizeof(ErrRecord);      }    }  return false;}// That's all, folks...</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/CPlusTESample/listing3.html%3Fid%3DDTS10000730-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/CPlusTESample/listing3.html%3Fid%3DDTS10000730-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/CPlusTESample/listing3.html%3Fid%3DDTS10000730-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>