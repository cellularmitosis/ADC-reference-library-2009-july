<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Quartz Programming Guide for QuickDraw Developers: Working With Bitmap Image Data</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Working With Bitmap Image Data"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001098-CH227" title="Working With Bitmap Image Data"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000420-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../tq_intro/tq_intro.html#//apple_ref/doc/uid/TP40001098-CH201-TPXREF101">Quartz Programming Guide for QuickDraw Developers</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../tq_moving_data/tq_moving_data.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../tq_masks/tq_masks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001098-CH227-TPXREF101" title="Working With Bitmap Image Data"></a><h1>Working With Bitmap Image Data</h1><p>A Quartz image (<code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/tdef/CGImageRef" target="_top">CGImageRef</a></code> data type) is an abstract representation of a bitmap image that encapsulates image data together with information about how to interpret and draw the data. A Quartz image is immutable—that is, you cannot “draw into” a Quartz image or change its attributes. You use Quartz images to work with bitmap data in a device-independent manner while taking advantage of built-in Quartz features such as color management, anti-aliasing, and interpolation.</p><p>This chapter provides strategies for performing the following tasks:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="tq_image_data.html#//apple_ref/doc/uid/TP40001098-CH227-BBCFFDBB">“Moving Bits to the Screen”</a></span> outlines the functions you can use to move bits, should you really need to do so.</p></li><li class="li"><p><span class="content_text"><a href="tq_image_data.html#//apple_ref/doc/uid/TP40001098-CH227-CJBGJHCH">“Getting Image Data and Creating an Image”</a></span> discusses strategies for obtaining bitmap image data.</p></li><li class="li"><p><span class="content_text"><a href="tq_image_data.html#//apple_ref/doc/uid/TP40001098-CH227-BBCGAAEF">“Changing Pixel Depth”</a></span> discusses why changing pixel depth is not an issue in Quartz.</p></li><li class="li"><p><span class="content_text"><a href="tq_image_data.html#//apple_ref/doc/uid/TP40001098-CH227-BBCCBFJD">“Drawing Subimages”</a></span> shows a variety of ways that you can use Quartz to draw a portion of an image.</p></li><li class="li"><p><span class="content_text"><a href="tq_image_data.html#//apple_ref/doc/uid/TP40001098-CH227-BBCFJDHB">“Resizing Images”</a></span> gives information on changing the size or scaling of an image.</p></li></ul><a name="//apple_ref/doc/uid/TP40001098-CH227-BBCFFDBB" title="Moving Bits to the Screen"></a><h2>Moving Bits to the Screen</h2><p>The Quartz imaging model does not provide the same sort of bit-copying functionality as QuickDraw because Quartz is not based on bitmap graphics. Most of the time you’ll want to adopt strategies that are not bit-based. However if you really need to draw bits, Quartz has the capability. To draw bits, create a bitmap graphics context and draw into it. You can then create an image from the bitmap graphics context by calling the function <code><a href="../../../../GraphicsImaging/Reference/CGBitmapContext/Reference/reference.html#//apple_ref/c/func/CGBitmapContextCreateImage" target="_top">CGBitmapContextCreateImage</a></code> (available starting in Mac OS X v10.4). To draw the image to screen, call <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawImage" target="_top">CGContextDrawImage</a></code>, supplying the appropriate windows graphics context. </p><p>Drawing to a bitmap graphics context, caching the drawing to a CGImage, and then drawing the image to a window graphics context is faster than copying the bits back from the backing store. (Note that you can no longer assume that window back buffers are in main memory.) Keep in mind that the source pixels of a CGImage are immutable.</p><a name="//apple_ref/doc/uid/TP40001098-CH227-CJBGJHCH" title="Getting Image Data and Creating an Image"></a><h2>Getting Image Data and Creating an Image</h2><p>Quartz image data can originate from three types of sources: a URL that specifies a location, a CFData object, which is a simple allocated buffer, and raw data, for which you provide a pointer and a set of callbacks that take care of memory management for the data. </p><p>To obtain image data from a data source, you use either a data provider (prior to Mac OS X v10.4) or an image source (starting in Mac OS X v.10.4). You can think of data providers and image sources as “data managers.” Quartz uses a data manager to obtain the source image data. The data manager handles the messy details of supplying bytes in their correct sequence—for example, a JPEG data provider might handle the task of decompressing the image data.</p><p>Here is the general procedure for getting image data from a data source and creating an image from it:</p><ol class="ol"><li class="li"><p>Create the data manager. If your application runs only in Mac OS X v10.4, use one of the CGImageSource creation functions. If your image data is in a common format (JPEG, PNG, and so forth) you can use the function <code><!--a target="_top" -->CGImageSourceCreateWithURL<!--/a--></code>. If your image data is in a nonstandard or proprietary format, you’ll need to set up a data provider along with callbacks for managing the data. For more information, see <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_data_mgr/dq_data_mgr.html#//apple_ref/doc/uid/TP30001066-CH216" target="_top">Data Management</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>.</p></li><li class="li"><p>Supply the data manager to an image creation function. If you’ve created an image source, you supply the CGImageSource object to the function <code><a href="../../../../GraphicsImaging/Reference/CGImageSource/Reference/reference.html#//apple_ref/c/func/CGImageSourceCreateImageAtIndex" target="_top">CGImageSourceCreateImageAtIndex</a></code>. Image source indexes are zero based, so if your image file contains only one image, supply <code>0</code>. If you’ve created a data provider, you supply it as a parameter to an image creation function (<code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/func/CGImageCreate" target="_top">CGImageCreate</a></code>, <code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/func/CGImageCreateWithJPEGDataProvider" target="_top">CGImageCreateWithJPEGDataProvider</a></code>, or <code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/func/CGImageCreateWithPNGDataProvider" target="_top">CGImageCreateWithPNGDataProvider</a></code>). For a description of all the image creation functions in Quartz, see <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212" target="_top">Bitmap Images and Image Masks</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>.</p></li></ol><p>To draw the newly created Quartz image in a graphics context, you call <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawImage" target="_top">CGContextDrawImage</a></code> and specify the destination rectangle for the image. This function does not have a parameter for a source rectangle; if you want to crop the image or extract a subimage, you’ll need to write some additional code—see <span class="content_text"><a href="tq_image_data.html#//apple_ref/doc/uid/TP40001098-CH227-BBCCBFJD">“Drawing Subimages.”</a></span></p><p>When you move image data from QuickDraw to Quartz, you might notice that the pixels in an image drawn in a Quartz graphics context look different from the pixels in the same image in QuickDraw. Changes are due to factors such as:</p><ul class="ul"><li class="li"><p>Anti-aliasing around the edges of the image</p></li><li class="li"><p>Image interpolation due to scaling</p></li><li class="li"><p>Alpha-based blending of image pixels with background pixels</p></li><li class="li"><p>Color matching, if the image and context color spaces are different</p></li><li class="li"><p>Color adjustments to match the display hardware</p></li></ul><a name="//apple_ref/doc/uid/TP40001098-CH227-BBCGAAEF" title="Changing Pixel Depth"></a><h2>Changing Pixel Depth</h2><p>For historical reasons, QuickDraw supports pixel formats with depths that range from 1 through 32 bits. When copying pixels between ports that have different formats and depths, the <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/CopyBits" target="_top">CopyBits</a></code> function automatically converts each source pixel to the destination depth. (When the depth is reduced, <code>CopyBits</code> also uses dithering to maintain image quality.)</p><p>Applications that run on older systems can sometimes save memory and improve rendering performance by using <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/CopyBits" target="_top">CopyBits</a></code> to reduce the depth of images that are drawn. Modern hardware has plenty of memory and rendering horsepower, and there is no longer any motivation to reduce image depth.</p><p>Mac OS X supports direct displays with pixel depths of 16 or 32, and Quartz bitmap contexts support 16-bit and 32-bit pixel formats. Quartz requires these higher depths to ensure that images can always be rendered faithfully on any destination device.</p><a name="//apple_ref/doc/uid/TP40001098-CH227-BBCCBFJD" title="Drawing Subimages"></a><h2>Drawing Subimages</h2><p>In QuickDraw, you can use <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/CopyBits" target="_top">CopyBits</a></code> to move a rectangular section of the source pixel map to the destination pixel map. This feature allows you to crop an image by copying a subimage.</p><p>Some applications have used this feature as a way to optimize the storage, management, and retrieval of small images. These applications assemble and cache numerous small images in a single offscreen buffer and use <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/CopyBits" target="_top">CopyBits</a></code> to copy them to the screen as needed. For example, a game could cache all the images used on each level of play, making image management easier and improving performance.</p><p>Unlike <code>CopyBits</code>, <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawImage" target="_top">CGContextDrawImage</a></code> does not allow you to specify a source rectangle. However, there are some good solutions in Quartz for drawing subimages of larger images. In Mac OS X v10.4 and later, you can use the function <code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/func/CGImageCreateWithImageInRect" target="_top">CGImageCreateWithImageInRect</a></code> to create a subimage to draw. Otherwise, you can draw a subimage using a clip, a bitmap context, or a custom data provider. </p><a name="//apple_ref/doc/uid/TP40001098-CH227-DontLinkElementID_6" title="Using CGImageCreateWithImageInRect"></a><h3>Using CGImageCreateWithImageInRect</h3><p>Introduced in Mac OS X v10.4, the function <code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/func/CGImageCreateWithImageInRect" target="_top">CGImageCreateWithImageInRect</a></code> uses a source rectangle to create a subimage from an existing Quartz image. Because the subimage is also a Quartz image (<code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/tdef/CGImageRef" target="_top">CGImageRef</a></code>), Quartz can cache the subimage for better drawing performance. To draw the subimage, you use the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawImage" target="_top">CGContextDrawImage</a></code>. </p><p>For more information and a code example, see <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212" target="_top">Bitmap Images and Image Masks</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP40001098-CH227-BBCJAHHJ" title="Using a Clip"></a><h3>Using a Clip</h3><p>This approach draws the entire image into a graphics context and clips the drawing to get the desired subimage. As in <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/CopyBits" target="_top">CopyBits</a></code>, you specify source and destination rectangles. The source rectangle defines the desired subimage, and the destination rectangle determines the clip. The full image is drawn into a third drawing rectangle, which is carefully constructed so that <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawImage" target="_top">CGContextDrawImage</a></code> translates and scales the image appropriately to get the desired effect. You should specify the source rectangle in image units and the destination rectangle in user space units.</p><p><span class="content_text">Listing 5-1</span> shows how you could implement this solution. A detailed explanation of each numbered line of code follows the listing. </p><p>A drawback to this approach is that clipping an image may introduce anti-aliased edges when the subimage is rendered. For information on controlling anti-aliasing in a context, see <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203" target="_top">Graphics Contexts</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP40001098-CH227-CJBEGIJA" title="Listing 5-1A routine that draws a subimage by clipping, translating, and scaling "></a><p class="codesample"><strong>Listing 5-1&nbsp;&nbsp;</strong>A routine that draws a subimage by clipping, translating, and scaling </p><div class="codesample"><table><tr><td scope="row"><pre>void MyDrawSubImage (<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRef context, CGImageRef image, CGRect src, CGRect dst)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* the default drawing rectangle */<span></span></pre></td></tr><tr><td scope="row"><pre>    float w = (float) CGImageGetWidth(image);<span></span></pre></td></tr><tr><td scope="row"><pre>    float h = (float) CGImageGetHeight(image);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGRect drawRect = CGRectMake (0, 0, w, h);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!CGRectEqualToRect (src, dst))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>        float sx = CGRectGetWidth(dst) / CGRectGetWidth(src);<span></span></pre></td></tr><tr><td scope="row"><pre>        float sy = CGRectGetHeight(dst) / CGRectGetHeight(src);<span></span></pre></td></tr><tr><td scope="row"><pre>        float dx = CGRectGetMinX(dst) - (CGRectGetMinX(src) * sx);<span></span></pre></td></tr><tr><td scope="row"><pre>        float dy = CGRectGetMinY(dst) - (CGRectGetMinY(src) * sy);<span></span></pre></td></tr><tr><td scope="row"><pre>        drawRect = CGRectMake (dx, dy, w*sx, h*sy);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextSaveGState (context);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    CGContextClipToRect (context, dst);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    CGContextDrawImage (context, drawRect, image);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>    CGContextRestoreGState (context);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Defines the drawing rectangle. If the source and destination rectangles are identical, the default values are correct.</p></li><li class="li"><p>The source and destination rectangles are different, so the image needs to be scaled and translated. This code block adjusts the drawing rectangle so that <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawImage" target="_top">CGContextDrawImage</a></code> performs the desired transformation; Quartz draws the image to fit the destination rectangle.</p></li><li class="li"><p>Pushes the current graphics state onto the state stack, in preparation for changing the clipping area.</p></li><li class="li"><p>Sets the clipping area to the destination rectangle.</p></li><li class="li"><p>Draws the image such that the desired subimage is visible in the clipping area. </p></li></ol><a name="//apple_ref/doc/uid/TP40001098-CH227-DontLinkElementID_7" title="Using a Bitmap Context"></a><h3>Using a Bitmap Context</h3><p>You can use a bitmap context to draw a subimage by following these steps:</p><ol class="ol"><li class="li"><p>Call the function <code><a href="../../../../GraphicsImaging/Reference/CGBitmapContext/Reference/reference.html#//apple_ref/c/func/CGBitmapContextCreate" target="_top">CGBitmapContextCreate</a></code> to create a bitmap that’s large enough for the subimage data and that uses the appropriate pixel format for the source image data. The pixel format of the bitmap context must be one of the supported formats—for more information, see <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212" target="_top">Bitmap Images and Image Masks</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>.</p></li><li class="li"><p>Create a drawing rectangle. You will want to draw the image so that Quartz writes into the bitmap precisely the subimage data that’s wanted. To accomplish this, draw the full image into a rectangle of the same size, and then translate the rectangle so that the origin of the subimage is aligned with the origin in the bitmap context.</p></li><li class="li"><p>Draw the source image into the bitmap context by calling the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawImage" target="_top">CGContextDrawImage</a></code>. The drawing rectangle is translated such that the bitmap ends up containing precisely the pixel data in the subimage. </p></li></ol><p>After drawing the source image in the bitmap context, you use the context data to create a Quartz image that represents the subimage. In Mac OS X v10.4 and later, you can use the function <code><a href="../../../../GraphicsImaging/Reference/CGBitmapContext/Reference/reference.html#//apple_ref/c/func/CGBitmapContextCreateImage" target="_top">CGBitmapContextCreateImage</a></code> to create this image. You can draw the image in any graphics context or save it for later use.</p><a name="//apple_ref/doc/uid/TP40001098-CH227-DontLinkElementID_8" title="Using a Custom Data Provider"></a><h3>Using a Custom Data Provider</h3><p>In this method, you create a custom data provider that supplies the bytes in the subimage and use this data provider to create a Quartz image (<code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/tdef/CGImageRef" target="_top">CGImageRef</a></code>). To use this method, you need to have direct access to the source image data. </p><p>One way to implement this method is to write a set of callback functions for a sequential-access data provider. Your <code>GetBytes</code> callback function needs to extract the pixel values in a subimage from the full bitmap and supply these bytes to the caller. When you create a data provider that uses your callbacks, you can also pass private information, such as the base address of the bitmap and the subimage rectangle. Quartz passes this information to your callbacks.</p><p>For each different subimage you want to draw, be sure to create a new data provider, and a new Quartz image to represent the subimage.</p><a name="//apple_ref/doc/uid/TP40001098-CH227-BBCFJDHB" title="Resizing Images"></a><h2>Resizing Images</h2><p>In QuickDraw, the <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/CopyBits" target="_top">CopyBits</a></code> function is often used to change the size or scale of an image, vertically or horizontally or both. Pixels are averaged during shrinking.</p><p>In Quartz, you can resize an image by drawing the image into a smaller or larger destination rectangle. Given the dimensions of the source image, you compute the dimensions of the destination rectangle needed to achieve the desired scaling. Then you use <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawImage" target="_top">CGContextDrawImage</a></code> to draw the image in the destination rectangle.</p><p>Quartz also allows you to scale (as well as rotate, skew, and translate) all subsequent drawing in a graphics context—including images—using an affine transformation. </p><p>Quartz draws images using an interpolation (or pixel-smoothing) algorithm that provides high-quality results when the image is scaled. When you create a Quartz image, you specify whether interpolation should be used when the image is drawn in a Quartz context. You can also use the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextSetInterpolationQuality" target="_top">CGContextSetInterpolationQuality</a></code> to set the level of interpolation quality in the context. This parameter is merely a hint to the context—not all contexts support all interpolation quality levels. </p><a name="//apple_ref/doc/uid/TP40001098-CH227-DontLinkElementID_9" title="Relevant Resources"></a><h2>Relevant Resources</h2><p>In <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>, see:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212" target="_top">Bitmap Images and Image Masks</a></span>, which shows how to work with images and image masks.</p></li><li class="li"><p><span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_data_mgr/dq_data_mgr.html#//apple_ref/doc/uid/TP30001066-CH216" target="_top">Data Management</a></span>, which discusses strategies for getting data into and out of Quartz using data providers, image sources, and image destinations.</p></li></ul><p>See these reference documents:</p><ul class="ul"><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGImage/index.html#//apple_ref/doc/uid/TP30000956" target="_top">CGImage Reference</a></em></p></li><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGImageDestination/index.html#//apple_ref/doc/uid/TP40001400" target="_top">CGImageDestination Reference</a></em></p></li><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGImageSource/index.html#//apple_ref/doc/uid/TP40001399" target="_top">CGImageSource Reference</a></em></p></li><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGDataConsumer/index.html#//apple_ref/doc/uid/TP30000951" target="_top">CGDataConsumer Reference</a></em></p></li><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGDataProvider/index.html#//apple_ref/doc/uid/TP30000952" target="_top">CGDataProvider Reference</a></em></p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../tq_moving_data/tq_moving_data.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../tq_masks/tq_masks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-09-05<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/QuickDrawToQuartz2D/tq_image_data/tq_image_data.html%3Fid%3DTP40001098-5.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/QuickDrawToQuartz2D/tq_image_data/tq_image_data.html%3Fid%3DTP40001098-5.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/QuickDrawToQuartz2D/tq_image_data/tq_image_data.html%3Fid%3DTP40001098-5.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>