<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Streams (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING27></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-26.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-28.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-21.html"><B>Part 1 - MacApp Theory and Architecture</B></A><BR><DD><A HREF="MacAppProgGuide-25.html"><B>Chapter 3 - Core Technologies</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING27-0></A>
<H1><A NAME=MARKER-9-46></A><A NAME=MARKER-2-47></A>Streams</H1>
 <A NAME=MARKER-2-48></A>A <B>stream</B> is, literally, a stream of bytes that can flow from one location to another. Streams can be used for many purposes:<P>
<UL>
<LI>to save object data and use the saved data to recreate the original objects
<LI>to read data from a file, memory handle, or other destination
<LI>to write data to a file, memory handle, or other destination
<LI>to count the number of bytes in a data stream<P>
</UL>
 Streaming in MacApp depends on two features:<P>
<UL>
<LI>The <CODE>TObject</CODE> class, the base class for the majority of MacApp classes, contains two methods for streaming data: <CODE><A NAME=MARKER-2-49></A>ReadFrom</CODE> and <CODE><A NAME=MARKER-2-50></A>WriteTo</CODE>. All classes that descend from <CODE>TObject</CODE> can override these methods to read or write their data, using the <CODE>TStream</CODE> parameter passed to <CODE>ReadFrom</CODE> and <CODE>WriteTo</CODE>.
<LI>MacApp supplies stream classes for a variety of destinations, including files, resources, handles, sections, and drag flavors (flavor data is described in <A HREF=MacAppProgGuide-72.html#MARKER-9-29>Chapter 9, "Drag and Drop."</A>) Your objects read and write their data the same way every time--they don't have to worry about the final destination.<P>
</UL>
 The <CODE>TStream</CODE> class is an abstract class that contains methods for reading and writing many primitive data types, such as bytes, integers, characters, points, rectangles, and strings. When an application calls one of these methods, passing data of the appropriate type, the method transfers the data with a call to <CODE><A NAME=MARKER-2-51></A>ReadBytes</CODE> or <CODE><A NAME=MARKER-2-52></A>WriteBytes</CODE>.<P>
 In the <CODE>TStream</CODE> class, the <CODE>ReadBytes</CODE> and <CODE>WriteBytes</CODE> methods are unimplemented and are left as a responsibility of the subclass. The following subclasses of <CODE>TStream</CODE> implement <CODE>ReadBytes</CODE> and <CODE>WriteBytes</CODE> to read and write data for specific destinations:<P>
<DL>
<DT><CODE>TCountingStream<B></B></CODE>
<DD> The <CODE>TCountingStream</CODE> class counts the bytes in a stream without writing them to a real destination; <I>it is not used for reading</I>.
<DT><CODE>TDragFlavorStream</CODE>
<DD> The <CODE>TDragFlavorStream</CODE> class calls Drag Manager routines to read and write flavor data.
<DT><CODE><A NAME=MARKER-2-53></A>TFileResourceStream</CODE>
<DD> This subclass of <CODE>TResourceStream</CODE> reads from or writes to a resource handle. <CODE>TFileResourceStream</CODE> has an associated file and uses it to set the current resource file before reading or writing.
<DT><CODE>TFileStream<B></B></CODE>
<DD> The <CODE>TFileStream</CODE> class reads from or writes to a file.
<DT><CODE>THandleStream<B></B></CODE>
<DD> The <CODE>THandleStream</CODE> class reads from or writes to a memory handle.
<DT><CODE>TResourceStream<B></B></CODE>
<DD> The <CODE>TResourceStream</CODE> class reads from or writes to a resource handle.
<DT><CODE>TSectionStream<B></B></CODE>
<DD> The <CODE>TSectionStream</CODE> class reads and writes data for a section (sections are described in <A HREF=MacAppProgGuide-61.html#MARKER-9-154>"Publish and Subscribe," beginning on page 184</A>).<A NAME=MARKER-2-54></A><A NAME=MARKER-2-55></A>
</DL>
<A NAME=HEADING27-18></A>
<H2><A NAME=MARKER-2-56></A><A NAME=MARKER-9-57></A>Streaming Object Data</H2>
 <B><A NAME=MARKER-2-58></A>Persistent data</B> is the data needed to recreate an object in the same state as when it wrote its data. For example, to recreate a view with its previous size and location, the persistent data must include the size and location. But if the view is always re-created with a default size and location, its persistent data need not include size and location.<P>
 When you override the <CODE>WriteTo</CODE> method to stream the data for a class, you generally need to write only its persistent data, because any constant data can be initialized automatically. When you override the <CODE>ReadFrom</CODE> method to read the data for a class from a stream, you read only the data you wrote in the <CODE>WriteTo</CODE> method, in exactly the same order.<P>
 <CODE>TStream</CODE> includes the <CODE>ReadStreamObject</CODE> and <CODE>WriteStreamObject</CODE> methods for reading and writing an entire object. Classes that support the use of <CODE>ReadStreamObject</CODE> and <CODE>WriteStreamObject</CODE> (including all of MacApp's view classes) override the <CODE>GetStandardSignature</CODE> method to supply a unique signature ID. For example, MacApp defines the following signature ID to be returned by the <CODE>GetStandardSignature</CODE> method of the <CODE>TButton</CODE> class:<P>
<PRE>
const IDType kStdButton = 'butn';
</PRE>
 Objects are streamed using the following mechanisms to ensure efficiency: <P>
<UL>
<LI>Class names and signature IDs are used to identify objects. A class name is written only once per class, not once per object of that class.
<LI>Objects are created by signature, if available; otherwise, by class name.
<LI><CODE>TStream</CODE> uses a <CODE><A NAME=MARKER-2-59></A>TContext</CODE> object to maintain a table of all the objects written out. The first time an object is written it is added to the table. If another reference to the same object is encountered, only its table index is written. A similar process is used when reading objects back.
<LI>If an object is not recognized when reading from a stream, the data for that object is skipped over.<P>
</UL>
<A NAME=HEADING27-28></A>
<H2>Examples of Using Streams in MacApp</H2>
 You can find useful examples of how to use the different types of streams in the MacApp class library. For example:<P>
<DL>
<DT><CODE><A NAME=MARKER-2-60></A>TDragItem<B></B></CODE>
<DD> This class uses a drag flavor stream in its <CODE>GetDataAsHandle</CODE> and <CODE>GetDataStream</CODE> methods.
<DT><CODE><A NAME=MARKER-2-61></A>TFileBasedDocument</CODE>
<DD> This class uses a counting stream in its <CODE><A NAME=MARKER-2-62></A>DoNeedDiskSpace</CODE> method to determine how much space the file will take on disk. Your document subclasses can use a similar approach. It also uses a file stream in its <CODE><A NAME=MARKER-2-63></A>DoReadScript</CODE> and <CODE><A NAME=MARKER-2-64></A>DoWriteScript</CODE> methods, to read a script from a file or write one to a file.
<DT><CODE><A NAME=MARKER-2-65></A>TSection<B></B></CODE>
<DD> This class uses a section stream in its <CODE><A NAME=MARKER-2-66></A>DoRead</CODE> and <CODE><A NAME=MARKER-2-67></A>DoWrite</CODE> methods, to read or write section data.
<DT><CODE><A NAME=MARKER-2-68></A>TViewServer<B></B></CODE>
<DD> This class creates a handle stream in its <CODE><A NAME=MARKER-2-69></A>DoMakeViewStream</CODE> method. The view server's <CODE><A NAME=MARKER-2-70></A>ReadViewsFromResource</CODE> and<CODE> <A NAME=MARKER-2-71></A>WriteViewsToHandle</CODE> methods call on <CODE>DoMakeViewStream</CODE> to supply a stream.
</DL>
 For additional information on using streams in your application, see <BR><A HREF=MacAppProgGuide-133.html#MARKER-9-19>Chapter 27, "Working With Streams."</A><P>
<A NAME=HEADING27-35></A>
<H2><A NAME=MARKER-2-72></A>Advantages of Using Streams</H2>
 One great benefit of using streams is that if your classes know how to read and write their data for one kind of stream, they can read and write for any kind of stream. If you create <CODE>ReadFrom</CODE> and <CODE>WriteTo</CODE> methods, your application's classes will be able to read and write their data to document files, memory handles, and other destinations. They will also be able to use a counting stream to count bytes and determine how much storage is needed.<P>
 Another advantage of using streams is that you can associate a failure handler with a stream operation, which gives you explicit control when an error occurs during the reading and writing of documents or other destinations.<A NAME=MARKER-2-73></A><P>
<A NAME=HEADING27-38></A>
<H2><A NAME=MARKER-2-74></A>Disadvantages of Using Streams</H2>
 Although MacApp's stream classes can serve many purposes, they do have inherent limitations. If any of these limitations represents a serious problem for your application, make sure your design includes an adequate solution before using streams.<P>
<A NAME=HEADING27-40></A>
<H3>File Formats</H3>
 Using the stream mechanism to write a document can result in a file format that varies widely from document to document and is difficult to explain. The data for a document is written out by the object hierarchy that exists at the time the document is written, and it can be read in conveniently only by recreating that same set of objects.<P>
 MacApp writes a length word with each object, so it <I>is</I> possible to skip over objects your application doesn't understand. However, information in a skipped object is effectively lost to your application and may prevent the recreation of a meaningful document.<P>
 Because a file format based on an object hierarchy can vary from document to document, it is difficult to support backward compatibility across document versions. For example, if you create a new version of your application that uses new or modified objects, it may be difficult to ensure that the new objects can read data written by the old ones.<P>
 One solution is to write a unique tag with each object, and change the tag if the object format changes in a future version of the application. With some effort, a tagged format can be built on top of MacApp's implementation of streams.<P>
<A NAME=HEADING27-45></A>
<H3>Speed and Data Access</H3>
 MacApp's stream classes provide basic persistent object support, but they are not an object database. If you need to create files with large numbers of objects, and especially if you want random read/write access to objects, you can use MacApp's streams to pack objects into handy chunks, but you will need to use some other software to access the chunks on disk. Third-party products are available for this purpose.<P>
<A NAME=HEADING27-47></A>
<H3>Ease of Modification</H3>
 The class hierarchy of MacApp's stream classes can make it difficult to modify stream behavior across all classes without changing MacApp code. For example, if you want to add a feature that works for all stream classes, you have to either modify <CODE>TStream</CODE> itself in the MacApp code or create a separate subclass for <CODE>TFileStream</CODE>, <CODE>THandleStream</CODE>, and each of the other stream classes.<P>
 One way to work around this is to create your own subclass of <CODE>TStream</CODE>, such as <CODE>TSuperStream</CODE>, and give it a field <CODE>TStream * fStream</CODE> that references a stream object of any type. You can set the <CODE>fStream</CODE> field by passing a stream to the <CODE>ISuperStream</CODE> method.<P>
 <CODE>TSuperStream</CODE> can override the <CODE>ReadBytes</CODE> and <CODE>WriteBytes</CODE> methods of <CODE>TStream</CODE> and make them defer to the <CODE>fStream</CODE> field. For example, <CODE>ReadBytes</CODE> would call <CODE>fStream-&gt;ReadBytes</CODE>. (You may need to override other methods as well, such as <CODE>GetPosition</CODE> and <CODE>SetPosition</CODE>.) Now you can add a feature to <CODE>TSuperStream</CODE> and use it with any stream type. <A NAME=MARKER-2-75></A><A NAME=MARKER-2-76></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-26.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-28.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
