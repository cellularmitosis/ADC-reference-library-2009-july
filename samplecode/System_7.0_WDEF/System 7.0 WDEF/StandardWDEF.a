;;	File:		StandardWDEF.a;;	Contains:	This file contains the window definition procedure; 				"DocumentProc", the standard Mac window type.;  				It is a rectangular window with a title bar.;           ••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••;			•••••••••••••>>>> IMPORTANT!!! <<<<<<<<•••••••••••••••••••••••••••;			••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••;			THESE ARE NOT FINAL!!!! This is the WDEF for Beta 4 System 7.  The ;			final WDEF may (will) be slightly or greatly different from this!;			This is provided for your information only, to see how to write your;			application's WDEFs to match System 7.;	Copyright:	© 1982-1991 by Apple Computer, Inc., all rights reserved.;			STRING		ASIS			PRINT		OFF			PRINT		ON; ================================================; REGISTERS; ================================================; registers being used and need to be preservedrectReg		EQU		A4			; rectangle’s address is kept in regwindowReg	EQU		A3			; window pointer address is kept in regtitleHgtReg	EQU		D7			; window’s title bar height in regparamReg	EQU		D6			; parameter passed in function callvarCodeReg	EQU		D5			; varCode passed in funciton call; ================================================; CONSTANTS; ================================================HiliteFlagGlobal	EQU		$B20	; low memory with hiliting flagHiliteFlagBit		EQU		0		; bit 0 in HiliteFlagGlobal bytehasZoom 	EQU 	3			; bit 3 is zoom bithasGrow 	EQU 	2			; bit 2 is grow bitIconSize	EQU		20			; width of small icon in titleminTitleH	EQU		19			; minimum title bar height without SICNminTitleHIcon EQU	21			; minimum title bar height with SICNdboxWithTitle	EQU		5		; proc ID of dBoxProc with title bardBoxBorderSize 	EQU		7		; dBoxProc border sizeproc5TopAdjust	EQU		4		; title and border share some areaproc5HitZAdjust	EQU		6		; zoom box is more to the leftscrollBarSize	EQU		16		; size of scroll bar areawHiliteLight		EQU		5wHiliteDark			EQU		6wTitleBarLight		EQU		7wTitleBarDark		EQU		8wDialogLight		EQU		9wDialogDark			EQU		10wTingeLight			EQU		11	; For color tinges in title bar & gadgetswTingeDark			EQU		12lowestShadeIndex	EQU		16wHiliteShade0		EQU		16wHiliteShade7		EQU		17wHiliteShade8		EQU		18wHiliteShadeA		EQU		19wHiliteShadeD		EQU		20wTitleBarShade0		EQU		21wTitleBarShade1		EQU		22wTitleBarShade4		EQU		23wDialogShade0w		EQU		24wDialogShade4w		EQU		25wDialogShade6w		EQU		26wDialogShadeBb		EQU		27wDialogShadeF		EQU		28wDialogShade0b		EQU		30wDialogShade4b		EQU		31wDialogShade6b		EQU		32wDialogShadeBw		EQU		33wLTinge0			EQU		34wLTinge4			EQU		35wDTingeF			EQU		36wZoomGadget			EQU		0wGoAwayGadget		EQU		1wZoomHilitedGadget	EQU		2wGoAwayHilitedGadget	EQU		3wGrowGadget			EQU		4kPixmapID			EQU		-14336kHighlightPix		EQU		-14334minWCTBDepth		EQU		4minColorDepth		EQU		8;  fakeDeviceFlags is used when we bypass DeviceLoop and draw the grow icon directly, and we’re; on a machine that doesn’t have Color QuickDraw.fakeDeviceFlags		equ		$A801; ================================================; TYPES; ================================================; There records are only types, they do not allocate space; ------------- FontInfo record TYPE -------------WInfoRec	RECORD	0				; FontInfo record typeWAscent		ds.w	1WDescent	ds.w	1WHeight		ds.w	1WBoxDelta	ds.w	1			ENDR; ------------- RGBInfo record TYPE -------------RGBInfoRec	RECORD	0				; RGBColor record typered			ds.w	1green		ds.w	1blue		ds.w	1			ENDRWDefDrawFrame	RECORD	0				; stack frame for DeviceLoop draw procretAddress		ds.l	1				; return addressStartParams		EQU		*userData		ds.l	1				; long we passed to DeviceLoopdevHandle		ds.l	1				; GDevice handledeviceFlags		ds.w	1				; flags for current devicedepth			ds.w	1				; bits/pixel for this callParamSize		EQU		*-StartParams				ENDR; ================================================WDEF0		PROC		EXPORT; ================================================; FUNCTION MyWindow(varCode: INTEGER; window: WindowPtr;;					message: INTEGER; param: LongInt): LongInt; Create a stack frame recode that matches the above function.; The parameters passed on the stack are between ParamBegin and ParamSize.; ParamSize the number of bytes to be removed (poped) off the stack after; the UNLINK instruction.  Any local variables to be created are listed; between A6Link and LinkSize.  LinkSize is the size of the entire stack; frame and it the number of bytes used in the LINK instruction.  To add; more local variables, insert it between A6Link and LinkSize.StackFrame	RECORD	{A6Link},DECR	; build a stack frame recordProcResult	ds.l	1				; function’s result returned to callerParamBegin	EQU	*					; start parameters after this point;			parameters on stackvarCode		ds.w	1				; variation codewindow		ds.l	1				; the window pointermessage		ds.w	1				; operation to performparam		ds.l	1				; addition information based on messageParamSize	EQU		ParamBegin-*	; size of all the passed parametersRetAddr 	ds.l	1				; place holder for return addressA6Link		ds.l	1				; place holder for A6 link;			local variables being allocatedSavFgCol	ds		RGBInfoRec		; saved WMgrCPort ForeColor (color only)SavBkCol	ds		RGBInfoRec		; saved WMgrCPort BackColor (color only)WInfo		ds		WInfoRec		; record for font and other infoOldPort		ds.l	1				; current port to be restoredTempRgn		ds.l	1				; temporary region handleAuxCTab		ds.l	1				; handle to auxCTable (color only)AuxCPtr		ds.l	1				; pointer to auxCTable (color only)IsColor		ds.b	1				; have colorQD in toolbox? [boolean]IsTitleIcon	ds.b	1				; do we have an icon in the title bar?IsProcFive	ds.b	1				; dBox with title bar? [boolean]threeDWind	ds.b	1				; conditions right for System 7 windows?curDepth	ds.l	1				; current drawing depth for SetupColorstartRGB	ds.w	3endRGB		ds.w	3tempRGB		ds.w	3workPixMap	ds.l	1gadgetHighlight	ds.w	1tempPixels	ds.l	1globalOffset	ds.l	1			; Amount to offset when drawing grow icon in WMgrPortcurZone		ds.l	1				; temporary storage for theZone bogusCtab	ds.l	1				; handle to bogus color table							LinkSize	EQU 	*				; size of all the local variables			ENDR; ================================================; MAIN entry point in the WDEF.; ================================================; Jump over the defined data and get to the code.DocProc		bra.s	WDEFStart			; and a way we go; Define in the code segment necessary data.  The standard header; is first then additional data used in the WDEF.			dc.w	0					; flags word			dc.b	'WDEF'				; resource type			dc.w	0					; resource ID			dc.w	15					; version number; ================================================WDEFStart								; start of the WDEF code; ================================================			WITH	StackFrame			; cover our local stack frame			LINK	A6,#LinkSize 		; set stack frame to address params			moveM.l D3-D7/A1-A4,-(SP)	; save work registers			clr.l	ProcResult(A6)		; initialize funtion’s result; test if the message is in range			cmp.w	#wGIconMsg,message(A6)	; compare to highest value			 			BGT 	WDEFEnd					; skip it, it’s too high			 			cmp.w	#wDrawMsg,message(A6)	;  compare to lowest value, too		 			BMI 	WDEFEnd					;			move.l	(A5),A0 			; get pointer to QuickDraw globals			move.l	(A0),OldPort(A6)	; save current port; ------------- fetch the parameters -------------			move.l	window(A6),windowReg ; get the window pointer			lea 	TempRect,rectReg	; get TempRect address in a reg			move.l	param(A6),paramReg	; get the param	in a reg			move.w	varCode(A6),varCodeReg	; get the selector integer			AND.w 	#3,varCodeReg		; ignore "inGrow" variant; ------------- is the dBox with title? -------------; determine if this is a dBoxProc using a title			move.w	varCode(A6),D0		; get real selector			AND.w	#7,D0				; AND off higher bits			cmp.w	#dboxWithTitle,D0	; compare against new proc			SEQ.b	IsProcFive(A6)		; set if dBox with title; ------------- Determine type of system -------------; We need to know if we have color QuickDraw and a color window manager port.			cmp.w	#$3FFF,ROM85		; do we have color QD?			SLS		IsColor(A6)			; set boolean depending on color or B&W system			BLS.s	@ColorSys			; this system has color QD			move.l	WMgrPort,-(SP)		; B&W, set to window manager port			_SetPort					;			bra.s	@CommonSys			; done for the B&W environment; ------------- doin it with color -------------; when using the WMgrCPort, it is the defproc’s responsibility to reconcile; the WMgrPort and the WMgrCPort.  Also find the auxWinRec and lock it down; This compares the pertinent fields of the WMgrPort and the WMgrCPort,; updating the WMgrCPort as necessary to match the WMgrPort.@ColorSys	move.l	WMgrCPort,-(SP)		; make the WMgrCPort the current port			_SetPort					; set it			move.l	WMgrPort,A0			; get the WMgrPort addr			move.l	WMgrCPort,A1		; and the WMgrCPort too			pea		bkPat(A0)			; push pointers to pattern for later			pea		pnPat(A0)			;										; copy all fields from pnLoc to end of grafPort,										; excluding pnPixPat and fillPixPat			lea		pnLoc(A0),A0				; point at source			lea		pnLoc(A1),A1				; point at dest			move.l	(A0)+,(A1)+					; copy pnLoc			move.l	(A0)+,(A1)+					; copy pnSize			move.w	(A0)+,(A1)+					; copy pnMode			addq	#8,A0						; skip pnPat (aka, pnPixPat,fillPixPat)			addq	#8,A1						;			move.w	#((portRec-pnVis)/2)-1,D0	; set up a counter (long sized)@1			move.w	(A0)+,(A1)+					; copy it			Dbra	D0,@1						; loop												; now set up the patterns in the WMgrCPort			_PenPat								; (which is thePort) the parameters were			_BackPat							; pushed before the copying loop above			pea		SavFgCol(A6)		; push a pointer to save area			_GetForeColor				; get the current color			pea		SavBkCol(A6)		;			_GetBackColor				;			move.l	#blackColor, -(SP)	; set default colors			_ForeColor			move.l	#whiteColor, -(SP)			_BackColor; ------------- get auxWinRec -------------			clr.l	-(SP)				; here’s a space for the var handle			clr.w	-(SP)				; function return here			move.l	windowReg,-(SP)		; push window ptr			pea		6(SP)				; a pointer to the space above			_GetAuxWin					; find the auxrec			addq	#2,SP				; pitch the boolean (it doesn’t matter)			move.l	(SP)+,A0			; get the auxRecHandle			move.l	(A0),A0				; handle -> ptr			move.l	awCTable(A0),A0		; get the colortable handle			move.l	A0,AuxCTab(A6)		; save this handle			_HLock						; lock the table down in memory			move.l	(A0),AuxCPtr(A6)	; and get a pointer too!; ------------- setup window info -------------; Get the font info for this window.  Put the height of the title bar in; titleHgtReg and wHeight(A6).  Put distance of the top of the goaway box; from the top of the bar in WBoxDelta(A6).;@CommonSys	pea		WInfo(A6)			; push pointer to a FontInfoRec			_GetFontInfo				; and get the font’s info			move.w	WInfo.wAscent(A6),titleHgtReg ; get font ascent			add.w	WInfo.wDescent(A6),titleHgtReg ; add descent			addq.w	#4,titleHgtReg		; get the height			BSET	#0,titleHgtReg		; make height odd for symmetry			moveq	#minTitleH,D1		; get min title height for no icon			cmp.w	D1,titleHgtReg		; force height to minimum			bge.s	@3					; => not a tiny font			move.w	D1,-(SP)			; save min title height on stack			sub.w	titleHgtReg,D1		; how much less than minimum is it?			LSR.w	#1,D1				; used for centering tiny fonts			add.w	D1,WInfo.wAscent(A6) ; make the ascent "bigger"			move.w	(SP)+,titleHgtReg	; pop min title height@3			move.w	titleHgtReg,WInfo.wHeight(A6) ; WHeight=ascent+descent+2			move.w	titleHgtReg,D0		; get height			sub.w	#13,D0				; subtract height of box			LSR.w	#1,D0				; divide by 2			move.w	D0,WInfo.wBoxDelta(A6) ; save delta to goAway box; ------------- create a temp region -------------			clr.l	-(SP)				; create a temp region			_NewRgn 					; get a new region			move.l	(SP)+,TempRgn(A6)	; and save in our frame; ------------- get a pixmap for drawing the gadgets ------------			subq.l	#4, SP					; room for a PixMapHandle			move.l	#'pmap', -(SP)			; the Pixmap resource type			move.w	#kPixmapID, -(SP)		; ID of working pixmap			_GetResource			move.l	(SP)+, workPixmap(A6)	; save it for later			move.l	#16,D0					; allocate a bogus ctab 									_NewHandle	,SYS,CLEAR			;	in sys heap with 0 entries								move.l	A0, bogusCtab(A6)		; store the ctab so that we can dispose of it				move.l	workPixmap(A6),A0		; get the pixmap											move.l	(A0),A0					; get ptr to pixmap											move.l	bogusCtab(A6),pmTable(A0)	; put the bogus ctab in our pixmap						clr.l	tempPixels(A6)			; init this to NIL; ------------- go handle the message -------------			move.w	message(A6),D0		; get message			ADD 	D0,D0				; double for word index			lea 	GoDocProc,A0		; get jump table address			add.w	GoDocProc(D0),A0	; compute dispatch address			jsr 	(A0); ------------- prepare to exit WDEF -------------; Dispose of all data allocated and restore port			move.l	bogusCtab(A6),A0	; Dispose the bogus Color table									_DisposHandle				;			move.l	TempRgn(A6),-(SP)	; dispose of temp region			_DisposRgn					;			tst.b	IsColor(A6)			; are we on a color system?			beq.s	@NoColor2			; if on B&W, then skip; ------------- color clean up -------------; unlock the color table and restore the fore- and backColors									 			move.l	AuxCTab(A6),A0		; get the colortable handle			_HUnlock					; release it			pea		SavBkCol(A6)		; pointer to RGBColor			_RGBBackColor				;			pea		SavFgCol(A6)		; pointer to RGBColor			_RGBForeColor				;@NoColor2								; END OF A COLOR-ONLY SECTION			move.l	OldPort(A6),-(SP)	; restore previous port			_SetPort; ------------- End of WDEF -------------WDEFEnd									; ‘Out Of Range, of course’			moveM.l (SP)+,D3-D7/A1-A4	; restore work registers			UNLK	A6					; unlink stack frame			move.l	(SP)+,A0			; get return address			ADD 	#ParamSize,SP		; strip parameters			jmp 	(A0)				; return to caller; ------------- WDEF message jump table -------------; dispatch table -- entries must be long branches!GoDocProc	dc.w	DrawDoc-GoDocProc	; draw is message #0			dc.w	HitDoc-GoDocProc	; hit test is message #1			dc.w	CalcDoc-GoDocProc	; calc test is message #2			dc.w	InitDoc-GoDocProc	; init is message #3			dc.w	DisposeDoc-GoDocProc ; dispose is message #4			dc.w	GrowDoc-GoDocProc	; grow message is #5			dc.w	DrawGIcon-GoDocProc ; draw grow icon is #6; ================================================; wNew message; ================================================; InitDoc is used to initialize our zoom size and title icon handle; Need to make sure the goAway is ignored if the application tried to; set this flag.  Changing this here will change the window record.; The application could set the goAway flag after creating the window,; but that doesn’t seem likely to happen.InitDoc			tst.b	IsProcFive(A6)		; dBoxProc with title bar?			beq.s	@KeepGoAway			; no, don’t touch goAway flag			clr.w	wGoAway(windowReg)	; yes, then clear the flag out@KeepGoAway			moveq	#8+8,D0				; space for 2 rects			_NewHandle ,clear			; allocate the space			move.l	A0,wDataHandle(windowReg)	; save handle to data			beq.s	InitDone					; => not able to get space			move.w	varCode(A6),D0			Btst	#hasZoom,D0			; does it want a zoom box?			beq.s	InitDone			; no, then we’re done; ------------- initialize userState and stdState -------------; set default zoom data.  Consists of 2 rects: SmallSize, BigSize; get the size of the zoomed out window in global coordinates.	To do this,; pull the screen size from screenbits.bounds and indent a little.			addq.b	#1,wZoom(windowReg)	; set zoom flag to TRUE			move.l	(A0),A2 			; point to data			addq.w	#8,A2				; point to bigSize			move.l	GrafGlobals(A5),A1	; point to QuickDraw globals			move.l	screenBits+bounds(A1),(A2)+ 	; get topLeft			move.l	screenBits+bounds+4(A1),(A2)+	; get botRight			moveq	#3,D0							; get indent; Zooming the dBoxProc with a title.  Here I set the alternate size to be; further inset of the screen.  This doesn’t take into account the; normal zoomable windows have a shadow and this causes the proc=5 to be; zoomed out one pixel short on the right edge.  Also, since proc=5 shares; a portion of the title area with the fancy border of the content this; makes the title bar zoom a few pixels lower than normal window.; Applications using this window are suppose to manually set the alternate; size anyway, so I’m not too concerned about this.			tst.b	IsProcFive(A6)		; dBoxProc with title bar?			beq.s	@1					; no, use normal sizing			addq.w	#dBoxBorderSize,D0	; add fancy border to sizing; ------------- inset stdState based on indentation -------------@1			sub.w	D0,-(A2)			; indent right			sub.w	D0,-(A2)			; indent bottom			add.w	D0,-(A2)			; indent left			add.w	D0,-(A2)			; indent top			move.w	MBarHeight,D0 		; get menu bar height			add.w	D0,(A2)				; past menu bar height			add.w	titleHgtReg,(A2) 	; and past window title			move.l	(A0),rectReg 		; point at userState			bsr		GetRect				; convert rect to globalInitDone	rts; ================================================; wDispose message; ================================================; DisposeDoc is called when the window is being closed.  All we need to do is; give back the handle we borrowed.DisposeDoc			move.l	wDataHandle(windowReg),D0	; a data handle?			beq.s	DisposeDone			; no, then we’re done			move.l	D0, A0				; get data handle			_DisposHandle				; release it, ignoring errorsDisposeDone	rts; ================================================; wDraw message; ================================================; DrawDoc -- draw the document window.   The windowPtr is in windowReg; First test for a EORGoAway call and special case it; Put shadowing about into D4.DrawDoc		tst.b	wVisible(windowReg)		; is it visible?			beq 	@exitDrawDoc 			; if not, don’t do anything; ------------- set up shadow -------------			_PenNormal					; we want the normal pen			move.l	OneOne,D4			; get shadow factor, assume 1,1			tst.w	varCodeReg			; documentProc?			beq.s  	@1					; if so, we’re cool			add.l	D4,D4				; double the shadow to 2,2			cmp.w	#3,varCodeReg		; does it have shadow?			beq.s  	@1					; if so, we’re cool			moveq	#0,D4				; otherwise no shadow@1			move.l	structRgn(windowReg), -(SP)			pea		WDefDrawWindow		; address of devloop drawing proc			clr.l	-(SP)				; no unusual activities			clr.l	-(SP)				; and no user data			_DeviceLoop; DeviceLoop is a new call for System 7.0, that iterates through all the current gDevices and; sees if the region you passed is on a specific device.  If it is, it calls the drawing proc; you passed.  It does lots of other neat things for you also, see the Device Manager chapter; of Inside Mac VI for a full description of this call.			cmp.w 	#wInGoAway,paramReg ; was it an XOR call?			blt 	@exitDrawDoc		; if not, don’t invert state bit			eor.b	#1<<HiliteFlagBit, HiliteFlagGlobal@exitDrawDoc			rtsWDefDrawWindow			with	WDefDrawFrame			move.w	depth(SP), curDepth(A6)	; save this for SetupColor magic			move.l	devHandle(SP), D1		; pass this drawing device			bsr		CheckAvailableColors	; see if we have enough colors			cmp.w 	#wInGoAway,paramReg ; is it a goAway call?			bge 	EORStuff			; if so, go handle it			bclr	#HiliteFlagBit, HiliteFlagGlobal	; otherwise, init hilite flag; ------------- frame the window’s body -------------			tst.b	wHilited(windowReg)	; Is window highlighted?			bz.s	@inactiveFrame		; don’t draw shaded title bar			moveq	#wFrameColor,D0		; get fore color			bra.s	@frameShadeCorrect@inactiveFrame			moveq	#wHiliteShadeA,D0		; Get fore color@frameShadeCorrect			moveq	#wContentColor,D1	; get back color			bsr		SetupColors			; set ’em up			bsr		StructInTemp		; get StrucRgn.rgnBBox in rectReg			sub.l	D4,botRight(rectReg) ; inset botRight to ignore shadow			move.l	rectReg,-(SP)		; push rect address			_FrameRect					; frame the body			cmp.l	#0,D4				; any drop shadow?			beq.s	NoDrop				; if not, skip; ------------- draw the drop shadow -------------; paint the drop shadow, shadow amount in D4			moveq	#wFrameColor,D0		; Draw drop shadow with frame color always			bsr		SetupForeColor			move.l	D4,-(SP)			; push shadow factor			_PenSize					; make penSize = shadow factor			move.w	right(rectReg),-(SP) ; push right			move.w	top(rectReg),-(SP)	; push top			add.w	D4,(SP)				; add shadow factor			_MoveTo 					; MoveTo(right,top+shadow)			move.w	right(rectReg),-(SP) ; push right			move.w	bottom(rectReg),-(SP) ; push bottom			_LineTo 					; LineTo(right,bottom)			move.w	left(rectReg),-(SP)	; push left			add.w	D4,(SP)				; add shadow factor			move.w	bottom(rectReg),-(SP) ; push bottom			_LineTo 					; LineTo(left+shadow,bottom)			_PenNormal					; restore normal penNoDrop		cmp.w 	#1,varCodeReg		; dBoxProc?			bne		NotFancy			; if not, skip; ------------- draw fancy border -------------; draw fancy for dialog box ( only for variant 1).  The code is a little; difficult to follow, but it saved some bytes this way.  New feature; for a dBoxProc that’s deactive is that it get a gray frame.  Also, I; removed the flicker that used to happen when a dBoxProc went deactive.; In the case of the dBoxProc with title bar, the fancy border needs to; consider the title area, and that the bottom of the title area is shared; with the fancy border by a few pixels.			tst.b	IsProcFive(A6)		; dBoxProc with title?			beq.s	@1					; no, then don’t adjust framing			add.w	titleHgtReg,top(rectReg) ; TempRect still in rectReg 			subq.w	#proc5TopAdjust,top(rectReg) ; tweak it@1			move.l	rectReg,-(SP) 		; push the window’s structure rect			move.l	OneOne,-(SP)		;			_InsetRect					; inset TempRect			lea		borderShades,a2		; Get shades for fancy border			tst.b	wHilited(windowReg)	; Is window highlighted?			bnz.s	@drawBorders		; Yes.  Go draw the borders			add.w	#$10,a2				; Use gray shades for inactive windows			tst.b	threeDWind(a6)		; Are we using System 7 windows?			bnz.s	@drawBorders		; Yes, start drawing			move.l	GrafGlobals(a5),a0	; No.  Use dithered gray			pea		gray(a0)			_PenPat@drawBorders			move.w	(a2)+, -(SP)		; lower right shade			move.w	(a2)+, -(SP)		; upper left shade			move.w	(a2)+, -(SP)		; shade for corners			bsr		DrawShadedRect		; _FrameRect with shades			move.l	rectReg,-(SP) 		; push the window’s structure rect			move.l	OneOne,-(SP)		;			_InsetRect					; inset TempRect			move.w	(a2)+, D0	; shade for rect			bsr		SetupForeColor			move.l	rectReg,-(SP) 		; push the window’s structure rect			_FrameRect			move.l	rectReg,-(SP) 		; push the window’s structure rect			move.l	OneOne,-(SP)		;			_InsetRect					; inset TempRect			move.w	(a2)+, -(SP)		; lower right shade			move.w	(a2)+, -(SP)		; upper left shade			move.w	(a2)+, -(SP)		; shade for corners			bsr		DrawShadedRect		; _FrameRect with shades			move.l	rectReg,-(SP) 		; push the window’s structure rect			move.l	OneOne,-(SP)		;			_InsetRect					; inset TempRect			move.w	(a2)+, D0			; shade for rect			bsr		SetupForeColor			move.l	rectReg,-(SP) 		; push the window’s structure rect			_FrameRect			move.l	rectReg,-(SP) 		; push the window’s structure rect			move.l	OneOne,-(SP)		;			_InsetRect					; inset TempRect			move.l	#$00030003,-(SP)	; erase to edge of content rgn			_PenSize					; get a thick pen			move.l	(A5), A2			; get graphic globals			pea 	white(A2)			; white for erasing			_PenPat						; set pen pattern			move.l	rectReg,-(SP)		; push TempRect			_FrameRect					; and frame TempRect			_PenNormal					; back to normal penNotFancy	tst.b	IsProcFive(A6)		; dBox with a title bar?			bne.s	DrawTitleBar		; yes, then draw it			tst.w	varCodeReg			; test for dialog windows			bne 	WDefDrawDone		; yes, dialogs have no title bar; ------------- draw the title bar -------------; Derive the titleBar rect from the structRgn and keep it in TempRect. Keep; rectReg preserved since it now points at TempRect.DrawTitleBar			bsr 	BuildTBarRect		; title rect in TempRect and rectReg			clr.b	-(SP)				; room for Boolean			move.l	rectReg, -(SP)		; test the title bar rect for			move.l	(A5), A0			; quickdraw globals			move.l	thePort(A0), A0		; point at current (Wmgr) port			move.l	visRgn(A0), -(SP) 	; intersection with the visRgn			_RectInRgn			tst.b	(SP)+				; test the result			bz		WDefDrawDone		; if not, skip all this work			tst.b	wHilited(windowReg)		; do we have a white background?			bz.s	@inactiveTitle		; don’t draw shaded title bar			moveq	#wFrameColor,D0		; get fore color			moveq	#wTitleBarShade1, D1	; get back color			bra.s	@titleShadeCorrect@inactiveTitle			moveq	#wHiliteShadeA,D0	; Get fore color			moveq	#wContentColor, D1	; get back color@titleShadeCorrect			bsr		SetupColors			; set ’em up			tst.b	isProcFive(A6)		; dBoxProc with title?			bnz.s	@1					; don’t frame title if so			move.l	rectReg, -(SP)		; rect of title bar			_FrameRect@1			move.l	rectReg, -(SP)			; rect of title bar			move.l	(SP), -(SP)				; also for _EraseRect			move.l	OneOne, -(SP)			; inset factor of 1, 1			_InsetRect						; exclude the actual frame			_EraseRect						; erase the contents			tst.b	wHilited(windowReg)		; do we have a white background?			bz.s	@doTitle				; don’t draw 3-d title bar			moveq	#wLTinge0, D0			; fore color			bsr		SetupForeColor			; do the right thing			move.w	left(rectReg), -(SP)	; left of tb interior			move.w	bottom(rectReg), -(SP)	; bottom of tb interior			sub.w	#1, (SP)				; pen falls to lower right			_MoveTo			clr.w	-(SP)					; no horiz delta			move.w	bottom(rectReg), D0		; vertical delta is bottom-top			sub.w	top(rectReg), D0			subq.w	#1, D0			neg.w	D0						; going -v, not +v			move.w	D0, -(SP)			_Line							; draw left hilite			move.w	right(rectReg), D0		; horiz delta is right			sub.w	left(rectReg), D0		; minus left			subq.w	#1, D0			move.w	D0, -(SP)			clr.w	-(SP)					; no v delta			_Line							; draw top hilite			moveq	#wLTinge4, D0			; fore color			bsr		SetupForeColor			; do the right thing			clr.w	-(SP)					; no h delta			move.w	bottom(rectReg), D0		; vertical delta is bottom-top			sub.w	top(rectReg), D0			subq.w	#1, D0			move.w	D0, -(SP)			_Line							; draw left hilite			move.w	right(rectReg), D0		; horiz delta is right			sub.w	left(rectReg), D0		; minus left			subq.w	#1, D0			neg.w	D0						; going -h, not +h			move.w	D0, -(SP)			clr.w	-(SP)					; no v delta			_Line							; draw top hilite@doTitle; ------------- DoTitleString  -------------; To prevent title flicker, DoTitleString leaves the left edge of the; title in D3 and the right edge in D4.  If the title bar needs to be; highlighted, the highlighting is done in 2 sections, one on each side; of the title.  DoTitleString draws the title centered in tempRect.; Warning -- it trashes D3 and D4.; compute indent factor based on GoAwayButton state			move.w	right(rectReg),D4	; get right into D4			move.w	D4,D3				;			sub.w	left(rectReg),D3	; compute width			sub.w	wTitleWidth(windowReg),D3	; compute extra x			asr.w	#1,D3				; divide by 2; if the string is too long, position left edge			moveq	#2,D0				; start title at x = 2			tst.b	wGoAway(windowReg) 	; is there a go away button			beq.s	@2					; skip if there’s not			moveq	#32,D0				; start title at x = 32@2			cmp.w	D0,D3				; to left of x?			bge.s	@3					; => no, D3 is ok			move.w	D0,D3@3			move.w	D3,D0				; save left indent in D0										add.w	left(rectReg),D3	; compute x position			move.w	D4,-(SP)			; save right across clip			tst.b	wZoom(windowReg)	; zoom flag set?			beq.s	@4					; => no, edge ok			sub.w	#32,D4				; get default right edge			bra.s	@doneAdjustRight	;													@4										; set clip to d3..d4			sub.w	D0,D4				; adjust right to have the same indent as left		@doneAdjustRight			move.l	 TempRgn(A6),-(SP)	; get our temp region			move.l	 (SP),-(SP) 		; copy for SectRgn			_GetClip					; and save for restore			move.w	D4,right(rectReg)	; set right for clipping			move.l	rectReg,-(SP)		; push tempRect			_ClipRect					; set clipping to it			move.l	(A5),A0 			; get globals			move.l	(A0),A0 			; get port			move.l	clipRgn(A0),-(SP)	; and the rect region			move.l	(SP),-(SP)			; and use clip as dest			_SectRgn					; get the intersection			move.w	(SP)+,right(rectReg); restore tempRect			move.w	D3,-(SP)			; push left for MoveTo; ------------- draw title string -------------			move.w	top(rectReg),D0 	; get top			add.w	WInfo.wAscent(A6),D0 ; move down to baseline			addq.w	#1,D0				; leave 2 pixels white space			move.w	D0,-(SP)			; push baseline			_MoveTo			tst.b	wHilited(windowReg)	; Is it highlighted?			beq.s	@noHighlight		; No			moveq	#wTextColor,D0		; get fore color for highlighted title			bra.s	@drawTitle@noHighlight			moveq	#wHiliteShade7,D0	; Use a gray shade to dim title string if not highlighted. @drawTitle			moveq	#wTitleBarShade1,D1	; get back color			bsr		SetupColors			; set ’em up			move.w	#srcOr,-(SP)		; set the mode to source OR			_TextMode					;			move.l	wTitleHandle(windowReg),A0	; get titleHandle			_HLock								; lock the title down			move.l	(A0),-(SP)					; push title pointer			_DrawString 						; draw it			move.l	wTitleHandle(windowReg),A0	; get the handle again			_HUnlock							; release it			move.l	TempRgn(A6),-(SP)	; push the old clip			_SetClip					; and restore it; ------------- calculate highlite rects  -------------; Now calculate the size of the clear area needed for the title; (only used if the window is highlighted).  The two registers D3 and; D4 are used to supply the left and right edges of the gap in the title; area for occupied by the string.  If no title is supplied, then there; isn’t a gap.  If there is a title, then there is an extra indentation; of a few pixels added.			move.w	D3,D1				; left in D3, calc right in D1			add.w	wTitleWidth(windowReg),D1	; add in the length			cmp.w	D4,D1				; was title longer than space?			bge.s	@5					; => yes, use D4			move.w	D1,D4				;@5			tst.w	wTitleWidth(windowReg)	; is there a title?			beq.s	@NoIndent			; no, then don’t include indent			addq.w	#6,D4				; indent on right			subq	#6,D3				; indent to the left@NoIndent								; no indentation				 						; Left in D3, right in D4; ------------- draw title bar highliting -------------			tst.b	wHilited(windowReg)	; is it hilited?			bne.s	DoHilite			; yes, then draw it			bra.w 	WDefDrawDone				; no, done with all drawingDoHilite			moveq	#wHiliteShade8, D0		; get fore color			bsr		SetupForeColor			; set ’em up			move.l	rectReg,-(SP)		; push the title rect			move.w	#1,-(SP)			; push dh			move.w	WInfo.wBoxDelta(A6),-(SP) ; push dv			_InsetRect					; inset it some; The dBoxProc with title has a two pixel fancy border around the entire; window.  When drawing the highlited pattern, I need to allow for this.			tst.b	IsProcFive(A6)		; dBoxProc with title?			beq.s	@NoAdjust			; no, then skip adjustment			addq.w	#1,left(rectReg)	; yes, adjust title bar left			subq.w	#1,right(rectReg)	; and right@NoAdjust; This WDEF tries to put at least 32 pixels on the left of the title if there is a go-away box.; However, if the title bar is less than 32 pixels wide, we will have a problem in which the; "racing" stripes will be drawn outside the title bar.; The following check is to make sure that the lines will be drawn within the title bar area.			move.w	right(rectReg),d0	; get right																		cmp.w	d0,d3				; Does lines fit in the title bar?												ble.s	@linesFitOnRight	; 	yes => continue																move.w	d0,d3				;	no => use the right of rect instead of the calculated value		@linesFitOnRight						;																				move.w	right(rectReg),-(SP) ; save right of TempRect			move.w	D3,right(rectReg)	; new right = title left			move.l	topLeft(rectReg),D0	; get topLeft			and.l	#$00070007,D0		; only use mod 8			move.l	(A5),A2 			; get globals, save in A2			move.l	D0,patAlign(A2) 	; set up patAlign			move.l	theZone,curZone(A6)	; save the current zone 			move.l	sysZone,theZone		; going to create the pixpat in sysZone 			move.l	rectReg,-(SP)		; fill this rect			pea 	HilitePattern		; push the pattern address			_FillRect					; fill left half with the pattern			tst.b	wZoom(windowReg)	; zoom flag set?			beq.s	@1					; => no, use current d4			move.w	(SP),D0 			; else get right edge of box			sub.w	#26,D0				; how much room is there?			cmp.w	D4,D0				; need at least 26 pixels			bge.s	@1					; => got ’em, use current d4			move.w	D0,D4				; else use right-26@1			move.w	(SP)+,right(rectReg) ; restore right of title box; This WDEF tries to put at least 26 pixels on the right if there is a zoom box or matches the indent; from the left. This may cause a problem in which the "racing stripes" will be drawn outside the title; bar area if the title bar is too small. The following check makes sure that the lines will be drawn; within the title bar area.			move.w	left(rectReg),d0	; get left of rect													 			cmp.w	d0,d4				; Does lines fit in the title bar?									 			bge.s	@linesFitOnLeft		;	yes => continue													 			move.w	d0,d4				;	no => use left instead of the calculated value					 @linesFitOnLeft							;																				move.w	D4,left(rectReg)	; set new left of title box			move.l	rectReg,-(SP)		; fill this rect			pea 	HilitePattern		; push the pattern address			_FillRect			move.l	curZone(A6),theZone	; restore the zone 			clr.l	patAlign(A2); ------------- DoGoAway  -------------			tst.b	wGoAway(windowReg)	; is there a goaway button?			beq.s	DoZoom				; => if not, try for zoom			moveq	#wGoAwayGadget, D0			bsr		SetupColorPict			pea		TingeGoAway			; Address of tinge routine			bsr	 	PlotGoAway; ------------- DoZoom  -------------DoZoom		tst.b	wZoom(windowReg)	; zoom flag set?			beq.s	WDefDrawDone		; no, then done drawing			moveq	#wZoomGadget, D0			bsr		SetupColorPict			pea		TingeZoom			; Address of tinge routine			bsr	 	PlotZoom			; and plot the symbol			bra.s	WDefDrawDone		; done drawing; ------------- goAway and zoom box highliting -------------; decide which icon needs hilitingEORStuff	beq.s	EORGoAway			; => it’s the goAway			tst.b	wZoom(windowReg)	; zoom flag set?			beq.s	WDefDrawDone		; => no			btst	#HiliteFlagBit, HiliteFlagGlobal			bz.s	@drawHilitedZoom			moveq	#wZoomGadget, D0			pea		TingeZoom			bra.s	@zoomCommon@drawHilitedZoom			moveq	#wZoomHilitedGadget, D0			clr.l	-(sp)				; No tinge routine@zoomCommon			bsr		SetupColorPict			bsr	 	PlotZoom			; and plot the symbol			bra.s	WDefDrawDoneEORGoAway								; hilites/unhilites the goAway			btst	#HiliteFlagBit, HiliteFlagGlobal			bz.s	@drawHilitedGoAway			moveq	#wGoAwayGadget, D0			pea		TingeGoAway			bra.s	@goAwayCommon@drawHilitedGoAway			moveq	#wGoAwayHilitedGadget, D0			clr.l	-(sp)				; Highlighted state needs no tinging@goAwayCommon			bsr		SetupColorPict			bsr		PlotGoAwayWDefDrawDone			move.l	(SP)+, A0			; return address			lea		WDefDrawFrame.ParamSize(SP), SP	; pop params			jmp		(A0)DrawShadedRectShadedRectFrame	RECORD	0retAddr		ds.l	1StartParams	EQU		*cornerColor	ds.w	1ulColor		ds.w	1lrColor		ds.w	1ParamSize	EQU		*-StartParams			ENDR			with	ShadedRectFrame			move.w	cornerColor(SP), D0		; shade/color of corner			bsr		SetupForeColor			; make it the pen color			move.w	left(rectReg), -(SP)	; start at lower left			move.w	bottom(rectReg), -(SP)			subq.w	#1, (SP)			_MoveTo			move.l	#$FFFF0000, -(SP)		; h=0, v=-1			_Line							; draw 1 pixel corner			move.w	ulColor(SP), D0			; get shade for left and top			bsr		SetupForeColor			; make it the pen color			move.l	top(rectReg), -(SP)		; top AND left			_LineTo							; draw line on left side			move.w	right(rectReg), -(SP)			subq.w	#1, (SP)			move.w	top(rectReg), -(SP)			_LineTo							; draw line across top			move.w	cornerColor(SP), D0		; need corner color again			bsr		SetupForeColor			; make it the pen color			move.w	right(rectReg), -(SP)	; start in upper right			subq.w	#1, (SP)			move.w	top(rectReg), -(SP)			_MoveTo			move.l	#$00010000, -(SP)		; h = 0, v = 1			_Line							; draw one pixel corner			move.w	lrColor(SP), D0			; get shade for right and bottom			bsr		SetupForeColor			move.l	bottom(rectReg), -(SP)	; bottom AND right			subq.w	#1, (SP)			subq.w	#1, 2(SP)			_LineTo							; draw line on right			move.w	left(rectReg), -(SP)			addq.w	#1, (SP)			move.w	bottom(rectReg), -(SP)			subq.w	#1, (SP)			_LineTo							; draw line across bottom			move.l	(SP)+, A0			addq.l	#ShadedRectFrame.ParamSize, SP			jmp		(A0)			endwith			endwith; ================================================; wHit message; ================================================; The hit test is to look for a click in the window’s content region.; The problem with this is that the WDEF extends the window’s contect to; include areas such as the fancy border, title bar, and drop shadow.  If; the user clicks in the fancy border or shadow it is outside of the content; but still within the window.  The reason for the inContent result in the; first place was to let the application know the user clicked any where; within the window excluding the drag area.  So, we check for a click; within the structRgn’s rect but remove the title bar is it has one.; This solved a few problems that hitherto were unknown, or at least not; reported.  ModalDialog no longers reports an error when clicking in the; dBoxProc’s fancy border.  Clicking in the drop shadow is a click in the; window.  Since a dBoxProc with title bar allows switching in MultiFinder,; clicking in the fancy border *must* be considered a click in the window.; paramReg holds the mousePoint in global coordinates .; windowReg holds the window pointerHitDoc		clr.w	-(SP)				; make room for function result			move.l	paramReg,-(SP)		; push the mouse point			bsr		StructInTemp		; structRgn.rgnBBox in TempRect			tst.w	varCodeReg			; dialog window?			beq.s 	@1					; no, they have a title bar			tst.b	IsProcFive(A6)		; dBoxProc with title?			beq.s	@2					; no, then no title bar@1			add.w	titleHgtReg,top(rectReg) ; remove title bar area@2			move.l	rectReg,-(SP)		; point at TempRect			_PtInRect					; pt in window area less title bar?			tst.b	(SP)+				; well, is it?			beq.s	NotInContent		; if not, go check out drag region										; see if its in the grow icon area			tst.w	varCodeReg			; is it a dialogBox?			bne.s	JustContent 		; if so, its only in the content; ------------- hit in grow?  -------------			tst.b	wHilited(windowReg) ; is it active?									beq.s	JustContent 		; if not, it cant be in grow			move.w	varCode(A6),D0			Btst	#hasGrow,D0			; inGrow enabled?			BGT.s	JustContent 		; if not, skip			move.l	contRgn(windowReg),A0	; get region handle							move.l	(A0),A0 				; get region ptr			move.l	rgnBBox+botRight(A0),D0 ; get bottom left of content										; first consider the x coordinate			moveq	#14,D4				; keep 14 in a register to save code			sub 	D4,D0				; offset x by 14			cmp 	D0,paramReg			; if <, just in content			BLT.s	JustContent			SWAP	D0					; its within range on x so try y			sub 	D4,D0				; check out y dimension			SWAP	paramReg			cmp 	D0,paramReg			; compare y coordinates			BLT.s	JustContent			moveq	#wInGrow,D0 		; flag in grow Icon			bra 	DoneHitDoc; the point is in the content region so return a ‘1’JustContent			moveq	#wInContent,D0		; return in content			bra 	DoneHitDoc			; go store function result and return; ------------- hit not in content  -------------; Not in the content.  see if its in the dragRgn (content extended by; titleBar) dBoxProc may have tile higher above content than normal.NotInContent			bsr 	BuildTBarRect		; title bar rect into rectReg			clr.w	-(SP)				; make room for function result			move.l	paramReg,-(SP)		; push the mouse point			move.l	rectReg,-(SP)		; and push the rect			_PtInRect					; is the point in the title bar?			tst.b	(SP)+				; examine result			beq		DoneHitDoc2			; if not, return already = 0			tst.b	wHilited(windowReg)	; is it hilited?			beq.s	ItsInDrag			; if not, can’t be in GoAway; ------------- hit in goAway or Zoom?  -------------; test vertical first for goAway and Zoom since they’re the same			move.l	paramReg,D0			; check vertical			SWAP	D0					; which is high word of mousePoint			move.l	windowReg,A0		; convert pointer if its a pixmap			bsr		PortToMap			; convert						 			add.w	bounds+top(A0),D0	; convert to local			sub.w	portRect+top(windowReg),D0 	; compensate for origin; The vertical hit test assumes the zoom is offset from the portRect.; The dBoxProc with title has the title area sharing a portion of the fancy; border surrounding the content.  So, an adjustment is needed to locate; the zoom box’s vertical position.			tst.b	IsProcFive(A6)		; dBoxProc with title bar?			beq.s	@OldVert			; no, use normal vertical test			addq.w	#proc5TopAdjust,D0	; yes, then tweak it@OldVert								; continue with normal testing			add.w	WInfo.wBoxDelta(A6),D0 ; below box?			bpl.s	ItsInDrag				; => yes			add.w	#11,D0					; in box?			BMI.s	ItsInDrag				; => no			tst.b	wGoAway(windowReg)	; is there a goAway button?			beq.s	HitZoom 			; => no, hit-test zoom			move.l	paramReg,D0			; get mousePt			ADD 	bounds+left(A0),D0	; convert to local (A0 still valid)  			sub 	portRect+left(windowReg),D0	; compensate for origin			cmp 	#18,D0				; is it too far right?			BGT.s	HitZoom 			; if so, its in drag			subq.w	#8,D0				; it must be at least 7			BMI.s	ItsInDrag			moveq	#wInGoAway,D0		; its in the goAway button so signal it			bra.s	DoneHitDocHitZoom		tst.b	wZoom(windowReg)	; zoom flag set?			beq.s	ItsInDrag			; => not in these here parts			move.w	paramReg,D0				; get mousePt			move.l	windowReg,A0			; convert pointer if its a pixmap			bsr		PortToMap				; convert					 			add.w	bounds+left(A0),D0	; convert to local			sub.w	portRect+right(windowReg),D0	; make right edge = 0; The dBoxProc with title has moved the zoom box in towards the left due to; the fancy border.  Need to adjust horizontal hit test for this case.			tst.b	IsProcFive(A6)			; dBoxProc with title?			beq.s	@OldZoomHit				; no, then normal position			subq.w	#proc5HitZAdjust,D0		; tweak it@OldZoomHit									; continue with testing			cmp.w	#-19,D0 				; too far left?			BLT.s	ItsInDrag				; => if so, it’s in drag			cmp.w	#-9,D0					; too far right?			BGT.s	ItsInDrag				; => if so, it’s in drag			bsr 	IsItSmall				; is window big?			beq.s	@1						; => oh boy, right again			moveq	#wInZoomOut,D0			; say window small			bra.s	DoneHitDoc				; und scram-muller@1			moveq	#wInZoomIn,D0			; say window big			bra.s	DoneHitDoc				; and muller out of hereItsInDrag	moveq	#wInDrag,D0 		; flag in drag regionDoneHitDoc	move.l	D0,ProcResult(A6)		; update function resultDoneHitDoc2	rts; ================================================; wCalcRgns message; ================================================; CalcDoc  -- calculate the structure and content regions for the window pointed; to by windowReg.  First update size for zooming if necessaryCalcDoc 	tst.b	wZoom(windowReg)	; zoom flag set?			beq.s	@1					; => no			bsr 	IsItSmall			; update window size; ------------- calc ContRgn -------------@1			bsr		GetRect				; make a rectangular content region			move.l	contRgn(windowReg),-(SP) ; content region gets result			move.l	rectReg,-(SP)		; tempRect is the rectangle			_RectRgn					; go make the region into content region; ------------- calc structRgn -------------; now do the structure region.	First correct the bounding rectangle (tempRect) for; structure instead of content			move.l	#$00020002,D4		; get the shadow factor for DBox			move.l	structRgn(windowReg),-(SP) ; push the structRgn for later			move.l	rectReg,-(SP)		; tempRect is the rect in rectReg			move.l	rectReg,-(SP)		; make two copies			move.l	MinusOne,-(SP)		; make 1 pixel bigger, all around			_InsetRect					; make it bigger			tst.w	varCodeReg			; is it dBox?			bne.s	DoDBoxCalc			; skip if it is			move.w	titleHgtReg,D0 		; move up to top of window			subq.w	#1,D0				; tweak it			sub.w	D0,top(rectReg) 	; and set top of struct region			LSR.l	#1,D4				; adjust shadow factor			bra.s	CalcCommon			; use common code for the rest; ------------- calc structRgn for dialogs -------------DoDBoxCalc			cmp 	#1,varCodeReg		; is it variant 1?			bne.s	CalcCommon			move.l	rectReg,-(SP)		; tempRect is the rect in rectReg			move.l	#$FFF9FFF9,-(SP)	; push (-7,-7)			_InsetRect					; inset it; The dBoxProc with title needs a larger structRgn. Also, a portion of this; title area is shared with the fancy border that surrounds the	content.			tst.b	IsProcFive(A6)		; dBoxProc with title?			beq.s	CalcCommon			; skip if without title bar			move.w	titleHgtReg,D0 		; move up to top of window			subq.w	#proc5TopAdjust,D0	; tweak it			sub.w	D0,top(rectReg) 	; and set top of struct regionCalcCommon								; create the structRgn for all windows.			_RectRgn					; RectRgn(structRgn,tempRect)			tst 	varCodeReg			beq.s	@1					; if so, it has shadow			cmp 	#3,varCodeReg		; is it variant 3?			bne.s	CalcDone			; if not, no shadow@1; ------------- include drop shadow -------------; now add in the 1 or 2 pixel drop shadow			move.l	TempRgn(A6),-(SP)	; get temp region			move.l	rectReg,-(SP)		; tempRect is the rect in rectReg			move.l	(SP),-(SP)			; save another copy			move.l	D4,-(SP)			; push shadow factor			_OffsetRect 				; offset it			_RectRgn			move.l	structRgn(windowReg),-(SP)	;			move.l	TempRgn(A6),-(SP)			; get temp region			move.l	structRgn(windowReg),-(SP)	; structure gets the result			_UnionRgn							; add it inCalcDone	rts							; all done with CalcDocRgns; ================================================; wGrow message; ================================================; GrowDoc handles the grow message by drawing a grow outline based on; the rectangle held in paramReg.  First make it one pixel bigger to; jibe with the structure then frame the entire window.GrowDoc		move.l	paramReg,-(SP)		; push the rect			move.l	MinusOne,-(SP)		; push (-1,-1)			_InsetRect			move.l	paramReg,A3			; get rect ptr			move.l	topLeft(A3),-(SP)	; save topleft for below			move.w	titleHgtReg,D0 		; adjust for title			subq.w	#1,D0				; and tweak it			sub.w	D0,top(A3)			; and save it			move.l	paramReg,-(SP)		; push the rectangle			_FrameRect					; frame it; ------------- draw the lower horizontal -------------; line at the top of the horizontal scroll bar area			move.w	left(A3),-(SP)		; push left			move.w	bottom(A3),-(SP)	; push bottom			sub 	#scrollBarSize,(SP)	; a few pixels above bottom			move.l	(SP),-(SP)			; make a copy of this point			_MoveTo 					; move to it			move.w	right(A3),2(SP) 	; now go to the right edge			_LineTo 					; draw the horizontal line; ------------- draw the upper horizontal -------------; line below the title bar area			move.l	(SP),topLeft(A3)	; restore topLeft, leave on stack			move.l	(SP),-(SP)			; make a copy of this point			_MoveTo 					; move to it			move.w	right(A3),2(SP) 	; now go to the right edge			_LineTo 					; draw the horizontal line; ------------- draw the vertical line -------------; line along left edge of the vertical scroll bar			move.w	right(A3),-(SP) 	; push right			sub 	#scrollBarSize,(SP)	; few pixels to the left			move.w	top(A3),-(SP)		; push top			move.l	(SP),-(SP)			; make a copy of this point			_MoveTo 					; and move to it			move.w	bottom(A3),(SP) 	; now go to bottom edge			_LineTo 					; draw the vertical line										; restore the rect back to										; how it was when we got it			move.l	paramReg,-(SP)		; push the rect			move.l	OneOne,-(SP)		; push (1,1)			_InsetRectGrowDone	rts; ================================================; wDrawGIcon message; ================================================;  Draw the grow icon.	First make this window the current grafPortDrawGIcon			move.l	GrafGlobals(A5),A0	; get the current port and save it  			move.l	thePort(A0),-(SP)	;								    			move.l	windowReg,-(SP)		; push the window’s port			_SetPort					; make that the port			clr.l	globalOffset(a6)	; No offset for BW systems.			tst.b	IsColor(A6)			; is this a color system?			beq		@NoColor8			; Nope.  Skip color stuff												; ------------- do color window -------------; The region passed to _DeviceLoop has to be offset into global coordinates on; color systems since we’re drawing into the window manager port.			move.l	GrafGlobals(a5),a0	; get the port															 			move.l	thePort(a0),a0		;																		/ /			lea		portBits(a0),a0		; point to “bitmap” in the port											/ /			tst.w	rowBytes(a0)		; is this a color port?													 			bpl.s	@bitmap				;																		 			move.l	baseAddr(a0),a0		; pixmap handle															 			move.l	(a0),a0				; pixmap ptr															 @bitmap									;																		 			move.l	ScrnBase,d0			; get base address of screen											 			cmp.l	baseAddr(a0),d0		; is it the same as thePort’s ?											 			beq.s	@drawToScreen		; yes => we are drawing to screen										 			move.w	#1, -(SP)			; no => assume old-port, depth equals 1									 			tst.w	rowBytes(A0)		; is this an old-style port?											 			bpl.s	@depthOk			; yes. depth of 1 on stack is okay										 			move.w	pmPixelSize(A0),(SP)	; fix depth on stack												 @depthOk								;																		 			move.w	#fakeDeviceFlags, -(SP)	; assume non-CQD case												 			clr.l	-(SP)				; NIL gDeviceHandle for non-CQD machines								 			btst	#6,ROM85			; Color QuickDraw available?											 			bnz		@deviceAndFlagsOk	; of not, fake versions on stack are correct							 			move.l	theGDevice, A1		; current device GDHandle												 			move.l	A1,(SP)				; fix gdHandle on stack													 			move.l	(A1), A1			; point to the device													 			move.w	gdFlags(A1),4(SP)	; fix gdFlags on stack													 @deviceAndFlagsOk						;																		 			clr.l	-(SP)				; flag clear (not drawing to screen)									 			bsr		WDefDrawGIcon		; 																		 			bra		@exitDrawGIcon		; 																		 @drawToScreen							;																		 			lea		globalOffset(a6),a2			move.l	portRect(windowReg),d4			move.l	d4,(a2)			move.l	a2,-(sp)			_LocalToGlobal				; Convert topLeft to global coordinates			move.l	d4,-(SP)			; push src point					 			move.l	a2,-(SP)			; push ptr to dest point			 			_SubPt						; get local to global offset		 ; save the foreground and background of the WMgr port & set new colors			subq	#6,SP				; make room for rgbColor on stack	 			move.l	SP,-(SP)			; push pointer to placeholder		 			_GetForeColor				; get the window port’s foreColor	 			subq	#6,SP				; make room for the backColor too	 			move.l	SP,-(SP)			; push pointer to placeholder		 			_GetBackColor				; get the window port’s backColor	 ; Get the intersection of the clipRgn and visRgn of the window to use as the; clipping region for drawing the grow icon.			move.l	clipRgn(windowReg),-(sp)			move.l	visRgn(windowReg),-(sp)			move.l	tempRgn(a6),-(sp)			_SectRgn 					; Get intersection of portRect & visRgn			move.l	tempRgn(a6),-(sp)			move.l	(a2),-(sp)			_OfsetRgn					; Move the clipRgn into global coordinates			move.l	WMgrCPort,-(sp)			_SetPort					; Set port back to WMgrPort			subq	#4,sp				;												 			_NewRgn						; Allocate new region…							 			move.l	(sp),-(sp)			;												 			_GetClip					;  to save WMgrPort’s clipRgn in.				 			move.l	tempRgn(A6),-(sp)			move.l	(SP), -(SP)			; once more for DeviceLoop			_SetClip					; Clip to the window’s clipRgn			bra.s	@isColor			; Fill in the other _DeviceLoop parameters@NoColor8								; END OF COLOR-ONLY SECTION			move.l	tempRgn(A6), -(SP)	; rgn handle			move.l	(SP), -(SP)			; once more for DeviceLoop			pea		portRect(windowReg)	; local coord rect			_RectRgn@isColor			pea		WDefDrawGIcon		; address of devloop drawing proc			clr.l	-(SP)				; no unusual activities			clr.l	-(SP)				; and no user data			_DeviceLoop			tst.b	IsColor(A6)			; is it a color system?			beq.s	@exitDrawGIcon		; no, so skip this restore			move.l	(sp),-(sp)			_SetClip					; Restore WMgrPort clipRgn			_DisposRgn					; Get rid of saved region			move.l	SP,-(SP)			; push ptr to rgbColor previously saved on top of stack 	 			_RGBBackColor				; 								 			addq	#6,SP				; trash backcolor				 			move.l	SP,-(SP)			; 								 			_RGBForeColor				;								 			addq	#6,SP				;								 @exitDrawGIcon			_SetPort					; restore the incoming port (saved above)  			rtsWDefDrawGIcon			with	WDefDrawFrame			move.w	depth(SP), curDepth(A6)	; save this for SetupColor magic			move.l	devHandle(SP), D1		; pass this drawing device			bsr		CheckAvailableColors			moveq	#wFrameColor,D0		; get fore color			moveq	#wContentColor,D1	; get back color			bsr		SetupColors			; set ’em up; ------------- plot grow icon -------------; compute the grow icon rectangle in tempRect which is inside the lower; left corner of the scroll bar area.			move.l	globalOffset(a6),d4						; Get offset amount			move.l	portRect+botRight(windowReg),(rectReg)	; botRight=topLeft			move.l	(rectReg),botRight(rectReg)				; copy into botRight, too			add.l	d4,(rectReg)							; Adjust for global case			add.l	d4,botRight(rectReg)					; Adjust for global case			sub.w	#scrollBarSize-2,top(rectReg)			; remove scroll area			sub.w	#scrollBarSize-2,left(rectReg)			tst.b	wHilited(windowReg)	; is it hilited?			bne.s	@1					; yes, plot it			move.l	rectReg,-(SP) 		; TempRect still in rectReg			_EraseRect					;			subi.l	#$00010001,(rectReg)	; Move topLeft back out			bra.s	PlotBoundary		;@1										;			moveq	#wGrowGadget, D0			bsr		SetupColorPict		; Get the grow gadget			beq.s	@2					; Don’t to extra stuff for black and white gadget; On color systems, the grow gadget is on a gray background;  do the gray.			move.w	d2,-(sp)			; PlotSymbol will need D2, so save it in case _EraseRect trashes it			moveq	#wTitleBarShade1, D0	; Use title bar gray for gray of grow icon			bsr		SetupBackColor			move.l	rectReg, -(SP)			_EraseRect					; Gray shade			move.w	(sp)+,d2; The inside of the grow gadget it a darker gray.  Set the rectangle to the area; to darken			move.l	#$00030003,d3			; Save ourselves 6 bytes by using a register			move.l	#$00040004,d4			add.l	d4,(rectReg)			sub.l	d3,botRight(rectReg)@2			subi.l	#$00010001,(rectReg)	; We subtracted one pixel less to avoid some flickering,			pea		TingeGrow			; Tinging routine for grow gadget			bsr		PlotSymbol			; so we have to put those pixels back before; Set colors for plotting boundary			moveq	#wFrameColor, D0	; get fore color			moveq	#wContentColor,D1	; get back color			bsr		SetupColors			; set it up; ------------- plot the boundary lines -------------; plot the left edge of the vertical scroll bar area and the top edge; of the horizontal scroll bar area.PlotBoundary			move.w	portRect+left(windowReg),-(SP)	; push portRect.left			move.l	globalOffset(a6),d4			add.w	d4,(sp)							; Adjust for global case			move.w	top(rectReg),-(SP)				; push tempRect.top			_MoveTo			move.w	portRect+right(windowReg),-(SP)	; push portRect.right			add.w	d4,(sp)							; Adjust for global case			move.w	top(rectReg),-(SP)				; push tempRect.top			_LineTo									; draw the horizontal line			swap	d4								; Get vertical offset into low word			move.w	left(rectReg),-(SP)				; push tempRect.left			move.w	(SP),-(SP)						; copy it again for later			move.w	portRect+top(windowReg),-(SP)	; push portRect.top			add.w	d4,(sp)							; Adjust for global case			_MoveTo 								; move to it			move.w	portRect+bottom(windowReg),-(SP) ; push portRect.bottom			add.w	d4,(sp)							; Adjust for global case			_LineTo 								; draw the vertical line; ------------- done with grow drawing -------------; don’t forget to take care of colors saved on stackDrawGrowDone			move.l	(SP)+, A0			; return address			lea		WDefDrawFrame.ParamSize(SP), SP	; pop params			jmp		(A0)			endwith; ================================================; Plotters; ================================================; common code to draw little things like the goAway, zoom, and grow boxes; A1 holds the symbol; rectReg is the rectangle’s address; D2 the plotting mode; A2 points at bitmap or pixmap rect info; ------------- Apply color tinge to the zoom box -------------TingeZoom			move.l	#$00040004,d3			sub.l	d3,botRight(rectReg)			move.l	rectReg,-(sp)			_FrameRect					; Draw little box in zoom box first			add.l	d3,botRight(rectReg)	; Restore full rectangle; ------------- Apply color tinge to the goAway box -------------TingeGoAway			move.l	rectReg,-(sp)			_FrameRect					; Draw upper part of shade			move.l	OneOne,d3			sub.l	d3,botRight(rectReg)			move.l	rectReg,-(sp)			_FrameRect					; Draw lower shade			move.l	rectReg,-(sp)			move.l	d3,-(sp)			_OffsetRect					; Position rectangle for light shade			moveq	#wLTinge0, D0			bsr		SetupForeColor		; Do light tinge			move.l	rectReg,-(sp)			_FrameRect					; Draw light tinge			sub.l	d3,(rectReg)		; Restore rectangle			rts; ------------- Apply color tinge to the grow box -------------TingeGrow			movem.l	d3/d4,-(sp)			; Save these registers			move.l	#$00010001,d4			add.l	d4,botRight(rectReg)			bsr.s	DrawGrowBoxPart		; Draw a section of the grow icon			moveq	#wDTingeF, D0		; Reset tinge for smaller box			bsr		SetupForeColor			move.l	rectReg,-(sp)			move.l	#-1,-(sp)			; Move rectangle up and to the left			_OffsetRect					; Set up position of smaller box			sub.l	#$00030003,botRight(rectReg)			bsr.s	DrawGrowBoxPart		; Draw smaller box			move.l	rectReg,-(sp)			move.l	d4,-(sp)			_InsetRect			add.l	d4,(rectReg)			moveq	#wTitleBarShade4,d0			bsr		SetupBackColor			move.l	rectReg,-(sp)			_EraseRect					; Refresh the dark gray inside small box			sub.l	d4,(rectReg)			asl.l	#2,d4			add.l	d4,botRight(rectReg)	; Restore rectangle			movem.l	(sp)+,d3/d4			; Restore registers; The main body of the wDrawGIcon routine shifted the rectangle.  Shift it back; to its original position here to save a check back in the mainstream.			sub.l	d4,(rectReg)			add.l	d3,botRight(rectReg)			rts; The grow box is made of two boxes that look like this:;;	@@@@@;	@oooo	DrawGrowBoxPart will draw this part based on the rectangle;	@o**@	in rectReg.  If we REALLY want to save some code, call TingeGoAway;	@o**@	instead of DrawGrowBoxPart.  The resulting gadget looks a little;	@o@@@	strange, but it’s passable in a pinch.;DrawGrowBoxPart			move.l	rectReg,-(sp)			_FrameRect					; Draw dark frame			moveq	#wLTinge0,D0			bsr		SetupForeColor			move.l	(rectReg),d3		; Get topLeft			add.l	OneOne,d3			move.w	d3,-(sp)			move.w	bottom(rectReg),-(sp)			sub.w	#1,(sp)			_MoveTo			move.l	d3,-(sp)			_LineTo						; Draw one light line			move.w	right(rectReg),-(sp)			sub.w	#1,(sp)			swap	d3			move.w	d3,-(sp)			_LineTo			rts; ------------- plot the goAway box  -------------PlotGoAway			bsr		BuildTBarRect		; build a title bar rect in rectReg			moveq	#9,D1				; add margin to left			bra.s	PlotIt				; use common code to plot it; ------------- plot the zoom box  -------------PlotZoom			bsr		BuildTBarRect		; build a title bar rect in rectReg			move	right(rectReg),left(rectReg) ; left := right-22			moveq	#-20,D1 			;; The dBoxProc with title has a fancy border around it’s structure.; This has to be taken into consideration when plotting the zoom box.			tst.b	IsProcFive(A6)		; dBoxProc with title?			beq.s	@1					; skip if standard title bar			subq.w	#1,D1				; inset zoom to the left@1										; don’t tweak it; ------------- plot the little dude face  -------------; make Temprect into a 16x16 square for our little bitmap; dest rect top = rectReg.top + WInfo.wBoxDelta - 1; dest rect bot = dest rect top + (A2).bottom - (A2).top; dest rect left = rectReg.left + D1; dest rect right = dest rect left + (A2).right - (A2).leftPlotIt			move.w	d2,-(sp)			add.w	D1,left(rectReg) 	; add offset to left			move.w	WInfo.wBoxDelta(A6), D1			add.w	D1, top(rectReg) 	; add offset to top			addq.w	#1, top(rectReg) 	; align bitmap			move.l	topLeft(rectReg),botRight(rectReg) ; topLeft = botRight			move.w	2+bottom(A2), D0			sub.w	2+top(A2), D0			add.w	D0, bottom(rectReg);			move.w	2+right(A2), D0			sub.w	2+left(A2), D0			add.w	D0, right(rectReg);			move.l	rectReg, -(SP)			move.l	#$FFFFFFFF, -(SP)			_InsetRect			moveq	#wTitleBarShade1, D0			bsr		SetupBackColor			move.l	rectReg, -(SP)			_EraseRect			move.l	rectReg, -(SP)			move.l	OneOne, -(SP)			_InsetRect			move.w	(sp)+,d2; ------------- plot the little dude’s face  -------------; PlotSymbol -- A2 contains a PicHandle. rectReg holds the address of; the destination rectangle.; D2 is non-zero for pixmap, zero for bitmap; pixmap is not included in this example since the format and kind of; these resources is subject to change and private; A2 points to bounds/rect/bits; rectReg holds destination rectPlotSymbol			move.w	D2,-(sp)			; Save color/BW flag			tst.b	D2					; use picture or bits?			bz.s	PlotBW				; if zero, use CopyBits			tst.b	gadgetHighlight(a6)			bz.s	@notHighlighted			moveq	#wTitleBarDark, D0			moveq	#wTingeLight, D1			bra.s	plotSetupCommon@notHighlighted			moveq	#wTitleBarLight, D0			moveq	#wTitleBarDark, D1plotSetupCommon			bsr		SetupColors			move.l	workPixmap(A6), A0			move.l	(A0), A0			move.l	A0, -(SP)			bra.s	copyBitsPixCommonPlotBW			lea 	IconBitmap,A0		; get pointer to source bitmap			move.w	(A2)+, rowBytes(A0)			move.l	(A2)+, bounds(A0)			move.l	(A2)+, bounds+4(A0)			move.l	A2, baseAddr(A0)			pea 	IconBitmap			; push pointer source bitmapcopyBitsPixCommon			move.l	(SP),A0 			; remember in A0, too			move.l	GrafGlobals(A5),A1	; get lisaGraf global baseaddress			move.l	thePort(A1),A1		; get thePort			pea 	portBits(A1)		; that’s the destination bitmap			pea 	bounds(A0)			; boundsRect of bitmap is source			move.l	rectReg,-(SP)		; tempRect is the destination			clr.w	-(SP)			clr.l	-(SP)				; no mask region										; the colors should be OK here										; transfer the bitMap (stretching as necessary...)			_CopyBits					; stretch those bits			move.l	tempPixels(A6), A0	; get the locked pixels (if any)			_HUnlock					; and unlock them			move.w	(sp)+,D2			bz.s	@noTingeRoutine		; Don’t tinge for black & white case; All the tinge routines do the dark tinge first, so set it up for them			moveq	#wDTingeF, D0			bsr		SetupForeColor			move.l	4(sp),d0			; Get address of tinging routine			bz.s	@noTingeRoutine		; No; get out of here.			move.l	(sp)+,(sp)			; Push down return address			move.l	d0,a0			jmp		(a0)				; Tinge the gadget@noTingeRoutine			move.l	(sp)+,a0			; Get return address			addq	#4,sp				; Remove tinge routine from stack			jmp		(a0)				; Return to caller; ================================================BuildTBarRect; ================================================; BuildTBarRect builds a rectangle enclosing the titleBar in TempRect; leave rectReg pointing at TempRect, which is nice.; WARNING -- Trashes D0,A0,A1,rectReg			bsr.s	StructInTemp		; structRgn.rgnBBox in rectReg										; make bottom := top + WHeight			move	top(rectReg),D0		; get top			add.w	titleHgtReg,D0 		; add precomputed height			move	D0,bottom(rectReg)	; update bottom; The dBoxProc with title has no shadow, don’t subtract off right edge.			tst.b	IsProcFive(A6)		; dBoxProc with title?			bne.s	@NoInset			; no, then standard title bar			subq	#1,right(rectReg)	; inset right@NoInset								; needed another entry point			rts 						; return to caller; ================================================StructInTemp; ================================================; Get structRgn.rgnBBox into TempRect and keep TempRect address in rectReg; WARNING - trashes A0			move.l	structRgn(windowReg),A0	; get region handle			move.l	(A0),A0 				; get region ptr			addq	#rgnBBox,A0 			; point A0 at the bounding box			move.l	(A0)+,(rectReg)			; copy rgnBox to TempRect			move.l	(A0)+,botRight(rectReg)	;			rts; ================================================IsItSmall; ================================================; IsItSmall returns NE if the window has been resized or moved (NE if window "small"); It updates smallsize if it has.  (If tab, only move small window).; WARNING -- Trashes A0,A2 and TempRect			bsr.s	GetRect 			; rectReg = curSize			move.l	wDataHandle(windowReg),A0	; get data handle			move.l	(A0),A2 			; A2 = bigSize			addq	#8,A2										; the window is large if all corners										; are within 7 of their default positions			bsr.s	ChkPoint			; compare topleft			bne.s	IsSmall 			; => not close enough			bsr.s	ChkPoint			; compare botRight			beq.s	NotSmall			; => it’s close enoughIsSmall 	move.l	wDataHandle(windowReg),A0	; get data handle			move.l	(A0),rectReg 		; save window’s current size			bsr.s	GetRect 			; get current size into rectReg			moveq	#1,D0				; return NE!NotSmall	lea 	TempRect,rectReg	; restore rectReg			rts							; we’re done; ================================================ChkPoint; ================================================; This routine is called in sequence.  First time it checks topLeft,; the next time is will check botRight.  It compares the rect in; TempRect against the rect pointed at in A2.; WARNING - increments rectReg			move.l	(A2),-(SP)			; make point into a rect			move.l	(A2)+,-(SP) 		; by pushing twice			move.l	SP,-(SP)			; and insetting by 7			move.l	#$FFF9FFF9,-(SP)	;			_InsetRect					;			clr.w	-(SP)				; is cursize within 7 of			move.l	(rectReg)+,-(SP) 	; that point?			pea 	6(SP)				;			_PtInRect					;			subq.b	#1,(SP) 			; reverse sign of result			move.b	(SP)+,D0			;			addq	#8,SP				; strip off the rect			rts 						; exit w/EQ if "Big"; ================================================GetRect; ================================================; Returns the rect in rectReg converted to global coordinates			move.l	portRect(windowReg),topLeft(rectReg)		   ; get locals			move.l	portRect+botRight(windowReg),botRight(rectReg) ; get locals			move.l	windowReg,A0		; copy portPtr for PortToMap			bsr		PortToMap			; get the rect pointer		 	move.l	rectReg,-(SP)		; push address of rect			move.l	bounds(A0),-(SP)	; push offset locToGlob			NEG.w	(SP)				; make offset positive			NEG.w	2(SP)			_OffsetRect 				; convert rect to globalGetRectDone	rts;----------------------------------------------------------------------------;; These routines are the heart of the WDEF’s ability to draw the right thing; on the right device based on the depth of the device. There are three kinds; of window color types we can draw:;;	Black and White		Drawn on non-CQD Macs, and on devices that have less;						than 8 bits per pixel. 8 bits per pixel is a high,;						arbitrary limit that we may be able to relax if we;						can integrate use of the Palette Manager into the;						WDEF.;	Custom wctbs		If there is a custom color table associated with;						this window, then its colors are used. This may;						change in the future if we find a way to customize;						the colors of the System 7 three-d windows.;	System 7.0 & later	Our new default for color environments.;----------------------------------------------------------------------------MakeRatioRGB			movem.l	D7/A2, -(SP)			lea		endRGB(A6), A0			lea		startRGB(A6), A1			lea		tempRGB(A6), A2			mulu	#$1111, D2			move.w	#2, D0@nextChannel			MOVEQ	#0, D1					; clear high word			MOVE	(A0)+, D1				; background color component			SUB		(A1), D1				; change from foreground			SLO		D7						; remember if it was negated			BHS.S	@orderedOK			NEG		D1						; flip if subtraction would overflow@orderedOK			mulu	D2, D1					; multiply times scale factor			SWAP	D1						; divide by 65K			TST.B	D7			BEQ.S	@notFlipped			NEG.L	D1						; flip it@notFlipped			add.w	(A1)+, D1			move.w	D1, (A2)+			dbra	D0, @nextChannel			movem.l	(SP)+, D7/A2			rtsCheckAvailableColors;----------------------------------------------------------------------------; This routine is called just as we enter the _DeviceLoop drawing proc, after; the current depth has been stored in curDepth(A6). If the depth is 8 bits; per pixel or greater, and the wctb for this window is the default, then; we’re going to draw the System 7 three-d windows instead (threeDWind gets; set to TRUE). Otherwise, threeDWind gets set to FALSE.;----------------------------------------------------------------------------			movem.l	D3-D4/A2, -(SP)					; these should be saved			move.w	curDepth(A6), D0				; how deep is the current device?			cmp.w	#2, D0							; must be 2 bits/pixel or better			sge		threeDWind(A6)					; set prelim answer			blt.s	@exit							; get out if already no good			move.l	TheGDevice, -(SP)				; save this			move.l	D1, TheGDevice					; set our device for color mapping			tst.b	varCodeReg						; what kind of window is this?			bz.s	@doCheckHilite			tst.b	IsProcFive(A6)					; is it moveable modal?			bne.s	@doneCheckHilite@doCheckHilite			lea		HiliteShades, A2				; point at shades we need			bsr.s	CheckShadesAvailable			; see if all these shades are here			tst.b	threeDWind(A6)					; did we fail to get the shades?			bz.s	@colorExit						; get out if so			lea		TitleBarShades, A2				; point at shades we need			bsr.s	CheckShadesAvailable			; see if all these shades are here			tst.b	threeDWind(A6)					; did we fail to get the shades?			bz.s	@colorExit						; get out if so			lea		TingeShades, A2					; point at shades we need			bsr.s	CheckShadesAvailable			; see if all these shades are here			tst.b	threeDWind(A6)					; did we fail to get the shades?			bz.s	@colorExit						; get out if so@doneCheckHilite			cmp.b	#dBoxProc, varCodeReg			; do we need the thick dialog border?			bne.s	@colorExit						; if not, we’re done checking			lea		DialogShades, A2				; point at shades we need			bsr.s	CheckShadesAvailable			; see if all these shades are here@colorExit			move.l	(SP)+, TheGDevice				; restore device@exit			movem.l	(SP)+, D3-D4/A2			rtsCheckShadesAvailable			move.w	(A2), D3						; get next ‘light’ color			move.l	#'csd ', D4						; an unlikely pixel value@rampLoop			cmp		(A2), D3						; get the next shade’s light color			bne.s	@exit							; if new, reinit for new ramp			move.l	A2, A0							; point to shade entry			bsr		SetupRatioColor					; get shade in tempRGB			subq.l	#4, SP							; room for pixel index			pea		tempRGB(A6)						; the shade RGB we want			_Color2Index							; what does it map to?			move.l	(SP)+, D0						; get the pixel index			cmp.l	D0, D4							; is it the same as last time?			beq.s	@failure						; if so, not enough colors			move.l	D0, D4							; update ‘last’ shade index			addq.l	#6, A2							; point to next shade			bra.s	@rampLoop						; and test it@failure			sf		threeDWind(A6)					; use the old kind@exit			rtsDefaultWCTB;----------------------------------------------------------; This table of bytes represents the colors in the default; wctb. It uses bytes because we know that the default; table only has black and white.;----------------------------------------------------------			dc.b	$FF, $00, $00, $00, $FF, $00, $00, $FF			dc.b	$FF, $00, $00, $00, $00, $00, $00, $00			dc.b	$00, $00, $00, $00, $00, $FF, $FF, $FF			dc.b	$FF, $FF, $FF, $00, $00, $00, $00, $00			dc.b	$00, $FF, $FF, $FF, $FF			alignSetupRatioColor			move.w	4(A0), -(SP)						; push shade percent			move.w	2(A0), -(SP)						; push dark (to/fore) end of shade			move.w	(A0), D0							; get light shade color number			bsr.s	SetUpColor							; get the color of the light (from/back) end			move.l	(SP)+, A0							; get pointer to light color			move.l	(A0)+, startRGB(A6)					; copy red and green			move.w	(A0), startRGB+4(A6)				; copy blue			move.w	(SP)+, D0							; get dark color number			bsr.s	SetUpColor							; get the color of the light end			move.l	(SP)+, A0							; get pointer to light color			move.l	(A0)+, endRGB(A6)					; copy red and green			move.w	(A0), endRGB+4(A6)					; copy blue			move.w	(SP)+, D2							; get shade percentage			bsr.s	MakeRatioRGB						; create a shade between the two			rts; ================================================SetupColors; ================================================; Added this routine to help setup fore- and back color and save code.; SetUpColor takes a fore color in D0, and a back color in D1.; It then calls SetUpColor with both of them (which likes its; parameter in D0), and calls RGBForeColor and RGBBackColor; where appropriate.			move.w	D1,-(SP)			; save part identifier of back color			bsr.s	SetupForeColor			move.w	(SP)+,D0			; get saved part			bsr.s	SetupBackColor			rts							; all done; ================================================SetupForeColor; ================================================			bsr.s	SetUpColor			; D0 has forecolor part identifier			bz.s	@setClassicFore		; if non-CQD answer, branch			_RGBForeColor			bra.s	@exit@setClassicFore			_ForeColor@exit			rts											; all done; ================================================SetupBackColor; ================================================			bsr.s	SetUpColor			; D0 has forecolor part identifier			bz.s	@setClassicBack		; if non-CQD answer, branch			_RGBBackColor			bra.s	@exit@setClassicBack			_BackColor@exit			rts											; all done; ================================================SetUpColor; ================================================; SetUpColor takes a window part identifier in D0, finds the corresponding;	part in the AuxWinTable (the part code is in the .value field) and returns;	a pointer to its RGB on the stack.  If the requested part is not found,;	the old black and white color for that part is used.			tst.b	threeDWind(A6)						; can we use System 7 windows?			bz.s	@useBlackAndWhite					; nope? Try other cases			cmp.w	#lowestShadeIndex, D0				; is this a shade color?			blt.s	@notShade							; not a shade color			sub.w	#lowestShadeIndex, D0				; normalize to shade colors			mulu	#6, D0								; x6 for table index			lea		ShadeTable, A0						; point at table of shade colors			add.w	D0, A0								; point to correct entry			bsr.s	SetupRatioColor						; get color in tempRGB			move.l	(SP)+, A0							; pop the return address			pea		tempRGB(A6)							; point to rgb color			moveq	#1, D0								; indicate color answer			jmp		(A0)								; get outa here@notShade			move.l	AuxCPtr(A6), A0						; get the color table pointer			bsr		GoodColorTable						; does ctb contain the index (in D0)?	 			beq.s	@foundIt							; yes => go return corresponding color	 			move.w	D0,-(SP)							; save the index to color table on stack 			subq.l	#4,SP								; leave space for results				 			move.l	#'wctb',-(SP)						; try to get the system wctb			 			clr.w	-(SP)								;										 			_GetResource								;										 			move.l	(SP)+,A0							; get the wctb resource					 			move.w	(SP)+,D0							; retrieve the index					 			cmp.l	#0,A0								; did we really get the wctb resource	 			beq.s	@useDefaultCTab						; no =>	go use the default ctab			 			move.l	(A0),A0								; yes => deference to get ptr to wctb	 			bsr		GoodColorTable						; does wctb contain the index (in D0)?	 			beq.s	@foundIt							; yes => go return corresponding color	 @useDefaultCTab											; no => use the default ctab			 			mulu	#6,D0								; (x6) index into rgb specs			lea		ThreeDColors, A0					; point at standard colors@getCorrectColor										;										 			move.l	(SP)+,D1							; get return address					 			pea		(A0, D0.w)							; point at correct color			move.l	D1, A0								; get return address			bra.s	@exitColor@foundIt			lea		ctTable+rgb(A0, D1), A0 			; get the address of the color to use			move.l	A0, D0								; we’ll need A0 in a second			move.l	(SP)+, A0							; get the return address			move.l	D0, -(SP)							; push the rgb addr on the stack@exitColor			moveq	#1, D0								; indicate color answer			jmp		(A0)								; return to caller@useBlackAndWhite			lea		DefaultWCTB, A0						; point to cheesy color table			move.b	(A0, D0.w), D0						; get white or black (as a byte)			bnz.s	@simpleWhite						; branch if we want white			moveq	#blackColor, D0						; get the old-style color			bra.s	@classicExit						; get outa here@simpleWhite			moveq	#whiteColor, D0						; get old-style white@classicExit			move.l	(SP)+, A0							; return address			move.l	D0, -(SP)							; classic color			moveq	#0, D0								; indicate classic answer			jmp		(A0)* •••• NOTE:  SetupColorPict is not included in this example.*  SetupColorPict uses private, undocumented, and highly unstable* resources in the system file.* You really don't need them, since the bitmap and iconic * representations of the window gadgets is/are included at the end * of this file, and you can design your own PICT type resource to do the same * thing.  SetupColorPict			rtsGoodColorTable			move.w	ctSize(A0), D1						; get the color table size			asl.w	#3, D1								; (x8) convert to color table index@legalIndex			cmp.w	ctTable+value(A0,D1), D0			; is this the one?			beq.s	@done								; if equal, then done			subq.w	#8, D1								; try the previous one			bge.s	@legalIndex							; loop while index positive@done			rts; ================================================PortToMap										;  ; ================================================; Given a window pointer in A0, return the bitmap/pixmap pointer in A0			addq	#portBits,A0				;POINT TO BITMAP/PIXMAP HANDLE			tst		rowBytes(A0)				;BITMAP OR PIXMAP HANDLE?			bpl.s	GotBitMap					;=>JUST A BITMAP			move.l	baseAddr(A0),A0				;ELSE GET PORT’S PIXMAP HANDLE			move.l	(A0),A0						;GET PIXMAP POINTERGotBitMap	rts; ================================================; CONSTANTS; ================================================; some data used in the WDEF; ------------- HilitePattern used in the title bar -------------HilitePattern			dc.w	$FF00,$FF00,$FF00,$FF00PixelRsrcIDs;----------------------------------------------------------; This is a table of resource IDs for the PICTs which are; used to draw the small pieces of the System 7 windows.;----------------------------------------------------------			dc.w	-14335							; wZoomGadget			dc.w	-14335							; wGoAwayGadget			dc.w	-14334							; wZoomGadgetHighlight			dc.w	-14334							; wGoAwayGadgetHighlight			dc.w	-14335							; wGrowGadgetThreeDColors;-----------------------------------------------------------; These are the RGB colors which are used to draw the shaded; windows.;-----------------------------------------------------------			dc.w	$FFFF, $FFFF, $FFFF				; wContentColor			dc.w	$0000, $0000, $0000				; wFrameColor			dc.w	$0000, $0000, $0000				; wTextColor			dc.w	$0000, $0000, $0000				; wHiliteColor (not used)			dc.w	$FFFF, $FFFF, $FFFF				; wTitleBarColor (not used)			dc.w	$FFFF, $FFFF, $FFFF				; wHiliteLight			dc.w	$0000, $0000, $0000				; wHiliteDark			dc.w	$FFFF, $FFFF, $FFFF				; wTitleBarLight			dc.w	$0000, $0000, $0000				; wTitleBarDark			dc.w	$CCCC, $CCCC, $FFFF				; wDialogLight			dc.w	$0000, $0000, $0000				; wDialogDark			dc.w	$CCCC, $CCCC, $FFFF				; wTingeLight			dc.w	$3333, $3333, $6666				; wTingeDarkShadeTableHiliteShades			dc.w	wHiliteLight, wHiliteDark, $0		; wHiliteShade0			dc.w	wHiliteLight, wHiliteDark, $7		; wHiliteShade7			dc.w	wHiliteLight, wHiliteDark, $8		; wHiliteShade8			dc.w	wHiliteLight, wHiliteDark, $A		; wHiliteShadeA			dc.w	wHiliteLight, wHiliteDark, $D		; wHiliteShadeDTitleBarShades			dc.w	wTitleBarLight, wTitleBarDark, $0	; wTitleBarShade0			dc.w	wTitleBarLight, wTitleBarDark, $1	; wTitleBarShade1			dc.w	wTitleBarLight, wTitleBarDark, $4	; wTitleBarShade4DialogShades			dc.w	wDialogLight, wDialogDark, $0		; wDialogShade0w			dc.w	wDialogLight, wDialogDark, $4		; wDialogShade4w			dc.w	wDialogLight, wDialogDark, $6		; wDialogShade6w			dc.w	wDialogLight, wDialogDark, $B		; wDialogShadeBb			dc.w	wDialogLight, wDialogDark, $F		; wDialogShadeF			dc.w	0, 0, 0								; stop checking shades			dc.w	wDialogLight, wDialogDark, $0		; wDialogShade0b			dc.w	wDialogLight, wDialogDark, $4		; wDialogShade4b			dc.w	wDialogLight, wDialogDark, $6		; wDialogShade6b			dc.w	wDialogLight, wDialogDark, $B		; wDialogShadeBwTingeShades			dc.w	wTingeLight, wTitleBarDark, $0		; wLTinge0			dc.w	wTingeLight, wTingeDark, $4			; wLTinge4					 			dc.w	wTitleBarLight, wTingeDark, $F		; wDTingeFEndOfShades			dc.w	0BorderShades			dc.w	wDialogShade6w, wDialogShade0w		; Border colors for active windows			dc.w	wDialogShade6w, wTitleBarShade4			dc.w	wDialogShade0b, wDialogShade6b			dc.w	wDialogShade6b, wDialogShadeF			dc.w	wTitleBarShade0, wTitleBarShade0		; Border colors for inactive windows			dc.w	wTitleBarShade0, wTitleBarShade0			dc.w	wHiliteShade8, wHiliteShade8			dc.w	wHiliteShade8, wHiliteShade8BitmapOffsets;----------------------------------------------------------; This is a table of words which represent the offsets; from WDEFBitmaps to the beginning of each bitmap;----------------------------------------------------------			dc.w	ZoomData-BitmapOffsets			dc.w	GoAwayData-BitmapOffsets			dc.w	ZoomHiliteData-BitmapOffsets			dc.w	GoAwayHiliteData-BitmapOffsets			dc.w	GrowBits-BitmapOffsetsWDEFBitmaps;----------------------------------------------------------; These bitmaps are used when drawing on classic QD; machines, or when the bit depth is too low to draw in; color.;----------------------------------------------------------; ------------- ZoomData used in the zoom box -------------ZoomData			dc.w	$0002						; rowBytes			dc.w	$0000, $0000, $000B, $000B	; bounds			dc.w	$FFE0						; •••••••••••.....			dc.w	$8220						; •.....•...•.....			dc.w	$8220						; •.....•...•.....			dc.w	$8220						; •.....•...•.....			dc.w	$8220						; •.....•...•.....			dc.w	$8220						; •.....•...•.....			dc.w	$FE20						; •••••••...•.....			dc.w	$8020						; •.........•.....			dc.w	$8020						; •.........•.....			dc.w	$8020						; •.........•.....			dc.w	$FFE0						; •••••••••••.....ZoomHiliteDataGoAwayHiliteData			dc.w	$0002						; rowBytes			dc.w	$0000, $0000, $000B, $000B	; bounds			dc.w	$FFE0						; •••••••••••.....			dc.w	$8420						; •....•....•.....			dc.w	$A4A0						; •.•..•..•.•.....			dc.w	$9520						; •..•.•.•..•.....			dc.w	$8020						; •.........•.....			dc.w	$F1E0						; ••••...••••.....			dc.w	$8020						; •.........•.....			dc.w	$9520						; •..•.•.•..•.....			dc.w	$A4A0						; •.•..•..•.•.....			dc.w	$8420						; •....•....•.....			dc.w	$FFE0						; •••••••••••.....; ------------- BitMap for default GoAway button -------------GoAwayData			dc.w	$0002						; rowBytes			dc.w	$0000, $0000, $000B, $000B	; bounds			dc.w	$FFE0						; •••••••••••.....			dc.w	$8020						; •.........•.....			dc.w	$8020						; •.........•.....			dc.w	$8020						; •.........•.....			dc.w	$8020						; •.........•.....			dc.w	$8020						; •.........•.....			dc.w	$8020						; •.........•.....			dc.w	$8020						; •.........•.....			dc.w	$8020						; •.........•.....			dc.w	$8020						; •.........•.....			dc.w	$FFE0						; •••••••••••.....; ------------- BitMap for GrowIcon -------------GrowBits			dc.w	$0002						; rowBytes			dc.w	$0000, $0000, $000F, $000F	; bounds			dc.w	$0000						; ................			dc.w	$0000						; ................			dc.w	$0000						; ................			dc.w	$1FC0						; ...•••••••......			dc.w	$1040						; ...•.....•......			dc.w	$107C						; ...•.....•••••..			dc.w	$1044						; ...•.....•...•..			dc.w	$1044						; ...•.....•...•..			dc.w	$1044						; ...•.....•...•..			dc.w	$1FC4						; ...•••••••...•..			dc.w	$0404						; .....•.......•..			dc.w	$0404						; .....•.......•..			dc.w	$0404						; .....•.......•..			dc.w	$07FC						; .....•••••••••..			dc.w	$0000						; ................			END