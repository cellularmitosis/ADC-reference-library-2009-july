<!-- legacy work start -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- legacy work end -->


<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)

LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Recording Sounds Directly From a Device (IM: S)  (deprecated)</Title>

<!-- legacy work start -->
        <META NAME="Generator" CONTENT="manual">
        <META http-equiv="content-type" CONTENT="text/html;charset=utf-8">
        <META NAME = "Copyright" CONTENT="Copyright 2007 Apple Inc. All Rights Reserved.">
        <META NAME="IndexTitle" CONTENT="Inside Macintosh: Sound (Not Recommended)">
        <meta name="xcode-display" content="render">

        <LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css"> <!-- before submitting, globally replace ".." with "developer.apple.com" -->
        <script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
<!-- legacy work end -->

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<A NAME=HEADING143></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Sound-142.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-144.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Sound-2.html"><B>Sound</B></A> / <BR><DD><A HREF="Sound-137.html"><B>Chapter 3 - Sound Input Manager</B></A> / <A HREF="Sound-142.html"><B>Using the Sound Input Manager</B></A></DL></FONT><P>
<HR>

<!-- legacy work start -->
<script type="text/javascript"> placeWatermark()</script>
<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
<i>Inside Macintosh: Sound</i> is deprecated as of Mac OS X v10.5. For new audio development in Mac OS X, use Core Audio. See the <a href="http://developer.apple.com/referencelibrary/MusicAudio/" target="_top">Audio</a> page in the ADC Reference Library.</p></div></div></div>
<!-- legacy work end -->


<BLOCKQUOTE>
<A NAME=HEADING143-0></A>
<H2>Recording Sounds Directly From a Device</H2>
 <A NAME=MARKER-2-104></A><A NAME=MARKER-2-211></A><A NAME=MARKER-2-131></A>The Sound Input Manager provides a number of routines that you can use for low-level control over the recording process (such as the ability to intercept sound input data at interrupt time). You can open a sound input device and read data from it by calling these low-level Sound Input Manager routines. Several of those routines access information through a <B>sound input parameter block,</B> which is defined by the <CODE>SPB</CODE> data type:<A NAME=MARKER-2-4></A><P>
<PRE>
TYPE SPB =
RECORD
   inRefNum:            LongInt;    {reference number of input device}
   count:               LongInt;    {number of bytes to record}
   milliseconds:        LongInt;    {number of milliseconds to record}
   bufferLength:        LongInt;    {length of buffer to record into}
   bufferPtr:           Ptr;        {pointer to buffer to record into}
   completionRoutine:   ProcPtr;    {pointer to a completion routine}
   interruptRoutine:    ProcPtr;    {pointer to an interrupt routine}
   userLong:            LongInt;    {for application's use}
   error:               OSErr;      {error returned after recording}
   unused1:             LongInt;    {reserved}
END;
</PRE>
 The <CODE>inRefNum</CODE> field indicates the reference number of the sound input device from which the recording is to occur. You can obtain the reference number of the default sound input device by using the <CODE>SPBOpenDevice</CODE> function.<P>
 The <CODE>count</CODE>, <CODE>milliseconds</CODE>, and <CODE>bufferLength</CODE> fields jointly determine the length of recording. The <CODE>count</CODE> field indicates the number of bytes to record; the <CODE>milliseconds</CODE> field indicates the number of milliseconds to record; and the <CODE>bufferLength</CODE> field indicates the length in bytes of the buffer into which the recorded sound data is to be placed. If the <CODE>count</CODE> and <CODE>milliseconds</CODE> fields are not equivalent, then the field which specifies the longer recording time is used. If the buffer specified by the <CODE>bufferLength</CODE> field is shorter than this recording time, then the recording time is truncated so that the recorded data can fit into the buffer specified by the <CODE>bufferPtr</CODE> field. The Sound Input Manager provides two functions, <CODE>SPBMilliSecondsToBytes</CODE> and <CODE>SPBBytesToMilliSeconds</CODE>, that allow you to convert between byte and millisecond values.<A NAME=MARKER-2-191></A><A NAME=MARKER-2-72></A><P>
 After recording finishes, the <CODE>count</CODE> and <CODE>milliseconds</CODE> fields indicate the number of bytes and milliseconds actually recorded.<P>
 The <CODE>completionRoutine</CODE> and <CODE>interruptRoutine</CODE> fields allow your application to define a sound input completion routine and a sound input interrupt routine, respectively. More information on these routines is provided later in this section.<A NAME=MARKER-2-193></A><P>
 The <CODE>userLong</CODE> field contains a long integer that is provided for your application's own use. You can use this field, for instance, to pass a handle to an application-defined structure to the sound input completion or interrupt routine. Or, you can use this field to store the value of your application's A5 register, so that your sound input completion or interrupt routine can access your application's global variables. For more information on preserving the value of the A5 register, see the discussion of the <CODE>SetA5</CODE> and <CODE>SetCurrentA5</CODE> functions in the chapter "Memory Management Utilities" in <I><A HREF="../Memory/Memory-2.html">Inside Macintosh: Memory</A></I>.<P>
 The <CODE>error</CODE> field describes any errors that occur during the recording. This field contains a value greater than 0 while recording unless an error occurs, in which case it contains a value less than 0 that indicates an operating system error. Your application can poll this field to check on the status of an asynchronous recording. If recording terminates without an error, this field contains 0.<P>
 <A HREF=#MARKER-9-75>Listing 3-1</A> shows how to set up a sound parameter block and record synchronously using the <CODE>SPBRecord</CODE> function. This procedure takes one parameter, a handle to a block of memory in which the recorded sound data is to be stored. It is assumed that the block of memory is large enough to hold the sound to be recorded.<A NAME=MARKER-2-8></A><P>
<B>Listing 3-1  <A NAME=MARKER-9-75></A>Recording directly from a sound input device</B><P>
<PRE>
PROCEDURE MyRecordSnd (mySndH: Handle);
CONST
   kAsync = TRUE;
   kMiddleC = 60;
VAR
   mySPB:         SPB;        {a sound input parameter block}
   myInRefNum:    LongInt;    {device reference number}
   myBuffSize:    LongInt;    {size of buffer to record into}
   myHeadrLen:    Integer;    {length of sound header}
   myNumChans:    Integer;    {number of channels}
   mySampSize:    Integer;    {size of a sample}
   mySampRate:    Fixed;      {sample rate}
   myCompType:    OSType;     {compression type}
   myErr:         OSErr;
BEGIN
   {Open the default input device for reading and writing.}
   myErr := SPBOpenDevice('', siWritePermission, myInRefNum);

   IF myErr = noErr THEN
   BEGIN
      {Get current settings of sound input device.}
      MyGetDeviceSettings(myInRefNum, myNumChans, mySampRate, 
                           mySampSize, myCompType);

      {Set up handle to contain the 'snd ' resource header.}
      myErr := SetupSndHeader(mySndH, myNumChans, mySampRate,mySampSize,  
                                 myCompType, kMiddleC, 0, myHeadrLen);

      {Leave room in buffer for the sound resource header.}
      myBuffSize := GetHandleSize(mySndH) - myHeadrLen;

      {Lock down the sound handle until the recording is over.}
      HLockHi(mySndH);

      {Set up the sound input parameter block.}
      WITH mySPB do
      BEGIN
         inRefNum := myInRefNum;          {input device reference number}
         count := myBuffSize;             {number of bytes to record}
         milliseconds := 0;               {no milliseconds}
         bufferLength := myBuffSize;      {length of buffer}
         bufferPtr := Ptr(ORD4(mySndH^) + myHeadrLen);
                                          {put data after 'snd ' header}
         completionRoutine := NIL;        {no completion routine}
         interruptRoutine := NIL;         {no interrupt routine}
         userLong := 0;                   {no user data}
         error := noErr;                  {clear error field}
         unused1 := 0;                    {clear reserved field}
      END;

      {Record synchronously through the open sound input device.}
      myErr := SPBRecord(@mySPB, NOT kAsync);

      HUnlock(mySndH);                    {unlock the handle}

      {Indicate the number of bytes actually recorded.}
      myErr := SetupSndHeader(mySndH, myNumChans, mySampRate, mySampSize, 
                                 myCompType, kMiddleC, mySPB.count,
                                 myHeadrLen);

      {Close the input device.}
      myErr := SPBCloseDevice(myInRefNum);
   END;
END;
</PRE>
 The <CODE>MyRecordSnd</CODE> procedure defined in <A HREF=#MARKER-9-75>Listing 3-1</A> opens the default sound input device by using the <CODE>SPBOpenDevice</CODE> function. You can specify one of two values for the <CODE>permission</CODE> parameter of <CODE>SPBOpenDevice</CODE>:<P>
<PRE>
CONST
   siReadPermission  = 0;  {open device for reading}
   siWritePermission = 1;  {open device for reading/writing}
</PRE>
 You must open a device for both reading and writing if you intend to use the <CODE>SPBSetDeviceInfo</CODE> function or the <CODE>SPBRecord</CODE> function. If <CODE>SPBOpenDevice</CODE> successfully opens the specified device for reading and writing, <CODE>MyRecordSnd</CODE> calls the <CODE>MyGetDeviceSettings</CODE> procedure (defined in <A HREF=Sound-144.html#MARKER-9-102>Listing 3-3 on page 3-12</A>). That procedure calls the Sound Input Manager function <CODE>SPBGetDeviceInfo</CODE> (explained in <A HREF=Sound-144.html#MARKER-9-97>"Getting and Setting Sound Input Device Information" on page 3-10</A>) to determine the current number of channels, sample rate, sample size, and compression type in use by the device.<A NAME=MARKER-2-76></A><P>
 This information is then passed to the <CODE>SetupSndHeader</CODE> function, which sets up the handle <CODE>mySndH</CODE> with a sound header describing the current device settings. After doing this, <CODE>MyRecordSnd</CODE> sets up a sound input parameter block and calls the <CODE>SPBRecord</CODE> function to record a sound. Note that the handle must be locked during the recording because the parameter block contains a pointer to the input buffer. After the recording is done, <CODE>MyRecordSnd</CODE> once again calls the <CODE>SetupSndHeader</CODE> function to fill in the actual number of bytes recorded.<A NAME=MARKER-2-493></A><P>
 If the <CODE>MyRecordSnd</CODE> procedure defined in <A HREF=#MARKER-9-75>Listing 3-1</A> executes successfully, the handle <CODE>mySndH</CODE> points to a resource of type <CODE>'snd '</CODE>. Your application can then synchronously play the recorded sound, for example, by executing the following line of code:<A NAME=MARKER-2-78></A><P>
<PRE>
myErr := SndPlay(NIL, mySndH, FALSE);
</PRE>
 For more information on playing sounds your application has recorded, see the chapter <A HREF=Sound-44.html#MARKER-9-47>"Sound Manager"</A> in this book.<A NAME=MARKER-2-79></A><A NAME=MARKER-2-235></A><A NAME=MARKER-2-81></A><P>
<A NAME=HEADING143-19></A>
<H3>Defining a Sound Input Completion Routine<A NAME=MARKER-2-45></A></H3>
 <A NAME=MARKER-2-83></A><A NAME=MARKER-9-385></A>The <CODE>completionRoutine</CODE> field of the sound parameter block record contains the address of a completion routine that is executed when the recording terminates normally, either by reaching its prescribed time or size limits or by the application calling the <CODE>SPBStopRecording</CODE> function. A completion routine should have the following format:<A NAME=MARKER-2-258></A><A NAME=MARKER-2-474></A><P>
<PRE>
PROCEDURE MySICompletionRoutine (inParamPtr: SPBPtr);
</PRE>
 The completion routine is passed the address of the sound input parameter block that was passed to the <CODE>SPBRecord</CODE> function. You can gain access to other data structures in your application by passing an address in the <CODE>userLong</CODE> field of the parameter block. After the completion routine executes, your application should check the <CODE>error</CODE> field of the sound input parameter block to see if an error code was returned.<A NAME=MARKER-2-3></A><A NAME=MARKER-2-88></A><P>
 Your sound input interrupt routine is always called at interrupt time, so it should not call routines that might allocate or move memory or assume that A5 is set up. For more information on sound input interrupt routines, see <A HREF=Sound-184.html#MARKER-9-339>"Sound Input Interrupt Routines" beginning on page 3-55</A>.<P>
<A NAME=HEADING143-24></A>
<H3><A NAME=MARKER-9-89></A>Defining a Sound Input Interrupt Routine<A NAME=MARKER-9-180></A><A NAME=MARKER-2-91></A></H3>
 The <CODE>interruptRoutine</CODE> field of the sound input parameter block contains the address of a routine that executes when the internal buffers of an asynchronous recording device are filled. The internal buffers contain raw sound samples taken directly from the input device. The interrupt routine can modify the samples in the buffer in any way it requires. The processed samples are then written to the application buffer. If compression is enabled, the modified data is compressed after your interrupt routine operates on the samples and before the samples are written to the application buffer.<A NAME=MARKER-2-261></A><A NAME=MARKER-2-93></A><A NAME=MARKER-2-94></A><P>
 Your sound input interrupt routine is always called at interrupt time, so it should not call routines that might allocate or move memory or assume that A5 is set up. For more information on sound input interrupt routines, see <A HREF=Sound-184.html#MARKER-9-339>"Sound Input Interrupt Routines" beginning on page 3-55</A>. <A NAME=MARKER-2-95></A><A NAME=MARKER-2-96></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Sound-142.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-144.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Sound-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
