{ deleteEmptyDir and listEmptyDir identify all empty directories on a   specified volume.  If the tool is named deleteEmptyDir, the directories  will be removed.    This purpose of this snippet is to show how easy (hah!) and useful (well,  yeah) the PBCatSearch call is.  Ask Mark Johnson why this tool might be   helpful.    Syntax:   deleteEmptyDir <volName>            listEmptyDir <volName>			  Example:  listEmptyDir myHardDisk:    Grobbins 9/91}PROGRAM deleteEmptyDir;	USES		Memtypes, Quickdraw, OSIntf, ToolIntf, PackIntf, { include it all, why not }		PasLibIntf,	{ standard I/O }		IntEnv;	{ for command line arguments }			CONST		kMaxFinds = 100;		kBuffSize = 16384;					VAR		toolName, volName: 	 Str255;		retCode:	OSErr;		trashDirID: LongInt;		trashVRefNum: Integer;		trashedFSSpec: FSSpec;		myHPB: HParamBlockRec;		loopCtr: INTEGER;		resultFSSpecArr: PACKED ARRAY[1..kMaxFinds] OF FSSpec;		CISpec1, CISpec2: CInfoPBRec;		doneFlag: BOOLEAN;		buffer: PACKED ARRAY[1..kBuffSize] OF CHAR;			{$S Main}{*----------------* | deleteEmptyDir | *----------------*}		PROCEDURE Fail(retCode: OSErr);		BEGIN			IF retCode <> noErr THEN				BEGIN					WriteLn(Diagnostic, '# ', toolName, ' failed ', retCode);					IEexit(retCode); 		{ exit, returning the appropriate status code}				END;		END;			BEGIN 														 {main}		toolName := ArgV^[0]^;				retCode := noErr;				IF ArgC <> 2 THEN 		BEGIN			WriteLn(Diagnostic, Concat('### ', toolName, ' - needs 1 parameter'));			retCode := 2;  { Ord(FP_ParmErrs) = 2 }			IEexit(retCode); 		 {exit, returning the appropriate status code}		END;						volName := ArgV^[1]^;				{ folder path should end in a colon }		IF volName[Length(volName)] <> ':' THEN			volName := Concat(volName, ':');					WriteLn('volume is ', volName);				{ now set up parameter blocks for PBCatSearch }				{ find vRefNum for folder's disk }		myHPB.ioCompletion := NIL;		myHPB.ioNamePtr := @volName;		myHPB.ioVRefNum := 0;		myHPB.ioVolIndex := -1;		retCode := PBHGetVInfo(@myHPB, false);		IF retCode <> noErr THEN Fail(retCode);		WriteLn('vRefNum is ', myHPB.ioVRefNum);				{ set up parameter blocks to search for all folders with nothing in them }		myHPB.ioCompletion := NIL;		myHPB.ioNamePtr := NIL;		{ myHPB.ioVRefNum already set }		myHPB.ioMatchPtr := FSSpecArrayPtr(@resultFSSpecArr);		myHPB.ioReqMatchCount := kMaxFinds;		myHPB.ioSearchBits := fsSBFlAttrib + fsSBDrNmFls;		myHPB.ioSearchInfo1 := @CISpec1;		myHPB.ioSearchInfo2 := @CISpec2;		myHPB.ioSearchTime := -1;		myHPB.ioCatPosition.initialize := 0;		myHPB.ioOptBuffer := @buffer;		myHPB.ioOptBufSize := kBuffSize;				CISpec1.ioNamePtr := NIL;		CISpec1.ioDrNmFls := 0;		CISpec1.ioFlAttrib := $10;				CISpec2.ioNamePtr := NIL;		CISpec2.ioDrNmFls := 0;		CISpec2.ioFlAttrib := $10;				doneFlag := FALSE;		REPEAT			retCode := PBCatSearchSync(@myHPB);			doneFlag := (retCode = eofErr);			IF ((retCode = noErr) OR doneFlag) AND (myHPB.ioActMatchCount > 0) THEN				{ print out names of found folders & maybe delete them }				FOR loopCtr := 1 to myHPB.ioActMatchCount DO				BEGIN					Write(resultFSSpecArr[loopCtr].name);										{ delete only if name of this tool is deleteEmptyDir }					IF toolName = 'deleteEmptyDir' THEN					BEGIN						retCode := FSpDelete(resultFSSpecArr[loopCtr]);						IF retCode <> noErr THEN WriteLn('failed (',retCode,')')												ELSE WriteLn('... deleted');					END ELSE WriteLn;				END;						UNTIL doneFlag;		IEExit(retCode);	END.	