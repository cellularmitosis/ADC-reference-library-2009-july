<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Object Oriented Programming and the Objective-C Programming Language 1.0 (Not Recommended): The Language</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="The Language"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	<meta name="ROBOTS" content="NOINDEX"/>
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005191-CH7" title="The Language"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../LegacyTechnologies/index.html#//apple_ref/doc/uid/TP30000440-TP30000470" target="_top">Legacy Documents</a> &gt; <a href="../../../../LegacyTechnologies/Cocoa-date.html#//apple_ref/doc/uid/TP30000440-TP30000470-TP30000495" target="_top">Cocoa</a> &gt; <a href="../Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP40005191-CH1-SW2">Object Oriented Programming and the Objective-C Programming Language 1.0 (Not Recommended)</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/introObjectiveC.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocRuntimeSystem.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        <script type="text/javascript" language="JavaScript">placeWatermark()</script>
<div id="legacyOuterWrapper"><div align="center" id="watermark">
<div class="legacybox">
<h1>Legacy Document<span class="closebutton"><a href="javascript:closeWatermark()"><img src="../../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
You should read <em><a href="../../OOP_ObjC/index.html#//apple_ref/doc/uid/TP40005149" target="_top">Object-Oriented Programming with Objective-C</a></em>
                
                 and <em><a href="../../ObjectiveC/index.html#//apple_ref/doc/uid/TP30001163" target="_top">The Objective-C 2.0 Programming Language</a></em>
                
                 instead.</p></div></div></div>
        <a name="//apple_ref/doc/uid/TP40005191-CH7-BAJCJABD" title="The Language"></a><h1>The Language</h1><p>This chapter describes the Objective-C language and discusses the principles of object-oriented programming as they’re implemented in Objective-C. It covers all the features that the language adds to standard C and C++.</p><p>Because object-oriented programs postpone many decisions from compile time to runtime, object-oriented languages depend on a runtime system for executing the compiled code. The runtime system for the Objective-C language is discussed in <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-CJBBBCHG">“The Runtime System.”</a></span> This chapter presents the language, but touches on important elements of the runtime system.</p><p>The Apple compilers are based on the compilers of the GNU Compiler Collection<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_2"></a>. Objective-C syntax is a superset of GNU C/C++ syntax, and the Objective-C compiler works for C, C++ and Objective-C source code. The compiler recognizes Objective-C source files by the filename extension <code>.m</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_3"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_4"></a>, just as it recognizes files containing only standard C syntax by filename extension <code>.c</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_5"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_6"></a>. Similarly, the compiler recognizes C++ files that use Objective-C by the extension <code>.mm</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_7"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_8"></a>. Other issues when using Objective-C with C++ are covered in the section <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-117015">“Using C++ With Objective-C.”</a></span></p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-SW1">Objects</a>
				
			<br/>
			
        
			
			
				<a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-SW4">Object Messaging</a>
				
			<br/>
			
        
			
			
				<a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-BAJCDADF">Classes</a>
				
			<br/>
			
        
			
			
				<a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-BAJFFBGI">Defining a Class</a>
				
			<br/>
			
        
			
			
				<a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-BAJHIAGB">How Messaging Works</a>
				
			<br/>
			
        
			
			
				<a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-TPXREF138">Extending Classes</a>
				
			<br/>
			
        
			
			
				<a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-BAJIFIHG">Enabling Static Behaviors</a>
				
			<br/>
			
        
			
			
				<a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-BCIFAFAI">Exception Handling and Thread Synchronization</a>
				
			<br/>
			
        
			
			
				<a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-BCIDBAEA">Using C++ With Objective-C</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005191-CH7-111023" title="Objects"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-SW1" title="Objects"></a><h2>Objects</h2><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_9"></a>As the name implies, object-oriented programs are built around <strong>objects</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_10"></a>. An object associates data with the particular operations that can use or affect that data. In Objective-C, these operations are known as the object’s <strong>methods</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_11"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_12"></a>; the data they affect are its <strong>instance variables</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_13"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_14"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_15"></a>. In essence, an object bundles a data structure (instance variables) and a group of procedures<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_16"></a> (methods) into a self-contained programming unit.</p><p>For example, if you are writing a drawing program that allows a user to create images composed of lines, circles, rectangles, text, bit-mapped images, and so forth, you might create classes<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_17"></a> for many of the basic shapes that a user can manipulate. A Rectangle object<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_18"></a>, for instance, might have instance variables that identify the position of the rectangle within the drawing along with its width and its height. Other instance variables could define the rectangle’s color, whether or not it is to be filled, and a line pattern that should be used to display the rectangle. A Rectangle class would have methods to set an instance’s position, size, color, fill status, and line pattern, along with a method that causes the instance to display itself.</p><p>In Objective-C, an object’s instance variables<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_19"></a> are internal to the object; generally, you get access to an object’s state only through the object’s methods (you can specify whether subclasses or other objects can access instance variables directly by using scope directives, see <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-88468">“The Scope of Instance Variables”</a></span>). For others to find out something about an object, there has to be a method to supply the information. For example, a Rectangle would have methods that reveal its size and its position.</p><p>Moreover, an object sees only the methods that were designed for it; it can’t mistakenly perform methods intended for other types of objects. Just as a C function protects its local variables, hiding them from the rest of the program, an object hides both its instance variables and its method implementations.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_20"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-115416" title="id"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-SW2" title="id"></a><h3>id</h3><p>In Objective-C, object identifiers<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_21"></a> are a distinct data type: <code>id</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_22"></a>. This type is defined as a pointer to an object<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_23"></a>—in reality, a pointer to the instance variables of the object, the object’s unique data. Like a C function or an array, an object is identified by its address. All objects, regardless of their instance variables or methods, are of type <code>id</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>id anObject;<span></span></pre></td></tr></table></div><p>For the object-oriented constructs of Objective-C, such as method<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_24"></a> return values, <code>id</code> replaces <code>int</code> as the default data type. (For strictly C constructs, such as function return values, <code>int</code> remains the default type.)</p><p>The keyword <code>nil</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_25"></a> is defined as a null object, an <code>id</code> with a value of <code>0</code>. <code>id</code>, <code>nil</code>, and the other basic types of Objective-C are defined in the header file <code>objc/objc.h</code>.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-115349" title="Dynamic Typing"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-SW3" title="Dynamic Typing"></a><h3>Dynamic Typing</h3><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_26"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_27"></a><p>The <code>id</code> type is completely nonrestrictive. By itself, it yields no information about an object, except that it is an object.</p><p>But objects aren’t all the same. A Rectangle won’t have the same methods or instance variables as an object that represents a bit-mapped image. At some point, a program needs to find more specific information about the objects it contains—what the object’s instance variables are, what methods it can perform, and so on. Since the <code>id</code> type designator can’t supply this information to the compiler, each object has to be able to supply it at runtime.</p><p>This is possible because every object carries with it an <code>isa</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_28"></a> instance variable that identifies the object’s <strong>class</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_29"></a>—what kind of object it is. Every Rectangle object would be able to tell the runtime system that it is a Rectangle. Every Circle can say that it is a Circle. Objects with the same behavior (methods) and the same kinds of data (instance variables) are members of the same class.</p><p>Objects are thus <strong>dynamically typed</strong> at runtime. Whenever it needs to, the runtime system can find the exact class that an object belongs to, just by asking the object. Dynamic typing in Objective-C serves as the foundation for dynamic binding, discussed later.</p><p>The <code>isa</code> pointer also enables objects to perform <strong>introspection</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_30"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_31"></a>—to find out about themselves (or other objects). The compiler records information about class definitions in data structures for the runtime system to use. The functions of the runtime system use <code>isa</code>, to find this information at runtime. Using the runtime system, you can, for example, determine whether an object implements a particular method, or discover the name of its superclass.</p><p>Object classes are discussed in more detail under <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-86329">“Classes.”</a></span></p><p>It’s also possible to give the compiler information about the class of an object by statically typing it in source code using the class name. Classes are particular kinds of objects, and the class name can serve as a type name. See <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-86632">“Class Types”</a></span> and <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-93398">“Enabling Static Behaviors.”</a></span></p><a name="//apple_ref/doc/uid/TP40005191-CH7-85945" title="Object Messaging"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-SW4" title="Object Messaging"></a><h2>Object Messaging</h2><p>This section explains the syntax of sending messages, including how you can nest message expressions. It also discusses the “visibility” of an object’s instance variables, and the concepts of polymorphism and dynamic binding.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-SW5" title="Message Syntax"></a><h3>Message Syntax</h3><p>To get an object to do something, you send it a <strong>message</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_32"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_33"></a> telling it to apply a method<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_34"></a>. In Objective-C, <strong>message expressions</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_35"></a> are enclosed in brackets:</p><div class="codesample"><table><tr><td scope="row"><pre>[receiver message]<span></span></pre></td></tr></table></div><p>The receiver<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_36"></a> is an object, and the message tells it what to do. In source code, the message is simply the name of a method and any arguments that are passed to it. When a message<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_37"></a> is sent, the runtime system selects the appropriate method from the receiver’s repertoire and invokes it.</p><p>For example, this message tells the <code>myRect</code> object to perform its <code>display</code> method, which causes the rectangle to display itself:</p><div class="codesample"><table><tr><td scope="row"><pre>[myRect display];<span></span></pre></td></tr></table></div><p>Methods<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_38"></a> can also take arguments. The imaginary message below tells <code>myRect</code> to set its location within the window to coordinates (30.0, 50.0):</p><div class="codesample"><table><tr><td scope="row"><pre>[myRect setOrigin:30.0 :50.0];<span></span></pre></td></tr></table></div><p>Here the method name, <code>setOrigin::</code>, has two colons, one for each of its arguments<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_39"></a>. The arguments are inserted after the colons. This method name uses unlabeled arguments. Unlabeled arguments make it difficult to determine the kind and purpose of a method’s arguments. Instead, method names should include labels describing each of their arguments. Argument labels precede each colon in the method name. The <code>setWidth:height:</code> method, for example, makes the purpose of its two arguments clear:</p><div class="codesample"><table><tr><td scope="row"><pre>[myRect setWidth:10.0 height:15.0];<span></span></pre></td></tr></table></div><p>Methods that take a variable number of arguments<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_40"></a> are also possible, though they’re somewhat rare. Extra arguments are separated by commas after the end of the method name. (Unlike colons, the commas aren’t considered part of the name.) In the following example, the imaginary <code>makeGroup:</code> method is passed one required argument (<strong>group</strong>) and three that are optional:</p><div class="codesample"><table><tr><td scope="row"><pre>[receiver makeGroup:group, memberOne, memberTwo, memberThree];<span></span></pre></td></tr></table></div><p>Like standard C functions, methods<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_41"></a> can return values. The following example sets the variable <code>isFilled</code> to <code>YES</code> if <code>myRect</code> is drawn as a solid rectangle, or <code>NO</code> if it’s drawn in outline form only.</p><div class="codesample"><table><tr><td scope="row"><pre>BOOL isFilled;<span></span></pre></td></tr><tr><td scope="row"><pre>isFilled = [myRect isFilled];<span></span></pre></td></tr></table></div><p>Note that a variable and a method can have the same name.</p><p>One message expression can be nested inside another. Here, the color of one rectangle is set to the color of another:</p><div class="codesample"><table><tr><td scope="row"><pre>[myRect setPrimaryColor:[otherRect primaryColor]];<span></span></pre></td></tr></table></div><p>A message<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_42"></a> to <code>nil</code> also is valid, as long as the message returns an object, any pointer type, <code>void</code>, or any integer scalar of size less than or equal to <code>sizeof(void*)</code>; if it does, a message sent to <code>nil</code> returns <code>nil</code>. If the message sent to <code>nil</code> returns anything other than the aforementioned value types (for example, if it returns any struct type, any floating-point type, or any vector type) the return value is undefined. You should therefore not rely on the return value of messages sent to <code>nil</code> unless the method’s return type is an object, any pointer type, or any integer scalar of size less than or equal to <code>sizeof(void*)</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>id anObject = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// this is valid<span></span></pre></td></tr><tr><td scope="row"><pre>if ([anObject methodThatReturnsAnInt] == nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // implementation continues...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// this is not valid<span></span></pre></td></tr><tr><td scope="row"><pre>if ([anObject methodThatReturnsAFloat] == nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // implementation continues...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40005191-CH7-86167" title="The Receiver&acirc;&#128;&#153;s Instance Variables"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-SW6" title="The Receiver&acirc;&#128;&#153;s Instance Variables"></a><h3>The Receiver’s Instance Variables</h3><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_43"></a><p>A method has automatic access to the receiving object’s<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_44"></a> instance variables<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_45"></a>. You don’t need to pass them to the method as arguments. For example, the <code>primaryColor</code> method illustrated above takes no arguments, yet it can find the primary color for <code>otherRect</code> and return it. Every method assumes the receiver and its instance variables, without having to declare them as arguments.</p><p>This convention simplifies Objective-C source code. It also supports the way object-oriented programmers think about objects and messages. Messages are sent to receivers much as letters are delivered to your home. Message arguments bring information from the outside to the receiver; they don’t need to bring the receiver to itself.</p><p>A method has automatic access only to the receiver’s instance variables. If it requires information about a variable stored in another object, it must send a message to the object asking it to reveal the contents of the variable. The <code>primaryColor</code> and <code>isFilled</code> methods shown above are used for just this purpose.</p><p>See <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-139192">“Defining a Class”</a></span> for more information on referring to instance variables.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-86216" title="Polymorphism"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-SW7" title="Polymorphism"></a><h3>Polymorphism</h3><p>As the examples above illustrate, messages in Objective-C appear in the same syntactic positions as function calls in standard C. But, because methods “belong to” an object, messages behave differently than function calls.</p><p>In particular, an object can be operated on by only those methods that were defined for it. It can’t confuse them with methods defined for other kinds of objects, even if another object has a method with the same name. This means that two objects can respond differently to the same message. For example, each kind of object sent a <code>display</code> message could display itself in a unique way. A Circle and a Rectangle would respond differently to identical instructions to track the cursor.</p><p>This feature, referred to as <strong>polymorphism</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_46"></a>, plays a significant role in the design of object-oriented programs. Together with dynamic binding, it permits you to write code that might apply to any number of different kinds of objects, without you having to choose at the time you write the code what kinds of objects they might be. They might even be objects that will be developed later, by other programmers working on other projects. If you write code that sends a <code>display</code> message to an <code>id</code> variable, any object that has a <code>display</code> method is a potential receiver.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-86260" title="Dynamic Binding"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-SW8" title="Dynamic Binding"></a><h3>Dynamic Binding</h3><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_47"></a>A crucial difference between function calls and messages is that a function and its arguments are joined together in the compiled code, but a message and a receiving object aren’t united until the program is running and the message is sent. Therefore, the exact method that’s invoked to respond to a message can only be determined at runtime, not when the code is compiled.</p><p>The precise method<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_48"></a> that a message invokes depends on the receiver. Different receivers may have different method implementations for the same method name (polymorphism). For the compiler to find the right method implementation for a message, it would have to know what kind of object the receiver is—what class it belongs to. This is information the receiver is able to reveal at runtime when it receives a message (dynamic typing), but it’s not available from the type declarations found in source code.</p><p>The selection<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_49"></a> of a method implementation happens at runtime. When a message is sent, a runtime messaging routine looks at the receiver and at the method named in the message. It locates the receiver’s implementation of a method matching the name, “calls” the method, and passes it a pointer to the receiver’s instance variables. (For more on this routine, see <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-88846">“How Messaging Works.”</a></span>)</p><p>The method name in a message thus serves to “select” a method implementation. For this reason, method names in messages are often referred to as <strong>selectors</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_50"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_51"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_52"></a>.</p><p>This <strong>dynamic binding</strong> of methods to messages works hand-in-hand with polymorphism to give object-oriented programming much of its flexibility and power. Since each object can have its own version of a method, a program can achieve a variety of results, not by varying the message itself, but by varying just the object that receives the message. This can be done as the program runs; receivers can be decided “on the fly” and can be made dependent on external factors such as user actions.</p><p>When executing code based upon the Application Kit, for example, users determine which objects receive messages from menu commands like Cut, Copy, and Paste. The message goes to whatever object controls the current selection. An object that displays text would react to a <code>copy</code> message differently from an object that displays scanned images. An object that represents a set of shapes would respond differently from a Rectangle. Since messages don’t select methods (methods aren’t bound to messages) until runtime, these differences are isolated in the methods that respond to the message. The code that sends the message doesn’t have to be concerned with them; it doesn’t even have to enumerate the possibilities. Each application can invent its own objects that respond in their own way to <code>copy</code> messages.</p><p>Objective-C takes dynamic binding one step further and allows even the message that’s sent (the method selector) to be a variable<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_53"></a> that’s determined at runtime. This is discussed in the section <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-88846">“How Messaging Works.”</a></span><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_54"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-86329" title="Classes"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BAJCDADF" title="Classes"></a><h2>Classes</h2><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_55"></a>An object-oriented program is typically built from a variety of objects. A program based on the Cocoa frameworks might use <code>NSMatrix</code> objects, <code>NSWindow</code> objects, <code>NSDictionary</code> objects, <code>NSFont</code> objects, <code>NSText</code> objects, and many others. Programs often use more than one object of the same kind or class—several <code>NSArray</code> objects or <code>NSWindow</code> objects, for example.</p><p>In Objective-C, you define objects by defining their class. The class definition is a prototype for a kind of object; it declares the instance variables that become part of every member of the class, and it defines a set of methods that all objects in the class can use.</p><p>The compiler creates just one accessible object for each class, a <strong>class object</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_56"></a> that knows how to build new objects belonging to the class. (For this reason it’s traditionally called a “factory object.”) The class object is the compiled version of the class<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_57"></a>; the objects it builds are <strong>instances</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_58"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_59"></a> of the class<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_60"></a>. The objects that do the main work of your program are instances created by the class object at runtime.</p><p>All instances of a class have the same set of methods, and they all have a set of instance variables cut from the same mold. Each object gets its own instance variables, but the methods are shared.</p><p>By convention, class names begin with an uppercase letter (such as “Rectangle”); the names of instances typically begin with a lowercase letter (such as “myRect”).</p><a name="//apple_ref/doc/uid/TP40005191-CH7-86370" title="Inheritance"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BAJCCBHC" title="Inheritance"></a><h3>Inheritance</h3><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_61"></a>Class definitions are additive; each new class that you define is based on another class<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_62"></a> from which it <strong>inherits</strong> methods and instance variables. The new class simply adds to or modifies what it inherits. It doesn’t need to duplicate inherited code.</p><p>Inheritance links all classes together in a hierarchical tree with a single class at its root<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_63"></a>. When writing code that is based upon the Foundation framework, that root class is typically <code>NSObject</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_64"></a>. Every class (except a root class) has a <strong>superclass</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_65"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_66"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_67"></a> one step nearer the root, and any class (including a root class) can be the superclass for any number of <strong>subclasses</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_68"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_69"></a> one step farther from the root. <span class="content_text">Figure 1-1</span> illustrates the hierarchy for a few of the classes used in the drawing program.</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH7-86405" title="Figure 1-1Some Drawing Program Classes"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-CJBCADJA" title="Figure 1-1Some Drawing Program Classes"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>Some Drawing Program Classes</p><img src = "../Art/graphichierarchy.gif" alt = "" width="334" height="184"></div><br/><p>This figure shows that the Square class is a subclass of the Rectangle class, the Rectangle class is a subclass of Shape, Shape is a subclass of Graphic, and Graphic is a subclass of <code>NSObject</code>. Inheritance is cumulative. So a Square object has the methods and instance variables defined for Rectangle, Shape, Graphic, and <code>NSObject</code>, as well as those defined specifically for Square. This is simply to say that a Square object isn’t only a Square, it’s also a Rectangle, a Shape, a Graphic, and an <code>NSObject</code>.</p><p>Every class but <code>NSObject</code> can thus be seen as a specialization<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_70"></a> or an adaptation<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_71"></a> of another class. Each successive subclass further modifies the cumulative total of what’s inherited. The Square class defines only the minimum needed to turn a Rectangle into a Square.</p><p>When you define a class, you link it to the hierarchy by declaring its superclass; every class you create must be the subclass of another class (unless you define a new root class). Plenty of potential superclasses are available. Cocoa includes the <code>NSObject</code> class and several frameworks containing definitions for more than 250 additional classes. Some are classes that you can use “off the shelf”—incorporate into your program as is. Others you might want to adapt to your own needs by defining a subclass.</p><p>Some framework classes define almost everything you need, but leave some specifics to be implemented in a subclass. You can thus create very sophisticated objects by writing only a small amount of code, and reusing work done by the programmers of the framework.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-86438" title="The NSObject Class"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-SW9" title="The NSObject Class"></a><h4>The NSObject Class</h4><p><code>NSObject</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_72"></a> is a root<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_73"></a> class, and so doesn’t have a superclass. It defines the basic framework for Objective-C objects and object interactions. It imparts to the classes and instances of classes that inherit from it the ability to behave as objects and cooperate with the runtime system.</p><p>A class that doesn’t need to inherit any special behavior from another class should nevertheless be made a subclass of the <code>NSObject</code> class. Instances of the class must at least have the ability to behave like Objective-C objects at runtime. Inheriting this ability from the <code>NSObject</code> class is much simpler and much more reliable than reinventing it in a new class definition.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH7-SW10" title="Note"></a><p><strong>Note:</strong>&nbsp;Implementing a new root class is a delicate task and one with many hidden hazards. The class must duplicate much of what the <code>NSObject</code> class does, such as allocate instances, connect them to their class, and identify them to the runtime system. For this reason, you should generally use the <code>NSObject</code> class provided with Cocoa as the root class. For more information, see the Foundation framework documentation for the <code>NSObject</code> class and the <code>NSObject</code> protocol.</p></div><a name="//apple_ref/doc/uid/TP40005191-CH7-86471" title="Inheriting Instance Variables"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF109" title="Inheriting Instance Variables"></a><h4>Inheriting Instance Variables</h4><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_74"></a>When a class object creates a new instance, the new object contains not only the instance variables that were defined for its class but also the instance variables defined for its superclass and for its superclass’s superclass, all the way back to the root class. Thus, the <code>isa</code> instance variable defined in the <code>NSObject</code> class becomes part of every object. <code>isa</code> connects each object to its class.</p><p><span class="content_text">Figure 1-2</span> shows some of the instance variables that could be defined for a particular implementation of Rectangle, and where they may come from. Note that the variables that make the object a Rectangle are added to the ones that make it a Shape, and the ones that make it a Shape are added to the ones that make it a Graphic, and so on.</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH7-86501" title="Figure 1-2Rectangle Instance Variables"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-CJBEBJFD" title="Figure 1-2Rectangle Instance Variables"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Rectangle Instance Variables</p><img src = "../Art/graphicinstvars.gif" alt = "" width="288" height="149"></div><br/><p>A class doesn’t have to declare instance variables<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_75"></a>. It can simply define new methods and rely on the instance variables it inherits, if it needs any instance variables at all. For example, Square might not declare any new instance variables of its own.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_76"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-86520" title="Inheriting Methods"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF110" title="Inheriting Methods"></a><h4>Inheriting Methods</h4><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_77"></a><p>An object<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_78"></a> has access not only to the methods defined for its class<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_79"></a>, but also to methods defined for its superclass, and for its superclass’s superclass, all the way back to the root of the hierarchy. For instance, a Square object can use methods defined in the Rectangle, Shape, Graphic, and <code>NSObject</code> classes as well as methods defined in its own class.</p><p>Any new class you define in your program can therefore make use of the code written for all the classes above it in the hierarchy. This type of inheritance is a major benefit of object-oriented programming. When you use one of the object-oriented frameworks provided by Cocoa, your programs can take advantage of the basic functionality coded into the framework classes. You have to add only the code that customizes the standard functionality to your application.</p><p>Class objects also inherit from the classes above them in the hierarchy. But because they don’t have instance variables (only instances do), they inherit only methods.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-86544" title="Overriding One Method With Another"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF111" title="Overriding One Method With Another"></a><h4>Overriding One Method With Another</h4><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_80"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_81"></a><p>There’s one useful exception to inheritance: When you define a new class, you can implement a new method with the same name as one defined in a class farther up the hierarchy. The new method overrides the original; instances of the new class perform it rather than the original, and subclasses of the new class inherit it rather than the original.</p><p>For example, Graphic defines a <code>display</code> method that Rectangle overrides by defining its own version of <code>display</code>. The Graphic method is available to all kinds of objects that inherit from the Graphic class—but not to Rectangle objects, which instead perform the Rectangle version of <code>display</code>.</p><p>Although overriding a method blocks the original version from being inherited, other methods defined in the new class can skip over the redefined method and find the original (see <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-89660">“Messages to self and super”</a></span> to learn how).</p><p>A redefined method can also incorporate the very method it overrides. When it does, the new method serves only to refine or modify the method it overrides, rather than replace it outright. When several classes in the hierarchy define the same method, but each new version incorporates the version it overrides, the implementation of the method is effectively spread over all the classes.</p><p>Although a subclass can override inherited methods, it can’t override inherited instance variables. Since an object has memory allocated for every instance variable it inherits, you can’t override an inherited variable by declaring a new one with the same name. If you try, the compiler will complain.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-86594" title="Abstract Classes"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF112" title="Abstract Classes"></a><h4>Abstract Classes</h4><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_82"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_83"></a>Some classes are designed only so that other classes can inherit from them. These <strong>abstract classes</strong> group methods and instance variables that can be used by a number of different subclasses into a common definition. The abstract class is incomplete by itself, but contains useful code that reduces the implementation burden of its subclasses.</p><p>The <code>NSObject</code> class is the prime example of an abstract class. Although programs often define <code>NSObject</code> subclasses and use instances belonging to the subclasses, they never use instances belonging directly to the <code>NSObject</code> class. An <code>NSObject</code> instance wouldn’t be good for anything; it would be a generic object with the ability to do nothing in particular.</p><p>Abstract classes often contain code that helps define the structure of an application. When you create subclasses of these classes, instances of your new classes fit effortlessly into the application structure and work automatically with other objects.</p><p>(Because abstract classes must have subclasses to be useful, they’re sometimes also called <strong>abstract superclasses</strong>.)<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_84"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_85"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-86632" title="Class Types"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BAJCEHGF" title="Class Types"></a><h3>Class Types</h3><p>A class definition is a specification for a kind of object. The class, in effect, defines a data type. The type is based not just on the data structure the class defines (instance variables), but also on the behavior included in the definition (methods).</p><p>A class name can appear in source code wherever a type specifier is permitted in C—for example, as an argument to the <code>sizeof</code> operator:</p><div class="codesample"><table><tr><td scope="row"><pre>int i = sizeof(Rectangle);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40005191-CH7-86668" title="Static Typing"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF113" title="Static Typing"></a><h4>Static Typing</h4><p>You can use a class name in place of <code>id</code> to designate an object’s type:</p><div class="codesample"><table><tr><td scope="row"><pre>Rectangle *myRect;<span></span></pre></td></tr></table></div><p>Because this way of declaring an object type gives the compiler information about the kind of object it is, it’s known as <strong>static typing</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_86"></a>. Just as <code>id</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_87"></a> is defined as a pointer to an object, objects are statically typed as pointers to a class. Objects are always typed by a pointer. Static typing makes the pointer explicit; <code>id</code> hides it.</p><p>Static typing permits the compiler to do some type checking—for example, to warn if an object could receive a message that it appears not to be able to respond to—and to loosen some restrictions that apply to objects generically typed <code>id</code>. In addition, it can make your intentions clearer to others who read your source code. However, it doesn’t defeat dynamic binding or alter the dynamic determination of a receiver’s class at runtime.</p><p>An object can be statically typed to its own class or to any class that it inherits from. For example, since inheritance makes a Rectangle a kind of Graphic, a Rectangle instance could be statically typed to the Graphic class:</p><div class="codesample"><table><tr><td scope="row"><pre>Graphic *myRect;<span></span></pre></td></tr></table></div><p>This is possible because a Rectangle is a Graphic. It’s more than a Graphic since it also has the instance variables and method capabilities of a Shape and a Rectangle, but it’s a Graphic nonetheless. For purposes of type checking, the compiler considers <code>myRect</code> to be a Graphic, but at runtime it’s treated as a Rectangle.</p><p>See <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-93398">“Enabling Static Behaviors”</a></span> in the next chapter for more on static typing and its benefits.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-86761" title="Type Introspection"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF114" title="Type Introspection"></a><h4>Type Introspection</h4><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_88"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_89"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_90"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_91"></a><p>Instances can reveal their types at runtime. The <code>isMemberOfClass:</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_92"></a> method, defined in the <code>NSObject</code> class, checks whether the receiver is an instance of a particular class:</p><div class="codesample"><table><tr><td scope="row"><pre>if ( [anObject isMemberOfClass:someClass] )<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><p>The <code>isKindOfClass:</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_93"></a> method, also defined in the <code>NSObject</code> class, checks more generally whether the receiver inherits from or is a member of a particular class (whether it has the class in its inheritance path):</p><div class="codesample"><table><tr><td scope="row"><pre>if ( [anObject isKindOfClass:someClass] )<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><p>The set of classes for which <code>isKindOfClass:</code> returns <code>YES</code> is the same set to which the receiver can be statically typed.</p><p>Introspection isn’t limited to type information. Later sections of this chapter discuss methods that return the class object, report whether an object can respond to a message, and reveal other information.</p><p>See the <code>NSObject</code> class specification in the Foundation framework reference for more on <code>isKindOfClass:</code>, <code>isMemberOfClass:</code>, and related methods.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-86856" title="Class Objects"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF115" title="Class Objects"></a><h3>Class Objects</h3><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_94"></a>A class definition contains various kinds of information, much of it about instances of the class:</p><ul class="spaceabove"><li class="li"><p>The name of the class and its superclass</p></li><li class="li"><p>A template describing a set of instance variables</p></li><li class="li"><p>The declarations of method names and their return and argument types</p></li><li class="li"><p>The method implementations</p></li></ul><p>This information is compiled and recorded in data structures made available to the runtime system. The compiler creates just one object, a <strong>class object</strong>, to represent the class. The class object has access to all the information about the class, which means mainly information about what instances of the class are like. It’s able to produce new instances according to the plan put forward in the class definition.</p><p>Although a class object keeps the prototype of a class instance, it’s not an instance itself. It has no instance variables of its own and it can’t perform methods intended for instances of the class. However, a class definition can include methods intended specifically for the class object—<strong>class methods</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_95"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_96"></a> as opposed to <strong>instance methods</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_97"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_98"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_99"></a>. A class object inherits class methods from the classes above it in the hierarchy, just as instances inherit instance methods.</p><p>In source code, the class object is represented by the class name. In the following example, the Rectangle class returns the class version number using a method inherited from the <code>NSObject</code> class:</p><div class="codesample"><table><tr><td scope="row"><pre>int versionNumber = [Rectangle version];<span></span></pre></td></tr></table></div><p>However, the class name stands for the class object only as the receiver in a message expression. Elsewhere, you need to ask an instance or the class to return the class <code>id</code>. Both respond to a <code>class</code> message:</p><div class="codesample"><table><tr><td scope="row"><pre>id aClass = [anObject class];<span></span></pre></td></tr><tr><td scope="row"><pre>id rectClass = [Rectangle class];<span></span></pre></td></tr></table></div><p>As these examples show, class objects can, like all other objects, be typed <code>id</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_100"></a>. But class objects can also be more specifically typed to the Class data type<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_101"></a>:</p><div class="codesample"><table><tr><td scope="row"><pre>Class aClass = [anObject class];<span></span></pre></td></tr><tr><td scope="row"><pre>Class rectClass = [Rectangle class];<span></span></pre></td></tr></table></div><p>All class objects are of type Class. Using this type name for a class is equivalent to using the class name to statically type an instance.</p><p>Class objects are thus full-fledged objects that can be dynamically typed, receive messages, and inherit methods from other classes. They’re special only in that they’re created by the compiler, lack data structures (instance variables) of their own other than those built from the class definition, and are the agents for producing instances at runtime.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH7-SW11" title="Note"></a><p><strong>Note:</strong>&nbsp;The compiler also builds a “metaclass object<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_102"></a>” for each class. It describes the class object just as the class object describes instances of the class. But while you can send messages to instances and to the class object, the metaclass object is used only internally by the runtime system.</p></div><a name="//apple_ref/doc/uid/TP40005191-CH7-87015" title="Creating Instances"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF116" title="Creating Instances"></a><h4>Creating Instances</h4><p>A principal function of a class object is to create new instances<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_103"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_104"></a>. This code tells the Rectangle class to create a new Rectangle instance and assign it to the <code>myRect</code> variable:</p><div class="codesample"><table><tr><td scope="row"><pre>id  myRect;<span></span></pre></td></tr><tr><td scope="row"><pre>myRect = [Rectangle alloc];<span></span></pre></td></tr></table></div><p>The <code>alloc</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_105"></a> method dynamically allocates memory for the new object’s instance variables and initializes them all to <code>0</code>—all, that is, except the <code>isa</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_106"></a> variable that connects the new instance<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_107"></a> to its class. For an object to be useful, it generally needs to be more completely initialized. That’s the function of an <code>init</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_108"></a> method. Initialization<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_109"></a> typically follows immediately after allocation:</p><div class="codesample"><table><tr><td scope="row"><pre>myRect = [[Rectangle alloc] init];<span></span></pre></td></tr></table></div><p>This line of code, or one like it, would be necessary before <code>myRect</code> could receive any of the messages that were illustrated in previous examples in this chapter. The <code>alloc</code> method returns a new instance and that instance performs an <code>init</code> method to set its initial state. Every class object has at least one method (like <code>alloc</code>) that enables it to produce new objects, and every instance has at least one method (like <code>init</code>) that prepares it for use. Initialization methods often take arguments to allow particular values to be passed and have keywords to label the arguments (<code>initWithPosition:size:</code>, for example, is a method that might initialize a new Rectangle instance), but they all begin with “init”.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-87110" title="Customization With Class Objects"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF117" title="Customization With Class Objects"></a><h4>Customization With Class Objects</h4><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_110"></a>It’s not just a whim of the Objective-C language that classes are treated as objects. It’s a choice that has intended, and sometimes surprising, benefits for design. It’s possible, for example, to customize an object with a class, where the class belongs to an open-ended set. In the Application Kit, for example, an <code>NSMatrix</code> object can be customized<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_111"></a> with a particular kind of <code>NSCell</code> object.</p><p>An <code>NSMatrix</code> object can take responsibility for creating the individual objects that represent its cells. It can do this when the matrix is first initialized and later when new cells are needed. The visible matrix that an <code>NSMatrix</code> object draws on the screen can grow and shrink at runtime, perhaps in response to user actions. When it grows, the matrix needs to be able to produce new objects to fill the new slots that are added.</p><p>But what kind of objects should they be? Each matrix displays just one kind of <code>NSCell</code>, but there are many different kinds. The inheritance hierarchy in <span class="content_text">Figure 1-3</span> shows some of those provided by the Application Kit. All inherit from the generic <code>NSCell</code> class:</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH7-87137" title="Figure 1-3Inheritance hierarchy for NSCell"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-CJBBDEEH" title="Figure 1-3Inheritance hierarchy for NSCell"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>Inheritance hierarchy for NSCell</p><img src = "../Art/cellhierarchy.gif" alt = "" width="418" height="152"></div><br/><p>When an matrix creates <code>NSCell</code> objects, should they be <code>NSButtonCell</code> objects to display a bank of buttons or switches, <code>NSTextFieldCell</code> objects to display fields where the user can enter and edit text, or some other kind of <code>NSCell</code>? The <code>NSMatrix</code> object must allow for any kind of cell, even types that haven’t been invented yet.</p><p>One solution to this problem is to define the <code>NSMatrix</code> class as an abstract class and require everyone who uses it to declare a subclass and implement the methods that produce new cells. Because they would be implementing the methods, users of the class could be sure that the objects they created were of the right type.</p><p>But this requires others to do work that ought to be done in the <code>NSMatrix</code> class, and it unnecessarily proliferates the number of classes. Since an application might need more than one kind of <code>NSMatrix</code>, each with a different kind of <code>NSCell</code>, it could become cluttered with <code>NSMatrix</code> subclasses. Every time you invented a new kind of <code>NSCell</code>, you’d also have to define a new kind of <code>NSMatrix</code>. Moreover, programmers on different projects would be writing virtually identical code to do the same job, all to make up for <code>NSMatrix</code>'s failure to do it.</p><p>A better solution, the solution the <code>NSMatrix</code> class actually adopts, is to allow <code>NSMatrix</code> instances to be initialized with a kind of <code>NSCell</code>—with a class object. It defines a <code>setCellClass:</code> method that passes the class object for the kind of <code>NSCell</code> object an <code>NSMatrix</code> should use to fill empty slots:</p><div class="codesample"><table><tr><td scope="row"><pre>[myMatrix setCellClass:[NSButtonCell class]];<span></span></pre></td></tr></table></div><p>The <code>NSMatrix</code> object uses the class object to produce new cells when it’s first initialized and whenever it’s resized to contain more cells. This kind of customization would be difficult if classes weren’t objects that could be passed in messages and assigned to variables.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_112"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-87193" title="Variables and Class Objects"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF118" title="Variables and Class Objects"></a><h4>Variables and Class Objects</h4><p>When you define a new class, you can specify instance variables. Every instance of the class can maintain its own copy of the variables you declare—each object controls its own data. There is, however, no “class variable”<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_113"></a> counterpart to an instance variable. Only internal data structures, initialized from the class definition, are provided for the class. Moreover, a class object has no access to the instance variables of any instances; it can’t initialize, read, or alter them.</p><p>For all the instances of a class to share data, you must define an external variable of some sort. The simplest way to do this is to declare a variable in the class implementation file as illustrated in the following code fragment.</p><div class="codesample"><table><tr><td scope="row"><pre>int MCLSGlobalVariable;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyClass<span></span></pre></td></tr><tr><td scope="row"><pre>// implementation continues<span></span></pre></td></tr></table></div><p>In a more sophisticated implementation, you can declare a variable to be <code>static</code>, and provide class methods<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_114"></a> to manage it. Declaring a variable <code>static</code> limits its scope to just the class—and to just the part of the class that’s implemented in the file. (Thus unlike instance variables, static variables cannot be inherited by, or directly manipulated by, subclasses.) This pattern is commonly used to define shared instances of a class (such as singletons, see <span class="content_text"><!--a target="_top" -->Creating a Singleton Instance<!--/a--></span>).</p><div class="codesample"><table><tr><td scope="row"><pre>static MyClass *MCLSSharedInstance;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyClass<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>+ (MyClass *)sharedInstance<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // check for existence of shared instance<span></span></pre></td></tr><tr><td scope="row"><pre>    // create if necessary<span></span></pre></td></tr><tr><td scope="row"><pre>    return MCLSSharedInstance;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>// implementation continues<span></span></pre></td></tr></table></div><p>Static variables help give the class object more functionality than just that of a “factory” producing instances; it can approach being a complete and versatile object in its own right. A class object can be used to coordinate the instances it creates, dispense instances from lists of objects already created, or manage other processes essential to the application. In the case when you need only one object of a particular class, you can put all the object’s state into static variables and use only class methods. This saves the step of allocating and initializing an instance.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH7-SW12" title="Note"></a><p><strong>Note:</strong>&nbsp;It is also possible to use external variables that are not declared <code>static</code>, but the limited scope of static variables better serves the purpose of encapsulating data into separate objects.</p></div><a name="//apple_ref/doc/uid/TP40005191-CH7-87244" title="Initializing a Class Object"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF119" title="Initializing a Class Object"></a><h4>Initializing a Class Object</h4><p>If a class object<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_115"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_116"></a> is to be used for anything besides allocating instances, it may need to be initialized just as an instance is. Although programs don’t allocate class objects, Objective-C does provide a way for programs to initialize them.</p><p>If a class makes use of static or global variables, the <code>initialize</code> method is a good place to set their initial values. For example, if a class maintains an array of instances, the <code>initialize</code> method could set up the array and even allocate one or two default instances to have them ready.</p><p>The runtime system sends an <code>initialize</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_117"></a> message to every class object before the class receives any other messages and after its superclass has received the <code>initialize</code> message. This gives the class a chance to set up its runtime environment before it’s used. If no initialization is required, you don’t need to write an <code>initialize</code> method to respond to the message.</p><p>Because of inheritance, an <code>initialize</code> message sent to a class that doesn’t implement the <code>initialize</code> method is forwarded to the superclass, even though the superclass has already received the <code>initialize</code> message. For example, assume class A implements the <code>initialize</code> method, and class B inherits from class A but does not implement the <code>initialize</code> method. Just before class B is to receive its first message, the runtime system sends <code>initialize</code> to it. But, because class B doesn’t implement <code>initialize</code>, class A’s <code>initialize</code> is executed instead. Therefore, class A should ensure that its initialization logic is performed only once.</p><p>To avoid performing initialization logic more than once, use the template in <span class="content_text">Listing 1-1</span> when implementing the <code>initialize</code> method.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-204371" title="Listing 1-1Implementation of the initialize method"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BBCBIGBG" title="Listing 1-1Implementation of the initialize method"></a><p class="codesample"><strong>Listing 1-1&nbsp;&nbsp;</strong>Implementation of the initialize method</p><div class="codesample"><table><tr><td scope="row"><pre>+ (void)initialize<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    static BOOL initialized = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!initialized) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Perform initialization here.<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>        initialized = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH7-SW13" title="Note"></a><p><strong>Note:</strong>&nbsp;Remember that the runtime system sends <code>initialize</code> to each class individually. Therefore, in a class’s implementation of the <code>initialize</code> method, you must not send the <code>initialize</code> message to its superclass.</p></div><a name="//apple_ref/doc/uid/TP40005191-CH7-87293" title="Methods of the Root Class"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF120" title="Methods of the Root Class"></a><h4>Methods of the Root Class</h4><p>All objects, classes and instances alike, need an interface to the runtime system. Both class objects and instances should be able to introspect about their abilities and to report their place in the inheritance hierarchy. It’s the province of the <code>NSObject</code> class to provide this interface.</p><p>So that <code>NSObject</code>'s methods don’t have to be implemented twice—once to provide a runtime interface for instances and again to duplicate that interface for class objects—class objects<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_118"></a> are given special dispensation to perform instance methods defined in the root class. When a class object receives a message that it can’t respond to with a class method<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_119"></a>, the runtime system determines whether there’s a root instance method<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_120"></a> that can respond. The only instance methods that a class object can perform are those defined in the root class, and only if there’s no class method that can do the job.</p><p>For more on this peculiar ability of class objects to perform root instance methods, see the <code>NSObject</code> class specification in the Foundation framework reference.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_121"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-87318" title="Class Names in Source Code"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF121" title="Class Names in Source Code"></a><h3>Class Names in Source Code</h3><p>In source code<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_122"></a>, class names can be used in only two very different contexts. These contexts reflect the dual role of a class as a data type and as an object:</p><ul class="spaceabove"><li class="li"><p>The class name can be used as a type name for a kind of object. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>Rectangle * anObject;<span></span></pre></td></tr></table></div><p>Here <code>anObject</code> is statically typed to be a pointer to a Rectangle. The compiler expects it to have the data structure of a Rectangle instance and the instance methods defined and inherited by the Rectangle class. Static typing enables the compiler to do better type checking and makes source code more self-documenting. See <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-93398">“Enabling Static Behaviors”</a></span> for details.</p><p>Only instances can be statically typed; class objects<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_123"></a> can’t be, since they aren’t members of a class, but rather belong to the Class data type.</p></li><li class="li"><p>As the receiver<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_124"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_125"></a> in a message expression, the class name refers to the class object. This usage was illustrated in several of the earlier examples. The class name can stand for the class object only as a message receiver. In any other context, you must ask the class object to reveal its <code>id</code> (by sending it a class message). The example below passes the Rectangle class as an argument in an <code>isKindOfClass:</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_126"></a> message.</p><div class="codesample"><table><tr><td scope="row"><pre>if ( [anObject isKindOfClass:[Rectangle class]] )<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><p>It would have been illegal to simply use the name “Rectangle” as the argument. The class name can only be a receiver.</p><p>If you don’t know the class name at compile time but have it as a string at runtime, <code>NSClassFromString</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_127"></a> will return the class object:</p><div class="codesample"><table><tr><td scope="row"><pre>NSString *className;<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>if ( [anObject isKindOfClass:NSClassFromString(className)] )<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><p>This function returns <code>nil</code> if the string it’s passed is not a valid class name.</p></li></ul><p>Classnames exist in the same namespace as global variables and function names. A class and a global variable can’t have the same name. Classnames are about the only names with global visibility in Objective-C.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_128"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-139192" title="Defining a Class"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BAJFFBGI" title="Defining a Class"></a><h2>Defining a Class</h2><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_129"></a>Much of object-oriented programming consists of writing the code for new objects—defining new classes. In Objective-C, classes are defined in two parts:</p><ul class="ul"><li class="li"><p>An <strong>interface</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_130"></a> that declares the methods and instance variables of the class and names its superclass</p></li><li class="li"><p>An <strong>implementation</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_131"></a> that actually defines the class (contains the code that implements its methods)</p></li></ul><p>Although the compiler doesn’t require it, the interface and implementation are usually separated into two different files. The interface file must be made available to anyone who uses the class.</p><p>A single file can declare or implement more than one class. Nevertheless, it’s customary to have a separate interface file for each class, if not also a separate implementation file. Keeping class interfaces separate better reflects their status as independent entities.</p><p>Interface and implementation files typically are named after the class. The name of the implementation file<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_132"></a> has the <code>.m</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_133"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_134"></a> extension, indicating that it contains Objective-C source code. The interface file can be assigned any other extension. Because it’s included in other source files, the name of the interface file usually has the <code>.h</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_135"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_136"></a> extension typical of header files. For example, the Rectangle class would be declared in <code>Rectangle.h</code> and defined in <code>Rectangle.m</code>.</p><p>Separating an object’s interface from its implementation fits well with the design of object-oriented programs. An object is a self-contained entity that can be viewed from the outside almost as a “black box.” Once you’ve determined how an object interacts with other elements in your program—that is, once you’ve declared its interface—you can freely alter its implementation without affecting any other part of the application.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-87537" title="The Interface"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF122" title="The Interface"></a><h3>The Interface</h3><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_137"></a>The declaration of a class interface begins with the compiler directive <code>@interface</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_138"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_139"></a> and ends with the directive<code> @end</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_140"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_141"></a>. (All Objective-C directives to the compiler begin with “@”.)</p><div class="codesample"><table><tr><td scope="row"><pre>@interface ClassName : ItsSuperclass<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    instance variable declarations<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>method declarations<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>The first line of the declaration presents the new class name and links it to its superclass. The superclass defines the position of the new class in the inheritance hierarchy, as discussed under <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-86370">“Inheritance.”</a></span> If the colon and superclass name are omitted, the new class is declared as a root class<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_142"></a>, a rival to the <code>NSObject</code> class.</p><p>Following the first part of the class declaration, braces enclose declarations of <strong>instance variables</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_143"></a>, the data structures that are part of each instance of the class. Here’s a partial list of instance variables that might be declared in the Rectangle class:</p><div class="codesample"><table><tr><td scope="row"><pre>float width;<span></span></pre></td></tr><tr><td scope="row"><pre>float height;<span></span></pre></td></tr><tr><td scope="row"><pre>BOOL filled;<span></span></pre></td></tr><tr><td scope="row"><pre>NSColor *fillColor;<span></span></pre></td></tr></table></div><p>Methods<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_144"></a> for the class are declared next, after the braces enclosing instance variables and before the end of the class declaration. The names of methods that can be used by class objects, <strong>class methods</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_145"></a>, are preceded by a plus sign<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_146"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_147"></a>:</p><div class="codesample"><table><tr><td scope="row"><pre>+ alloc;<span></span></pre></td></tr></table></div><p>The methods that instances of a class can use, <strong>instance methods</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_148"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_149"></a>, are marked with a minus sign<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_150"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_151"></a>:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)display;<span></span></pre></td></tr></table></div><p>Although it’s not a common practice, you can define a class method and an instance method with the same name. A method can also have the same name as an instance variable. This is more common, especially if the method returns the value in the variable. For example, Circle has a <code>radius</code> method that could match a <code>radius</code> instance variable.</p><p>Method return types<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_152"></a> are declared using the standard C syntax for casting one type to another:</p><div class="codesample"><table><tr><td scope="row"><pre>- (float)radius;<span></span></pre></td></tr></table></div><p>Argument types<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_153"></a> are declared in the same way:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setRadius:(float)aRadius;<span></span></pre></td></tr></table></div><p>If a return or argument type isn’t explicitly declared, it’s assumed to be the default type for methods and messages—an <code>id</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_154"></a>. The <code>alloc</code> method illustrated earlier returns <code>id</code>.</p><p>When there’s more than one argument, the arguments are declared within the method name after the colons. Arguments break the name apart in the declaration, just as in a message. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setWidth:(float)width height:(float)height;<span></span></pre></td></tr></table></div><p>Methods that take a variable<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_155"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_156"></a> number of arguments declare them using a comma and ellipsis points, just as a function would:</p><div class="codesample"><table><tr><td scope="row"><pre>- makeGroup:group, ...;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40005191-CH7-87788" title="Importing the Interface"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF123" title="Importing the Interface"></a><h4>Importing the Interface</h4><p>The interface file<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_157"></a> must be included in any source module that depends on the class interface—that includes any module that creates an instance of the class, sends a message to invoke a method declared for the class, or mentions an instance variable declared in the class. The interface is usually included with the <code>#import</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_158"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_159"></a> directive:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "Rectangle.h"<span></span></pre></td></tr></table></div><p>This directive is identical to <code>#include</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_160"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_161"></a>, except that it makes sure that the same file is never included more than once. It’s therefore preferred and is used in place of <code>#include</code> in code examples throughout Objective-C–based documentation.</p><p>To reflect the fact that a class definition builds on the definitions of inherited classes, an interface file<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_162"></a> begins by importing the interface for its superclass<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_163"></a>:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "ItsSuperclass.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface ClassName : ItsSuperclass<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    instance variable declarations<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>method declarations<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>This convention means that every interface file includes, indirectly, the interface files for all inherited classes. When a source module imports a class interface, it gets interfaces for the entire inheritance hierarchy that the class is built upon.</p><p>Note that if there is a <em>precomp</em>—a precompiled header<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_164"></a>—that supports the superclass, you may prefer to import the precomp instead.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-87895" title="Referring to Other Classes"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF124" title="Referring to Other Classes"></a><h4>Referring to Other Classes</h4><p>An interface file declares a class and, by importing its superclass, implicitly contains declarations for all inherited classes, from <code>NSObject</code> on down through its superclass. If the interface mentions classes not in this hierarchy, it must import them explicitly or declare them with the <code>@class</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_165"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_166"></a> directive:</p><div class="codesample"><table><tr><td scope="row"><pre>@class Rectangle, Circle;<span></span></pre></td></tr></table></div><p>This directive simply informs the compiler that “Rectangle” and “Circle” are class names. It doesn’t import their interface files.</p><p>An interface file mentions class names when it statically types instance variables, return values, and arguments. For example, this declaration</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setPrimaryColor:(NSColor *)aColor;<span></span></pre></td></tr></table></div><p>mentions the <code>NSColor</code> class.</p><p>Since declarations like this simply use the class name as a type and don’t depend on any details of the class interface (its methods and instance variables), the <code>@class</code> directive gives the compiler sufficient forewarning of what to expect. However, where the interface to a class is actually used (instances created, messages sent), the class interface must be imported. Typically, an interface file uses <code>@class</code> to declare classes, and the corresponding implementation file imports their interfaces (since it will need to create instances of those classes or send them messages).</p><p>The <code>@class</code> directive minimizes the amount of code seen by the compiler and linker, and is therefore the simplest way to give a forward declaration of a class name. Being simple, it avoids potential problems that may come with importing files that import still other files. For example, if one class declares a statically typed<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_167"></a> instance variable of another class, and their two interface files import each other, neither class may compile correctly.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-87976" title="The Role of the Interface"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF125" title="The Role of the Interface"></a><h4>The Role of the Interface</h4><p>The purpose of the interface file is to declare the new class to other source modules (and to other programmers). It contains all the information they need to work with the class (programmers might also appreciate a little documentation).</p><ul class="spaceabove"><li class="li"><p>The interface file tells users how the class is connected into the inheritance hierarchy and what other classes—inherited or simply referred to somewhere in the class—are needed.</p></li><li class="li"><p>The interface file also lets the compiler know what instance variables an object contains, and tells programmers what variables subclasses inherit. Although instance variables are most naturally viewed as a matter of the implementation of a class rather than its interface, they must nevertheless be declared in the interface file. This is because the compiler must be aware of the structure of an object where it’s used, not just where it’s defined. As a programmer, however, you can generally ignore the instance variables of the classes you use, except when defining a subclass.</p></li><li class="li"><p>Finally, through its list of method declarations, the interface file lets other modules know what messages can be sent to the class object and instances of the class. Every method that can be used outside the class definition is declared in the interface file; methods that are internal to the class implementation can be omitted.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_168"></a></p></li></ul><a name="//apple_ref/doc/uid/TP40005191-CH7-88010" title="The Implementation"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF126" title="The Implementation"></a><h3>The Implementation</h3><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_169"></a><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_170"></a>The definition of a class is structured very much like its declaration. It begins with the <code>@implementation</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_171"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_172"></a> directive and ends with the <code>@end</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_173"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_174"></a> directive:</p><div class="codesample"><table><tr><td scope="row"><pre>@implementation ClassName : ItsSuperclass<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    instance variable declarations<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>method definitions<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>However, every implementation file<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_175"></a> must import its own interface. For example, <code>Rectangle.m</code> imports <code>Rectangle.h</code>. Because the implementation doesn’t need to repeat any of the declarations it imports, it can safely omit:</p><ul class="spaceabove"><li class="li"><p>The name of the superclass</p></li><li class="li"><p>The declarations of instance variables</p></li></ul><p>This simplifies the implementation<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_176"></a> and makes it mainly devoted to method definitions:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "ClassName.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation ClassName<span></span></pre></td></tr><tr><td scope="row"><pre>method definitions<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Methods<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_177"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_178"></a> for a class are defined, like C functions, within a pair of braces. Before the braces, they’re declared in the same manner as in the interface file, but without the semicolon. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>+ alloc<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isfilled<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setFilled:(BOOL)flag<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Methods that take a variable number of arguments handle them just as a function would:</p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;stdarg.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> ...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- getGroup:group, ...<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    va_list ap;<span></span></pre></td></tr><tr><td scope="row"><pre>    va_start(ap, group);<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40005191-CH7-88281" title="Referring to Instance Variables"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BAJHEIFE" title="Referring to Instance Variables"></a><h4>Referring to Instance Variables</h4><p>By default, the definition of an instance method<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_179"></a> has all the instance variables<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_180"></a> of the object within its scope. It can refer to them simply by name. Although the compiler creates the equivalent of C structures to store instance variables, the exact nature of the structure is hidden. You don’t need either of the structure operators (<code>.</code> or <code>-></code>) to refer to an object’s data. For example, the following method definition refers to the receiver’s <code>filled</code> instance variable:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setFilled:(BOOL)flag<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    filled = flag;<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Neither the receiving object nor its <code>filled</code> instance variable is declared as an argument to this method, yet the instance variable falls within its scope. This simplification of method syntax is a significant shorthand in the writing of Objective-C code.</p><p>When the instance variable belongs to an object that’s not the receiver, the object’s type must be made explicit to the compiler through static typing<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_181"></a>. In referring to the instance variable of a statically typed object, the structure pointer operator (<code>-></code>) is used.</p><p>Suppose, for example, that the Sibling class declares a statically typed object, <code>twin</code>, as an instance variable:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Sibling : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Sibling *twin;<span></span></pre></td></tr><tr><td scope="row"><pre>    int gender;<span></span></pre></td></tr><tr><td scope="row"><pre>    struct features *appearance;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>As long as the instance variables of the statically typed object are within the scope of the class (as they are here because <code>twin</code> is typed to the same class), a Sibling method can set them directly:</p><div class="codesample"><table><tr><td scope="row"><pre>- makeIdenticalTwin<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( !twin ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        twin = [[Sibling alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>        twin->gender = gender;<span></span></pre></td></tr><tr><td scope="row"><pre>        twin->appearance = appearance;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return twin;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40005191-CH7-88468" title="The Scope of Instance Variables"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF127" title="The Scope of Instance Variables"></a><h4>The Scope of Instance Variables</h4><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_182"></a>Although they’re declared in the class interface, instance variables are more a matter of the way a class is implemented than of the way it’s used. An object’s interface lies in its methods, not in its internal data structures.</p><p>Often there’s a one-to-one correspondence between a method and an instance variable, as in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)isFilled<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return filled;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>But this need not be the case. Some methods might return information not stored in instance variables, and some instance variables might store information that an object is unwilling to reveal.</p><p>As a class is revised from time to time, the choice of instance variables may change, even though the methods it declares remain the same. As long as messages are the vehicle for interacting with instances of the class, these changes won’t really affect its interface.</p><p>To enforce the ability of an object to hide its data, the compiler limits the scope of instance variables—that is, limits their visibility within the program. But to provide flexibility, it also lets you explicitly set the scope at three different levels. Each level is marked by a compiler directive:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Directive</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th></tr><tr><td  scope="row"><p><code>@private</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_183"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_184"></a></p></td><td ><p>The instance variable<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_185"></a> is accessible only within the class that declares it.</p></td></tr><tr><td  scope="row"><p><code>@protected</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_186"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_187"></a></p></td><td ><p>The instance variable is accessible within the class that declares it and within classes that inherit it.</p></td></tr><tr><td  scope="row"><p><code>@public</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_188"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_189"></a></p></td><td ><p>The instance variable is accessible everywhere.</p></td></tr></table></div><p>This is illustrated in <span class="content_text">Figure 1-4</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH7-88582" title="Figure 1-4The scope of instance variables"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-CJBFHAIC" title="Figure 1-4The scope of instance variables"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>The scope of instance variables</p><img src = "../Art/scopeinstvariables.gif" alt = "" width="356" height="303"></div><br/><p>A directive applies to all the instance variables listed after it, up to the next directive or the end of the list. In the following example, the <code>age</code> and <code>evaluation</code> instance variables are private, <code>name</code>, <code>job</code>, and <code>wage</code> are protected, and <code>boss</code> is public.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Worker : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    char *name;<span></span></pre></td></tr><tr><td scope="row"><pre>@private<span></span></pre></td></tr><tr><td scope="row"><pre>    int age;<span></span></pre></td></tr><tr><td scope="row"><pre>    char *evaluation;<span></span></pre></td></tr><tr><td scope="row"><pre>@protected<span></span></pre></td></tr><tr><td scope="row"><pre>    id job;<span></span></pre></td></tr><tr><td scope="row"><pre>    float wage;<span></span></pre></td></tr><tr><td scope="row"><pre>@public<span></span></pre></td></tr><tr><td scope="row"><pre>    id boss;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>By default, all unmarked instance variables (like <code>name</code> above) are <code>@protected</code>.</p><p>All instance variables that a class declares, no matter how they’re marked, are within the scope of the class definition. For example, a class that declares a <code>job</code> instance variable, such as the Worker class shown above, can refer to it in a method definition:</p><div class="codesample"><table><tr><td scope="row"><pre>- promoteTo:newPosition<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    id old = job;<span></span></pre></td></tr><tr><td scope="row"><pre>    job = newPosition;<span></span></pre></td></tr><tr><td scope="row"><pre>    return old;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Obviously, if a class couldn’t access its own instance variables, the instance variables would be of no use whatsoever.</p><p>Normally, a class also has access to the instance variables<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_190"></a> it inherits. The ability to refer to an instance variable is usually inherited along with the variable. It makes sense for classes to have their entire data structures within their scope, especially if you think of a class definition as merely an elaboration of the classes it inherits from. The <code>promoteTo:</code> method illustrated earlier could just as well have been defined in any class that inherits the <code>job</code> instance variable from the Worker class.</p><p>However, there are reasons why you might want to restrict inheriting classes from directly accessing an instance variable:</p><ul class="spaceabove"><li class="li"><p>Once a subclass accesses an inherited instance variable, the class that declares the variable is tied to that part of its implementation. In later versions, it can’t eliminate the variable or alter the role it plays without inadvertently breaking the subclass.</p></li><li class="li"><p>Moreover, if a subclass accesses an inherited instance variable and alters its value, it may inadvertently introduce bugs in the class that declares the variable, especially if the variable is involved in class-internal dependencies.</p></li></ul><p>To limit an instance variable’s scope to just the class that declares it, you must mark it <code>@private</code>. Instance variables marked <code>@private</code> are only available to subclasses by calling public accessor methods, if they exist.</p><p>At the other extreme, marking a variable <code>@public</code> makes it generally available, even outside of class definitions that inherit or declare the variable. Normally, to get information stored in an instance variable, other objects must send a message requesting it. However, a public instance variable can be accessed anywhere as if it were a field in a C structure. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>Worker *ceo = [[Worker alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>ceo->boss = nil;<span></span></pre></td></tr></table></div><p>Note that the object must be statically typed.</p><p>Marking instance variables <code>@public</code> defeats the ability of an object to hide its data. It runs counter to a fundamental principle of object-oriented programming—the encapsulation of data within objects where it’s protected from view and inadvertent error. Public instance variables should therefore be avoided except in extraordinary cases.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_191"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_192"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_193"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-88846" title="How Messaging Works"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BAJHIAGB" title="How Messaging Works"></a><h2>How Messaging Works</h2><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_194"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_195"></a>In Objective-C, messages<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_196"></a> aren’t bound to method implementations until runtime. The compiler converts a message expression,</p><div class="codesample"><table><tr><td scope="row"><pre>[receiver message]<span></span></pre></td></tr></table></div><p>into a call on a messaging function, <code>objc_msgSend</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_197"></a>. This function takes the receiver<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_198"></a> and the name of the method mentioned in the message—that is, the method selector—as its two principal parameters:</p><div class="codesample"><table><tr><td scope="row"><pre>objc_msgSend(receiver, selector)<span></span></pre></td></tr></table></div><p>Any arguments<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_199"></a> passed in the message are also handed to <code>objc_msgSend</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>objc_msgSend(receiver, selector, arg1, arg2, ...)<span></span></pre></td></tr></table></div><p>The messaging function does everything necessary for dynamic binding:</p><ul class="ul"><li class="li"><p>It first finds the procedure (method implementation) that the selector<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_200"></a> refers to. Since the same method can be implemented differently by separate classes, the precise procedure that it finds depends on the class of the receiver.</p></li><li class="li"><p>It then calls the procedure, passing it the receiving object (a pointer to its data), along with any arguments that were specified for the method.</p></li><li class="li"><p>Finally, it passes on the return value of the procedure as its own return value.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH7-SW14" title="Note"></a><p><strong>Note:</strong>&nbsp;The compiler generates calls to the messaging function. You should never call it directly in the code you write.</p></div><p>The key to messaging lies in the structures that the compiler builds for each class and object. Every class structure includes these two essential elements:</p><ul class="ul"><li class="li"><p>A pointer to the superclass.</p></li><li class="li"><p>A class <strong>dispatch table</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_201"></a>. This table has entries that associate method selectors with the class-specific addresses of the methods they identify. The selector for the <code>setOrigin::</code> method is associated with the address of (the procedure that implements) <code>setOrigin::</code>, the selector for the <code>display</code> method is associated with <code>display</code>’s address, and so on.</p></li></ul><p>When a new object is created, memory for it is allocated, and its instance variables are initialized. First among the object’s variables is a pointer to its class structure. This pointer, called <code>isa</code>, gives the object access to its class and, through the class, to all the classes it inherits from.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH7-SW15" title="Note"></a><p><strong>Note:</strong>&nbsp;While not strictly a part of the language, the <code>isa</code> pointer is required for an object to work with the Objective-C runtime system. An object needs to be “equivalent” to a <code>struct objc_object</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_202"></a> (defined in <code>objc/objc.h</code>) in whatever fields the structure defines. However, you rarely, if ever, need to create your own root object, and objects that inherit from <code>NSObject</code> or <code>NSProxy</code> automatically have the <code>isa</code> variable.</p></div><p>These elements of class and object structure are illustrated in <span class="content_text">Figure 1-5</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH7-89042" title="Figure 1-5Messaging Framework"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-CJBFGABC" title="Figure 1-5Messaging Framework"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>Messaging Framework</p><img src = "../Art/messaging1.gif" alt = "" width="332" height="544"></div><br/><p>When a message is sent to an object, the messaging function follows the object’s <code>isa</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_203"></a> pointer to the class structure where it looks up the method selector in the dispatch table. If it can’t find the selector there, <code>objc_msgSend</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_204"></a> follows the pointer to the superclass and tries to find the selector in its dispatch table. Successive failures cause <code>objc_msgSend</code> to climb the class hierarchy until it reaches the <code>NSObject</code> class. Once it locates the selector, the function calls the method entered in the table and passes it the receiving object’s data structure.</p><p>This is the way that method implementations are chosen at runtime—or, in the jargon of object-oriented programming, that methods are dynamically bound to messages.</p><p>To speed the messaging process, the runtime system caches the selectors and addresses of methods as they are used. There’s a separate cache for each class, and it can contain selectors for inherited methods as well as for methods defined in the class. Before searching the dispatch tables, the messaging routine first checks the cache of the receiving object’s class (on the theory that a method that was used once may likely be used again). If the method selector is in the cache, messaging is only slightly slower than a function call. Once a program has been running long enough to “warm up” its caches, almost all the messages it sends find a cached method. Caches grow dynamically to accommodate new messages as the program runs.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-173190" title="Selectors"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF128" title="Selectors"></a><h3>Selectors</h3><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_205"></a>For efficiency, full ASCII names are not used as method selectors in compiled code. Instead, the compiler writes each method name into a table, then pairs the name with a unique identifier that represents the method at runtime. The runtime system makes sure each identifier is unique: No two selectors are the same, and all methods with the same name have the same selector. Compiled selectors are assigned to a special type, <code>SEL</code>, to distinguish them from other data. Valid selectors are never 0. You must let the system assign <code>SEL</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_206"></a> identifiers to methods; it’s futile to assign them arbitrarily.</p><p>The <code>@selector()</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_207"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_208"></a> directive lets Objective-C source code refer to the compiled selector, rather than to the full method name. Here, the selector for <code>setWidth:height:</code> is assigned to the <code>setWidthHeight</code> variable:</p><div class="codesample"><table><tr><td scope="row"><pre>SEL  setWidthHeight;<span></span></pre></td></tr><tr><td scope="row"><pre>setWidthHeight = @selector(setWidth:height:);<span></span></pre></td></tr></table></div><p>It’s most efficient to assign values to <code>SEL</code> variables at compile time with the <code>@selector()</code> directive. However, in some cases, a program may need to convert a character string to a selector at runtime. This can be done with the <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSSelectorFromString" target="_top">NSSelectorFromString</a></code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_209"></a> function:</p><div class="codesample"><table><tr><td scope="row"><pre>setWidthHeight = NSSelectorFromString(aBuffer);<span></span></pre></td></tr></table></div><p>Conversion in the opposite direction is also possible. The <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSStringFromSelector" target="_top">NSStringFromSelector</a></code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_210"></a> function returns a method name for a selector:</p><div class="codesample"><table><tr><td scope="row"><pre>NSString *method;<span></span></pre></td></tr><tr><td scope="row"><pre>method = NSStringFromSelector(setWidthHeight);<span></span></pre></td></tr></table></div><p>These and other runtime functions are described in the Cocoa framework reference documentation.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_211"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-89196" title="Methods and Selectors"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF129" title="Methods and Selectors"></a><h4>Methods and Selectors</h4><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_212"></a><p>Compiled selectors identify method names, not method implementations. Rectangle’s <code>display</code> method, for example, has the same selector<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_213"></a> as <code>display</code> methods defined in other classes. This is essential for polymorphism and dynamic binding; it lets you send the same message to receivers belonging to different classes. If there were one selector per method implementation, a message would be no different than a function call.</p><p>A class method<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_214"></a> and an instance method with the same name are assigned the same selector. However, because of their separate domains, there’s no confusion between the two. A class could define a <code>display</code> class method in addition to a <code>display</code> instance method.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-89231" title="Method Return and Argument Types"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF130" title="Method Return and Argument Types"></a><h4>Method Return and Argument Types</h4><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_215"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_216"></a><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_217"></a>The messaging routine has access to method implementations only through selectors, so it treats all methods with the same selector alike. It discovers the return type of a method, and the data types of its arguments, from the selector. Therefore, except for messages sent to statically typed receivers, dynamic binding requires all implementations of identically named methods to have the same return type and the same argument types. (Statically typed receivers are an exception to this rule, since the compiler can learn about the method implementation from the class type.)</p><p>Although identically named class methods and instance methods are represented by the same selector, they can have different argument and return types.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_218"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-89250" title="Varying the Message at Runtime"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF131" title="Varying the Message at Runtime"></a><h4>Varying the Message at Runtime</h4><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_219"></a><p>The <code>performSelector:</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_220"></a>, <code>performSelector:withObject:</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_221"></a>, and <code>performSelector:withObject:withObject:</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_222"></a> methods, defined in the <code>NSObject</code> protocol, take <code>SEL</code> identifiers as their initial arguments. All three methods map directly into the messaging function. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>[friend performSelector:@selector(gossipAbout:)<span></span></pre></td></tr><tr><td scope="row"><pre>    withObject:aNeighbor];<span></span></pre></td></tr></table></div><p>is equivalent to:</p><div class="codesample"><table><tr><td scope="row"><pre>[friend gossipAbout:aNeighbor];<span></span></pre></td></tr></table></div><p>These methods make it possible to vary a message at runtime, just as it’s possible to vary the object that receives the message. Variable names can be used in both halves of a message expression:</p><div class="codesample"><table><tr><td scope="row"><pre>id   helper = getTheReceiver();<span></span></pre></td></tr><tr><td scope="row"><pre>SEL  request = getTheSelector();<span></span></pre></td></tr><tr><td scope="row"><pre>[helper performSelector:request];<span></span></pre></td></tr></table></div><p>In this example, the receiver (<code>helper</code>) is chosen at runtime (by the fictitious <code>getTheReceiver</code> function), and the method the receiver is asked to perform (<code>request</code>) is also determined at runtime (by the equally fictitious <code>getTheSelector</code> function).</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH7-SW16" title="Note"></a><p><strong>Note:</strong>&nbsp;<code>performSelector:</code> and its companion methods return an <code>id</code>. If the method that’s performed returns a different type, it should be cast to the proper type. (However, casting doesn’t work for all types; the method should return a pointer or a type compatible with a pointer.)</p></div><a name="//apple_ref/doc/uid/TP40005191-CH7-89387" title="The Target-Action Paradigm"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF132" title="The Target-Action Paradigm"></a><h4>The Target-Action Paradigm</h4><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_223"></a>In its treatment of user-interface controls, the Application Kit makes good use of the ability to vary both the receiver and the message.</p><p><code>NSControl</code> objects are graphical devices that can be used to give instructions to an application. Most resemble real-world control devices such as buttons, switches, knobs, text fields, dials, menu items, and the like. In software, these devices stand between the application and the user. They interpret events coming from hardware devices like the keyboard and mouse and translate them into application-specific instructions. For example, a button labeled “Find” would translate a mouse click into an instruction for the application to start searching for something.</p><p>The Application Kit defines a template for creating control devices and defines a few “off-the-shelf” devices of its own. For example, the <code>NSButtonCell</code> class defines an object that you can assign to an <code>NSMatrix</code> instance and initialize with a size, a label, a picture, a font, and a keyboard alternative. When the user clicks the button (or uses the keyboard alternative), the <code>NSButtonCell</code> object sends a message instructing the application to do something. To do this, an <code>NSButtonCell</code> object must be initialized not just with an image, a size, and a label, but with directions on what message to send and who to send it to. Accordingly, an <code>NSButtonCell</code> instance can be initialized for an action<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_224"></a> message, the method selector it should use in the message it sends, and a target<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_225"></a>, the object that should receive the message.</p><div class="codesample"><table><tr><td scope="row"><pre>[myButtonCell setAction:@selector(reapTheWind:)];<span></span></pre></td></tr><tr><td scope="row"><pre>[myButtonCell setTarget:anObject];<span></span></pre></td></tr></table></div><p>The button cell sends the message using <code>NSObject</code>’s <code>performSelector:withObject:</code> method. All action messages take a single argument, the <code>id</code> of the control device sending the message.</p><p>If Objective-C didn’t allow the message to be varied, all <code>NSButtonCell</code> objects would have to send the same message; the name of the method would be frozen in the <code>NSButtonCell</code> source code. Instead of simply implementing a mechanism for translating user actions into action messages, button cells and other controls would have to constrain the content of the message. This would make it difficult for any object to respond to more than one button cell. There would either have to be one target for each button, or the target object would have to discover which button the message came from and act accordingly. Each time you rearranged the user interface, you would also have to re-implement the method that responds to the action message. This would be an unnecessary complication that Objective-C happily avoids.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_226"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-89447" title="Avoiding Messaging Errors"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF133" title="Avoiding Messaging Errors"></a><h4>Avoiding Messaging Errors</h4><p>If an object receives a message<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_227"></a> to perform a method that isn’t in its repertoire, an error results. It’s the same sort of error as calling a nonexistent function. But because messaging occurs at runtime, the error often isn’t evident until the program executes.</p><p>It’s relatively easy to avoid this error when the message selector is constant and the class of the receiving object is known. As you write your programs, you can make sure that the receiver is able to respond. If the receiver is statically typed, the compiler performs this test for you.</p><p>However, if the message selector<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_228"></a> or the class of the receiver varies, it may be necessary to postpone this test until runtime. The <code>respondsToSelector:</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_229"></a> method, defined in the <code>NSObject</code> class, determines whether a receiver can respond to a message. It takes the method selector as an argument and returns whether the receiver has access to a method matching the selector:</p><div class="codesample"><table><tr><td scope="row"><pre>if ( [anObject respondsToSelector:@selector(setOrigin::)] )<span></span></pre></td></tr><tr><td scope="row"><pre>    [anObject setOrigin:0.0 :0.0];<span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>    fprintf(stderr, "%s can’t be placed\n",<span></span></pre></td></tr><tr><td scope="row"><pre>        [NSStringFromClass([anObject class]) UTF8String]);<span></span></pre></td></tr></table></div><p>The <code>respondsToSelector:</code> test is especially important when sending messages to objects that you don’t have control over at compile time. For example, if you write code that sends a message to an object represented by a variable that others can set, you should make sure the receiver implements a method that can respond to the message.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_230"></a></p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH7-SW17" title="Note"></a><p><strong>Note:</strong>&nbsp;An object can also arrange to have the messages it receives forwarded to other objects if it can’t respond to them directly itself. In that case, it appears that the object can handle the message, even though the object responds to the message indirectly by assigning it to another object. See <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-87022">“Forwarding”</a></span> for more information.</p></div><a name="//apple_ref/doc/uid/TP40005191-CH7-89536" title="Hidden Arguments"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF134" title="Hidden Arguments"></a><h3>Hidden Arguments</h3><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_231"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_232"></a><p>When the messaging function finds the procedure that implements a method, it calls the procedure and passes it all the arguments in the message. It also passes the procedure two hidden arguments:</p><ul class="spaceabove"><li class="li"><p>The receiving object</p></li><li class="li"><p>The selector<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_233"></a> for the method</p></li></ul><p>These arguments give every method implementation explicit information about the two halves of the message expression that invoked it. They’re said to be “hidden” because they aren’t declared in the source code that defines the method. They’re inserted into the implementation when the code is compiled.</p><p>Although these arguments aren’t explicitly declared, source code can still refer to them (just as it can refer to the receiving object’s instance variables). A method refers to the receiving object as <code>self</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_234"></a>, and to its own selector as <code>_cmd</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_235"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_236"></a>. In the example below, <code>_cmd</code> refers to the selector for the <code>strange</code> method and <code>self</code> to the object that receives a <code>strange</code> message.</p><div class="codesample"><table><tr><td scope="row"><pre>- strange<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    id  target = getTheReceiver();<span></span></pre></td></tr><tr><td scope="row"><pre>    SEL method = getTheMethod();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( target == self || method == _cmd )<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    return [target performSelector:method];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><code>self</code> is the more useful of the two arguments. It is, in fact, the way the receiving object’s instance variables are made available to the method definition.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-89660" title="Messages to self and super"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BAJHDGAC" title="Messages to self and super"></a><h3>Messages to self and super</h3><p>Objective-C provides two terms that can be used within a method definition to refer to the object that performs the method—<code>self</code> and <code>super</code>.</p><p>Suppose, for example, that you define a <code>reposition</code> method that needs to change the coordinates of whatever object it acts on. It can invoke the <code>setOrigin::</code> method to make the change. All it needs to do is send a <code>setOrigin::</code> message to the same object that the <code>reposition</code> message itself was sent to. When you’re writing the reposition code, you can refer to that object as either <code>self</code> or <code>super</code>. The <code>reposition</code> method could read either:</p><div class="codesample"><table><tr><td scope="row"><pre>- reposition<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setOrigin:someX :someY];<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>or:</p><div class="codesample"><table><tr><td scope="row"><pre>- reposition<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    [super setOrigin:someX :someY];<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here, <code>self</code> and <code>super</code> both refer to the object receiving a <code>reposition</code> message, whatever object that may happen to be. The two terms are quite different, however. <code>self</code> is one of the hidden arguments that the messaging routine passes to every method; it’s a local variable that can be used freely within a method implementation, just as the names of instance variables can be. <code>super</code> is a term that substitutes for <code>self</code> only as the receiver in a message expression. As receivers, the two terms differ principally in how they affect the messaging process:</p><ul class="spaceabove"><li class="li"><p><code>self</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_237"></a> searches for the method implementation in the usual manner, starting in the dispatch table of the receiving object’s class. In the example above, it would begin with the class of the object receiving the reposition message.</p></li><li class="li"><p><code>super</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_238"></a> starts the search for the method implementation in a very different place. It begins in the superclass of the class that defines the method where <code>super</code> appears. In the example above, it would begin with the superclass of the class where reposition is defined.</p></li></ul><p>Wherever <code>super</code> receives a message, the compiler substitutes another messaging routine for the <code>objc_msgSend</code> function. The substitute routine looks directly to the superclass of the defining class—that is, to the superclass of the class sending the message to <code>super</code>—rather than to the class of the object receiving the message.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-89868" title="An Example"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF135" title="An Example"></a><h4>An Example</h4><p>The difference between <code>self</code> and <code>super</code> becomes clear in a hierarchy of three classes. Suppose, for example, that we create an object belonging to a class called Low. Low’s superclass is Mid; Mid’s superclass is High. All three classes define a method called <code>negotiate</code>, which they use for a variety of purposes. In addition, Mid defines an ambitious method called <code>makeLastingPeace</code>, which also has need of the <code>negotiate</code> method. This is illustrated in <span class="content_text">Figure 1-6</span>:</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH7-89905" title="Figure 1-6High, Mid, Low"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-CJBEEDHJ" title="Figure 1-6High, Mid, Low"></a><p><strong>Figure 1-6&nbsp;&nbsp;</strong>High, Mid, Low</p><img src = "../Art/highmidlow.gif" alt = "" width="198" height="431"></div><br/><p>We now send a message to our Low object to perform the <code>makeLastingPeace</code> method, and <code>makeLastingPeace</code>, in turn, sends a <code>negotiate</code> message to the same Low object. If source code calls this object <code>self</code>,</p><div class="codesample"><table><tr><td scope="row"><pre>- makeLastingPeace<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self negotiate];<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>the messaging routine finds the version of <code>negotiate</code> defined in Low, <code>self</code>’s class. However, if Mid’s source code calls this object <code>super</code>,</p><div class="codesample"><table><tr><td scope="row"><pre>- makeLastingPeace<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [super negotiate];<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>the messaging routine will find the version of <code>negotiate</code> defined in High. It ignores the receiving object’s class (Low) and skips to the superclass of Mid, since Mid is where <code>makeLastingPeace</code> is defined. Neither message finds Mid’s version of <code>negotiate</code>.</p><p>As this example illustrates, <code>super</code> provides a way to bypass a method that overrides another method. Here it enabled <code>makeLastingPeace</code> to avoid the Mid version of <code>negotiate</code> that redefined the original High version.</p><p>Not being able to reach Mid’s version of <code>negotiate</code> may seem like a flaw, but, under the circumstances, it’s right to avoid it:</p><ul class="spaceabove"><li class="li"><p> The author of the Low class intentionally overrode Mid’s version of <code>negotiate</code> so that instances of the Low class (and its subclasses) would invoke the redefined version of the method instead. The designer of Low didn’t want Low objects to perform the inherited method.</p></li><li class="li"><p> In sending the message to <code>super</code>, the author of Mid’s <code>makeLastingPeace</code> method intentionally skipped over Mid’s version of <code>negotiate</code> (and over any versions that might be defined in classes like Low that inherit from Mid) to perform the version defined in the High class. Mid’s designer wanted to use the High version of <code>negotiate</code> and no other.</p></li></ul><p>Mid’s version of <code>negotiate</code> could still be used, but it would take a direct message to a Mid instance to do it.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-90109" title="Using super"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF136" title="Using super"></a><h4>Using super</h4><p>Messages to <code>super</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_239"></a> allow method implementations to be distributed over more than one class. You can override an existing method to modify or add to it, and still incorporate the original method in the modification:</p><div class="codesample"><table><tr><td scope="row"><pre>- negotiate<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    return [super negotiate];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For some tasks, each class in the inheritance hierarchy can implement a method that does part of the job and passes the message on to <code>super</code> for the rest. The <code>init</code> method, which initializes a newly allocated instance, is designed to work like this. Each <code>init</code> method has responsibility for initializing<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_240"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_241"></a> the instance variables defined in its class. But before doing so, it sends an <code>init</code> message to <code>super</code> to have the classes it inherits from initialize their instance variables. Each version of <code>init</code> follows this procedure, so classes initialize their instance variables in the order of inheritance:</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)init<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [super init];<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>It’s also possible to concentrate core functionality in one method defined in a superclass, and have subclasses incorporate the method through messages to <code>super</code>. For example, every class method that creates an instance must allocate storage for the new object and initialize its <code>isa</code> pointer to the class structure. This is typically left to the <code>alloc</code> and <code>allocWithZone:</code> methods defined in the <code>NSObject</code> class. If another class overrides these methods (a rare case), it can still get the basic functionality by sending a message to <code>super</code>.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-90247" title="Redefining self"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF137" title="Redefining self"></a><h4>Redefining self</h4><p><code>super</code> is simply a flag to the compiler telling it where to begin searching for the method to perform; it’s used only as the receiver of a message. But <code>self</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_242"></a> is a variable name that can be used in any number of ways, even assigned a new value.</p><p>There’s a tendency to do just that in definitions of class methods. Class methods are often concerned not with the class object, but with instances of the class. For example, many class methods combine allocation and initialization of an instance, often setting up instance variable values at the same time. In such a method, it might be tempting to send messages to the newly allocated instance and to call the instance <code>self</code>, just as in an instance method. But that would be an error. <code>self</code> and <code>super</code> both refer to the receiving object—the object that gets a message telling it to perform the method. Inside an instance method, <code>self</code> refers to the instance; but inside a class method<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_243"></a>, <code>self</code> refers to the class object. This is an example of what not to do:</p><div class="codesample"><table><tr><td scope="row"><pre>+ (Rectangle *)rectangleOfColor:(NSColor *) color<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self = [[Rectangle alloc] init]; // BAD<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setColor:color];<span></span></pre></td></tr><tr><td scope="row"><pre>    return [self autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>To avoid confusion, it’s usually better to use a variable other than <code>self</code> to refer to an instance inside a class method:</p><div class="codesample"><table><tr><td scope="row"><pre>+ (id)rectangleOfColor:(NSColor *)color<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    id newInstance = [[Rectangle alloc] init]; // GOOD<span></span></pre></td></tr><tr><td scope="row"><pre>    [newInstance setColor:color];<span></span></pre></td></tr><tr><td scope="row"><pre>    return [newInstance autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In fact, rather than sending the <code>alloc</code> message to the class in a class method, it’s often better to send <code>alloc</code> to <code>self</code>. This way, if the class is subclassed, and the <code>rectangleOfColor:</code> message is received by a subclass, the instance returned will be the same type as the subclass (for example, the <code>array</code> method of <code>NSArray</code> is inherited by <code>NSMutableArray</code>).</p><div class="codesample"><table><tr><td scope="row"><pre>+ (id)rectangleOfColor:(NSColor *)color<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    id newInstance = [[self alloc] init]; // EXCELLENT<span></span></pre></td></tr><tr><td scope="row"><pre>    [newInstance setColor:color];<span></span></pre></td></tr><tr><td scope="row"><pre>    return [newInstance autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>See <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-105377">“Allocating, Initializing, and Deallocating Objects”</a></span> for more information about object allocation.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_244"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-95276" title="Extending Classes"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF138" title="Extending Classes"></a><h2>Extending Classes</h2><p>Class<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_245"></a> definitions are at the heart of Objective-C programming, but they’re not the only mechanism for structuring object definitions in Objective-C. This section discusses two other ways of declaring methods and associating them with a class:</p><ul class="ul"><li class="li"><p>Categories can compartmentalize a class definition or extend an existing one.</p></li><li class="li"><p>Protocols<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_246"></a> declare methods that can be implemented by any class.</p></li></ul><a name="//apple_ref/doc/uid/TP40005191-CH7-113647" title="Categories&acirc;&#128;&#148;Adding Methods to Existing Classes"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF139" title="Categories&acirc;&#128;&#148;Adding Methods to Existing Classes"></a><h3>Categories—Adding Methods to Existing Classes</h3><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_247"></a>You<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_248"></a> can add methods<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_249"></a> to a class by declaring them in an interface file under a category name and defining them in an implementation file under the same name. The category name indicates that the methods are additions to a class declared elsewhere, not a new class. You cannot, however, use a category to add additional instance variables to a class.</p><p>A category can be an alternative to a subclass. Rather than define a subclass to extend an existing class, through a category you can add methods to the class directly. For example, you could add categories to <code>NSArray</code> and other Cocoa classes. As in the case of a subclass, you don’t need source code for the class you’re extending.</p><p>The methods the category adds become part of the class type. For example, methods added to the <code>NSArray</code> class in a category are among the methods the compiler expects an <code>NSArray</code> instance to have in its repertoire. Methods added to the <code>NSArray</code> class in a subclass are not included in the <code>NSArray</code> type. (This matters only for statically typed objects, since static typing is the only way the compiler can know an object’s class.)</p><p>Category methods can do anything that methods defined in the class proper can do. At runtime, there’s no difference. The methods the category adds to the class are inherited by all the class’s subclasses, just like other methods.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-113675" title="Adding to a Class"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF140" title="Adding to a Class"></a><h4>Adding to a Class</h4><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_250"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_251"></a>The declaration of a category interface looks very much like a class interface declaration—except the category name is listed within parentheses after the class name and the superclass isn’t mentioned. Unless its methods don’t access any instance variables of the class, the category must import the interface file for the class it extends:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "ClassName.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface ClassName ( CategoryName )<span></span></pre></td></tr><tr><td scope="row"><pre>// method declarations<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>The implementation, as usual, imports its own interface. Assuming that the interface file is named after the category, a category implementation looks like this:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "CategoryName.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation ClassName ( CategoryName )<span></span></pre></td></tr><tr><td scope="row"><pre>// method definitions<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Note that a category can’t declare additional instance variables for the class; it includes only methods. However, all instance variables within the scope of the class are also within the scope<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_252"></a> of the category. That includes all instance variables declared by the class, even ones declared <code>@private</code>.</p><p>There’s no limit to the number of categories that you can add to a class, but each category name must be different, and each should declare and define a different set of methods.</p><p>The methods added in a category can be used to extend the functionality of the class or override methods the class inherits. A category can also override methods declared in the class interface. However, it cannot reliably override methods declared in another category of the same class. A category is not a substitute for a subclass. It’s best if categories don’t attempt to redefine methods that are explicitly declared in the class’s <code>@interface</code> section. Also note that a class can’t define the same method more than once.</p><p>When a category overrides an inherited method, the new version can, as usual, incorporate the inherited version through a message to <code>super</code>. But there’s no way for a category method to incorporate a method with the same name defined for the same class.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_253"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_254"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-113792" title="How Categories Are Used"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF141" title="How Categories Are Used"></a><h4>How Categories Are Used</h4><p>Categories<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_255"></a> can be used to extend classes defined by other implementors—for example, you can add methods to the classes defined in the Cocoa frameworks. The added methods are inherited by subclasses and are indistinguishable at runtime from the original methods of the class.</p><p>Categories can also be used to distribute the implementation of a new class into separate source files—for example, you could group the methods of a large class into several categories and put each category in a different file. When used like this, categories can benefit the development process in a number of ways:</p><ul class="spaceabove"><li class="li"><p>They provide a simple way of grouping related methods. Similar methods defined in different classes can be kept together in the same source file.</p></li><li class="li"><p>They simplify the management of a large class when several developers contribute to the class definition.</p></li><li class="li"><p>They let you achieve some of the benefits of incremental compilation for a very large class.</p></li><li class="li"><p>They can help improve locality of reference for commonly used methods.</p></li><li class="li"><p>They enable you to configure a class differently for separate applications, without having to maintain different versions of the same source code.</p></li></ul><p>Categories are also used to declare informal protocols, as discussed under <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-113922">“Protocols—Declaring Interfaces for Others to Implement.”</a></span></p><a name="//apple_ref/doc/uid/TP40005191-CH7-113849" title="Categories of the Root Class"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF142" title="Categories of the Root Class"></a><h4>Categories of the Root Class</h4><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_256"></a><p>A category can add methods to any class, including the root class<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_257"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_258"></a>. Methods added to <code>NSObject</code> become available to all classes that are linked to your code. While this can be useful at times, it can also be quite dangerous. Although it may seem that the modifications the category makes are well understood and of limited impact, inheritance gives them a wide scope. You may be making unintended changes to unseen classes; you may not know all the consequences of what you’re doing. Moreover, others who are unaware of your changes won’t understand what they’re doing.</p><p>In addition, there are two other considerations to keep in mind when implementing methods for the root class:</p><ul class="spaceabove"><li class="li"><p>Messages to <code>super</code> are invalid (there is no superclass).</p></li><li class="li"><p>Class objects<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_259"></a> can perform instance methods defined in the root class.</p></li></ul><p>Normally, class objects can perform only class methods. But instance methods defined in the root class are a special case. They define an interface to the runtime system that all objects inherit. Class objects are full-fledged objects and need to share the same interface.</p><p>This feature means that you need to take into account the possibility that an instance method you define in a category of the <code>NSObject</code> class might be performed not only by instances but by class objects as well. For example, within the body of the method, <code>self</code> might mean a class object as well as an instance. See the <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject" target="_top">NSObject</a></code> class specification in the Foundation framework reference for more information on class access to root instance methods.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_260"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-113922" title="Protocols&acirc;&#128;&#148;Declaring Interfaces for Others to Implement"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BAJJABHJ" title="Protocols&acirc;&#128;&#148;Declaring Interfaces for Others to Implement"></a><h3>Protocols—Declaring Interfaces for Others to Implement</h3><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_261"></a>Class and category interfaces declare methods that are associated with a particular class—mainly methods that the class implements. Informal and formal <strong>protocols</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_262"></a>, on the other hand, declare methods not associated with a class, but which any class, and perhaps many classes, might implement.</p><p>A protocol is simply a list of method declarations, unattached to a class definition. For example, these methods that report user actions on the mouse could be gathered into a protocol:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)mouseDown:(NSEvent *)theEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)mouseDragged:(NSEvent *)theEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)mouseUp:(NSEvent *)theEvent;<span></span></pre></td></tr></table></div><p>Any class that wanted to respond to mouse events could adopt the protocol and implement its methods.</p><p>Protocols free method declarations from dependency on the class hierarchy, so they can be used in ways that classes and categories cannot. Protocols list methods that are (or may be) implemented somewhere, but the identity of the class that implements them is not of interest. What is of interest is whether or not a particular class <strong>conforms</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_263"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_264"></a> to the protocol—whether it has implementations of the methods the protocol declares. Thus objects can be grouped into types not just on the basis of similarities due to the fact that they inherit from the same class, but also on the basis of their similarity in conforming to the same protocol. Classes in unrelated branches of the inheritance hierarchy might be typed alike because they conform to the same protocol.</p><p>Protocols can play a significant role in object-oriented design, especially where a project is divided among many implementors or it incorporates objects developed in other projects. Cocoa software uses them heavily to support interprocess communication through Objective-C messages.</p><p>However, an Objective-C program doesn’t need to use protocols. Unlike class definitions and message expressions, they’re optional. Some Cocoa frameworks use them; some don’t. It all depends on the task at hand.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-113992" title="When to Use Protocols"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF143" title="When to Use Protocols"></a><h4>When to Use Protocols</h4><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_265"></a>Protocols are useful in at least three situations:</p><ul class="spaceabove"><li class="li"><p>To declare methods that others are expected to implement</p></li><li class="li"><p>To declare the interface to an object while concealing its class</p></li><li class="li"><p>To capture similarities among classes that are not hierarchically related</p></li></ul><p>The following sections discuss these situations and the roles protocols can play.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-114029" title="Methods for Others to Implement"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF144" title="Methods for Others to Implement"></a><h5>Methods for Others to Implement</h5><p>If you know the class of an object, you can look at its interface declaration (and the interface declarations of the classes it inherits from) to find what messages it responds to. These declarations advertise the messages it can receive. Protocols provide a way for it to also advertise the messages it sends.</p><p>Communication works both ways; objects send messages as well as receive them. For example, an object might delegate responsibility for a certain operation to another object, or it may on occasion simply need to ask another object for information. In some cases, an object might be willing to notify other objects of its actions so that they can take whatever collateral measures might be required.</p><p>If you develop the class of the sender and the class of the receiver as part of the same project (or if someone else has supplied you with the receiver and its interface file), this communication is easily coordinated. The sender simply imports the interface file of the receiver. The imported file declares the method selectors the sender uses in the messages it sends.</p><p>However, if you develop an object that sends messages to objects that aren’t yet defined—objects that you’re leaving for others to implement—you won’t have the receiver’s interface file. You need another way to declare the methods you use in messages but don’t implement. A protocol serves this purpose. It informs the compiler about methods the class uses and also informs other implementors of the methods they need to define to have their objects work with yours.</p><p>Suppose, for example, that you develop an object that asks for the assistance of another object by sending it <code>helpOut:</code> and other messages. You provide an <code>assistant</code> instance variable to record the outlet for these messages and define a companion method to set the instance variable. This method lets other objects register themselves as potential recipients of your object’s messages:</p><div class="codesample"><table><tr><td scope="row"><pre>- setAssistant:anObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    assistant = anObject;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Then, whenever a message is to be sent to the <code>assistant</code>, a check is made to be sure that the receiver implements a method that can respond:</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)doWork<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( [assistant respondsTo:@selector(helpOut:)] ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [assistant helpOut:self];<span></span></pre></td></tr><tr><td scope="row"><pre>        return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return NO;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Since, at the time you write this code, you can’t know what kind of object might register itself as the <code>assistant</code>, you can only declare a protocol for the <code>helpOut:</code> method; you can’t import the interface file of the class that implements it.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-114174" title="Declaring Interfaces for Anonymous Objects"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF145" title="Declaring Interfaces for Anonymous Objects"></a><h5>Declaring Interfaces for Anonymous Objects</h5><p>A protocol can be used to declare the methods of an <strong>anonymous object</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_266"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_267"></a>, an object of unknown class. An anonymous object may represent a service or handle a limited set of functions, especially where only one object of its kind is needed. (Objects that play a fundamental role in defining an application’s architecture and objects that you must initialize before using are not good candidates for anonymity.)</p><p>Objects are not anonymous to their developers, of course, but they are anonymous when the developer supplies them to someone else. For example, consider the following situations:</p><ul class="spaceabove"><li class="li"><p>Someone who supplies a framework or a suite of objects for others to use can include objects that are not identified by a class name or an interface file. Lacking the name and class interface, users have no way of creating instances of the class. Instead, the supplier must provide a ready-made instance. Typically, a method in another class returns a usable object:</p><div class="codesample"><table><tr><td scope="row"><pre>id formatter = [receiver formattingService];<span></span></pre></td></tr></table></div><p>The object returned by the method is an object without a class identity, at least not one the supplier is willing to reveal. For it to be of any use at all, the supplier must be willing to identify at least some of the messages that it can respond to. This is done by associating the object with a list of methods declared in a protocol.</p></li><li class="li"><p>You can send Objective-C messages to <strong>remote objects</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_268"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_269"></a>—objects in other applications. (<span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-103647">“Remote Messaging,”</a></span> discusses this possibility in more detail.)</p><p>Each application has its own structure, classes, and internal logic. But you don’t need to know how another application works or what its components are to communicate with it. As an outsider, all you need to know is what messages you can send (the protocol) and where to send them (the receiver).</p><p>An application that publishes one of its objects as a potential receiver of remote messages must also publish a protocol declaring the methods the object will use to respond to those messages. It doesn’t have to disclose anything else about the object. The sending application doesn’t need to know the class of the object or use the class in its own design. All it needs is the protocol.</p></li></ul><p>Protocols make anonymous objects possible. Without a protocol, there would be no way to declare an interface to an object without identifying its class.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH7-SW18" title="Note"></a><p><strong>Note:</strong>&nbsp;Even though the supplier of an anonymous object doesn’t reveal its class, the object itself reveals it at runtime. A class message returns the anonymous object’s class. However, there’s usually little point in discovering this extra information; the information in the protocol is sufficient.</p></div><a name="//apple_ref/doc/uid/TP40005191-CH7-173878" title="Non-Hierarchical Similarities"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF146" title="Non-Hierarchical Similarities"></a><h5>Non-Hierarchical Similarities</h5><p>If more than one class implements a set of methods, those classes are often grouped under an abstract class<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_270"></a> that declares the methods they have in common. Each subclass may re-implement the methods in its own way, but the inheritance hierarchy and the common declaration in the abstract class captures the essential similarity between the subclasses.</p><p>However, sometimes it’s not possible to group common methods in an abstract class. Classes that are unrelated in most respects might nevertheless need to implement some similar methods. This limited similarity may not justify a hierarchical relationship. For example, many different kinds of classes might implement methods to facilitate reference counting (this is just an example, since the Foundation Framework already implements reference counting for you):</p><div class="codesample"><table><tr><td scope="row"><pre>- setRefCount:(int)count;<span></span></pre></td></tr><tr><td scope="row"><pre>- (int)refCount;<span></span></pre></td></tr><tr><td scope="row"><pre>- incrementCount;<span></span></pre></td></tr><tr><td scope="row"><pre>- decrementCount;<span></span></pre></td></tr></table></div><p>These methods could be grouped into a protocol and the similarity between implementing classes accounted for by noting that they all conform to the same protocol.</p><p>Objects can be typed by this similarity (the protocols they conform to), rather than by their class. For example, an <code>NSMatrix</code> instance must communicate with the objects that represent its cells. The matrix could require each of these objects to be a kind of <code>NSCell</code> (a type based on class) and rely on the fact that all objects that inherit from the <code>NSCell</code> class have the methods needed to respond to <code>NSMatrix</code> messages. Alternatively, the <code>NSMatrix</code> object could require objects representing cells to have methods that can respond to a particular set of messages (a type based on protocol). In this case, the <code>NSMatrix</code> object wouldn’t care what class a cell object belonged to, just that it implemented the methods.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-114323" title="Informal Protocols "></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF147" title="Informal Protocols "></a><h5>Informal Protocols </h5><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_271"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_272"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_273"></a><p>The simplest way of declaring a protocol is to group the methods in a category<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_274"></a> declaration:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface NSObject ( RefCounting )<span></span></pre></td></tr><tr><td scope="row"><pre>- (int)refCount;<span></span></pre></td></tr><tr><td scope="row"><pre>- incrementCount;<span></span></pre></td></tr><tr><td scope="row"><pre>- decrementCount;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Informal protocols are typically declared as categories<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_275"></a> of the <code>NSObject</code> class, since that broadly associates the method names with any class that inherits from <code>NSObject</code>. Because all classes inherit from the root class, the methods aren’t restricted to any part of the inheritance hierarchy. (It would also be possible to declare an informal protocol as a category of another class to limit it to a certain branch of the inheritance hierarchy, but there is little reason to do so.)</p><p>When used to declare a protocol, a category interface doesn’t have a corresponding implementation. Instead, classes that implement the protocol declare the methods again in their own interface files and define them along with other methods in their implementation files.</p><p>An informal protocol bends the rules of category declarations to list a group of methods but not associate them with any particular class or implementation.</p><p>Being informal, protocols declared in categories don’t receive much language support. There’s no type checking at compile time nor a check at runtime to see whether an object conforms to the protocol. To get these benefits, you must use a formal protocol. An informal protocol is good for times when implementing all the methods is optional, such as for a delegate.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-114390" title="Formal Protocols"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF148" title="Formal Protocols"></a><h5>Formal Protocols</h5><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_276"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_277"></a><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_278"></a>The Objective-C language provides a way to formally declare a list of methods as a protocol. Formal protocols are supported by the language and the runtime system. For example, the compiler can check for types based on protocols, and objects can introspect at runtime to report whether or not they conform to a protocol.</p><p>Formal protocols are declared with the <code>@protocol</code> directive:</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol ProtocolName<span></span></pre></td></tr><tr><td scope="row"><pre>method declarations<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>For example, the reference-counting protocol could be declared like this:</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol ReferenceCounting<span></span></pre></td></tr><tr><td scope="row"><pre>- (int)refCount;<span></span></pre></td></tr><tr><td scope="row"><pre>- incrementCount;<span></span></pre></td></tr><tr><td scope="row"><pre>- decrementCount;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Unlike class names, protocol names don’t have global visibility. They live in their own namespace.</p><p>A class is said to <strong>adopt</strong><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_279"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_280"></a> a formal protocol if it agrees to implement the methods the protocol declares. Class declarations list the names of adopted protocols within angle brackets after the superclass name:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface ClassName : ItsSuperclass &lt; protocol list ><span></span></pre></td></tr></table></div><p>Categories adopt protocols in much the same way:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface ClassName ( CategoryName ) &lt; protocol list ><span></span></pre></td></tr></table></div><p>Names in the protocol list are separated by commas.</p><p>A class or category that adopts a protocol must import the header file where the protocol is declared. The methods declared in the adopted protocol are not declared elsewhere in the class or category interface.</p><p>It’s possible for a class to simply adopt protocols and declare no other methods. For example, the following class declaration adopts the Formatting and Prettifying protocols, but declares no instance variables or methods of its own:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Formatter : NSObject &lt; Formatting, Prettifying ><span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>A class or category that adopts a protocol is obligated to implement all the methods the protocol declares. Otherwise, the compiler issues a warning. The Formatter class above would define all the methods declared in the two protocols it adopts, in addition to any it might have declared itself.</p><p>Adopting a protocol is similar in some ways to declaring a superclass. Both assign methods to the class. The superclass declaration assigns it inherited methods; the protocol assigns it methods declared in the protocol list.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_281"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_282"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-114567" title="Protocol Objects"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF149" title="Protocol Objects"></a><h5>Protocol Objects</h5><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_283"></a><p>Just as classes are represented at runtime by class objects and methods by selector codes, formal protocols are represented by a special data type—instances of the Protocol<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_284"></a> class. Source code that deals with a protocol (other than to use it in a type specification) must refer to the Protocol object.</p><p>In many ways, protocols are similar to class definitions. They both declare methods, and at runtime they’re both represented by objects—classes by class objects and protocols by Protocol objects. Like class objects, Protocol objects are created automatically from the definitions and declarations found in source code and are used by the runtime system. They’re not allocated and initialized in program source code.</p><p>Source code can refer to a Protocol object using the <code>@protocol()</code> directive—the same directive that declares a protocol, except that here it has a set of trailing parentheses. The parentheses enclose the protocol name:</p><div class="codesample"><table><tr><td scope="row"><pre>Protocol *counter = @protocol(ReferenceCounting);<span></span></pre></td></tr></table></div><p>This is the only way that source code can conjure up a Protocol object. Unlike a class name, a protocol name doesn’t designate the object—except inside <code>@protocol()</code>.</p><p>The compiler creates a Protocol object for each protocol declaration it encounters, but only if the protocol is also:</p><ul class="spaceabove"><li class="li"><p>Adopted by a class, or</p></li><li class="li"><p>Referred to somewhere in source code (using <code>@protocol()</code>)</p></li></ul><p>Protocols that are declared but not used (except for type checking as described below) aren’t represented by Protocol objects at runtime.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-114645" title="Conforming to a Protocol"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF150" title="Conforming to a Protocol"></a><h5>Conforming to a Protocol</h5><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_285"></a><p>A class is said to <strong>conform</strong> to a formal protocol if it (or a superclass) implements the methods declared in the protocol. An instance of a class is said to conform to the same set of protocols its class conforms to.</p><p>Since a class must implement all the methods declared in the protocols it adopts, and those methods are inherited by its subclasses, saying that a class or an instance conforms to a protocol is tantamount to saying that it has in its repertoire all the methods the protocol declares.</p><p>It’s possible to check whether an object conforms to a protocol by sending it a <code>conformsToProtocol:</code> message.</p><div class="codesample"><table><tr><td scope="row"><pre>if ( [receiver conformsToProtocol:@protocol(ReferenceCounting)]  )<span></span></pre></td></tr><tr><td scope="row"><pre>    [receiver incrementCount];<span></span></pre></td></tr></table></div><p>The <code>conformsToProtocol:</code> test is very much like the <code>respondsTo:</code> test for a single method, except that it tests whether a protocol has been adopted (and presumably all the methods it declares implemented) rather than just whether one particular method has been implemented. Because it checks for a whole list of methods, <code>conformsToProtocol:</code> can be more efficient than <code>respondsTo:</code>.</p><p>The <code>conformsToProtocol:</code> test is also very much like the <code>isKindOfClass:</code> test, except that it tests for a type based on a protocol rather than a type based on the inheritance hierarchy.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-114729" title="Type Checking"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF151" title="Type Checking"></a><h5>Type Checking</h5><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_286"></a><p>Type declarations for objects can be extended to include formal protocols<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_287"></a>. Protocols thus offer the possibility of another level of type checking by the compiler, one that’s more abstract since it’s not tied to particular implementations.</p><p>In a type declaration, protocol names are listed between angle brackets after the type name:</p><div class="codesample"><table><tr><td scope="row"><pre>- (id &lt;Formatting>)formattingService;<span></span></pre></td></tr><tr><td scope="row"><pre>id &lt;ReferenceCounting, AutoFreeing> anObject;<span></span></pre></td></tr></table></div><p>Just as static typing permits the compiler to test for a type based on the class hierarchy, this syntax permits the compiler to test for a type based on conformance to a protocol.</p><p>For example, if Formatter is an abstract class, this declaration</p><div class="codesample"><table><tr><td scope="row"><pre>Formatter *anObject;<span></span></pre></td></tr></table></div><p>groups all objects that inherit from Formatter into a type and permits the compiler to check assignments against that type.</p><p>Similarly, this declaration,</p><div class="codesample"><table><tr><td scope="row"><pre>id &lt;Formatting> anObject;<span></span></pre></td></tr></table></div><p>groups all objects that conform to the Formatting protocol into a type, regardless of their positions in the class hierarchy. The compiler can make sure only objects that conform to the protocol are assigned to the type.</p><p>In each case, the type groups similar objects—either because they share a common inheritance, or because they converge on a common set of methods.</p><p>The two types can be combined in a single declaration:</p><div class="codesample"><table><tr><td scope="row"><pre>Formatter &lt;Formatting> *anObject;<span></span></pre></td></tr></table></div><p>Protocols can’t be used to type class objects. Only instances can be statically typed to a protocol, just as only instances can be statically typed to a class. (However, at runtime, both classes and instances will respond to a <code>conformsToProtocol:</code> message.)</p><a name="//apple_ref/doc/uid/TP40005191-CH7-114849" title="Protocols Within Protocols"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF152" title="Protocols Within Protocols"></a><h5>Protocols Within Protocols</h5><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_288"></a>One protocol can incorporate other protocols using the same syntax that classes use to adopt<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_289"></a> a protocol:</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol ProtocolName &lt; protocol list ><span></span></pre></td></tr></table></div><p>All the protocols listed between angle brackets are considered part of the <em>ProtocolName</em> protocol. For example, if the Paging protocol incorporates the Formatting protocol,</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol Paging &lt; Formatting ><span></span></pre></td></tr></table></div><p>any object that conforms<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_290"></a> to the Paging protocol also conforms to Formatting. Type declarations</p><div class="codesample"><table><tr><td scope="row"><pre>id &lt;Paging> someObject;<span></span></pre></td></tr></table></div><p>and <code>conformsToProtocol:</code> messages</p><div class="codesample"><table><tr><td scope="row"><pre>if ( [anotherObject conformsToProtocol:@protocol(Paging)] )<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><p>need to mention only the Paging protocol to test for conformance to Formatting as well.</p><p>When a class adopts a protocol, it must implement the methods the protocol declares, as mentioned earlier. In addition, it must conform to any protocols the adopted protocol incorporates. If an incorporated protocol incorporates still other protocols, the class must also conform to them. A class can conform to an incorporated protocol by either:</p><ul class="spaceabove"><li class="li"><p>Implementing the methods the protocol declares, or</p></li><li class="li"><p>Inheriting from a class that adopts the protocol and implements the methods.</p></li></ul><p>Suppose, for example, that the Pager class adopts the Paging protocol. If Pager is a subclass of <code>NSObject</code>, </p><div class="codesample"><table><tr><td scope="row"><pre>@interface Pager : NSObject &lt; Paging ><span></span></pre></td></tr></table></div><p>it must implement all the Paging methods, including those declared in the incorporated Formatting protocol. It adopts the Formatting protocol along with Paging.</p><p>On the other hand, if Pager is a subclass of Formatter (a class that independently adopts the Formatting protocol),</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Pager : Formatter &lt; Paging ><span></span></pre></td></tr></table></div><p>it must implement all the methods declared in the Paging protocol proper, but not those declared in Formatting. Pager inherits conformance to the Formatting protocol from Formatter.</p><p>Note that a class can conform to a protocol without formally adopting it simply by implementing the methods declared in the protocol.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_291"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-115018" title="Referring to Other Protocols"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF153" title="Referring to Other Protocols"></a><h5>Referring to Other Protocols</h5><p>When working on complex applications, you occasionally find yourself writing code that looks like this:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "B.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@protocol A<span></span></pre></td></tr><tr><td scope="row"><pre>- foo:(id &lt;B>)anObject;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>where protocol B is declared like this:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "A.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@protocol B<span></span></pre></td></tr><tr><td scope="row"><pre>- bar:(id &lt;A>)anObject;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>In such a situation, circularity results and neither file will compile correctly. To break this recursive cycle, you must use the <code>@protocol</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_292"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_293"></a> directive to make a forward reference<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_294"></a> to the needed protocol instead of importing the interface file where the protocol is defined. The following code excerpt illustrates how you would do this:</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol B;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@protocol A<span></span></pre></td></tr><tr><td scope="row"><pre>- foo:(id &lt;B>)anObject;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Note that using the <code>@protocol</code> directive in this manner simply informs the compiler that “B” is a protocol to be defined later. It doesn’t import the interface file where protocol B is defined.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_295"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_296"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-93398" title="Enabling Static Behaviors"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BAJIFIHG" title="Enabling Static Behaviors"></a><h2>Enabling Static Behaviors</h2><p>This section explains how static typing works and discusses some other features of Objective-C, including ways to temporarily overcome its inherent dynamism.</p><p>Objective-C objects are dynamic entities. As many decisions about them as possible are pushed from compile time to runtime:</p><ul class="ul"><li class="li"><p>The memory for objects<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_297"></a> is <strong>dynamically allocated</strong> at runtime by class methods that create new instances.</p></li><li class="li"><p>Objects are <strong>dynamically typed</strong>. In source code (at compile time), any object pointer can be of type <code>id</code> no matter what the object’s class is. The exact class of an <code>id</code> variable (and therefore its particular methods and data structure) isn’t determined until the program runs.</p></li><li class="li"><p>Messages and methods are <strong>dynamically bound</strong>, as described under <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-88846">“How Messaging Works.”</a></span> A runtime procedure matches the method selector in the message to a method implementation that “belongs to” the receiver.</p></li></ul><p>These features give object-oriented programs a great deal of flexibility and power, but there’s a price to pay. Messages are somewhat slower than function calls, for example, (though not much slower due to the efficiency of the runtime system) and the compiler can’t check the exact types (classes) of <code>id</code> variables.</p><p>To permit better compile-time type checking<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_298"></a>, and to make code more self-documenting, Objective-C allows objects to be statically typed with a class name rather than generically typed as <code>id</code>. It also lets you turn some of its object-oriented features off in order to shift operations from runtime back to compile time.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-93473" title="Static Typing"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF159" title="Static Typing"></a><h3>Static Typing</h3><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_299"></a><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_300"></a>If a pointer to a class name is used in place of <code>id</code> in an object declaration,</p><div class="codesample"><table><tr><td scope="row"><pre>Rectangle *thisObject;<span></span></pre></td></tr></table></div><p>the compiler restricts the value of the declared variable to be either an instance of the class named in the declaration or an instance of a class that inherits from the named class. In the example above, <code>thisObject</code> can only be a Rectangle of some kind.</p><p>Statically typed objects have the same internal data structures as objects declared to be <code>id</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_301"></a>s. The type doesn’t affect the object; it affects only the amount of information given to the compiler about the object and the amount of information available to those reading the source code.</p><p>Static typing also doesn’t affect how the object is treated at runtime. Statically typed objects are dynamically allocated by the same class methods that create instances of type <code>id</code>. If Square is a subclass of Rectangle, the following code would still produce an object with all the instance variables of a Square, not just those of a Rectangle:</p><div class="codesample"><table><tr><td scope="row"><pre>Rectangle *thisObject = [[Square alloc] init];<span></span></pre></td></tr></table></div><p>Messages<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_302"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_303"></a> sent to statically typed objects are dynamically bound, just as objects typed <code>id</code> are. The exact type of a statically typed receiver is still determined at runtime as part of the messaging process. A <code>display</code> message sent to <code>thisObject</code></p><div class="codesample"><table><tr><td scope="row"><pre>[thisObject display];<span></span></pre></td></tr></table></div><p>performs the version of the method defined in the Square class, not the one in its Rectangle superclass.</p><p>By giving the compiler more information about an object, static typing opens up possibilities that are absent for objects typed <code>id</code>:</p><ul class="spaceabove"><li class="li"><p>In certain situations, it allows for compile-time type checking.</p></li><li class="li"><p>It can free objects from the restriction that identically named methods must have identical return and argument types.</p></li><li class="li"><p>It permits you to use the structure pointer operator to directly access an object’s instance variables.</p></li></ul><p>The first two topics are discussed in the sections that follow. The third is covered in <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-139192">“Defining a Class.”</a></span></p><a name="//apple_ref/doc/uid/TP40005191-CH7-93615" title="Type Checking"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF160" title="Type Checking"></a><h4>Type Checking</h4><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_304"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_305"></a><p>With the additional information provided by static typing, the compiler can deliver better type-checking services in two situations:</p><ul class="spaceabove"><li class="li"><p>When a message is sent to a statically typed receiver, the compiler can make sure the receiver can respond. A warning is issued if the receiver doesn’t have access to the method named in the message.</p></li><li class="li"><p>When a statically typed object is assigned to a statically typed variable, the compiler makes sure the types are compatible. A warning is issued if they’re not.</p></li></ul><p>An assignment can be made without warning, provided the class of the object being assigned is identical to, or inherits from, the class of the variable receiving the assignment. The following example illustrates this:</p><div class="codesample"><table><tr><td scope="row"><pre>Shape     *aShape;<span></span></pre></td></tr><tr><td scope="row"><pre>Rectangle *aRect;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>aRect = [[Rectangle alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>aShape = aRect;<span></span></pre></td></tr></table></div><p>Here <code>aRect</code> can be assigned to <code>aShape</code> because a Rectangle is a kind of Shape—the Rectangle class inherits from Shape. However, if the roles of the two variables are reversed and <code>aShape</code> is assigned to <code>aRect</code>, the compiler generates a warning; not every Shape is a Rectangle. (For reference, see <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-86501">Figure 1-2</a></span>, which shows the class hierarchy including Shape and Rectangle.)</p><p>There’s no check when the expression on either side of the assignment operator is an <code>id</code>. A statically typed object can be freely assigned to an <code>id</code>, or an <code>id</code> to a statically typed object. Because methods like <code>alloc</code> and <code>init</code> return <code>id</code>s, the compiler doesn’t ensure that a compatible object is returned to a statically typed variable. The following code is error-prone, but is allowed nonetheless:</p><div class="codesample"><table><tr><td scope="row"><pre>Rectangle *aRect;<span></span></pre></td></tr><tr><td scope="row"><pre>aRect = [[Shape alloc] init];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40005191-CH7-93783" title="Return and Argument Types"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF161" title="Return and Argument Types"></a><h4>Return and Argument Types</h4><p>In general, methods<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_306"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_307"></a> in different classes that have the same selector (the same name) must also share the same return<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_308"></a> and argument types. This constraint is imposed by the compiler to allow dynamic binding<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_309"></a>. Because the class of a message receiver (and therefore class-specific details about the method it’s asked to perform), can’t be known at compile time, the compiler must treat all methods with the same name alike. When it prepares information on method return and argument types<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_310"></a> for the runtime system, it creates just one method description for each method selector.</p><p>However, when a message is sent to a statically typed object, the class of the receiver is known by the compiler. The compiler has access to class-specific information about the methods. Therefore, the message is freed from the restrictions on its return and argument types.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-93802" title="Static Typing to an Inherited Class"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF162" title="Static Typing to an Inherited Class"></a><h4>Static Typing to an Inherited Class</h4><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_311"></a><p>An instance can be statically typed to its own class or to any class that it inherits from. All instances, for example, can be statically typed as <code>NSObject</code>.</p><p>However, the compiler understands the class of a statically typed object only from the class name in the type designation, and it does its type checking accordingly. Typing an instance to an inherited class can therefore result in discrepancies between what the compiler thinks would happen at runtime and what actually happens.</p><p>For example, if you statically type a Rectangle instance as a Shape,</p><div class="codesample"><table><tr><td scope="row"><pre>Shape *myRect = [[Rectangle alloc] init];<span></span></pre></td></tr></table></div><p>the compiler will treat it as a Shape. If you send the object a message to perform a Rectangle method,</p><div class="codesample"><table><tr><td scope="row"><pre>BOOL solid = [myRect isFilled];<span></span></pre></td></tr></table></div><p>the compiler will complain. The <code>isFilled</code> method is defined in the Rectangle class, not in Shape.</p><p>However, if you send it a message to perform a method that the Shape class knows about,</p><div class="codesample"><table><tr><td scope="row"><pre>[myRect display];<span></span></pre></td></tr></table></div><p>the compiler won’t complain, even though Rectangle overrides the method. At runtime, Rectangle’s version of the method is performed.</p><p>Similarly, suppose that the Upper class declares a <code>worry</code> method that returns a <code>double</code>,</p><div class="codesample"><table><tr><td scope="row"><pre>- (double)worry;<span></span></pre></td></tr></table></div><p>and the Middle subclass of Upper overrides the method and declares a new return type:</p><div class="codesample"><table><tr><td scope="row"><pre>- (int)worry;<span></span></pre></td></tr></table></div><p>If an instance is statically typed to the Upper class, the compiler will think that its <code>worry</code> method returns a <code>double</code>, and if an instance is typed to the Middle class, it will think that <code>worry</code> returns an <code>int</code>. Errors will obviously result if a Middle instance is typed to the Upper class. The compiler will inform the runtime system that a <code>worry</code> message sent to the object returns a <code>double</code>, but at runtime it actually returns an <code>int</code> and generates an error.</p><p>Static typing can free identically named methods from the restriction that they must have identical return and argument types, but it can do so reliably only if the methods are declared in different branches of the class hierarchy.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_312"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-93972" title="Getting a Method Address"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF163" title="Getting a Method Address"></a><h3>Getting a Method Address</h3><p>The only way to circumvent dynamic binding is to get the address of a method<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_313"></a> and call it directly as if it were a function. This might be appropriate on the rare occasions when a particular method will be performed many times in succession and you want to avoid the overhead of messaging each time the method is performed.</p><p>With a method defined in the <code>NSObject</code> class, <code>methodForSelector:</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_314"></a>, you can ask for a pointer to the procedure that implements a method, then use the pointer to call the procedure. The pointer that <code>methodForSelector:</code> returns must be carefully cast to the proper function type. Both return and argument types should be included in the cast.</p><p>The example below shows how the procedure that implements the <code>setFilled:</code> method might be called:</p><div class="codesample"><table><tr><td scope="row"><pre>void (*setter)(id, SEL, BOOL);<span></span></pre></td></tr><tr><td scope="row"><pre>int i;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>setter = (void (*)(id, SEL, BOOL))[target<span></span></pre></td></tr><tr><td scope="row"><pre>    methodForSelector:@selector(setFilled:)];<span></span></pre></td></tr><tr><td scope="row"><pre>for ( i = 0; i &lt; 1000, i++ )<span></span></pre></td></tr><tr><td scope="row"><pre>    setter(targetList[i], @selector(setFilled:), YES);<span></span></pre></td></tr></table></div><p>The first two arguments passed to the procedure are the receiving object (<code>self</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_315"></a>) and the method selector (<code>_cmd</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_316"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_317"></a>). These arguments are hidden in method syntax but must be made explicit when the method is called as a function.</p><p>Using <code>methodForSelector:</code> to circumvent dynamic binding saves most of the time required by messaging. However, the savings will be significant only where a particular message is repeated many times, as in the <code>for</code> loop shown above.</p><p>Note that <code>methodForSelector:</code> is provided by the Cocoa runtime system; it’s not a feature of the Objective-C language itself.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-94086" title="Getting an Object Data Structure"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF164" title="Getting an Object Data Structure"></a><h3>Getting an Object Data Structure</h3><p>A fundamental tenet of object-oriented programming is that the data structure of<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_318"></a> an object<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_319"></a> is private to the object. Information stored there can be accessed only through messages sent to the object. Although it is generally considered a poor programming practice, there is a way to strip an object data structure of its “objectness” and treat it like any other C structure. This makes all the object’s instance variables publicly available.</p><p>When given a class name as an argument, the <code>@defs()</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_320"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_321"></a> directive produces the declaration list for an instance of the class. This list is useful only in declaring structures, so <code>@defs()</code> can appear only in the body of a structure declaration. This code, for example, declares a structure that’s identical to the template for an instance of the Worker class:</p><div class="codesample"><table><tr><td scope="row"><pre>struct workerDef {<span></span></pre></td></tr><tr><td scope="row"><pre>    @defs(Worker)<span></span></pre></td></tr><tr><td scope="row"><pre>} *public;<span></span></pre></td></tr></table></div><p>Here <code>public</code> is declared as a pointer to a structure that’s essentially indistinguishable from a Worker instance. With a little help from a type cast, a Worker <code>id</code> can be assigned to the pointer. The object’s instance variables<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_322"></a> can then be accessed publicly through the pointer:</p><div class="codesample"><table><tr><td scope="row"><pre>id aWorker;<span></span></pre></td></tr><tr><td scope="row"><pre>aWorker = [[Worker alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>public = (struct workerDef *)aWorker;<span></span></pre></td></tr><tr><td scope="row"><pre>public->boss = nil;<span></span></pre></td></tr></table></div><p>This technique of turning an object into a structure makes all its instance variables public, whether they are declared <code>@private</code>, <code>@protected</code>, or <code>@public</code>.</p><p>Objects generally aren’t designed with the expectation that they be turned into C structures. You may want to use <code>@defs()</code> for classes you define entirely yourself, but it should not be applied to classes found in a framework or to classes you define that inherit from framework classes.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-169825" title="Exception Handling and Thread Synchronization"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BCIFAFAI" title="Exception Handling and Thread Synchronization"></a><h2>Exception Handling and Thread Synchronization</h2><p>Objective-C provides support for exception handling and thread synchronization, which are explained in <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-171620">“Handling Exceptions”</a></span> and <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-171334">“Synchronizing Thread Execution.”</a></span> To turn on support for these features<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_323"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_324"></a>, use the <code>-fobjc-exceptions</code> switch of the GNU Compiler Collection (GCC) version 3.3 and later.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH7-SW19" title="Note"></a><p><strong>Note:</strong>&nbsp;Using either of these features in a program, renders the application runnable only in Mac OS X v10.3 and later<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_325"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_326"></a> because runtime support for exception handling and synchronization is not present in earlier versions of the software.</p></div><a name="//apple_ref/doc/uid/TP40005191-CH7-171620" title="Handling Exceptions"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BCIGHBBA" title="Handling Exceptions"></a><h3>Handling Exceptions</h3><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_327"></a>The Objective-C language has an exception-handling syntax similar to that of Java and C++. Coupled with the use of the <a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_328"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_329"></a><code>NSException</code>, <code>NSError</code>, or custom classes, you can add robust error-handling to your programs.</p><p>The exception support revolves around four compiler directives: <code>@try</code>, <code>@catch</code>, <code>@throw</code>, and <code>@finally</code>. Code that can potentially throw an exception is enclosed in a <code>@try</code> block. <code>@catch()</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_330"></a>blocks contain the exception-handling logic for exceptions thrown in a <code>@try</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_331"></a>block. A <code>@finally</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_332"></a>block contains code that must be executed whether an exception is thrown or not. You use the <code>@throw</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_333"></a>directive to throw an exception, which is essentially a pointer to an Objective-C object. You can use <a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_334"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_335"></a><code>NSException</code> objects but are not limited to them.</p><p>The example below depicts a simple exception-handling algorithm:</p><div class="codesample"><table><tr><td scope="row"><pre>Cup *cup = [[Cup alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@try {<span></span></pre></td></tr><tr><td scope="row"><pre>    [cup fill];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@catch (NSException *exception) {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"main: Caught %@: %@", [exception name], [exception  reason]);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@finally {<span></span></pre></td></tr><tr><td scope="row"><pre>    [cup release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40005191-CH7-171819" title="Throwing Exceptions"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF168" title="Throwing Exceptions"></a><h4>Throwing Exceptions</h4><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_336"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_337"></a>To throw an exception you must instantiate an object with the appropriate information, such as the exception name and the reason it was thrown.</p><div class="codesample"><table><tr><td scope="row"><pre>NSException *exception = [NSException exceptionWithName:@"HotTeaException"<span></span></pre></td></tr><tr><td scope="row"><pre>                            reason:@"The tea is too hot"  userInfo:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>@throw exception;<span></span></pre></td></tr></table></div><p>Inside a <code>@catch()</code> block, you can re-throw the caught exception using the <code>@throw</code> directive without an argument. This can help make your code more readable.</p><p>You can subclass <code>NSException</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_338"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_339"></a> to implement specialized types of exceptions, such as file-system exceptions or communications exceptions.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH7-SW20" title="Note"></a><p><strong>Note:</strong>&nbsp;You are not limited to throwing <code>NSException</code> objects. You can throw any Objective-C object as an exception object. The <code>NSException</code> class provides methods that help in exception processing, but you can implement your own if you so desire.</p></div><a name="//apple_ref/doc/uid/TP40005191-CH7-171873" title="Processing Exceptions"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF169" title="Processing Exceptions"></a><h4>Processing Exceptions</h4><p>To catch an exception thrown in a <code>@try</code> block, use one or more <code>@catch()</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_340"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_341"></a>blocks following the <code>@try</code> block. The <code>@catch()</code> blocks should be ordered from most-specific to the least-specific. That way you can tailor the processing of exceptions as groups, as shown in <span class="content_text">Listing 1-2</span>.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-171908" title="Listing 1-2An exception handler"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BCICHFFA" title="Listing 1-2An exception handler"></a><p class="codesample"><strong>Listing 1-2&nbsp;&nbsp;</strong>An exception handler</p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_342"></a><div class="codesample"><table><tr><td scope="row"><pre>@try {<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@catch (CustomException *ce) {  <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@catch (NSException *ne) {  <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    // Perform processing necessary at this level.<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Rethrow the exception so that it's handled at a higher level.<span></span></pre></td></tr><tr><td scope="row"><pre>    @throw;  <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@catch (id ue) {<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@finally {  <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    // Perform processing necessary whether an exception occurred  or not.<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The following list describes the numbered code-lines:</p><ol class="ol"><li class="li"><p>Catches the most specific exception type.</p></li><li class="li"><p>Catches a more general exception type.</p></li><li class="li"><p>Re-throws<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_343"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_344"></a> the exception caught.</p><p>To compartmentalize exception processing, you can <a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_345"></a>nest exception handlers in a program. That way if a method or function catches an exception that it cannot process, it can rethrow it to the next exception handler.</p></li><li class="li"><p>Performs any clean-up processing<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_346"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_347"></a> that must always be performed, whether exceptions were thrown or not.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_348"></a></p></li></ol><a name="//apple_ref/doc/uid/TP40005191-CH7-171334" title="Synchronizing Thread Execution"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BCIIGGHG" title="Synchronizing Thread Execution"></a><h3>Synchronizing Thread Execution</h3><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_349"></a>Objective-C supports multithreading in applications. This means that two threads can try to modify the same object at the same time, a situation that can cause serious problems in a program. To protect sections of code from being executed by more than one thread at a time, Objective-C provides the <code>@synchronized()</code> directive.</p><p>The <code>@synchronized()</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_350"></a>directive locks a section of code for use by a single thread. Other threads are blocked until the thread exits the protected code; that is, when execution continues past the last statement in the <code>@synchronized()</code> block.</p><p>The <code>@synchronized()</code> directive takes as its only argument any Objective-C object, including <code>self</code>. This object is known as a <em>mutual exclusion</em> semaphore or <em>mutex</em><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_351"></a>. It allows a thread to lock a section of code to prevent its use by other threads. You should use separate semaphores to protect different critical sections of a program. It’s safest to create all the mutual exclusion objects before the application becomes multithreaded to avoid race conditions.</p><p><span class="content_text">Listing 1-3</span> shows an example of code that uses <code>self</code> as the mutex to synchronize access to the instance methods of the current object. You can take a similar approach to synchronize the class methods of the associated class, using the Class object instead of <code>self</code>. In the latter case, of course, only one thread at a time is allowed to execute a class method because there is only one class object that is shared by all callers.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-203668" title="Listing 1-3Locking a method using self"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BBCDHBCG" title="Listing 1-3Locking a method using self"></a><p class="codesample"><strong>Listing 1-3&nbsp;&nbsp;</strong>Locking a method using <code>self</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (void)criticalMethod<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    @synchronized(self) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Critical code.<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 1-4</span> uses the current selector, <code>_cmd</code>, as the mutex. This kind of synchronization is beneficial only when the method being synchronized has a unique name. This is because no other object or class would be allowed to execute a different method with the same name until the current method ends.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-203769" title="Listing 1-4Locking a method using _cmd"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BBCGICHD" title="Listing 1-4Locking a method using _cmd"></a><p class="codesample"><strong>Listing 1-4&nbsp;&nbsp;</strong>Locking a method using _cmd</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)criticalMethod<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    @synchronized(NSStringFromSelector(_cmd)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Critical code.<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 1-5</span> shows a general approach. Before executing a critical process, the code obtains a semaphore from the Account class and uses it to lock the critical section. The Account class could create the semaphore in its <code>initialize</code> method.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-204000" title="Listing 1-5Locking a method using a custom semaphore"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BBCCAHEC" title="Listing 1-5Locking a method using a custom semaphore"></a><p class="codesample"><strong>Listing 1-5&nbsp;&nbsp;</strong>Locking a method using a custom semaphore</p><div class="codesample"><table><tr><td scope="row"><pre>Account *account = [Account accountFromString:[accountField stringValue]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Get the semaphore.<span></span></pre></td></tr><tr><td scope="row"><pre>id accountSemaphore = [Account semaphore];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@synchronized(accountSemaphore) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Critical code.<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The Objective-C synchronization feature supports recursive and reentrant code. A thread can use a single semaphore several times in a recursive manner; other threads are blocked from using it until the thread releases all the locks obtained with it; that is, every <code>@synchronized()</code> block is exited normally or through an exception.</p><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_352"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_353"></a>When code in an <code>@synchronized()</code> block throws an exception, the Objective-C runtime catches the exception, releases the semaphore (so that the protected code can be executed by other threads), and re-throws the exception to the next exception handler.<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_354"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH7-117015" title="Using C++ With Objective-C"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BCIDBAEA" title="Using C++ With Objective-C"></a><h2>Using C++ With Objective-C</h2><p><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_355"></a>Apple’s Objective-C compiler allows you to freely mix C++ and Objective-C code in the same source file. This Objective-C/C++ language hybrid is called Objective-C++<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_356"></a>. With it you can make use of existing C++ libraries from your Objective-C applications. Note that XCode requires that file names have a “.mm” extension for the Objective-C++ extensions to be enabled by the compiler.</p><p>Objective-C++ does not add C++ features to Objective-C classes, nor does it add Objective-C features to C++ classes. For example, you cannot use Objective-C syntax to call a C++ object, you cannot add constructors or destructors to an Objective-C object, and you cannot use the keywords <code>this</code> and <code>self</code> interchangeably. The class hierarchies are separate; a C++ class cannot inherit from an Objective-C class, and an Objective-C class cannot inherit from a C++ class. In addition, multi-language exception handling is not supported. That is, an exception thrown in Objective-C code cannot be caught in C++ code and, conversely, an exception thrown in C++ code cannot be caught in Objective-C code. For more information on exceptions in Objective-C, see <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-169825">“Exception Handling and Thread Synchronization.”</a></span></p><p>The next section discusses what you <em>can</em> do with Objective-C++.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-117041" title="Mixing Objective-C and C++ Language Features"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF166" title="Mixing Objective-C and C++ Language Features"></a><h3>Mixing Objective-C and C++ Language Features</h3><p>In Objective-C++, you can call methods from either language in C++ code and in Objective-C methods. Pointers to objects in either language are just pointers, and as such can be used anywhere. For example, you can include pointers to Objective-C objects as data members of C++ classes, and you can include pointers to C++ objects as instance variables of Objective-C classes. <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-117058">Listing 1-6</a></span> illustrates this. </p><a name="//apple_ref/doc/uid/TP40005191-CH7-117058" title="Listing 1-6Using C++ and Objective-C instances as instance variables"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-BCIFEHAB" title="Listing 1-6Using C++ and Objective-C instances as instance variables"></a><p class="codesample"><strong>Listing 1-6&nbsp;&nbsp;</strong>Using C++ and Objective-C instances as instance variables</p><div class="codesample"><table><tr><td scope="row"><pre>/* Hello.mm<span></span></pre></td></tr><tr><td scope="row"><pre> * Compile with: g++ -x objective-c++ -framework Foundation Hello.mm  -o hello<span></span></pre></td></tr><tr><td scope="row"><pre> */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre>class Hello {<span></span></pre></td></tr><tr><td scope="row"><pre>    private:<span></span></pre></td></tr><tr><td scope="row"><pre>        id _greeting_text;  // holds an NSString<span></span></pre></td></tr><tr><td scope="row"><pre>    public:<span></span></pre></td></tr><tr><td scope="row"><pre>        Hello() {<span></span></pre></td></tr><tr><td scope="row"><pre>            _greeting_text = @"Hello, world!";<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        Hello(const char* greeting_text) {<span></span></pre></td></tr><tr><td scope="row"><pre>            _greeting_text = [NSString stringWithUTF8String:greeting_text];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        void say_hello() {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("%s\n", [_greeting_text UTF8String]);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface Greeting : NSObject {<span></span></pre></td></tr><tr><td scope="row"><pre>    @private<span></span></pre></td></tr><tr><td scope="row"><pre>        Hello *_hello;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (id)init;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)dealloc;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)sayGreeting;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)sayGreeting:(Hello*)greeting;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation Greeting<span></span></pre></td></tr><tr><td scope="row"><pre>- (id)init {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self = [super init]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        _hello = new Hello();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)dealloc {<span></span></pre></td></tr><tr><td scope="row"><pre>    delete _hello;<span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)sayGreeting {<span></span></pre></td></tr><tr><td scope="row"><pre>    _hello->say_hello();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)sayGreeting:(Hello*)greeting {<span></span></pre></td></tr><tr><td scope="row"><pre>    greeting->say_hello();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main() {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Greeting *greeting = [[Greeting alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    [greeting sayGreeting];                         // > Hello,  world!<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Hello *hello = new Hello("Bonjour, monde!");<span></span></pre></td></tr><tr><td scope="row"><pre>    [greeting sayGreeting:hello];                   // > Bonjour,  monde!<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    delete hello;<span></span></pre></td></tr><tr><td scope="row"><pre>    [greeting release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [pool release];<span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>As you can declare C structs in Objective-C interfaces, you can also declare C++ classes in Objective-C interfaces. As with C structs, C++ classes defined within an Objective-C interface are globally-scoped, not nested within the Objective-C class. (This is consistent with the way in which standard C—though not C++—promotes nested struct definitions to file scope.)</p><p>To allow you to conditionalize your code based on the language variant, the Objective-C++ compiler defines both the <code>__cplusplus</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_357"></a> and the <code>__OBJC__</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_358"></a> preprocessor constants, as specified by (respectively) the C++ and Objective-C language standards.</p><p>As previously noted, Objective-C++ does not allow you to inherit C++ classes from Objective-C objects, nor does it allow you to inherit Objective-C classes from C++ objects. </p><div class="codesample"><table><tr><td scope="row"><pre>class Base { /* ... */ };<span></span></pre></td></tr><tr><td scope="row"><pre>@interface ObjCClass: Base ... @end // ERROR!<span></span></pre></td></tr><tr><td scope="row"><pre>class Derived: public ObjCClass ... // ERROR!<span></span></pre></td></tr></table></div><p>Unlike Objective-C, objects in C++ are statically typed, with runtime polymorphism available as an exceptional case. The object models of the two languages are thus not directly compatible. More fundamentally, the layout of Objective-C and C++ objects in memory is mutually incompatible, meaning that it is generally impossible to create an object instance that would be valid from the perspective of both languages. Hence, the two type hierarchies cannot be intermixed.</p><p>You can declare a C++ class within an Objective-C class declaration. The compiler treats such classes as having been declared in the global namespace, as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Foo {<span></span></pre></td></tr><tr><td scope="row"><pre> class Bar { ... } // OK<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Bar *barPtr; // OK<span></span></pre></td></tr></table></div><p>Objective-C allows C structures (whether declared inside of an Objective-C declaration or not) to be used as instance variables.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Foo {<span></span></pre></td></tr><tr><td scope="row"><pre>   struct CStruct { ... };<span></span></pre></td></tr><tr><td scope="row"><pre>   struct CStruct bigIvar; // OK<span></span></pre></td></tr><tr><td scope="row"><pre>} ... @end<span></span></pre></td></tr></table></div><p>Objective-C++ similarly strives to allow C++ class instances to serve as instance variables. This is possible as long as the C++ class in question (along with all of its superclasses) does not have any virtual member functions defined. If any virtual member functions are present, the C++ class may not serve as an Objective-C instance variable.</p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;Cocoa/Cocoa.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>struct Class0 { void foo(); };<span></span></pre></td></tr><tr><td scope="row"><pre>struct Class1 { virtual void foo(); };<span></span></pre></td></tr><tr><td scope="row"><pre>struct Class2 { Class2(int i, int j); };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface Foo : NSObject {<span></span></pre></td></tr><tr><td scope="row"><pre>    Class0 class0;      // OK<span></span></pre></td></tr><tr><td scope="row"><pre>    Class1 class1;      // ERROR!<span></span></pre></td></tr><tr><td scope="row"><pre>    Class1 *ptr;        // OK—call 'ptr = new Class1()' from Foo'  init,<span></span></pre></td></tr><tr><td scope="row"><pre>                        // 'delete ptr' from Foo's dealloc<span></span></pre></td></tr><tr><td scope="row"><pre>    Class2 class2;      // WARNING - constructor not called!<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>C++ requires each instance of a class containing virtual functions to contain a suitable virtual function table pointer. However, the Objective-C runtime cannot initialize the virtual function table pointer, because it is not familiar with the C++ object model. Similarly, the Objective-C runtime cannot dispatch calls to C++ constructors or destructors for those objects. If a C++ class has any user-defined constructors or destructors, they are not called. The compiler emits a warning in such cases.</p><p>Objective-C does not have a notion of nested namespaces. You cannot declare Objective-C classes within C++ namespaces, nor can you declare namespaces within Objective-C classes.</p><p>Objective-C classes, protocols, and categories cannot be declared inside a C++ template, nor can a C++ template be declared inside the scope of an Objective-C interface, protocol, or category.</p><p>However, Objective-C classes may serve as C++ template parameters. C++ template parameters can also be used as receivers or parameters (though not as selectors) in Objective-C message expressions.</p><a name="//apple_ref/doc/uid/TP40005191-CH7-117447" title="C++ Lexical Ambiguities and Conflicts"></a><a name="//apple_ref/doc/uid/TP40005191-CH7-TPXREF167" title="C++ Lexical Ambiguities and Conflicts"></a><h3>C++ Lexical Ambiguities and Conflicts</h3><p>There are a few identifiers that are defined in the Objective-C header files that every Objective-C program must include. These identifiers are <code>id</code>, <code>Class</code>, <code>SEL</code>, <code>IMP</code>, and <code>BOOL</code>.</p><p>Inside an Objective-C method, the compiler predeclares the identifiers <code>self</code> and <code>super</code>, similarly to the keyword <code>this</code> in C++. However, unlike the C++ <code>this</code><a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_359"></a> keyword, <code>self</code> and <code>super</code> are context-sensitive; they may be used as ordinary identifiers outside of Objective-C methods.</p><p>In the parameter list of methods within a protocol, there are five more context-sensitive keywords (<code>oneway</code>, <code>in</code>, <code>out</code>, <code>inout</code>, and <code>bycopy</code>). These are not keywords in any other contexts.</p><p>From an Objective-C programmer's point of view, C++ adds quite a few new keywords. You can still use C++ keywords as a part of an Objective-C selector, so the impact isn’t too severe, but you cannot use them for naming Objective-C classes or instance variables. For example, even though <code>class</code> is a C++ keyword, you can still use the <code>NSObject</code> method <code>class</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>[foo class]; // OK<span></span></pre></td></tr></table></div><p>However, because it is a keyword, you cannot use <code>class</code> as the name of a variable:</p><div class="codesample"><table><tr><td scope="row"><pre>NSObject *class; // Error<span></span></pre></td></tr></table></div><p>In Objective-C, the names for classes and categories live in separate namespaces. That is, both <code>@interface foo</code> and <code>@interface(foo)</code> can exist in the same source code. In Objective-C++, you can also have a category whose name matches that of a C++ class or structure.</p><p>Protocol and template specifiers use the same syntax for different purposes:</p><div class="codesample"><table><tr><td scope="row"><pre>id&lt;someProtocolName> foo;<span></span></pre></td></tr><tr><td scope="row"><pre>TemplateType&lt;SomeTypeName> bar;<span></span></pre></td></tr></table></div><p>To avoid this ambiguity, the compiler doesn’t permit <code>id</code> to be used as a template name.</p><p>Finally, there is a lexical ambiguity in C++ when a label is followed by an expression that mentions a global name, as in:</p><div class="codesample"><table><tr><td scope="row"><pre>label: ::global_name = 3;<span></span></pre></td></tr></table></div><p>The space after the first colon is required. Objective-C++ adds a similar case, which also requires a space:<a name="//apple_ref/doc/uid/TP40005191-CH7-DontLinkElementID_360"></a></p><div class="codesample"><table><tr><td scope="row"><pre>receiver selector: ::global_c++_name;<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/introObjectiveC.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocRuntimeSystem.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-06-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/OOPandObjC1/Articles/ocLanguage.html%3Fid%3DTP40005191-1.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/OOPandObjC1/Articles/ocLanguage.html%3Fid%3DTP40005191-1.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/OOPandObjC1/Articles/ocLanguage.html%3Fid%3DTP40005191-1.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>