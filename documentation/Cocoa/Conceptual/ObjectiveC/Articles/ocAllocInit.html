<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>The Objective-C 2.0 Programming Language: Allocating and Initializing Objects</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Allocating and Initializing Objects"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001163-CH22" title="Allocating and Initializing Objects"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ObjectiveCLanguage-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000856" target="_top">Objective-C Language</a> &gt; <a href="../Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163-CH1-SW2">The Objective-C 2.0 Programming Language</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ocDefiningClasses.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocProperties.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001163-CH22-SW1" title="Allocating and Initializing Objects"></a><h1>Allocating and Initializing Objects</h1><p></p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-SW2">Allocating and Initializing Objects</a>
				
			<br/>
			
        
			
			
				<a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-SW3">The Returned Object</a>
				
			<br/>
			
        
			
			
				<a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-SW4">Implementing an Initializer</a>
				
			<br/>
			
        
			
			
				<a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-SW8">The Designated Initializer</a>
				
			<br/>
			
        
			
			
				<a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-SW12">Combining Allocation and Initialization</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001163-CH22-105377" title="Allocating and Initializing Objects"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-SW2" title="Allocating and Initializing Objects"></a><h2>Allocating and Initializing Objects</h2><p><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_6"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_7"></a>It takes two steps to create an object using Objective-C. You must:</p><ul class="ul"><li class="li"><p>Dynamically allocate memory for the new object</p></li><li class="li"><p>Initialize<a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_8"></a> the newly allocated memory<a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_9"></a> to appropriate values</p></li></ul><p>An object isn’t fully functional until both steps have been completed. Each step is accomplished by a separate method but typically in a single line of code:</p><div class="codesample"><table><tr><td scope="row"><pre>id anObject = [[Rectangle alloc] init];<span></span></pre></td></tr></table></div><p>Separating allocation from initialization gives you individual control over each step so that each can be modified independently of the other. The following sections look first at allocation and then at initialization, and discuss how they are controlled and modified.</p><p>In Objective-C, memory for new objects<a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_10"></a> is allocated using class methods defined in the <code>NSObject</code> class. <code>NSObject</code> defines two principal methods for this purpose, <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/alloc" target="_top">alloc</a></code> and <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/allocWithZone:" target="_top">allocWithZone:</a></code>.</p><p>These methods allocate enough memory to hold all the instance variables for an object belonging to the receiving class. They don’t need to be overridden and modified in subclasses.</p><p>The <code>alloc</code><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_11"></a> and <code>allocWithZone:</code><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_12"></a> methods initialize a newly allocated object’s <code>isa</code> instance variable so that it points to the object’s class (the class object). All other instance variables are set to <code>0</code>. Usually, an object needs to be more specifically initialized before it can be safely used.</p><p>This initialization<a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_13"></a> is the responsibility of class-specific instance methods that, by convention, begin with the abbreviation “init”. If the method takes no arguments, the method name is just those four letters, <code>init</code><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_14"></a>. If it takes arguments, labels for the arguments follow the “init” prefix. For example, an <code>NSView</code> object can be initialized with an <code>initWithFrame:</code> method.</p><p>Every class that declares instance variables must provide an <code>init...</code> method to initialize them. The <code>NSObject</code> class declares the <code>isa</code> variable and defines an <code>init</code> method. However, since <code>isa</code> is initialized when memory for an object is allocated, all <code>NSObject</code>’s <code>init</code> method does is return <code>self</code>. <code>NSObject</code> declares the method mainly to establish the naming convention described earlier.<a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_15"></a></p><a name="//apple_ref/doc/uid/TP30001163-CH22-105952" title="The Returned Object"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-SW3" title="The Returned Object"></a><h2>The Returned Object</h2><p>An <code>init...</code> method normally initializes the instance variables of the receiver, then returns it. It’s the responsibility of the method to return an object that can be used without error.</p><p>However, in some cases, this responsibility can mean returning a different object than the receiver. For example, if a class keeps a list of named objects, it might provide an <code>initWithName:</code> method to initialize new instances. If there can be no more than one object per name, <code>initWithName:</code> might refuse to assign the same name to two objects. When asked to assign a new instance a name that’s already being used by another object, it might free the newly allocated instance and return the other object—thus ensuring the uniqueness of the name while at the same time providing what was asked for, an instance with the requested name.</p><p>In a few cases, it might be impossible for an <code>init...</code> method to do what it’s asked to do. For example, an <code>initFromFile:</code> method might get the data it needs from a file passed as an argument. If the file name it’s passed doesn’t correspond to an actual file, it won’t be able to complete the initialization. In such a case, the <code><!--a  -->init...<!--/a--></code> method could free the receiver and return <code>nil</code>, indicating that the requested object can’t be created.</p><p>Because an <code>init...</code> method might return an object other than the newly allocated receiver, or even return <code>nil</code>, it’s important that programs use the value returned by the initialization method, not just that returned by <code>alloc</code> or <code>allocWithZone:</code>. The following code is very dangerous, since it ignores the return of <code>init</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>id anObject = [SomeClass alloc];<span></span></pre></td></tr><tr><td scope="row"><pre>[anObject init];<span></span></pre></td></tr><tr><td scope="row"><pre>[anObject someOtherMessage];<span></span></pre></td></tr></table></div><p>Instead, to safely initialize an object, you should combine allocation and initialization messages in one line of code.</p><div class="codesample"><table><tr><td scope="row"><pre>id anObject = [[SomeClass alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>[anObject someOtherMessage];<span></span></pre></td></tr></table></div><p>If there’s a chance that the <code>init...</code> method might return <code>nil</code> (see <span class="content_text"><a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-SW13">“Handling Initialization Failure”</a></span>), then you should check the return value before proceeding:</p><div class="codesample"><table><tr><td scope="row"><pre>id anObject = [[SomeClass alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>if ( anObject )<span></span></pre></td></tr><tr><td scope="row"><pre>    [anObject someOtherMessage];<span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH22-143322" title="Implementing an Initializer"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-SW4" title="Implementing an Initializer"></a><h2>Implementing an Initializer</h2><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_16"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_17"></a><p>When a new object is created, all bits of memory (except for <code>isa</code>)—and hence the values for all its instance variables—are set to <code>0</code>. In some situations, this may be all you require when an object is initialized; in many others, you want to provide other default values for an object’s instance variables, or you want to pass values as arguments to the initializer. In these other cases, you need to write a custom initializer. In Objective-C, custom initializers are subject to more constraints and conventions than are most other methods.</p><a name="//apple_ref/doc/uid/TP30001163-CH22-SW14" title="Constraints and Conventions"></a><h3>Constraints and Conventions</h3><p>There are several constraints and conventions that apply to initializer methods that do not apply to other methods:</p><ul class="spaceabove"><li class="li"><p>By convention, the name of a custom initializer method begins with <code>init</code>.</p><p>Examples from the Foundation framework include, <code><a href="../../../Reference/Foundation/Classes/NSString_Class/Reference/NSString.html#//apple_ref/occ/instm/NSString/initWithFormat:" target="_top">initWithFormat:</a></code>, <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSArray/initWithObjects:" target="_top">initWithObjects:</a></code>, and <code><a href="../../../Reference/Foundation/Classes/NSDictionary_Class/Reference/Reference.html#//apple_ref/occ/instm/NSDictionary/initWithObjectsAndKeys:" target="_top">initWithObjectsAndKeys:</a></code>.</p></li><li class="li"><p>The return type of an initializer method should be <code>id</code>.</p><p>The reason for this is that <code>id</code> gives an indication that the class is purposefully not considered—that the class is unspecified and subject to change, depending on context of invocation. For example, <code>NSString</code> provides a method <code>initWithFormat:</code>. When sent to an instance of <code>NSMutableString</code> (a subclass of <code>NSString</code>), however, the message returns an instance of <code>NSMutableString</code>, not <code>NSString</code>. (See also, though, the singleton example given in <span class="content_text"><a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-86749">“Combining Allocation and Initialization.”</a></span>)</p></li><li class="li"><p>In the implementation of a custom initializer, you must untimately invoke a <strong>designated initializer</strong>. </p><p>Designated initializers are described in <span class="content_text"><a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-106376">“The Designated Initializer”</a></span>; a full explanation of this issue is given in <span class="content_text"><a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-106169">“Coordinating Classes.”</a></span> </p><p>In brief, if you are implementing a new designated initializer, it must invoke the superclass’ designated initialiser. If you are implementing any other initializer, it should invoke its own class’s designated initializer, or another of its own initializers that ultimately invokes the designated initializer.</p><p>By default (such as with <code>NSObject</code>), the designated initializer is <code>init</code>.</p></li><li class="li"><p>You should assign <code>self</code> to the value returned by the initializer.</p><p>This is because the initializer could return a different object than the original receiver.</p></li><li class="li"><p>If you set the value of an instance variable, you typically do so using direct assignment rather than using an accessor method.</p><p>This avoids the possibility of triggering unwanted side-effects in the accessors.</p></li><li class="li"><p>At the end of the initializer, you must return <code>self</code>, unless the initializer fails in which case you return <code>nil</code>.</p><p>Failed initializers are discussed in more detail in <span class="content_text"><a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-SW13">“Handling Initialization Failure.”</a></span></p></li></ul><p>The following example illustrates the implementation of a custom initializer for a class that inherits from <code>NSObject</code> and has an instance variable, <code>creationDate</code>, that represents the time when the object was created:</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)init {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Assign self to value returned by super's designated initializer<span></span></pre></td></tr><tr><td scope="row"><pre>    // Designated initializer for NSObject is init<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self = [super init]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        creationDate = [[NSDate alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>(The reason for using the <code>if (self = [super init])</code> pattern is discussed in <span class="content_text"><a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-SW13">“Handling Initialization Failure.”</a></span>)</p><p>An initializer doesn’t need to provide an argument for each variable. For example, if a class requires its instances to have a name and a data source, it might provide an <code>initWithName:fromURL:</code> method, but set nonessential instance variables to arbitrary values or allow them to have the null values set by default. It could then rely on methods like <code>setEnabled:</code>, <code>setFriend:</code>, and <code>setDimensions:</code> to modify default values after the initialization phase had been completed.</p><p>The next example illustrates the implementation of a custom initializer that takes a single argument. In this case, the class inherits from <code>NSView</code>. It shows that you can do work before invoking the super class’s designated initializer.</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)initWithImage:(NSImage *)anImage {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Find the size for the new instance from the image<span></span></pre></td></tr><tr><td scope="row"><pre>    NSSize size = anImage.size;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect frame = NSMakeRect(0.0, 0.0, size.width, size.height);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Assign self to value returned by super's designated initializer<span></span></pre></td></tr><tr><td scope="row"><pre>    // Designated initializer for NSView is initWithFrame:<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self = [super initWithFrame:frame]) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        image = [anImage retain];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This example doesn’t show what to do if there are any problems during initialization; this is discussed in the next section.</p><a name="//apple_ref/doc/uid/TP30001163-CH22-SW13" title="Handling Initialization Failure"></a><h3>Handling Initialization Failure</h3><p>In general, if there is a problem during an initialization method, you should call <code>[self release]</code> and return <code>nil</code>. </p><p>There are two main consequences of this policy:</p><ul class="spaceabove"><li class="li"><p>Any object (whether your own class, a subclass, or an external caller) that receives a <code>nil</code> from an initializer method should be able to deal with it. In the unlikely case where the caller has established any external references to the object before the call, this includes undoing any connections.</p></li><li class="li"><p>You must make sure that <code>dealloc</code> methods are safe in presence of partially-initialized objects.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP30001163-CH22-SW15" title="Note"></a><p><strong>Note:</strong>&nbsp;You should only call <code>[self release]</code> at the point of failure. If you get <code>nil</code> back from an invocation of the superclass’s initializer, you should not also call <code>release</code>. You should simply clean up any references you set up that are not dealt with in <code>dealloc</code> and return <code>nil</code>. This is typically handled by the pattern of performing initialization within a block dependent on a test of the return value of the superclass’s initializer—as seen in previous examples:</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)init {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self = [super init]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        creationDate = [[NSDate alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></div><p>The following example builds on that shown in <span class="content_text"><a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-SW14">“Constraints and Conventions”</a></span> to show how to handle an inappropriate value passed as the parameter:</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)initWithImage:(NSImage *)anImage {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (anImage == nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self release];<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Find the size for the new instance from the image<span></span></pre></td></tr><tr><td scope="row"><pre>    NSSize size = anImage.size;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect frame = NSMakeRect(0.0, 0.0, size.width, size.height);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Assign self to value returned by super's designated initializer<span></span></pre></td></tr><tr><td scope="row"><pre>    // Designated initializer for NSView is initWithFrame:<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self = [super initWithFrame:frame]) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        image = [anImage retain];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The next example illustrates best practice where, in the case of a problem, there is a possibility of returning meaningful information in the form of an <code>NSError</code> object returned by reference:</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)initWithURL:(NSURL *)aURL (NSError **)errorPtr {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (self = [super init]) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        NSData *data = [[NSData alloc] initWithContentsOfURL:aURL<span></span></pre></td></tr><tr><td scope="row"><pre>                                       options:NSUncachedRead error:errorPtr];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (data == nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>            // In this case the error object is created in the NSData initializer<span></span></pre></td></tr><tr><td scope="row"><pre>            [self release];<span></span></pre></td></tr><tr><td scope="row"><pre>            return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        // implementation continues...<span></span></pre></td></tr></table></div><p>You should typically not use exceptions to signify errors of this sort—for more information, see <em><a href="../../ErrorHandlingCocoa/index.html#//apple_ref/doc/uid/TP40001806" target="_top">Error Handling Programming Guide For Cocoa</a></em>.</p><a name="//apple_ref/doc/uid/TP30001163-CH22-106169" title="Coordinating Classes"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-SW5" title="Coordinating Classes"></a><h3>Coordinating Classes</h3><p>The <code>init...</code> methods a class defines typically initializes only those variables declared in that class. Inherited instance variables<a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_18"></a> are initialized by sending a message to <code>super</code><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_19"></a> to perform an initialization method defined somewhere farther up the inheritance hierarchy:</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)initWithName:(NSString *)string {<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( self = [super init] ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        name = [string copy];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The message to <code>super</code> chains together initialization methods in all inherited classes. Because it comes first, it ensures that superclass variables are initialized before those declared in subclasses. For example, a Rectangle object must be initialized as an <code>NSObject</code>, a Graphic, and a Shape before it’s initialized as a Rectangle.</p><p>The connection between the <code>initWithName:</code> method illustrated above and the inherited <code>init</code> method it incorporates is illustrated in <span class="content_text">Figure 3-1</span>:</p><br/><div><a name="//apple_ref/doc/uid/TP30001163-CH22-106278" title="Figure 3-1Incorporating an Inherited Initialization Method"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-SW6" title="Figure 3-1Incorporating an Inherited Initialization Method"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>Incorporating an Inherited Initialization Method</p><img src = "../Art/initsimple.gif" alt = "" width="278" height="302"></div><br/><p>A class must also make sure that all inherited initialization methods work. For example, if class A defines an <code>init</code> method and its subclass B defines an <code>initWithName:</code> method, as shown in <span class="content_text">Figure 3-1</span>, B must also make sure that an <code>init</code> message successfully initializes B instances. The easiest way to do that is to replace the inherited <code>init</code> method with a version that invokes <code>initWithName:</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>- init {<span></span></pre></td></tr><tr><td scope="row"><pre>    return [self initWithName:"default"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>initWithName:</code> method would, in turn, invoke the inherited method, as shown earlier. <span class="content_text">Figure 3-2</span> includes B’s version of <code>init</code>:</p><br/><div><a name="//apple_ref/doc/uid/TP30001163-CH22-106357" title="Figure 3-2Covering an Inherited Initialization Model"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-SW7" title="Figure 3-2Covering an Inherited Initialization Model"></a><p><strong>Figure 3-2&nbsp;&nbsp;</strong>Covering an Inherited Initialization Model</p><img src = "../Art/inita_b.gif" alt = "" width="278" height="302"></div><br/><p>Covering inherited initialization methods makes the class you define more portable to other applications. If you leave an inherited method uncovered, someone else may use it to produce incorrectly initialized instances of your class.</p><a name="//apple_ref/doc/uid/TP30001163-CH22-106376" title="The Designated Initializer"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-SW8" title="The Designated Initializer"></a><h2>The Designated Initializer</h2><p><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_20"></a>In the example given in <span class="content_text"><a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-106169">“Coordinating Classes,”</a></span> <code>initWithName:</code> would be the <strong>designated initializer</strong><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_21"></a> for its class (class B). The designated initializer is the method in each class<a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_22"></a> that guarantees inherited instance variables are initialized (by sending a message to <code>super</code> to perform an inherited method). It’s also the method that does most of the work, and the one that other initialization methods in the same class invoke. It’s a Cocoa convention that the designated initializer is always the method that allows the most freedom to determine the character of a new instance (usually this is the one with the most arguments, but not always).</p><p>It’s important to know the designated initializer when defining a subclass. For example, suppose we define class C, a subclass of B, and implement an <code>initWithName:fromFile:</code> method. In addition to this method, we have to make sure that the inherited <code>init</code> and <code>initWithName:</code> methods also work for instances of C. This can be done just by covering B’s <code>initWithName:</code> with a version that invokes <code>initWithName:fromFile:</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>- initWithName:(char *)string {<span></span></pre></td></tr><tr><td scope="row"><pre>    return [self initWithName:string fromFile:NULL];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For an instance of the C class, the inherited <code>init</code> method invokes this new version of <code>initWithName:</code> which invokes <code>initWithName:fromFile:</code>. The relationship between these methods is shown in <span class="content_text">Figure 3-3</span>:</p><br/><div><a name="//apple_ref/doc/uid/TP30001163-CH22-106471" title="Figure 3-3Covering the Designated Initializer"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-SW9" title="Figure 3-3Covering the Designated Initializer"></a><p><strong>Figure 3-3&nbsp;&nbsp;</strong>Covering the Designated Initializer</p><img src = "../Art/initb_c.gif" alt = "" width="223" height="253"></div><br/><p>This figure omits an important detail. The <code>initWithName:fromFile:</code> method, being the designated initializer for the C class, sends a message to <code>super</code> to invoke an inherited initialization method. But which of B’s methods should it invoke, <code>init</code> or <code>initWithName:</code>? It can’t invoke <code>init</code>, for two reasons:</p><ul class="ul"><li class="li"><p>Circularity would result (<code>init</code> invokes C’s <code>initWithName:</code>, which invokes <code>initWithName:fromFile:</code>, which invokes <code>init</code> again).</p></li><li class="li"><p>It won’t be able to take advantage of the initialization code in B’s version of <code>initWithName:</code>.</p></li></ul><p>Therefore, <code>initWithName:fromFile:</code> must invoke <code>initWithName:</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>- initWithName:(char *)string fromFile:(char *)pathname {<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( self = [super initWithName:string] )<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP30001163-CH22-SW10" title="General Principle"></a><p><strong>General Principle:</strong>&nbsp;The designated initializer in a class must, through a message to <code>super</code>, invoke the designated initializer in a superclass.</p></div><p>Designated initializers are chained to each other through messages to <code>super</code>, while other initialization methods are chained to designated initializers through messages to <code>self</code>.</p><p><span class="content_text">Figure 3-4</span> shows how all the initialization methods in classes A, B, and C are linked. Messages to <code>self</code> are shown on the left and messages to <code>super</code> are shown on the right.</p><br/><div><a name="//apple_ref/doc/uid/TP30001163-CH22-106638" title="Figure 3-4Initialization Chain"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-SW11" title="Figure 3-4Initialization Chain"></a><p><strong>Figure 3-4&nbsp;&nbsp;</strong>Initialization Chain</p><img src = "../Art/initall.gif" alt = "" width="222" height="367"></div><br/><p>Note that B’s version of <code>init</code> sends a message to <code>self</code> to invoke the <code>initWithName:</code> method. Therefore, when the receiver is an instance of the B class, it invokes B’s version of <code>initWithName:</code>, and when the receiver is an instance of the C class, it invokes C’s version.<a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_23"></a></p><a name="//apple_ref/doc/uid/TP30001163-CH22-86749" title="Combining Allocation and Initialization"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-SW12" title="Combining Allocation and Initialization"></a><h2>Combining Allocation and Initialization</h2><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_24"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_25"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_26"></a><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_27"></a><p>In Cocoa, some classes define creation methods that combine the two steps of allocating and initializing to return new, initialized instances of the class. These methods are often referred to as <strong>convenience constructors</strong> and typically take the form <code>+ </code><em>className...</em> where <em>className</em> is the name of the class. For example, <code>NSString</code> has the following methods (among others):</p><div class="codesample"><table><tr><td scope="row"><pre>+ (id)stringWithCString:(const char *)cString encoding:(NSStringEncoding)enc;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)stringWithFormat:(NSString *)format, ...;<span></span></pre></td></tr></table></div><p>Similarly, <code>NSArray</code> defines the following class methods that combine allocation and initialization:</p><div class="codesample"><table><tr><td scope="row"><pre>+ (id)array;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)arrayWithObject:(id)anObject;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)arrayWithObjects:(id)firstObj, ...;<span></span></pre></td></tr></table></div><div class="importantbox"><a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_1" title="Important:"></a><p><strong>Important:</strong>&nbsp;It is important to understand the memory management implications of using these methods if you do not use garbage collection (see <span class="content_text"><a href="ocObjectsClasses.html#//apple_ref/doc/uid/TP30001163-CH11-142945">“Memory Management”</a></span>). You must read <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em> to understand the policy that applies to these convenience constructors.</p><p></p></div><p>Notice that the return type of these methods is <code>id</code>. This is for the same reason as for initializer methods, as discussed in <span class="content_text"><a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-SW14">“Constraints and Conventions.”</a></span></p><p>Methods that combine allocation and initialization are particularly valuable if the allocation must somehow be informed by the initialization. For example, if the data for the initialization is taken from a file, and the file might contain enough data to initialize more than one object, it would be impossible to know how many objects to allocate until the file is opened. In this case, you might implement a <code>listFromFile:</code> method that takes the name of the file as an argument. It would open the file, see how many objects to allocate, and create a List object large enough to hold all the new objects. It would then allocate and initialize the objects from data in the file, put them in the List, and finally return the List.</p><p>It also makes sense to combine allocation and initialization in a single method if you want to avoid the step of blindly allocating memory for a new object that you might not use. As mentioned in <span class="content_text"><a href="ocAllocInit.html#//apple_ref/doc/uid/TP30001163-CH22-105952">“The Returned Object,”</a></span> an <code>init...</code> method might sometimes substitute another object for the receiver. For example, when <code>initWithName:</code> is passed a name that’s already taken, it might free the receiver and in its place return the object that was previously assigned the name. This means, of course, that an object is allocated and freed immediately without ever being used.</p><p>If the code that determines whether the receiver should be initialized is placed inside the method that does the allocation instead of inside <code>init...</code>, you can avoid the step of allocating a new instance when one isn’t needed.</p><p>In the following example, the <code>soloist</code> method ensures that there’s no more than one instance of the Soloist class. It allocates and initializes a single shared instance:<a name="//apple_ref/doc/uid/TP30001163-CH22-DontLinkElementID_28"></a></p><div class="codesample"><table><tr><td scope="row"><pre>+ (Soloist *)soloist {<span></span></pre></td></tr><tr><td scope="row"><pre>    static Soloist *instance = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( instance == nil ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        instance = [[self alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return instance;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Notice that in this case the return type is <code>Soloist *</code>. Since this method returns a singleton share instance, strong typing is appropriate—there is no expectation that this method will be overridden.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ocDefiningClasses.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocProperties.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocAllocInit.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocAllocInit.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocAllocInit.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>