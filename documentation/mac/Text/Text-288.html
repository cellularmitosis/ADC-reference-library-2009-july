<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Modifying Text(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING288></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-287.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-289.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-279.html"><B>Chapter 5 - Text Utilities</B></A> / <A HREF="Text-284.html"><B>Using the Text Utilities</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING288-0></A>
<H2><A NAME=MARKER-9-143></A>Modifying Text</H2>
 The Text Utilities include a number of routines that you can use to modify the contents of strings. Several of these routines operate on Pascal strings, while others operate on text strings.<P>
 Several of the text modification routines also take a script code parameter, which is used to indicate which script system's resources should be used to define the results of various character modifications. Script codes are described in the chapter "Script Manager" in this book.<P>
 There are three kinds of text modification routines:<P>
<UL>
<LI>routines that convert the case of characters and strip diacritical marks from characters in a string
<LI>routines that truncate a string to make it fit into a specified area on the screen
<LI>routines that search for a character pattern in a string and replace it with a different character pattern<P>
</UL>
<A NAME=HEADING288-7></A>
<H3>Converting Characters and Stripping Marks in Strings<A NAME=MARKER-9-46></A></H3>
 Several Text Utilities routines allow you to convert the case of characters and strip diacritical marks from strings. They can be useful when you want to present strings in a simplified form or to store strings in a form that can increase the efficiency of a comparison.<P>
 You can use the <CODE>UpperString</CODE> procedure to convert any lowercase letters in a Pascal string into their uppercase equivalents; however, this procedure assumes that you are using the Macintosh file system conversion rules and does not use any of the information in the international resources to perform its conversion.<P>
 <A NAME=MARKER-2-39></A>You can use the <CODE>UppercaseText</CODE> procedure to convert any lowercase letters in a text string into their uppercase equivalents. This procedure takes a script code parameter and uses the case conversion information in the string-manipulation resource for the indicated script system to convert the characters.<P>
 <A NAME=MARKER-2-44></A>The <CODE>LowercaseText</CODE> procedure converts any uppercase letters in a text string into their lowercase equivalents. This procedure takes a script code parameter and uses the case conversion information in the string-manipulation resource for the indicated script system to convert the characters.<P>
 The <CODE>StripDiacritics</CODE> procedure removes any diacritical marks from a text string. This procedure takes a script code parameter and uses the information in the string-manipulation resource for the indicated script system to determine what character results when a diacritical mark is stripped.<P>
 <A NAME=MARKER-2-126></A>The <CODE>UppercaseStripDiacritics</CODE> procedure combines the effects of the <CODE>UppercaseText</CODE> and <CODE>StripDiacritics</CODE> procedures: it converts any lowercase letters to their uppercase equivalents and strips any diacritical marks from characters in a text string. This procedure also takes a script code parameter, which specifies which script system's resources are used to determine conversion results.<A NAME=MARKER-2-166></A><P>
 Certain other routines in Macintosh system software convert characters in a text string. The <CODE>TransliterateText</CODE> function converts characters from one subscript into the closest possible approximation in a different subscript within the same script system. The <CODE>IntlTokenize</CODE> function converts text into language-independent tokens, for further processing by interpreters or compilers. <CODE>TransliterateText</CODE> and <CODE>IntlTokenize</CODE> are documented in the chapter "Script Manager" in this book.<A NAME=MARKER-2-170></A><A NAME=MARKER-2-51></A><P>
<A NAME=HEADING288-15></A>
<H3>Fitting a String Into a Screen Area<A NAME=MARKER-2-171></A></H3>
 When you want to ensure that a string fits in a certain area of the screen, you can use either the <CODE>TruncString</CODE> or <CODE>TruncText</CODE> routine. Each performs the same operation: truncating the string (removing characters from it) so that it fits into a specified pixel width. The <CODE>TruncString</CODE> function truncates a Pascal string and the <CODE>TruncText</CODE> function truncates a text string.<A NAME=MARKER-2-172></A><P>
 Both of the truncation functions use the current font--the font currently in use in the current graphics port--and its script to determine where the string should be truncated. The font size is used to determine how many characters can completely fit in the number of pixels specified as a parameter to the function.<P>
 Both functions also take a parameter that specifies where any needed truncation is to occur. You can specify that characters are to be truncated from the end or from the middle of the string, as MPW does with pathnames, for example.<A NAME=MARKER-2-53></A><P>
 A truncation indicator is inserted into a string after characters are truncated; in the U.S. Roman script system, the ellipsis (...) is used for this purpose. You should specify the truncation indicator by token, rather than by specific character code, so that the proper indicator is applied to each script system's text. Specify a token from the untoken table of the tokens (<CODE>'itl4'</CODE>) resource of the script system of the current font. The untoken table is described in the appendix "International Resources" in this book.<P>
 Truncating a string in its middle is commonly used on pathnames, where you want the user to see the beginning and end of the full path, but are willing to sacrifice some of the information in the middle, as shown in <A HREF=#MARKER-9-154>Figure 5-7</A>.<P>
<B>Figure 5-7  <A NAME=MARKER-9-154></A>Truncating a pathname in its middle</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/TU_L-05.jpg">
 The code in <A HREF=#MARKER-9-155>Listing 5-2</A> performs the truncation that is illustrated in <A HREF=#MARKER-9-154>Figure 5-7</A>. Assuming that each character in the string requires 12 pixels, then 480 pixels will be wide enough to hold 40 characters:<P>
<B>Listing 5-2  <A NAME=MARKER-9-155></A>Truncating a pathname</B><P>
<PRE>
str := "Mymac:myfolder:mysubfolder:myownfolder:myfile"
ans := TruncString( 480, str, truncEnd );    {480 pixels available}
   {str would be "Mymac:myfolder:mysubfolder:myownfolder:..."}
ans := TruncString( 480, str, truncMiddle );
   {str would now be "Mymac:myfolder:mysub...:myownfolder:myfile"}
</PRE>
 Since the truncation functions can alter the length and contents of the string that you pass in, it is good practice to make a copy of a string before passing it to one of them<A NAME=MARKER-2-638></A>.<P>
<A NAME=HEADING288-27></A>
<H3><A NAME=MARKER-2-452></A>Replacing a Portion of a String</H3>
 The Text Utilities include two routines for replacing a portion of a string with another string. Each of these routines searches through a string looking for the pattern string. Whenever it finds an occurrence of the pattern string, the routine replaces it with the new string.<P>
 The <CODE>ReplaceText</CODE> function takes information about the current script system into account: it looks through the string character-by-character rather than byte-by-byte. Specifically, this means that <CODE>ReplaceText</CODE> properly examines strings that contain both 1-byte and 2-byte characters.<P>
 The <CODE>Munger</CODE> function searches for a sequence of bytes and replaces it with another sequence of bytes that you specify. It provides the same capability as <CODE>ReplaceText</CODE>, but searches for a byte pattern without regard to character length. In a string that contains a mixture of 1-byte and 2-byte characters, <CODE>Munger</CODE> can, under some conditions, wrongly find a pattern string. This is because the second byte in some 2-byte characters can be wrongly regarded as a 1-byte character.<A NAME=MARKER-9-282></A><P>
 For example, suppose that you want to search a string for the copyright ("&#169;") character and replace each occurrence with the string "Registered". If you use <CODE>Munger</CODE> to search a string with Japanese characters in it, <CODE>Munger</CODE> will mistakenly find and replace the byte with value A9, which is really part of a 2-byte character in the Japanese script system. <A HREF=#MARKER-9-160>Figure 5-8</A> shows how the Japanese word for "morning sun" could be incorrectly identified as containing the copyright character.<A NAME=MARKER-2-159></A><P>
<B>Figure 5-8  <A NAME=MARKER-9-160></A>Replacing a portion of a string with 1-byte and 2-byte characters</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/TU_L-13.jpg">
 <CODE>Munger</CODE> provides a great deal of power, allowing you to perform many interesting substitutions; however, you need to limit your use of <CODE>Munger</CODE> in applications that are script-aware, or else do your own checking for 2-byte characters.<P>
 <A HREF=#MARKER-9-161>Listing 5-3</A> uses the <CODE>ReplaceText</CODE> and <CODE>TruncText</CODE> functions. It assumes that you have <CODE>Str255</CODE> strings containing base text and substitution text and that you want the result to fit in a specified number of pixels.<P>
<B>Listing 5-3  <A NAME=MARKER-9-161></A><A NAME=MARKER-21-162></A>Substituting and truncating text</B><P>
<PRE>
CONST
   maxInt = 32767;
VAR
   baseString: Str255;
   subsString: Str255;
   baseHandle: Handle;
   subsHandle: Handle;
   keyStr: Str15;
   sizeL: LongInt;
   myWidth: Integer;
   length: Integer;
   result: Integer;
   myErr: OSErr;
BEGIN
   baseString:'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz';

   subsString := 'KILROY WAS HERE';    {insert this into baseString}
   keyStr := 'mnop';                   {replace this with subString}
   myWidth := 500;                     {truncate string at this width}
   sizeL := ord(baseString[0]);
   myErr := PtrToHand(@baseString[1], baseHandle, sizeL);
   IF myErr &lt;&gt; noErr
      THEN DoError(myErr);
   sizeL := ord(subsString[0]);
   myErr := PtrToHand(@subsString[1], subsHandle, sizeL);
   IF myErr &lt;&gt; noErr
      THEN DoError(myErr);
   result := ReplaceText(baseHandle, subsHandle, keyStr);
   IF result &lt; 0
      THEN DoError(result);
   sizeL := GetHandleSize(baseHandle);
   IF MemError &lt;&gt; noErr
      THEN DoError(MemError);
   length := sizeL;
   HLock(baseHandle);
   IF MemError &lt;&gt; noErr
      THEN DoError(MemError);          {Memory Manager error}
   result := TruncText(myWidth, baseHandle^, length, TruncEnd);
   IF result &lt; 0
      THEN DoError(result);
   DrawText(baseHandle^, 0, length);
   HUnlock(baseHandle);
   IF MemError &lt;&gt; noErr
      THEN DoError(myErr);             {Memory Manager error}
END;
</PRE>
 The code in <A HREF=#MARKER-9-161>Listing 5-3</A> first calls the <CODE>ReplaceText</CODE> function to replace a portion of the base string (the string initialized to contain the alphabet) with another string. Since two of the parameters to <CODE>ReplaceText</CODE> are string handles, the code first creates handles to the two strings and verifies that no errors occurred. It then calls the <CODE>TruncText</CODE> function to remove characters from the end of the modified base string so that the string can be displayed, using the text font, size, and style settings in the current graphics port, in an area 500 pixels wide. Once the string is truncated, the code calls the QuickDraw procedure <CODE>DrawText</CODE> to draw the string in the current graphics port on the screen.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-287.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-289.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
