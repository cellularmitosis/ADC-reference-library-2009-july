<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MenuScripter - /Sources/MSFile.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">MenuScripter</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MenuScripter</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sources/MSFile.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Resources/MenuScripterAETE.r</option>
<option value="listing2.html">/Sources/DebugUtils.c</option>
<option value="listing3.html">/Sources/DebugUtils.h</option>
<option value="listing4.html">/Sources/MenuScripter.r</option>
<option value="listing5.html">/Sources/MenuScripterPPC.r</option>
<option value="listing6.html">/Sources/MSAccessors.c</option>
<option value="listing7.html">/Sources/MSAccessors.h</option>
<option value="listing8.html">/Sources/MSAEClone.c</option>
<option value="listing9.html">/Sources/MSAEClone.h</option>
<option value="listing10.html">/Sources/MSAEClose.c</option>
<option value="listing11.html">/Sources/MSAEClose.h</option>
<option value="listing12.html">/Sources/MSAECoercions.c</option>
<option value="listing13.html">/Sources/MSAECoercions.h</option>
<option value="listing14.html">/Sources/MSAECompare.c</option>
<option value="listing15.html">/Sources/MSAECompare.h</option>
<option value="listing16.html">/Sources/MSAECopy.c</option>
<option value="listing17.html">/Sources/MSAECopy.h</option>
<option value="listing18.html">/Sources/MSAECountElements.c</option>
<option value="listing19.html">/Sources/MSAECountElements.h</option>
<option value="listing20.html">/Sources/MSAECreate.c</option>
<option value="listing21.html">/Sources/MSAECreate.h</option>
<option value="listing22.html">/Sources/MSAECut.c</option>
<option value="listing23.html">/Sources/MSAECut.h</option>
<option value="listing24.html">/Sources/MSAEDelete.c</option>
<option value="listing25.html">/Sources/MSAEDelete.h</option>
<option value="listing26.html">/Sources/MSAEGetData.c</option>
<option value="listing27.html">/Sources/MSAEGetData.h</option>
<option value="listing28.html">/Sources/MSAEGetDataSize.c</option>
<option value="listing29.html">/Sources/MSAEGetDataSize.h</option>
<option value="listing30.html">/Sources/MSAEMenuUtils.c</option>
<option value="listing31.html">/Sources/MSAEMenuUtils.h</option>
<option value="listing32.html">/Sources/MSAEMove.c</option>
<option value="listing33.html">/Sources/MSAEMove.h</option>
<option value="listing34.html">/Sources/MSAEObjectsExist.c</option>
<option value="listing35.html">/Sources/MSAEObjectsExist.h</option>
<option value="listing36.html">/Sources/MSAEPaste.c</option>
<option value="listing37.html">/Sources/MSAEPaste.h</option>
<option value="listing38.html">/Sources/MSAERecording.c</option>
<option value="listing39.html">/Sources/MSAERecording.h</option>
<option value="listing40.html">/Sources/MSAERevert.c</option>
<option value="listing41.html">/Sources/MSAERevert.h</option>
<option value="listing42.html">/Sources/MSAESave.c</option>
<option value="listing43.html">/Sources/MSAESave.h</option>
<option value="listing44.html">/Sources/MSAESelect.c</option>
<option value="listing45.html">/Sources/MSAESelect.h</option>
<option value="listing46.html">/Sources/MSAESetData.c</option>
<option value="listing47.html">/Sources/MSAESetData.h</option>
<option value="listing48.html">/Sources/MSAETextUtils.c</option>
<option value="listing49.html">/Sources/MSAETextUtils.h</option>
<option value="listing50.html">/Sources/MSAEUtils.c</option>
<option value="listing51.html">/Sources/MSAEUtils.h</option>
<option value="listing52.html">/Sources/MSAEWindowUtils.c</option>
<option value="listing53.html">/Sources/MSAEWindowUtils.h</option>
<option value="listing54.html">/Sources/MSAppleEvents.c</option>
<option value="listing55.html">/Sources/MSAppleEvents.h</option>
<option value="listing56.html">/Sources/MSASSubroutines.c</option>
<option value="listing57.html">/Sources/MSASSubroutines.h</option>
<option value="listing58.html">/Sources/MSDrag.c</option>
<option value="listing59.html">/Sources/MSDrag.h</option>
<option value="listing60.html">/Sources/MSFile.c</option>
<option value="listing61.html">/Sources/MSFile.h</option>
<option value="listing62.html">/Sources/MSGlobals.c</option>
<option value="listing63.html">/Sources/MSGlobals.h</option>
<option value="listing64.html">/Sources/MSGXPrinting.c</option>
<option value="listing65.html">/Sources/MSGXPrinting.h</option>
<option value="listing66.html">/Sources/MSMain.c</option>
<option value="listing67.html">/Sources/MSMain.h</option>
<option value="listing68.html">/Sources/MSResultWind.c</option>
<option value="listing69.html">/Sources/MSResultWind.h</option>
<option value="listing70.html">/Sources/MSScript.c</option>
<option value="listing71.html">/Sources/MSScript.h</option>
<option value="listing72.html">/Sources/MSToken.h</option>
<option value="listing73.html">/Sources/MSUtils.c</option>
<option value="listing74.html">/Sources/MSUtils.h</option>
<option value="listing75.html">/Sources/MSWindow.c</option>
<option value="listing76.html">/Sources/MSWindow.h</option>
<option value="listing77.html">/Sources/Offscreen.c</option>
<option value="listing78.html">/Sources/Offscreen.h</option>
<option value="listing79.html">/Sources/PLStrs.c</option>
<option value="listing80.html">/Sources/PLStrs.h</option></select>
				</p>
				</form>
				<p><strong><a href="MenuScripter.zip">Download Sample</a></strong> (&#147;MenuScripter.zip&#148;, 288.0K)<BR>
<strong><a href="MenuScripter.dmg">Download Sample</a></strong> (&#147;MenuScripter.dmg&#148;, 355.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">// MSFile.c//// Original version by Jon Lansdell and Nigel Humphreys.// 4.0 and 3.1 updates by Greg Sutton.// &copy;Apple Computer Inc 1996, all rights reserved./*  Changes for 4.0  28-Feb-96 : GS : Added script to document file. This script is attached to the document            and gets first go at handling Apple events targetted at the document.*/#include &lt;Errors.h&gt;#include &lt;Resources.h&gt;#include &lt;Desk.h&gt;#ifdef THINK_C  #include &quot;PLStrs.h&quot;#else  #include &lt;PLStringFuncs.h&gt;#endif#include &lt;AppleEvents.h&gt;#include &lt;AERegistry.h&gt;#include &lt;StandardFile.h&gt;#include &quot;MSFile.h&quot;#include &quot;Offscreen.h&quot;#include &quot;MSResultWind.h&quot;#include &quot;MSAEWindowUtils.h&quot;#include &quot;MSScript.h&quot;#include &quot;MSAESetData.h&quot;#include &lt;LowMem.h&gt;  // Constantsconst  OSType  kStyleInfoType    = 'TFSF';const  OSType  kHeaderInfoType    = 'TFSS';const  OSType  kGXPrinterInfoType  = 'TFGX';//  Name:       FileError//  Purpose:    Puts up an error alert.#pragma segment Filevoid  FileError( Str255 s, Str255 f ){  short    alertResult;    SetCursor(&amp;qd.arrow);  ParamText(s, f, (unsigned char *)&quot;&quot;, (unsigned char *)&quot;&quot;);  alertResult = Alert( ErrorAlert, NULL );}//  Name:       DoClose//  Purpose:    Closes a window.#pragma segment FileOSErr  DoClose( WindowPtr aWindow,Boolean canInteract,DescType dialogAnswer ){  DPtr    aDocument;  short   alertResult;  OSErr   myErr;              myErr = noErr;      aDocument = DPtrFromWindowPtr(aWindow);  if ( ! aDocument )    return noErr;        // Save if the windows contents have changed and it's not the results window  if ((aDocument-&gt;dirty) &amp;&amp; !IsThisResultWind(aWindow))  {    if (canInteract &amp;&amp; (dialogAnswer==kAEAsk))    {      alertResult = DoFileDialog ( kSaveDontsaveDialog, aWindow );      switch ( alertResult )      {        case kStdOkItemIndex:          if (aDocument-&gt;everSaved == false)          {            myErr = GetFileNameToSaveAs(aDocument);            if (myErr == noErr)              myErr = DoSave(aDocument, aDocument-&gt;theFSSpec);          }          else            myErr = SaveUsingTemp(aDocument);        break;                                      case kStdCancelItemIndex:          return(userCanceledErr);        break;                case kDontSaveItemIndex:          aDocument-&gt;dirty = false;        break;      }    }    else    {      if (dialogAnswer==kAEYes)        if (aDocument-&gt;everSaved == false)        {          if (canInteract)          {            myErr = GetFileNameToSaveAs(aDocument);            if (myErr==noErr)              myErr = DoSave(aDocument, aDocument-&gt;theFSSpec);          }          else              return(errAENoUserInteraction);        }        else          myErr = SaveUsingTemp(aDocument);      else        myErr = noErr; // Don't save    }  }        if ( myErr == noErr )    CloseMyWindow(aWindow);        return(myErr);}// This is called to display the &quot;save before closing&quot; and &quot;revert&quot; dialogs.short  DoFileDialog( short theDlogID, WindowRef theWindow ){  short    theItem;  DialogRef  theDialog;  WindowRef  dialogWindow;  DPtr      theDocument;  Str255    theTitle, theReason;      theDocument = DPtrFromWindowPtr ( theWindow );    theDialog = GetNewDialog ( theDlogID, nil, (WindowRef) -1 );  dialogWindow = GetDialogWindow ( theDialog );  SetPortWindowPort ( dialogWindow );      if ( theDocument-&gt;everSaved == false )    GetWTitle ( theWindow, theTitle );     // Pick it up as a script may have changed it  else    PLstrcpy ( theTitle, theDocument-&gt;theFileName );    if ( gQuitting )    GetIndString ( theReason, kMiscStrings, kQuittingIndex );  else    GetIndString ( theReason, kMiscStrings, kClosingindex );    SetCursor ( &amp;qd.arrow );  ParamText ( theTitle, theReason, nil, nil );  ShowMSWindow ( dialogWindow );  SelectWindow ( dialogWindow );    SetDialogDefaultItem ( theDialog, kStdOkItemIndex );  SetDialogCancelItem ( theDialog, kStdCancelItemIndex );    // As long as the only enabled items are the dimissers,   // there is no need to call ModalDialog within a loop.  ModalDialog ( nil, &amp;theItem );  DisposeDialog ( theDialog );    return theItem;}    #pragma segment File//  DoQuit//  saveOpt - one of kAEAsk,kAEYes,kAENo//  if kAEYes or kAEAsk then AEInteactWithUser should have been called//  before DoQuit. Assumes that it can interact if it needs to.void  DoQuit( DescType saveOpt ){  WindowPtr    aWindow;    WindowPtr    nextWindow;    WindowPeek   nextWPeek;    short        theKind;    OSErr        check;      aWindow = (WindowPtr)LMGetWindowList();    gQuitting = true;  while ( aWindow )  {    nextWPeek  = ((WindowPeek)aWindow)-&gt;nextWindow;    nextWindow = &amp;nextWPeek-&gt;port;    if (Ours(aWindow))    {      check = DoClose(aWindow, true, saveOpt);      if ( check != noErr )      {        gQuitting = false;        return;      }    }    else    {      theKind = ((WindowPeek)aWindow)-&gt;windowKind;      if (theKind &lt; 0)        CloseDeskAcc(theKind);    }    aWindow = nextWindow;  }} // DoQuitOSErr  GetFile( FSSpec *theFSSpec ){  SFTypeList         myTypes;  StandardFileReply  reply;    myTypes[0] = 'TEXT';    StandardGetFile( NULL, 1, myTypes, &amp;reply );    if (reply.sfGood)  {    *theFSSpec = reply.sfFile;    return(noErr);  }  else    return(userCanceledErr);}#pragma segment FileOSErr  DoCreate( FSSpec theSpec ){  OSErr err;    err = FSpCreate(&amp;theSpec, MenuScripterAppSig, 'TEXT', smSystemScript);    if (err != noErr)     ShowError((unsigned char *)&quot;\pDoCreate&quot;, err);        return(err);}#pragma segment FileOSErr  WriteFile( DPtr theDocument, short refNum, FSSpec theFSSpec ){  short        resFile;  long         length;  HHandle      theHHandle;  StScrpHandle theSHandle;  OSErr        err;  StringHandle theAppName;  short        oldSelStart;  short        oldSelEnd;  Handle       thePHandle;  Handle       myText;  Handle       thePGXHandle;    tWindowOffscreen*  theOffscreen = nil;    // first write out the text to the data fork      length = (*(theDocument-&gt;theText))-&gt;teLength;  myText = (*(theDocument-&gt;theText))-&gt;hText;      HLock( myText );    err = FSWrite(refNum, &amp;length, *myText);  if ( noErr != err )    return err;        HUnlock( myText );      // we are writing to a temporary file, so we need to create the resource file    // before writing out the resources    // now open the resource file      HCreateResFile(theFSSpec.vRefNum, theFSSpec.parID, theFSSpec.name);  err = ResError();  if (err)  {    ShowError((unsigned char *)&quot;\pHCreateResFile&quot;, err);    return(err);  }    resFile = HOpenResFile( theFSSpec.vRefNum, theFSSpec.parID, theFSSpec.name, fsWrPerm );  err = ResError();    if (err)  {    ShowError((unsigned char *)&quot;\pHOpenResFile&quot;, err);    return(err);  }    // Write out our 'TFSF' resource to file     //  Draw everything into offscreen pixmap.  theOffscreen = DrawOffscreen ( theDocument-&gt;theWindow );  if ( theOffscreen  )    (*theDocument-&gt;theText)-&gt;inPort = (GrafPtr) theOffscreen-&gt;offscreenWorld;      oldSelStart = (*(theDocument-&gt;theText))-&gt;selStart;  oldSelEnd   = (*(theDocument-&gt;theText))-&gt;selEnd;  TESetSelect( 0, kMaxTELength, theDocument-&gt;theText );    theSHandle = TEGetStyleScrapHandle(theDocument-&gt;theText);    TESetSelect(oldSelStart,oldSelEnd, theDocument-&gt;theText);      if ( theOffscreen )  {    // If it wasn't for the caret, we wouldn't need to draw this    theOffscreen = DrawOnscreen ( theOffscreen );    (*theDocument-&gt;theText)-&gt;inPort = theDocument-&gt;theWindow;  }    AddResource((Handle)theSHandle, kStyleInfoType, 255, (unsigned char *)&quot;\pStyle Info&quot;);  err = ResError();  if (err)  {    ShowError((unsigned char *)&quot;\pAddResource - Style Info&quot;, err);    return(err);  }            // Write out the printer info          // First the QD info          if (theDocument-&gt;thePrintSetup)  {    thePHandle = (Handle)theDocument-&gt;thePrintSetup;    err = HandToHand(&amp;thePHandle);        AddResource(thePHandle, 'TFSP', 255, (unsigned char *)&quot;\pPrinter Info&quot;);    err = ResError();    if (err)      {        ShowError((unsigned char *)&quot;\pAddResource- TFSP&quot;, err);        return(err);      }  }          // Next the QD QX info  if ( ( gGXIsPresent ) &amp;&amp; ( theDocument-&gt;documentJob ) )  {    thePGXHandle = NewHandle(0);    GXFlattenJobToHdl(theDocument-&gt;documentJob, thePGXHandle);      AddResource(thePGXHandle, kGXPrinterInfoType, 255, (unsigned char *)&quot;\pGX Printer Info&quot;);    err = ResError();    if (err)    {      ShowError((unsigned char *)&quot;\pAddResource- TFGX&quot;, err);      return(err);    }  }          theHHandle = (HHandle)NewHandle(sizeof(HeaderRec));  HLock((Handle)theHHandle);    GetFontName(theDocument-&gt;theFont, (unsigned char *)&amp;(*theHHandle)-&gt;theFont);  (*theHHandle)-&gt;theSize     = theDocument-&gt;theSize;  (*theHHandle)-&gt;theStyle    = theDocument-&gt;theStyle;  (*theHHandle)-&gt;lastID      = 0;    HUnlock((Handle)theHHandle);    AddResource((Handle)theHHandle, kHeaderInfoType, 255, (unsigned char *)&quot;\pHeader Info&quot;);    err = ResError();  if (err)  {    ShowError((unsigned char *)&quot;\pAddResource- Header Info&quot;, err);    return(err);  }    // Now put an AppName in for Finder in 7.0    theAppName = (StringHandle)NewHandle(gAppRec.theName[0]);  PLstrcpy( *theAppName, gAppRec.theName );    AddResource((Handle)theAppName, 'STR ', -16396, (unsigned char *)&quot;\pFinder App Info&quot;);    err = ResError();    if (err)  {    ShowError((unsigned char *)&quot;\pAppName&quot;, err);    return(err);  }      // Each document has a script associated with it    //  this can be changed so store in resource.  err = StoreDocumentScript( theDocument, resFile );    CloseResFile( resFile );    return err;} // WriteFile#pragma segment FileOSErr  ReadFile( DPtr theDocument, short  refNum, Str255 fn ){  long            theSize;  short           resFile;  OSErr           err;  HHandle         aHandle;  Handle          gHandle;  Handle          hGXJobData;  Boolean     gotQDPrintRec;    gotQDPrintRec = false;    err = GetEOF(refNum, &amp;theSize);  if (err)    return(err);    // We're only using TE, so check that there is not more than 32K worth of text        if (theSize &gt; kMaxTELength)    return(1);    gHandle = NewHandle(theSize);  HLock(gHandle);  err = FSRead(refNum, &amp;theSize, *gHandle);        if (err)  {    HUnlock(gHandle);    return(err);  }                resFile = HOpenResFile(theDocument-&gt;theFSSpec.vRefNum,                          theDocument-&gt;theFSSpec.parID,                         fn,                         fsWrPerm);  if ( resFile == -1 )    err = fnfErr;          if ( err == noErr )  {    aHandle = NULL;    if ( Count1Resources( kHeaderInfoType ) )      aHandle = (HHandle)Get1Resource( kHeaderInfoType, 255 );    //  New Format Info    aHandle = nil;        if ( Count1Resources( kStyleInfoType ) )      aHandle = (HHandle)Get1Resource( kStyleInfoType, 255 );          HLock(gHandle);    TEStylInsert( *gHandle, GetHandleSize(gHandle),              (StScrpHandle)aHandle, theDocument-&gt;theText );    HUnlock(gHandle);        //  If there is a print record saved, ditch the old one    //  created by new document and fill this one in    if (Count1Resources('TFSP'))    {      if (theDocument-&gt;thePrintSetup)        DisposHandle((Handle)theDocument-&gt;thePrintSetup);            theDocument-&gt;thePrintSetup = (THPrint)Get1Resource('TFSP', 255);        err = HandToHand((Handle *)&amp;theDocument-&gt;thePrintSetup);            gotQDPrintRec = true;      if (! gGXIsPresent)        PrValidate(theDocument-&gt;thePrintSetup);    }    if ( gGXIsPresent )      if ( Count1Resources( kGXPrinterInfoType ) )      {        if (theDocument-&gt;documentJob)        {//            GXDisposeJob(theDocument-&gt;documentJob);//            theDocument-&gt;documentJob = nil;        }        hGXJobData = Get1Resource( kGXPrinterInfoType, 255 );        if (hGXJobData)        {          GXUnflattenJobFromHdl(theDocument-&gt;documentJob, hGXJobData);          err = GXGetJobError(theDocument-&gt;documentJob);          ReleaseResource(hGXJobData);        }      }      else      {        if (gotQDPrintRec)          GXConvertPrintRecord(theDocument-&gt;documentJob, theDocument-&gt;thePrintSetup);      }          err = LoadDocumentScript( theDocument, resFile );    CloseResFile(resFile);    err = ResError();    if (err)    {      ShowError((unsigned char *)&quot;\pReadFile - CloseResFile&quot;, err);      return(err);    }  }  else    TESetText( *gHandle, GetHandleSize(gHandle), theDocument-&gt;theText );      if (gHandle)    DisposHandle(gHandle);      if (err==fnfErr)    err = noErr;    return(err);} // ReadFile//  Name:       GetFileContents//  Purpose:    Opens the document specified by theFSSpec and puts//           the contents into theDocument.    #pragma segment FileOSErr  GetFileContents( FSSpec theFSSpec, DPtr theDocument ){  OSErr  err;  short  theRefNum;  // this can be called from two places- on an OpenDoc AppleEvent  // and by the user just selecting Open from the File Menu  // assume that the CFS is correct when the routine is called  err = FSpOpenDF( &amp;theFSSpec, fsRdWrPerm, &amp;theRefNum );  if (err)  {    ShowError((unsigned char *)&quot;\pFSpOpenDF&quot;, err);    return(err);  }  else  {    err = ReadFile(theDocument, theRefNum, theFSSpec.name);    if (err)    {      ShowError((unsigned char *)&quot;\pReadFile&quot;, err);      return(err);    }    err=FSClose(theRefNum);    if (err)    {      ShowError((unsigned char *)&quot;\pFSClose&quot;, err);      return(err);    }    return(noErr);  }}    #pragma segment FileOSErr  SaveUsingTemp( DPtr theDocument ){  Str255    tempName;  FSSpec    tempFSSpec;  OSErr    err;    // save the file to disk using a temporary file  // this is the recommended way of doing things  // first write out the file to disk using a temporary filename  // if it is sucessfully written, exchange the temporary file with the last one saved  // then delete the temporary file- so if anything goes wrong, the original version is still there  // first generate the temporary filename    GetTempFileName(theDocument, tempName);  //create this file on disk    tempFSSpec = theDocument-&gt;theFSSpec;  PLstrcpy( tempFSSpec.name, tempName );      err = DoCreate(tempFSSpec);      // now save the file as normal    if (err == noErr)    err = DoSave(theDocument, tempFSSpec);    if (err == noErr)    err = FSpExchangeFiles(&amp;tempFSSpec, &amp;theDocument-&gt;theFSSpec);    // we've exchanged the files, now delete the temporary one    if (err == noErr)    err = FSpDelete(&amp;tempFSSpec);    return(err);}    #pragma segment File//  Fills in the document record with the user chosen destinationOSErr  GetFileNameToSaveAs(DPtr theDocument){        StandardFileReply   reply;  OSErr               err;  Str255              suggestName;    GetWTitle(theDocument-&gt;theWindow, suggestName);    StandardPutFile((unsigned char *)&quot;\pSave Document As:&quot;, suggestName, &amp;reply);    if (reply.sfGood)  {            err = FSpDelete(&amp;reply.sfFile);        if (!((err==noErr) || (err==fnfErr)))      return(err);    else      err = noErr;          theDocument-&gt;theFSSpec = reply.sfFile;    PLstrcpy(theDocument-&gt;theFileName, reply.sfFile.name);  }  else    err = userCanceledErr;    return(err);} // GetFileNameToSaveAs    #pragma segment FileOSErr  DoSave( DPtr theDocument, FSSpec theFSSpec ){  short      refNum;  OSErr      fileErr;    fileErr = FSpOpenDF(&amp;theFSSpec, fsRdWrPerm, &amp;refNum);    if (fileErr == fnfErr)  {    fileErr = DoCreate(theFSSpec);        if (fileErr)      return(fileErr);          fileErr = FSpOpenDF(&amp;theFSSpec, fsRdWrPerm, &amp;refNum);  }    if (fileErr == noErr)  {    fileErr = WriteFile(theDocument, refNum, theFSSpec);        if (fileErr==noErr)      theDocument-&gt;dirty = false;          fileErr = FSClose(refNum);  }  else    FileError((unsigned char *)&quot;\perror opening file &quot;, theFSSpec.name);    return(fileErr);}    #pragma segment FileOSErr  OpenOld( FSSpec aFSSpec ){      DPtr        aDocument;  AEDesc      aDesc = { typeNull, NULL },          aBoundsDesc = { typeNull, NULL };  WindowPropToken  aPropToken;  Str255      aPStr;  OSErr      anErr;    aDocument = NewDocument( true, (WindowPtr)-1L );    SetWTitle( aDocument-&gt;theWindow, aFSSpec.name );    SetPort( aDocument-&gt;theWindow );    aDocument-&gt;theFSSpec   = aFSSpec;    PLstrcpy( aDocument-&gt;theFileName,aFSSpec.name );    aDocument-&gt;dirty       = false;  aDocument-&gt;everSaved   = true;    anErr = GetFileContents( aFSSpec, aDocument );    if ( noErr == anErr )  {      // Try and get the saved script property    if ( kOSANullScript != aDocument-&gt;theScriptID )    {      PLstrcpy( aPStr, &quot;\pwindowbounds&quot; );      anErr = AECreateDesc( typeChar, (Ptr)&amp;aPStr[1], aPStr[0], &amp;aDesc );      if ( noErr != anErr ) goto done;            anErr = GetScriptProperty( aDocument-&gt;theScriptID, &amp;aDesc, &amp;aBoundsDesc );      if ( noErr == anErr )      {    // Set up a token for the document        aPropToken.tokenWindowToken.tokenWindow = aDocument-&gt;theWindow;        aPropToken.tokenProperty = pBounds;              anErr = SetDocumentTokenProperty( &amp;aPropToken, &amp;aBoundsDesc );      }      else        anErr = noErr;  // Script does not have this property    }      ResizeWindow( aDocument );    SelectWindow( aDocument-&gt;theWindow );    ShowMSWindow( aDocument-&gt;theWindow );  }  else    FileError( (unsigned char *)&quot;\pError Opening &quot;, aFSSpec.name );done:  (void)AEDisposeDesc( &amp;aDesc );  (void)AEDisposeDesc( &amp;aBoundsDesc );    return anErr;} // OpenOld/*   #pragma segment FileOSErr  OpenUsingAlias( AliasHandle theAliasH ){  OSErr    err;  FSSpec   aFSSpec;  Boolean  dummy;    err = ResolveAlias(nil, theAliasH, &amp;aFSSpec, &amp;dummy);    if (err == noErr)    err = OpenOld(aFSSpec);          return(err);}*/</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MenuScripter/listing60.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MenuScripter/listing60.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MenuScripter/listing60.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>