<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Memory Usage Performance Guidelines: Memory Management in Mac OS X</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Memory Management in Mac OS X"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20001880" title="Memory Management in Mac OS X"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../DeveloperTools/index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../../DeveloperTools/Performance-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000901" target="_top">Performance</a> &gt; <a href="../index.html" target="_top">Memory Usage Performance Guidelines</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ManagingMemory.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="MemoryAlloc.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20001880-BCICIHAB" title="Memory Management in Mac OS X"></a><hr /><H1>Memory Management in Mac OS X</H1><p>Efficient memory management is an important aspect of writing high performance code in Mac OS X code. Tuning your memory usage can reduce both your application’s memory footprint and the amount of CPU time it uses. In order to properly tune your code though, you need to understand something about how Mac OS X manages memory. </p><p>Unlike earlier versions of Mac OS, Mac OS X includes a fully-integrated virtual memory system that you cannot turn off. It is always on, providing up to 4 gigabytes of addressable space per 32-bit process and approximately 18 exabytes of addressable space for 64-bit processes. However, few machines have this much dedicated RAM for the entire system, much less for a single process. To compensate for this limitation, the virtual memory system uses hard disk storage to hold data not currently in use. This hard disk storage is sometimes called the “swap” space because of its use as storage for data being swapped in and out of memory.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_2" title="Note"></a><p><strong>Note:</strong>&nbsp;Unlike most UNIX-based operating systems, Mac OS X does not use a preallocated swap partition for virtual memory. Instead, it uses all of the available space on the machine’s boot partition. </p></div><p>The following sections introduce terminology and provide a brief overview of the Mac OS X virtual memory system. For more detailed information on how the Mac OS X virtual memory system works, please see <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em>.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="AboutMemory.html#//apple_ref/doc/uid/20001880-99100-TPXREF113">Virtual Memory Theory</a>
				
			<br/>
			
        
			
			
				<a href="AboutMemory.html#//apple_ref/doc/uid/20001880-119066-TPXREF102">Virtual Memory in Mac OS X</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20001880-99100" title="Virtual Memory Theory"></a><a name="//apple_ref/doc/uid/20001880-99100-TPXREF113" title="Virtual Memory Theory"></a><h2>Virtual Memory Theory</h2><p><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_16"></a><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_17"></a>Virtual memory allows an operating system to escape the limitations of physical RAM. A virtual memory manager creates a <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_18"></a>logical address space (or “<a name="//apple_ref/doc/uid/20001880-DontLinkElementID_19"></a>virtual” address space) that is larger than the installed physical memory (RAM) <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_20"></a>and divides it up into uniformly-sized chunks of memory called <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_21"></a><strong>pages</strong>. Each page in the logical address space has a corresponding page on the disk, in a special file known as the <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_22"></a><strong>backing store</strong>. The system then populates the computer’s physical memory with the pages currently in use to give the illusion that the entire logical address space is made up of real memory.</p><p>There are two key features of the processor and its <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_23"></a><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_24"></a>memory management unit (MMU) that you must grasp in order to understand how virtual memory works. The first is the <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_25"></a><strong>page table</strong>, which is a table that maps all logical pages into their corresponding physical pages. When the processor accesses a logical address, the MMU uses the page table to translate the access into a physical address, which is the address that’s actually passed to the computer’s memory subsystem.</p><p>If the translation from a logical page address to a physical address fails, a <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_26"></a><strong>page fault</strong> occurs. The virtual memory system invokes a special page-fault handler to stop executing the current code and respond to the fault. The page-fault handler finds a free page of physical memory, transfers the data from the backing store to the physical page, and then updates the page table so that the page now appears to be at the correct logical address. If no free pages are available in physical memory, the handler must first release an existing page. If that page contains modified data, the handler writes its contents to the backing store before releasing it. This process is known as <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_27"></a><strong>paging</strong>.</p><p>Moving data from physical memory to disk is called <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_28"></a><strong>paging out</strong> (or “swapping out”); moving data from disk to physical memory is called <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_29"></a><strong>paging in</strong> (or “swapping in”). In both Mac OS 9 and Mac OS X, the size of a page<a name="//apple_ref/doc/uid/20001880-DontLinkElementID_30"></a> is 4 kilobytes. Every time a page fault occurs, the system reads 4 kilobytes from disk. Extended periods of paging activity reduce performance significantly; such activity is sometimes called <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_31"></a><strong>disk thrashing</strong>.</p><p>Reading from disk is much slower than reading directly from RAM, just as reading from RAM is always slower than reading directly from the CPU caches. Because a page fault involves reading data from disk, and potentially writing data to disk as well, reducing the number of occurring page faults can have a significant improvement on overall system performance.</p><a name="//apple_ref/doc/uid/20001880-119066" title="Virtual Memory in Mac OS X"></a><a name="//apple_ref/doc/uid/20001880-119066-TPXREF102" title="Virtual Memory in Mac OS X"></a><h2>Virtual Memory in Mac OS X</h2><p>In Mac OS X, each process has its own sparse 32-bit or 64-bit <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_32"></a>virtual address space<a name="//apple_ref/doc/uid/20001880-DontLinkElementID_33"></a>. For 32-bit processes, each process has an address space that can grow dynamically up to a limit of four gigabytes. For 64-bit processes, the address space can grow dynamically up to a limit of approximately 18 exabytes. As an application uses up space, the virtual memory system allocates additional swap file space on the root file system.</p><p>The virtual address space of a process consists of mapped regions of memory. Each region of memory in the process represents a specific set of virtual memory pages. A region has specific attributes controlling such things as inheritance (portions of the region may be mapped from “parent” regions), write-protection, and whether it is “wired” (that is, it cannot be paged out). Because regions contain a given number of pages, they are <strong>page-aligned</strong>,<a name="//apple_ref/doc/uid/20001880-DontLinkElementID_34"></a> meaning the starting address of the region is also the starting address of a page and the ending address also defines the end of a page.</p><p>The kernel associates a <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_35"></a><strong>VM object</strong><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_36"></a> with each region of the virtual address space. The kernel uses the VM object to track and manage the resident and nonresident pages of that region. A region can map either to an area of memory in the backing store or to a specific file-mapped file in the file system. </p><p>The VM object maps regions in the backing store through the default pager and maps file-mapped files through the vnode pager. The <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_37"></a><strong>default pager</strong> is a system manager that maps the nonresident virtual memory pages to backing store and fetches those pages when requested. The <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_38"></a><strong>vnode pager</strong> implements <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_39"></a>file mapping. The vnode pager uses the paging mechanism to provide a window directly into a file. This mechanism lets you read and write portions of the file as if they were located in memory.</p><p>A VM object may point to a pager or to another VM object. The kernel uses this self referencing to implement a form of page-level sharing known as <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_40"></a><strong>copy-on-write</strong>. Copy-on-write allows multiple blocks of code (including different processes) to share a page as long as none write to that page. If one process writes to the page, a new, writable copy of the page is created in the address space of the process doing the writing. This mechanism allows the system to copy large quantities of data efficiently. </p><p>Each VM object contains several fields, as shown in <span class="content_text"><a href="AboutMemory.html#//apple_ref/doc/uid/20001880-99331-BCIIJDBG">Table 1</a></span>.</p><a name="//apple_ref/doc/uid/20001880-99331-BCIIJDBG" title="Table 1Fields of the VM object"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/20001880-99331" title="Table 1Fields of the VM object"></a><strong>Table 1&nbsp;&nbsp;</strong>Fields of the VM object</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Field</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Resident pages</p></td><td ><p>A list of the pages of this region that are currently resident in physical memory.</p></td></tr><tr><td  scope="row"><p>Size</p></td><td ><p>The size of the region, in bytes.</p></td></tr><tr><td  scope="row"><p>Pager</p></td><td ><p>The pager responsible for tracking and handling the pages of this region in backing store.</p></td></tr><tr><td  scope="row"><p>Shadow</p></td><td ><p>Used for copy-on-write optimizations.</p></td></tr><tr><td  scope="row"><p>Copy</p></td><td ><p>Used for copy-on-write optimizations.</p></td></tr><tr><td  scope="row"><p>Attributes</p></td><td ><p>Flags indicating the state of various implementation details.</p></td></tr></table></div><p>If the VM object is involved in a copy-on-write (<code>vm_copy</code>) <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_41"></a>operation, the shadow and copy fields may point to other VM objects. Otherwise both fields are usually <code>NULL</code>.<a name="//apple_ref/doc/uid/20001880-DontLinkElementID_42"></a></p><a name="//apple_ref/doc/uid/20001880-99406" title="Page Lists in the Kernel"></a><a name="//apple_ref/doc/uid/20001880-99406-TPXREF103" title="Page Lists in the Kernel"></a><h3>Page Lists in the Kernel</h3><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_43"></a><p>The kernel maintains and queries three system-wide lists of physical memory pages:</p><ul class="spaceabove"><li class="li"><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_44"></a><p>The <strong>active list</strong> contains pages that are currently mapped into memory and have been recently accessed. </p></li><li class="li"><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_45"></a><p>The <strong>inactive list</strong> contains pages that are currently resident in physical memory but have not been accessed recently. These pages contain valid data but may be released from memory at any time. </p></li><li class="li"><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_46"></a><p>The <strong>free list</strong> contains pages of physical memory that are not associated with any address space of VM object. These pages are available for immediate use by any process that needs them. </p></li></ul><p>When the number of pages on the free list falls below a threshold (determined by the size of physical memory), the pager attempts to balance the queues. It does this by pulling pages from the inactive list. If a page has been accessed recently, it is reactivated and placed on the end of the active list. If an inactive page contains data that has not been written to the backing store recently, its contents must be paged out to disk before it can be placed on the free list. If an inactive page has not been modified and is not permanently resident (wired), it is stolen (any current virtual mappings to it are destroyed) and added to the free list. Once the free list size exceeds the target threshold, the pager rests.</p><p>The kernel moves pages from the active list to the inactive list if they are not accessed; it moves pages from the inactive list to the active list on a soft fault (see <span class="content_text"><a href="AboutMemory.html#//apple_ref/doc/uid/20001880-99598">“Paging Virtual Memory In”</a></span>). When virtual pages are swapped out, the associated physical pages are placed in the free list. Also, when processes explicitly free memory, the kernel moves the affected pages to the free list.<a name="//apple_ref/doc/uid/20001880-DontLinkElementID_47"></a></p><a name="//apple_ref/doc/uid/20001880-99461" title="Allocating and Accessing Virtual Memory"></a><a name="//apple_ref/doc/uid/20001880-99461-TPXREF104" title="Allocating and Accessing Virtual Memory"></a><h3>Allocating and Accessing Virtual Memory</h3><p>Applications usually allocate memory<a name="//apple_ref/doc/uid/20001880-DontLinkElementID_48"></a> using the <code>malloc</code><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_49"></a> routine. This routine finds free space on an existing page or allocates new pages using <code>vm_allocate</code><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_50"></a> to create space for the new memory block. Through the <code>vm_allocate</code> routine, the kernel performs a series of initialization steps:</p><ol class="ol"><li class="li"><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_51"></a><p>It maps a range of memory in the virtual address space of this process by creating a <strong>map entry</strong>; the map entry is a simple structure that defines the starting and ending addresses of the region.</p></li><li class="li"><p>The range of memory is backed by the default pager. </p></li><li class="li"><p>The kernel creates and initializes a VM object, associating it with the map entry.</p></li></ol><p>At this point there are no pages resident in physical memory and no pages in the backing store. Everything is mapped virtually within the system. When a program accesses the region, by reading or writing to a specific address in it, a fault occurs because that address has not been mapped to physical memory. The kernel also recognizes that the VM object has no backing store for the page on which this address occurs. The kernel then performs the following steps for each page fault:<a name="//apple_ref/doc/uid/20001880-DontLinkElementID_52"></a></p><ol class="ol"><li class="li"><p>It acquires a page from the free list and fills it with zeroes.</p></li><li class="li"><p>It inserts a reference to this page in the VM object’s list of resident pages.</p></li><li class="li"><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_53"></a><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_54"></a><p>It maps the virtual page to the physical page by filling in a data structure called the <strong>pmap</strong>. The pmap contains the page table used by the processor (or by a separate memory management unit) to map a given virtual address to the actual hardware address.</p></li></ol><a name="//apple_ref/doc/uid/20001880-104263" title="Paging Virtual Memory Out"></a><a name="//apple_ref/doc/uid/20001880-104263-TPXREF105" title="Paging Virtual Memory Out"></a><h3>Paging Virtual Memory Out</h3><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_55"></a><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_56"></a><p>The kernel continuously compares the number of physical pages in the free list against a threshold value. When the number of pages in the free list dips below this threshold, the kernel reclaims physical pages for the free list by swapping inactive pages out of memory. To do this, the kernel iterates all resident pages in the active and inactive lists, performing the following steps:</p><ol class="ol"><li class="li"><p>If a page in the active list is not recently touched, it is moved to the inactive list.</p></li><li class="li"><p>If a page in the inactive list is not recently touched, the kernel finds the page’s VM object.</p></li><li class="li"><p>If the VM object has never been paged before, the kernel calls an initialization routine that creates and assigns a default pager object.</p></li><li class="li"><p>The VM object’s default pager attempts to write the page out to the backing store.</p></li><li class="li"><p>If the pager succeeds, the kernel frees the physical memory occupied by the page and moves the page from the inactive to the free list.</p></li></ol><a name="//apple_ref/doc/uid/20001880-99598" title="Paging Virtual Memory In"></a><a name="//apple_ref/doc/uid/20001880-99598-BAJDDCEA" title="Paging Virtual Memory In"></a><h3>Paging Virtual Memory In</h3><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_57"></a><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_58"></a><p>The final phase of virtual memory management moves pages in the backing store back into physical memory. A memory access fault <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_59"></a>initiates the page-in process. Memory access faults occur when code tries to access data at a virtual address that is not mapped to physical memory. There are two kinds of faults:</p><ul class="spaceabove"><li class="li"><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_60"></a><p>A <strong>soft fault</strong> occurs when the page of the referenced address is resident in physical memory but is currently not mapped into the address space of this process.</p></li><li class="li"><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_61"></a><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_62"></a><p>A <strong>hard fault</strong> occurs when the page of the referenced address is not in physical memory but is swapped out to backing store (or is available from a mapped file). This is what is typically known as a page fault. </p></li></ul><p>When any type of fault occurs, the kernel locates the map entry and VM object for the accessed region. The kernel then goes through the VM object’s list of resident pages. If the desired page is in the list of resident pages, the kernel generates a soft fault. If the page is not in the list of resident pages, it generates a hard fault.</p><p>For soft faults, the kernel maps the physical memory containing the pages to the virtual address space of the process. The kernel then marks the specific page as active. If the fault involved a write operation, the page is also marked as modified so that it will be written to backing store if it needs to be freed later.</p><p>For hard faults, the VM object’s pager finds the page in the backing store or from the file-mapped file, depending on the type of pager. After making the appropriate adjustments to the map information, the pager moves the page into physical memory and places the page on the active list. As with a soft fault, if the fault involved a write operation, the page is marked as modified. </p><a name="//apple_ref/doc/uid/20001880-99673" title="Shared Memory"></a><a name="//apple_ref/doc/uid/20001880-99673-TPXREF111" title="Shared Memory"></a><h3>Shared Memory</h3><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_63"></a><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_64"></a><p>Shared memory is memory that can be written to or read from by two or more processes. Shared memory can be inherited<a name="//apple_ref/doc/uid/20001880-DontLinkElementID_65"></a> from a parent process, created by a shared memory server, or explicitly created by an application for export to other applications. Uses for shared memory include the following:</p><ul class="spaceabove"><li class="li"><p>sharing large resources such as icons or sounds</p></li><li class="li"><p>fast communication between one or more processes</p></li></ul><p>Shared memory is fragile. If one program corrupts a section of shared memory, any programs that also use that memory share the corrupted data. </p><a name="//apple_ref/doc/uid/20001880-99714" title="Wired Memory"></a><a name="//apple_ref/doc/uid/20001880-99714-TPXREF106" title="Wired Memory"></a><h3>Wired Memory</h3><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_66"></a><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_67"></a><p>Wired memory (also called <strong>resident</strong> memory<a name="//apple_ref/doc/uid/20001880-DontLinkElementID_68"></a>) stores kernel code and data structures that should never be paged out to disk. Applications, frameworks, and other user-level software cannot allocate wired memory. However, they can affect how much wired memory exists at any time. There is memory overhead associated with each kernel resource expended on behalf of a program.</p><p><span class="content_text"><a href="AboutMemory.html#//apple_ref/doc/uid/20001880-99736-BAJJCDEH">Table 2</a></span> lists some of the wired-memory costs for user-generated entities.</p><a name="//apple_ref/doc/uid/20001880-99736-BAJJCDEH" title="Table 2Wired memory generated by user-level software"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/20001880-99736" title="Table 2Wired memory generated by user-level software"></a><strong>Table 2&nbsp;&nbsp;</strong>Wired memory generated by user-level software</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Resource</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Wired Memory Used by Kernel</p></th></tr><tr><td  scope="row"><p>Process</p></td><td ><p>16 kilobytes</p></td></tr><tr><td  scope="row"><p>Thread</p></td><td ><p>blocked in a continuation—5 kilobytes; blocked—21 kilobytes</p></td></tr><tr><td  scope="row"><p>Mach port</p></td><td ><p>116 bytes</p></td></tr><tr><td  scope="row"><p>Mapping</p></td><td ><p>32 bytes</p></td></tr><tr><td  scope="row"><p>Library</p></td><td ><p>2 kilobytes plus 200 bytes for each task that uses it</p></td></tr><tr><td  scope="row"><p>Memory region</p></td><td ><p>160 bytes</p></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/20001880-DontLinkElementID_3" title="Note"></a><p><strong>Note:</strong>&nbsp;These measurements will change with each new Mac OS X release. They are provided here to give you a rough estimate of the relative cost of system resource usage.</p></div><p>As you can see, each thread created, each subprocess forked, and each library linked contributes to the resident footprint of the system.</p><p>In addition to wired memory generated through user-level requests, the following kernel entities also use wired memory:</p><ul class="spaceabove"><li class="li"><p>VM objects</p></li><li class="li"><p>the virtual memory buffer cache</p></li><li class="li"><p>I/O buffer caches</p></li><li class="li"><p>drivers</p></li></ul><p>Wired data structures are also associated with the physical page and map tables used to store virtual-memory mapping information, Both of these entities scale with the amount of available physical memory. Consequently, when you add memory to a system the wired memory increases even if nothing else changes. When the computer is first booted into the Finder, with no other applications running, wired memory consumes approximately 14 megabytes of a 64 megabyte system and 17 megabytes of a 128 megabyte system.</p><p>Wired memory is not immediately released back to the free list when it becomes invalid. Instead it is “garbage collected” when the free-page count falls below the threshold that triggers page out events. <a name="//apple_ref/doc/uid/20001880-DontLinkElementID_69"></a></p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ManagingMemory.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="MemoryAlloc.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-06-28<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html%3Fid%3D10000160i-3.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html%3Fid%3D10000160i-3.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html%3Fid%3D10000160i-3.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
