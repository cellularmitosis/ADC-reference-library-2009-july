<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>OTRcvURequest</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING171></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-170.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-172.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-81.html"><B>Part 2 - Open Transport Reference</B></A><BR><DD><A HREF="NetworkingWOT-127.html"><B>Chapter 22 - Endpoints Reference</B></A> / <A HREF="NetworkingWOT-146.html"><B>Functions</B></A><BR><DL><DD><A HREF="NetworkingWOT-169.html"><B>Functions for Connectionless Transaction-Based Endpoints</B></A> / </DL></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING171-0></A>
<H3><A NAME=MARKER-9-184></A>OTRcvURequest</H3>
 Reads a request sent by a client using a connectionless transaction-based protocol.<P>
<A NAME=HEADING171-2></A>
<H5>C INTERFACE</H5>
<PRE>
<A NAME=MARKER-11-185></A>OSStatus OTRcvURequest(EndpointRef ref,
                                         TUnitRequest* req, 
                                         OTFlags* reqFlags);
</PRE>
<A NAME=HEADING171-4></A>
<H5>C++ INTERFACE</H5>
<PRE>
<A NAME=MARKER-12-186></A>OSStatus TEndpoint::RcvURequest(TUnitRequest* req, 
                                         OTFlags* reqFlags);
</PRE>
<A NAME=HEADING171-6></A>
<H5>PARAMETERS</H5>
<DL>
<DT><CODE>ref</CODE>
<DD> The endpoint reference of the endpoint accepting the request.
<DT><CODE>req</CODE><P>
<DD> A pointer to a <A HREF=NetworkingWOT-140.html#MARKER-9-97><CODE>TUnitRequest</CODE></A> structure  that contains information about the request being received.<P> 
<DT>
<DD> The <CODE>req-&gt;addr</CODE> field specifies the location and size of a buffer containing the address of the endpoint that made the request; the field is filled in by the <CODE>OTRcvURequest</CODE> function when it returns. You must allocate a buffer to hold address information and set the <CODE>req-&gt;addr.buf</CODE> field to point to it. You must also set the <CODE>req-&gt;addr.maxlen</CODE> field to the maximum size of the address.<P>
<DT>
<DD> The <CODE>req-&gt;opt</CODE> field specifies the location and size of a buffer containing the association-related options specified by the requester. Otherwise, this buffer is empty. When the <CODE>OTRcvURequest</CODE> function returns, it places option information in this buffer. You must allocate a buffer to contain the option information and set the <CODE>req-&gt;opt.buf</CODE> field to point to this buffer. You must set the <CODE>req-&gt;opt.maxlen</CODE> field to the maximum size necessary to hold option information for the endpoint.<P>
<DT>
<DD> The <CODE>req-&gt;udata </CODE>field specifies the location and size of a buffer containing the request. You must allocate a buffer into which the <CODE>OTRcvURequest</CODE> function can place the request and set the <CODE>req-&gt;udata.buf</CODE> field to point to it. You must set the <CODE>req-&gt;udata.maxlen</CODE> field to the maximum size of the request data.<P>
<DT>
<DD> The value of the <CODE>req-&gt;sequence </CODE>field is generated by the endpoint provider when you read the request. You need to save this value and use it for the <CODE>req-&gt;sequence</CODE> field when sending a reply or cancelling the transaction.<P>
<DT><CODE>reqFlags</CODE>
<DD> A bitmapped 32-bit value set by the endpoint provider that specifies whether the request is acknowledged (<CODE>T_ACKNOWLEDGED</CODE>) and whether there is more request data coming (<CODE>T_MORE</CODE>) or <CODE>(T_PARTIALDATA)</CODE>. A value of <CODE>T_MORE</CODE> indicates that the buffer you have allocated<CODE> </CODE>is too small to contain the reply. A value of <CODE>T_PARTIALDATA</CODE> indicates that the data unit being read does not contain the complete request. It is possible that all flags are set.<P>
<DT><I>function result</I>
<DD> An error code. See Discussion.
</DL>
<A NAME=HEADING171-15></A>
<H5>DISCUSSION</H5>
 You use the <CODE>OTRcvURequest</CODE> function to read an incoming request. When the function returns, it fills in the <CODE>TUnitRequest</CODE> structure (referenced by the <CODE>req</CODE> parameter) with the address of the sender, the request data, and any association-related options pertaining to this request. If the buffer you allocated for the address is not big enough, the function returns with the <CODE>kOTBufferOverflowErr</CODE> result and the incoming request is dropped.<P>
 If the endpoint is in synchronous mode and is blocking, the <CODE>OTRcvURequest</CODE> function waits for a request to arrive. If the endpoint is in asynchronous mode or is not blocking, the <CODE>OTRcvURequest</CODE> function retrieves the next pending unread request or returns the <CODE>kOTNoDataErr</CODE> result if there are no pending requests.<P>
 If the endpoint is in asynchronous mode, the endpoint provider generates a <CODE>T_REQUEST</CODE> event when a request arrives. You can poll the endpoint using the <A HREF=NetworkingWOT-156.html#MARKER-9-143><CODE>OTLook</CODE></A> function or use a notifier function to retrieve this event. You should then call the funtion to retrieve request data until the function returns with the <CODE>kOTNoDataErr</CODE> result.<P>
 If the <CODE>T_MORE</CODE> bit is set in the <CODE>flags</CODE> parameter, this means your buffer is not large enough to hold the entire request. You must call the <CODE>OTRcvURequest</CODE> function again to retrieve more request data. Open Transport ignores the <CODE>addr</CODE> and <CODE>opt</CODE> fields of the <CODE>req</CODE> parameter for subsequent calls to the <CODE>OTRcvURequest</CODE> function. The <CODE>T_MORE</CODE> flag is not set for the last request packet to let you know that this is the last packet. <P>
 If the <CODE>T_PARTIALDATA </CODE>bit is set in the <CODE>flags</CODE> parameter, this means that the data you are about to read with the <CODE>OTRcvURequest</CODE> function does not constitute the entire request and that you must call the function again to read more of or the rest of the request.<P>
 If the <CODE>T_MORE</CODE> and the <CODE>T_PARTIALDATA</CODE> bits are both set, this means that the data you are about to read constitutes only part of the request and that your buffer is too small to contain even this chunk. In this case, you must call the function again until the <CODE>T_MORE</CODE> flag is clear. The <CODE>T_PARTIALDATA</CODE> bit is set only on the first call to the function.<P>
 If you are communicating with multiple requesters and the <CODE>OTRcvURequest</CODE> function returns with the <CODE>T_PARTIALDATA</CODE> flag set, it is possible that your next call to the <CODE>OTRcvURequest</CODE> function might not read the rest of the request because the next data unit coming in belongs to a different request. One way to handle this situation is to use the next call to the <CODE>OTRcvURequest</CODE> function to determine the sequence number of the incoming request (by setting <CODE>req-&gt;udata.len</CODE> to 0) and then, having determined which request data is coming in, read the data into the appropriate buffer. <P>
 The provider sets the <CODE>T_ACKNOWLEDGED</CODE> flag if the requester has set this flag when calling the <CODE>OTSndURequest</CODE> function. When this flag is set and you call the <CODE>OTSndUReply</CODE> function, Open Transport guarantees that your reply is acknowledged by the requester. This flag is set only on the first call to the <CODE>OTRcvURequest</CODE> function for any given transaction. <P>
<A NAME=HEADING171-24></A>
<H5>SEE ALSO</H5>
 The <A HREF=NetworkingWOT-172.html#MARKER-9-187><CODE>OTSndUReply</CODE></A> function.<P>
 <A HREF=NetworkingWOT-414.html#MARKER-9-27>"AppleTalk Reference"</A>.<P>
 <A HREF=NetworkingWOT-27.html#MARKER-9-12>Table 4-4</A>.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="NetworkingWOT-170.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-172.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
