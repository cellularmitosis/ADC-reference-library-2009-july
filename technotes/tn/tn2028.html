<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><!--Includes revisions to code listings--><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="Stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN2028: Threading Architectures</title><meta name="keywords" content="Mac OS X, Mac OS 9, threading"><meta name="Description" content="Technical Note TN2028: This technote describes the various                  threading APIs on Mac OS 9 and Mac OS X,and how                   those APIs interact with the coreoperating system                   on each platform."><meta name="categories" content="Runtime Architecture, Overview, Operating System and Processes"><meta name="week-posted" content="Aug 6, 2001 - Aug 10, 2001"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003065" title="Threading Architectures"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxProcessManagement-date.html">Process Management</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN2028</div>
<div id="pageheadsub">Threading Architectures</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                   <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle"> CONTENTS  <BR> <BR>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->					<p id="menutext">					<A HREF="#Introduction">Introduction</A><BR><BR><A HREF="#MacOS9Threading">Mac OS 9 Threading</A><BR><BR><A HREF="#MacOSXThreading">Mac OS X Threading</A><BR><BR><A HREF="#MacOSXKernelThreading">Mac OS X Kernel Threading</A><BR><BR><A HREF="#Summary">Summary</A><BR><BR><A HREF="#references">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P> <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>		<td width=300 valign="top" align=left>	<!-- begin_intro_text -->                  <P id=introtext>This technote describes the various                  threading APIs on Mac OS 9 and Mac OS X, and how                  those APIs interact with the core operating system                  on each platform. It is not a practical guide to                  implementing threading, but an architectural                  overview of threading on each OS (with a few hints                  and tips along the way).</P>                                    <P id=introtext>This technote is directed at anyone                  who wants to understand how Mac OS threading works.                  It would be especially beneficial to anyone porting                  a threaded application from Mac OS 9 to Mac OS X,                  where the platform differences may require one to                  revisit previously sensible decisions.</P>                  <!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Aug 08 2001]</h3><!-- end_date -->                </TD>             </TR>          </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR>          <!-- begin_content -->         <P><A NAME=Introduction></A></P>                  <H2>Introduction</H2>                  <P>It should come as no surprise that Mac OS 9 and Mac OS X         have different threading characteristics. While Mac OS X         does support the Mac OS 9 threading APIs (as part of         Carbon), it does so using an entirely different core OS;         this core OS brings with it a number of subtle changes in         behavior of those threading APIs.</P>                  <P>This technote explains the basics of the threading         architecture on both platforms. By understanding the         fundamental design you can understand the subtle differences         in how each platform handles threads. The ultimate goal is         to make it easier for you to tune your threaded application         to match the behavior of each platform. This should yield         better performance for both your application and other         applications on the system.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                  If you're unfamiliar with the overall architecture                  of Mac OS X (you don't know the distinction between                  Mach, BSD, and IOKit), it would be a good idea to                  read the <a href="http://developer.apple.com/documentation/macosx/Essentials/devessentials.html">Inside                  Mac OS X: System Overview</A> before starting this                  technote.</P>               </TD>            </TR>         </TABLE>         </CENTER>                  <P>This technote describes the threading architecture for         Mac OS 9.1 and Mac OS X 10.0.x, specifically. Things are         different on older versions of traditional Mac OS and may be         different on future versions of Mac OS X. Mac OS X is a         rapidly evolving system. You should use this document as a         guide to thinking about threading on Mac OS X, not as the         final word about threading on that platform.</P>                  <P><A HREF="#top">Back to top</A></P>                  <P><A NAME=MacOS9Threading></A></P>                  <H2>Mac OS 9 Threading</H2>                  <P>This section describes threading on Mac OS 9. Mac OS 9         has two threading APIs.</P>                  <UL>            <LI>Thread Manager provides cooperatively scheduled            threads within a process.<BR><BR></li>                        <LI>MP tasks are preemptively scheduled by the            nanokernel.<BR><BR></li>         </UL>                  <P>In addition to these threading APIs, it's impossible to         understand Mac OS 9 threading without also understanding Mac         OS 9 process scheduling, as implemented by the Process         Manager.</P>                  <P>Links to programming documentation for each of these APIs         are given in the <A HREF="#references">References</A>         section at the end of this technote.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                  While the "MP" in "MP tasks" stands for                  "multiprocessor," MP tasks are available and                  scheduled preemptively even on single processor                  systems. You don't need a multiprocessor system to                  take advantage of preemptive threading with MP                  tasks.</P>               </TD>            </TR>         </TABLE>         <BR>         <TABLE BORDER=0 CELLPADDING=3 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                  Threading terminology can get confusing, especially                  on a system like Mac OS X that inherits terminology                  from many different sources. One particularly                  confusing term is "task." The MP API uses the term                  "MP task" to describe a thread of execution with a                  process. On the other hand, Mach uses the term                  "Mach task" to describe a collection of resources                  such as threads, memory, and ports (an idea more                  commonly known as a process). This technote always                  uses either "MP task" or "Mach task" to                  differentiate between these two concepts, and never                  uses the term "task" unqualified.</P>               </TD>            </TR>         </TABLE><BR>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note:</B><BR>                  The title of this section is "Mac OS 9 Threading,"                  not "Traditional Mac OS Threading." This section                  does not describe any obsolete traditional Mac OS                  threading concepts, such as:</P>                                    <UL>                     <LI>custom threading libraries that were popular                     before the introduction of Thread Manager,<BR><BR></li>                                          <LI>preemptively scheduled Thread Manager                     threads that were only supported on 68K                     systems, or<BR><BR></li>                                          <LI>Multiprocessing Services prior to version                     2.0 (Mac OS 8.6). These were implemented by a                     shared library outside of the nanokernel and                     were not generally useful because they only                     worked with VM off.<BR><BR></li>                  </UL>               </TD>            </TR>         </TABLE></CENTER>                  <H3>Mac OS 9 Without MP Tasks</H3>                  <P>If you temporarily ignore MP tasks, the Mac OS 9         threading architecture is shown in Figure 1.</P>                  <TABLE BORDER=0 CELLPADDING=0 WIDTH=480>            <TR>               <td align="left">                   <P align=center><img src="images/tn2028_1.gif" width=368 height=350 align=bottom alt="MacOS09.gif"><BR>                  <B>Figure 1</B>. Mac OS 9 threading.</P>               </TD>            </TR>         </TABLE>                  <P>In this architecture, all scheduling is done         cooperatively. Each process is round-robin scheduled by the         Process Manager when the process calls a yielding function         such as <CODE>WaitNextEvent</CODE>. Within each process         there is a set of cooperatively scheduled threads, which are         scheduled by the Thread Manager when the process calls         <CODE>YieldToAnyThread</CODE> (or         <CODE>YieldToThread</CODE>).</P>                  <P>You can draw a number of conclusions from this         diagram:</P>                  <UL>            <LI>Each process instantiates its own copy of the Thread            Manager, which is responsible for scheduling threads            solely within that process's context.<BR><BR></li>                        <LI>Every thread belongs to a one specific process            context.<BR><BR></li>                        <LI>Because Thread Manager threads are always attached to            a process and there is no system process, there is no way            to create a system Thread Manager thread.<BR><BR></li>                        <LI>When you yield to a thread, you are yielding to a            thread in your process. There is no way for your process            to directly yield to a thread in another process. Your            threads must yield to your main thread, which in turns            calls <CODE>WaitNextEvent</CODE>, which causes the            Process Manager to schedule the other process's main            thread, which can then yield to its threads.<BR><BR></li>                        <LI>There is no way to yield to another process without            handling user interface events. See DTS Q&amp;A PS 06            <a href="../../qa/ps/ps06.html">Yielding            Time Without Getting Events</A> for more on this            topic.<BR><BR></li>                        <LI>Because cooperative threads are local to your            process, and thus don't involve any "kernel" resources,            they are very lightweight and context switches between            threads are cheap.<BR><BR></li>         </UL>                  <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note:</B><BR>                  Some of the blanket statements above have                  noteworthy exceptions. For example, Apple software,                  such as NSL, does create system-wide Thread                  Manager threads. However, the mechanism that it                  uses is both private and not particularly pleasant.                  In addition, it is legal to call                  <CODE>WaitNextEvent</CODE> from a thread other than                  your main thread, but doing so tends to cause                  confusion. The confusion arises because you can't                  call <CODE>WaitNextEvent</CODE> without also                  accepting user events, which means you have to                  handle user events on your non-main thread.</P>               </TD>            </TR>         </TABLE>         </CENTER>                  <P>One important feature of Mac OS 9 threading is that         Process Manager processes are very expensive. They consume a         lot of resources (processes have fixed-size memory         partitions) and, for historical reasons, the context switch         time between processes is very expensive.</P>                  <H3>Mac OS 9 With MP Tasks</H3>                  <P>If you consider MP tasks, Mac OS 9's threading         architecture is only slightly more complex, as shown in         Figure 2.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=480>            <TR>               <td align="left">                    <P><img src="images/tn2028_2.gif" width=453 height=311 align=bottom alt="MacOS9WithMP.gif"><BR>                                    <B>Figure 2</B>. Mac OS 9 threading showing MP                  tasks.</P>               </TD>            </TR>         </TABLE></center>                  <P>The entire cooperative environment runs within a single         MP task. This task is known as the <b>blue         task</b>. All Process Manager processes and all Thread         Manager threads are executed by the blue task. Other MP         tasks, created either by the system or by an application,         are executed as separate entities. The nanokernel schedules         tasks to run on the processor (or processors) in a         preemptive fashion.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                  Figure 2 is a highly simplified representation of                  the nanokernel task scheduler. The scheduler has to                  deal with numerous complications that aren't                  represented here:</P>                                    <UL>                     <LI>It must never run a task that's blocked (for                     example, waiting for queue).<BR><BR></li>                                          <LI>On MP systems it must schedule tasks for                     each processor.<BR><BR></li>                                          <LI>It must account for the various tasks'                     scheduling weights and latency                     requirements.<BR><BR></li>                  </UL>               </TD>            </TR>         </TABLE>         </CENTER>                  <P>You should note the following consequences of this         architecture:</P>                  <UL>            <LI>The nanokernel preemptively schedules all MP tasks,            including the blue task, using its own internal            scheduling policies. While you can affect these policies            (for example, by calling <CODE>MPSetTaskWeight</CODE>)            you are no longer in direct control of your scheduling            points as you were with the Process Manager and Thread            Manager. In fact, if the blue task is running the 68K            emulator it can be preempted by another MP task midway            through a single 68K instruction!<BR><BR></li>                        <LI>The system tracks the MP tasks created by a process            and ensures that these MP tasks are terminated when the            process terminates. This relationship is shown by the            magenta lines in Figure 2. However, as far as the            nanokernel's task scheduler is concerned, all MP tasks            are considered equal. The nanokernel can preempt process            A's MP task and immediately switch to one of process B's            MP tasks.<BR><BR></li>                        <LI>However, the nanokernel has a number of special cases            for the blue task. For example, when an MP task takes a            page fault the nanokernel blocks that task then sends a            software interrupt to the blue task to resolve the page            fault. However, from the perspective of an external            developer, all MP tasks are created equally.<BR><BR></li>                        <LI>Only software running in the blue task has access to            the 68K emulator. This means that MP tasks can            directly use only a limited set of system services. This set            of services is documented in DTS Technote 2006 <a href="tn2006.html">MP-Safe            Routines</A>. Non-MP safe routines can be called via            <CODE>MPRemoteCall</CODE>.<BR><BR></li>                        <LI>The system providers both high- and low-latency            communications between MP tasks and the blue task.                        <UL>               <LI>An MP task can use <CODE>MPRemoteCall</CODE>               (passing either <CODE>kMPAnyRemoteContext</CODE> or               <CODE>kMPOwningProcessRemoteContext</CODE> to the               <CODE>context</CODE> parameter) to request that the               blue task call a function at system task time. Because               this function runs at system task time, there is a               significant delay between when it is scheduled and               when it is executed. The system must wait until the               blue task calls one of the standard Process Manager               descheduling routines (<CODE>WaitNextEvent</CODE>,               <CODE>EventAvail</CODE>, and so on) before it can               execute the function. However, the function is run at               system task time, and thus has access to virtually all               Mac OS system calls. As an example of how this service               is used, <CODE>MPAllocateAligned</CODE> uses               <CODE>MPRemoteCall</CODE> when it needs to grow the               process's MP memory pool because the underlying Mac OS               Memory Manager must be called at system task               time.<BR><BR></li>                              <LI>Mac OS 9.0 and above allow an MP task to send a               software interrupt to the blue task. This software               interrupt is called with very little delay because it               doesn't have to wait for the blue task to call a               Process Manager descheduling routines. However, the               software interrupt runs at interrupt time, and can               only call system services that are interrupt-safe (see               DTS Technote 1104 <a href="tn1104.html">Interrupt-Safe               Routines</A>). Your code can schedule a software               interrupt using either <CODE>MPRemoteCall</CODE>               (under Mac OS 9.1 and above, passing               <CODE>kMPInterruptRemoteContext</CODE> to the               <CODE>context</CODE> parameter) or               <CODE>DTInstall</CODE> (Mac OS 9.0 and above).<BR>               <BR>               <TABLE BORDER=0 CELLPADDING=3 WIDTH=500>                  <TR>                     <td bgcolor="#E6E6E6" align=left>                        <P><B>Note:</B><BR>                        This software interrupt mechanism enables MP                        tasks to call synchronous File Manager                        routines on Mac OS 9.0 and later. When an MP                        task calls the File Manager, the File Manager                        puts the request on a queue and schedules a                        software interrupt to do the actual work at                        interrupt time within the blue task.</P>                     </TD>                  </TR>               </TABLE>               <BR>               <TABLE BORDER=0 CELLPADDING=3 WIDTH=500>                  <TR>                     <td bgcolor="#E6E6E6" align=left>                        <P><B>IMPORTANT:</B><BR>                        Do not confuse the software interrupt                        mechanism described above with the software                        interrupts described in <a href="http://developer.apple.com/documentation/hardware/DeviceManagers/pci_srvcs/pci_cards_drivers/index.html">Designing                        PCI Cards and Drivers for Power Macintosh                        Computers</A>. While conceptually similar                        (hence the names), the mechanisms are                        completely different. In fact, the latter is                        a Copland construct and was never actually                        implemented properly on traditional Mac                        OS.</P>                     </TD>                  </TR>               </TABLE>               <BR><BR></li>            </UL>            <BR><BR></li>         </UL>                  <P><A HREF="#top">Back to top</A></P>                  <P><A NAME=MacOSXThreading></A></P>                  <H2>Mac OS X Threading</H2>                  <P>This section describes threading on Mac OS X, which         provides five different threading APIs:</P>                  <ol>            <LI>Mach threads represent the lowest level threading on            the system.<BR><BR></li>                        <LI>POSIX threads (pthreads) are layered on top of Mach            threads.<BR><BR></li>                        <LI>Cocoa threads (NSThreads) are layered directly on top            of pthreads.<BR><BR></li>                        <LI>Carbon MP tasks, which are API compatible with the MP            tasks in Mac OS 9, are layered on top of pthreads.<BR><BR></li>                        <LI>Carbon Thread Manager cooperative threads, which are            also API compatible with their Mac OS 9 equivalent, are            also layered on top of pthreads.<BR><BR></li>        </ol>                  <P>The <a href="http://developer.apple.com/documentation/Carbon/CarbonSpecification/CarbonSpecTOC.html">Carbon         Specification</A> describes some of the issues you might         encounter when porting MP task or Thread Manager code to         Carbon on Mac OS X.</P>                  <P>One useful way to think about Mac OS X's various         threading APIs is to arrange them in an layered hierarchy.         For example, each MP task is layered on top of a pthread,         and each pthread is layered on top of a Mach thread. This         hierarchy is shown in Figure 3.</P>                  <A NAME=ClassHierarchy></A>         <CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=480>            <TR>               <td align="left">                                                      <P><img src="images/tn2028_3.gif" width=236 height=196 align=bottom alt="MacOSXThreadHierarchy.gif"><BR>                                    <B>Figure 3</B>. Mac OS X thread layering                  hierarchy.</P>               </TD>            </TR>         </TABLE></center>                  <P>Links to programming documentation for each of these APIs         are given in the <A HREF="#references">References</A>         section at the end of this technote.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note:</B><BR>                  Carbon implements a private threading abstraction                  layer known as Thread Support (TS) which is layered                  on top of pthreads. Both MP tasks and Thread                  Manager threads are currently layered on top of TS                  threads. Thread Support (TS) is not exposed as a                  public API and may well be removed in a future                  release of Mac OS X.</P>               </TD>            </TR>         </TABLE>         </CENTER>                  <H3>Thread API Choice</H3>                  <P>With five public threading APIs to choose from, it can be         hard to decide which threading API to use. Here are some         general guidelines:</P>                  <UL>            <LI>User-space processes should not create Mach threads            directly.<BR><BR></li>                        <LI>If you're working within the Cocoa environment,            NSThreads are the obvious choice, although pthreads are            also available and may make sense in some cases. For            example, your Cocoa user interface might be acting as a            front end to some existing code that already uses            pthreads.<BR><BR></li>                        <LI>If you're working in the Carbon environment the first            decision you have to make is whether you can use            preemptive threads or whether you must use cooperative            threads. Many Carbon calls are not available to            preemptive threads, even on Mac OS X. However, if you can            use preemptive threads then you should; it's difficult to            <a href="../../qa/qa2001/qa1061.html">integrate            cooperative threads into a well-behaved Mac OS X            application</A>.<BR><BR></li>                        <LI>If your Carbon application has to use cooperative            threads, your only choice is Thread Manager.<BR><BR></li>                        <LI>If your Carbon application can use preemptive            threads, you can choose either pthreads or MP tasks.            However, you should take note of the following:<BR><BR>                        <UL>               <LI>pthreads are not available on Mac OS 9.<BR><BR></li>                              <LI>Mac OS X does not provide a CFM binding for               pthreads. If you want to call pthreads from a CFM               application, you must create your own CFM-to-Mach-O               glue. The <a href="http://developer.apple.com/sdk/">CarbonLib               SDK</A> includes a number of samples that show how to               do this.<BR><BR></li>            </UL>            </li>                        <LI>In all cases it's acceptable to mix different threads            within the same process. For example, your Carbon            application can create cooperative threads and MP tasks.            Or your Cocoa application might use NSThreads and            pthreads.<BR><BR></li>                        <LI>You must be careful when mixing thread APIs on the            same thread. This problem is described in a <A HREF="#MixNMatch">later            section</A>.<BR><BR></li>         </UL>                  <P>In contrast to Mac OS 9, all threads have roughly equal         cost on Mac OS X. The overhead of wrapping a pthread up as         an NSThread, MP task, or cooperative thread is small         compared to the overhead of the base Mach thread. This also         means that cooperative threads are more expensive (relative         to other types of threads) than they are on Mac OS 9. For         more details on the cost of threads in Mac OS X, see         <a href="http://developer.apple.com/documentation/macosx/Essentials/devessentials.html">Inside         Mac OS X: Performance</A>.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note:</B><BR>                  Apple recognizes that using a Mach thread per                  Thread Manager thread is expensive and is looking                  at ways to reduce this cost in the future. However,                  this change is not in Mac OS X 10.0.x and will not                  be in Mac OS X 10.1.</P>               </TD>            </TR>         </TABLE>         </CENTER>                  <P>Thread context switch time can vary depending on the         threading API you choose. The overhead for an involuntary         context switch and to block for I/O in the kernel is the         same regardless of how you created the thread. The overhead         for other context switches (for example, waiting on a         semaphore) depends on the API you choose, with higher-level         APIs generally being slower.</P>                  <H3>Mac OS X Thread Scheduling</H3>                  <P>One consequence of the thread hierarchy described earlier         is that ultimately all threads are represented by Mach         threads. As far as Mach is concerned, all threads are equal.         When choosing a thread to run, the Mach scheduler always         follows its <A HREF="#MachPolicy">scheduling policies</A> to         choose the next thread to run. It does not care whether the         Mach thread was created as a pthread, an MP task, a         cooperative thread, and so on. Thus you can represent the         Mach scheduling as a single flat ring, as shown in Figure         4.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=480>            <TR>               <td align="left">                                                      <P><img src="images/tn2028_4.gif" width=450 height=304 align=bottom alt="MacOSXThreads.gif"><BR>                                    <B>Figure 4</B>. The Mach thread scheduler                  (highly simplified).</P>               </TD>            </TR>         </TABLE></CENTER>         <BR>         <TABLE BORDER=0 CELLPADDING=3 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>IMPORTANT:</B><BR>                  Figure 4 is a highly simplified representation of                  the Mach thread scheduler. The scheduler has to                  deal with numerous complications that aren't                  represented here:</P>                                    <UL>                     <LI>It must never run a thread that's blocked                     (for example, waiting for I/O or a mutex).<BR><BR></li>                                          <LI>On MP systems it must schedule threads for                     each processor.<BR><BR></li>                                          <LI>It must follow the various threads'                     <A HREF="#MachPolicy">scheduling policies and                     priorities</A>.<BR><BR></li>                  </UL>                                    <P>In addition, each Mach thread is owned by a                  particular Mach task. The relationship between                  threads and tasks is not represented in Figure 4,                  although in some scheduling policies this                  relationship is important.</P>               </TD>            </TR>         </TABLE>                  <P>To understand how cooperative threads are implemented, you         need to turn this diagram on its side and look at how         abstractions are layered on top of the fundamental Mach         threads. Figure 5 shows this. At the bottom layer of each         abstraction stack is the Mach thread that is actually         scheduled by the kernel. Some Mach threads exist in their         raw form (typically these threads are created to execute         within the <A HREF="#MacOSXKernelThreading">kernel</A>). All         user space Mach threads have a pthread layered on top of         them. Threads created by Cocoa applications have an NSThread         layered on top of that. Carbon can created threads both for         itself and to implement higher-level threading APIs. If the         thread is created for <A HREF="#CarbonAndInterrupts">internal         use by Carbon</A>, it is implemented a very simple wrapper         around a pthread. If the thread is created by Carbon at the         behest of a Carbon application, it is also a pthread but         with either a Thread Manager thread or an MP task layered on         top of it.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=480>            <TR>               <td align="left">                                                      <P><img src="images/tn2028_5.gif" width=299 height=183 align=bottom alt="MacOSXThreadsStacked.gif"><BR>                                    <B>Figure 5</B>. Mac OS X thread abstractions                  with cooperative thread token rings.</P>               </TD>            </TR>         </TABLE></center>                  <P>Carbon ensures that all Thread Manager threads created         within a single process are scheduled cooperatively. Each         process has a special synchronization token (the token is         implemented as a Mach message) that is passed between the         cooperative threads within the process. If the cooperative         thread has the token it is allowed to run. If it does not         have the token, it must block waiting for it. When the         cooperative thread that has the token calls to         <CODE>YieldToAnyThread</CODE>, Carbon chooses the next         cooperative thread to run and passes the token to it. The         new thread starts running and the original thread blocks         waiting for the token.</P>                  <P>This token passing arrangement is represented by the red         lines in Figure 5.</P>                  <H3><A NAME=MachPolicy></A>Mach Scheduling Policies and         Priorities</H3>                  <P>A Mach thread's <b>policy</b> controls the         algorithm used to schedule the thread. The recommended         thread policies on Mac OS X are:</P>                  <UL>            <LI>the standard policy            (<CODE>THREAD_STANDARD_POLICY</CODE>), under which            threads are scheduled by a system-defined fair            algorithm<BR><BR></li>                        <LI>the time constraint policy            (<CODE>THREAD_TIME_CONSTRAINT_POLICY</CODE>), under which            threads are scheduled according to real-time constraints,            and<BR><BR></li>                        <LI>the precedence policy            (<CODE>THREAD_PRECEDENCE_POLICY</CODE>), which allows a            task to specify the importance of a thread relative to            the task's other threads.<BR><BR></li>         </UL>                  <P>For each policy there are a number of <B>policy         parameters</B> that control how the thread acts within that         policy. These parameters are roughly equivalent to the         common idea of thread priority. For example, threads using         the precedence policy have an "importance" parameter that         controls the thread's priority with respect to other threads         within that task. However, this simplistic equivalence         breaks down for more the more complex time constraint         policy, where the policy parameters are actually a number of         real-time values.</P>                  <P>Each threading API has its own idea of thread priorities.         For example, MP tasks have the concept of task weight (as         defined by <CODE>MPSetTaskWeight</CODE>), while pthreads         have thread scheduling parameters (set by         <CODE>pthread_setschedparam</CODE>). Each threading API maps         from its concept of priority to the underlying Mach policy         and policy parameters. In general these algorithms are         private and subject to change; however, you can learn more         about how pthreads does this mapping by reading the         <A HREF="#references">Darwin source</A>.</P>                  <P>To learn more about Mac OS's recommended thread policies,         see &lt;mach/thread_policy.h&gt;. Mac OS X also supports         some older, deprecated thread policies, which are defined in         &lt;mach/policy.h&gt;.</P>                  <H3>Mac OS X Thread Miscellanea</H3>                  <P>This section covers a number of miscellaneous topics         related to threading on Mac OS X.</P>                  <H4>Main Threads</H4>                  <P>The main thread is a valid thread for all threading APIs.         For example, you can call <CODE>MPTaskIsPreemptive</CODE>         (an MP API) and <CODE>ThreadCurrentStackSpace</CODE> (a         Thread Manager API) on the main thread. While this breaks a         strict interpretation of the hierarchy shown in <A HREF="#ClassHierarchy">Figure         3</A>, it is generally considered useful.</P>                  <H4><A NAME=CarbonAndInterrupts></A>Carbon and         Interrupts</H4>                  <P>Traditional Mac OS makes heavy use of asynchronous I/O         with I/O completion routines that are delivered at interrupt         time. However, the Mac OS X core OS does not support a         callback-based asynchronous I/O model, and user space code         never runs at interrupt time. Carbon simulates asynchronous         I/O completion routines using preemptive threads.</P>                  <P>For example, when you make an asynchronous File Manager         request, Carbon simply puts the request on an internal queue         and wakes up its asynchronous file I/O thread. That thread         pulls the first item off the queue, executes it         synchronously, and then calls its completion routine. If         there are no more items on the queue the thread goes to         sleep. The upshot of this is that the operations appear to         operate asynchronously even though the underlying core OS         does not have an asynchronous file system API.</P>                  <P>Carbon uses techniques like this for many different         interrupt time callback-based APIs, including File Manager,         Time Manager, Deferred Task Manager, and Open Transport.         Each subsystem creates its own pthread for making         callbacks.</P>                  <P>This design has a number of interesting consequences.</P>                  <UL>            <LI>As with traditional Mac OS, Carbon I/O completion            routines are serialized within a given subsystem. For            example, there is only one File Manager asynchronous I/O            thread;, therefore, it can only be calling one completion            routine at a time. This is generally considered a good            thing.<BR><BR></li>                        <LI>The fact that the file system subsystem within Carbon            has only one thread for all asynchronous file I/O within            a given process means that asynchronous file I/O is            serialized. This is much like the File Manager on            traditional Mac OS. However, the Mac OS X core OS does            support multiple outstanding I/O requests. If you want to            exploit this facility you should create multiple threads            and have each thread do its own synchronous I/O.<BR><BR></li>                        <LI>Carbon's I/O completion model differs from            traditional Mac OS in that I/O completion routines do not            "run to completion." Your I/O completion routine is            executed by a preemptive thread. While this thread has a            higher priority than the process's main thread, there is            no guarantee that the I/O completion thread won't be            preempted by that main thread. For example, if the I/O            completion thread takes a page fault, Mach could decide            to run the process's main thread. Moreover, if you're            running on a multiprocessor system, the I/O completion            thread and your main thread could be running            simultaneously. If your application's synchronization            model assumes that I/O completion routines run to            completion, this change in system behavior can create            bugs that are hard to reproduce, hard to debug, and hard            to fix.<BR><BR></li>                        <LI>Because all Carbon "interrupts" are actually executed            by a preemptive thread, it stands to reason than any            interrupt-safe routine is also preemptive-safe (on Mac OS            X).<BR><BR></li>         </UL>                  <H4><A NAME=MixNMatch></A>Mix 'n' match</H4>                  <P>With all of these threading APIs available, it's         inevitable that at some point you will want to mix and match         threads and their APIs. For example, you might want to call         a Mach thread API on an MP task, or maybe an MP call on a         pthread. If one thread is layered on top of another thread         (assuming the layering hierarchy from <A HREF="#ClassHierarchy">Figure         3</A>), you can, in general, do low-level operations on the         high-level thread. For example, most pthread calls are safe         to make on MP tasks. There are, however, a number of issues         to consider.</P>                  <P>The first issue is how to get a reference to the         low-level thread. Only the pthread API provides an explicit         mechanism to get a reference to the underlying thread         (<CODE>pthread_mach_thread_np</CODE> returns the Mach thread         for a given pthread). All of the other thread APIs provide         no explicit support for this. The only way to get a         reference to the low-level thread is to call the low-level         "self" (or "current thread") API while in the context of the         high-level thread. For example, to find the pthread for an         MP task you can call <CODE>pthread_self</CODE> from within         the MP task.</P>                  <P>Another question is whether low-level operations actually         work on a high-level thread. In general, most pthread APIs         are safe on pthreads created by the higher-level thread         APIs. On the other hand, you should be very careful when         making Mach thread calls on pthreads (and hence on threads         created by any high-level API). In general, it is not         appropriate to make Mach thread calls on pthreads. Some         exceptions are the Mach APIs for getting thread information,         setting up thread exception handlers, and death         notification, which should work for any Mach thread         regardless of how it was created.</P>                  <P>Finally, given that most high-level threads are         implemented in terms of pthreads, is it safe to use         high-level thread APIs on an arbitrary pthread? For example,         is it safe to call MP API routines on a pthread? This         approach definitely breaks the thread layering hierarchy and         is not recommended. One notable, and useful, exception is         that it is safe to make MP API synchronization calls         (<CODE>MPNotify</CODE>/<CODE>WaitOnQueue</CODE>,         <CODE>MPSignal</CODE>/<CODE>WaitOnSemaphore</CODE>,         <CODE>MPEnter</CODE>/<CODE>ExitCriticalRegion</CODE>, and         <CODE>MPSet</CODE>/<CODE>WaitForEvent</CODE>) on a pthread.         This is useful because it allows you to use MP API routines         to synchronize between your main thread and <A HREF="#CarbonAndInterrupts">Carbon         "interrupts</A>."</P>                  <P><A HREF="#top">Back to top</A></P>                  <P><A NAME=MacOSXKernelThreading></A></P>                  <H2>Mac OS X Kernel Threading</H2>                  <P>On traditional BSD-based systems the kernel is divided         into upper and lower halves. The upper half is executed by         the user thread that made a particular kernel call. It can         block (sleep) while waiting for I/O to complete or for         access to shared kernel resources. The lower half is         executed as the result of hardware interrupts. Interrupts         must not block. The upper half synchronizes with the lower         half by disabling interrupts. <A HREF="#references">McKusick,         et al.,</A> provide a more in depth explanation of this         design.</P>                  <P>While Mac OS X uses a large part of the BSD kernel source         code, it is not a traditional BSD system. Its Mach         underpinnings require a rework of the BSD kernel         synchronization mechanism. For example, Mach supports         multiprocessor systems, so disabling interrupts is no longer         a sufficient synchronization guarantee.</P>                  <P>The upper half of the Mac OS X BSD kernel still runs in         the context of the user thread that made the kernel call.         However, the lower half is no longer executed in a hardware         interrupt context. Hardware interrupts have a tiny scope         within Mac OS X. When the hardware interrupt occurs it         simply wakes up an IOKit workloop thread. These workloop         threads are <b>kernel threads</b>; they are owned         by the kernel, not by any BSD process. The workloop thread         is the entity that executes the lower half of the BSD         kernel. This means that the BSD kernel synchronization         approach (using <CODE>splx</CODE> calls to disable         interrupts) no longer works on Mac OS X; the upper and lower         halves of the BSD kernel could be running on different         threads on different processors!</P>                  <P>The solution to this problem is the kernel funnel. The         <b>kernel funnel</b> is a mutex that prevents more         than one thread from running inside the BSD portions of the         kernel at the same time. Each thread acquires the kernel         funnel when it enters the BSD portion of the kernel, and         releases it when it leaves. In addition, if a thread blocks         (sleeps) while holding a funnel, it automatically drops the         funnel, and thus allows other threads to enter the         kernel.</P>                  <P>Mac OS X 10.0.x implements <B>split funnels</B>. There is         one funnel for the networking part of the kernel, and one         funnel for the other BSD parts of the kernel (file system,         process management, device management, and so on). This         split results in a significant performance improvement for         tasks that use both the disk and the network. Future         versions of Mac OS X may use even more funnels, allowing         even greater kernel re-entrancy, and even greater         performance.</P>                  <P>As far as the Mach scheduler is concerned, threads         running within the BSD kernel are like any other Mach         thread. One particularly interesting consequence of this is         <b>kernel preemption</b>. When a high priority         thread wakes up it will preempt a thread running within the         BSD kernel. This happens regardless of whether the high         priority thread is a kernel thread or a user thread. As long         as the high priority thread does not attempt to acquire a         kernel funnel (that is, it makes no BSD system calls), it         can do its job despite the limited re-entrancy of the BSD         parts of the kernel. This design allows Mac OS X to meet the         real-time goals required by its real-time components, such         as the highly responsive audio playback engine.</P>                  <P><A HREF="#top">Back to top</A></P>                  <P><A NAME=Summary></A></P>                  <H2>Summary</H2>                  <P>With five different threading APIs, Mac OS X threading         looks complicated, but it's actually simpler than Mac OS 9         threading. All you have to do is understand the fundamental         concepts:</P>                  <UL>            <LI>Ultimately all threads are layered on top of Mach            threads.<BR><BR></li>                        <LI>The layers can be arranged into an <A HREF="#ClassHierarchy">hierarchy</A>.<BR><BR></li>                        <LI>You have to be careful when <A HREF="#MixNMatch">mixing            thread APIs</A> on threads from different layers.<BR><BR></li>                        <LI>When scheduling threads, Mach ignores the threading            API that created the thread.<BR><BR></li>                        <LI>Carbon "interrupt" routines are <A HREF="#CarbonAndInterrupts">simulated</A>            using preemptive threads.<BR><BR></li>         </UL>                  <P><A NAME=references></A></P>                  <H2>References</H2>                  <P><a href="http://developer.apple.com/documentation/macosx/Essentials/devessentials.html">Inside         Mac OS X: System Overview</A></P>                  <P>DTS Q&amp;A PS 06 <a href="../../qa/ps/ps06.html">Yielding         Time Without Getting Events</A> -- This describes why it is         impossible to yield to other processes without handling user         interface events on traditional Mac OS.</P>                  <P>DTS Q&amp;A 1061 <a href="../../qa/qa2001/qa1061.html">RunApplicationEventLoop         and Thread Manager</A> -- This discusses the problems with         integrating cooperative threads into         <CODE>RunApplicationEventLoop</CODE>-based Carbon         application.</P>                  <P>DTS Technote 1104 <a href="tn1104.html">Interrupt-Safe         Routines</A></P>                  <P>DTS Technote 2006 <a href="tn2006.html">MP-Safe         Routines</A></P>                  <P><a href="http://developer.apple.com/documentation/Carbon/CarbonSpecification/CarbonSpecTOC.html">Carbon         Specification</A> -- Describes some of the issues you might         encounter when porting MP task or Thread Manager code to         Carbon on Mac OS X.</P>                  <P><A HREF="http://www-2.cs.cmu.edu/afs/cs/project/art-6/www/osf.html">Mach 3 Kernel Principles and Interfaces</A> -- While these         documents are somewhat out of date, they're still a valuable         introduction to the Mach 3 kernel and its programming         APIs.</P>                  <P><A HREF="http://www.opensource.apple.com/">Darwin</A> -- The         source code for Mac OS X's kernel (CVS module "xnu") and         pthreads library (CVS module "Libc") is available as part of         Apple's open source efforts.</P>                  <P>The Open Group's <A HREF="http://www.opengroup.org/">Single         UNIX Specification</A> -- This includes reference         documentation for the pthreads API.</P>                  <P>David R Butenhof , <CITE>Programming with POSIX         Threads</CITE>, Addison-Wesley, 1997, ISBN: 0201633922 -- A         good introduction to pthreads programming for UNIX         systems.</P>                  <P><a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/ObjC_classic/Classes/NSThread.html">NSThread         Class</A> -- This is the reference documentation for the         NSThread class.</P>                  <P><a href="http://developer.apple.com/documentation/mac/Processes/Processes-2.html">Inside         Macintosh: Processes</A> -- This book describes the Process         Manager and its APIs.</P>                  <P><a href="http://developer.apple.com/documentation/mac/Toolbox/Toolbox-2.html">Inside         Macintosh: Macintosh Toolbox Essentials</A> -- This book         includes a chapter on the Event Manager, which describes the         all-important <CODE>WaitNextEvent</CODE> call.</P>                  <P><a href="http://developer.apple.com/documentation/macos8/pdf/ThreadManager.pdf">Inside         Macintosh: Thread Manager</A> -- This book describes the Mac         OS 9 Thread Manager.</P>                  <P><a href="http://developer.apple.com/documentation/Carbon/oss/ThreadManager/Thread_Manager/index.html">Inside         Carbon: Thread Manager</A> -- This describes the Carbon         Thread Manager.</P>                  <P><a href="http://developer.apple.com/documentation/Carbon/oss/MultiPServices/multiprocessingservices.html">Adding         Multitasking Capability to Applications Using         Multiprocessing Services</A> -- This describes the Mac OS 9         MP task API.</P>                  <P><a href="http://developer.apple.com/documentation/Carbon/oss/MultiPServices/multiprocessingservices.html">Adding         Multitasking Capability to Applications Using         Multiprocessing Services</A> -- This describes the Carbon MP         task API.</P>                  <P><a href="http://developer.apple.com/documentation/macosx/Essentials/devessentials.html">Inside         Mac OS X: Performance</A> -- This book contains information         about the memory cost of threads on Mac OS X.</P>                  <P>Marshall Kirk McKusick, et al., <CITE>The Design and         Implementation of the 4.4BSD Operating System</CITE>,         Addison-Wesley, 1996, ISBN: 0201549794</P>                  <P><A HREF="#top">Back to top</A></P>                           <P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <CENTER><img src="images/acrobatsmall.gif" alt="Acrobat gif" align=middle width=22 height=23></CENTER>               </TD>               <td align="left">                  <P>Acrobat version of this Note (248K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn2028.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR>                                           <P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn2028.html%3Fid%3DDTS10003065-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn2028.html%3Fid%3DDTS10003065-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn2028.html%3Fid%3DDTS10003065-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --><hr width=500 align=center></BODY></HTML>