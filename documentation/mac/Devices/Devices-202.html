<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Summary of SCSI Manager 4.3(IM: D)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING202></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="Devices-201.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-203.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Devices-2.html"><B>Devices</B></A> / <BR><DD><A HREF="Devices-151.html"><B>Chapter 4 - SCSI Manager 4.3</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING202-0></A>
<H1>Summary of SCSI Manager 4.3</H1>
<A NAME=HEADING202-1></A>
<H2>C Summary</H2>
<A NAME=HEADING202-2></A>
<H3>Constants</H3>
<PRE>
enum {
   scsiVERSION = 43
};
/* SCSI Manager function codes */
enum {
   SCSINop                 = 0x00,  /* no operation */
   SCSIExecIO              = 0x01,  /* execute a SCSI IO transaction */
   SCSIBusInquiry          = 0x03,  /* bus inquiry */
   SCSIReleaseQ            = 0x04,  /* release a frozen SIM queue */
   SCSIAbortCommand        = 0x10,  /* abort a SCSI command */
   SCSIResetBus            = 0x11,  /* reset the SCSI bus */
   SCSIResetDevice         = 0x12,  /* reset a SCSI device */
   SCSITerminateIO         = 0x13,  /* terminate I/O transaction */
   SCSIGetVirtualIDInfo    = 0x80,  /* return DeviceIdent of virtual ID */
   SCSILoadDriver          = 0x82,  /* load a driver from a SCSI device */
   SCSIOldCall             = 0x84,  /* begin old-API emulation */
   SCSICreateRefNumXref    = 0x85,  /* register a device driver */
   SCSILookupRefNumXref    = 0x86,  /* find a driver reference number */
   SCSIRemoveRefNumXref    = 0x87,  /* deregister a device driver */
   SCSIRegisterWithNewXPT  = 0x88,  /* XPT replaced; SIM must reregister */
   vendorUnique            = 0xC0   /* 0xC0 through 0xFF */
};
/* allocation lengths for parameter block fields */
enum {
   handshakeDataLength     = 8,     /* handshake data length */
   maxCDBLength            = 16,    /* space for the CDB bytes/pointer */
   vendorIDLength          = 16     /* ASCII string length for vendor ID  */
};
/* types for the scsiTransferType field */
enum {
   scsiTransferBlind    = 0,        /* DMA if available, otherwise blind */
   scsiTransferPolled               /* polled */
}; 
/* types for the scsiDataType field */
enum {
   scsiDataBuffer       = 0,        /* single contiguous buffer supplied */
   scsiDataTIB          = 1,        /* TIB supplied (ptr in scsiDataPtr) */
   scsiDataSG           = 2         /* scatter/gather list supplied */
}; 
/* flags for the scsiResultFlags field */
enum {
   scsiSIMQFrozen       = 0x0001,   /* the SIM queue is frozen */
   scsiAutosenseValid   = 0x0002,   /* autosense data valid for target */
   scsiBusNotFree       = 0x0004    /* SCSI bus is not free */
};
/* bit numbers of the scsiFlags field */
enum {
   kbSCSIDisableAutosense  = 29,    /* disable autosense feature */
   kbSCSIFlagReservedA     = 28,
   kbSCSIFlagReserved0     = 27,
   kbSCSICDBLinked         = 26,    /* the PB contains a linked CDB */
   kbSCSIQEnable           = 25,    /* target queue actions are enabled */
   kbSCSICDBIsPointer      = 24,    /* the CDB field contains a pointer */
   kbSCSIFlagReserved1     = 23,
   kbSCSIInitiateSyncData  = 22,    /* attempt sync data transfer and SDTR */
   kbSCSIDisableSyncData   = 21,    /* disable sync, go to async */
   kbSCSISIMQHead          = 20,    /* place PB at the head of SIM queue */
   kbSCSISIMQFreeze        = 19,    /* freeze the SIM queue */
   kbSCSISIMQNoFreeze      = 18,    /* disable SIM queue freezing */
   kbSCSIDoDisconnect      = 17,    /* definitely do disconnect */
   kbSCSIDontDisconnect    = 16,    /* definitely don't disconnect */
   kbSCSIDataReadyForDMA   = 15,    /* data buffer(s) are ready for DMA */
   kbSCSIFlagReserved3     = 14,
   kbSCSIDataPhysical      = 13,    /* S/G buffer data ptrs are physical */
   kbSCSISensePhysical     = 12,    /* autosense buffer ptr is physical */
   kbSCSIFlagReserved5     = 11,
   kbSCSIFlagReserved6     = 10,
   kbSCSIFlagReserved7     = 9,
   kbSCSIFlagReserved8     = 8,
   kbSCSIDataBufferValid   = 7,     /* data buffer valid */
   kbSCSIStatusBufferValid = 6,     /* status buffer valid */
   kbSCSIMessageBufferValid= 5,     /* message buffer valid */
   kbSCSIFlagReserved9     = 4
};
/* bit masks for the scsiFlags field */
enum {
   scsiDirectionMask       = 0xC0000000, /* data direction mask */
   scsiDirectionNone       = 0xC0000000, /* data direction (11: no data) */
   scsiDirectionReserved   = 0x00000000, /* data direction (00: reserved) */
   scsiDirectionOut        = 0x80000000, /* data direction (10: DATA OUT) */
   scsiDirectionIn         = 0x40000000, /* data direction (01: DATA IN) */
   scsiDisableAutosense    = 0x20000000, /* disable auto sense feature */
   scsiFlagReservedA       = 0x10000000,
   scsiFlagReserved0       = 0x08000000,
   scsiCDBLinked           = 0x04000000, /* the PB contains a linked CDB */
   scsiQEnable             = 0x02000000, /* target queue actions enabled */
   scsiCDBIsPointer        = 0x01000000, /* the CDB field is a pointer */
   scsiFlagReserved1       = 0x00800000,
   scsiInitiateSyncData    = 0x00400000, /* attempt sync data xfer &amp; SDTR */
   scsiDisableSyncData     = 0x00200000, /* disable sync, go to async */
   scsiSIMQHead            = 0x00100000, /* place PB at the head of queue */
   scsiSIMQFreeze          = 0x00080000, /* freeze the SIM queue */
   scsiSIMQNoFreeze        = 0x00040000, /* disallow SIM Q freezing */
   scsiDoDisconnect        = 0x00020000, /* definitely do disconnect */
   scsiDontDisconnect      = 0x00010000, /* definitely don't disconnect */
   scsiDataReadyForDMA     = 0x00008000, /* buffer(s) are ready for DMA */
   scsiFlagReserved3       = 0x00004000,
   scsiDataPhysical        = 0x00002000, /* S/G buffer ptrs are physical */
   scsiSensePhysical       = 0x00001000, /* autosense ptr is physical */
   scsiFlagReserved5       = 0x00000800,
   scsiFlagReserved6       = 0x00000400,
   scsiFlagReserved7       = 0x00000200,
   scsiFlagReserved8       = 0x00000100
};
/* bit masks for the scsiIOFlags field */
enum {
   scsiNoParityCheck       = 0x0002,   /* disable parity checking */
   scsiDisableSelectWAtn   = 0x0004,   /* disable select w/Atn */
   scsiSavePtrOnDisconnect = 0x0008,   /* SaveDataPointer on disconnect */
   scsiNoBucketIn          = 0x0010,   /* don't bit-bucket on input */
   scsiNoBucketOut         = 0x0020,   /* don't bit-bucket on output */
   scsiDisableWide         = 0x0040,   /* disable wide negotiation */
   scsiInitiateWide        = 0x0080,   /* initiate wide negotiation */
   scsiRenegotiateSense    = 0x0100,   /* renegotiate sync/wide */
   scsiIOFlagReserved0080  = 0x0080,
   scsiIOFlagReserved8000  = 0x8000
};
/* SIM queue actions. */
enum {
   scsiSimpleQTag          = 0x20,     /* tag for a simple queue */
   scsiHeadQTag            = 0x21,     /* tag for head of queue  */
   scsiOrderedQTag         = 0x22      /* tag for ordered queue */
};
/* scsiHBAInquiry field bits */
enum {
   scsiBusMDP        = 0x80,     /* supports Modify Data Pointer message */
   scsiBusWide32     = 0x40,     /* supports 32-bit wide SCSI */
   scsiBusWide16     = 0x20,     /* supports 16-bit wide SCSI */
   scsiBusSDTR       = 0x10,     /* supports SDTR message */
   scsiBusLinkedCDB  = 0x08,     /* supports linked CDBs */
   scsiBusTagQ       = 0x02,     /* supports tag queue message */
   scsiBusSoftReset  = 0x01      /* supports soft reset */
};
/* scsiDataTypes field bits  */
/* bits 0-15 Apple-defined, 16-30 vendor unique, 31 = reserved */
enum {
   scsiBusDataBuffer       = (1&lt;&lt;scsiDataBuffer),  /* single buffer */
   scsiBusDataTIB          = (1&lt;&lt;scsiDataTIB), /* TIB (ptr in scsiDataPtr) */
   scsiBusDataSG           = (1&lt;&lt;scsiDataSG),      /* scatter/gather list */
   scsiBusDataReserved     = 0x80000000
};
/* scsiScanFlags field bits */
enum {
   scsiBusScansDevices     = 0x80, /* bus scans and maintains device list */
   scsiBusScansOnInit      = 0x40, /* bus scans at startup */
   scsiBusLoadsROMDrivers  = 0x20/* may load ROM drivers for targets */
};
/* scsiFeatureFlags field bits */
enum {
   scsiBusInternalExternalMask   = 0x000000C0, /* internal/external mask*/
   scsiBusInternalExternalUnknown = 0x00000000, /* unknown if in or out */
   scsiBusInternalExternal       = 0x000000C0, /* both inside and outside */
   scsiBusInternal               = 0x00000080, /* bus goes inside the box */
   scsiBusExternal               = 0x00000040, /* bus goes outside the box */
   scsiBusCacheCoherentDMA       = 0x00000020, /* DMA is cache coherent */
   scsiBusOldCallCapable         = 0x00000010, /* SIM supports old API */
   scsiBusDifferential           = 0x00000004, /* uses differential bus */
   scsiBusFastSCSI               = 0x00000002, /* HBA supports fast SCSI */
   scsiBusDMAavailable           = 0x00000001/* DMA is available */
};
/* scsiWeirdStuff field bits */
enum {
   /* disconnects on odd byte boundries are unsafe with DMA or blind reads */
   scsiOddDisconnectUnsafeRead1  = 0x0001,
   /* disconnects on odd byte boundries unsafe with DMA or blind writes */
   scsiOddDisconnectUnsafeWrite1 = 0x0002,
   /* non-handshaked delays or disconnects on blind transfer may hang */
   scsiBusErrorsUnsafe           = 0x0004,
   /* non-handshaked delays or disconnects on blind transfer may corrupt */
   scsiRequiresHandshake         = 0x0008,
   /* targets that initiate synchronous negotiations are supported */
   scsiTargetDrivenSDTRSafe      = 0x0010
};
/* scsiHBAslotType values */
enum {
   scsiMotherboardBus            = 0x01,  /* a built-in Apple bus */
   scsiNuBus                     = 0x02,  /* a SIM on a NuBus card */
   scsiPDSBus                    = 0x03   /* a SIM on a PDS card  */
};
/* flags for the scsiDriverFlags field */
enum {
   scsiDeviceSensitive = 0x0001, /* only driver should access this device */
   scsiDeviceNoOldCallAccess = 0x0002 /* device does not support old API */
};
/* SCSI Phases (used by SIMs that support the original SCSI Manager) */
enum {
   kDataOutPhase,       /* encoded MSG, C/D, I/O bits */
   kDataInPhase,
   kCommandPhase,
   kStatusPhase,
   kPhaseIllegal0,
   kPhaseIllegal1,
   kMessageOutPhase,
   kMessageInPhase,
   kBusFreePhase,       /* additional phases */
   kArbitratePhase,
   kSelectPhase
};
</PRE>
<A NAME=HEADING202-21></A>
<H3>Data Types</H3>
<PRE>
/* SCSI callback function prototypes */  
typedef pascal void (*CallbackProc) (void * scsiPB);
typedef void   (*AENCallbackProc) (void);
typedef OSErr  (*SIMInitProc) (Ptr SIMinfoPtr);
typedef void   (*SIMActionProc) (void * scsiPB, Ptr SIMGlobals);
typedef void   (*SCSIProc) (void );
typedef void   (*MakeCallbackProc) (void * scsiPB);
typedef SInt32 (*InterruptPollProc) (Ptr SIMGlobals);
struct DeviceIdent 
{
   UInt8 diReserved;                /* reserved */
   UInt8 bus;                       /* SCSI - bus number */
   UInt8 targetID;                  /* SCSI - target SCSI ID */
   UInt8 LUN;                       /* SCSI - logical unit number */
};
typedef struct DeviceIdent DeviceIdent;
union CDB
{
   UInt8 *cdbPtr;                   /* pointer to the CDB, or */
   UInt8 cdbBytes[maxCDBLength];    /* the actual CDB to send */
};
typedef union CDB CDB, *CDBPtr;
struct SGRecord
{
   Ptr      SGAddr;              /* scatter/gather buffer address */
   UInt32   SGCount;             /* buffer size */
};
typedef struct SGRecord SGRecord;
#define SCSIPBHdr \
   struct SCSIHdr *qLink;        /*internal use, must be nil */      \
   SInt16   scsiReserved1;       /* -&gt; reserved for input */             \
   UInt16   scsiPBLength;        /* -&gt; length of the entire PB  */       \
   UInt8    scsiFunctionCode;    /* -&gt; function selector */              \
   UInt8    scsiReserved2;       /* &lt;- reserved for output*/             \
   OSErr    scsiResult;          /* &lt;- returned result */                \
   DeviceIdentscsiDevice;     /* -&gt; device ID (bus+target+LUN) */     \
   CallbackProcscsiCompletion; /* -&gt; completion routine pointer */                    \
   UInt32   scsiFlags;           /* -&gt; assorted flags */                 \
   UInt8    *scsiDriverStorage;  /* &lt;&gt; pointer for driver private use */ \
   Ptr      scsiXPTprivate;      /*private field for XPT */          \
   SInt32   scsiReserved3;       /*reserved */

struct SCSI_PB
{
   SCSIPBHdr
};
typedef struct SCSI_PB SCSI_PB;
#define SCSI_IO_Macro \
   SCSIPBHdr                     /*header information fields */     \
   UInt16   scsiResultFlags;     /* &lt;- flags that modify scsiResult */  \
   UInt16   scsiReserved12;      /* -&gt; reserved */                      \
   UInt8    *scsiDataPtr;        /* -&gt; data pointer */                  \
   UInt32   scsiDataLength;      /* -&gt; data transfer length */          \
   UInt8    *scsiSensePtr;       /* -&gt; autosense data buffer pointer */ \
   UInt8    scsiSenseLength;     /* -&gt; size of the autosense buffer */     \
   UInt8    scsiCDBLength;       /* -&gt; number of bytes for the CDB */   \
   UInt16   scsiSGListCount;     /* -&gt; number of S/G list entries */    \
   UInt32   scsiReserved4;       /* &lt;- reserved for output */           \
   UInt8    scsiSCSIstatus;      /* &lt;- returned SCSI device status */   \
   SInt8    scsiSenseResidual;   /* &lt;- autosense residual length */     \
   UInt16   scsiReserved5;       /* &lt;- reserved for output */           \
   SInt32   scsiDataResidual;    /* &lt;- data residual length */          \
   CDB      scsiCDB;             /* -&gt; actual CDB or pointer to CDB */  \
   SInt32   scsiTimeout;         /* -&gt; timeout value */                 \
   UInt8    *scsiReserved13;     /* -&gt; reserved */                      \
   UInt16   scsiReserved14;      /* -&gt; reserved */                         \
   UInt16   scsiIOFlags;         /* -&gt; additional I/O flags */          \
   UInt8    scsiTagAction;       /* -&gt; what to do for tag queuing */    \
   UInt8    scsiReserved6;       /* -&gt; reserved for input */            \
   UInt16   scsiReserved7;       /* -&gt; reserved for input */            \
   UInt16   scsiSelectTimeout;   /* -&gt; select timeout value */          \
   UInt8    scsiDataType;        /* -&gt; data description type */         \
   UInt8    scsiTransferType;    /* -&gt; transfer type (blind/polled) */  \
   UInt32   scsiReserved8;       /* -&gt; reserved for input */            \
   UInt32   scsiReserved9;       /* -&gt; reserved for input */            \
   UInt16   scsiHandshake[handshakeDataLength]; /* -&gt; handshake info */ \
   UInt32   scsiReserved10;      /* -&gt; reserved for input */            \
   UInt32   scsiReserved11;      /* -&gt; reserved for input */            \
   struct   SCSI_IO *scsiCommandLink; /* -&gt; linked command pointer */   \
   UInt8    scsiSIMpublics[8];   /* -&gt; reserved for SIM input */        \
   UInt8    scsiAppleReserved6[8];/* -&gt; reserved for input */       \
   /* XPT private fields for original SCSI Manager emulation */         \
   UInt16   scsiCurrentPhase;    /* &lt;- bus phase after old call */         \
   SInt16   scsiSelector;        /* -&gt; selector for old call */            \
   OSErr    scsiOldCallResult;   /* &lt;- result of old call */            \
   UInt8    scsiSCSImessage;     /* &lt;- SCSIComplete message byte */     \
   UInt8    XPTprivateFlags;     /* &lt;&gt; XPT private flags */             \
   UInt8    XPTextras[12];       /*reserved */

struct SCSI_IO
{
   SCSI_IO_Macro
};
typedef struct SCSI_IO SCSI_IO;
typedef SCSI_IO SCSIExecIOPB;
struct SCSIBusInquiryPB
{
   SCSIPBHdr                        /* header information fields */
   UInt16   scsiEngineCount;        /* &lt;- number of engines on HBA */
   UInt16   scsiMaxTransferType;    /* &lt;- number of xfer types supported */
   UInt32   scsiDataTypes;          /* &lt;- data types supported by this SIM */
   UInt16   scsiIOpbSize;           /* &lt;- size of SCSI_IO PB for this SIM */
   UInt16   scsiMaxIOpbSize;        /* &lt;- largest SCSI_IO PB for all SIMs */
   UInt32   scsiFeatureFlags;       /* &lt;- supported features flags field */
   UInt8    scsiVersionNumber;      /* &lt;- version number for the SIM/HBA */
   UInt8    scsiHBAInquiry;         /* &lt;- mimic of INQ byte 7 for the HBA */
   UInt8    scsiTargetModeFlags;    /* &lt;- flags for target mode support */
   UInt8    scsiScanFlags;          /* &lt;- scan related feature flags */
   UInt32   scsiSIMPrivatesPtr;     /* &lt;- pointer to SIM private data */
   UInt32   scsiSIMPrivatesSize;    /* &lt;- size of SIM private data */
   UInt32   scsiAsyncFlags;         /* &lt;- reserved for input */
   UInt8    scsiHiBusID;            /* &lt;- highest path ID in the subsystem */
   UInt8    scsiInitiatorID;        /* &lt;- ID of the HBA on the SCSI bus */
   UInt16   scsiBIReserved0;        /* reserved */
   UInt32   scsiBIReserved1;        /* reserved */
   UInt32   scsiFlagsSupported;     /* &lt;- which scsiFlags are supported */
   UInt16   scsiIOFlagsSupported;   /* &lt;- which scsiIOFlags are supported */
   UInt16   scsiWeirdStuff;         /* &lt;- flags for strange behavior */
   UInt16   scsiMaxTarget;          /* &lt;- maximum target ID supported */
   UInt16   scsiMaxLUN;             /* &lt;- maximum LUN supported */
   SInt8 scsiSIMVendor[vendorIDLength]; /* &lt;- vendor ID of the SIM */
   SInt8 scsiHBAVendor[vendorIDLength]; /* &lt;- vendor ID of the HBA */
   SInt8 scsiControllerFamily[vendorIDLength]; /* &lt;- controller family */
   SInt8 scsiControllerType[vendorIDLength]; /* &lt;- controller model */
   SInt8 scsiXPTversion[4];         /* &lt;- version number of XPT */
   SInt8 scsiSIMversion[4];         /* &lt;- version number of SIM */
   SInt8 scsiHBAversion[4];         /* &lt;- version number of HBA */
   UInt8    scsiHBAslotType;        /* &lt;- type of slot this HBA is in */
   UInt8    scsiHBAslotNumber;      /* &lt;- slot number of this HBA */
   UInt16   scsiSIMsRsrcID;         /* &lt;- sResource ID of this SIM */
   UInt16   scsiBIReserved3;        /* &lt;- reserved for input */
   UInt16   scsiAdditionalLength;   /* &lt;- additional length of PB */
};
typedef struct SCSIBusInquiryPB SCSIBusInquiryPB;
struct SCSIAbortCommandPB
{
   SCSIPBHdr               /* header information fields */
   SCSI_IO  *scsiIOptr;    /* -&gt; pointer to the PB to abort */
};
typedef struct SCSIAbortCommandPB SCSIAbortCommandPB;
struct SCSITerminateIOPB
{
   SCSIPBHdr               /* header information fields */
   SCSI_IO  *scsiIOptr;    /* -&gt; pointer to the PB to terminate */
};
typedef struct SCSITerminateIOPB SCSITerminateIOPB;
struct SCSIGetVirtualIDInfoPB
{
   SCSIPBHdr               /* header information fields */
   UInt16   scsiOldCallID; /* -&gt; SCSI ID of device in question */
   Boolean  scsiExists;    /* &lt;- true if device exists */
};
typedef struct SCSIGetVirtualIDInfoPB SCSIGetVirtualIDInfoPB;
struct SCSIDriverPB
{
   SCSIPBHdr                     /* header information fields */
   SInt16      scsiDriver;       /* -&gt; driver refNum, for CreateRefNumXref */
                                 /* &lt;- for LookupRefNumXref */
   UInt16      scsiDriverFlags;  /* &lt;&gt; details of driver/device */
   DeviceIdent scsiNextDevice;   /* &lt;- DeviceIdent of the next driver */
};
typedef struct SCSIDriverPB SCSIDriverPB;
struct SCSILoadDriverPB
{
   SCSIPBHdr                     /* header information fields */
   SInt16   scsiLoadedRefNum;    /* &lt;- SIM returns driver reference number */
   Boolean  scsiDiskLoadFailed;  /* -&gt; if true, previous call failed */
};
typedef struct SCSILoadDriverPB SCSILoadDriverPB;
struct SIMInitInfo 
{
   UInt8          *SIMstaticPtr;  /* &lt;- pointer to the SIM's static data */
   SInt32         staticSize;     /* -&gt; size requested for SIM static data */
   SIMInitProc    SIMInit;        /* -&gt; pointer to the SIMInit function */
   SIMActionProc  SIMAction;      /* -&gt; pointer to the SIMAction function */
   SCSIProc       SIM_ISR;        /*  reserved */
   InterruptPollProc SIMInterruptPoll; /* -&gt; pointer to SIMInterruptPoll */
   SIMActionProc  NewOldCall;     /* -&gt; pointer to NewOldCall function */
   UInt16         ioPBSize;       /* -&gt; size of SCSI_IO PB for this SIM */
   Boolean        oldCallCapable; /* -&gt; true if SIM handles old-API calls */
   UInt8          simInfoUnused1; /*   reserved */
   SInt32         simInternalUse; /* not affected or viewed by XPT */
   SCSIProc       XPT_ISR;        /*    reserved */
   SCSIProc       EnteringSIM;    /* &lt;- pointer to EnteringSIM function */
   SCSIProc       ExitingSIM;     /* &lt;- pointer to ExitingSIM function */
   MakeCallbackProc MakeCallback; /* &lt;- pointer to MakeCallback function */
   UInt16         busID;          /* &lt;- bus number for the registered bus */
   UInt16         simInfoUnused3; /* &lt;- reserved */
   SInt32         simInfoUnused4; /* &lt;- reserved */
};
typedef struct SIMInitInfo SIMInitInfo; 
</PRE>
<A NAME=HEADING202-35></A>
<H3>Functions</H3>
<PRE>
OSErr SCSIAction        (SCSI_PB *scsiPB);
OSErr SCSIRegisterBus   (SIMInitInfo *SIMinfoPtr);
OSErr SCSIDeregisterBus (SCSI_PB *scsiPB);
OSErr SCSIReregisterBus (SIMInitInfo *SIMinfoPtr);
OSErr SCSIKillXPT       (void *);
</PRE>
<A NAME=HEADING202-37></A>
<H2>Pascal Summary</H2>
<A NAME=HEADING202-38></A>
<H3>Constants</H3>
<PRE>
CONST
   scsiVERSION    = 43;
   {SCSI Manager function codes}
   SCSINop                    = $00;   {no operation}
   SCSIExecIO                 = $01;   {execute a SCSI IO transaction}
   SCSIBusInquiry             = $03;   {bus inquiry}
   SCSIReleaseQ               = $04;   {release a frozen SIM queue}
   SCSIAbortCommand           = $10;   {abort a SCSI command}
   SCSIResetBus               = $11;   {reset the SCSI bus}
   SCSIResetDevice            = $12;   {reset a SCSI device}
   SCSITerminateIO            = $13;   {terminate I/O transaction}
   SCSIGetVirtualIDInfo       = $80;   {return DeviceIdent of virtual ID}
   SCSILoadDriver             = $82;   {load a driver from a SCSI device}
   SCSIOldCall                = $84;   {begin old-API emulation}
   SCSICreateRefNumXref       = $85;   {register a device driver}
   SCSILookupRefNumXref       = $86;   {find a driver reference number}
   SCSIRemoveRefNumXref       = $87;   {deregister a device driver}
   SCSIRegisterWithNewXPT     = $88;   {XPT replaced; SIM must reregister}
   vendorUnique               = $C0;   {$C0 through $FF}
   {allocation lengths for parameter block fields}
   handshakeDataLength        = 8;     {handshake data length}
   maxCDBLength               = 16;    {space for the CDB bytes/pointer}
   vendorIDLength             = 16;    {ASCII string length for Vendor ID}
   {types for the scsiTransferType field}
   scsiTransferBlind          = 0;     {DMA if available, otherwise blind}
   scsiTransferPolled         = 1;     {polled}
   {types for the scsiDataType field}
   scsiDataBuffer             = 0;     {single contiguous buffer supplied}
   scsiDataTIB                = 1;     {TIB supplied (ptr in scsiDataPtr)}
   scsiDataSG                 = 2;     {scatter/gather list supplied}
   {flags for the scsiResultFlags field}
   scsiSIMQFrozen             = $0001; {the SIM queue is frozen}
   scsiAutosenseValid         = $0002; {autosense data valid for target}
   scsiBusNotFree             = $0004; {SCSI bus is not free}
   {bit numbers in the scsiFlags field}
   kbSCSIDisableAutosense     = 29;    {disable auto sense feature}
   kbSCSIFlagReservedA        = 28;
   kbSCSIFlagReserved0        = 27;
   kbSCSICDBLinked            = 26;    {the PB contains a linked CDB}
   kbSCSIQEnable              = 25;    {target queue actions are enabled}
   kbSCSICDBIsPointer         = 24;    {the CDB field contains a pointer}
   kbSCSIFlagReserved1        = 23;
   kbSCSIInitiateSyncData     = 22;    {attempt sync data transfer and SDTR}
   kbSCSIDisableSyncData      = 21;    {disable sync, go to async}
   kbSCSISIMQHead             = 20;    {place PB at the head of SIM queue}
   kbSCSISIMQFreeze           = 19;    {freeze the SIM queue}
   kbSCSISIMQNoFreeze         = 18;    {disable SIM queue freezing}
   kbSCSIDoDisconnect         = 17;    {definitely do disconnect}
   kbSCSIDontDisconnect       = 16;    {definitely don't disconnect}
   kbSCSIDataReadyForDMA      = 15;    {data buffer(s) are ready for DMA}
   kbSCSIFlagReserved3        = 14;
   kbSCSIDataPhysical         = 13;    {S/G buffer data ptrs are physical}
   kbSCSISensePhysical        = 12;    {autosense buffer ptr is physical}
   kbSCSIFlagReserved5        = 11;
   kbSCSIFlagReserved6        = 10;
   kbSCSIFlagReserved7        = 9;
   kbSCSIFlagReserved8        = 8;
   kbSCSIDataBufferValid      = 7;     {data buffer valid}
   kbSCSIStatusBufferValid    = 6;     {status buffer valid}
   kbSCSIMessageBufferValid   = 5;     {message buffer valid}
   kbSCSIFlagReserved9        = 4;
   {bit masks for the scsiFlags field}
   scsiDirectionMask          = $C0000000;   {data direction mask}
   scsiDirectionNone          = $C0000000;   {data direction (11: no data)}
   scsiDirectionReserved      = $00000000;   {data direction (00: reserved)}
   scsiDirectionOut           = $80000000;   {data direction (10: DATA OUT)}
   scsiDirectionIn            = $40000000;   {data direction (01: DATA IN)}
   scsiDisableAutosense       = $20000000;   {disable auto sense feature}
   scsiFlagReservedA          = $10000000;
   scsiFlagReserved0          = $08000000;
   scsiCDBLinked              = $04000000;   {the PB contains a linked CDB}
   scsiQEnable                = $02000000;   {target queue actions enabled}
   scsiCDBIsPointer           = $01000000;   {the CDB field is a pointer}
   scsiFlagReserved1          = $00800000;
   scsiInitiateSyncData       = $00400000;   {attempt sync data xfer &amp; SDTR}
   scsiDisableSyncData        = $00200000;   {disable sync; go to async}
   scsiSIMQHead               = $00100000;   {place PB at the head of queue}
   scsiSIMQFreeze             = $00080000;   {freeze the SIM queue}
   scsiSIMQNoFreeze           = $00040000;   {disallow SIM Q freezing}
   scsiDoDisconnect           = $00020000;   {definitely do disconnect}
   scsiDontDisconnect         = $00010000;   {definitely don't disconnect}
   scsiDataReadyForDMA        = $00008000;   {buffer(s) are ready for DMA}
   scsiFlagReserved3          = $00004000;
   scsiDataPhysical           = $00002000;   {S/G buffer ptrs are physical}
   scsiSensePhysical          = $00001000;   {autosense ptr is physical}
   scsiFlagReserved5          = $00000800;
   scsiFlagReserved6          = $00000400;
   scsiFlagReserved7          = $00000200;
   scsiFlagReserved8          = $00000100;
   {bit masks for the scsiIOFlags field}
   scsiNoParityCheck          = $0002;       {disable parity checking}
   scsiDisableSelectWAtn      = $0004;       {disable select w/Atn}
   scsiSavePtrOnDisconnect    = $0008;       {SaveDataPointer on disconnect}
   scsiNoBucketIn             = $0010;       {don't bit-bucket on input}
   scsiNoBucketOut            = $0020;       {don't bit-bucket on output}
   scsiDisableWide            = $0040;       {disable wide negotiation}
   scsiInitiateWide           = $0080;       {initiate wide negotiation}
   scsiRenegotiateSense       = $0100;       {renegotiate sync/wide}
   scsiIOFlagReserved0080     = $0080;
   scsiIOFlagReserved8000     = $8000;
   {SIM queue actions}
   scsiSimpleQTag             = $20;   {tag for a simple queue}
   scsiHeadQTag               = $21;   {tag for head of queue}
   scsiOrderedQTag            = $22;   {tag for ordered queue}
   {scsiHBAInquiry field bits}
   scsiBusMDP                 = $80;   {supports Modify Data Pointer message}
   scsiBusWide32              = $40;   {supports 32-bit wide SCSI}
   scsiBusWide16              = $20;   {supports 16-bit wide SCSI}
   scsiBusSDTR                = $10;   {supports SDTR message}
   scsiBusLinkedCDB           = $08;   {supports linked CDBs}
   scsiBusTagQ                = $02;   {supports tag queue message}
   scsiBusSoftReset           = $01;   {supports soft reset}
   {scsiDataTypes field bits}
   {bits 0-15 Apple-defined, 16-30 vendor unique, 31 = reserved}
   scsiBusDataBuffer          = $00000001; {single buffer}
   scsiBusDataTIB             = $00000002; {TIB (pointer in scsiDataPtr)}
   scsiBusDataSG              = $00000004; {scatter/gather list}
   scsiBusDataReserved        = $80000000;
   {scsiScanFlags field bits}
   scsiBusScansDevices        = $80;   {bus scans and maintains device list}
   scsiBusScansOnInit         = $40;   {bus scans at startup}
   scsiBusLoadsROMDrivers     = $20;   {may load ROM drivers for targets}
   {scsiFeatureFlags field bits}
   scsiBusInternalExternalMask      = $000000C0; {internal/external mask}
   scsiBusInternalExternalUnknown   = $00000000; {unknown if in or out}
   scsiBusInternalExternal          = $000000C0; {both inside and outside}
   scsiBusInternal                  = $00000080; {bus goes inside the box}
   scsiBusExternal                  = $00000040; {bus goes outside the box}
   scsiBusCacheCoherentDMA          = $00000020; {DMA is cache coherent}
   scsiBusOldCallCapable            = $00000010; {SIM supports old-API}
   scsiBusDifferential              = $00000004; {uses differential bus}
   scsiBusFastSCSI                  = $00000002; {HBA supports fast SCSI}
   scsiBusDMAavailable              = $00000001; {DMA is available}
   {scsiWeirdStuff field bits}
   scsiOddDisconnectUnsafeRead1     = $0001; {odd byte disconnects unsafe}
   scsiOddDisconnectUnsafeWrite1    = $0002; {odd byte disconnects unsafe}
   scsiBusErrorsUnsafe              = $0004; {delays or disconnects may hang}
   scsiRequiresHandshake            = $0008; {delays/disconnects may corrupt}
   scsiTargetDrivenSDTRSafe         = $0010; {target-driven STDR supported}
   {scsiHBAslotType values}
   scsiMotherboardBus         = $01;   {a built-in Apple bus}
   scsiNuBus                  = $02;   {a SIM on a NuBus card}
   scsiPDSBus                 = $03;   {a SIM on a PDS card}
   {flags for the scsiDriverFlags field}
   scsiDeviceSensitive        = $0001; {only driver should access the device}
   scsiDeviceNoOldCallAccess  = $0002; {device does not support old API}
   {SCSI Phases (used by SIMs that support the original SCSI Manager)}
   kDataOutPhase              = $00;   {encoded MSG, C/D, I/O bits}
   kDataInPhase               = $01;
   kCommandPhase              = $02;
   kStatusPhase               = $03;
   kPhaseIllegal0             = $04;
   kPhaseIllegal1             = $05;
   kMessageOutPhase           = $06;
   kMessageInPhase            = $07;
   kBusFreePhase              = $08;   {additional phases}
   kArbitratePhase            = $09;
   kSelectPhase               = $0A;
</PRE>
<A NAME=HEADING202-57></A>
<H3>Data Types</H3>
<PRE>
TYPE
   {SCSI callback function prototypes}
   CallbackProc               = ProcPtr;
   AENCallbackProc            = ProcPtr;
   SIMInitProc                = ProcPtr;
   SIMActionProc              = ProcPtr;
   SCSIProc                   = ProcPtr;
   MakeCallbackProc           = ProcPtr;
   InterruptPollProc          = ProcPtr;
TYPE
   DI =
   PACKED RECORD
      diReserved:             Byte;    {reserved}
      bus:                    Byte;    {SCSI - bus number}
      targetID:               Byte;    {SCSI - target SCSI ID}
      LUN:                    Byte;    {SCSI - logical unit number}
   END;
   DeviceIdent = DI;
   CDBRec = 
   PACKED RECORD
   CASE Integer OF
      0: cdbPtr:           ^Byte;               {pointer to the CDB, or}
      1: cdbBytes:         ARRAY [0..15] OF Byte; {the actual CDB to send}
   END;
   CDB = CDBRec;
   CDBPtr = ^CDBRec;
   SGR = 
   PACKED RECORD
      SGAddr:              Ptr;           {scatter/gather buffer address}
      SGCount:             LongInt;       {buffer size}
   END;
   SGRecord = SGR;
   SCSIHdr = 
   PACKED RECORD
      qLink:               ^SCSIHdr;      {internal use, must be NIL}
      scsiReserved1:       Integer;       {-&gt; reserved for input}
      scsiPBLength:        Integer;       {-&gt; length of the entire PB}
      scsiFunctionCode:    Byte;          {-&gt; function selector}
      scsiReserved2:       Byte;          {&lt;- reserved for output}
      scsiResult:          OSErr;         {&lt;- returned result}
      scsiDevice:          DeviceIdent;   {-&gt; device ID (bus+target+LUN)}
      scsiCompletion:      CallbackProc;  {-&gt; completion routine pointer}
      scsiFlags:           LongInt;       {-&gt; assorted flags}
      scsiDriverStorage:   ^Byte;         {&lt;&gt; pointer for driver private use}
      scsiXPTprivate:      Ptr;           {private field for XPT}
      scsiReserved3:       LongInt;       {reserved}
   END;
   SCSI_PB = SCSIHdr;
   SCSI_IO = 
   PACKED RECORD
      qLink:               ^SCSIHdr;      {internal use, must be NIL}
      scsiReserved1:       Integer;       {-&gt; reserved for input}
      scsiPBLength:        Integer;       {-&gt; length of the entire PB}
      scsiFunctionCode:    Byte;          {-&gt; function selector}
      scsiReserved2:       Byte;          {&lt;- reserved for output}
      scsiResult:          OSErr;         {&lt;- returned result}
      scsiDevice:          DeviceIdent;   {-&gt; device ID (bus+target+LUN)}
      scsiCompletion:      CallbackProc;  {-&gt; completion routine pointer}
      scsiFlags:           LongInt;       {-&gt; assorted flags}
      scsiDriverStorage:   ^Byte;         {&lt;&gt; pointer for driver private use}
      scsiXPTprivate:      Ptr;           {private field for XPT}
      scsiReserved3:       LongInt;       {reserved}
      scsiResultFlags:     Integer;       {&lt;- flags that modify scsiResult}
      scsiReserved12:      Integer;       {-&gt; reserved}
      scsiDataPtr:         ^Byte;         {-&gt; data pointer}
      scsiDataLength:      LongInt;       {-&gt; data transfer length}
      scsiSensePtr:        ^Byte;         {-&gt; autosense data buffer pointer}
      scsiSenseLength:     Byte;          {-&gt; size of the autosense buffer}
      scsiCDBLength:       Byte;          {-&gt; number of bytes for the CDB}
      scsiSGListCount:     Integer;       {-&gt; number of S/G list entries}
      scsiReserved4:       LongInt;       {&lt;- reserved for output}
      scsiSCSIstatus:      Byte;          {&lt;- returned SCSI device status}
      scsiSenseResidual:   Char;          {&lt;- autosense residual length}
      scsiReserved5:       Integer;       {&lt;- reserved for output}
      scsiDataResidual:    LongInt;       {&lt;- data residual length}
      scsiCDB:             CDB;           {-&gt; actual CDB or pointer to CDB}
      scsiTimeout:         LongInt;       {-&gt; timeout value}
      scsiReserved13:      ^Byte;         {-&gt; reserved}
      scsiReserved14:      Integer;       {-&gt; reserved}
      scsiIOFlags:         Integer;       {-&gt; additional I/O flags}
      scsiTagAction:       Byte;          {-&gt; what to do for tag queuing}
      scsiReserved6:       Byte;          {-&gt; reserved for input}
      scsiReserved7:       Integer;       {-&gt; reserved for input}
      scsiSelectTimeout:   Integer;       {-&gt; select timeout value}
      scsiDataType:        Byte;          {-&gt; data description type}
      scsiTransferType:    Byte;          {-&gt; transfer type (blind/polled)}
      scsiReserved8:       LongInt;       {-&gt; reserved for input}
      scsiReserved9:       LongInt;       {-&gt; reserved for input}
      scsiHandshake:       ARRAY [0..7] OF Integer; {-&gt; handshake info}
      scsiReserved10:      LongInt;       {-&gt; reserved for input}
      scsiReserved11:      LongInt;       {-&gt; reserved for input}
      scsiCommandLink:     ^SCSI_IO;      {-&gt; linked command pointer}
      scsiSIMpublics:      ARRAY [0..7] OF Byte; {-&gt; reserved for SIM input}
      scsiAppleReserved6:  ARRAY [0..7] OF Byte; {-&gt; reserved for input}
      scsiCurrentPhase:    Integer;       {&lt;- bus phase after old call}
      scsiSelector:        Integer;       {-&gt; selector for old call}
      scsiOldCallResult:   OSErr;         {&lt;- result of old call}
      scsiSCSImessage:     Byte;          {&lt;- SCSIComplete message byte}
      XPTprivateFlags:     Byte;          {&lt;&gt; XPT private flags}
      XPTextras:           ARRAY [0..11] OF Byte; {reserved}
   END;
   SCSIExecIOPB = SCSI_IO;
   SCSIBusInquiryPB = 
   PACKED RECORD
      qLink:                ^SCSIHdr;     {internal use, must be NIL}
      scsiReserved1:        Integer;      {-&gt; reserved for input}
      scsiPBLength:         Integer;      {-&gt; length of the entire PB}
      scsiFunctionCode:     Byte;         {-&gt; function selector}
      scsiReserved2:        Byte;         {&lt;- reserved for output}
      scsiResult:           OSErr;        {&lt;- returned result}
      scsiDevice:           DeviceIdent;  {-&gt; device ID (bus+target+LUN)}
      scsiCompletion:       CallbackProc; {-&gt; completion routine pointer}
      scsiFlags:            LongInt;      {-&gt; assorted flags}
      scsiDriverStorage:    ^Byte;        {&lt;&gt; pointer for driver private use}
      scsiXPTprivate:       Ptr;          {private field for XPT}
      scsiReserved3:        LongInt;      {reserved}
      scsiEngineCount:      Integer;      {&lt;- number of engines on HBA}
      scsiMaxTransferType:  Integer;      {&lt;- number of xfer types supported}
      scsiDataTypes:        LongInt;      {&lt;- data types supported by SIM}
      scsiIOpbSize:         Integer;      {&lt;- size of SCSI_IO PB for SIM}
      scsiMaxIOpbSize:      Integer;      {&lt;- largest SCSI_IO PB registered}
      scsiFeatureFlags:     LongInt;      {&lt;- supported features flags field}
      scsiVersionNumber:    Byte;         {&lt;- version number for the SIM/HBA}
      scsiHBAInquiry:       Byte;         {&lt;- mimic of INQ byte 7 for HBA}
      scsiTargetModeFlags:  Byte;         {&lt;- flags for target mode support}
      scsiScanFlags:        Byte;         {&lt;- scan related feature flags}
      scsiSIMPrivatesPtr:   LongInt;      {&lt;- pointer to SIM private data}
      scsiSIMPrivatesSize:  LongInt;      {&lt;- size of SIM private data}
      scsiAsyncFlags:       LongInt;      {&lt;- reserved for input}
      scsiHiBusID:          Byte;         {&lt;- highest bus ID registered}
      scsiInitiatorID:      Byte;         {&lt;- ID of the HBA on the SCSI bus}
      scsiBIReserved0:      Integer;      {reserved}
      scsiBIReserved1:      LongInt;      {reserved}
      scsiFlagsSupported:   LongInt;      {&lt;- which scsiFlags are supported}
      scsiIOFlagsSupported: Integer;      {&lt;- which scsiIOFlags supported}
      scsiWeirdStuff:       Integer;      {&lt;- flags for strange behavior}
      scsiMaxTarget:        Integer;      {&lt;- maximum target ID supported}
      scsiMaxLUN:           Integer;      {&lt;- maximum LUN supported}
      scsiSIMVendor:        ARRAY [0..15] OF Char; {&lt;- vendor ID of the SIM}
      scsiHBAVendor:        ARRAY [0..15] OF Char; {&lt;- vendor ID of the HBA}
      scsiControllerFamily: ARRAY [0..15] OF Char; {&lt;- controller family}
      scsiControllerType:   ARRAY [0..15] OF Char; {&lt;- controller model}
      scsiXPTversion:       ARRAY [0..3] OF Char; {&lt;- version number of XPT}
      scsiSIMversion:       ARRAY [0..3] OF Char; {&lt;- version number of SIM}
      scsiHBAversion:       ARRAY [0..3] OF Char; {&lt;- version number of HBA}
      scsiHBAslotType:      Byte;         {&lt;- type of slot this HBA is in}
      scsiHBAslotNumber:    Byte;         {&lt;- slot number of this HBA}
      scsiSIMsRsrcID:       Integer;      {&lt;- sResource ID of this SIM}
      scsiBIReserved3:      Integer;      {&lt;- reserved for input}
      scsiAdditionalLength: Integer;      {&lt;- additional length of PB}
   END;
   SCSIAbortCommandPB = 
   PACKED RECORD
      qLink:               ^SCSIHdr;      {internal use, must be NIL}
      scsiReserved1:       Integer;       {-&gt; reserved for input}
      scsiPBLength:        Integer;       {-&gt; length of the entire PB}
      scsiFunctionCode:    Byte;          {-&gt; function selector}
      scsiReserved2:       Byte;          {&lt;- reserved for output}
      scsiResult:          OSErr;         {&lt;- returned result}
      scsiDevice:          DeviceIdent;   {-&gt; device ID (bus+target+LUN)}
      scsiCompletion:      CallbackProc;  {-&gt; completion routine pointer}
      scsiFlags:           LongInt;       {-&gt; assorted flags}
      scsiDriverStorage:   ^Byte;         {&lt;&gt; pointer for driver private use}
      scsiXPTprivate:      Ptr;           {private field for XPT}
      scsiReserved3:       LongInt;       {reserved}
      scsiIOptr:           ^SCSI_IO;      {-&gt; pointer to the PB to abort}
   END;
   SCSITerminateIOPB = 
   PACKED RECORD
      qLink:               ^SCSIHdr;      {internal use, must be NIL}
      scsiReserved1:       Integer;       {-&gt; reserved for input}
      scsiPBLength:        Integer;       {-&gt; length of the entire PB}
      scsiFunctionCode:    Byte;          {-&gt; function selector}
      scsiReserved2:       Byte;          {&lt;- reserved for output}
      scsiResult:          OSErr;         {&lt;- returned result}
      scsiDevice:          DeviceIdent;   {-&gt; device ID (bus+target+LUN)}
      scsiCompletion:      CallbackProc;  {-&gt; completion routine pointer}
      scsiFlags:           LongInt;       {-&gt; assorted flags}
      scsiDriverStorage:   ^Byte;         {&lt;&gt; pointer for driver private use}
      scsiXPTprivate:      Ptr;           {private field for XPT}
      scsiReserved3:       LongInt;       {reserved}
      scsiIOptr:           ^SCSI_IO;      {-&gt; pointer to the PB to terminate}
   END;
   SCSIGetVirtualIDInfoPB = 
   PACKED RECORD
      qLink:               ^SCSIHdr;      {internal use, must be NIL}
      scsiReserved1:       Integer;       {-&gt; reserved for input}
      scsiPBLength:        Integer;       {-&gt; length of the entire PB}
      scsiFunctionCode:    Byte;          {-&gt; function selector}
      scsiReserved2:       Byte;          {&lt;- reserved for output}
      scsiResult:          OSErr;         {&lt;- returned result}
      scsiDevice:          DeviceIdent;   {-&gt; device ID (bus+target+LUN)}
      scsiCompletion:      CallbackProc;  {-&gt; completion routine pointer}
      scsiFlags:           LongInt;       {-&gt; assorted flags}
      scsiDriverStorage:   ^Byte;         {&lt;&gt; pointer for driver private use}
      scsiXPTprivate:      Ptr;           {private field for XPT}
      scsiReserved3:       LongInt;       {reserved}
      scsiOldCallID:       Integer;       {-&gt; SCSI ID of device in question}
      scsiExists:          Boolean;       {&lt;- true if device exists}
   END;
   SCSIDriverPB = 
   PACKED RECORD
      qLink:               ^SCSIHdr;      {internal use, must be NIL}
      scsiReserved1:       Integer;       {-&gt; reserved for input}
      scsiPBLength:        Integer;       {-&gt; length of the entire PB}
      scsiFunctionCode:    Byte;          {-&gt; function selector}
      scsiReserved2:       Byte;          {&lt;- reserved for output}
      scsiResult:          OSErr;         {&lt;- returned result}
      scsiDevice:          DeviceIdent;   {-&gt; device ID (bus+target+LUN)}
      scsiCompletion:      CallbackProc;  {-&gt; completion routine pointer}
      scsiFlags:           LongInt;       {-&gt; assorted flags}
      scsiDriverStorage:   ^Byte;         {&lt;&gt; pointer for driver private use}
      scsiXPTprivate:      Ptr;           {private field for XPT}
      scsiReserved3:       LongInt;       {reserved}
      scsiDriver:          Integer;       {&lt;&gt; driver reference number}
      scsiDriverFlags:     Integer;       {&lt;&gt; details of driver/device}
      scsiNextDevice:      DeviceIdent;   {&lt;- DeviceIdent of the next driver}
   END;
   SCSILoadDriverPB = 
   PACKED RECORD
      qLink:               ^SCSIHdr;      {internal use, must be NIL}
      scsiReserved1:       Integer;       {-&gt; reserved for input}
      scsiPBLength:        Integer;       {-&gt; length of the entire PB}
      scsiFunctionCode:    Byte;          {-&gt; function selector}
      scsiReserved2:       Byte;          {&lt;- reserved for output}
      scsiResult:          OSErr;         {&lt;- returned result}
      scsiDevice:          DeviceIdent;   {-&gt; device ID (bus+target+LUN)}
      scsiCompletion:      CallbackProc;  {-&gt; completion routine pointer}
      scsiFlags:           LongInt;       {-&gt; assorted flags}
      scsiDriverStorage:   ^Byte;         {&lt;&gt; pointer for driver private use}
      scsiXPTprivate:      Ptr;           {private field for XPT}
      scsiReserved3:       LongInt;       {reserved}
      scsiLoadedRefNum:    Integer;       {&lt;- SIM returns driver refNum}
      scsiDiskLoadFailed:  Boolean;       {-&gt; if true, previous call failed}
   END;
   SIMInitInfo = 
   PACKED RECORD
      SIMstaticPtr:        ^Byte;         {&lt;- pointer to SIM's static data}
      staticSize:          LongInt;       {-&gt; requested SIM static data size}
      SIMInit:             SIMInitProc;   {-&gt; SIMInit function pointer}
      SIMAction:           SIMActionProc; {-&gt; SIMAction function pointer}
      SIM_ISR:             SCSIProc;      {reserved}
      SIMInterruptPoll:    InterruptPollProc;{-&gt; SIMInterruptPoll function}
      NewOldCall:          SIMActionProc; {-&gt; NewOldCall function pointer}
      ioPBSize:            Integer;       {-&gt; size of SCSI_IO PB for SIM}
      oldCallCapable:      Boolean;       {-&gt; true if SIM supports old-API}
      simInfoUnused1:      Byte;          {reserved}
      simInternalUse:      LongInt;       { not affected or viewed by XPT}
      XPT_ISR:             SCSIProc;      {reserved}
      EnteringSIM:         SCSIProc;      {&lt;- EnteringSIM function pointer}
      ExitingSIM:          SCSIProc;      {&lt;- ExitingSIM function pointer}
      MakeCallback:        MakeCallbackProc;{&lt;- MakeCallback function ptr}
      busID:               Integer;       {&lt;- bus number assigned by XPT}
      simInfoUnused3:      Integer;       {&lt;- reserved}
      simInfoUnused4:      LongInt;       {&lt;- reserved}
   END;
</PRE>
<A NAME=HEADING202-71></A>
<H3>Routines</H3>
<PRE>
FUNCTION SCSIAction        (VAR ioPtr: SCSI_PB): OSErr;
FUNCTION SCSIRegisterBus   (VAR ioPtr: SIMInitInfo): OSErr;
FUNCTION SCSIDeregisterBus (VAR ioPtr: SIMInitInfo): OSErr;
FUNCTION SCSIReregisterBus (VAR ioPtr: SIMInitInfo): OSErr;
FUNCTION SCSIKillXPT       (VAR ioPtr: SIMInitInfo): OSErr;
</PRE>
<A NAME=HEADING202-73></A>
<H2>Assembly-Language Summary</H2>
<A NAME=HEADING202-74></A>
<H3>Data Structures</H3>
<A NAME=HEADING202-75></A>
<H4>The Device Identification Record
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>diReserved<TD>byte<TD>reserved<TR>
<TD>1<TD>bus<TD>byte<TD>bus number<TR>
<TD>2<TD>targetID<TD>byte<TD>target SCSI ID<TR>
<TD>3<TD>LUN<TD>byte<TD>logical unit number</TABLE>
</H4>
<A NAME=HEADING202-76></A>
<H4>The Command Descriptor Block Record
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>cdbPtr<TD>long<TD>CDB buffer pointer<TR>
<TD>4<TD>cdbBytes<TD>16 bytes<TD>CDB buffer</TABLE>
</H4>
<A NAME=HEADING202-77></A>
<H4>The Scatter/Gather List Element
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>SGAddr<TD>long<TD>buffer pointer<TR>
<TD>4<TD>SGCount<TD>long<TD>buffer size</TABLE>
</H4>
<A NAME=HEADING202-78></A>
<H4>The SCSI Manager Parameter Block Header
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>qLink<TD>long<TD>used internally by the SCSI Manager<TR>
<TD>4<TD>scsiReserved<TD>word<TD>reserved<TR>
<TD>6<TD>scsiPBLength<TD>word<TD>parameter block size<TR>
<TD>8<TD>scsiFunctionCode<TD>byte<TD>function selector code<TR>
<TD>9<TD>scsiReserved2<TD>byte<TD>reserved<TR>
<TD>10<TD>scsiResult<TD>word<TD>result code<TR>
<TD>12<TD>scsiDevice<TD>4 bytes<TD>device ID (bus number, target ID, LUN)<TR>
<TD>16<TD>scsiCompletion<TD>long<TD>completion routine<TR>
<TD>20<TD>scsiFlags<TD>long<TD>flags<TR>
<TD>24<TD>scsiDriverStorage<TD>long<TD>driver private data<TR>
<TD>28<TD>scsiXPTprivate<TD>long<TD>reserved<TR>
<TD>32<TD>scsiReserved3<TD>long<TD>reserved</TABLE>
</H4>
<A NAME=HEADING202-79></A>
<H4>The SCSI I/O Parameter Block
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>SCSIPBHdr<TD>36 bytes<TD>parameter block header<TR>
<TD>36<TD>scsiResultFlags<TD>word<TD>I/O result flags<TR>
<TD>38<TD>scsiReserved12<TD>word<TD>reserved<TR>
<TD>40<TD>scsiDataPtr<TD>long<TD>data buffer pointer<TR>
<TD>44<TD>scsiDataLength<TD>long<TD>data buffer size<TR>
<TD>48<TD>scsiSensePtr<TD>long<TD>autosense buffer pointer<TR>
<TD>52<TD>scsiSenseLength<TD>byte<TD>autosense buffer size<TR>
<TD>53<TD>scsiCDBLength<TD>byte<TD>CDB size<TR>
<TD>54<TD>scsiSGListCount<TD>word<TD>number of scatter/gather list entries<TR>
<TD>56<TD>scsiReserved4<TD>long<TD>reserved<TR>
<TD>60<TD>scsiSCSIstatus<TD>byte<TD>SCSI device status<TR>
<TD>61<TD>scsiSenseResidual<TD>byte<TD>autosense residual length<TR>
<TD>62<TD>scsiReserved5<TD>word<TD>reserved<TR>
<TD>64<TD>scsiDataResidual<TD>long<TD>data transfer residual length<TR>
<TD>68<TD>scsiCDB<TD>16 bytes<TD>command descriptor block record<TR>
<TD>84<TD>scsiTimeout<TD>long<TD>timeout value, in Time Manager format<TR>
<TD>88<TD>scsiReserved13<TD>long<TD>reserved<TR>
<TD>92<TD>scsiReserved14<TD>long<TD>reserved<TR>
<TD>94<TD>scsiIOFlags<TD>word<TD>I/O flags<TR>
<TD>96<TD>scsiTagAction<TD>byte<TD>reserved<TR>
<TD>97<TD>scsiReserved6<TD>byte<TD>reserved<TR>
<TD>98<TD>scsiReserved7<TD>word<TD>reserved<TR>
<TD>100<TD>scsiSelectTimeout<TD>word<TD>selection timeout value, in milliseconds<TR>
<TD>102<TD>scsiDataType<TD>byte<TD>data type of <CODE>scsiDataPtr</CODE><TR>
<TD>103<TD>scsiTransferType<TD>byte<TD>transfer mode (polled or blind)<TR>
<TD>104<TD>scsiReserved8<TD>long<TD>reserved<TR>
<TD>108<TD>scsiReserved9 <TD>long<TD>reserved<TR>
<TD>112<TD>scsiHandshake<TD>16 bytes<TD>handshaking instructions<TR>
<TD>128<TD>scsiReserved10<TD>long<TD>reserved<TR>
<TD>132<TD>scsiReserved1<TD>long<TD>reserved<TR>
<TD>136<TD>scsiCommandLink<TD>long<TD>linked parameter block pointer<TR>
<TD>140<TD>scsiSIMpublics<TD>8 bytes<TD>additional input to SIM<TR>
<TD>148<TD>scsiAppleReserved6<TD>8 bytes<TD>reserved<TR>
<TD>156<TD>scsiCurrentPhase<TD>word<TD>bus phase after original SCSI Manager function<TR>
<TD>158<TD>scsiSelector<TD>word<TD><CODE>_SCSIDispatch</CODE> selector for original function<TR>
<TD>160<TD>scsiOldCallResult<TD>word<TD>result code of original function<TR>
<TD>162<TD>scsiSCSImessage<TD>byte<TD><CODE>SCSIComplete</CODE> message byte<TR>
<TD>163<TD>XPTprivateFlags<TD>byte<TD>reserved<TR>
<TD>164<TD>XPTextras<TD>12 bytes<TD>reserved<TR>
<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;</TABLE>
</H4>
<A NAME=HEADING202-80></A>
<H4>The SCSI Bus Inquiry Parameter Block
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>SCSIPBHdr<TD>36 bytes<TD>parameter block header<TR>
<TD>36<TD>scsiEngineCount<TD>word<TD>number of engines on the HBA<TR>
<TD>38<TD>scsiMaxTransferType<TD>word<TD>number of data transfer types supported<TR>
<TD>40<TD>scsiDataTypes<TD>long<TD>bit map of supported data types<TR>
<TD>44<TD>scsiIOpbSize <TD>word<TD>SCSI I/O parameter block size for this SIM<TR>
<TD>46<TD>scsiMaxIOpbSize <TD>word<TD>largest parameter block for any registered SIM<TR>
<TD>48<TD>scsiFeatureFlags <TD>long<TD>bus feature flags<TR>
<TD>52<TD>scsiVersionNumber<TD>byte<TD>SIM/HBA version number<TR>
<TD>53<TD>scsiHBAInquiry <TD>byte<TD>bus capability flags<TR>
<TD>54<TD>scsiTargetModeFlags<TD>byte<TD>reserved<TR>
<TD>55<TD>scsiScanFlags <TD>byte<TD>scan feature flags<TR>
<TD>56<TD>scsiSIMPrivatesPtr<TD>long<TD>SIM private data pointer<TR>
<TD>60<TD>scsiSIMPrivatesSize<TD>long<TD>SIM private data size<TR>
<TD>64<TD>scsiAsyncFlags <TD>long<TD>reserved<TR>
<TD>68<TD>scsiHiBusID  <TD>byte<TD>highest registered bus number<TR>
<TD>69<TD>scsiInitiatorID <TD>byte<TD>SCSI ID of the HBA<TR>
<TD>70<TD>scsiBIReserved0 <TD>word<TD>reserved<TR>
<TD>72<TD>scsiBIReserved1 <TD>long<TD>reserved<TR>
<TD>76<TD>scsiFlagsSupported<TD>long<TD>bit map of supported <CODE>scsiFlags</CODE><TR>
<TD>80<TD>scsiIOFlagsSupported<TD>word<TD>bit map of supported <CODE>scsiIOFlags</CODE><TR>
<TD>82<TD>scsiWeirdStuff <TD>word<TD>miscellaneous flags<TR>
<TD>84<TD>scsiMaxTarget <TD>word<TD>highest SCSI ID supported by the HBA<TR>
<TD>86<TD>scsiMaxLUN  <TD>word<TD>highest LUN supported by the HBA<TR>
<TD>88<TD>scsiSIMVendor <TD>16 bytes<TD>SIM vendor string<TR>
<TD>104<TD>scsiHBAVendor <TD>16 bytes<TD>HBA vendor string<TR>
<TD>120<TD>scsiControllerFamily <TD>16 bytes<TD>SCSI controller family string<TR>
<TD>136<TD>scsiControllerType<TD>16 bytes<TD>SCSI controller type string<TR>
<TD>152<TD>scsiXPTversion <TD>4 bytes<TD>XPT version string<TR>
<TD>156<TD>scsiSIMversion <TD>4 bytes<TD>SIM version string<TR>
<TD>160<TD>scsiHBAversion <TD>4 bytes<TD>HBA version string<TR>
<TD>164<TD>scsiHBAslotType <TD>byte<TD>HBA slot type<TR>
<TD>165<TD>scsiHBAslotNumber <TD>byte<TD>HBA slot number<TR>
<TD>166<TD>scsiSIMsRsrcID <TD>word<TD>SIM sResource ID<TR>
<TD>168<TD>scsiBIReserved3 <TD>word<TD>reserved<TR>
<TD>170<TD>scsiAdditionalLength<TD>word<TD>additional size of the parameter block</TABLE>
</H4>
<A NAME=HEADING202-81></A>
<H4>The SCSI Abort Command Parameter Block
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>SCSIPBHdr<TD>36 bytes<TD>parameter block header<TR>
<TD>36<TD>scsiIOptr<TD>long<TD>SCSI I/O parameter block pointer</TABLE>
</H4>
<A NAME=HEADING202-82></A>
<H4>The SCSI Terminate I/O Parameter Block
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>SCSIPBHdr<TD>36 bytes<TD>parameter block header<TR>
<TD>36<TD>scsiIOptr<TD>long<TD>SCSI I/O parameter block pointer</TABLE>
</H4>
<A NAME=HEADING202-83></A>
<H4>The SCSI Virtual ID Information Parameter Block
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>SCSIPBHdr<TD>36 bytes<TD>parameter block header<TR>
<TD>36<TD>scsiOldCallID<TD>word<TD>virtual SCSI ID of the device to search for<TR>
<TD>38<TD>scsiExists<TD>byte<TD>Boolean (<CODE>true</CODE> if the device was found)</TABLE>
</H4>
<A NAME=HEADING202-84></A>
<H4>The SCSI Load Driver Parameter Block
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>SCSIPBHdr<TD>36 bytes<TD>parameter block header<TR>
<TD>36<TD>scsiLoadedRefNum<TD>word<TD>driver reference number<TR>
<TD>38<TD>scsiDiskLoadFailed<TD>byte<TD>Boolean (<CODE>true</CODE> if a driver could not be loaded)</TABLE>
</H4>
<A NAME=HEADING202-85></A>
<H4>The SCSI Driver Identification Parameter Block
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>SCSIPBHdr<TD>36 bytes<TD>parameter block header<TR>
<TD>36<TD>scsiDriver<TD>word<TD>driver reference number<TR>
<TD>38<TD>scsiDriverFlags<TD>word<TD>driver flags<TR>
<TD>40<TD>scsiNextDevice<TD>4 bytes<TD>device ID of the next device in the list</TABLE>
</H4>
<A NAME=HEADING202-86></A>
<H4>The SIM Initialization Record
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>SIMstaticPtr<TD>long<TD>SIM private data pointer<TR>
<TD>4<TD>staticSize<TD>long<TD>SIM private data size<TR>
<TD>8<TD>SIMInit<TD>long<TD><CODE>SIMInit</CODE> function pointer<TR>
<TD>12<TD>SIMAction<TD>long<TD><CODE>SIMAction</CODE> function pointer<TR>
<TD>16<TD>SIM_ISR<TD>long<TD>reserved<TR>
<TD>20<TD>SIMInterruptPoll<TD>long<TD><CODE>SIMInterruptPoll</CODE> function pointer<TR>
<TD>24<TD>NewOldCall<TD>long<TD><CODE>NewOldCall</CODE> function pointer<TR>
<TD>28<TD>ioPBSize<TD>word<TD>SCSI I/O parameter block size for this SIM<TR>
<TD>30<TD>oldCallCapable<TD>byte<TD>Boolean (<CODE>true</CODE> if SIM accepts original functions)<TR>
<TD>31<TD>simInfoUnused1<TD>byte<TD>reserved<TR>
<TD>32<TD>simInternalUse<TD>long<TD>SIM private data<TR>
<TD>36<TD>XPT_ISR<TD>long<TD>reserved<TR>
<TD>40<TD>EnteringSIM<TD>long<TD>EnteringSIM function pointer<TR>
<TD>44<TD>ExitingSIM<TD>long<TD>ExitingSIM function pointer<TR>
<TD>48<TD>MakeCallback<TD>long<TD>MakeCallback function pointer<TR>
<TD>52<TD>busID<TD>word<TD>bus number<TR>
<TD>54<TD>simInfoUnused3<TD>word<TD>reserved<TR>
<TD>56<TD>simInfoUnused4<TD>long<TD>reserved</TABLE>
</H4>
<A NAME=HEADING202-87></A>
<H3>Trap Macros</H3>
<A NAME=HEADING202-88></A>
<H4>Trap Macros Requiring Routine Selectors</H4>
<PRE>
_SCSIAtomic
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Selector<TH>Routine<TR>
<TD>$0001<TD><CODE>SCSIAction</CODE><TR>
<TD>$0002<TD><CODE>SCSIRegisterBus</CODE><TR>
<TD>$0003<TD><CODE>SCSIDeregisterBus</CODE><TR>
<TD>$0004<TD><CODE>SCSIReregisterBus</CODE><TR>
<TD>$0005<TD><CODE>SCSIKillXPT</CODE></TABLE>

</PRE>
<A NAME=HEADING202-90></A>
<H2><A NAME=MARKER-9-248></A>Result Codes
<TABLE BORDER="0" CELLPADDING=3><TD>noErr<TD>0<TD>No error<TR>
<TD>scsiRequestInProgress<TD>1<TD>Parameter block request is in progress<TR>
<TD>scsiCDBLengthInvalid<TD>-7863<TD>The CDB length supplied is not supported by this SIM; typically this means it was too big<TR>
<TD>scsiTransferTypeInvalid<TD>-7864<TD>The <CODE>scsiTransferType</CODE> is not supported by this SIM<TR>
<TD>scsiDataTypeInvalid<TD>-7865<TD>SIM does not support the requested <CODE>scsiDataType</CODE><TR>
<TD>scsiIDInvalid<TD>-7866<TD>The initiator ID is invalid<TR>
<TD>scsiLUNInvalid<TD>-7867<TD>The logical unit number is invalid<TR>
<TD>scsiTIDInvalid<TD>-7868<TD>The target ID is invalid<TR>
<TD>scsiBusInvalid<TD>-7869<TD>The bus ID is invalid<TR>
<TD>scsiRequestInvalid<TD>-7870<TD>The parameter block request is invalid<TR>
<TD>scsiFunctionNotAvailable<TD>-7871<TD>The requested function is not supported by this SIM<TR>
<TD>scsiPBLengthError<TD>-7872<TD>The parameter block length is too small for this SIM<TR>
<TD>scsiQLinkInvalid<TD>-7881<TD>The <CODE>qLink</CODE> field was not 0<TR>
<TD>scsiNoSuchXref<TD>-7882<TD>No driver has been cross-referenced with this device<TR>
<TD>scsiDeviceConflict<TD>-7883<TD>Attempt to register more than one driver to a device<TR>
<TD>scsiNoHBA<TD>-7884<TD>No HBA detected<TR>
<TD>scsiDeviceNotThere<TD>-7885<TD>SCSI device not installed or available<TR>
<TD>scsiProvideFail<TD>-7886<TD>Unable to provide the requested service<TR>
<TD>scsiBusy<TD>-7887<TD>SCSI subsystem is busy<TR>
<TD>scsiTooManyBuses<TD>-7888<TD>SIM registration failed because the XPT registry is full<TR>
<TD>scsiCDBReceived<TD>-7910<TD>The SCSI CDB was received<TR>
<TD>scsiNoNexus<TD>-7911<TD>Nexus is not established<TR>
<TD>scsiTerminated<TD>-7912<TD>Parameter block request terminated by the host<TR>
<TD>scsiBDRsent<TD>-7913<TD>A SCSI bus device reset (BDR) message was sent to the target<TR>
<TD>scsiWrongDirection<TD>-7915<TD>Data phase was in an unexpected direction<TR>
<TD>scsiSequenceFail<TD>-7916<TD>Target bus phase sequence failure<TR>
<TD>scsiUnexpectedBusFree<TD>-7917<TD>Unexpected bus free phase<TR>
<TD>scsiDataRunError<TD>-7918<TD>Data overrun/underrun error<TR>
<TD>scsiAutosenseFailed<TD>-7920<TD>Automatic <CODE>REQUEST SENSE</CODE> command failed<TR>
<TD>scsiParityError<TD>-7921<TD>An uncorrectable parity error occurred<TR>
<TD>scsiSCSIBusReset<TD>-7922<TD>Execution of this parameter block was halted because of a SCSI bus reset<TR>
<TD>scsiMessageRejectReceived<TD>-7923<TD><CODE>REJECT</CODE> message received<TR>
<TD>scsiIdentifyMessageRejected<TD>-7924<TD>The target issued a <CODE>REJECT</CODE> message in response to the <CODE>IDENTIFY</CODE> message; the LUN probably does not exist<TR>
<TD>scsiCommandTimeout<TD>-7925<TD>The timeout value for this parameter block was exceeded and the parameter block was aborted<TR>
<TD>scsiSelectTimeout<TD>-7926<TD>Target selection timeout<TR>
<TD>scsiUnableToTerminate<TD>-7927<TD>Unable to terminate I/O parameter block request<TR>
<TD>scsiNonZeroStatus<TD>-7932<TD>The target returned non-zero status upon completion of the request<TR>
<TD>scsiUnableToAbort<TD>-7933<TD>Unable to abort parameter block request<TR>
<TD>scsiRequestAborted<TD>-7934<TD>Parameter block request aborted by the host</TABLE>
</H2>
 <A NAME=MARKER-2-249></A><P>
</BLOCKQUOTE><P>
<HR>
<center>
<A HREF="Devices-201.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-203.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Devices-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML>  
