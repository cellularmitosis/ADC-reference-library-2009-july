<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html><head>
<!-- BEGIN META TAG INFO -->
<link rel="home" href="http://developer.apple.com/">
<link rel="find" href="http://developer.apple.com/search/">
<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
<script language="JavaScript" type="text/javascript" src="../../documentation/js/busnav.js"></script>
<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- END META TAG INFO -->
<!-- BEGIN TITLE -->
<title>Technical Note TN1195: Tagging Handle and Pointer Data References in QuickTime</title>
<!-- END TITLE -->
</head>
<!-- BEGIN BODY OPEN -->
<body bgcolor="#ffffff"><a name="//apple_ref/doc/uid/DTS10003034" title="Tagging Handle and Pointer Data References in QuickTime"></a>
<!--END BODY OPEN -->
<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->
<a name="top"></a>
<!-- BEGIN LOGO AND SEARCH -->
<!--#include virtual="/includes/adcnavbar"-->
<!-- END LOGO AND SEARCH -->
<!-- START BREADCRUMB -->
<div id="breadcrumb"><table width="680" border="0" cellpadding="0" cellspacing="0"><tr>
<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
<td><img width="340" height="10" src="images/1dot.gif" alt=""></td></tr><tr valign="middle"><td align="left" colspan="2">
<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/QuickTime/index.html">QuickTime</a> &gt; <a href="../../technicalnotes/QuickTime/idxMovieBasics-date.html">Movie Basics</a> &gt; 
</td></tr><tr><td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td></tr></table></div>
<!-- END BREADCRUMB -->

<!-- START MAIN CONTENT -->
<!-- START TITLE GRAPHIC AND INTRO-->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top">
<td><h1>
<div id="pagehead">Technical Note TN1195</div>
<div id="pageheadsub">Tagging Handle and Pointer Data References in QuickTime</div>
</h1></td></tr></table>
<!-- END TITLE GRAPHIC AND INTRO -->
<!-- BEGIN WIDE COLUMN -->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td align="left" width="680">
<!-- BEGIN CONTENTS -->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td><p>This Technote discusses the use of data reference extensions, which are used by QuickTime to tag handle and pointer data references. Data reference extensions give you the ability to associate Mac OS file type, MIME type, initialization data and/or file name information with a given data reference.</p><p>This note is directed at developers who want to take advantage of this feature in QuickTime.</p></td></tr><tr><td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br><img height="1" width="680" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt=""></td></tr></table><table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td width="680"><ul><li><a href="#TNTAG1">Overview</a></li><li><a href="#TNTAG2">Data References</a></li><li><a href="#TNTAG5">Constructing Data Reference Handles</a><ul><li><a href="#TNTAG6">Alias Data Reference Handle</a></li><li><a href="#TNTAG8">Handle Data Reference Handle</a></li><li><a href="#TNTAG11">Pointer Data Reference Handle</a></li><li><a href="#TNTAG26">URL Data Reference Handle</a></li><li><a href="#TNTAG13">Resource Data Reference Handle</a></li></ul></li><li><a href="#TNTAG15">Data Reference Extensions</a></li><li><a href="#TNTAG19">Building a Handle or Pointer Data Reference with Data Reference Extensions</a></li><li><a href="#TNTAG22">Additional Notes & Comments</a></li><li><a href="#TNTAG23">Summary</a></li><li><a href="#TNTAG24">References</a></li><li><a href="#TNT_HISTORY_TAG">Document Revision History</a></li></ul></td></tr><tr><td colspan="3" scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br><img height="1" width="680" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt=""></td></tr></table><A NAME="TNTAG1"></A><H2>Overview</H2><p>When you ask QuickTime to create a new movie from a file which is not a QuickTime movie file, QuickTime will locate an appropriate movie importer component to read the file. In doing so, QuickTime needs to know the type of data in the file. It usually find this information through either the file type,  file extension, or MIME type associated with the file. If the data is in memory referenced via a handle data reference or a pointer data reference, none of this information is available. To remedy this, you can attach (&quot;tag&quot;) this information to the data reference as a data reference extension so QuickTime knows the type of the data -- you can attach the MIME type extension, MacOS File Type extension or you can use the File Name extension with an appropriate file extension. You can also specify initialization data for the handle data reference.</p><p>After tagging the data reference, any QuickTime function call that will look at the type of data (<code><code>GetGraphicsImporterForDataRef</code></code>, <code>NewMovieFromDataRef</code>, <code>GetMovieImporterForDataRef</code>, etc.) will find the type information you provided.</p><div class="notebox"><p><strong>IMPORTANT:</strong> If you ask QuickTime to create a new movie for any non-QuickTime movie (.mov) data in a handle or pointer data reference <strong> without </strong> specifying any of the data reference extensions (filename, file type, MIME type, and so on) this will fail with the -2048 <code>noMovieFound</code> error. You must set at least one of the data reference extensions.</p><p>Alternately, you can use the <A HREF="../../documentation/QuickTime/APIREF/movieimportdataref.htm">MovieImportDataRef</A> function and directly specify the movie importer component you would like to use to perform the import (rather than let QuickTime decide based on the data reference extensions). See <A HREF="../../qa/qtmtb/qtmtb52.html">Q&amp;A QTMTB52 - Playing memory resident WAVE data using QuickTime</A> for an example code listing.</p></div><p>For example, you can tag a handle to a PhotoShop image file's data with the Mac OS <code>'8BPS'</code> file type and be assured that the correct Graphics Importer Component will be chosen.</p><p>Also, the handle and pointer data handlers are the only data handlers that support the above extensions since there's no intrinsic file type, file name or MIME type for a handle or pointer to a block of memory.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG2"></A><H2>Data References</H2><p>The handle and pointer data handlers are the only data handlers that support the data reference extensions. So what exactly is a handle or pointer data reference? A handle or pointer data reference is simply a reference to data that resides in a block of memory as specified by a handle or pointer, rather than in a file (or somewhere else).</p><p>In QuickTime, all data handlers identify their data with data references. Data references specify the location of the data, and the data reference type indicates the data handler able to interpret the data. We can therefore specify a data reference programatically by a type value and a reference value as follows:</p><p class="smalltext"><strong>Table 1:</strong> Specifying a Data Reference.</p><table cellspacing="0" class="graybox"><tr><th>type</th><th>description</th></tr><tr><td scope="row">OSType dataRefType</td><td>Specifies the type of data reference</td></tr><tr><td scope="row">Handle dataRef</td><td>Specifies the actual data reference</td></tr></table><p>The dataRef value specifies the actual data reference. This is a handle to the information that identifies the data to be used. The type of information stored in the handle depends on the data reference type. For example, if your application is loading a movie from a file, this handle would contain a Macintosh alias to the movie file.</p><p>The dataRefType value specifies the type of data reference. For example, for an alias data reference you set this to <code>rAliasType</code> ('alis'), indicating that the reference is an alias.</p><p>Listed below are all the available data reference types:</p><p class="smalltext"><strong>Table 2:</strong> Data Reference Types.</p><table cellspacing="0" class="graybox"><tr><th>Data reference type</th><th>Description</th></tr><tr><td scope="row">'alis'</td><td>Data reference is a Macintosh alias handle. An alias handle contains information about the file, including its full path name. For more information about aliases, see Inside Macintosh: Files.</td></tr><tr><td scope="row">'hndl'</td><td>Data reference is a Macintosh handle containing the data. For more information about Macintosh handles, see Inside Macintosh: Memory. In addition to specifying movie data in memory, this handle may contain data reference extensions as described in section &quot;Data Reference Extensions&quot; below.</td></tr><tr><td scope="row">'rsrc'</td><td>Data reference is a Macintosh alias handle. However, appended to the end of the alias handle is the resource type (stored as a 32-bit unsigned integer) and ID (stored as a 16-bit signed integer) to use within the specified file. Both these values must be big-endian format.</td></tr><tr><td scope="row">'url '</td><td>Data reference is a handle whose data is a C-string (null-terminated) specifying a URL (note: a URL data reference can have data reference extensions too, so the actual size of a URL data reference may be larger than the length of the string).</td></tr><tr><td scope="row">'ptr '</td><td>Data reference is a pointer to the data in memory plus a size value. In addition to specifying movie data in memory, the pointer data reference may contain data reference extensions as described in section &quot;Data Reference Extensions&quot; below</td></tr></table><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG5"></A><H2>Constructing Data Reference Handles</H2><p>How do you construct a data reference handle? As stated above, the information that identifies the data is specified in the data reference handle (while the type of the data reference is specified in the data reference type). Here's how to construct data reference handles for the various data references:</p><A NAME="TNTAG6"></A><H3>Alias Data Reference Handle</H3><p>The alias data reference handle is a standard Macintosh alias handle (see Inside Macintosh:Files for more information). Here's code showing how to construct the data reference handle for an alias data reference. In our example, you pass a standard Macintosh file system specification record for the desired file in the <code>theFile</code> parameter and an alias handle is returned. We use the <code>NewAlias</code> function to create the alias handle, but you can also use any of the other Alias Manager functions which return an alias handle (<code>QTNewAlias</code>, <code>NewAliasMinimal</code>, <code>NewAliasMinimalFromFullPath</code>, etc.):</p><p class="smalltext"><strong>Listing 1:</strong> Creating an alias data reference.</p><pre class="sourcecodebox">
Handle MyCreateAliasDataReferenceHandle(const FSSpec *theFile)
{
    OSErr err;
    AliasHandle theAlias;

    err = NewAlias(NULL, theFile, &amp;theAlias);
    if (err == noErr)
    {
        return (Handle)theAlias;
    }

    return NULL;
}
</pre><p>Also, new with QuickTime 6.4 are a set of convenience functions for creating alias data references from various file references. These are shown below. For more information, see <A HREF="../../documentation/QuickTime/whatsnew.htm#//apple_ref/doc/uid/TP40001050">What's New in QuickTime 6.4</A>.</p><p><code>QTNewDataReferenceFromFSRef</code> - creates an alias data reference from a file specification</p><p><code>QTNewDataReferenceFromFSRefCFString</code> - creates an alias data reference from a file reference pointing to a directory and a file name.</p><p><code>QTNewDataReferenceFromFSSpec</code> - creates an alias data reference from a file specification of type <code>FSSpec</code>.</p><p><code>QTNewDataReferenceWithDirectoryCFString</code> - creates an alias data reference from another alias data reference pointing to the parent directory and a <code>CFString</code> that contains the file name.</p><p><code>QTNewDataReferenceFromFullPathCFString</code> - creates an alias data reference from a <code>CFString</code> that represents the full pathname of a file.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG8"></A><H3>Handle Data Reference Handle</H3><p>The handle data reference handle is a handle whose data is a Macintosh handle containing the actual data. Here's code showing how to construct the data reference handle for a handle data reference. In our example, you simply pass a handle to your actual data in the <code>theDataH</code> parameter and a data reference handle is returned. The data reference handle may be null, in which case the actual data would need to be specified by a data ('data') data reference extension (see &quot;Data Reference Extensions&quot;).</p><p class="smalltext"><strong>Listing 2:</strong> Creating a handle data reference.</p><pre class="sourcecodebox">
Handle MyCreateDataReferenceHandle(Handle theDataH)
{
    Handle  dataRef = NULL;
    OSErr   err     = noErr;

    // Create a data reference handle for our data.
    err = PtrToHand( &amp;theDataH, &amp;dataRef, sizeof(Handle));

    return dataRef;
}
</pre><div class="notebox"><p><strong>Note:</strong> most QuickTime functions which accept data references accept the data reference handle and data reference type as separate parameters. For example, here's how you would pass a handle data reference to the Graphics Importer function <code><code>GetGraphicsImporterForDataRef</code></code>:</p></div><p class="smalltext"><strong>Listing 3:</strong> Using a handle data reference with GetGraphicsImporterForDataRef.</p><pre class="sourcecodebox">
void MyGetGraphicsImporterForDataRef(Handle ourData)
{
    OSErr err;
    ComponentInstance gi;
    Handle dataRefH = NULL;

    dataRefH = MyCreateDataReferenceHandle(ourData);
    if (dataRefH)
    {
        err = GetGraphicsImporterForDataRef (
                 dataRefH,                 /* data reference */
                 HandleDataHandlerSubType, /* data ref type */
                 &amp;gi);                     /* importer returned here */

         /* ...now use the returned graphics importer component
          gi as you please... */

         /* close the graphics importer component instance when
        we are done */
        CloseComponent(gi);
    }

    /* clean up our data reference handle when we
       are done */
    if (dataRefH)
    {
     DisposeHandle(dataRefH);
    }
}
</pre><div class="notebox"><p><strong>Note:</strong> you would need to dispose of the data reference handle when you are done.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG11"></A><H3>Pointer Data Reference Handle</H3><p>The pointer data reference handle is a handle whose data is a record containing a pointer to the actual data along with a value specifying the size of the data. Here's code showing how to construct the data reference handle for a pointer data reference. In our example, you simply pass a pointer to your actual data in the <code>data</code> parameter as well as the size of the data in the <code>dataSize</code> parameter and a pointer data reference handle is returned:</p><p class="smalltext"><strong>Listing 4:</strong> Creating a pointer data reference.</p><pre class="sourcecodebox">
Handle MyCreatePointerReferenceHandle(void *data, Size dataSize)
{
    PointerDataRefRecord    ptrDataRefRec;
    Handle                  dataRef = NULL;
    OSErr                   err     = noErr;


    ptrDataRefRec.data          = data;
    ptrDataRefRec.dataLength    = dataSize;

    // create a data reference handle for our data
    err = PtrToHand( &amp;ptrDataRefRec, &amp;dataRef, sizeof(PointerDataRefRecord));

    return dataRef;
}
</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG26"></A><H3>URL Data Reference Handle</H3><p>The URL data reference handle is a handle whose data is a C-string (null-terminated) specifying a URL. Here's code showing how to construct the data reference handle for a URL data reference:</p><p class="smalltext"><strong>Listing 5:</strong> Creating a URL data reference.</p><pre class="sourcecodebox">
Handle MyCreateURLDataReferenceHandle(char *theURL)
{
    Handle          myDataRef = NULL;
    Size            mySize = 0;

    // get the size of the URL, plus the terminating null byte
    mySize = (Size)strlen(theURL) + 1;
    if (mySize &lt;= 1)
        goto bail;

    // copy the URL into the handle
    PtrToHand(theURL, &amp;myDataRef, mySize);

bail:
    return(myDataRef);
}
</pre><p>Also, new with QuickTime 6.4 are a set of convenience functions for creating URL data references. These are shown below. For more information, see <A HREF="../../documentation/QuickTime/whatsnew.htm#//apple_ref/doc/uid/TP40001050">What's New in QuickTime 6.4</A>.</p><p><code>QTNewDataReferenceFromCFURL</code> - creates a URL data reference from a <code>CFURL</code>.</p><p><code>QTNewDataReferenceFromURLCFString</code> - creates a URL data reference from a <code>CFString</code> that represents a URL string.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG13"></A><H3>Resource Data Reference Handle</H3><p>The resource data reference handle is also a Macintosh alias handle. However, appended to the end of the alias handle is the resource type (stored as a 32-bit unsigned integer) and ID (stored as a 16-bit signed integer) to use within the specified file. These values must be big-endian format.</p><p>Here's code showing how to construct the data reference handle for a resource data reference. In our example, we build a data reference for a standard QuickTime movie file whose movie resource resides in the resource fork of the file. Pass a standard Macintosh file system specification record for the desired movie file in the <code>theFile</code> parameter. Next, an alias handle is created for this file. Finally, we append to this alias handle the resource type for the movie resource (type 'moov') along with the movie resource ID (128). Once this information is appended, the completed resource data reference handle is returned.</p><p>Note you can use any of the other Alias Manager functions to create the alias handle (<code>QTNewAlias</code>, <code>NewAliasMinimal</code>, <code>NewAliasMinimalFromFullPath</code>, etc.):</p><p class="smalltext"><strong>Listing 6:</strong> Type your listing title text here.</p><pre class="sourcecodebox">
Handle MyCreateResourceDataReferenceHandle(FSSpec *theFile)
{
    OSErr err;
    AliasHandle theAlias;

    err = NewAlias(NULL, theFile, &amp;theAlias);
    if (err == noErr)
    {
        OSType ourType = EndianU32_NtoB(MovieResourceType);
        short ourID = EndianU16_NtoB(128);

        /* append resource type */
        err = PtrAndHand(&amp;ourType, (Handle)theAlias, sizeof(OSType));

        /* append resource id */
        err = PtrAndHand(&amp;ourID, (Handle)theAlias, sizeof(short));

        return (Handle)theAlias;
    }

    return NULL;
}
</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG15"></A><H2>Data Reference Extensions</H2><p>One can certainly construct a handle or pointer data reference for a given piece of data, and use this data reference with any of the QuickTime API's which operate on data references. However, if you just construct a &quot;plain&quot; handle or pointer data reference, the reference doesn't contain any information about the file type or file name, so QuickTime will end up performing a slow validate search to identify the file (since there's really no other way). As well as being slow, this technique will miss some file formats which can't be detected by validation.</p><p>For example, when you call the <code>GetGraphicsImporterForFile</code> function to try to obtain a graphics importer for a given file, QuickTime first tries to locate a graphics importer component for the specified file based on the Macintosh file type of the file. If it is unable to locate a graphics importer component based on the Macintosh file type, <code>GetGraphicsImporterForFile</code> will try to locate a graphics importer component for the specified file based on the file name extension of the file.</p><p>If you have the file name, you should add the file name to the handle or pointer data reference. If you know the file type or MIME type, you should add this information as well. You can also specify any initialization data for the handle data reference.</p><p>How do you go about adding this information to a handle or pointer data reference? Use the handle or pointer data reference extensions.</p><div class="notebox"><p><strong>Note:</strong> The pointer and handle data handlers treat data reference extensions differently. In particular, the internal format of the tags for pointer data references is not identical to that of handle data references. For this reason, the pointer data handler supports the following data handler functions for getting and setting the extensions:</p><p><code>DataHSetDataRefExtension</code></p><p><code>DataHGetDataRefExtension</code></p><p>Developers should make use of these functions for getting and setting the extensions, rather than building and parsing the extensions by hand. See <A HREF="#TNTAG19">Building a Handle or Pointer Data Reference with Data Reference Extensions</A> below for code snippets showing how to construct data reference extensions for both handle and pointer data references.</p></div><p>Here's the format of a data reference handle with data reference extensions:</p><p>The format of a handle data reference is:</p><p class="caption"><strong>Figure 1:</strong> Data reference handle.</p><p><img  src="images/tn1195_001.jpg" width="290" height="110" alt="Figure 1, Data reference handle."></p><p>optionally continued by a pascal string containing the file name (*not padded* - zero byte if not available). Note the filename is not really a data reference extension - QuickTime will recognize any file name added to the data reference.</p><p class="caption"><strong>Figure 2:</strong> Optional file name.</p><p><img  src="images/tn1195_002.jpg" width="360" height="90" alt="Figure 2, Optional file name."></p><p>optionally continued by a sequence of n classic atoms, whose format is as follows (atom size and atom type fields must be big-endian):</p><p class="caption"><strong>Figure 3:</strong> Optional sequence of classic atoms.</p><p><img  src="images/tn1195_003.jpg" width="280" height="180" alt="Figure 3, Optional sequence of classic atoms."></p><p>Atom types may be any of the following:</p><ul><li><p>'ftyp' - Mac OS file type, data is a big-endian OSType</p></li><li><p>'mime' - MIME type, data is a pascal string (no padding)</p></li><li><p>'data' - Initialization data (for handle data reference only), data can be a any block of image, video/audio data, etc.</p></li></ul><div class="notebox"><p><strong>Note:</strong> The pointer data reference does not support the initialization data extension ('data').</p></div><div class="notebox"><p><strong>Note:</strong> If you add any of these atoms, you MUST add a file name first -- even if it is an empty Pascal string.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG19"></A><H2>Building a Handle or Pointer Data Reference with Data Reference Extensions</H2><p>As shown above, building a handle or pointer data reference with data reference extensions involves first creating a data reference handle for your data, then adding any additional data reference extension information (Mac OS file type, MIME type and/or file name, initialization data) that you may have for this data reference handle. Listed below are code snippets which demonstrate how it's done.</p><div class="notebox"><p><strong>Note:</strong> Remember, as stated in <A HREF="#TNTAG15">Data Reference Extensions</A> when adding data reference extensions to the pointer data reference you should use the data handler functions <code>DataHSetDataRefExtension</code> and <code>DataHGetDataRefExtension</code> rather than constructing the extensions by hand.</p></div><p>The first example shows how to build a handle data reference with extensions. You pass to the function first a handle to your data, followed by (optionally) the file name, file type, MIME type and any initialization data you may have. If you specify initialization data, the data is added in-place to the handle data reference (which means the data reference can grow to be quite large). The advantage to adding initialization data in this manner is that once you've created the data reference you no longer have to manage the actual data handle yourself as you would if you added the data via the handle data reference handle.</p><p>You may pass nulls for any of the file name, file type, MIME type and initialization data parameters, in which case these parameters are not added as data reference extensions to the data reference handle. The function returns a handle data reference handle for your data:</p><p class="smalltext"><strong>Listing 7:</strong> Creating a handle data reference with extensions.</p><pre class="sourcecodebox">
//
// createHandleDataRefWithExtensions
//
// Creates a handle data reference for a
// handle containing a block of movie data. It also
// adds data reference extensions for file name, file
// type, mime type and initialization data.
//
// Parameters
//
//   dataHandle        A handle to your movie data. You
//                     may pass NULL here, in which case
//                     you would have to  pass a valid
//                     value for the initDataPtr parameter
//                     which adds the data ('data')
//                     extension to specify the actual data.
//
//   fileName          If you know the original file name
//                     you should pass it here to help
//                     QuickTime determine which importer
//                     to use. Pass NULL if you do not wish
//                     to specify the fileName
//
//   fileType          If you know the file type of the
//                     original file name, you should
//                     pass it here. Pass 0 here if you
//                     do not wish to specify the fileType
//
//   mimeTypeString    If you know the mime type of the
//                     data, you should pass it here. Pass
//                     NULL if you do not wish to specify
//                     the mime type.
//
//   initDataPtr       Pass any initialization data here, or
//                     0 if there is none.
//
//   initDataByteCount Specify the size of any initialization
//                     data, or 0 if there is none.
//

Handle createHandleDataRefWithExtensions(
                         Handle             dataHandle,
                         Str255             fileName,
                         OSType             fileType,
                         StringPtr          mimeTypeString,
                         Ptr                initDataPtr,
                         Size               initDataByteCount
                         )
{
    OSErr  err = noErr;
    Handle dataRef = NULL;

    // First create a data reference handle for our data
    dataRef = MyCreateDataReferenceHandle(dataHandle);
    if (!dataRef) goto bail;

    // We can add the filename to the data ref to help
    // importer finding process. Find uses the extension.
    // We must add the file name if we are also adding a
    // file type, MIME type or initialization data

    // If file name is NULL we still need to specify a
    // null Pascal string (a single 0 byte) in the data
    // reference prior to adding the other extensions
    err = AddFilenamingExtension (dataRef, fileName);
    if (err) goto bail;

    // The handle data handler can also be told the
    // filetype and/or MIME type by adding data ref
    // extensions. These help the importer finding process.
    // NOTE: If you add either of these, you MUST add
    // a filename first -- even if it is an empty Pascal
    // string. Any data ref extensions will be ignored.

    // to add file type, you add a classic atom followed
    // by the Mac OS filetype for the kind of file

    if (fileType)
    {
        err = AddMacOSFileTypeDataRefExtension (dataRef, fileType);
        if (err) goto bail;
    }


    // to add MIME type information, add a classic atom followed by
    // a Pascal string holding the MIME type

    if (mimeTypeString)
    {
        err = AddMIMETypeDataRefExtension (dataRef, mimeTypeString);
        if (err) goto bail;
    }

    // add any initialization data, but only if a dataHandle was
    // not already specified (any initialization data is ignored
    // in this case)
    if((dataHandle == NULL) &amp;&amp; (initDataPtr))
    {
        err = AddInitDataDataRefExtension (dataRef, initDataPtr);
        if (err) goto bail;
    }

    return dataRef;

bail:
    if (dataRef)
    {
        // make sure and dispose the data reference handle
        DisposeHandle(dataRef);
    }

    return NULL;
}

//////////
//
// MyCreateDataReferenceHandle
// Create a handle data reference handle.
//
// The handle data reference handle contains
// a handle to a block of data.
//
//////////

Handle MyCreateDataReferenceHandle(Handle theDataH)
{
    Handle  dataRef = NULL;
    OSErr   err     = noErr;

    // Create a data reference handle for our data.
    err = PtrToHand( &amp;theDataH, &amp;dataRef, sizeof(Handle));

    return dataRef;
}

//////////
//
// AddMIMETypeDataRefExtension
// Add a MIME type as a data reference extension.
//
// A MIME type data extension is an atom whose data
// is a Pascal string.
//
//////////

OSErr AddMIMETypeDataRefExtension (
                                  Handle theDataRef,
                                  StringPtr theMIMEType
                                  )
{
    unsigned long   myAtomHeader[2];
    OSErr           myErr = noErr;

    if (theMIMEType == NULL)
        return(paramErr);

    myAtomHeader[0] = EndianU32_NtoB(sizeof(myAtomHeader) +
                                    theMIMEType[0] + 1);
    myAtomHeader[1] =
        EndianU32_NtoB(kDataRefExtensionMIMEType);

    myErr = PtrAndHand(myAtomHeader, theDataRef,
                            sizeof(myAtomHeader));
    if (myErr == noErr)
        myErr = PtrAndHand(theMIMEType, theDataRef,
                              theMIMEType[0] + 1);

    return(myErr);
}

//////////
//
// AddInitDataDataRefExtension
// Add some initialization data as a data reference extension.
//
// An initialization data data extension is an atom whose data
// is any block of data.
//
//////////

OSErr AddInitDataDataRefExtension (
                                    Handle theDataRef,
                                    Ptr theInitDataPtr
                                   )
{
    unsigned long   myAtomHeader[2];
    OSErr           myErr = noErr;

    if (theInitDataPtr == NULL)
        return(paramErr);

    myAtomHeader[0] = EndianU32_NtoB(sizeof(myAtomHeader) +
         GetPtrSize(theInitDataPtr));
    myAtomHeader[1] =
       EndianU32_NtoB(kDataRefExtensionInitializationData);

    myErr = PtrAndHand(myAtomHeader, theDataRef,
                            sizeof(myAtomHeader));
    if (myErr == noErr)
        myErr = PtrAndHand(theInitDataPtr,
                   theDataRef, GetPtrSize(theInitDataPtr));

    return(myErr);
}

//////////
//
// AddMacOSFileTypeDataRefExtension
// Add a Macintosh file type as a data reference extension.
//
// A Macintosh file type data extension is an atom whose
// data is a 4-byte OSType.
//
//////////

OSErr AddMacOSFileTypeDataRefExtension (
                                       Handle theDataRef,
                                       OSType theType
                                       )
{
    unsigned long   myAtomHeader[2];
    OSType          myType;
    OSErr           myErr = noErr;

    myAtomHeader[0] = EndianU32_NtoB(sizeof(myAtomHeader) +
                                    sizeof(theType));
    myAtomHeader[1] = EndianU32_NtoB(kDataRefExtensionMacOSFileType);

    myType = EndianU32_NtoB(theType);

    myErr = PtrAndHand(myAtomHeader, theDataRef,
                          sizeof(myAtomHeader));
    if (myErr == noErr)
        myErr = PtrAndHand(&amp;myType, theDataRef,
                            sizeof(myType));

    return(myErr);
}

//////////
//
// AddFilenamingExtension
// Add a filenaming extension to a data reference.
// If theStringPtr is NULL, add a 0-length filename.
//
// A filenaming extension is a Pascal string.
//
//////////

OSErr AddFilenamingExtension (
                            Handle theDataRef,
                            Str255 theFileName
                            )
{
    unsigned char   myChar = 0;
    OSErr           myErr = noErr;
    if (theFileName == NULL)
        myErr = PtrAndHand(&amp;myChar, theDataRef, sizeof(myChar));
    else
        myErr = PtrAndHand(theFileName, theDataRef,
                             theFileName[0] + 1);

    return(myErr);
}

</pre><p>The next example shows how to build a pointer data reference with extensions. You pass to the function first a pointer to your data along with the size of the data, followed by (optionally) the file name, file type and MIME type.</p><p>You may pass nulls for any of the file name, file type, and MIME type parameters, in which case these parameters are not added as data reference extensions to the pointer data reference handle. The function returns a pointer data reference handle for your data:</p><p class="smalltext"><strong>Listing 8:</strong> Creating a pointer data reference with extensions.</p><pre class="sourcecodebox">

//
// createPointerDataRefWithExtensions
//
// Given a pointer to some movie data, it creates a
// pointer data reference with extensions.
//
// Parameters
//
//   data             A pointer to your movie data
//   dataSize         The actual size of the movie data
//                    specified by the data pointer
//   fileName         If you know the original file name
//                    you should pass it here to help
//                    QuickTime determine which importer
//                    to use. Pass NULL if you do not wish
//                    to specify the fileName
//   fileType         If you know the file type of the
//                    original file name, you should
//                    pass it here. Pass 0 here if you
//                    do not wish to specify the fileType
//   mimeTypeString   If you know the mime type of the
//                    data, you should pass it here. Pass
//                    NULL if you do not wish to specify
//                    the mime type.
//

Handle createPointerDataRefWithExtensions(
                         void               *data,
                         Size               dataSize,
                         Str255             fileName,
                         OSType             fileType,
                         StringPtr          mimeTypeString
                         )
{
    OSStatus  err = noErr;
    Handle dataRef = NULL;
    ComponentInstance dataRefHandler = NULL;

    // First create a data reference handle for our data
    dataRef = MyCreatePointerReferenceHandle(data, dataSize);
    if (!dataRef) goto bail;

    //  Get a data handler for our data reference
    err = OpenADataHandler(
            dataRef,                    /* data reference */
            PointerDataHandlerSubType,  /* data ref. type */
            NULL,                       /* anchor data ref. */
            (OSType)0,                  /* anchor data ref. type */
            NULL,                       /* time base for data handler */
            kDataHCanRead,              /* flag for data handler usage */
            &amp;dataRefHandler);           /* returns the data handler */
    if (err) goto bail;

    // We can add the filename to the data ref to help
    // importer finding process. Find uses the extension.
    // If we add a filetype or mimetype we must add a
    // filename -- even if it is an empty string
    if (fileName || fileType || mimeTypeString)
    {
        err = PtrDataRef_AddFileNameExtension(
            dataRefHandler, /* data ref. handler */
            fileName);      /* file name for extension */

        if (err) goto bail;
    }

    // The pointer data handler can also be told the
    // filetype and/or MIME type by adding data ref
    // extensions. These help the importer finding process.
    // NOTE: If you add either of these, you MUST add
    // a filename first -- even if it is an empty Pascal
    // string. Any data ref extensions will be ignored.

    // to add file type, you add a classic atom followed
    // by the Mac OS filetype for the kind of file

    if (fileType)
    {
        err = PtrDataRef_AddFileTypeExtension(
            dataRefHandler, /* data ref. handler */
            fileType);      /* file type for extension */
        if (err) goto bail;
    }


    // to add MIME type information, add a classic atom followed by
    // a Pascal string holding the MIME type

    if (mimeTypeString)
    {
        err = PtrDataRef_AddMIMETypeExtension (
                dataRefHandler,     /* data ref. handler */
                mimeTypeString);    /* mime string for extension */
        if (err) goto bail;
    }

    /* dispose old data ref handle because
        it does not contain our new changes */
    DisposeHandle(dataRef);
    dataRef = NULL;

    /* re-acquire data reference from the
        data handler to get the new
        changes */
    err = DataHGetDataRef(dataRefHandler, &amp;dataRef);
    if (err) goto bail;

    CloseComponent(dataRefHandler);

    return dataRef;

bail:
    if (dataRefHandler)
    {
        CloseComponent(dataRefHandler);
    }

    if (dataRef)
    {
        // make sure and dispose the data reference handle
        // once we are done with it
        DisposeHandle(dataRef);
    }

    return NULL;
}

//////////
//
// PtrDataRef_AddFileNameExtension
//
// Tell the data handler to set
// the file name extension in the
// data reference.
//
//////////

OSStatus PtrDataRef_AddFileNameExtension(
        ComponentInstance dataRefHandler,   /* data ref. handler */
        Str255 fileName)                    /* file name for extension */
{
    OSStatus anErr = noErr;
    unsigned char myChar = 0;
    Handle fileNameHndl = NULL;

    /* create a handle with our file name string */

    /* if we were passed a null string, then we
       need to add this null string (a single 0
       byte) to the handle */

    if (fileName == NULL)
        anErr = PtrToHand(&amp;myChar, &amp;fileNameHndl, sizeof(myChar));
    else
        anErr = PtrToHand(fileName, &amp;fileNameHndl, fileName[0] + 1);
    if (anErr != noErr) goto bail;

    /* set the data ref extension for the
        data ref handler */
    anErr = DataHSetDataRefExtension(
            dataRefHandler,         /* data ref. handler */
            fileNameHndl,           /* data ref. extension to add */
            kDataRefExtensionFileName);

bail:
    if (fileNameHndl)
        /* no longer need this */
        DisposeHandle(fileNameHndl);

    return anErr;

}

//////////
//
// PtrDataRef_AddFileTypeExtension
//
// Tell the data handler to set
// the file type extension in the
// data reference.
//
//////////

OSStatus PtrDataRef_AddFileTypeExtension(
        ComponentInstance dataRefHandler,   /* data ref. handler */
        OSType fileType)                    /* file type for extension */
{
    Handle      fileTypeHndl = NULL;
    OSStatus    anErr        = noErr;
    OSType      myType;

    myType = EndianU32_NtoB(fileType);

    anErr = PtrToHand(&amp;myType, &amp;fileTypeHndl, sizeof(OSType));
    if (anErr != noErr) goto bail;

    /* set the data ref extension for the
        data ref handler */
    anErr = DataHSetDataRefExtension(
            dataRefHandler,             /* data ref. handler */
            fileTypeHndl,               /* data ref. extension to add */
            kDataRefExtensionMacOSFileType);

bail:

    if (fileTypeHndl)
        /* no longer need this */
        DisposeHandle(fileTypeHndl);

    return anErr;
}

//////////
//
// PtrDataRef_AddMIMETypeExtension
//
// Tell the data handler to set
// the mime type extension in the
// data reference.
//
//////////

OSStatus PtrDataRef_AddMIMETypeExtension(
        ComponentInstance dataRefHandler,   /* data ref. handler */
        StringPtr mimeType)                 /* mime type for extension */
{
    OSStatus anErr = noErr;
    Handle mimeTypeHndl = NULL;

    if (mimeType == NULL)
        return paramErr;

    anErr = PtrToHand(mimeType, &amp;mimeTypeHndl, mimeType[0] + 1);
    if (anErr != noErr) goto bail;

    /* set the data ref extension for the
        data ref handler */
    anErr = DataHSetDataRefExtension(
            dataRefHandler,             /* data ref. handler */
            mimeTypeHndl,               /* data ref. extension to add */
            kDataRefExtensionMIMEType);

bail:

    if (mimeTypeHndl)
        /* no longer need this */
        DisposeHandle(mimeTypeHndl);

    return anErr;
}


//////////
//
// MyCreatePointerReferenceHandle
// Create a pointer data reference handle.
//
// The pointer data reference handle contains
// a record specifying a pointer to a block of
// movie data along with a size value.
//
//////////

Handle MyCreatePointerReferenceHandle(void *data, Size dataSize)
{
 Handle dataRef = NULL;
 PointerDataRefRecord ptrDataRefRec;
 OSErr err;


 ptrDataRefRec.data = data;
 ptrDataRefRec.dataLength = dataSize;

 // create a data reference handle for our data
 err = PtrToHand( &amp;ptrDataRefRec, &amp;dataRef, sizeof(PointerDataRefRecord));

 return dataRef;
}
</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG22"></A><H2>Additional Notes & Comments</H2><p>If you add a Mac OS file type or MIME type or initialization data extension as shown above, you MUST add a file name *first* in the sequence - even if it is an empty Pascal string (a single 0 length byte).</p><div class="notebox"><p><strong>Note:</strong> Only the handle data reference supports the initialization data ('data') extension.</p></div><p>Remember, any initialization data you specify via the 'data' extension for a handle data reference is of course added to the data reference, meaning the data reference can grow to be quite large. You'll probably only want to use image data (GIF, etc.), text data or music data as initialization data (rather than audio/video data) , as it tends to take up less space.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG23"></A><H2>Summary</H2><p>Data reference extensions in QuickTime give you the ability to associate Mac OS file type, MIME type, initialization data and/or file name information with a given data reference. This assures QuickTime will interpret your data correctly and as quickly as possible.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG24"></A><H2>References</H2><ul><li><p><A HREF="../../quicktime/icefloe/dispatch005.html">Letters From the Ice Floe Dispatch #5 - Finding the file type and extension from the MIME type</A></p></li><li><p><A HREF="../../documentation/QuickTime/RM/ImportExport/GraphicImport/index.html">QuickTime API Documentation, Graphics Importer</A></p></li><li><p><A HREF="../../documentation/QuickTime/QTFF/index.html">QuickTime File Format Documentation, QuickTime Atoms</A></p></li><li><p><A HREF="../../documentation/QuickTime/whatsnew.htm">What's New in QuickTime 6.4</A></p></li></ul><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNT_HISTORY_TAG"></A><H2>Document Revision History</H2><table cellspacing="0" class="graybox" width="680"><tr><th width="100">Date</th><th width="580">Notes</th></tr><tr><td scope="row">2006-08-30</td><td>createPointerDataRefWithExtensions now correctly calls CloseComponent to close the DataHandler being used.</td></tr><tr><td scope="row">2006-03-21</td><td>Explain why movie import might fail with the -2048 noMovieFound error.</td></tr><tr><td scope="row">2004-05-26</td><td>Add information for the pointer data reference, new QuickTim 6.4 convenience functions for creating data references, and updated code snippets.</td></tr><tr><td scope="row">2000-04-01</td><td>The use of data reference extensions used by QuickTime to tag handle and pointer data references.</td></tr></table><p><b>Posted:</b> 2006-08-30</p>
<!-- END CONTENTS -->
</td></tr></table>
<!-- END WIDE COLUMN -->
<!-- END MAIN CONTENT -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1195.html%3Fid%3DDTS10003034-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1195.html%3Fid%3DDTS10003034-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1195.html%3Fid%3DDTS10003034-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

<!-- START BOTTOM APPLE NAVIGATION -->
<!--#include virtual="/includes/footer"-->
<!-- END BOTTOM APPLE NAVIGATION -->
<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->
</body></html>