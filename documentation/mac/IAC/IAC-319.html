<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Factoring the Quit Command and the New Command(IM:IC)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING319></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="IAC-318.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-320.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="IAC-2.html"><B>Interapplication Communication</B></A> / <BR><DD><A HREF="IAC-316.html"><B>Chapter 9 - Recording Apple Events</B></A> / <A HREF="IAC-318.html"><B>Factoring Your Application for Recording</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING319-0></A>
<H2>Factoring the Quit Command and the New Command</H2>
 This section demonstrates how to factor two File menu commands: Quit and New. <A NAME=MARKER-21-32></A><P>
 <A NAME=MARKER-2-112></A>When the user chooses a menu command, an application first determines which one was chosen and then performs the action associated with that command. For example, when a user chooses Quit from the File menu, an application that is not factored simply calls an application-defined <CODE>DoQuit</CODE> routine. Because Quit Application is one of the required Apple events, it is relatively easy for most applications that support Apple events to factor the code that responds to the Quit command.<P>
 After a factored application has determined that the user has chosen the Quit command, it sends the Quit Application event to itself by calling its <CODE>MyDoMenuQuit</CODE> routine.<P>
<PRE>
PROCEDURE MyDoMenuQuit;
VAR
   myErr: OSErr;
BEGIN
   myErr := MySendAEQuit(kAEAskUser);
   {handle any errors}
END;
</PRE>
 The <CODE>MyDoMenuQuit</CODE> routine in turn calls the <CODE>MySendAEQuit</CODE> routine shown in <BR><A HREF=#MARKER-9-14>Listing 9-1</A>, which creates the Quit Application event and sends it. <P>
<B>Listing 9-1  <A NAME=MARKER-9-14></A>A function used by a factored application to send itself a Quit Application event<A NAME=MARKER-2-8></A></B><P>
<PRE>
FUNCTION MySendAEQuit (saveOpt: DescType): OSErr;
VAR 
   myAppleEvent, defReply: AppleEvent;
   myErr, ignoreErr:       OSErr;
BEGIN
   {create Quit event}
   myErr := AECreateAppleEvent(kCoreEventClass, 
                                 kAEQuitApplication, 
                                 gSelfAddrDesc, 
                                 kAutoGenerateReturnID, 
                                 kAnyTransactionID, myAppleEvent);
   IF myErr = noErr THEN
      {add optional parameter that specifies whether this app }
      { should prompt user if window is dirty}
      myErr := AEPutParamPtr(myAppleEvent, keyAESaveOptions, 
                              typeEnumerated, @saveOpt,
                              SizeOf(saveOpt));
   IF myErr = noErr THEN 
      {send event}
      myErr := AESend(myAppleEvent, defReply, 
                        kAENoReply+kAEAlwaysInteract,
                        kAENormalPriority, kAEDefaultTimeOut,
                        NIL, NIL);
   MySendAEQuit := myErr;
   ignoreErr := AEDisposeDesc(myAppleEvent);
END;
</PRE>
 The input to the <CODE>MySendAEQuit</CODE> routine is a constant that indicates whether to save dirty windows without asking the user (<CODE>kAEYes</CODE>), quit without saving dirty windows (<CODE>kAENo</CODE>), or ask the user whether each dirty window should be saved (<CODE>kAEAskUser</CODE>). In this example, the constant <CODE>kAEAskUser</CODE> passed to the <CODE>MySendAEQuit</CODE> routine indicates that the user will be asked whether each dirty window should be saved. <P>
 After the application receives the Quit Application event, the <CODE>MyHandleQuit</CODE> handler shown in <A HREF=#MARKER-9-16>Listing 9-2</A> performs all the actions associated with that event, such as saving any open documents. (Note that your application should call the <CODE>ExitToShell</CODE> procedure from the main event loop, not from your handler for the Quit Application event.)<P>
<B>Listing 9-2  <A NAME=MARKER-9-16></A>A routine used by a factored application to handle a Quit Application event<A NAME=MARKER-2-9></A></B><P>
<PRE>
FUNCTION MyHandleQuit (theAppleEvent, reply: AppleEvent;
                        handlerRefcon: LongInt): OSErr;
VAR
   userCanceled:           Boolean;
   saveOpt, returnedType:  DescType;
   actSize:                Size;
   myErr:                  OSErr;
BEGIN
   {check for missing required parameters}
   myErr := MyGotRequiredParams(theAppleEvent);
   IF myErr = noErr THEN
   BEGIN
      {pick up optional save parameter}
      saveOpt := kAEAskUser;  {the default}
      myErr := AEGetParamPtr(theAppleEvent, keyAESaveOptions, 
                              typeEnumerated, returnedType,
                              @saveOpt, SizeOf(saveOpt), actSize);
      IF myErr = errAEDescNotFound THEN 
         myErr := noErr;
      MyHandleQuit := myErr;
      IF myErr = noErr THEN
      BEGIN
         userCanceled := MyPrepareToTerminate(saveOpt);
         IF userCanceled THEN 
            MyHandleQuit := kUserCanceled;
      END;
   END
   ELSE
      MyHandleQuit := myErr;
END;
</PRE>
 The handler in <A HREF=#MARKER-9-16>Listing 9-2</A> calls another function supplied by the application, the <CODE>MyPrepareToTerminate</CODE> function. When the value of the optional parameter that specifies how to deal with dirty windows equals <CODE>kAEAskUser</CODE>, this function asks the user whether to save each dirty window and returns a Boolean value that indicates whether the user canceled the Quit request. It also responds appropriately to the other possible values of the optional parameter.<P>
 If recording has been turned on for a scripting component (for example, after a user clicks the Record button in the Script Editor application) and the user quits the application, the Apple Event Manager automatically sends the scripting component a copy of the Quit Application event sent by the <CODE>MySendAEQuit</CODE> routine. The scripting component records the event in a compiled script. When a user executes the recorded script, the scripting component sends the same Quit Application event to the application, which calls the <CODE>MyHandleQuit</CODE> function and responds to the event just as if the user had chosen Quit from the File menu. <A NAME=MARKER-2-48></A> <A NAME=MARKER-2-128></A><P>
 <A NAME=MARKER-21-130></A>After you have factored the commands associated with required Apple events for an existing application, you can move on to the other commands in the File menu, such as New. After a factored application has determined that the user has chosen New, it calls its <CODE>MyDoMenuNew</CODE> routine, which sends the Create Element event to the application.<A NAME=MARKER-2-49></A><P>
<PRE>
PROCEDURE MyDoMenuNew;
VAR
   myErr := OSErr;
BEGIN
   myErr := MySendAECreateElement(gNullDesc, cDocument);
   {handle any errors}
END;
</PRE>
 The container for the new element is the application's default container, specified by a null descriptor record, and the desired class is <CODE>cDocument</CODE>. The <CODE>MyDoMenuNew</CODE> routine in turn calls the <CODE>MySendAECreateElement</CODE> routine shown in <A HREF=#MARKER-9-22>Listing 9-3</A>, which creates the Apple event and sends it. <P>
<B>Listing 9-3  <A NAME=MARKER-9-22></A>A routine used by a factored application to send itself a Create Element event<A NAME=MARKER-2-11></A></B><P>
<PRE>
FUNCTION MySendAECreateElement (cont: AEDesc; 
                                elemClass: DescType): OSErr; 
VAR 
   myAppleEvent, defReply: AppleEvent;
   myErr, ignoreErr:       OSErr;
BEGIN
   {create Create Element event}
   myErr := AECreateAppleEvent(kCoreEventClass, kAECreateElement,
                                 gSelfAddrDesc,
                                 kAutoGenerateReturnID,
                                 kAnyTransactionID, myAppleEvent);
   IF myErr = noErr THEN
      {add parameter that specifies insertion location for the }
      { new element}
      myErr :=  AEPutParamDesc(myAppleEvent,keyAEInsertHere,cont);
   IF myErr = noErr THEN 
      {add parameter that specifies new element's object class}
      myErr := AEPutParamPtr(myAppleEvent, keyAEObjectClass,
                             typeType, @elemClass,
                             SizeOf(elemClass));
   IF myErr = noErr THEN
      {send the event}
      myErr := AESend(myAppleEvent, defReply, 
                        kAENoReply+kAECanInteract, 
                        kAENormalPriority, kAEDefaultTimeOut, NIL, 
                        NIL);
   MySendAECreateElement := myErr;
   ignoreErr := AEDisposeDesc(myAppleEvent); {must dispose of }
                                             { event}
END;
</PRE>
 For the purposes of this example, the routine shown in <A HREF=#MARKER-9-22>Listing 9-3</A> sends only the required parameters and can only create a new active window with the default name. After the application receives the Create Element event, its <CODE>MyHandleCreateElement</CODE> handler performs the requested action, as shown in <A HREF=#MARKER-9-24>Listing 9-4</A>. In this case, it creates a new active window with a default title.<P>
<B>Listing 9-4  <A NAME=MARKER-9-24></A>The Create Element event handler for a factored application<A NAME=MARKER-2-81></A><A NAME=MARKER-2-12></A></B><P>
<PRE>
FUNCTION MyHandleCreateElement (theAppleEvent: AppleEvent; 
                                reply: AppleEvent; 
                                handlerRefCon: LongInt): OSErr;
VAR
   myCont:                     AEDesc;
   returnedType, newElemClass: DescType;
   actSize:                    Size;
   contClass:                  DescType;
   window:                     WindowPtr;
   myErr:                      OSErr;
BEGIN
   {get the parameters out of the event}
   {first get the direct parameter, which specifies insertion }
   { location for new window--that is, frontmost window}
   myCont.dataHandle := NIL;
   myErr := AEGetParamDesc(theAppleEvent, keyAEInsertHere, 
                           typeWildCard, myCont);
   IF myErr = noErr THEN
      {get the other required parameter, which specifies class }
      { cDocument when MyHandleCreateElement creates a new window}
      myErr := AEGetParamPtr(theAppleEvent, keyAEObjectClass, 
                              typeType, returnedType,
                              @newElemClass, 
                              SizeOf(newElemClass), actSize);
   IF myErr = noErr THEN
      myErr := MyGotRequiredParams(theAppleEvent);
   MyHandleCreateElement := myErr;
   IF myErr = noErr THEN
   BEGIN
      {check container and class, just to make sure}
      IF (myCont.descriptorType &lt;&gt; typeNull) OR (newElemClass &lt;&gt; 
            cDocument) THEN 
         MyHandleCreateElement := kWrongContainerOrElement
      ELSE
         {MyNewWindow creates a new window with a default name }
         { and returns a pointer to it in the window parameter}
         MyHandleCreateElement := MyNewWindow(window);
   END;
   myErr := AEDisposeDesc(myCont);
   {if your app sends a reply in response to the Create Element }
   { event, then set up the reply event as appropriate}
END; 
</PRE>
 If recording has been turned on for a scripting component (for example, after a user clicks the Record button in the Script Editor application), the Apple Event Manager automatically sends the scripting component a copy of the Create Element event sent by the <CODE>MySendAECreateElement</CODE> routine. The scripting component records the Apple event as a statement in a compiled script. When a user executes the recorded script, the scripting component sends the same Create Element event to the application, which calls its <CODE>MyHandleCreateElement</CODE> handler and responds to the event just as if the user had chosen New from the File menu. <A NAME=MARKER-2-133></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="IAC-318.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-320.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="IAC-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
