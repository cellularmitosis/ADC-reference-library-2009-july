<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SGDataProcSample - /SonOfMungGrab.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxCompressionDecompression-date.html">Compression & Decompression</a> &gt; <A HREF="javascript:location.replace('index.html');">SGDataProcSample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SGDataProcSample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SonOfMungGrab.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Minimung.c</option>
<option value="listing2.html">/Minimung.r</option>
<option value="listing3.html">/Munggrab.c</option>
<option value="listing4.html">/Munggrab.r</option>
<option value="listing5.html">/SonOfMungGrab.c</option>
<option value="listing6.html">/SonOfMunggrab.r</option>
<option value="listing7.html">/SonOfMunggrabPrefix.r</option></select>
				</p>
				</form>
				<p><strong><a href="SGDataProcSample.zip">Download Sample</a></strong> (&#147;SGDataProcSample.zip&#148;, 89.3K)<BR>
<strong><a href="SGDataProcSample.dmg">Download Sample</a></strong> (&#147;SGDataProcSample.dmg&#148;, 159.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SonOfMunggrab.c    Description: This example shows how to run the Sequence Grabber in record mode and use         a DataProc to get and modify the captured data. SonOfMunggrab calculates the         frame rate using the time value stamp passed to the data proc then draws this         rate onto the frame. This technique provides optimal performance, far better         than using preview mode or bottlenecks. This code will help a lot when         capturing from DV and should allow 30fps playthrough using DV capture on a G3.                  SonOfMunggrab is the offspring of Munggrab written by the illustrious         Kevin Marks. While the techniques presented in the original Munggrab remain         the same, this sample throws Carbon Events into the fray for better performance         on Mac OS X.  Author:    km, era  Copyright:   &copy; Copyright 2000 - 2001 Apple Computer, Inc. All rights reserved.    Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your        use, installation, modification or redistribution of this Apple software        constitutes acceptance of these terms.  If you do not agree with these terms,        please do not use, install, modify or redistribute this Apple software.        In consideration of your agreement to abide by the following terms, and subject        to these terms, Apple grants you a personal, non-exclusive license, under Apple's        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,        reproduce, modify and redistribute the Apple Software, with or without        modifications, in source and/or binary forms; provided that if you redistribute        the Apple Software in its entirety and without modifications, you must retain        this notice and the following text and disclaimers in all such redistributions of        the Apple Software.  Neither the name, trademarks, service marks or logos of        Apple Computer, Inc. may be used to endorse or promote products derived from the        Apple Software without specific prior written permission from Apple.  Except as        expressly stated in this notice, no other rights or licenses, express or implied,        are granted by Apple herein, including but not limited to any patent rights that        may be infringed by your derivative works or by other works in which the Apple        Software may be incorporated.        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN        COMBINATION WITH YOUR PRODUCTS.        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.          Change History (most recent first): &lt;3&gt; 3/28/02 DV source rect bug fix in DataProc                    &lt;2&gt; 7/08/01 carbonized and born as SonOfMunggrab                    &lt;1&gt; 1/13/00 initial release*/// NOTE: This is a CARBON sample and uses the Carbon Event Model.//     For best results use CarbonLib 1.3.1, Universal Interfaces 3.4//     QuickTime 5, a DV camera of some sort and a large polo-mallet.// build for carbon#define TARGET_API_MAC_CARBON 1#if __APPLE_CC__  #include &lt;Carbon/Carbon.h&gt;  #include &lt;QuickTime/QuickTime.h&gt;#else  #include &lt;ConditionalMacros.h&gt;  #include &lt;Carbon.h&gt;  #include &lt;QuickTimeComponents.h&gt;  #include &lt;stdio.h&gt;#endif// defines#define BailErr(x) {err = x; if(err != noErr) goto bail;}#define DisplayAndBail(x, y) {pMungData-&gt;err = x; if(x != noErr) { DisplayError(pMungData-&gt;pWindow, y, x); goto bail;}}// constantsconst EventTime kTimerInterval = kEventDurationSecond / 60;  // idle timer interval// mung data structtypedef struct {    WindowRef          pWindow;  // window    Rect         bounds;    // bounds rect    GWorldPtr        pGWorld;  // offscreen    SeqGrabComponent   seqGrab;  // sequence grabber    ImageSequence      decomSeq;  // unique identifier for our decompression sequence    ImageSequence      drawSeq;  // unique identifier for our draw sequence    long          drawSize;    TimeValue        lastTime;    TimeScale        timeScale;    long          frameCount;    Boolean         isGrabbing;    EventLoopTimerRef  timerRef;    OSErr         err;} MungDataRecord, *MungDataPtr;// globalsstatic BitMap gScreenbits;// --------------------// Initialize for Carbon &amp; QuickTime//void InitializeApp(void);void InitializeApp(void){  long response = 0;    InitCursor();    // draw a menu bar on X so Quit will be seen  OSErr err = Gestalt(gestaltMenuMgrAttr, &amp;response);  if ((err == noErr) &amp;&amp; (response &amp; gestaltMenuMgrAquaLayoutMask))  {    Handle menuBar = GetNewMBar(128);    SetMenuBar(menuBar);    DrawMenuBar();  }    EnterMovies();    GetQDGlobalsScreenBits(&amp;gScreenbits);}// --------------------// InitializeMungData//MungDataPtr  InitializeMungData(WindowRef inWindow, Rect inBounds, SeqGrabComponent inSeqGrab);MungDataPtr InitializeMungData(WindowRef inWindow, Rect inBounds, SeqGrabComponent inSeqGrab){  MungDataPtr pMungData = NULL;    CGrafPtr theOldPort;    GDHandle theOldDevice;        OSErr err = noErr;        // allocate memory for the data    pMungData = (MungDataPtr)NewPtrClear(sizeof(MungDataRecord));    if (MemError() || NULL == pMungData ) return NULL;        // create a GWorld    err = QTNewGWorld(&amp;(pMungData-&gt;pGWorld),  // returned GWorld              k32ARGBPixelFormat,    // pixel format              &amp;inBounds,        // bounds              0,            // color table              NULL,          // GDHandle              0);            // flags  BailErr(err);        // lock the pixmap and make sure it's locked because    // we can't decompress into an unlocked PixMap    if(!LockPixels(GetGWorldPixMap(pMungData-&gt;pGWorld)))    goto bail;        GetGWorld(&amp;theOldPort, &amp;theOldDevice);        SetGWorld(pMungData-&gt;pGWorld, NULL);    BackColor(blackColor);    ForeColor(whiteColor);    EraseRect(&amp;inBounds);        SetGWorld(theOldPort, theOldDevice);  pMungData-&gt;pWindow = inWindow;  pMungData-&gt;bounds = inBounds;  pMungData-&gt;seqGrab = inSeqGrab;  pMungData-&gt;isGrabbing = false;     return pMungData;   bail:  // something's bust, clean up and get out  if (pMungData) {    if (pMungData-&gt;pGWorld) DisposeGWorld(pMungData-&gt;pGWorld);    DisposePtr((Ptr)pMungData);  }    return NULL;}// --------------------// MakeAWindow//OSErr MakeAWindow(WindowRef *outWindow);OSErr MakeAWindow(WindowRef *outWindow){    Rect  windowRect = {0, 0, 240, 320};    Rect    bestRect;    WindowAttributes wAttributes = kWindowCloseBoxAttribute |                     kWindowCollapseBoxAttribute |                     kWindowStandardHandlerAttribute |                     kWindowInWindowMenuAttribute;  OSErr err = noErr;      // figure out the best monitor for the window    GetBestDeviceRect(NULL, &amp;bestRect);    // put the window in the top left corner of that monitor    OffsetRect(&amp;windowRect, bestRect.left + 10, bestRect.top + 50);      BailErr(CreateNewWindow(kDocumentWindowClass, wAttributes, &amp;windowRect, outWindow));    SetWTitle(*outWindow, &quot;\pSonOfMunggrab&quot;);  ShowWindow(*outWindow);    // set the port to the new window    SetPortWindowPort(*outWindow);bail:    return err;}// --------------------// DisposeMungData//void DisposeMungData(MungDataPtr pMungData);void DisposeMungData(MungDataPtr pMungData){    // clean up the bits    if(pMungData) {        if (pMungData-&gt;decomSeq)          CDSequenceEnd(pMungData-&gt;decomSeq);        if (pMungData-&gt;drawSeq)          CDSequenceEnd(pMungData-&gt;drawSeq);        if (pMungData-&gt;seqGrab)        CloseComponent(pMungData-&gt;seqGrab);        if (pMungData-&gt;pGWorld) {          DisposeGWorld(pMungData-&gt;pGWorld);          pMungData-&gt;pGWorld = NULL;        }        DisposePtr((Ptr)pMungData);        pMungData = NULL;    }}static void DisplayError(WindowRef inWindow, char inStr[], OSErr inError){  // set the window title to display the error  char errMsg[64];    sprintf(errMsg, &quot;%s: %d&quot;, inStr, inError);  CopyCStringToPascal(errMsg, (unsigned char *)&amp;errMsg);  SetWTitle(inWindow, (unsigned char *)errMsg);}#pragma mark-// --------------------// MakeSequenceGrabber//SeqGrabComponent MakeSequenceGrabber(WindowRef pWindow);SeqGrabComponent MakeSequenceGrabber(WindowRef pWindow){  SeqGrabComponent seqGrab = NULL;  OSErr       err = noErr;    // open the default sequence grabber    seqGrab = OpenDefaultComponent(SeqGrabComponentType, 0);    if (seqGrab != NULL) {       // initialize the default sequence grabber component      err = SGInitialize(seqGrab);      if (err == noErr)          // set its graphics world to the specified window          err = SGSetGWorld(seqGrab, GetWindowPort(pWindow), NULL);            if (err == noErr)        // specify the destination data reference for a record operation        // tell it we're not making a movie        // if the flag seqGrabDontMakeMovie is used, the sequence grabber still calls        // your data function, but does not write any data to the movie file        // writeType will always be set to seqGrabWriteAppend        err = SGSetDataRef(seqGrab,                   0,                   0,                   seqGrabDontMakeMovie);    }    if (err &amp;&amp; (seqGrab != NULL)) { // clean up on failure      CloseComponent(seqGrab);        seqGrab = NULL;    }      return seqGrab;}// --------------------// MakeSequenceGrabChannel//OSErr MakeSequenceGrabChannel(SeqGrabComponent seqGrab, SGChannel *sgchanVideo, Rect const *rect);OSErr MakeSequenceGrabChannel(SeqGrabComponent seqGrab, SGChannel *sgchanVideo, Rect const *rect){    long  flags = 0;        OSErr err = noErr;        err = SGNewChannel(seqGrab, VideoMediaType, sgchanVideo);    if (err == noErr) {      err = SGSetChannelBounds(*sgchanVideo, rect);      if (err == noErr)        // set usage for new video channel to avoid playthrough         // note we don't set seqGrabPlayDuringRecord        err = SGSetChannelUsage(*sgchanVideo, flags | seqGrabRecord);            if (err != noErr) {          // clean up on failure          SGDisposeChannel(seqGrab, *sgchanVideo);          *sgchanVideo = NULL;      }    }  return err;}#pragma mark-// --------------------// MakeImageSequenceForGWorld//OSErr MakeImageSequenceForGWorld(GWorldPtr pGWorld, GWorldPtr pDest, long *imageSize, ImageSequence *seq);OSErr MakeImageSequenceForGWorld(GWorldPtr pGWorld, GWorldPtr pDest, long *imageSize, ImageSequence *seq){    ImageDescriptionHandle desc = NULL;    PixMapHandle hPixMap = GetGWorldPixMap(pGWorld);    Rect bounds;        OSErr err = noErr;        GetPixBounds(hPixMap, &amp;bounds);    *seq = NULL;        // returns an image description for the GWorlds PixMap  // on entry the imageDesc is NULL, on return it is correctly filled out  // you are responsible for disposing it    err = MakeImageDescriptionForPixMap(hPixMap, &amp;desc);    BailErr(err);        *imageSize = (GetPixRowBytes(hPixMap) * (*desc)-&gt;height); // ((**hPixMap).rowBytes &amp; 0x3fff) * (*desc)-&gt;height;  // begin the process of decompressing a sequence of frames  // the destination is the onscreen window    err = DecompressSequenceBegin(seq,          // pointer to field to receive unique ID for sequence                    desc,          // handle to image description structure                    pDest,        // port for the DESTINATION image                    NULL,          // graphics device handle, if port is set, set to NULL                                  &amp;bounds,        // source rectangle defining the portion of the image to decompress                                  NULL,          // transformation matrix                                  ditherCopy,      // transfer mode specifier                                  (RgnHandle)NULL,    // clipping region in dest. coordinate system to use as a mask                                    0,          // flags                                  codecNormalQuality,  // accuracy in decompression                                  anyCodec);      // compressor identifier or special identifiers ie. bestSpeedCodecbail:    if (desc)      DisposeHandle((Handle)desc);        return err;}/* ---------------------------------------------------------------------- *//* sequence grabber data procedure - this is where the work is done/* ---------------------------------------------------------------------- *//* MungGrabDataProc - the sequence grabber calls the data function whenever   any of the grabber's channels write digitized data to the destination movie file.      NOTE: We really mean any, if you have an audio and video channel then the DataProc will        be called for either channel whenever data has been captured. Be sure to check which        channel is being passed in. In this example we never create an audio channel so we know        we're always dealing with video.      This data function does two things, it first decompresses captured video   data into an offscreen GWorld, draws some status information onto the frame then   transfers the frame to an onscreen window.      For more information refer to Inside Macintosh: QuickTime Components, page 5-120   c - the channel component that is writing the digitized data.   p - a pointer to the digitized data.   len - the number of bytes of digitized data.   offset - a pointer to a field that may specify where you are to write the digitized data,         and that is to receive a value indicating where you wrote the data.   chRefCon - per channel reference constant specified using SGSetChannelRefCon.   time  - the starting time of the data, in the channel's time scale.   writeType - the type of write operation being performed.       seqGrabWriteAppend - Append new data.       seqGrabWriteReserve - Do not write data. Instead, reserve space for the amount of data                   specified in the len parameter.       seqGrabWriteFill - Write data into the location specified by offset. Used to fill the space                  previously reserved with seqGrabWriteReserve. The Sequence Grabber may                  call the DataProc several times to fill a single reserved location.   refCon - the reference constant you specified when you assigned your data function to the sequence grabber.*/pascal OSErr MungGrabDataProc(SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType, long refCon);pascal OSErr MungGrabDataProc(SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType, long refCon){#pragma unused(offset,chRefCon,writeType)    CGrafPtr  theSavedPort;    GDHandle    theSavedDevice;    CodecFlags  ignore;    float    fps = 0,             averagefps = 0;        ComponentResult err = noErr;        MungDataPtr pMungData = (MungDataPtr)refCon;    if (NULL == pMungData) return -1;    // reset frame and time counters after a stop/start  if (pMungData-&gt;lastTime &gt; time) {    pMungData-&gt;lastTime = 0;    pMungData-&gt;frameCount = 0;  }        pMungData-&gt;frameCount++;            if (pMungData-&gt;timeScale == 0) {      // first time here so set the time scale      err = SGGetChannelTimeScale(c, &amp;pMungData-&gt;timeScale);      DisplayAndBail(err, &quot;SGGetChannelTimeScale&quot;);    }      if (pMungData-&gt;pGWorld) {      if (pMungData-&gt;decomSeq == 0) {        // Set up getting grabbed data into the GWorld                Rect           sourceRect = { 0, 0 };      MatrixRecord       scaleMatrix;        ImageDescriptionHandle imageDesc = (ImageDescriptionHandle)NewHandle(0);                        // retrieve a channel's current sample description, the channel returns a sample description that is            // appropriate to the type of data being captured            err = SGGetChannelSampleDescription(c, (Handle)imageDesc);            DisplayAndBail(err, &quot;SGGetChannelSampleDescription&quot;);                        /***** IMPORTANT NOTE *****                   Previous versions of this sample code made an incorrect decompression       request.  Intending to draw the DV frame at quarter-size into a quarter-size       offscreen GWorld, it made the call           err = DecompressSequenceBegin(..., &amp;rect, nil, ...);       passing a quarter-size rectangle as the source rectangle.  The correct       interpretation of this request is to draw the top-left corner of the DV       frame cropped at normal size.  Unfortunately, a DV-specific bug in QuickTime       5 caused it to misinterpret this request and scale the frame to fit.       This bug will be fixed in QuickTime 6.  If your code behaves as intended       because of the bug, you should fix your code to pass a matrix scaling the       frame to fit the offscreen gworld:        RectMatrix( &amp; scaleMatrix, &amp;dvFrameRect, &amp;gworldBounds );         err = DecompressSequenceBegin(..., nil, &amp;scaleMatrix, ...);             This approach will work in all versions of QuickTime.                   **************************/                  // make a scaling matrix for the sequence      sourceRect.right = (**imageDesc).width;      sourceRect.bottom = (**imageDesc).height;      RectMatrix(&amp;scaleMatrix, &amp;sourceRect, &amp;pMungData-&gt;bounds);                  // begin the process of decompressing a sequence of frames            // this is a set-up call and is only called once for the sequence - the ICM will interrogate different codecs            // and construct a suitable decompression chain, as this is a time consuming process we don't want to do this            // once per frame (eg. by using DecompressImage)            // for more information see Ice Floe #8 http://developer.apple.com/quicktime/icefloe/dispatch008.html            // the destination is specified as the GWorld      err = DecompressSequenceBegin(&amp;pMungData-&gt;decomSeq,  // pointer to field to receive unique ID for sequence                      imageDesc,      // handle to image description structure                      pMungData-&gt;pGWorld,   // port for the DESTINATION image                      NULL,          // graphics device handle, if port is set, set to NULL                      NULL,          // source rectangle defining the portion of the image to decompress                                           &amp;scaleMatrix,      // transformation matrix                                          srcCopy,        // transfer mode specifier                                          (RgnHandle)NULL,    // clipping region in dest. coordinate system to use as a mask                                          NULL,          // flags                                          codecNormalQuality,   // accuracy in decompression                                          bestSpeedCodec);    // compressor identifier or special identifiers ie. bestSpeedCodec            DisplayAndBail(err, &quot;GWorldDecompressSequenceBegin&quot;);                        DisposeHandle((Handle)imageDesc);                                 // Set up getting grabbed data into the Window                        // create the image sequence for the offscreen            err = MakeImageSequenceForGWorld(pMungData-&gt;pGWorld,                             GetWindowPort(pMungData-&gt;pWindow),                             &amp;pMungData-&gt;drawSize,                             &amp;pMungData-&gt;drawSeq);        DisplayAndBail(err, &quot;MakeImageSequenceForGWorld&quot;);        }                // decompress a frame into the GWorld - can queue a frame for async decompression when passed in a completion proc        err = DecompressSequenceFrameS(pMungData-&gt;decomSeq,  // sequence ID returned by DecompressSequenceBegin                         p,          // pointer to compressed image data                         len,          // size of the buffer                         0,          // in flags                         &amp;ignore,        // out flags                         NULL);        // async completion proc                                 DisplayAndBail(err, &quot;GWorldDecompressSequenceFrameS&quot;);      // Write status information onto the frame        char   status[64];      Str255  theString;                GetGWorld(&amp;theSavedPort, &amp;theSavedDevice);         SetGWorld(pMungData-&gt;pGWorld, NULL);                TextSize(12);         TextMode(srcCopy);         MoveTo(pMungData-&gt;bounds.left +10, pMungData-&gt;bounds.bottom - 14);         fps = (float)pMungData-&gt;timeScale / (float)(time - pMungData-&gt;lastTime);         averagefps = ((float)pMungData-&gt;frameCount * (float)pMungData-&gt;timeScale) / (float)time;         sprintf(status, &quot;time stamp: %ld, fps:%5.1f average fps:%5.1f&quot;, time, fps, averagefps);         CopyCStringToPascal(status, theString);         DrawString(theString);        SetGWorld(theSavedPort, theSavedDevice);                // draw the frame to the destination, in this case the onscreen window          err = DecompressSequenceFrameS(pMungData-&gt;drawSeq,                  // sequence ID                             GetPixBaseAddr(GetGWorldPixMap(pMungData-&gt;pGWorld)),  // pointer image data                             pMungData-&gt;drawSize,                  // size of the buffer                             0,                          // in flags                             &amp;ignore,                        // out flags                             NULL);                         // can async help us?        DisplayAndBail(err, &quot;WindowDecompressSequenceFrameS&quot;);  }            bail:    pMungData-&gt;lastTime = time;    return err;}// --------------------// DoUpdate//void DoUpdate(MungDataPtr pMungData);void DoUpdate(MungDataPtr pMungData){  CodecFlags ignore;  // draw the last frame  pMungData-&gt;err = DecompressSequenceFrameS(pMungData-&gt;drawSeq,                            GetPixBaseAddr(GetGWorldPixMap(pMungData-&gt;pGWorld)),                            pMungData-&gt;drawSize,                            0,                            &amp;ignore,                            NULL);    if (pMungData-&gt;err)    DisplayError(pMungData-&gt;pWindow, &quot;DoUpdate&quot;, pMungData-&gt;err);}#pragma mark-// --------------------// MGIdleTimer//// Munggrab idle timer to idle the sequence grabber, call this at least// as much as the desired frame rate - more is betterstatic pascal void MGIdleTimer(EventLoopTimerRef inTimer, void *inUserData){#pragma unused(inTimer)    MungDataPtr pMungData = MungDataPtr(inUserData);  if (NULL == pMungData) return;    OSErr err = SGIdle(pMungData-&gt;seqGrab);  if (err &amp;&amp; err != pMungData-&gt;err) {      // some error specific to SGIdle occurred - any errors returned from the      // data proc will also show up here and we don't want to write over them            // in QT 4 you would always encounter a cDepthErr error after a user drags      // the window, this failure condition has been greatly relaxed in QT 5      // it may still occur but should only apply to vDigs that really control      // the screen            // you don't always know where these errors originate from, some may come      // from the VDig...            DisplayError(pMungData-&gt;pWindow, &quot;SGIdle&quot;, err);            // ...to fix this we simply call SGStop and SGStartRecord again      // calling stop allows the SG to release and re-prepare for grabbing      // hopefully fixing any problems, this is obviously a very relaxed      // approach      SGStop(pMungData-&gt;seqGrab);      SGStartRecord(pMungData-&gt;seqGrab);  }}// --------------------// MGAppEventHandler//// Munggrab application event handlerstatic pascal OSStatus MGAppEventHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void *inUserData){#pragma unused(nextHandler)  OSStatus status = eventNotHandledErr;    MungDataPtr pMungData = MungDataPtr(inUserData);  if (NULL == pMungData) goto done;    UInt32 eventKind;  eventKind = GetEventKind(theEvent);    switch (eventKind) {  case kEventAppActivated:    if (!pMungData-&gt;isGrabbing) {      // switched in, if the window isn't collapsed start grabbing      // if it is collapsed let the kEventWindowExpanded event      // start things up again      if (!IsWindowCollapsed(pMungData-&gt;pWindow)) {        SGStartRecord(pMungData-&gt;seqGrab);        SetEventLoopTimerNextFireTime(pMungData-&gt;timerRef, kEventDurationNoWait);        pMungData-&gt;isGrabbing = true;      }    }    status = noErr;    break;  case kEventAppDeactivated:    if (pMungData-&gt;isGrabbing) {      // switched out, stop grabbin'      SGStop(pMungData-&gt;seqGrab);      SetEventLoopTimerNextFireTime(pMungData-&gt;timerRef, kEventDurationForever);      pMungData-&gt;isGrabbing = false;    }    status = noErr;    break;  default:    break;  }done:    return status;}// --------------------// MGWindowEventHandler//// Munggrab window event handlerstatic pascal OSStatus MGWindowEventHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void *inUserData){#pragma unused(nextHandler)  WindowRef theWindow;    OSStatus status = eventNotHandledErr;    MungDataPtr pMungData = MungDataPtr(inUserData);  if (NULL == pMungData) goto done;    UInt32 eventKind;  eventKind = GetEventKind(theEvent);    // we need the window ref or bail  OSErr err;  err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef, NULL, sizeof(theWindow), NULL, &amp;theWindow);  if (err) goto done;      switch (eventKind) {  case kEventWindowUpdate:      if (pMungData-&gt;isGrabbing) {           // inform the sequence grabber of the update            RgnHandle theUpdateRgn = NewRgn();                         GetWindowRegion(theWindow, kWindowUpdateRgn, theUpdateRgn);             SGUpdate(pMungData-&gt;seqGrab, theUpdateRgn);            DisposeRgn(theUpdateRgn);      } else {        DoUpdate(pMungData);    }                     // swallow the update event         BeginUpdate(theWindow);         EndUpdate(theWindow);         status = noErr;    break;  case kEventWindowHiding:    // fall through, same action as kEventWindowCollapsed  case kEventWindowCollapsed:    // checking this here avoids codecNothingToBlitErr later        if (pMungData-&gt;isGrabbing) {          SGStop(pMungData-&gt;seqGrab);          SetEventLoopTimerNextFireTime(pMungData-&gt;timerRef, kEventDurationForever);          pMungData-&gt;isGrabbing = false;        }        status = noErr;    break;  case kEventWindowShown:    // on 9.1 with CarbonLib 1.3.1 we DON'T get this event, when the window is shown    // an update event is generated and we update; on X we DO receive this event but    // receive NO update event, so we update ourselves    DoUpdate(pMungData);    status = noErr;    break;  case kEventWindowExpanded:    // we stopped grabbing in the collapsed event so start grabbing on expanded    if (!pMungData-&gt;isGrabbing) {          SGStartRecord(pMungData-&gt;seqGrab);          SetEventLoopTimerNextFireTime(pMungData-&gt;timerRef, kEventDurationNoWait);          pMungData-&gt;isGrabbing = true;         }         status = noErr;    break;  case kEventWindowClickDragRgn:    Point where;    ICMAlignmentProcRecord apr;                // we need the 'where' param from the Event for DragAlignedWindow        err = GetEventParameter(theEvent, kEventParamMouseLocation, typeQDPoint, NULL, sizeof(where), NULL, &amp;where);        if (err) goto done;                SGGetAlignmentProc(pMungData-&gt;seqGrab, &amp;apr);        DragAlignedWindow(theWindow, where, &amp;gScreenbits.bounds, NULL, &amp;apr);        status = noErr;    break;  case kEventWindowClose:    // we're done    RemoveEventLoopTimer(pMungData-&gt;timerRef);    QuitApplicationEventLoop();    status = noErr;    break;  default:    break;  }done:  return status;}// --------------------// HandleQuit AE//pascal OSErr HandleQuitAE(const AppleEvent *theAppleEvent, AppleEvent *reply, long inRefcon);pascal OSErr HandleQuitAE(const AppleEvent *theAppleEvent, AppleEvent *reply, long inRefcon){#pragma unused (theAppleEvent, reply)  MungDataPtr pMungData = MungDataPtr(inRefcon);    if (pMungData)    RemoveEventLoopTimer(pMungData-&gt;timerRef);    QuitApplicationEventLoop();    return noErr;}// --------------------// InstallEvenHandlers//// install carbon event handlers and timer// you can find more information about carbon events here:// http://developer.apple.com/techpubs/macosx/Carbon/carbon.html// http://developer.apple.com/sdk/index.htmlstatic OSErr InstallEvenHandlers(MungDataPtr inMungData){  OSStatus err = eventInternalErr;    const EventTypeSpec appEventList[] = { kEventClassApplication, kEventAppActivated,                       kEventClassApplication, kEventAppDeactivated };    const EventTypeSpec windowEventList[] = { kEventClassWindow, kEventWindowUpdate,                         kEventClassWindow, kEventWindowCollapsed,                         kEventClassWindow, kEventWindowExpanded,                         kEventClassWindow, kEventWindowClickDragRgn,                         kEventClassWindow, kEventWindowClose,                         kEventClassWindow, kEventWindowShown,                         kEventClassWindow, kEventWindowHiding };  err = InstallEventLoopTimer(GetMainEventLoop(), kEventDurationNoWait, kTimerInterval, NewEventLoopTimerUPP(MGIdleTimer), inMungData, &amp;inMungData-&gt;timerRef);  BailErr(err);    err = InstallApplicationEventHandler(NewEventHandlerUPP(MGAppEventHandler), 2, appEventList, inMungData, NULL);  BailErr(err);    err = InstallWindowEventHandler(inMungData-&gt;pWindow, NewEventHandlerUPP(MGWindowEventHandler), 7, windowEventList, inMungData, NULL);  BailErr(err);    err = AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(HandleQuitAE), (long)inMungData, false);bail:  return err;  }#pragma mark-// --------------------int main(void){    WindowRef      pMainWindow = NULL;    MungDataPtr     pMungData = NULL;    SeqGrabComponent  seqGrab = 0;    SGChannel      sgchanVideo = 0;  Rect         portRect;        OSErr        err = noErr;        InitializeApp();        // create the window    err = MakeAWindow(&amp;pMainWindow);    BailErr(err);        GetPortBounds(GetWindowPort(pMainWindow), &amp;portRect);        // create and initialize the sequence grabber    seqGrab = MakeSequenceGrabber(pMainWindow);    BailErr(NULL == seqGrab);        // create the channel    err = MakeSequenceGrabChannel(seqGrab, &amp;sgchanVideo, &amp;portRect);    BailErr(err);        // initialize our data that's going to be passed around    pMungData = InitializeMungData(pMainWindow, portRect, seqGrab);    BailErr(NULL == pMungData);        // specify a sequence grabber data function  err = SGSetDataProc(seqGrab, NewSGDataUPP(MungGrabDataProc), (long)pMungData);  BailErr(err);    // install carbon event handlers  err = InstallEvenHandlers(pMungData);  BailErr(err);    // lights...camera...  err = SGPrepare(seqGrab, false, true);  BailErr(err);         // ...action  err = SGStartRecord(seqGrab);  BailErr(err);  pMungData-&gt;isGrabbing = true;    // run the application  RunApplicationEventLoop();  bail:  // clean up        if (pMainWindow)      DisposeWindow(pMainWindow);        DisposeMungData(pMungData);    return 0;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SGDataProcSample/listing5.html%3Fid%3DDTS10000807-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SGDataProcSample/listing5.html%3Fid%3DDTS10000807-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SGDataProcSample/listing5.html%3Fid%3DDTS10000807-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>