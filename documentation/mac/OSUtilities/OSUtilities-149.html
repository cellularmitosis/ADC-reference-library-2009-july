<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the Queue Utilities (IM: U)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING149></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="OSUtilities-148.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="OSUtilities-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="OSUtilities-222.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="OSUtilities-150.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="OSUtilities-2.html"><B>Operating System Utilities</B></A> / <BR><DD><A HREF="OSUtilities-147.html"><B>Chapter 6 - Queue Utilities</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING149-0></A>
<H1>Using the Queue Utilities</H1>
 The Queue Utilities provide routines for directly adding elements to a queue and removing them from a queue. The <CODE>Enqueue</CODE> procedure lets you add elements to the end of a queue, and the <CODE>Dequeue</CODE> function lets you remove elements from a queue. You should manipulate an operating-system queue used by the Macintosh Operating System indirectly, by calling special-purpose routines. For example, to install a deferred task into a deferred task queue, your application should use the <CODE>DTInstall</CODE> function instead of the <CODE>Enqueue</CODE> procedure. However, if you create your own queues, you can use the <CODE>Enqueue</CODE> procedure and the <CODE>Dequeue</CODE> function to manipulate these queues directly. This section describes how to<P>
<UL>
<LI>search for an element in an operating-system queue
<LI>add an element to an operating-system queue
<LI>remove an element from an operating-system queue<P>
</UL>
<A NAME=HEADING149-5></A>
<H2>Searching for an Element in an Operating-System Queue</H2>
 You can search an operating-system queue for a specific element or elements. For example, <A HREF=#MARKER-9-67>Listing 6-1</A> shows a simplified way to search a drive queue for all the drives connected to the computer. The application-defined function, <CODE>MySearchDriveQueue</CODE>, walks through the drive queue searches for all connected drives. If it finds any, it calls the application-defined function DoDisplayDriveInfo to display information about the connected drive.<P>
<B>Listing 6-1  <A NAME=MARKER-9-67></A>Searching for drives in the drive queue</B><P>
<PRE>
FUNCTION MySearchDriveQueue: Boolean;
VAR
   driveQHdr:     QHdrPtr;
   result:        Boolean;
BEGIN 
   result := FALSE;                          {assume no drivers in the queue}
   driveQHdr := GetDrvQHdr;                  {get the drive queue header}
   driveQPtr := DrvQElPtr(driveQHdr^.qHead);
   WHILE (driveQPtr &lt;&gt; NIL) DO               {while drive queue is not empty}
   BEGIN
      result := TRUE;                        {found a drive}
      DoDisplayDriveInfo(driveQPtr);         {display drive information}
                                             {go to next drive in the queue}
      driveQPtr := DrvQElPtr(driveQPtr^.qLink);
   END; {of while}
   MySearchDriveQueue := result;             {return result of search}
END;
</PRE>
<A NAME=HEADING149-9></A>
<H2><A NAME=MARKER-2-60></A><A NAME=MARKER-2-24></A><A NAME=MARKER-9-28></A>Adding Elements to an Operating-System Queue</H2>
 You should avoid direct manipulation of an operating-system queue used by the Macintosh Operating System. Your application should, when possible, use the installation routines in <A HREF=#MARKER-9-5>Table 6-2</A> to add new elements to an operating-system queue.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-5></A><B>Table 6-2 Installation routines for operating-system queue elements</B><A NAME=MARKER-2-14></A></CAPTION>
<TH>Queue element<TH>Installation routine<TH>Additional information<TR>
<TD>Slot-based VBL task<TD><CODE>SlotVInstall</CODE><TD>The chapter "Vertical Retrace Manager" in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I><TR>
<TD>System-based VBL task<TD><CODE>VInstall</CODE><TD>The chapter "Vertical Retrace Manager" in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I><TR>
<TD>Parameter block for an asynchronous routine awaiting execution<TD><A HREF="#FOOTNOTE-1">*</A><TD>The chapter "File Manager" in <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I><TR>
<TD>Disk drive<TD>AddDrive<TD>The chapter "File Manager" in <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I><TR>
<TD>Event<TD><CODE>PPostEvent</CODE> and <CODE>PostEvent</CODE><TD>The chapter "Event Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I><TR>
<TD>Volume control block<TD><A HREF=#nonexistent-marker><EM>*</EM></A><TD>The chapter "File Manager" in <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I><TR>
<TD>Deferred task<TD><CODE>DTInstall</CODE><TD>The chapter "Deferred Task Manager" in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I><TR>
<TD>Slot interrupt<TD><CODE>SI</CODE>ntInstall<TD>The chapter "Slot Manager" in <I><A HREF="../Devices/Devices-2.html">Inside Macintosh: Devices</A></I><TR>
<TD>Notification request<TD><CODE>NMInstall</CODE><TD>The chapter "Notification Manager" in <I>Inside Macintosh: Processes<A NAME=MARKER-2-60></A><A NAME=MARKER-2-71></A><A NAME=MARKER-2-72></A><A NAME=MARKER-2-73></A><A NAME=MARKER-2-108></A><A NAME=MARKER-2-109></A><A NAME=MARKER-2-86></A><A NAME=MARKER-9-100></A><A NAME=MARKER-2-52></A><A NAME=MARKER-2-89></A><A NAME=MARKER-9-95></A></I><TR>
<TD>Sleep<TD>SleepQInstall<TD>The chapter "Power Manager" in <I><A HREF="../Devices/Devices-2.html">Inside Macintosh: Devices</A></I></TABLE>
<A NAME=MARKER-2-14></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>It is not recommended that you directly add elements to an operating-system queue used by the Macintosh Operating System. If at all possible, your application should use the installation routines provided by the various managers.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 If you have created a queue for your own use, you can use the <CODE>Enqueue</CODE> procedure to add a new element to your queue. For example, <A HREF=#MARKER-9-72>Listing 6-2</A> presents the application-defined procedure <CODE>DoAddBankCustomer</CODE>, which uses the <CODE>Enqueue</CODE> procedure for directly installing a customer into a bank-teller queue.<P>
<B>Listing 6-2  <A NAME=MARKER-9-72></A>Using the <EM>Enqueue</EM> procedure to add a bank customer to a teller queue</B><P>
<PRE>
PROCEDURE DoAddBankCustomer(myQueueHdrPtr: QHdrPtr,
                            Var bankCustomer: MyCustomerRecord);
BEGIN
   WITH bankCustomer^ DO               {get bank customer data}
   BEGIN
      qType := kTellerQType;           {queue type for the bank-teller queue}
      account := MyGetNextAccount;     {get account number}
      action := MyGetBankAction;       {get action to perform}
      amount := MyGetAmount;           {get the amount}
   END;
   Enqueue(QElemPtr(bankCustomer), myQueueHdrPtr);    {add customer to queue}
END;
</PRE>
 Note that you are responsible for allocating memory for a queue element before you insert into a queue and for deallocating that memory when you remove the queue element.<P>
<A NAME=HEADING149-16></A>
<H2><A NAME=MARKER-2-10></A><A NAME=MARKER-2-3></A><A NAME=MARKER-8-83></A>Removing Elements From an Operating-System Queue</H2>
 This section describes how your application can remove elements from an operating-system queue. Whenever possible, your application should use the removal routines listed in <A HREF=#MARKER-9-28>Table 6-3</A> to remove elements indirectly from an operating-system queue used by the Macintosh Operating System.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-28></A><B>Table 6-3 Removal routines for operating-system elements</B></CAPTION>
<TH>Queue element<TH>Removal routine<TH>Additional information<TR>
<TD>Slot-based VBL task<TD><CODE>SlotVRemove</CODE><TD>The chapter "Vertical Retrace Manager" in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I><TR>
<TD>System-based VBL task<TD><CODE>VRemove</CODE><TD>The chapter "Vertical Retrace Manager" in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I><TR>
<TD>Parameter block for an asynchronous routine awaiting execution<TD><A HREF="#FOOTNOTE-2">*</A><TD>The chapter "File Manager" in <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I><TR>
<TD>Disk drive<TD><A HREF="#FOOTNOTE-2"><EM>*</EM></A><TD>The chapter "File Manager" in <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I><TR>
<TD>Event<TD><CODE>WaitNextEvent</CODE><TD>The chapter "Event Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I><TR>
<TD>Volume control block<TD><A HREF="#FOOTNOTE-2"><EM>*</EM></A><TD>The chapter "File Manager" in <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I><TR>
<TD>Deferred task<TD><A HREF="#FOOTNOTE-2"><EM>*</EM></A><TD>The chapter "Deferred Task Manager" in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I><TR>
<TD>Slot interrupt<TD><CODE>SIntRemove</CODE><TD>The chapter "Slot Manager" in <I><A HREF="../Devices/Devices-2.html">Inside Macintosh: Devices</A></I><TR>
<TD>Notification request<TD><CODE>NMRemove</CODE><TD>The chapter "Notification Manager" in <I>Inside Macintosh: Processes<A NAME=MARKER-2-61></A><A NAME=MARKER-9-96></A><A NAME=MARKER-2-51></A><A NAME=MARKER-2-32></A><A NAME=MARKER-2-33></A><A NAME=MARKER-2-4></A><A NAME=MARKER-2-63></A><A NAME=MARKER-2-123></A><A NAME=MARKER-2-37></A><A NAME=MARKER-2-6></A><A NAME=MARKER-2-39></A><A NAME=MARKER-2-40></A></I><TR>
<TD>Sleep<TD>SleepQRemove<TD>The chapter "Power Manager" in <I><A HREF="../Devices/Devices-2.html">Inside Macintosh: Devices</A></I></TABLE>
<P>
 <P>
 <P>
 <P>
<DL>
<DT><B>IMPORTANT</B>
<DD>It is not recommended that you directly remove queue elements from an operating-system queue used by the Macintosh Operating System. If at all possible, your application should use the removal routines provided by the various managers.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 If you have created a queue for your own use, you can use the <CODE>Dequeue</CODE> function to remove elements from that queue.<P>
 <A HREF=#MARKER-9-76>Listing 6-3</A> shows the application-defined function <CODE>DoRemoveBankCustomer</CODE>, which uses the <CODE>Dequeue</CODE> procedure for directly removing the first customer from a bank-teller queue. The <CODE>DoRemoveBankCustomer</CODE> function returns <CODE>TRUE</CODE> if it removes the customer.<P>
<B>Listing 6-3  <A NAME=MARKER-9-76></A>Using <EM>Dequeue</EM> to remove the first customer in the bank-teller queue</B><P>
<PRE>
FUNCTION DoRemoveBankCustomer (VAR myQueueHdr: QHdr): BOOLEAN;
VAR
   bankCustomerPtr: MyCustomerRecordPtr;
   customerRemoved: Boolean;

BEGIN
   customerRemoved := FALSE;
   bankCustomerPtr := MyCustomerRecordPtr(myQueueHdr.qHead);
   IF bankCustomerPtr &lt;&gt; NIL THEN      {Check for non-empty queue}
   BEGIN
      Dequeue(QElemPtr(bankCustomerPtr),&amp;myQueueHdr) {remove customer}
      customerRemoved := TRUE;
   END; {of queue not empty}
   DoRemoveCustomer := customerRemoved;
END;
</PRE>
<HR>

<A NAME="FOOTNOTE-1">* No comparative installation routine available.
<HR>


</BLOCKQUOTE>
<HR>
<center>
<A HREF="OSUtilities-148.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="OSUtilities-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="OSUtilities-222.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="OSUtilities-150.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="OSUtilities-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
