<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Authorization Services Programming Guide: Authorization Concepts</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Authorization Concepts"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000995-CH205" title="Authorization Concepts"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000434" target="_top">Security</a> &gt; <a href="../../../Authorization-date.html#//apple_ref/doc/uid/TP30000440-TP30000434-TP30001024" target="_top">Authorization</a> &gt; <a href="../01introduction/introduction.html#//apple_ref/doc/uid/TP30000995-CH204-TP1">Authorization Services Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../01introduction/introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../03authtasks/authtasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000995-CH205-TP9" title="Authorization Concepts"></a><h1>Authorization Concepts</h1><p>This chapter covers concepts rather than implementation or programming details. See <span class="content_text"><a href="../03authtasks/authtasks.html#//apple_ref/doc/uid/TP30000995-CH206-TP9">“Authorization Services Tasks”</a></span> for information about using specific Authorization Services functions in your application.</p><p>You should understand the basics of permissions and ownership in BSD and Mac OS X before reading this chapter. See Chapter 13, “Installation and Integration”, of <em>Inside Mac OS X: System Overview</em> for a brief introduction to these concepts. For definitions of terms, see the <span class="content_text"><a href="../glossary/glossary.html#//apple_ref/doc/uid/TP30000995-CH208-TP1">“Glossary.”</a></span></p><p>This chapter contains the following sections:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205-TPXREF9">“Authorization”</a></span> provides a conceptual overview of the policy-based authorization used by Mac OS X.</p></li><li class="li"><p><span class="content_text"><a href="authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205-TPXREF18">“Authentication”</a></span> describes how authorization uses authentication.</p></li><li class="li"><p><span class="content_text"><a href="authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205-TPXREF14">“The Security Server”</a></span> describes how you use Authorization Services in your application to interact with the Security Server.</p></li><li class="li"><p><span class="content_text"><a href="authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205-TPXREF16">“Rights”</a></span> describes how to name your own rights.</p></li><li class="li"><p><span class="content_text"><a href="authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205-TPXREF19">“The Policy Database”</a></span> explains how the Security Server uses a policy database to make authorization decisions.</p></li><li class="li"><p><span class="content_text"><a href="authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205-CJBJBGAA">“The Credentials Cache and the Authentication Dialog”</a></span> explains how the Security Server determines whether to display an authentication dialog.</p></li><li class="li"><p><span class="content_text"><a href="authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205-TPXREF20">“Scenarios”</a></span> describes different scenarios that use Authorization Services.</p></li></ul><a name="//apple_ref/doc/uid/TP30000995-CH205-TPXREF9" title="Authorization"></a><h2>Authorization</h2><p>The underlying BSD portion of the Mac OS X kernel provides a user-and-owner-security model. Each file system object, such as a file or directory, has an owner and a set of <strong>permissions</strong>, or attributes, specifying what the owner, one group, and all others are able to do with the object. </p><p>There are cases where the BSD security model doesn’t fit situations faced by Mac OS X users. For example, if you want to create a grades-and-transcripts application, you’ll want teachers and school registrars to use the application, but you may want to restrict the creation of transcripts to just the registrars.</p><p>You may need to protect the user from accidentally making important changes that the underlying BSD security model allows. For example, you may want a user to authenticate as an administrator before changing application-specific preferences. Authorization Services can also be used to perform operations as <strong>root</strong>—also known as the superuser—such as restarting a daemon.</p><p>In these cases, a policy-based security model, used in addition to the BSD permissions, provides additional important features for your application. In a <strong>policy-based system</strong>, a user requests <strong>authorization</strong>—the act of granting a right or privilege—to perform a privileged operation. Authorization is performed through an agent so the user doesn’t have to trust the application with a password. The agent is the user interface— operating on behalf of the Security Server—used to obtain the user’s password or other form of identification, which also ensures consistency between applications. The <strong>Security Server</strong>—a Core Services daemon in Mac OS X that deals with authorization and authentication—determines whether no one, everyone, or only certain users may perform a privileged operation.</p><p>Authorization offers you fine-grained control over granting users privileges to perform administrative tasks and other privileged operations. Using Authorization Services allows you to restrict parts of your application, add extra security precautions, and still satisfy the BSD security model. You should avoid bypassing the BSD security model—for example, don’t run processes as root—unless you have no alternative, in which case you should limit the amount of code involved.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000995-CH205-DontLinkElementID_3" title="Note"></a><p><strong>Note:</strong>&nbsp;It is your responsibility, in a policy-based system, to request authorization for your users. Your application should authorize immediately before every privileged operation.</p></div><p>In some circumstances it is valuable to determine if the user is authorized to perform privileged operations well before your application actually needs to perform those operations. For example, when the System Preferences application is locked, it requires a user to provide a name and password before it will allow the user to change any settings. When the user clicks on the lock button (see <span class="content_text">Figure 1-1</span>), the System Preferences application performs <strong>preauthorization</strong>. Preauthorization determines a user’s rights before authorization is required. By preauthorizing, System Preferences prevents users from customizing and selecting options for an operation they are not authorized to perform.</p><br/><div><a name="//apple_ref/doc/uid/TP30000995-CH205-BAJHGJIE" title="Figure 1-1An example of the System Preferences application as seen by an unauthorized user"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>An example of the System Preferences application as seen by an unauthorized user</p><img src = "../art/sys_pref_locked.gif" alt = "An example of the System Preferences application as seen by an unauthorized user" width="470" height="372"></div><br/><p><span class="content_text">Figure 1-2</span> shows the window the user sees after successfully preauthorizing. However, the System Preferences application still performs authorization immediately before carrying out any privileged operation.</p><br/><div><a name="//apple_ref/doc/uid/TP30000995-CH205-BAJCJACG" title="Figure 1-2An example of the System Preferences application as seen by a preauthorized user"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>An example of the System Preferences application as seen by a preauthorized user</p><img src = "../art/sys_pref_unlocked.gif" alt = "An example of the System Preferences application as seen by a preauthorized user" width="471" height="371"></div><br/><a name="//apple_ref/doc/uid/TP30000995-CH205-TPXREF18" title="Authentication"></a><h2>Authentication</h2><p><strong>Authentication</strong> is the act of verifying the identity of the user. A common misconception is that authorization and authentication are one and the same; however, authentication is only part of the authorization process. As discussed in <span class="content_text"><a href="authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205-TPXREF9">“Authorization,”</a></span> after the user is authenticated, the authorization process involves determining what rights or privileges that user has. </p><p><span class="content_text">Figure 1-3</span> shows an example of authentication in the System Preferences application.</p><br/><div><a name="//apple_ref/doc/uid/TP30000995-CH205-BAJHACIF" title="Figure 1-3An example of authentication in the System Preferences application"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>An example of authentication in the System Preferences application</p><img src = "../art/sys_pref_authenticating.gif" alt = "An example of authentication in the System Preferences application" width="488" height="371"></div><br/><p>Typically today, the user types in a user name and password to be authenticated. In future releases of Mac OS X, the user might produce a smart card, use a <strong>biometric identifier</strong>, such as a fingerprint or retinal scan, or use a combination of authentication methods.</p><p>When your application requests authorization of the user, you can set an option that allows the Security Server to interact with the user. Doing so tells the Security Server to request proof of identity from the user for authentication purposes, as needed.</p><a name="//apple_ref/doc/uid/TP30000995-CH205-TPXREF14" title="The Security Server"></a><h2>The Security Server</h2><p>The Security Server processes authorization requests in a manner analogous to how an immigration official processes visas. <span class="content_text">Table 1-1</span> compares the two processes.</p><a name="//apple_ref/doc/uid/TP30000995-CH205-BAJCBACF" title="Table 1-1A comparison of the steps involved in authorization and the immigration processes"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-1&nbsp;&nbsp;</strong>A comparison of the steps involved in authorization and the immigration processes</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Immigration</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Authorization</p></th></tr><tr><td  scope="row"><p>The immigrant provides a passport and visa to the immigration official.</p></td><td ><p>The application provides the authorization reference, authorization rights set, and authorization options to the Security Server.</p></td></tr><tr><td  scope="row"><p>The immigration official uses the visa number to access information about the immigrant.</p></td><td ><p>The Security Server uses the authorization reference to access credentials.</p></td></tr><tr><td  scope="row"><p>The immigration official uses the picture in the passport to validate the identity of the immigrant.</p></td><td ><p>The Security Server asks the user to provide a user name and password for authentication.</p></td></tr><tr><td  scope="row"><p>The immigration official uses the privileges requested in the visa to look up the laws in the policy book.</p></td><td ><p>The Security Server uses the rights in the authorization rights set to look up the rules in the policy database.</p></td></tr><tr><td  scope="row"><p>The immigration official uses the credentials to determine if the immigrant complies with the laws and should be granted the privileges requested in the visa.</p></td><td ><p>The Security Server uses the credentials and authorization options to determine if the user complies with the rules and should be granted the rights requested in the authorization rights set.</p></td></tr><tr><td  scope="row"><p>The immigration official informs the immigrant whether or not he grants the privileges requested in the visa.</p></td><td ><p>The Security Server returns a result granting or denying the authorization rights.</p></td></tr></table></div><p>To initiate an authorization session between your application and the Security Server, you create an <strong>authorization reference</strong>. The Security Server uses the authorization reference to access the authorization session. You pass the authorization reference to almost every Authorization Services function.</p><p>When you request authorization, you send instructions to the Security Server in the form of <strong>authorization options</strong>. The authorization options tell the Security Server how to proceed with the authorization request. For example, you can specify that the call is for authorization, partial authorization, or preauthorization. You can also specify whether you want to allow the Security Server to interact with the user to perform authentication.</p><p>To authorize a user, you must pass the Security Server an <strong>authorization rights set</strong> that contains rights a user needs, such as the right to create a transcript or restart a daemon. A <strong>right</strong> is a named privilege that the application requests on behalf of a user.</p><p>A <strong>credential</strong> is a token representing an authenticated user that the Security Server stores as part of the authorization session. The Security Server uses these credentials as proof of authenticity. Credentials expire after a set length of time. You can also force their expiration when freeing an authorization reference.</p><p>The Security Server uses a <strong>policy database</strong> that contains a set of rules. A <strong>rule</strong> is a set of attributes that determine who should be authorized to perform a specific action. The Security Server compares the rules with a user’s rights and authentication credentials to determine if the user is authorized to perform a privileged operation.</p><p>Rights that are granted are not stored in the authorization session. Instead, every time authorization is performed, the Security Server uses the credentials—or reauthenticates the user if the credentials have expired—and consults the appropriate rule in the policy database to reevaluate the authorization.</p><a name="//apple_ref/doc/uid/TP30000995-CH205-TPXREF16" title="Rights"></a><h2>Rights</h2><p>When your application requests authorization, you pass the requested rights (an authorization rights set) to the Security Server. The Security Server compares the rights you pass to the keys in the policy database. When a match is found, the Security Server uses the rules associated with the key to determine authorization. For more information about the policy database see <span class="content_text"><a href="authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205-TPXREF19">“The Policy Database.”</a></span></p><p>You must create the rights your application uses. Rights use a hierarchical namespace. The right should begin with the reverse domain name of your organization. The right should then specify the name of your application and become more specific—for example, <code>com.myOrganization.myProduct.myRight</code>. Rights that are specific to Mac OS X have right names that begin with <code>system</code>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000995-CH205-DontLinkElementID_4" title="Note"></a><p><strong>Note:</strong>&nbsp;Rights are case sensitive.</p></div><p>Your right should represent an individual action on one or a group of targets. For example, a right might represent the individual action of restarting a daemon, such as <code>com.myOrganization.myProduct.inetd.restart</code> to restart the Internet daemon, or <code>com.myOrganization.myProduct.daemons.restart</code> to restart a group of daemons.</p><p>Because you can request multiple rights for the same user, there is no need to create rights that represent combinations of actions. For example, in a grades-and-transcripts application, if you name a right <code>com.myOrganization.myProduct.transcripts.create</code> and another right <code>com.myOrganization.myProduct.grades.edit</code>, there is no need for a separate right <code>com.myOrganization.myProduct.createTranscriptsAndEditGrades</code>.</p><p>The name you select for a right should make sense to the user. For example, <code>system.finder.trash.empty</code> is more readily understood than <code>system.finder.trashDirectory.deleteFiles</code>.</p><a name="//apple_ref/doc/uid/TP30000995-CH205-TPXREF19" title="The Policy Database"></a><h2>The Policy Database</h2><p>The policy database contains a set of rules the Security Server uses to authorize rights for a user. Each rule consists of a set of attributes. The rules are preconfigured when Mac OS X is installed, but an application may change them at any time. Because any application can change the rights in the database, your application must take into account all possible scenarios. <span class="content_text">Table 1-2</span> describes the attributes defined for rules.</p><p>There are some specific rules in the policy database for Mac OS X applications. There is also a generic rule in the policy database that the Security Server uses for any right that doesn’t have a specific rule.</p><a name="//apple_ref/doc/uid/TP30000995-CH205-BAJDCADH" title="Table 1-2Rule attributes and descriptions"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-2&nbsp;&nbsp;</strong>Rule attributes and descriptions</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Rule attribute</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Generic rule value</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>key</code></p></td><td ><p></p></td><td ><p>The <strong>key</strong> is the name of a rule. A key uses the same naming conventions as a right. The Security Server uses a rule’s key to match the rule with a right. Wildcard keys end with a ‘<code>.</code>’. The generic rule has an empty key value. Any rights that do not match a specific rule use the generic rule.</p></td></tr><tr><td  scope="row"><p><code>group</code></p></td><td ><p><code>admin</code></p></td><td ><p>The user must authenticate as a member of this group. This attribute can be set to any one group.</p></td></tr><tr><td  scope="row"><p><code>shared</code></p></td><td ><p><code>true</code></p></td><td ><p>If this is set to <code>true</code>, then the Security Server marks the credentials used to gain this right as shared. The Security Server may use any shared credentials to authorize this right. For maximum security, set sharing to <code>false</code> so credentials stored by the Security Server for one application may not be used by another application.</p></td></tr><tr><td  scope="row"><p><code>timeout</code></p></td><td ><p><code>300</code></p></td><td ><p>The credential used by this rule expires in the specified number of seconds. For maximum security where the user must authenticate every time, set the timeout to <code>0</code>. For minimum security, remove the timeout attribute so the user authenticates only once per session.</p></td></tr></table></div><p>Your right always matches up with the generic rule unless a new rule is added to the policy database. Use the <code><a href="../../../Reference/authorization_ref/Reference/reference.html#//apple_ref/doc/c_ref/AuthorizationRightSet" target="_top">AuthorizationRightSet</a></code> function to add or edit a rule in the database. Use the <code><a href="../../../Reference/authorization_ref/Reference/reference.html#//apple_ref/doc/c_ref/AuthorizationRightGet" target="_top">AuthorizationRightGet</a></code> function to read the current rule. Use the <code><a href="../../../Reference/authorization_ref/Reference/reference.html#//apple_ref/doc/c_ref/AuthorizationRightRemove" target="_top">AuthorizationRightRemove</a></code> function to delete a rule.</p><p>To lock out all privileged operations not explicitly allowed, change the generic rule by setting the timeout attribute to <code>0</code>. To allow all privileged operations once the user is authorized, remove the timeout attribute from the generic rule. To prevent applications from sharing rights, set the shared attribute to <code>false</code>. To require users to authenticate as a member of the staff group instead of the admin group, set the group attribute to <code>staff</code>.</p><p>As an example of how the Security Server matches a right with a rule in the policy database, consider a grades-and-transcripts application. The application requests the right <code>com.myOrganization.myProduct.transcripts.create</code>. The Security Server looks up the right in the policy database. Not finding an exact match, the Security Server looks for a rule with a wildcard key set to <code>com.myOrganization.myProduct.transcripts.</code>, <code>com.myOrganization.myProduct.</code>, <code>com.myOrganization.</code>, or <code>com.</code>—in that order—checking for the longest match. If no wildcard key matches, then the Security Server uses the generic rule. The Security Server requests authentication from the user. The user provides a user name and password to authenticate as a member of the group <code>admin</code>. The Security Server creates a credential based on the user authentication and the right requested. The credential specifies that other applications may use it, and the Security Server sets the expiration to five minutes.</p><p>Three minutes later, a child process of the application starts up. The child process requests the right <code>com.myOrganization.myProduct.transcripts.create</code>. The Security Server finds the credential, sees that it allows sharing, and uses the right. Two and a half minutes later, the same child process requests the right <code>com.myOrganization.myProduct.transcripts.create</code> again, but the right has expired. The Security Server begins the process of creating a new credential by consulting the policy database and requesting user authentication.</p><a name="//apple_ref/doc/uid/TP30000995-CH205-CJBJBGAA" title="The Credentials Cache and the Authentication Dialog"></a><h2>The Credentials Cache and the Authentication Dialog</h2><p>You might notice that when you call the <code>AuthorizationCreate</code> function or the <code><a href="../../../Reference/authorization_ref/Reference/reference.html#//apple_ref/doc/c_ref/AuthorizationCopyRights" target="_top">AuthorizationCopyRights</a></code> function to obtain rights for a user, sometimes an authentication dialog appears and at other times the dialog does not appear. The reason for this behavior is related to the settings in the policy database and the way in which the Security Server caches user credentials.</p><p>A credential is something that the Security Server knows about a particular user, such as the fact that a particular user has entered a valid user name and password.</p><p>For each login session, the Security Server maintains a global credentials cache and a credentials cache per authorization instance (that is, for each time a new authorization reference is created). The rule for each right in the policy database indicates the group to which the authenticated user must belong and how long the credential is considered valid. The rule might also indicate that the credential is to be shared. </p><p>When Authorization Services needs a credential in order to grant a right to a user, the Security Server attempts to obtain the credential from a credentials cache. It first looks in the credentials cache associated with the authorization instance. If the credential isn’t there and credentials are shared, it then looks in the global credentials cache. Only if the Security Server can’t find the credential in a cache does it try to acquire the credential, typically by displaying an authentication dialog. (In some cases, the Security Server might be able to acquire the credential from another source, such as a smart card.)</p><p>If the Security Server successfully obtains a new credential, it stores it in the credentials cache associated with the authorization instance and—if the rule specifies that the credential should be shared—in the global credentials cache.</p><p>If the rule for the right has a timeout attribute, its value indicates how long (in seconds) a cached credential is applicable for this right. A value of <code>0</code> means that the credential can only be used once (that is, it times out immediately). If the timeout attribute is missing, the credential can be used to grant the right as long as the login session lasts, unless the credential is explicitly destroyed.</p><p>When a user who is a member of the admin group logs on to the system, for example, the user’s credential (that is, the fact that they have entered a valid admin user name and password) is saved in the global credentials cache. Then when this user attempts to modify a system preference, Security Server finds the credential in the cache and does not display an authentication dialog.</p><p>On the other hand, if a user logs on with a non-admin user name and password and tries to modify one of the system preferences, Security Server cannot obtain the needed credential from a credentials cache. Therefore, it displays the authentication dialog. </p><p>The same principle applies for any application that requires a credential: if the user has been authenticated for one application and the credential has been shared, another application can use that credential. </p><p>Consequently, whether a call to <code><a href="../../../Reference/authorization_ref/Reference/reference.html#//apple_ref/doc/c_ref/AuthorizationCopyRights" target="_top">AuthorizationCopyRights</a></code> results in an authentication dialog depends on whether the Security Server has already cached the required credential.</p><p>The only way to guarantee that a credential acquired when you request a right is not shared with other authorization instances is to destroy the credential. To do so, call the <code><a href="../../../Reference/authorization_ref/Reference/reference.html#//apple_ref/doc/c_ref/AuthorizationFree" target="_top">AuthorizationFree</a></code> function with the flag <code>kAuthorizationFlagDestroyRights</code>.</p><a name="//apple_ref/doc/uid/TP30000995-CH205-TPXREF20" title="Scenarios"></a><h2>Scenarios</h2><p>There are three main scenarios that involve Authorization Services: simple self-restricted applications, factored applications, and installers. </p><a name="//apple_ref/doc/uid/TP30000995-CH205-TPXREF21" title="Simple, Self-Restricted Applications"></a><h3>Simple, Self-Restricted Applications</h3><p>A <strong>self-restricted application</strong> requires that certain features be accessible only by a specific group of users. In a simple self-restricted application, this separation of features is done within the main application. You use Authorization Services in this situation because this kind of fine-grain restriction cannot be controlled by BSD permissions.</p><p>Consider a grades-and-transcripts application that allows only registrars to create transcripts, while the rest of the application is available to both teachers and registrars. When a user attempts to create a transcript, the application uses Authorization Services to decide if that user may perform the operation.</p><p><span class="content_text">Figure 1-4</span> shows a flow chart of a simple, self-restricting application. The application creates an authorization reference. The authorization reference refers to the authorization session with the Security Server. Immediately before performing any privileged operation, such as creating a transcript, the application requests authorization on behalf of the user. If required, the Security Server requests authentication of the user. If authorization succeeds, the privileged operation is performed. The application releases the authorization reference when it is no longer needed.</p><p>In most cases, it is beneficial to separate the privileged operations into a separate helper tool. See <span class="content_text"><a href="authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205-TPXREF22">“Factored Applications”</a></span> for more information on how to use Authorization Services with helper tools.</p><p>You can perform authorization without creating an authorization reference if you need to authorize just once—for example, when your application first starts up. To do so you use the result of the authorization call directly. Because in this case you did not create an authorization reference, you don’t have to release it. One-time authorization is described in more detail in the section <span class="content_text"><a href="../03authtasks/authtasks.html#//apple_ref/doc/uid/TP30000995-CH206-TPXREF12">“Authorizing.”</a></span></p><br/><div><a name="//apple_ref/doc/uid/TP30000995-CH205-BAJDDDFA" title="Figure 1-4Flow chart for a simple, self-restricted application"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>Flow chart for a simple, self-restricted application</p><img src = "../art/selfrestrictingapp.gif" alt = "Flow chart for a simple, self-restricted application" width="164" height="198"></div><br/><a name="//apple_ref/doc/uid/TP30000995-CH205-TPXREF22" title="Factored Applications"></a><h3>Factored Applications</h3><p>A <strong>factored application</strong> is an application that delegates specific tasks to smaller, separate tools. These tools are sometimes referred to as <strong>helper tools</strong>. In a simple, self-restricted application, the privileged code is in the application itself, whereas in a factored application, the privileged code is in the helper tool.</p><p>An operation that your application performs might be restricted by the BSD security model. Such an application is a <strong>system-restricted</strong> application. For example, an application that requires restarting the Internet daemon (<code>inetd</code>) must have root privileges, but it runs with the privileges of the user that started it.</p><p>It is recommended that you factor both self-restricted applications and system-restricted applications. Factoring your application provides two benefits. The first is that it is easier to audit a factored application because the privileged operation is performed in a separate process by the helper tool. The second is that a factored application provides more security. In a nonfactored application, you not only have to trust that there are no security holes in your code but also no holes in all of the code that you link to.</p><p><span class="content_text">Figure 1-5</span> shows a flow chart for the application part of a factored application while the flow chart for the helper tool is shown in <span class="content_text">Figure 1-6</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30000995-CH205-BAJHDCHE" title="Figure 1-5Flow chart for the application part of a factored application"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>Flow chart for the application part of a factored application</p><img src = "../art/privilegedapp.gif" alt = "Flow chart for the application part of a factored application" width="166" height="242"></div><br/><p>The application begins by creating an authorization reference and requesting preauthorization from the Security Server immediately before calling the helper tool. The application uses the results of preauthorization to determine if the user has the right to perform the privileged operations in the helper tool. Performing preauthorization ensures that resources and time aren’t wasted invoking a helper tool that the user does not have the right to use.</p><br/><div><a name="//apple_ref/doc/uid/TP30000995-CH205-BAJEFJHE" title="Figure 1-6Flow chart for a helper tool"></a><p><strong>Figure 1-6&nbsp;&nbsp;</strong>Flow chart for a helper tool</p><img src = "../art/helpertool.gif" alt = "Flow chart for a helper tool" width="274" height="163"></div><br/><p>The application needs to pass the authorization reference to the helper tool. Because you cannot transfer an authorization reference itself between two processes, the application uses Authorization Services to create an external, transferable form of the authorization reference to send to its helper tool.</p><p>The helper tool uses Authorization Services to create an authorization reference from the external authorization reference. The helper tool requests authorization and uses the results to decide whether to continue with the privileged operation.</p><p>You must pass the authorization reference to your helper tool so that the authorization dialog can show your application’s path rather than the path to the helper tool and to allow the system to determine whether the authorization dialog should have keyboard focus.</p><p>You must perform authorization immediately before any privileged operation, even if the user has already successfully authorized. Rights can expire, thus it is your responsibility as a developer to ensure that the user is up to date on all required rights. Any application can modify the policy database to set the length of time a right is available (see <span class="content_text"><a href="authconcepts.html#//apple_ref/doc/uid/TP30000995-CH205-TPXREF19">“The Policy Database”</a></span>).</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000995-CH205-DontLinkElementID_5" title="Note"></a><p><strong>Note:</strong>&nbsp;The ability to perform a privileged operation is governed by the BSD security model, not Authorization Services. The expiration of a right does not prevent a user with the proper BSD permissions from performing certain privileged operations—you must build that prevention into your code by authorizing immediately before privileged operations.</p></div><p>Some system-supplied utilities use Authorization Services. For example, the <code>authopen</code> utility uses Authorization Services to open privileged files. If you call a utility like <code>authopen</code>, then it is unnecessary to write your own helper tool.</p><p>Some privileged operations require special permissions. For example, an application that restarts the Internet daemon must have root privileges. There are three possible ways to perform this operation, all with their own problems:</p><ul class="spaceabove"><li class="li"><p>Make the application run as root by calling itself with a special Authorization Services function.</p></li><li class="li"><p>Set the <strong>setuid bit</strong> of the application and change its owner to root, and then use the special Authorization Services function.</p></li><li class="li"><p>Factor out the operation that performs the privileged operation and put it in a separate <strong>setuid tool</strong>—a tool that has its setuid bit set—and set the setuid tool’s owner to root.</p></li></ul><p>Both the first and second options are a security breach waiting to happen. When the privileged application runs, it calls a special function that Authorization Services provides—<code>AuthorizationExecuteWithPrivileges</code> (see <span class="content_text"><a href="../03authtasks/authtasks.html#//apple_ref/doc/uid/TP30000995-CH206-TPXREF18">“Calling a Helper Tool as Root”</a></span> for more details). Calling this function executes any application or tool with root privileges, regardless of the owner of the application or tool. This is very dangerous since parts of the application can be easily replaced.</p><p>The second option is to set the setuid bit of the privileged application and change its owner to root. The setuid bit, when set, allows the process running it to masquerade as another user. Setting the setuid bit and owner of the application to a different user, such as root, makes it more difficult to replace. However, running code as root is very dangerous and should be done as seldom as possible. Setting the setuid bit on an entire application is especially dangerous because you are trusting that your entire application, and the code your application links to, is free of security holes.</p><p>The third scenario is by far the best. The application is split into an application that controls all of the graphical user interface elements and nonprivileged operations, and a helper tool that performs only the operations involved in restarting the Internet daemon. The helper tool’s setuid bit is set and the owner is set to root. The proper Authorization Services functions are used as described previously. Factoring and setting the setuid bit not only minimizes the risk but also makes it easier to audit your code for security holes.</p><p>One problem with the last scenario is that setuid bit settings are lost when a file is copied. Thus, if the user copies your setuid tool, the setuid bit is no longer set. It is possible to reset the setuid bit in the setuid tool itself. <span class="content_text">Figure 1-7</span> shows the flow chart of a setuid tool that repairs its own setuid bit. You may not want the user to be able to copy the application. If that is the case, you don’t need to worry about repairing the setuid bit, just let the user know that they need to reinstall the application.</p><br/><div><a name="//apple_ref/doc/uid/TP30000995-CH205-BAJFHAAG" title="Figure 1-7Flow chart for a self-repairing helper tool"></a><p><strong>Figure 1-7&nbsp;&nbsp;</strong>Flow chart for a self-repairing helper tool</p><img src = "../art/helpertoolflow.gif" alt = "Flow chart for a self-repairing helper tool" width="426" height="293"></div><br/><p>When the self-repairing helper tool is run, it checks if the self-repair flag was passed. If the self-repair flag was not passed, then it reads in the external authorization reference that the application passed.</p><p>The self-repairing setuid tool then checks if it is running as root. If it is running as root, then authorization is performed and, based on the result, the privileged operation is performed. If the self-repairing setuid tool is not running as root, then it calls itself with the <code>AuthorizationExecuteWithPrivileges</code> function and passes itself the self-repair flag.</p><p>When the new self-repairing setuid tool process starts, it checks if the self-repair flag was passed. If the self-repair flag was passed, then the self-repairing setuid tool recovers the authorization reference and repairs the setuid bit. After the self-repairing setuid tool is running as root, it performs authorization and continues as a normal helper tool.</p><a name="//apple_ref/doc/uid/TP30000995-CH205-TPXREF23" title="Installers"></a><h3>Installers</h3><p>Not all installers require authorization—only those that need special privileges to copy files to restricted directories, make changes to restricted files, or set setuid bits.</p><p>An installer is a special case because unlike other applications, an installer is usually run only once. Due to the limited use, Authorization Services provides a function to invoke your installer to run with root privileges. It is up to the user to determine if the installer is from a trusted source.</p><p><span class="content_text">Figure 1-8</span> shows a flow chart of an application using Authorization Services to call an installer. In this case, the application creates the authorization reference and performs preauthorization. If the user successfully preauthorizes, then you call the <code>AuthorizationExecuteWithPrivileges</code> function to execute your installer with root privileges.</p><br/><div><a name="//apple_ref/doc/uid/TP30000995-CH205-BAJJHADD" title="Figure 1-8Flow chart of an application to call a privileged installer"></a><p><strong>Figure 1-8&nbsp;&nbsp;</strong>Flow chart of an application to call a privileged installer</p><img src = "../art/installercaller.gif" alt = "Flow chart of an application to call a privileged installer" width="164" height="196"></div><br/><p><span class="content_text">Figure 1-9</span> shows a flow chart for the Authorization Services calls performed in the installer itself. Authorization should be performed before any privileged operation.</p><br/><div><a name="//apple_ref/doc/uid/TP30000995-CH205-BAJDJCEG" title="Figure 1-9Flow chart of an installer&acirc;&#128;&#153;s Authorization Services calls."></a><p><strong>Figure 1-9&nbsp;&nbsp;</strong>Flow chart of an installer’s Authorization Services calls.</p><img src = "../art/installer.gif" alt = "Flow chart of an installer’s Authorization Services calls." width="275" height="160"></div><br/>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../01introduction/introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../03authtasks/authtasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-01-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Security/Conceptual/authorization_concepts/02authconcepts/authconcepts.html%3Fid%3DTP30000995-3.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Security/Conceptual/authorization_concepts/02authconcepts/authconcepts.html%3Fid%3DTP30000995-3.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Security/Conceptual/authorization_concepts/02authconcepts/authconcepts.html%3Fid%3DTP30000995-3.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>