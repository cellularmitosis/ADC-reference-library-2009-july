<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GlyphaIVOld - /G4Graphics.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Games/index.html">Games</a> &gt; <a href="../../samplecode/Games/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">GlyphaIVOld</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Games/idxGraphicsImaging-date.html" target="_blank">Games > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GlyphaIVOld</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/G4Graphics.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/G4Enemy.c</option>
<option value="listing2.html">/G4Externs.h</option>
<option value="listing3.html">/G4Graphics.c</option>
<option value="listing4.html">/G4Interface.c</option>
<option value="listing5.html">/G4Lava.c</option>
<option value="listing6.html">/G4Main.c</option>
<option value="listing7.html">/G4Play.c</option>
<option value="listing8.html">/G4Prefs.c</option>
<option value="listing9.html">/G4SetUpTakeDown.c</option>
<option value="listing10.html">/G4Sound.c</option>
<option value="listing11.html">/G4Utilities.c</option></select>
				</p>
				</form>
				<p><strong><a href="GlyphaIVOld.zip">Download Sample</a></strong> (&#147;GlyphaIVOld.zip&#148;, 106.6K)<BR>
<strong><a href="GlyphaIVOld.dmg">Download Sample</a></strong> (&#147;GlyphaIVOld.dmg&#148;, 175.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    G4Graphics.c  Contains:  xxx put contents here xxx  Version:  xxx put version here xxx  Copyright:  &copy; 1998 by Apple Computer, Inc., all rights reserved.  File Ownership:    DRI:        xxx put dri here xxx    Other Contact:    xxx put other contact here xxx    Technology:      xxx put technology here xxx  Writers:    (sjb)  Steve Bollinger  Change History (most recent first):     &lt;3&gt;    7/1/98  sjb    Update to CWPro 2*///============================================================================//----------------------------------------------------------------------------//                  Graphics.c//----------------------------------------------------------------------------//============================================================================// I like to isolate all the graphic routines - put them in their own file.// This way all the thousands of Rect variables and Pixmaps have a place to go.// Anyway, this file contains all the drawing routines.#include &quot;G4Externs.h&quot;#include &lt;Palettes.h&gt;#include &lt;QuickdrawText.h&gt;#include &lt;Fonts.h&gt;#include &lt;TextUtils.h&gt;#include &lt;Events.h&gt;#define kUpperEyeHeight      100#define kLowerEyeHeight      200#define kNumLightningPts    8void QuickUnionRect (Rect *, Rect *, Rect *);void CheckPlayerWrapAround (void);void DrawHand (void);void DrawEye (void);void DrawPlayer (void);void CheckEnemyWrapAround (short);void DrawEnemies (void);void DrawBanner (void);void DrawLava(void);void HandleLava(void);void HandlePixelShatter(void);Rect    backSrcRect, workSrcRect, obSrcRect, playerSrcRect;Rect    numberSrcRect, idleSrcRect, enemyWalkSrcRect, enemyFlySrcRect;Rect    obeliskRects[4], playerRects[11], numbersSrc[11], numbersDest[11];Rect    flameSrcRect, flameDestRects[2], flameRects[4], eggSrcRect;Rect    platformSrcRect, platformCopyRects[9], helpSrcRect, eyeSrcRect, bannerSrcRect;Rect    helpSrc, helpDest, handSrcRect, handRects[2], eyeRects[4];Point    leftLightningPts[kNumLightningPts], rightLightningPts[kNumLightningPts];CGrafPtr  origBackSrcMap, backSrcMap, workSrcMap, obeliskSrcMap, playerSrcMap, eyeSrcMap;CGrafPtr  numberSrcMap, idleSrcMap, enemyWalkSrcMap, enemyFlySrcMap;CGrafPtr  flameSrcMap, eggSrcMap, bannerSrcMap, platformSrcMap, helpSrcMap, handSrcMap;GrafPtr    playerMaskMap, enemyWalkMaskMap, enemyFlyMaskMap, eggMaskMap;GrafPtr    handMaskMap, eyeMaskMap, obeliskMaskMap;Boolean    whichList, helpOpen, scoresOpen;short numPixelShatter;pixelShatter thePixelShatter[kMaxPixelShatter];extern  handInfo  theHand;extern  eyeInfo    theEye;extern  prefsInfo  thePrefs;extern  playerType  thePlayer;extern  enemyType  theEnemies[];extern  Rect    enemyRects[24];extern  long    theScore, wasTensOfThousands;extern  short    livesLeft, levelOn, numEnemies;extern  Boolean    evenFrame;extern short lightningCount;void HandleLightning();extern short oldFrameRate;// in DR3 of DrawSprocket the underlay buffer will give the game the// ability to not worry about keeping track fo the update rects.  As it// is right now, if you use update rects you have to save the update// rectangle for each frame, and the number of frames will vary depending// on the state of triple buffering and page flipping.// // Once the Underlay buffers are operational, enabiling this #define// will allow DS to optimize the screen updates instead of doing// a full screen copy (as happens in Glypha)//#define USE_INVALID_RECTS 1//==============================================================  Functions//--------------------------------------------------------------  DrawPlatforms// This function draws all the platforms on the background pixmap and the\xC9// work pixmap.  It needs to know merely how many of them to draw.void DrawPlatforms (short howMany){  if (howMany &gt; 3)      // If there are more than 3 platforms\xC9  {              // Draw a platform to background pixmap.    CopyBits(&amp;((GrafPtr)platformSrcMap)-&gt;portBits,         &amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;platformCopyRects[2], &amp;platformCopyRects[7], srcCopy, 0L);                    // Draw a platform to work pixmap.    CopyBits(&amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;platformCopyRects[7], &amp;platformCopyRects[7], srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;platformCopyRects[7] );    #endif                // Add rectangle to update list to be drawn to screen.                // Ditto for a second platform.    CopyBits(&amp;((GrafPtr)platformSrcMap)-&gt;portBits,         &amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;platformCopyRects[4], &amp;platformCopyRects[8], srcCopy, 0L);    CopyBits(&amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;platformCopyRects[8], &amp;platformCopyRects[8], srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;platformCopyRects[8] );    #endif  }  else            // If there are 3 or less platforms\xC9  {    CopyBits(&amp;((GrafPtr)platformSrcMap)-&gt;portBits,         &amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;platformCopyRects[3], &amp;platformCopyRects[7], srcCopy, 0L);    CopyBits(&amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;platformCopyRects[7], &amp;platformCopyRects[7], srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;platformCopyRects[7] );    #endif        CopyBits(&amp;((GrafPtr)platformSrcMap)-&gt;portBits,         &amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;platformCopyRects[5], &amp;platformCopyRects[8], srcCopy, 0L);    CopyBits(&amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;platformCopyRects[8], &amp;platformCopyRects[8], srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;platformCopyRects[8] );    #endif  }    if (howMany &gt; 5)    // If there are more than 5 platforms\xC9  {    CopyBits(&amp;((GrafPtr)platformSrcMap)-&gt;portBits,         &amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;platformCopyRects[0], &amp;platformCopyRects[6], srcCopy, 0L);    CopyBits(&amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;platformCopyRects[6], &amp;platformCopyRects[6], srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;platformCopyRects[6] );    #endif  }  else          // If there are 5 or less platforms\xC9  {    CopyBits(&amp;((GrafPtr)platformSrcMap)-&gt;portBits,         &amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;platformCopyRects[1], &amp;platformCopyRects[6], srcCopy, 0L);    CopyBits(&amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;platformCopyRects[6], &amp;platformCopyRects[6], srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;platformCopyRects[6] );    #endif  }}//--------------------------------------------------------------  ScrollHelp// This function scrolls the help screen.  You pass it a number of pixels\xC9// to scroll up or down (positive or negative number).void ScrollHelp (short scrollDown){  // don't do any drawing, drawing is done by the idle animation automatically    OffsetRect(&amp;helpSrc, 0, scrollDown);    // Move the source rectangle.    if (helpSrc.bottom &gt; 398)          // Check to see we don't go too far.  {    helpSrc.bottom = 398;    helpSrc.top = helpSrc.bottom - 199;  }  else if (helpSrc.top &lt; 0)  {    helpSrc.top = 0;    helpSrc.bottom = helpSrc.top + 199;  }}//--------------------------------------------------------------  OpenHelp// Bring up the help screen.  This is a kind of &quot;wipe&quot; or &quot;barn door&quot; effect.void OpenHelp (void){  Rect    wallSrc, wallDest;  short    i;    SetRect(&amp;helpSrc, 0, 0, 231, 0);  // Initialize source and destination rects.  helpDest = helpSrc;  OffsetRect(&amp;helpDest, 204, 171);    SetRect(&amp;wallSrc, 0, 0, 231, 199);  OffsetRect(&amp;wallSrc, 204, 171);  wallDest = wallSrc;    for (i = 0; i &lt; 199; i ++)      // Loop through 1 pixel at a time.  {    DSpContext_GetBackBuffer( gTheContext, kDSpBufferKind_Normal, &amp;workSrcMap );    DumpBackToWorkMap();          // clear the screen    HandleLava();    HandlePixelShatter();    DrawTorches();    DrawBanner();    DrawLava();    DrawPixelShatter();    LogNextTick(1L);        // Speed governor.    helpSrc.bottom++;        // Grow help source rect.    helpDest.bottom++;        // Grow help dest as well.    wallSrc.bottom--;        // Shrink wall source.    wallDest.top++;          // Shrink wall dest.                        // So, as the help graphic grows, the wall graphic\xC9                    // shrinks.  Thus it is as though the wall is\xC9                    // lifting up to expose the help screen beneath.        CopyBits(  &amp;((GrafPtr)helpSrcMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;helpSrc, &amp;helpDest, srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;helpDest );    #endif    CopyBits(  &amp;((GrafPtr)backSrcMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;wallSrc, &amp;wallDest, srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;wallDest );    #endif                    // Copy slightly larger help screen.    DSpContext_SwapBuffers( gTheContext, NULL, NULL );  }  helpOpen = TRUE;          // When done, set flag to indicate help is open.}//--------------------------------------------------------------  CloseWall// Close the wall over whatever screen is up (help screen or high scores).// Since the wall just comes down over the opening - covering whatever was beneath,\xC9// it's simpler than the above function.void CloseWall (void){  DSpContext_GetBackBuffer( gTheContext, kDSpBufferKind_Normal, &amp;workSrcMap );  DumpBackToWorkMap();          // clear the screen  DSpContext_SwapBuffers( gTheContext, NULL, NULL );}//--------------------------------------------------------------  OpenHighScores// This function is practically identical to the OpenHelp().  The only real\xC9// difference is that we must first draw all the high scores offscreen before\xC9// lifting the wall to reveal them.void OpenHighScores (void){  RGBColor  theRGBColor, wasColor;  Rect    wallSrc, wallDest;  Rect    scoreSrc, scoreDest;  Str255    scoreStr;  short    i, scoreWide;    SetRect(&amp;scoreSrc, 0, 0, 231, 0);        // Initialize source and dest rects.  OffsetRect(&amp;scoreSrc, 204, 171);  scoreDest = scoreSrc;    SetRect(&amp;wallSrc, 0, 0, 231, 199);  OffsetRect(&amp;wallSrc, 204, 171);  wallDest = wallSrc;    SetPort((GrafPtr)workSrcMap);          // We'll draw scores to the work pixmap.  PaintRect(&amp;wallSrc);              // Paint it black.    GetForeColor(&amp;wasColor);            // Save the foreground color.    TextFont(kFontIDGeneva);            // Use Geneva 12 point Bold font.  TextSize(12);  TextFace(bold);    Index2Color(132, &amp;theRGBColor);          // Get the 132nd color in RGB form.  RGBForeColor(&amp;theRGBColor);            // Make this color the pen color.  MoveTo(scoreSrc.left + 36, scoreSrc.top + 20);  // Get pen in right position to draw.  DrawString(&quot;\pGlypha IV High Scores&quot;);      // Draw the title.    TextFont(kFontIDGeneva);            // Use Geneva 9 point Bold font.  TextSize(9);  TextFace(bold);    for (i = 0; i &lt; 10; i++)            // Walk through all 10 high scores.  {    Index2Color(133, &amp;theRGBColor);        // Use color 133 (in palette).    RGBForeColor(&amp;theRGBColor);    NumToString((long)i + 1L, scoreStr);    // Draw &quot;place&quot; (1, 2, 3, \xC9).    MoveTo(scoreSrc.left + 8, scoreSrc.top + 40 + (i * 16));    DrawString(scoreStr);        Index2Color(128, &amp;theRGBColor);        // Use color 128 (from palette).    RGBForeColor(&amp;theRGBColor);    MoveTo(scoreSrc.left + 32, scoreSrc.top + 40 + (i * 16));    DrawString(thePrefs.highNames[i]);      // Draw the high score name (Sue, \xC9).        Index2Color(164, &amp;theRGBColor);        // Use color 164 (from palette).    RGBForeColor(&amp;theRGBColor);    NumToString(thePrefs.highScores[i], scoreStr);    scoreWide = StringWidth(scoreStr);      // Right justify.    MoveTo(scoreSrc.left + 191 - scoreWide, scoreSrc.top + 40 + (i * 16));    DrawString(scoreStr);            // Draw the high score (12,000, \xC9).        Index2Color(134, &amp;theRGBColor);        // Use color 134 (from palette).    RGBForeColor(&amp;theRGBColor);    NumToString(thePrefs.highLevel[i], scoreStr);    scoreWide = StringWidth(scoreStr);      // Right justify.    MoveTo(scoreSrc.left + 223 - scoreWide, scoreSrc.top + 40 + (i * 16));    DrawString(scoreStr);            // Draw highest level (12, 10, \xC9).  }    RGBForeColor(&amp;wasColor);            // Restore foreground color.  for (i = 0; i &lt; 199; i ++)            // Now the standard scroll functions.  {    WaitForNextTick();        DSpContext_GetBackBuffer( gTheContext, kDSpBufferKind_Normal, &amp;workSrcMap );    DumpBackToWorkMap();          // clear the screen      LogNextTick(1L);        // Speed governor.    scoreSrc.bottom++;    scoreDest.bottom++;    wallSrc.bottom--;    wallDest.top++;                        // So, as the help graphic grows, the wall graphic\xC9                    // shrinks.  Thus it is as though the wall is\xC9                    // lifting up to expose the help screen beneath.        CopyBits(  &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;scoreSrc, &amp;scoreDest, srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;scoreDest );    #endif    CopyBits(  &amp;((GrafPtr)backSrcMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;wallSrc, &amp;wallDest, srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;wallDest );    #endif                    // Copy slightly larger help screen.    DSpContext_SwapBuffers( gTheContext, NULL, NULL );  }    scoresOpen = TRUE;                // Flag that the scores are up.}//--------------------------------------------------------------  UpdateLivesNumbers// During a game, this function is called to reflect the current number of lives.// This is &quot;lives remaining&quot;, so 1 is subtracted before displaying it to the screen.// The lives is &quot;wrapped around&quot; after 99.  So 112 lives will display as 12.  It's\xC9// a lot easier to handle numbers this way (it beats a recursive function that might\xC9// potentially draw across the entire screen.void UpdateLivesNumbers (void){  short    digit;    digit = (livesLeft - 1) / 10;    // Get the &quot;10's&quot; digit.  digit = digit % 10L;        // Keep it less than 10 (0 -&gt; 9).  if ((digit == 0) &amp;&amp; ((livesLeft - 1) &lt; 10))    digit = 10;            // Use a &quot;blank&quot; space if zero and less than 10.                    // Draw digit.  CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,       &amp;((GrafPtr)backSrcMap)-&gt;portBits,       &amp;numbersSrc[digit], &amp;numbersDest[0], srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;numbersDest[0] );  #endif  digit = (livesLeft - 1) % 10;    // Get 1's digit.                    // Draw digit.  CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,       &amp;((GrafPtr)backSrcMap)-&gt;portBits,       &amp;numbersSrc[digit], &amp;numbersDest[1], srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;numbersDest[1] );  #endif}//--------------------------------------------------------------  UpdateScoreNumbers// This function works just like the above function.  However, we allow the\xC9// score to go to 6 digits (999,999) before rolling over.  Note however, that\xC9// in both the case of the score, number of lives, etc., the game does in fact\xC9// keep track of the &quot;actual&quot; number.  It is just that only so many digits are\xC9// being displayed.void UpdateScoreNumbers (void){  long    digit;  digit = theScore / 100000L;    // Get &quot;hundreds of thousands&quot; digit  digit = digit % 10L;      // Clip off anything greater than 9.  if ((digit == 0) &amp;&amp; (theScore &lt; 1000000L))    digit = 10;          // Use blank space if zero.                  // Draw digit.  CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,       &amp;((GrafPtr)backSrcMap)-&gt;portBits,       &amp;numbersSrc[digit], &amp;numbersDest[2], srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;numbersDest[2] );  #endif  digit = theScore / 10000L;    // Get &quot;tens of thousands&quot; digit.  if (digit &gt; wasTensOfThousands)  // Check for &quot;extra life&quot; here.  {    livesLeft++;        // Increment number of lives.    UpdateLivesNumbers();    // Reflect new lives on screen.    wasTensOfThousands = digit;  // Note that life was given.  }  digit = digit % 10L;      // Clip off anything greater than 9.  if ((digit == 0) &amp;&amp; (theScore &lt; 100000L))    digit = 10;          // Use blank space if zero.                  // Draw digit.  CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,       &amp;((GrafPtr)backSrcMap)-&gt;portBits,       &amp;numbersSrc[digit], &amp;numbersDest[3], srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;numbersDest[3] );  #endif    digit = theScore / 1000L;    // Handle &quot;thousands&quot; digit.  digit = digit % 10L;  if ((digit == 0) &amp;&amp; (theScore &lt; 10000L))    digit = 10;  CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,       &amp;((GrafPtr)backSrcMap)-&gt;portBits,       &amp;numbersSrc[digit], &amp;numbersDest[4], srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;numbersDest[4] );  #endif  digit = theScore / 100L;    // Handle 100's digit.  digit = digit % 10L;  if ((digit == 0) &amp;&amp; (theScore &lt; 1000L))    digit = 10;  CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,       &amp;((GrafPtr)backSrcMap)-&gt;portBits,       &amp;numbersSrc[digit], &amp;numbersDest[5], srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;numbersDest[5] );  #endif  digit = theScore / 10L;      // Handle 10's digit.  digit = digit % 10L;  if ((digit == 0) &amp;&amp; (theScore &lt; 100L))    digit = 10;  CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,       &amp;((GrafPtr)backSrcMap)-&gt;portBits,       &amp;numbersSrc[digit], &amp;numbersDest[6], srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;numbersDest[6] );  #endif    digit = theScore % 10L;      // Handle 1's digit.  CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,       &amp;((GrafPtr)backSrcMap)-&gt;portBits,       &amp;numbersSrc[digit], &amp;numbersDest[7], srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;numbersDest[7] );  #endif}//--------------------------------------------------------------  UpdateLevelNumbers// Blah, blah, blah.  Just like the above functions but handles displaying the\xC9// level the player is on.  We allow 3 digits here (up to 999) before wrapping.void UpdateLevelNumbers (void){  short    digit;  short    workNumber;  //  workNumber = levelOn;  workNumber = oldFrameRate;      digit = (workNumber + 1) / 100;    // Do 100's digit.  digit = digit % 10L;  if ((digit == 0) &amp;&amp; ((workNumber + 1) &lt; 1000))    digit = 10;  CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,       &amp;((GrafPtr)backSrcMap)-&gt;portBits,       &amp;numbersSrc[digit], &amp;numbersDest[8], srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;numbersDest[3] );  #endif    digit = (workNumber + 1) / 10;      // Do 10's digit.  digit = digit % 10L;  if ((digit == 0) &amp;&amp; ((workNumber + 1) &lt; 100))    digit = 10;  CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,       &amp;((GrafPtr)backSrcMap)-&gt;portBits,       &amp;numbersSrc[digit], &amp;numbersDest[9], srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;numbersDest[9] );  #endif    digit = (workNumber + 1) % 10;      // Do 1's digit.  CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,       &amp;((GrafPtr)backSrcMap)-&gt;portBits,       &amp;numbersSrc[digit], &amp;numbersDest[10], srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;numbersDest[10] );  #endif}//--------------------------------------------------------------  GenerateLightning// This function takes a point (h and v) and then generates two lightning bolts\xC9// (one from the tip of each obelisk) to the point.  It does this by generating\xC9// a list of segments (as the lightning is broken up into segements).  The drawing\xC9// counterpart to this function will draw a line connecting these segements (a sort\xC9// of dot-to-dot).void GenerateLightning (short h, short v){  #define kLeftObeliskH    172  #define kLeftObeliskV    250  #define kRightObeliskH    468  #define kRightObeliskV    250  #define kWander        16    short    i, leftDeltaH, rightDeltaH, leftDeltaV, rightDeltaV, range;    leftDeltaH = h - kLeftObeliskH;        // Determine the h and v distances between\xC9  rightDeltaH = h - kRightObeliskH;      // obelisks and the target point.  leftDeltaV = v - kLeftObeliskV;  rightDeltaV = v - kRightObeliskV;    for (i = 0; i &lt; kNumLightningPts; i++)    // Calculate an even spread of points between\xC9  {                      // obelisk tips and the target point.    leftLightningPts[i].h = (leftDeltaH * i) / (kNumLightningPts - 1) + kLeftObeliskH;    leftLightningPts[i].v = (leftDeltaV * i) / (kNumLightningPts - 1) + kLeftObeliskV;    rightLightningPts[i].h = (rightDeltaH * i) / (kNumLightningPts - 1) + kRightObeliskH;    rightLightningPts[i].v = (rightDeltaV * i) / (kNumLightningPts - 1) + kRightObeliskV;  }    range = kWander * 2 + 1;          // Randomly scatter the points vertically\xC9  for (i = 1; i &lt; kNumLightningPts - 1; i++)  // but NOT the 1st or last points.  {    leftLightningPts[i].v += RandomInt(range) - kWander;    rightLightningPts[i].v += RandomInt(range) - kWander;  }}void DrawObelisks (void){    if ((lightningCount &gt; 0) &amp;&amp; evenFrame)    // Draw them &quot;inverted&quot;  {    CopyMask(  &amp;((GrafPtr)obeliskSrcMap)-&gt;portBits,    // src          &amp;((GrafPtr)obeliskMaskMap)-&gt;portBits,    // mask          &amp;((GrafPtr) workSrcMap)-&gt;portBits,       // dst          &amp;obeliskRects[0],               // src rect          &amp;obeliskRects[0],               // mask rect          &amp;obeliskRects[2]);              // dst rect    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;obeliskRects[2] );    #endif    CopyMask(  &amp;((GrafPtr)obeliskSrcMap)-&gt;portBits,    // src          &amp;((GrafPtr)obeliskMaskMap)-&gt;portBits,    // mask          &amp;((GrafPtr) workSrcMap)-&gt;portBits,       // dst          &amp;obeliskRects[1],               // src rect          &amp;obeliskRects[1],               // mask rect          &amp;obeliskRects[3]);              // dst rect    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;obeliskRects[3] );    #endif  }  else  {    CopyMask(  &amp;((GrafPtr)backSrcMap)-&gt;portBits,    // src          &amp;((GrafPtr)obeliskMaskMap)-&gt;portBits,    // mask          &amp;((GrafPtr) workSrcMap)-&gt;portBits,       // dst          &amp;obeliskRects[2],               // src rect          &amp;obeliskRects[0],               // mask rect          &amp;obeliskRects[2]);               // dst rect    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;obeliskRects[2] );    #endif    CopyMask(  &amp;((GrafPtr)backSrcMap)-&gt;portBits,    // src          &amp;((GrafPtr)obeliskMaskMap)-&gt;portBits,    // mask          &amp;((GrafPtr) workSrcMap)-&gt;portBits,       // dst          &amp;obeliskRects[3],               // src rect          &amp;obeliskRects[1],               // mask rect          &amp;obeliskRects[3]);              // dst rect    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;obeliskRects[3] );    #endif  }}void StrikeLightningWork (void){  short    i;  GrafPtr    oldPort;  RGBColor   yellow = {65535, 65535, 0};  Rect    theRect;    GetPort(&amp;oldPort);  SetPort((GrafPtr)workSrcMap);  PenSize(1, 2);                // Use a tall pen.  RGBForeColor(&amp;yellow);                        // Draw lightning bolts with inverted pen.  MoveTo(leftLightningPts[0].h, leftLightningPts[0].v);  for (i = 0; i &lt; kNumLightningPts - 1; i++)  // Draw left lightning bolt.  {    MoveTo(leftLightningPts[i].h, leftLightningPts[i].v);    LineTo(leftLightningPts[i + 1].h - 1, leftLightningPts[i + 1].v);  }  SetRect( &amp;theRect, leftLightningPts[0].h, leftLightningPts[0].v,     leftLightningPts[kNumLightningPts].h - 1, leftLightningPts[kNumLightningPts].v );  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;theRect );  #endif    MoveTo(rightLightningPts[0].h, rightLightningPts[0].v);  for (i = 0; i &lt; kNumLightningPts - 1; i++)  // Draw right lightning bolt.  {    MoveTo(rightLightningPts[i].h, rightLightningPts[i].v);    LineTo(rightLightningPts[i + 1].h - 1, rightLightningPts[i + 1].v);  }  SetRect( &amp;theRect, rightLightningPts[0].h, rightLightningPts[0].v,     rightLightningPts[kNumLightningPts].h - 1, rightLightningPts[kNumLightningPts].v );  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;theRect );  #endif    PenNormal();                // Return pen to normal.    SetPort(oldPort);}//--------------------------------------------------------------  DumpBackToWorkMap// Simple handy function that copies the entire background pixmap to the\xC9// work pixmap.//--//--------------------------------------------------------------  DumpBackToWorkMap// Simple handy function that copies the entire background pixmap to the\xC9// work pixmap.static inline void ClassicDumpBackToWork(void){  // this is doing a full clean of the work map from the source map, don't inval  // this rect.  //  // * this will go away once DrawSprocket Underlays are used (in DR3 release)  CopyBits(&amp;((GrafPtr)backSrcMap)-&gt;portBits,       &amp;((GrafPtr)workSrcMap)-&gt;portBits,       &amp;backSrcRect, &amp;backSrcRect, srcCopy, 0L);}// faster on some machines, on others it is slow because of dcbzstatic inline void FastDumpBackToWorkMap (void){  CGrafPtr srcGrafPtr = backSrcMap;  PixMap *srcMap = *(srcGrafPtr-&gt;portPixMap);  char *src = srcMap-&gt;baseAddr;  UInt32 srcBump = srcMap-&gt;rowBytes &amp; 0x3fff;    CGrafPtr dstGrafPtr = workSrcMap;  PixMap *dstMap = *(dstGrafPtr-&gt;portPixMap);  char *dst = dstMap-&gt;baseAddr;  UInt32 dstBump = dstMap-&gt;rowBytes &amp; 0x3fff;    int count;    for(count = 0; count &lt; 480; count++)  {    BlockMoveData(src,dst,640);        src += srcBump;    dst += dstBump;  }}void DumpBackToWorkMap(void){    ClassicDumpBackToWork();}//--------------------------------------------------------------  QuickUnionRect// The Mac Toolbox gives you a UnionRect() function, but, like any Toolbox\xC9// routine, if we can do it faster, we ought to.  Well, the function below\xC9// is quick because (among other reasons), it assumes that the two rects\xC9// being compared are the same size.//// Notes from Cary Farrier: Sorry John I don't agree with that advice.  You// may be able to do something faster, but the speed gain you achieve may not// be worth the effort required to develop, test, and debug the code.  John's// advice is good for some scenarios, but it is the exception and not the// rule.void QuickUnionRect (Rect *rect1, Rect *rect2, Rect *whole){  if (rect1-&gt;left &lt; rect2-&gt;left)    // See if we're to use rect1's left.  {    whole-&gt;left = rect1-&gt;left;    whole-&gt;right = rect2-&gt;right;  }  else                // Use rect2's left.  {    whole-&gt;left = rect2-&gt;left;    whole-&gt;right = rect1-&gt;right;  }    if (rect1-&gt;top &lt; rect2-&gt;top)    // See if we're to use rect1's top.  {    whole-&gt;top = rect1-&gt;top;    whole-&gt;bottom = rect2-&gt;bottom;  }  else                // Use rect2's top.  {    whole-&gt;top = rect2-&gt;top;    whole-&gt;bottom = rect1-&gt;bottom;  }}//--------------------------------------------------------------  CheckPlayerWrapAround// This handles drawing wrap-around.  It is such that, when a player walks partly\xC9// off the right edge of the screen, you see the player peeking through on the left\xC9// side of the screen.  Since we can't (shouldn't) assume that the physical screen\xC9// memory wraps around, we'll draw the right player clipped against the right edge\xC9// of the screen and draw a SECOND PLAYER on the left edge (clipped to the left).void CheckPlayerWrapAround (void){  Rect    wrapRect, wasWrapRect, src;    if (thePlayer.dest.right &gt; 640)    // Player off right edge of screen.  {    thePlayer.wrapping = TRUE;    // Set &quot;wrapping&quot; flag.    wrapRect = thePlayer.dest;    // Start out with copy of player bounds.    wrapRect.left -= 640;      // Offset it a screenwidth to left.    wrapRect.right -= 640;                    // Ditto with old location.    wasWrapRect = thePlayer.wasDest;    wasWrapRect.left -= 640;    wasWrapRect.right -= 640;        if (thePlayer.mode == kBones)  // Draw second bones.    {      src = playerRects[thePlayer.srcNum];      src.bottom = src.top + thePlayer.frame;      CopyMask(&amp;((GrafPtr)playerSrcMap)-&gt;portBits,           &amp;((GrafPtr)playerMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;src, &amp;src, &amp;wrapRect);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;wrapRect );      #endif    }    else              // Draw second player (not bones).    {      CopyMask(&amp;((GrafPtr)playerSrcMap)-&gt;portBits,           &amp;((GrafPtr)playerMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;playerRects[thePlayer.srcNum],           &amp;playerRects[thePlayer.srcNum],           &amp;wrapRect);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;wrapRect );      #endif    }    thePlayer.wrap = wrapRect;  }  else if (thePlayer.dest.left &lt; 0)  // Else if off the left edge\xC9  {    thePlayer.wrapping = TRUE;    // Set &quot;wrapping&quot; flag.    wrapRect = thePlayer.dest;    // Start out with copy of player bounds.    wrapRect.left += 640;      // Offset it a screenwidth to right.    wrapRect.right += 640;                    // Ditto with old location.    wasWrapRect = thePlayer.wasDest;    wasWrapRect.left += 640;    wasWrapRect.right += 640;        if (thePlayer.mode == kBones)  // Draw second bones.    {      src = playerRects[thePlayer.srcNum];      src.bottom = src.top + thePlayer.frame;      CopyMask(&amp;((GrafPtr)playerSrcMap)-&gt;portBits,           &amp;((GrafPtr)playerMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;src, &amp;src, &amp;wrapRect);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;wrapRect );      #endif    }    else              // Draw second player (not bones).    {      CopyMask(&amp;((GrafPtr)playerSrcMap)-&gt;portBits,           &amp;((GrafPtr)playerMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;playerRects[thePlayer.srcNum],           &amp;playerRects[thePlayer.srcNum],           &amp;wrapRect);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;wrapRect );      #endif    }    thePlayer.wrap = wrapRect;  }  else    thePlayer.wrapping = FALSE;    // Otherwise, we're not wrapping.}//--------------------------------------------------------------  DrawTorches// This handles drawing the two torch's flames.  It chooses randomly from\xC9// 4 torch graphics and draws right over the old torches.void DrawTorches (void){  short    who;    who = RandomInt(4);  if (evenFrame)    // Only draw 1 torch - left on even frames\xC9  {    CopyBits(&amp;((GrafPtr)flameSrcMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;flameRects[who], &amp;flameDestRects[0], srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;flameDestRects[0] );    #endif  }  else        // and draw the right torch on odd frames.  {          // We do this even/odd thing for speed.  Why draw both?    CopyBits(&amp;((GrafPtr)flameSrcMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;flameRects[who], &amp;flameDestRects[1], srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;flameDestRects[1] );    #endif  }}//--------------------------------------------------------------  DrawHand// This function takes care of drawing the hand offscreen.  There are only\xC9// two (well really three) choices - hand open, hand clutching (or no hand\xC9// in which case both options are skipped).void DrawHand (void){  theHand.dest.right = theHand.dest.left + 56;  theHand.dest.bottom = theHand.dest.top + 57;  if (theHand.mode == kOutGrabeth)    // Fingers open.  {    CopyMask(&amp;((GrafPtr)handSrcMap)-&gt;portBits,         &amp;((GrafPtr)handMaskMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;handRects[0],         &amp;handRects[0],         &amp;theHand.dest);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;theHand.dest );    #endif  }  else if (theHand.mode == kClutching)  // Fingers clenched.  {    CopyMask(&amp;((GrafPtr)handSrcMap)-&gt;portBits,         &amp;((GrafPtr)handMaskMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;handRects[1],         &amp;handRects[1],         &amp;theHand.dest);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;theHand.dest );    #endif  }}//--------------------------------------------------------------  DrawEye// This function draws the eye (if it's floating about - stalking).void DrawEye (void){  if (theEye.mode == kStalking)  {    CopyMask(&amp;((GrafPtr)eyeSrcMap)-&gt;portBits,         &amp;((GrafPtr)eyeMaskMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;eyeRects[theEye.srcNum],         &amp;eyeRects[theEye.srcNum],         &amp;theEye.dest);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;theEye.dest );    #endif  }}//--------------------------------------------------------------  DrawPlayer// Although called &quot;DrawPlayer()&quot;, this function actually does its drawing\xC9// offscreen.  It is the above routine that will finally copy our offscreen\xC9// work to the main screen.  Anyway, the below function draws the player\xC9// offscreen in the correct position and state.void DrawPlayer (void){  Rect    src;    if ((evenFrame) &amp;&amp; (thePlayer.mode == kIdle))  {      // On even frames, we'll draw the &quot;flashed&quot; graphic of the player.        // If you've played Glypha, you notice that the player begins a\xC9        // game flashing alternately between bones and a normal player.    CopyMask(&amp;((GrafPtr)idleSrcMap)-&gt;portBits,         &amp;((GrafPtr)playerMaskMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;idleSrcRect,         &amp;playerRects[thePlayer.srcNum],         &amp;thePlayer.dest);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;thePlayer.dest );    #endif  }  else if (thePlayer.mode == kBones)  {      // If the player is dead and a pile of bones\xC9    src = playerRects[thePlayer.srcNum];    src.bottom = src.top + thePlayer.frame;    CopyMask(&amp;((GrafPtr)playerSrcMap)-&gt;portBits,         &amp;((GrafPtr)playerMaskMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;src, &amp;src, &amp;thePlayer.dest);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;thePlayer.dest );    #endif  }  else    // Else, if the player is neither idle nor dead\xC9  {    CopyMask(&amp;((GrafPtr)playerSrcMap)-&gt;portBits,         &amp;((GrafPtr)playerMaskMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;playerRects[thePlayer.srcNum],         &amp;playerRects[thePlayer.srcNum],         &amp;thePlayer.dest);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;thePlayer.dest );    #endif  }        // Now we add the player to the update rect list.        // Record old locations.  thePlayer.wasH = thePlayer.h;  thePlayer.wasV = thePlayer.v;        // Record old bounds rect.  thePlayer.wasDest = thePlayer.dest;}//--------------------------------------------------------------  CheckEnemyWrapAround// This function both determines whether or not an enemy (sphinx) is wrapping around.// If it is, the &quot;second&quot; wrapped-around enemy is drawn.void CheckEnemyWrapAround (short who){  Rect    wrapRect, wasWrapRect, src;    if (theEnemies[who].dest.right &gt; 640)  // Is enemy off the right edge of screen?  {    wrapRect = theEnemies[who].dest;  // Copy bounds.    wrapRect.left -= 640;        // Offset bounds copy to left (one screen width).    wrapRect.right -= 640;                      // Ditto with old bounds.    wasWrapRect = theEnemies[who].wasDest;    wasWrapRect.left -= 640;    wasWrapRect.right -= 640;                      // Handle &quot;egg&quot; enemies.    if ((theEnemies[who].mode == kFalling) || (theEnemies[who].mode == kEggTimer))    {                  // Handle &quot;egg&quot; enemy sinking into platform.      if ((theEnemies[who].mode == kEggTimer) &amp;&amp; (theEnemies[who].frame &lt; 24))      {        src = eggSrcRect;        src.bottom = src.top + theEnemies[who].frame;      }      else        src = eggSrcRect;      CopyMask(&amp;((GrafPtr)eggSrcMap)-&gt;portBits,           &amp;((GrafPtr)eggMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;src, &amp;src, &amp;wrapRect);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;wrapRect );      #endif    }    else                // Otherwise, if enemy not an egg\xC9    {      CopyMask(&amp;((GrafPtr)enemyFlySrcMap)-&gt;portBits,           &amp;((GrafPtr)enemyFlyMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;enemyRects[theEnemies[who].srcNum],           &amp;enemyRects[theEnemies[who].srcNum],           &amp;wrapRect);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;wrapRect );      #endif    }  }  else if (theEnemies[who].dest.left &lt; 0)  // Check to see if enemy off left edge instead.  {    wrapRect = theEnemies[who].dest;  // Make a copy of enemy bounds.    wrapRect.left += 640;        // Offset it right one screens width.    wrapRect.right += 640;                      // Ditto with old bounds.    wasWrapRect = theEnemies[who].wasDest;    wasWrapRect.left += 640;    wasWrapRect.right += 640;    if ((theEnemies[who].mode == kFalling) || (theEnemies[who].mode == kEggTimer))    {                  // Blah, blah, blah.  This is just like the above.      if ((theEnemies[who].mode == kEggTimer) &amp;&amp; (theEnemies[who].frame &lt; 24))      {        src = eggSrcRect;        src.bottom = src.top + theEnemies[who].frame;      }      else        src = eggSrcRect;      CopyMask(&amp;((GrafPtr)eggSrcMap)-&gt;portBits,           &amp;((GrafPtr)eggMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;src, &amp;src, &amp;wrapRect);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;wrapRect );      #endif    }    else    {      CopyMask(&amp;((GrafPtr)enemyFlySrcMap)-&gt;portBits,           &amp;((GrafPtr)enemyFlyMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;enemyRects[theEnemies[who].srcNum],           &amp;enemyRects[theEnemies[who].srcNum],           &amp;wrapRect);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;wrapRect );      #endif    }  }}//--------------------------------------------------------------  DrawEnemies// This function draws all the sphinx enemies (or eggs if they're in that state).// It doesn't handle wrap-around (the above function does) but it does call it.void DrawEnemies (void){  Rect    src;  short    i;    for (i = 0; i &lt; numEnemies; i++)  // Go through all enemies.  {    switch (theEnemies[i].mode)    // Handle the different modes as seperate cases.    {      case kSpawning:        // Spawning enemies are &quot;growing&quot; out of the platform.      src = enemyRects[theEnemies[i].srcNum];      src.bottom = src.top + theEnemies[i].frame;      CopyMask(&amp;((GrafPtr)enemyWalkSrcMap)-&gt;portBits,           &amp;((GrafPtr)enemyWalkMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;src, &amp;src, &amp;theEnemies[i].dest);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;theEnemies[i].dest );      #endif                              // Don't need to check wrap-around, when enemies\xC9                    // spawn, they're never on the edge of screen.      theEnemies[i].wasDest = theEnemies[i].dest;      theEnemies[i].wasH = theEnemies[i].h;      theEnemies[i].wasV = theEnemies[i].v;      break;            case kFlying:        // Flying enemies are air borne (gee).      CopyMask(&amp;((GrafPtr)enemyFlySrcMap)-&gt;portBits,           &amp;((GrafPtr)enemyFlyMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;enemyRects[theEnemies[i].srcNum], &amp;enemyRects[theEnemies[i].srcNum],           &amp;theEnemies[i].dest);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;theEnemies[i].dest );      #endif                CheckEnemyWrapAround(i);  // I like the word &quot;air bourne&quot;.      theEnemies[i].wasDest = theEnemies[i].dest;      theEnemies[i].wasH = theEnemies[i].h;      theEnemies[i].wasV = theEnemies[i].v;      break;            case kWalking:        // Walking enemies are walking.  Enemies.      CopyMask(&amp;((GrafPtr)enemyWalkSrcMap)-&gt;portBits,           &amp;((GrafPtr)enemyWalkMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;enemyRects[theEnemies[i].srcNum], &amp;enemyRects[theEnemies[i].srcNum],           &amp;theEnemies[i].dest);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;theEnemies[i].dest );      #endif                    // Don't need to check wrap-around, enemies walk\xC9                    // only briefly, and never off edge of screen.      theEnemies[i].wasDest = theEnemies[i].dest;      theEnemies[i].wasH = theEnemies[i].h;      theEnemies[i].wasV = theEnemies[i].v;      break;            case kFalling:        // Falling enemies are in fact eggs!      CopyMask(&amp;((GrafPtr)eggSrcMap)-&gt;portBits,           &amp;((GrafPtr)eggMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;eggSrcRect, &amp;eggSrcRect, &amp;theEnemies[i].dest);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;theEnemies[i].dest );      #endif                CheckEnemyWrapAround(i);  // Check for wrap around.      theEnemies[i].wasDest = theEnemies[i].dest;      theEnemies[i].wasH = theEnemies[i].h;      theEnemies[i].wasV = theEnemies[i].v;      break;            case kEggTimer:        // These are idle, perhaps hatching, eggs.      if (theEnemies[i].frame &lt; 24)      {              // Below countdown = 24, the egss are sinking\xC9        src = eggSrcRect;    // into the platform (hatch time!).        src.bottom = src.top + theEnemies[i].frame;      }      else        src = eggSrcRect;      CopyMask(&amp;((GrafPtr)eggSrcMap)-&gt;portBits,           &amp;((GrafPtr)eggMaskMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;src, &amp;src, &amp;theEnemies[i].dest);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;theEnemies[i].dest );      #endif                CheckEnemyWrapAround(i);  // Check for wrap around.      theEnemies[i].wasDest = theEnemies[i].dest;      theEnemies[i].wasH = theEnemies[i].h;      theEnemies[i].wasV = theEnemies[i].v;      break;    }  }}//------------- DrawBannervoid DrawBanner (void){  Rect destRect;  Rect srcRect;  long start = (TickCount() / 2) % 1280;  long seg1Len;  long seg2Len;    if (start &lt;= 640)   {    seg1Len = 640;    seg2Len = 0;  }  else  {    seg1Len = 1280 - start;    seg2Len = 640 - seg1Len;  }    SetRect(&amp;destRect,      0,    // left      460,  // top      seg1Len,  // right      480);  // bottom          SetRect(&amp;srcRect,      start,      0,      start + seg1Len,      20);              CopyBits(  &amp;((GrafPtr)bannerSrcMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;srcRect, &amp;destRect, srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;destRect );  #endif          if (seg2Len &gt; 0)  {    destRect.left = seg1Len;    destRect.right = 640;    srcRect.left = 0;    srcRect.right = seg2Len;        CopyBits(  &amp;((GrafPtr)bannerSrcMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;srcRect, &amp;destRect, srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;destRect );  #endif  }}//--------------------------------------------------------------  DrawPixelShattervoid DrawPixelShatter (void){  int i;  CGrafPtr theGrafPtr = workSrcMap;  PixMap *theMap = *(theGrafPtr-&gt;portPixMap);  short h,v;  short rowBytes = theMap-&gt;rowBytes &amp; 0x3fff;  short minH = 1000, minV = 1000, maxH = 0, maxV = 0;  Rect theRect;    for(i = 0; i &lt; numPixelShatter; i++)  {    char *addr = theMap-&gt;baseAddr;    int offset = 0;            h = thePixelShatter[i].h;    v = thePixelShatter[i].v;    if( h &lt; minH )      minH = h;    if( h &gt; maxH )      maxH = h;    if( v &lt; minV )      minV = v;    if( v &gt; maxV )      maxV = v;          h &gt;&gt;= 4;    v &gt;&gt;= 4;        offset = rowBytes * v;    offset += h;        addr += offset;        *addr = thePixelShatter[i].color;  }    SetRect( &amp;theRect, minH, minV, maxH, maxV );  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;theRect );  #endif  }//--------------------------------------------------------------  DrawLavavoid DrawLava(void);#if 0void DrawLava(void){  short where = RandomInt(640);  short velocity = -(RandomInt(15) + 15);  StartPixelShatter(  where, 460, 0, velocity, kShatterLavaBubble);}#endifvoid DrawScoreFloaters(void);void DrawScoreFloaters(void){#if 0  int i,j,count;  Rect r;  CGrafPtr theGrafPtr = workSrcMap;  PixMap *theMap = *(theGrafPtr-&gt;portPixMap);  short rowBytes = theMap-&gt;rowBytes &amp; 0x3fff;  char *addr = theMap-&gt;baseAddr;    for(count = 0; count &lt; numScoreFloater; count++)  {    r.top = theScoreFloater[count].location.v;    r.left = theScoreFloater[count].location.h;    r.bottom = theScoreFloater[count].location.v + 20;    r.right = theScoreFloater[count].location.h + 60;      addr = theMap-&gt;baseAddr + (r.top * rowBytes);        for(j = r.top; j &lt; r.bottom; j++)    {      for(i = r.left; i &lt; r.right; i++)      {        addr[i] = 0;      }            addr += rowBytes;    }  }#else  int count;  Rect baseRect = {0,0,8,11};      for(count = 0; count &lt; numScoreFloater; count++)  {    short    digit;    short    workNumber;    Rect r = baseRect;            r.top += theScoreFloater[count].location.v;    r.bottom += theScoreFloater[count].location.v;    r.left += theScoreFloater[count].location.h;    r.right += theScoreFloater[count].location.h;    workNumber = theScoreFloater[count].score;          digit = (workNumber + 1) / 1000;    // Do 1000's digit.    digit = digit % 10L;    if (digit != 0)    {      CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;numbersSrc[digit], &amp;r, srcCopy, 0L);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;r );      #endif    }        r.left += 11;    r.right += 11;    digit = (workNumber + 1) / 100;    // Do 100's digit.    digit = digit % 10L;    if ((digit != 0) || (workNumber &gt;= 1000))    {      CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;numbersSrc[digit], &amp;r, srcCopy, 0L);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;r );      #endif    }    r.left += 11;    r.right += 11;            digit = (workNumber + 1) / 10;      // Do 10's digit.    digit = digit % 10L;    if ((digit != 0) || (workNumber &gt;= 100))    {      CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,           &amp;((GrafPtr)workSrcMap)-&gt;portBits,           &amp;numbersSrc[digit], &amp;r, srcCopy, 0L);      #ifdef USE_INVALID_RECTS      DSpContext_InvalBackBufferRect( gTheContext, &amp;r );      #endif    }        r.left += 11;    r.right += 11;    digit = (workNumber) % 10;      // Do 1's digit.    CopyBits(&amp;((GrafPtr)numberSrcMap)-&gt;portBits,         &amp;((GrafPtr)workSrcMap)-&gt;portBits,         &amp;numbersSrc[digit], &amp;r, srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;r );    #endif  }#endif}//--------------------------------------------------------------  DrawFrame// This function is the &quot;master&quot; drawing function that calls all the above\xC9// routines.  It is called once per frame.void DrawFrame (void){  Boolean bannerInFront = false;    {    KeyMap theKeys;    GetKeys(theKeys);      if ((theKeys[1] &amp; 0x004))    {      bannerInFront = true;    }  }  if (!bannerInFront)  {    DrawBanner();  }  DrawTorches();        // Gee, draws the torches?    DrawScoreFloaters();    DrawHand();          // Draws the hand?  DrawEye();          // A clue to easing your documentation demands\xC9  DrawPlayer();        // is to use &quot;smart&quot; names for your functions.  CheckPlayerWrapAround();  // Check for player wrap-around.  DrawEnemies();        // Handle all sphinx-type enemy drawing.  DrawObelisks();      // draw the obelisks  DrawPixelShatter();      // draw exploding pixels    DrawLava();          // add sparkling lava  if (bannerInFront)  {    DrawBanner();  }  }//--------------------------------------------------------------  GameQuitGraphicsvoid GameQuitGraphics(void){  short h,v;    for(v = 0; v &lt; 480; v += 24)  {    for(h = 0; h &lt; 640; h += 32)    {        StartPixelShatter(h, v, 0, 0, kShatterLightningDust);    }  }  CopyBits(  &amp;((GrafPtr)origBackSrcMap)-&gt;portBits,         &amp;((GrafPtr)backSrcMap)-&gt;portBits,         &amp;backSrcRect, &amp;backSrcRect, srcCopy, 0L);  #ifdef USE_INVALID_RECTS  DSpContext_InvalBackBufferRect( gTheContext, &amp;backSrcRect );  #endif}//--------------------------------------------------------------  GameIdleAnimationvoid GameIdleAnimation(void){  // do our idle animation  DSpContext_GetBackBuffer( gTheContext, kDSpBufferKind_Normal, &amp;workSrcMap );  DumpBackToWorkMap();          // clear the screen  DrawBanner();  DrawTorches();  HandlePixelShatter();  HandleLava();  DrawLava();    if (helpOpen)  {    CopyBits(&amp;((GrafPtr)helpSrcMap)-&gt;portBits,       &amp;((GrafPtr)workSrcMap)-&gt;portBits,       &amp;helpSrc, &amp;helpDest, srcCopy, 0L);    #ifdef USE_INVALID_RECTS    DSpContext_InvalBackBufferRect( gTheContext, &amp;helpDest );    #endif  }    DrawPixelShatter();  HandleLightning();  DSpContext_SwapBuffers( gTheContext, NULL, NULL );  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/GlyphaIVOld/listing3.html%3Fid%3DDTS10000053-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/GlyphaIVOld/listing3.html%3Fid%3DDTS10000053-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/GlyphaIVOld/listing3.html%3Fid%3DDTS10000053-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>