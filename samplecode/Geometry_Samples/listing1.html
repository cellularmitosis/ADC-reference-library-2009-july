<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Geometry Samples - /Txtr_Geometry.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Geometry Samples</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Geometry Samples</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Txtr_Geometry.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Txtr_Geometry.c</option>
<option value="listing2.html">/Txtr_Geometry.h</option>
<option value="listing3.html">/Txtr_Math.h</option></select>
				</p>
				</form>
				<p><strong><a href="Geometry_Samples.zip">Download Sample</a></strong> (&#147;Geometry_Samples.zip&#148;, 6.3K)<BR>
<strong><a href="Geometry_Samples.dmg">Download Sample</a></strong> (&#147;Geometry_Samples.dmg&#148;, 65.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/* *  Txtr_Geometry.c * *  This is a simple library illustrating trigrid and box geometries. The trigrids *  represented are Square, Torus, Wavey Torus, Splash, Sphere, Cone, Pipe, Steps, *  and Spring. * *  NewLibraryTriGrid returns a trigrid geometry when kGeometryLibraryRange_Simple *  is added to the trigrid number (0 to 8) or a trigrid with shading uv attributes *  when kGeometryLibraryRange_UVGeoAttributes or kGeometryLibraryRange_UVFaceAttributes *  is added to the trigrid number. * *  Note: The calculation of uv's may be flipping the texture. * * *  Robert Dierkes *  &copy; 1995 Apple Computer, Inc. * *   03/22/95  RDD    Created. *   09/20/95  RDD    Cleanup. *   11/13/95  RDD    Changed macro to DebugStr. *//*------------------*//*  Include Files  *//*------------------*/#include &lt;Memory.h&gt;#include &lt;math.h&gt;#include &quot;QD3D.h&quot;#include &quot;QD3DGeometry.h&quot;#include &quot;QD3DMath.h&quot;#include &quot;QD3DSet.h&quot;#include &quot;Txtr_Geometry.h&quot;#include &quot;Txtr_Math.h&quot;#include &quot;Txtr_Error.h&quot;/*----------------------*//*  Local Prototypes  *//*----------------------*/staticvoid AddVertexNormals(  unsigned long  geoNum,  TQ3TriGridData  *pTriData);unsigned long GetLibraryMaxSimpleBox(void){  return kGeometryLibrary_BoxMaxSimple;}unsigned long GetLibraryMaxSimpleTriGrid(void){  return kGeometryLibrary_TriGridMaxSimple;}TQ3GeometryObject NewLibraryBox(      unsigned long    num){  TQ3GeometryObject  geometryObject = NULL;  TQ3BoxData      boxData;  switch (num)  {  case kGeometryLibraryRange_Simple+0:  /* Box */    Q3Point3D_Set(&amp;boxData.origin,    -0.5,-0.5,-0.5);    Q3Vector3D_Set(&amp;boxData.orientation, 0.0, 1.0, 0.0);    Q3Vector3D_Set(&amp;boxData.majorAxis,   0.0, 0.0, 1.0);    Q3Vector3D_Set(&amp;boxData.minorAxis,   1.0, 0.0, 0.0);    boxData.boxAttributeSet  = NULL;    boxData.faceAttributeSet = NULL;    geometryObject = Q3Box_New(&amp;boxData);    break;  case kGeometryLibraryRange_Simple+1:  /* Skewed Box */    Q3Point3D_Set(&amp;boxData.origin,    -0.75,-0.5,-0.75);    Q3Vector3D_Set(&amp;boxData.orientation, 0.5,  1.0, 0.5);    Q3Vector3D_Set(&amp;boxData.majorAxis,   0.0,  0.0, 1.0);    Q3Vector3D_Set(&amp;boxData.minorAxis,   1.0,  0.0, 0.0);    boxData.boxAttributeSet  = NULL;    boxData.faceAttributeSet = NULL;    geometryObject = Q3Box_New(&amp;boxData);    break;  default:    DebugStr(&quot;\pWarning:  NewLibraryBox ; unknown box index&quot;);    return NULL;    break;  }  return geometryObject;}/* *  NewLibraryTriGrid * * There are two methods below for creating trigrid vertices. If the trigrid is: * *  1. planar (relatively) then the vvValue (an x-coordinate) increases from vvMin to vvMax. *  2. a cross section revolved about the Y axis then the vvValue (an angle) decreases from *    vvMax to vvMin in a counter-clockwise manner about the axis. This puts the correct *    side of the trigrid facing outward for texture uvs. * * In both cases, uuValue decreases from uuMax to uuMin from postive to negative Y. * *  TriGrid vertex index numbering * *     (i) *    8    9    10    11 *    4    5    6    7 *    0    1    2    3 * * *  UVs for an upright texture continuous across the trigrid * *     (U,V) *     (x,y) * *    ^ +    0.0, 1.0  0.33, 1.0  0.66, 1.0  1.0, 1.0 *    |    0.0, 0.5  0.33, 0.5  0.66, 0.5  1.0, 0.5 *    V -    0.0, 0.0  0.33, 0.0  0.66, 0.0  1.0, 0.0 * *           U --&gt; *           -   + * *  UVs for an upright repeated texture * *     (U,V) *     (x,y) * *    ^ +    0,2    1,2    2,2    3,2 *    |    0,1    1,1    2,1    3,1 *    V -    0,0    1,0    2,0    3,0 * *           U --&gt; *           -   + */TQ3GeometryObject NewLibraryTriGrid(      unsigned long    num){  TQ3GeometryObject  geometryObject = NULL;  TQ3TriGridData    data;  TQ3Vertex3D      *vertices;  unsigned long    i;  float        uuValue, vvValue,            uuMin, uuMax, uuStep,            vvMin, vvMax, vvStep,            radius;  TQ3Boolean      hasUVAttributes;  TQ3Param2D      param2D;  TQ3Boolean      addNormals;  hasUVAttributes = (TQ3Boolean) (mHasUVGeoAttributes(num)  ||  mHasUVFaceAttributes(num));  switch (num)  {    case kGeometryLibraryRange_Simple+0:    /* Flat 5x5 */    case kGeometryLibraryRange_UVGeoAttributes+0:    case kGeometryLibraryRange_UVFaceAttributes+0:    case kGeometryLibraryRange_Simple+3:    /* Splash */    case kGeometryLibraryRange_UVGeoAttributes+3:    case kGeometryLibraryRange_UVFaceAttributes+3:    case kGeometryLibraryRange_Simple+7:    /* Steps */    case kGeometryLibraryRange_UVGeoAttributes+7:    case kGeometryLibraryRange_UVFaceAttributes+7:    {      addNormals = kQ3False;      /* Setup min, max and step values trigrid vertex u &amp; v values */      switch (num)      {      /**       ** Flat 5x5       **/      case kGeometryLibraryRange_Simple+0:      case kGeometryLibraryRange_UVGeoAttributes+0:      case kGeometryLibraryRange_UVFaceAttributes+0:        /*         * uuValue is an x-coordinate         * vvValue is a  y-coordinate         */        uuMin = -0.5;        uuMax =  0.5;        uuStep = 0.25;        vvMin = -0.5;        vvMax =  0.5;        vvStep = 0.25;      break;      /**       ** Splash       **/      case kGeometryLibraryRange_Simple+3:      case kGeometryLibraryRange_UVGeoAttributes+3:      case kGeometryLibraryRange_UVFaceAttributes+3:        addNormals = kQ3True;        /*         * uuValue is an x-coordinate         * vvValue is a  y-coordinate         */        uuMin = -3.5;        uuMax =  3.5;        vvMin = -3.5;        vvMax =  3.5;        if (hasUVAttributes) {          uuStep = 0.35;          vvStep = 0.35;        } else {          uuStep = 0.25;          vvStep = 0.25;        }        break;      /**       ** Steps       **/      case kGeometryLibraryRange_Simple+7:      case kGeometryLibraryRange_UVGeoAttributes+7:      case kGeometryLibraryRange_UVFaceAttributes+7:        /*         * uuValue is an x-coordinate         * vvValue is a  y-coordinate         */        #define  kStepScale   0.2        uuMin = -4.5;        uuMax =  4.5;        uuStep = 0.5;        vvMin = -4.5;        vvMax =  4.5;        vvStep = 0.5;        break;      default:        DebugStr(&quot;\pWarning:  NewLibraryTriGrid ; unknown flat trigrid index&quot;);        return NULL;        break;      }      /* Setup TQ3TriGridData */      data.numRows    = (unsigned long) ((vvMax - vvMin) / vvStep) + 1;      data.numColumns    = (unsigned long) ((uuMax - uuMin) / uuStep) + 1;      data.facetAttributeSet  = NULL;      data.triGridAttributeSet= NULL;      data.vertices = (TQ3Vertex3D *) NewPtrClear (data.numRows * data.numColumns * sizeof(TQ3Vertex3D));      if (data.vertices == NULL)      {        ERROR_DEBUG_STR(&quot;Error:  NewLibraryTriGrid ; Out of memory for triGrid vertices, geometry library number&quot;);        return NULL;      }      /* Set trigrid vertices and shading UVs, if it hasUVAttributes */      vertices = data.vertices;      i = 0;      for (vvValue = vvMin; vvValue &lt;= vvMax; vvValue += vvStep)      {        for (uuValue = uuMin; uuValue &lt;= uuMax; uuValue += uuStep)        {          switch (num)          {          /* Flat 5x5 */          case kGeometryLibraryRange_Simple+0:          case kGeometryLibraryRange_UVGeoAttributes+0:          case kGeometryLibraryRange_UVFaceAttributes+0:            vertices[i].point.x = uuValue;            vertices[i].point.y = vvValue;            vertices[i].point.z = 0;          break;          /* Splash */          case kGeometryLibraryRange_Simple+3:          case kGeometryLibraryRange_UVGeoAttributes+3:          case kGeometryLibraryRange_UVFaceAttributes+3:            vertices[i].point.x = uuValue;            vertices[i].point.y = vvValue;            vertices[i].point.z = 1.5 * uMath_Sin_Deg(48.0 * uuValue * vvValue) *                          uMath_Cos_Deg(48.0 * uuValue * vvValue);          break;          /* Steps */          case kGeometryLibraryRange_Simple+7:          case kGeometryLibraryRange_UVGeoAttributes+7:          case kGeometryLibraryRange_UVFaceAttributes+7:            vertices[i].point.x = uuValue;            vertices[i].point.y = vvValue;            vertices[i].point.z = kStepScale * (((long) uuValue) % ((data.numRows-1)/2)) *                               (((long) vvValue) % ((data.numColumns-1)/2));          break;          }          if (hasUVAttributes)          {            if (mHasUVGeoAttributes(num))            {              param2D.u = (uuValue - uuMin) / (uuMax - uuMin);              param2D.v = (vvValue - vvMin) / (vvMax - vvMin);            }            else /* mHasUVFaceAttributes */            {              param2D.u = i % data.numColumns;              param2D.v = i / data.numColumns;            }            vertices[i].attributeSet = Q3AttributeSet_New();            if (vertices[i].attributeSet != NULL)              Q3AttributeSet_Add(vertices[i].attributeSet, kQ3AttributeTypeShadingUV, &amp;param2D);          }          else            vertices[i].attributeSet = NULL;          i++;        }      }      if (addNormals)        AddVertexNormals(num, &amp;data);      geometryObject = Q3TriGrid_New (&amp;data);      if (hasUVAttributes)      {        for (i = 0; i &lt; data.numRows * data.numColumns; i++)        {          if (vertices[i].attributeSet != NULL)            Q3Object_Dispose(vertices[i].attributeSet);        }      }      DisposePtr ((void *) vertices);    }    break;    case kGeometryLibraryRange_Simple+1:    /* Torus */    case kGeometryLibraryRange_UVGeoAttributes+1:    case kGeometryLibraryRange_UVFaceAttributes+1:    case kGeometryLibraryRange_Simple+2:    /* Wavey Torus */    case kGeometryLibraryRange_UVGeoAttributes+2:    case kGeometryLibraryRange_UVFaceAttributes+2:    case kGeometryLibraryRange_Simple+4:    /* Sphere */    case kGeometryLibraryRange_UVGeoAttributes+4:    case kGeometryLibraryRange_UVFaceAttributes+4:    case kGeometryLibraryRange_Simple+5:    /* Cone */    case kGeometryLibraryRange_UVGeoAttributes+5:    case kGeometryLibraryRange_UVFaceAttributes+5:    case kGeometryLibraryRange_Simple+6:    /* Pipe */    case kGeometryLibraryRange_UVGeoAttributes+6:    case kGeometryLibraryRange_UVFaceAttributes+6:    case kGeometryLibraryRange_Simple+8:    /* Spring */    case kGeometryLibraryRange_UVGeoAttributes+8:    case kGeometryLibraryRange_UVFaceAttributes+8:    {      /* Setup min, max and step values trigrid vertex u &amp; v values */      switch (num)      {      /**       ** Torus       **/      case kGeometryLibraryRange_Simple+1:      case kGeometryLibraryRange_UVGeoAttributes+1:      case kGeometryLibraryRange_UVFaceAttributes+1:      /**       ** Wavey Torus       **/      case kGeometryLibraryRange_Simple+2:      case kGeometryLibraryRange_UVGeoAttributes+2:      case kGeometryLibraryRange_UVFaceAttributes+2:        addNormals = kQ3True;        /*         * uuValue is used to generate each circular cross section about the y axis         * vvValue is used to revolve the circular cross section about the torus' center         */        #define  kTorusCrossRadius   0.5        #define  kTorusInnerRadius   1.0        #define  kTorusWaveyAmpRadius 5.0        uuMin =    0.0;        uuMax =  360.0;        vvMin = -180.0;        vvMax =  180.0;        if (hasUVAttributes) {          uuStep = 12.0;  /* 10.0; */          vvStep = 12.0;  /* 10.0; */        } else {          uuStep = 10.0;          vvStep = 10.0;        }        break;      /**       ** Sphere       **/      case kGeometryLibraryRange_Simple+4:      case kGeometryLibraryRange_UVGeoAttributes+4:      case kGeometryLibraryRange_UVFaceAttributes+4:        addNormals = kQ3True;        /*         * uuValue is an angle used to revolve the cross section about the y axis         * vvValue is an angle used to generate each half circular cross section         */        uuMin =    0.0;        uuMax =  360.0;        vvMin = - 90.0;        vvMax =   90.0;        if (hasUVAttributes) {          uuStep =  12.0;  /* 10.0; */          vvStep =  12.0;  /* 10.0; */        } else {          uuStep =   9.0;          vvStep =   9.0;        }        radius = 1.0;        break;      /**       ** Cone       **/      case kGeometryLibraryRange_Simple+5:      case kGeometryLibraryRange_UVGeoAttributes+5:      case kGeometryLibraryRange_UVFaceAttributes+5:        addNormals = kQ3True;        /*         * vvValue is the length of the cone side from point to the edge         * uuValue is an angle used to revolve the cross section about the y axis         */        if (hasUVAttributes) {          uuStep = 24.0;  /* 15.0; */          vvStep =  0.25;        } else {          uuStep = 10.0;          vvStep =  0.25;        }        uuMin =   0.0;        uuMax = 360.0;        vvMin = -vvStep;        vvMax =   2.0;        radius =  0.5;        break;      /**       ** Pipe       **/      case kGeometryLibraryRange_Simple+6:      case kGeometryLibraryRange_UVGeoAttributes+6:      case kGeometryLibraryRange_UVFaceAttributes+6:        addNormals = kQ3True;        /*         * uuValue is used to revolve the line cross section about the y axis         * vvValue is used to generate the length of the pipe         */        if (hasUVAttributes) {          uuStep = 20.0;  /* 10.0; */          vvStep =  0.5;        } else {          uuStep = 10.0;  /* 15.0; */          vvStep =  0.3;        }        uuMin =   0.0;        uuMax = 360.0;        vvMin = - 1.5;        vvMax =   1.5;#ifdef  FINISH_THIS        vvMin = - 1.5 - vvStep;        vvMax =   1.5 + vvStep;#else  /* FINISH_THIS */        vvMin = - 1.5;        vvMax =   1.5;#endif  /* FINISH_THIS */        radius =  1.0;        break;      /**       ** Spring       **/      case kGeometryLibraryRange_Simple+8:      case kGeometryLibraryRange_UVGeoAttributes+8:      case kGeometryLibraryRange_UVFaceAttributes+8:        addNormals = kQ3True;        /*         * uuValue is used to revolve the circular cross section about the springs' axis         * vvValue is used to generate each circular cross section         */        #define  kSpringCrossRadius   0.25        #define  kSpringInnerRadius   1.0        #define  kSpringSpacing     3.5*kSpringCrossRadius        uuMin = - 90.0;        uuMax =  810.0;        vvMin = -180.0;        vvMax =  180.0;        if (hasUVAttributes) {          uuStep = 15.0;  /* 30.0; */          vvStep = 30.0;        } else {          uuStep = 15.0;  /* 20.0; */          vvStep = 15.0;        }        break;      default:        DebugStr(&quot;\pWarning: NewLibraryTriGrid ; unknown revolved trigrid index&quot;);        return NULL;        break;      }      /* Setup TQ3TriGridData */      data.numRows    = (unsigned long) ((vvMax - vvMin) / vvStep) + 1;      data.numColumns    = (unsigned long) ((uuMax - uuMin) / uuStep) + 1;      data.facetAttributeSet  = NULL;      data.triGridAttributeSet= NULL;      data.vertices = (TQ3Vertex3D *) NewPtrClear (data.numRows * data.numColumns * sizeof(TQ3Vertex3D));      if (data.vertices == NULL)      {        ERROR_DEBUG_STR(&quot;Error:  NewLibraryTriGrid ; Out of memory for triGrid vertices.&quot;);        return NULL;      }      /* Set trigrid vertices and shading UVs, if it hasUVAttributes */      vertices = data.vertices;      i = 0;      for (vvValue = vvMin; vvValue &lt;= vvMax; vvValue += vvStep)      {        for (uuValue = uuMax; uuValue &gt;= uuMin; uuValue -= uuStep)        {          switch (num)          {          /* Torus */          case kGeometryLibraryRange_Simple+1:          case kGeometryLibraryRange_UVGeoAttributes+1:          case kGeometryLibraryRange_UVFaceAttributes+1:            vertices[i].point.x = (uMath_Cos_Deg(vvValue) * kTorusCrossRadius + kTorusInnerRadius) * uMath_Cos_Deg(uuValue);            vertices[i].point.y =  uMath_Sin_Deg(vvValue) * kTorusCrossRadius;            vertices[i].point.z = (uMath_Cos_Deg(vvValue) * kTorusCrossRadius + kTorusInnerRadius) * uMath_Sin_Deg(uuValue);          break;          /* Wavey Torus */          case kGeometryLibraryRange_Simple+2:          case kGeometryLibraryRange_UVGeoAttributes+2:          case kGeometryLibraryRange_UVFaceAttributes+2:            radius = kTorusCrossRadius / kTorusWaveyAmpRadius * uMath_Sin_Deg(kTorusWaveyAmpRadius * uuValue) + kTorusCrossRadius;            vertices[i].point.x = (uMath_Cos_Deg(vvValue) * radius + kTorusInnerRadius) * uMath_Cos_Deg(uuValue);            vertices[i].point.y =  uMath_Sin_Deg(vvValue) * radius;            vertices[i].point.z = (uMath_Cos_Deg(vvValue) * radius + kTorusInnerRadius) * uMath_Sin_Deg(uuValue);          break;          /* Sphere */          case kGeometryLibraryRange_Simple+4:          case kGeometryLibraryRange_UVGeoAttributes+4:          case kGeometryLibraryRange_UVFaceAttributes+4:            vertices[i].point.x = uMath_Cos_Deg(vvValue) * uMath_Cos_Deg(uuValue) * radius;            vertices[i].point.y = uMath_Sin_Deg(vvValue) * radius;            vertices[i].point.z = uMath_Cos_Deg(vvValue) * uMath_Sin_Deg(uuValue) * radius;          break;          /* Cone */          case kGeometryLibraryRange_Simple+5:          case kGeometryLibraryRange_UVGeoAttributes+5:          case kGeometryLibraryRange_UVFaceAttributes+5:            if (vvValue &lt; (vvMin + vvStep))            {              vertices[i].point.x = 0.0;              vertices[i].point.y = vvMin + vvStep;              vertices[i].point.z = 0.0;            }            else            {              vertices[i].point.x = (vvMax - vvValue) * uMath_Cos_Deg(uuValue) * radius;              vertices[i].point.y =  vvValue;              vertices[i].point.z = (vvMax - vvValue) * uMath_Sin_Deg(uuValue) * radius;            }          break;          /* Pipe */          case kGeometryLibraryRange_Simple+6:          case kGeometryLibraryRange_UVGeoAttributes+6:          case kGeometryLibraryRange_UVFaceAttributes+6:#ifdef  FINISH_THIS            if (vvValue &lt; (vvMin + vvStep))            {              vertices[i].point.x = 0.0;              vertices[i].point.y = vvMin + vvStep;              vertices[i].point.z = 0.0;            }            else            if (vvValue &gt; (vvMax - vvStep))            {              vertices[i].point.x = 0.0;              vertices[i].point.y = vvMax - vvStep;              vertices[i].point.z = 0.0;            }            else            {              vertices[i].point.x = uMath_Cos_Deg(uuValue) * radius;              vertices[i].point.y = vvValue;              vertices[i].point.z = uMath_Sin_Deg(uuValue) * radius;            }#else  /* FINISH_THIS */            vertices[i].point.x = radius * uMath_Cos_Deg(uuValue);            vertices[i].point.y = vvValue;            vertices[i].point.z = radius * uMath_Sin_Deg(uuValue);#endif  /* FINISH_THIS */          break;          /* Spring */          case kGeometryLibraryRange_Simple+8:          case kGeometryLibraryRange_UVGeoAttributes+8:          case kGeometryLibraryRange_UVFaceAttributes+8:            vertices[i].point.x = (uMath_Cos_Deg(vvValue) * kSpringCrossRadius + kSpringInnerRadius) * uMath_Cos_Deg(uuValue);            vertices[i].point.y =  uMath_Sin_Deg(vvValue) * kSpringCrossRadius + kSpringSpacing * uuValue/360.0;            vertices[i].point.z = (uMath_Cos_Deg(vvValue) * kSpringCrossRadius + kSpringInnerRadius) * uMath_Sin_Deg(uuValue);          break;          }          if (hasUVAttributes)          {            if (mHasUVGeoAttributes(num))            {              param2D.u = 1.0 - ((uuValue - uuMin) / (uuMax - uuMin));              param2D.v = (vvValue - vvMin) / (vvMax - vvMin);            }            else /* mHasUVFaceAttributes */            {              param2D.u = i % data.numColumns;              param2D.v = i / data.numColumns;            }            vertices[i].attributeSet = Q3AttributeSet_New();            if (vertices[i].attributeSet != NULL)              Q3AttributeSet_Add(vertices[i].attributeSet, kQ3AttributeTypeShadingUV, &amp;param2D);          }          else            vertices[i].attributeSet = NULL;          i++;        }      }      if (addNormals)        AddVertexNormals(num, &amp;data);      geometryObject = Q3TriGrid_New (&amp;data);      if (hasUVAttributes)      {        for (i = 0; i &lt; data.numRows * data.numColumns; i++)        {          if (vertices[i].attributeSet != NULL)            Q3Object_Dispose(vertices[i].attributeSet);        }      }      DisposePtr ((void *) vertices);    }    break;    default:      DebugStr(&quot;\pWarning:  NewLibraryTriGrid ; index unimplemented &quot;);      break;  }  return geometryObject;}void AddVertexNormals(  unsigned long  geoNum,  TQ3TriGridData  *pTriData){  TQ3Vector3D    vector3D;  TQ3Point3D    point3D;  TQ3Vertex3D    *pVertices;  unsigned long  i,          j,          k;  pVertices = pTriData-&gt;vertices;  if (    /* Torus */    geoNum == kGeometryLibraryRange_Simple+1      ||    geoNum == kGeometryLibraryRange_UVGeoAttributes+1  ||    geoNum == kGeometryLibraryRange_UVFaceAttributes+1  ||    /* Wavey Torus */    geoNum == kGeometryLibraryRange_Simple+2        ||    geoNum == kGeometryLibraryRange_UVGeoAttributes+2  ||    geoNum == kGeometryLibraryRange_UVFaceAttributes+2  ||    /* Spring */    geoNum == kGeometryLibraryRange_Simple+8        ||    geoNum == kGeometryLibraryRange_UVGeoAttributes+8  ||    geoNum == kGeometryLibraryRange_UVFaceAttributes+8    )  {    unsigned long  i2;    i2 = pTriData-&gt;numColumns * (pTriData-&gt;numRows/2);    #define  p1  pVertices[i].point    #define  p2  pVertices[i2].point    i = 0;    for (k = 0; k &lt; pTriData-&gt;numRows / 2; k++)    {      for (j = 0; j &lt; pTriData-&gt;numColumns; j++)      {        /* Create an attribute set for non-textured geometry */        if (pVertices[i ].attributeSet == NULL)          pVertices[i ].attributeSet = Q3AttributeSet_New();        if (pVertices[i2].attributeSet == NULL)          pVertices[i2].attributeSet = Q3AttributeSet_New();        switch (geoNum)        {        /* Torus */        case kGeometryLibraryRange_Simple+1:        case kGeometryLibraryRange_UVGeoAttributes+1:        case kGeometryLibraryRange_UVFaceAttributes+1:        /* Wavey Torus */        case kGeometryLibraryRange_Simple+2:        case kGeometryLibraryRange_UVGeoAttributes+2:        case kGeometryLibraryRange_UVFaceAttributes+2:        /* Spring */        case kGeometryLibraryRange_Simple+8:        case kGeometryLibraryRange_UVGeoAttributes+8:        case kGeometryLibraryRange_UVFaceAttributes+8:          /* point3D is midpoint */          Q3Point3D_Set (&amp;point3D,            (uMath_Fabs(p2.x - p1.x) / 2) + uMath_Min(p1.x, p2.x),            (uMath_Fabs(p2.y - p1.y) / 2) + uMath_Min(p1.y, p2.y),            (uMath_Fabs(p2.z - p1.z) / 2) + uMath_Min(p1.z, p2.z)            );          Q3Point3D_Subtract(&amp;pVertices[i].point, &amp;point3D, &amp;vector3D);        break;        }        if ((i % pTriData-&gt;numColumns) != (pTriData-&gt;numRows / 2))        {          Q3Vector3D_Normalize(&amp;vector3D, &amp;vector3D);          Q3AttributeSet_Add(pVertices[i].attributeSet, kQ3AttributeTypeNormal, &amp;vector3D);        }        Q3Vector3D_Negate(&amp;vector3D, &amp;vector3D);        Q3Vector3D_Normalize(&amp;vector3D, &amp;vector3D);        Q3AttributeSet_Add(pVertices[i2].attributeSet, kQ3AttributeTypeNormal, &amp;vector3D);        i++;        i2++;      }    }    #undef  p1    #undef  p2    return;  }  else  if (    /* Splash */    geoNum == kGeometryLibraryRange_Simple+3        ||    geoNum == kGeometryLibraryRange_UVGeoAttributes+3  ||    geoNum == kGeometryLibraryRange_UVFaceAttributes+3    )  {    TQ3Point3D    point3Dc,            point3Dr;    /*  C = numColumns     *  i = vertex index     *     *    i+C     *     *  i-1  i  i+1     *     *    i-C     */    #define  pL  pVertices[i-1].point    #define  pR  pVertices[i+1].point    #define  pT  pVertices[i+pTriData-&gt;numColumns].point    #define  pB  pVertices[i-pTriData-&gt;numColumns].point    #define  pH  point3Dc    #define  pV  point3Dr    i = pTriData-&gt;numColumns + 1;    for (k  = 1;       k &lt;= pTriData-&gt;numRows - 2;       k++)    {      for (j  = 1;         j &lt;= pTriData-&gt;numColumns - 2;         j++)      {        /* Create an attribute set for non-textured geometry */        if (pVertices[i].attributeSet == NULL)          pVertices[i].attributeSet = Q3AttributeSet_New();        /* point3Dc, point3Dr, point3D are midpoints */        /* i-1 and i+1 */        Q3Point3D_Set (&amp;point3Dc,          (uMath_Fabs(pR.x - pL.x) / 2) + uMath_Min(pL.x, pR.x),          (uMath_Fabs(pR.y - pL.y) / 2) + uMath_Min(pL.y, pR.y),          (uMath_Fabs(pR.z - pL.z) / 2) + uMath_Min(pL.z, pR.z)          );        /* i-C and i+C */        Q3Point3D_Set (&amp;point3Dr,          (uMath_Fabs(pT.x - pB.x) / 2) + uMath_Min(pB.x, pT.x),          (uMath_Fabs(pT.y - pB.y) / 2) + uMath_Min(pB.y, pT.y),          (uMath_Fabs(pT.z - pB.z) / 2) + uMath_Min(pB.z, pT.z)          );        /* point3Dc and point3Dr */        Q3Point3D_Set (&amp;point3D,          (uMath_Fabs(pH.x - pV.x) / 2) + uMath_Min(pV.x, pH.x),          (uMath_Fabs(pH.y - pV.y) / 2) + uMath_Min(pV.y, pH.y),          (uMath_Fabs(pH.z - pV.z) / 2) + uMath_Min(pV.z, pH.z)          );        Q3Point3D_Subtract(&amp;pVertices[i].point, &amp;point3D, &amp;vector3D);        Q3Vector3D_Normalize(&amp;vector3D, &amp;vector3D);        Q3AttributeSet_Add(pVertices[i].attributeSet, kQ3AttributeTypeNormal, &amp;vector3D);        i += ((i+2) % pTriData-&gt;numColumns == 0) ? 3 : 1;      }    }    #undef  pL    #undef  pR    #undef  pT    #undef  pB    #undef  pH    #undef  pV    return;  }  /*   *  Sphere   *  Cone   *  Pipe   */  i = 0;  for (k = 0; k &lt; pTriData-&gt;numRows; k++)  {    for (j = 0; j &lt; pTriData-&gt;numColumns; j++)    {      /* Create an attribute set for non-textured geometry */      if (pVertices[i].attributeSet == NULL)        pVertices[i].attributeSet = Q3AttributeSet_New();      switch (geoNum)      {      /* Sphere */      case kGeometryLibraryRange_Simple+4:      case kGeometryLibraryRange_UVGeoAttributes+4:      case kGeometryLibraryRange_UVFaceAttributes+4:        Q3Point3D_Set (&amp;point3D, 0.0, 0.0, 0.0);        Q3Point3D_Subtract(&amp;pVertices[i].point, &amp;point3D, &amp;vector3D);      break;      /* Cone */      case kGeometryLibraryRange_Simple+5:      case kGeometryLibraryRange_UVGeoAttributes+5:      case kGeometryLibraryRange_UVFaceAttributes+5:        Q3Point3D_Set (  &amp;point3D,                0.0,/**/              ((pVertices[i].point.y &gt; kQ3RealZero)  ||                 (pVertices[i].point.y == kQ3RealZero  &amp;&amp;                  Q3Vector3D_Length((TQ3Vector3D *) &amp;pVertices[i].point) == 0.5))                  ? pVertices[i].point.y                  : 100.0,                0.0);        Q3Point3D_Subtract(&amp;pVertices[i].point, &amp;point3D, &amp;vector3D);      break;      /* Pipe */      case kGeometryLibraryRange_Simple+6:      case kGeometryLibraryRange_UVGeoAttributes+6:      case kGeometryLibraryRange_UVFaceAttributes+6:        Q3Point3D_Set (&amp;point3D, 0.0, pVertices[i].point.y, 0.0);        Q3Point3D_Subtract(&amp;pVertices[i].point, &amp;point3D, &amp;vector3D);      break;      }      Q3Vector3D_Normalize(&amp;vector3D, &amp;vector3D);      Q3AttributeSet_Add(pVertices[i].attributeSet, kQ3AttributeTypeNormal, &amp;vector3D);      i++;    }  /* for j */  }  /* for k */}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Geometry_Samples/listing1.html%3Fid%3DDTS10000102-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Geometry_Samples/listing1.html%3Fid%3DDTS10000102-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Geometry_Samples/listing1.html%3Fid%3DDTS10000102-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>