<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Show Movie - /MovieStuff.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMovieBasics-date.html">Movie Basics</a> &gt; <A HREF="javascript:location.replace('index.html');">Show Movie</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Show Movie</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MovieStuff.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MenuStuff.c</option>
<option value="listing2.html">/MenuStuff.h</option>
<option value="listing3.html">/MoviePrefs.c</option>
<option value="listing4.html">/MoviePrefs.h</option>
<option value="listing5.html">/MovieStuff.c</option>
<option value="listing6.html">/MovieStuff.h</option>
<option value="listing7.html">/Show Movie.c</option>
<option value="listing8.html">/WindStuff.c</option>
<option value="listing9.html">/WindStuff.h</option></select>
				</p>
				</form>
				<p><strong><a href="Show_Movie.zip">Download Sample</a></strong> (&#147;Show_Movie.zip&#148;, 109.4K)<BR>
<strong><a href="Show_Movie.dmg">Download Sample</a></strong> (&#147;Show_Movie.dmg&#148;, 171.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    MovieStuff.c  Contains:    movie handling routines              This handles all the clever movie stuff.              - Sets up movie windows              - Tears down movie windows              - handles updates and events              - handles slaving, altering playback speed, looping etc                Written by: Jason Hodges-Harris &amp; Don Swatman    Copyright:  Copyright &copy; 1995-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/17/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &lt;Memory.h&gt;#include &lt;TextUtils.h&gt;#include &lt;Movies.h&gt;#include &quot;MovieStuff.h&quot;#include &quot;WindStuff.h&quot;//==============================================//  CallBackInfoType//// This structure is used to store QuickTime // call backs and any data they require.// - It has a several parameters at the front,//   then a variable size record at the end. It also//   needs the parameters used in CallMeWhen// - It's size is://      &quot;sizeof(CallBackInfoType) + callBackDataSize - sizeof(long)&quot;// - Data should not contain the only reference//   to other handles, as it can't dispose of them// - It forms a linked list. Any new items are//   added to the front.// - It should be passed in the call backs //   reference field.//==============================================struct CallBackInfoType{  struct CallBackInfoType **hNextCallBackInfo; // Next in the list    QTCallBack actualCallBack;    // the call back  WindowPtr  pParentWindow;     // parent window of the movie  long       param1;            // Used in &quot;CallMeWhen&quot;  long       param2;            // Used in &quot;CallMeWhen&quot;  long       param3;            // Used in &quot;CallMeWhen&quot;  long       callBackDataSize;  // Size of the data attached on the end  long       callBackDataStart; // where the data starts};typedef struct CallBackInfoType CallBackInfoType,  *CallBackInfoPtr, **CallBackInfoHdl;//==============================================//  DocMovieInfoType//// Used to hold information about a movie within// a window// - It should be attached to the windows RefCon//==============================================struct DocMovieInfoType{    FSSpec          movieFileSpec;  // movies File Spec    MovieController movieControls;  // standard movie controller    Movie           actualMovie;    // the Movie itself!    Boolean         movieAutoClose; // True if the window closes after movie finishes    TimeBase        moviesTimeBase;    TimeScale        moviesTimeScale;    CallBackInfoHdl hFirstCallBackData; // Handle to first item of the call back info list    WindowPtr       pSlaveWind;     // WindowPtr of this movies slave};typedef struct DocMovieInfoType DocMovieInfoType,  *DocMovieInfoPtr, **DocMovieInfoHndl;//==============================================// Global Stuff, init and tear down             //==============================================// Prototypes of functions  used in UPPspascal void StartMovieCB(QTCallBack myCallBack,long ref);pascal void AlterRate( QTCallBack myCallBack,long ref);pascal void AlterMasterOffset( QTCallBack myCallBack,long ref);// Global UPPsQTCallBackUPP    gStartMovieCBUpp;QTCallBackUPP    gAlterRateUpp;QTCallBackUPP    gAlterMasterOffsetUpp;//----------------------------------------------// InitMovieGlobals//// Init's any globals used in MovieStuff// i.e. the UPPs             //----------------------------------------------void InitMovieGlobals(void){  gStartMovieCBUpp = nil;  gAlterRateUpp    = nil;  gAlterMasterOffsetUpp = nil;//  Create routine descriptor for &quot;StartMovieCB&quot; QT callback routine  gStartMovieCBUpp = NewQTCallBackProc(StartMovieCB);//  Create routine descriptor for &quot;AlterRate&quot; QT callback routine  gAlterRateUpp = NewQTCallBackProc(AlterRate);//  Create routine descriptor for &quot;AlterMasterOffset&quot; QT callback routine  gAlterMasterOffsetUpp = NewQTCallBackProc(AlterMasterOffset);}//----------------------------------------------// KillMovieGlobals//// Removes the UPPs             //----------------------------------------------void KillMovieGlobals(void){// Clear the Universal Proc Pointers//    You don't need to do this as quiting the app will do it for you,//    however, I have this thing about neatness.    if (gStartMovieCBUpp)    DisposeRoutineDescriptor(gStartMovieCBUpp);  if (gAlterRateUpp)    DisposeRoutineDescriptor(gAlterRateUpp);  if (gAlterMasterOffsetUpp)    DisposeRoutineDescriptor(gAlterMasterOffsetUpp);    }//==============================================//// Error Reporting////==============================================//----------------------------------------------// Report Error//// If an error occurs, Uses DebugStr to send out// some text passed to it, then the error number//----------------------------------------------void ReportError( Str255 errText, OSErr theErr );void ReportError( Str255 errText, OSErr theErr ){  Str255 errorStr;// Check there is an error  if (theErr)  {// convert theErr number to text    NumToString(theErr,errorStr);// if there is error text then displat it    if (errText != &quot;\p&quot;)      DebugStr(errText);// Display error number    DebugStr(errorStr);  }}//----------------------------------------------// GetAndReportError////   Checks GetMoviesError and reports error if// needed//----------------------------------------------OSErr GetAndReportError( Str255 errText );OSErr GetAndReportError( Str255 errText ){  OSErr  theErr;  theErr = GetMoviesError();       // Get Movies error number  ReportError( errText, theErr );  // And report it  return(theErr);                  // Oh yeh, return it to the caller}//==============================================//// Call Back info stuff//// Following routines handle the CallBackInfoHdl// structure.//==============================================//----------------------------------------------// AddNewCallBackInfo////  Creates a new &quot;CallBackInfoHdl&quot;, intialises and//    returns it// - It puts &quot;pWindow&quot; and &quot;theCallBack&quot; into the structure// - It appends &quot;dataSize&quot; bytes of data from &quot;pDataStart&quot;//   on to the end of the structure //----------------------------------------------CallBackInfoHdl AddNewCallBackInfo( WindowPtr  pWindow,                                    QTCallBack theCallBack,                                    Ptr        pDataStart,                                    long       dataSize,                                    long       param1,                                    long       param2,                                    long       param3                                  );CallBackInfoHdl AddNewCallBackInfo( WindowPtr  pWindow,                                    QTCallBack theCallBack,                                    Ptr        pDataStart,                                    long       dataSize,                                    long       param1,                                    long       param2,                                    long       param3                                  ){  CallBackInfoHdl  hNewCBInfo = nil;  // the new call back info record  DocMovieInfoHndl hDocMovieInfo;  long newSize;   // Size of hNewCBInfo and the data added to it  // Calculate how big the block needs to be  newSize = sizeof(CallBackInfoType) + dataSize - sizeof(long);// Create the call back data item  hNewCBInfo = (CallBackInfoHdl) NewHandle (newSize);// Check that we actualy did create it!  if (hNewCBInfo)  {// Setup the structure    (**hNewCBInfo).hNextCallBackInfo = nil;    (**hNewCBInfo).actualCallBack    = theCallBack;    (**hNewCBInfo).pParentWindow     = pWindow;    (**hNewCBInfo).param1 = param1;    (**hNewCBInfo).param2 = param2;    (**hNewCBInfo).param3 = param3;    (**hNewCBInfo).callBackDataSize  = 0;// Add in the data (if there is any)    if (dataSize &amp;&amp; pDataStart)    {      (**hNewCBInfo).callBackDataSize  = dataSize;      BlockMove( pDataStart, &amp;((**hNewCBInfo).callBackDataStart), dataSize);    }// Now, link it into the window data structure (attach it to the front of the chain)    hDocMovieInfo = (DocMovieInfoHndl)GetWRefCon ( pWindow );    (**hNewCBInfo).hNextCallBackInfo     = (**hDocMovieInfo).hFirstCallBackData;    (**hDocMovieInfo).hFirstCallBackData = hNewCBInfo;  }    return( hNewCBInfo );}//----------------------------------------------//  RemoveCallBackInfo////  Scans down the CallBackInfoHdl chain and disposes// of each one//----------------------------------------------void RemoveCallBackInfo ( CallBackInfoHdl hFirstItem );void RemoveCallBackInfo ( CallBackInfoHdl hFirstItem ){  CallBackInfoHdl  hNextCBInfo;  CallBackInfoHdl  hDisposeData;  if (hFirstItem)  {// Scan down the chain of items, disposing as we go    hNextCBInfo = hFirstItem;    while (hNextCBInfo)    {      hDisposeData = hNextCBInfo;      hNextCBInfo  = (**hNextCBInfo).hNextCallBackInfo;      // Dispose of the call back      DisposeCallBack( (**hDisposeData).actualCallBack );    // Dispose of the call back info block      DisposeHandle( (Handle) hDisposeData);    }  }    }//----------------------------------------------//  GetDataFromCBInfo//// Extracts the data from a CallBackInfoHdl and// moves the data into it. Checks the stored structure// is smaller than requested size. Ideally they should// be the same size.//----------------------------------------------Boolean GetDataFromCBInfo ( CallBackInfoHdl  hCallBackInfo,                            Ptr    pData,                            long   maxDataSize   );Boolean GetDataFromCBInfo ( CallBackInfoHdl  hCallBackInfo,                            Ptr    pData,                            long   maxDataSize   ){  Boolean isOk = false;  // Check that we have a call back,//           and we have some where to put the data,//             and it's bigger than 0  if (hCallBackInfo &amp;&amp; pData &amp;&amp; maxDataSize)// Check the call back data is smaller than the new structure     if ( (**hCallBackInfo).callBackDataSize  &lt;= maxDataSize)    {// Move the data to pData      BlockMove ( &amp;((**hCallBackInfo).callBackDataStart),                  pData,                  (**hCallBackInfo).callBackDataSize );      isOk = true;    }  return ( isOk );}//----------------------------------------------//  IsMoviePlaying//// Find out if any movie is playing//----------------------------------------------Boolean IsMoviePlaying (void){  DocMovieInfoHndl hDocMovieInfo; // The movie we're checkings info  Boolean movieLive = false; // set to true if there is a live window  short   windCount;  // Scan the window list until we've found a live window  for (windCount = 0;(windCount &lt; kMaxWindows) &amp;&amp; !movieLive; windCount++ )// If this window is open    if (gTheWinds[windCount])      {// Get information about the movie        hDocMovieInfo = (DocMovieInfoHndl)GetWRefCon (gTheWinds[windCount]);// Use IsMovieDone to see if it's still running        if (!IsMovieDone((**hDocMovieInfo).actualMovie) )          movieLive = true;      }  return (movieLive);}//----------------------------------------------// UpdateMovieWindow//----------------------------------------------void UpdateMovieWindow (  WindowPtr pWindow   ){// Get the movie from the ref con and update it. Easy.  UpdateMovie( (**(DocMovieInfoHndl)GetWRefCon( pWindow )).actualMovie);}//----------------------------------------------// Load a movie into memory////  Use standard file to get and load a movie//----------------------------------------------void  LoadOneMovie( DocMovieInfoHndl hDocMovieInfo );void  LoadOneMovie( DocMovieInfoHndl hDocMovieInfo ){  Movie         myNewMovie = nil;   // The new movie  StandardFileReply  newMovieFile;   // Standard File Reply about the  movies file  Str255        myMovieName;        // The Movies name  OSErr         error;  SFTypeList    myTypes = {MovieFileType}; // File types we want Standard File to get  short         myMovieResFile;     // Movie files ref number  short         myMovieResID = 0;   // Load the first movie res  Boolean       movieChanged;       // Set to true if movie was changed durring                                     // loading to resolve references    // Use standard file to get the fsSpec etc.  StandardGetFilePreview(nil,1,myTypes,&amp;newMovieFile);  if (newMovieFile.sfGood)  {// Open the movie file    error = OpenMovieFile( &amp;newMovieFile.sfFile, &amp;myMovieResFile, fsRdPerm);    if (error==noErr)    {// Store the file spec      (**hDocMovieInfo).movieFileSpec = newMovieFile.sfFile;// Move Movie data in to memory      error = NewMovieFromFile( &amp;myNewMovie, myMovieResFile, &amp;myMovieResID,                                myMovieName, newMovieActive, &amp;movieChanged);// Close the file as we succeded in opening it      CloseMovieFile (myMovieResFile);    }  }  (**hDocMovieInfo).actualMovie =  myNewMovie; // Return myNewMovie}//----------------------------------------------// ServiceMovieTasks//// Used to Handle the null event. You need to handle// this to make the movie play!// - First it sees if the movie controller has an event// - Scans the window list looking for movies// - If the movie has finished then close it if the//   flags are set that way// - If any movies are active, then call MoviesTask//   to make them play// - Finally return true if the event was handled by the//   movie controller//----------------------------------------------Boolean ServiceMovieTasks ( WindowPtr pWindow, const EventRecord *theEvent ){#pragma unused ( pWindow )  Boolean doneProccessing = false;  // goes to true if MCIsPlayerEvent handles event  DocMovieInfoHndl hDocMovieInfo;   // Current windows movie info  short   windCount;  Boolean needMovieTasks = false;   // Goes true if there is a movie running  Boolean moviePlaying;  // Scan window list  for (windCount = 0;windCount &lt; kMaxWindows; windCount++ )    if (gTheWinds[windCount])      {// Get movie information for this window        hDocMovieInfo = (DocMovieInfoHndl)GetWRefCon (gTheWinds[windCount]);// Handle any events to this windows movie controller if it's got one        if (!doneProccessing)          if ((**hDocMovieInfo).movieControls)            if (MCIsPlayerEvent((**hDocMovieInfo).movieControls, theEvent))              doneProccessing = true;  // Next bit checks to see if a window has finished playing (by using// IsMovieDone) and closes it if auto close has been set for it        moviePlaying = !IsMovieDone((**hDocMovieInfo).actualMovie);        if (   (**hDocMovieInfo).movieAutoClose &amp;&amp; (!moviePlaying) )          CloseOurWindow( windCount );        else          if (moviePlaying)            needMovieTasks = true; // Hey there's a movie running      }// If we have an active movie, then service all movies  if (needMovieTasks)    MoviesTask(nil,0);  return ( doneProccessing );  }//----------------------------------------------//  CloseMovieWindow//// Close a movie window and destroys associated// structures. If this is a Master window,// sets &quot;*pSlaveWindow&quot; to the slave WindowPtr//----------------------------------------------OSErr CloseMovieWindow( WindowPtr pWindow,                        WindowPtr *pSlaveWindow ){  DocMovieInfoHndl hDocMovieInfo;    *pSlaveWindow = nil;// Get movie structure  hDocMovieInfo = (DocMovieInfoHndl)GetWRefCon(pWindow);  if (hDocMovieInfo)  {// Set the slave WindowPtr    *pSlaveWindow = (**hDocMovieInfo).pSlaveWind;// dispose movie    DisposeMovie((**hDocMovieInfo).actualMovie);  // dispose of the controller if it exists    if ((**hDocMovieInfo).movieControls)      DisposeMovieController ( (**hDocMovieInfo).movieControls );  // dispose of call back structures    RemoveCallBackInfo ( (**hDocMovieInfo).hFirstCallBackData );    // dispose movie structure    DisposeHandle( (Handle)hDocMovieInfo );  }  return ( noErr );}//----------------------------------------------//   OpenMovieWindow//// - Opens a movie// - Creates and initialises the windows movie//   structure &quot;DocMovieInfoHndl&quot;// - Creates (if wanted) a movie controller// - Sizes the window to fit the movie and controller// - Shows the window//----------------------------------------------OSErr OpenMovieWindow ( WindowPtr pWindow,                        Boolean   doesAutoClose,                        Boolean   hasControler  ){  OSErr theErr = noErr;  DocMovieInfoHndl hDocMovieInfo = nil; // new window movie information  Rect moviesRect;   // Size of the movie  Rect newWindRect;  // New Windows rect (movie + Controllers rect)    if (!pWindow)  {  // Error !!!!    DebugStr(&quot;\pHey, this window doesn't exists!!&quot;);    theErr = userCanceledErr;  // Should be something more appropriate  }  else  {// allocate new movie doc structure    hDocMovieInfo = (DocMovieInfoType**) NewHandle (sizeof(DocMovieInfoType));    if (hDocMovieInfo == nil)    { // Error !!!!      DebugStr(&quot;\pError allocating doc handle&quot;);      theErr = userCanceledErr;  // Should be something more appropriate    }    else    {// Set up the hDocMovieInfo record      (**hDocMovieInfo).movieAutoClose = doesAutoClose;      (**hDocMovieInfo).hFirstCallBackData  = nil;      (**hDocMovieInfo).movieControls = nil;      (**hDocMovieInfo).actualMovie   = nil;      (**hDocMovieInfo).pSlaveWind    = nil;      // set window refcon to movie doc handle      SetWRefCon( pWindow, (long)hDocMovieInfo );      SetPort(pWindow);          // load movie refs into doc structure      LoadOneMovie ( hDocMovieInfo );      if ((**hDocMovieInfo).actualMovie == nil)      { // Cancel button pressed or Error !!!!        theErr = userCanceledErr;  // Should be something more appropriate        return(theErr);      }      else      {// get timebase from movie        (**hDocMovieInfo).moviesTimeBase = GetMovieTimeBase((**hDocMovieInfo).actualMovie);        theErr = GetAndReportError( &quot;\pError!! GetMovieTimeBase&quot;);// get timescale from movie        if (!theErr)        {          (**hDocMovieInfo).moviesTimeScale = GetMovieTimeScale((**hDocMovieInfo).actualMovie);          theErr = GetAndReportError( &quot;\pError!! Getting movie time scale&quot;);        }        if (!theErr)          if (!hasControler)          {  // Don't want a controller, so just    // Get movies rect as this is the size of the window            GetMovieBox((**hDocMovieInfo).actualMovie, &amp;newWindRect);          }          else          {  // We want a movie controller so create it beneath the movie    // Get the movies rect as this is the size we want to put it in            GetMovieBox((**hDocMovieInfo).actualMovie, &amp;moviesRect);      //Create a controller and put below the movie. as moviesRect is the size of the movie,    // the controller will fall outside the rect            (**hDocMovieInfo).movieControls = NewMovieController ( (**hDocMovieInfo).actualMovie,                                                                   &amp;moviesRect,                                                                   mcTopLeftMovie);            if ((**hDocMovieInfo).movieControls == nil)            { // Failed to create controller Error !!!!              theErr = userCanceledErr;  // Should be something more appropriate              return(theErr);            }            else            {  // Get movieControllers rect. Because it is attached the movie, it will return  // the controller and movies size              theErr = MCGetControllerBoundsRect((**hDocMovieInfo).movieControls, &amp;newWindRect);            }          }        if (!theErr)        {  // Size the window to fit the movie and controller          SizeWindow( pWindow,newWindRect.right, newWindRect.bottom,true);        }      }    }  }    return ( theErr );}//==============================================// The time base call back procs//==============================================//----------------------------------------------//   AlterMasterOffset//// QuickTime callback used to set the SetTimeBaseValue.// - Can be used to make the movie loop.// - Takes a value in seconds in the data of//   the CallBackInfoHdl passed in &quot;ref&quot;//----------------------------------------------pascal void AlterMasterOffset(QTCallBack myCallBack,long ref){  DocMovieInfoHndl hDocMovieInfo;  WindowPtr pWindow;  TimeValue newTimeValue; // Where we want to move to  OSErr     theErr;// Extract where we want to move to from (CallBackInfoHdl)ref  if (GetDataFromCBInfo( ( CallBackInfoHdl)ref,                         (Ptr) &amp;newTimeValue, sizeof ( TimeValue ) ))  {    pWindow = (**(CallBackInfoHdl)ref).pParentWindow;  // Get the parent window    hDocMovieInfo = (DocMovieInfoHndl)GetWRefCon ( pWindow ); // Get the movie info// Move our position in the movie    SetTimeBaseValue ( (**hDocMovieInfo).moviesTimeBase,                       newTimeValue,                       (**hDocMovieInfo).moviesTimeScale);// Finally must reschedule the call back so that it happens again    theErr = CallMeWhen ( myCallBack,                          gAlterMasterOffsetUpp, ref,                          (**(CallBackInfoHdl)ref).param1,                          (**(CallBackInfoHdl)ref).param2,                          (**(CallBackInfoHdl)ref).param3);  }}//----------------------------------------------//   AlterRate//// QuickTime callback used to set the movies rate.// - Alters the speed of playback.// - Takes a value in the data of the CallBackInfoHdl//   passed in &quot;ref&quot;//----------------------------------------------pascal void AlterRate( QTCallBack myCallBack,long ref){#pragma unused ( myCallBack )  DocMovieInfoHndl hDocMovieInfo;  WindowPtr pWindow;  long      newMovieRate;// Extract the new speed we want the movie to run at  if (GetDataFromCBInfo ( ( CallBackInfoHdl)ref, (Ptr) &amp;newMovieRate, sizeof ( long ) ))  {    pWindow = (**(CallBackInfoHdl)ref).pParentWindow;  // Get the parent window    hDocMovieInfo = (DocMovieInfoHndl)GetWRefCon ( pWindow ); // Get the movie info// Change the movies rate    SetMovieRate((**hDocMovieInfo).actualMovie, newMovieRate);  }  return;}//----------------------------------------------//   StartMovieCB//// QuickTime callback used to start a movie.// - Takes a value (Movie) in the data of the CallBackInfoHdl//   passed in &quot;ref&quot; which is the movie you want to start.//----------------------------------------------pascal void StartMovieCB(QTCallBack myCallBack,long ref){#pragma unused ( myCallBack )  Movie movieToStart;      if (GetDataFromCBInfo ( ( CallBackInfoHdl)ref, (Ptr) &amp;movieToStart, sizeof ( Movie ) ))  {    SetMovieRate(movieToStart,65536);  }}//==============================================// Set up the various options//==============================================//----------------------------------------------// SetupMovieRate//// - Sets up the call backs to change the play back speed//   of the movie.// - &quot;delayBeforeChange&quot; gives the time in seconds when//   the first speed change happens or a constant that//   tells it to change at 1/3 (&amp; 2/3) of the movies //   duration.//----------------------------------------------OSErr SetupMovieRate( WindowPtr pWindow,  short delayBeforeChange  ){  OSErr            theErr = noErr;  QTCallBack       theNewCallBack;     // Call Back  long             theCallBackOffset;  // When we want to change the rate  TimeValue         theMovieLen;        // Length of the movie  DocMovieInfoHndl hDocMovieInfo;      // Info about the windows movie  CallBackInfoHdl  hTempCallBackInfo;  // Call back information  long             newMovieRate;       // What the new rate will be  hDocMovieInfo = (DocMovieInfoHndl)GetWRefCon (pWindow);  if (hDocMovieInfo != nil)  {// Set up the time base value    SetTimeBaseValue( (**hDocMovieInfo).moviesTimeBase,                      0,                      (**hDocMovieInfo).moviesTimeScale);    // If we're changing by a thirds, we need the movie's length    if (delayBeforeChange == kOneThird)      theMovieLen  = GetMovieDuration((**hDocMovieInfo).actualMovie);// ---- First call back - slow playback rate to x2 normal -----// Work out length of delay before callbacks start    if (delayBeforeChange == kOneThird)      theCallBackOffset = theMovieLen*0.3333;    else      theCallBackOffset = delayBeforeChange * (**hDocMovieInfo).moviesTimeScale;// Create a new call back    theNewCallBack = NewCallBack((**hDocMovieInfo).moviesTimeBase,callBackAtTime);    newMovieRate = 131072;    // speed up rate to x2 normal// Put the call back into call back chain ( and append newMovieRate )    hTempCallBackInfo = AddNewCallBackInfo( pWindow,                                            theNewCallBack,                                            (Ptr)&amp;newMovieRate, sizeof ( long ),                                            triggerTimeFwd,                                            theCallBackOffset,                                            (**hDocMovieInfo).moviesTimeScale  );// Attach the call back to the movie's time structures    theErr = CallMeWhen ( theNewCallBack,                            gAlterRateUpp,                            (long)hTempCallBackInfo,                            (**hTempCallBackInfo).param1,                            (**hTempCallBackInfo).param2,                            (**hTempCallBackInfo).param3 );    if (theErr)      ReportError( &quot;\pError !! CallMeWhen&quot;, theErr );    else    {// ---  Second call back - slow playback rate to 1/2 normal ----// Work out length of delay before callbacks start      if (delayBeforeChange == kOneThird)        theCallBackOffset = theMovieLen*0.6666;      else        theCallBackOffset = (2 * delayBeforeChange) * (**hDocMovieInfo).moviesTimeScale;  // Create a new call back      theNewCallBack = NewCallBack((**hDocMovieInfo).moviesTimeBase,callBackAtTime);        newMovieRate = 32768;    // speed up rate to 1/2 normal    // Put the call back into call back chain ( and append newMovieRate )      hTempCallBackInfo = AddNewCallBackInfo( pWindow,                                              theNewCallBack,                                              (Ptr)&amp;newMovieRate, sizeof ( long ),                                              triggerTimeFwd,                                              theCallBackOffset,                                              (**hDocMovieInfo).moviesTimeScale  );  // Attach the call back to the movie's time structures      theErr = CallMeWhen ( theNewCallBack,                            gAlterRateUpp,                            (long)hTempCallBackInfo,                            (**hTempCallBackInfo).param1,                            (**hTempCallBackInfo).param2,                            (**hTempCallBackInfo).param3 );      if (theErr)        ReportError( &quot;\pError !! CallMeWhen&quot;, theErr );    }  }  return ( theErr );  }//----------------------------------------------//  SetupLoop//// Set up a loop in the movie.// - It uses call backs, to change the position of//   the movie &quot;loopWhen&quot; seconds into it and moves it//   to &quot;loopTo&quot; seconds//----------------------------------------------OSErr SetupLoop ( WindowPtr pWindow,                  short    loopWhen,                  short    loopTo  ){  OSErr  theErr = noErr;  DocMovieInfoHndl hDocMovieInfo; // Info about the windows movie  long             callBackWhen;  // When we want to start loop  CallBackInfoHdl  hTempCallBackInfo; // Call back information  QTCallBack       tempCallBack;  // Call Back  TimeValue        newTimeValue;  // Where we want to loop to  hDocMovieInfo = (DocMovieInfoHndl)GetWRefCon (pWindow);// Calculate when the movie should 'jump'  callBackWhen = loopWhen*(**hDocMovieInfo).moviesTimeScale;// Creates a call back  tempCallBack = NewCallBack((**hDocMovieInfo).moviesTimeBase, callBackAtTime);// Set up where it's going to loop to  newTimeValue = loopTo * (**hDocMovieInfo).moviesTimeScale;// Add the call back to the call back list  hTempCallBackInfo = AddNewCallBackInfo( pWindow,                                          tempCallBack,                                          (Ptr) &amp;newTimeValue, sizeof ( TimeValue ),                                          triggerTimeFwd,                                          callBackWhen,                                          (**hDocMovieInfo).moviesTimeScale  );// Attach the call back to the movie's time structures  theErr = CallMeWhen( tempCallBack,                       gAlterMasterOffsetUpp, (long)hTempCallBackInfo,                      (**hTempCallBackInfo).param1,                      (**hTempCallBackInfo).param2,                      (**hTempCallBackInfo).param3 );  return ( theErr );}//----------------------------------------------// SetupSlaveMovie//// This sets up the slaved movie// - &quot;slaveAheadBy&quot; sets the duration that the//   slave  will lead the master (in seconds)// - &quot;slaveDelayStart&quot; sets the duration that the//   slave start will be delayed after the master starts// - If both values are set the same, the slave will start//   n seconds behind the master and run in sync//----------------------------------------------OSErr SetupSlaveMovie ( WindowPtr pMasterWindow,                        WindowPtr pSlaveWindow,                        short     slaveAheadBy,                        short     slaveDelayStart ){  OSErr             theErr = noErr;  DocMovieInfoHndl hDocMasterInfo;  // masters info  DocMovieInfoHndl hDocSlaveInfo;   // slaves info  long             slaveTimeOffset; // difference between the two movies  long             slaveStartDelay; // when we've got to start the slave  CallBackInfoHdl  hTempCallBackInfo; // Call back information  QTCallBack       tempCallBack;    // call back  Movie            movieToStart;    // Put into the call back  TimeValue         theMovieLen;     // Length of the movie// Get the info about the two movies  hDocMasterInfo = (DocMovieInfoHndl)GetWRefCon (pMasterWindow);  hDocSlaveInfo  = (DocMovieInfoHndl)GetWRefCon (pSlaveWindow);// Attach the slave window onto the master  (**hDocMasterInfo).pSlaveWind = pSlaveWindow;// Set the master movies time base value  SetTimeBaseValue((**hDocMasterInfo).moviesTimeBase,0,(**hDocMasterInfo).moviesTimeScale);// slave second movie to first  SetMovieMasterTimeBase( (**hDocSlaveInfo).actualMovie,                          (**hDocMasterInfo).moviesTimeBase,                          nil );// --- Setup the slave so it will lead the master ---  if (slaveAheadBy != kInSync)  {// Calculate how big the offset should be    if (slaveAheadBy == kOneThird)    {  // get the movie's length      theMovieLen  = GetMovieDuration((**hDocSlaveInfo).actualMovie);      slaveTimeOffset  = theMovieLen*0.3333;    }    else      slaveTimeOffset  = slaveAheadBy*(**hDocMasterInfo).moviesTimeScale;      // Set the slaves time base offset    SetTimeBaseValue( (**hDocSlaveInfo).moviesTimeBase,                      slaveTimeOffset,                      (**hDocSlaveInfo).moviesTimeScale);    theErr = GetAndReportError( &quot;\pError !! - Offsetting timebase&quot; );  }// --- Put in the call back to start the slave movie (delayed if requested )--// Set up slaveStartDelay  if (slaveDelayStart == kInSync)    slaveStartDelay = 0;  else    if (slaveDelayStart == kOneThird)    {  // get the movie's length      theMovieLen  = GetMovieDuration((**hDocMasterInfo).actualMovie);      slaveStartDelay = theMovieLen*0.3333;    }    else      slaveStartDelay = slaveDelayStart * (**hDocMasterInfo).moviesTimeScale;// Create a new call back  tempCallBack = NewCallBack((**hDocMasterInfo).moviesTimeBase,callBackAtTime);// Link the call back into the chain  movieToStart = (**hDocSlaveInfo).actualMovie;  hTempCallBackInfo = AddNewCallBackInfo( pMasterWindow,                                          tempCallBack,                                          (Ptr) &amp;movieToStart, sizeof(Movie),                                          triggerTimeFwd,                                          slaveStartDelay,                                          (**hDocMasterInfo).moviesTimeScale  );// Attach the call back to the movie's time structures  theErr = CallMeWhen ( tempCallBack, gStartMovieCBUpp,                        (long)hTempCallBackInfo,                        (**hTempCallBackInfo).param1,                        (**hTempCallBackInfo).param2,                        (**hTempCallBackInfo).param3 );  ReportError( &quot;\pError!! - Creating movie start call back&quot;, theErr );  return ( theErr );  }//----------------------------------------------// StartMovieWindow//// Start a movie in pWindow//----------------------------------------------OSErr StartMovieWindow( WindowPtr pWindow,                        Boolean   fromBegining  ){  DocMovieInfoHndl hDocMovieInfo;    if (pWindow)  {    hDocMovieInfo = (DocMovieInfoHndl)GetWRefCon (pWindow);// Set up the movie and start it    if (fromBegining)      GoToBeginningOfMovie((**hDocMovieInfo).actualMovie);    SetMovieActive((**hDocMovieInfo).actualMovie,true);    StartMovie((**hDocMovieInfo).actualMovie);  }  return( noErr );}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Show_Movie/listing5.html%3Fid%3DDTS10000792-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Show_Movie/listing5.html%3Fid%3DDTS10000792-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Show_Movie/listing5.html%3Fid%3DDTS10000792-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>