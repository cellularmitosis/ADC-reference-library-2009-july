<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1180: Sherlock's Find By Content Library</title>       <meta name="keywords" content="Sherlock Find by Content Mac OS 8 Mac OS 9">    <meta name="Description" content="Technical Note TN1180: have creator write a brief descriptionhere."><meta name="categories" content="System Releases and Platforms and Tools"><meta name="week-posted" content="Sep 27, 1999 - Oct 1, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003019" title="Sherlock's Find By Content Library"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/InternetWeb/index.html">Internet & Web</a> &gt; <a href="../../technicalnotes/InternetWeb/idxWebServices-date.html">Web Services</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1180</div>
<div id="pageheadsub">Sherlock's Find By Content Library</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">   <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>            <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <span id="menutitle">CONTENTS   <br>  <br> </span>   </td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <!-- begin_toc -->         <P id = "menutext">        <A HREF = "#Anchor1588">Overview</A><BR>            <A HREF = "#Anchor1861">Determining if Find By Content is Available</A><BR>            <A HREF = "#Anchor2351">Working with Search Sessions</A><BR>            <A HREF = "#Anchor2614">Setting up a Search Session</A><BR>            <A HREF = "#Anchor3097">Performing Searches</A><BR>            <A HREF = "#Anchor3511">Retrieving Information from a Search Session</A><BR>            <A HREF = "#Anchor4006">Find By Content Reference</A></p>            <p id ="menutext2">                           <A HREF = "#Anchor4500">Data Types</A><BR>                <A HREF = "#Anchor4877">Allocation and Initialization of Search Sessions</A><BR>                <A HREF = "#Anchor5386">Configuring Search Sessions</A><BR>                <A HREF = "#Anchor5978">Executing a Search</A><BR>                <A HREF = "#Anchor6825">Getting Information About Hits</A><BR>                <A HREF = "#Anchor7359">Summarizing Text</A><BR>                <A HREF = "#Anchor7686">Getting Information About Volumes</A><BR>                <A HREF = "#IndexingThings">Indexing Volumes, Folders, and Files</A><BR>                <A HREF = "#Anchor8305">Reserving Heap Space</A><BR>                <A HREF = "#Anchor8666">Application-Defined Routine</A></p><P id = "menutext">            <A HREF = "#Anchor9490">Find By Content C Summary</A><BR>          <A HREF = "#References">References</A><BR><A HREF = "#Downloads">Downloadables</A></p> <!-- end_toc --></td>  </tr>  <tr>   <td width=300 align=left scope="row"> <img src="images/tnmenubottom.gif" alt="" width=300 height=16>   </td>  </tr>    </table></td>  <td width=300 valign="top" align=left>            <!-- begin_intro_text --><p id = "introtext">This Technote         describes the Find by Content libraries used by         Sherlock for searching the contents of files.</P>                  <p id = "introtext">The Find by Content libraries export a full suite         of routines and functions allowing applications to         perform content based searches of files.</P>                 <p id = "introtext">With MacOS 8.6, Text Extractor Plug-ins were introduced.  These    allow Find By Content to extract textual information from binary    files for inclusion in index files.  Text Extractor Plug-ins    are documented in Technote <A HREF = "tn1181.html">TN1181,     "Find by Content Text Extractor Plug-ins."</A></P>         <p id = "introtext">This Note is directed at application developers who wish         to access the Find By Content library directly from their         applications.</P>     <!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Oct 5 1999]</h3><!-- end_date --></TD> </TR>    </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content -->    <A NAME=Anchor1588></A>        <H2>Overview</H2>                  <P>The Find By Content (FBC) facilities provided in Mac OS         8.6 are implemented in a PowerPC Code Fragment Manager         library that resides in the "Extensions" folder.         The Sherlock application is a client         of FBC, accessing FBC services through this shared library.         Developer applications can also access the search facilities         provided by this library. This section describes how         developers can create products that access the new FBC         facilities through this shared library.</P>                  <P>Compiler interfaces to FBC are found in the C header file         "FindByContent.h."         And, for linking purposes, the         Code Fragment Manager library         implementing FBC is named "Find By Content" (without the         quotes). Developers using the FBC routines described herein         should weak-link against this library, and then check the         Gestalt selectors from within their application before         calling any of these routines.</P>     <p><A HREF = "#top">Back to top</a></p><BR>                  <A NAME=Anchor1861></A>                  <H3>Determining if Find By Content is Available</H3>                  <P>FBC defines two         <CODE>Gestalt</CODE> selectors. Clients of FBC must verify         that correct version of the implementation is available         before making any of these calls, and will want to check the         FBC indexing state before performing any         searches.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    gestaltFBCVersion            = 'fbcv',    gestaltFBCCurrentVersion     = 0x0011};</pre></TD></TR></TABLE></CENTER><BR><BR>             <BR>                  <P>The         <CODE>gestaltFBCVersion</CODE>         selector returns the version of FBC         that is installed on the computer. Developers can compare         this version with the version of the interface with which         they have compiled their programs using the         <CODE>gestaltFBCCurrentVersion</CODE>         to determine if it is safe to make any         calls to FBC. If         <CODE>gestaltFBCVersion</CODE>         produces some version other than the version of the         interface your application has been compiled to run with,         then your application should not make any calls to         FBC.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    gestaltFBCIndexingState      = 'fbci',    gestaltFBCindexingSafe       = 0,    gestaltFBCindexingCritical   = 1};</pre></TD></TR></TABLE></CENTER><BR><BR>              <BR>                  <P>The <CODE>gestaltFBCIndexingState</CODE>         selector returns information about the current indexing         status of FBC. At any given time, the indexing status will         be either <CODE>gestaltFBCindexingSafe</CODE> or         <CODE>gestaltFBCindexingCritical</CODE>.         If the status is <CODE>gestaltFBCindexingCritical</CODE>,         then any search will result in a synchronous wait until the         state returns to <CODE>gestaltFBCindexingSafe</CODE>.         When the FBC indexing state returned         is <CODE>gestaltFBCindexingSafe</CODE>, then all         searches will execute immediately. To avoid synchronous         waits, developers should check the         <CODE>gestaltFBCIndexingState</CODE> selector and only make         calls to FBC when the indexing state returned is         <CODE>gestaltFBCindexingSafe</CODE>.</P><p><A HREF = "#top">Back to top</a></p><BR>    <A NAME=Anchor2351></A>             <H3>Working with Search Sessions</H3>                  <P>FBC allows client applications to open and close a         "search session." A search session contains all of the         information about a search, including the list of matched         files after the search is complete. Clients of FBC can         obtain references to search sessions, modify them, and query         their state using the routines defined in this section.         References to search sessions are defined as an opaque         pointer type owned by the FBC library.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct OpaqueFBCSearchSession* FBCSearchSession;</pre></TD></TR></TABLE></CENTER><BR><BR>                         <P>Developers should only access the search session         structure using the routines defined herein. This includes         using the appropriate FBC routines for duplicating and         disposing of search sessions. Search sessions are complex         memory structures that contain pointers to other data that         may need to be copied when a search session is duplicated or         disposed of when a search session is deallocated.</P>                  <P>The normal sequence of actions one takes when using the         FBC library is to create a search session, configure the         search session to target specific volumes, perform the         search, query the search results, and dispose of the search.         Other possibilities for searches include the ability to         reinitialize a search session and use it over again for         another search, to provide backtracking by cloning search         sessions and performing additional searches using the         clones, or to limit search results to files found in         particular directories.</P>         <p><A HREF = "#top">Back to top</a></p><BR>    <A NAME=Anchor2614></A>        <H3>Setting up a Search Session</H3>                  <P>Creating a new session and preparing it for a search, as         shown in Listing 6, requires at least two calls to the FBC         library. In this example, a new search session is created         and it is configured to search all local volumes that         contain index files. The call to         <CODE>FBCAddAllVolumesToSession</CODE>         automatically configures the search session to search all         indexed volumes.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* SimpleSetUpSession allocates a new search session and    returns a FBCSearchSession value in the *session    parameter. if an error occurs, *session is left    untouched. */OSErr SimpleSetUpSession(FBCSearchSession* session) {    OSErr err;    FBCSearchSession newsession;        /* set up our local variables */    err = noErr;    newsession = NULL;    if (session == NULL) return paramErr;        /* create the new session */    err = FBCCreateSearchSession(&amp;newsession);    if (err != noErr) goto bail;        /* search all available local volumes */    err = FBCAddAllVolumesToSession(newsession, false);    if (err != noErr) goto bail;        /* store our result and leave */    *session = newsession;    return noErr;bail:    if (newsession != NULL)        FBCDestroySearchSession(newsession);    return err;}</pre></TD></TR></TABLE></CENTER>        <p align="center"><B>Listing 6</B>.  Setting up a search session to search all local, indexed volumes.</p>           <P>FBC provides a complete set of routines for developers         wanting more control over what volumes will be searched by         the search session. Listing 7 illustrates how a new search         session could be configured to search a particular set of         volumes.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* SetUpVolumeSession allocates a new search session and    returns a FBCSearchSession value in the *session parameter.    if vCount is not zero, then vRefNums points to an array of    volume reference numbers for volumes that are to be searched.    if any of the vRefNums refer to a volume without an index,    paramErr is returned.  */OSErr SetUpVolumeSession (FBCSearchSession* session,                            UInt16 vCount, SInt16 *vRefNums) {    OSErr err;    UInt16 i;    FBCSearchSession newsession;        /* set up our local variables */    err = noErr;    newsession = NULL;    if (vCount == 0) return paramErr;    if (session == NULL) return paramErr;    if (vRefNums == NULL) return paramErr;        /* create the new session */    err = FBCCreateSearchSession(&amp;newsession);    if (err != noErr) goto bail;        /* search the volumes specified in vRefNums */    for (i=0; i&lt;vCount; i++) {        if (!FBCVolumeIsIndexed(vRefNums[i])) {            err = paramErr;            goto bail;        } else {            err = FBCAddVolumeToSession(newsession,                                        vRefNums[i]);            if (err != noErr) goto bail;        }    }        /* store our result and leave */    *session = newsession;    return noErr;bail:    if (newsession != NULL)        FBCDestroySearchSession(newsession);    return err;}</pre></TD></TR></TABLE></CENTER>                <p align="center"><B>Listing 7</B>.  Setting up a session to search a particular set of volumes.</p>            <P>In this example, the <CODE>FBCAddVolumeToSession</CODE>         routine is used to add volumes to the search session.         Other routines for querying what volumes are currently         targeted by a search session and removing volumes from that         list are provided.</P>                  <P>Once a search session has been configured to search a         number of volumes, it can be used again after a search has         been conducted without having to reconfigure its target         volumes. After performing a search and examining the         results, the search session can be prepared for another         search by calling the routine         <CODE>FBCReleaseSessionHits</CODE>. This routine releases         all of the search results from the last search while leaving         the list of target volumes intact.</P>                  <P>Making a copy of a search session using the routine         <CODE>FBCCloneSearchSession</CODE> will copy the list of         target volumes to the duplicate search session.</P>        <p><A HREF = "#top">Back to top</a></p><BR>        <A NAME=Anchor3097></A>             <H3>Performing Searches</H3>                  <P>When FBC performs a search, it will generate a list of         files that were matched. This list is referred to as the         "hits," and it is stored inside of the search session. FBC         can be asked to perform a content-based search using a query         string containing a list of words, a similarity search based         on one or more hits obtained in a previous search, or a         similarity search based on a list of example files. Listing         8 illustrates how a query-based search can be performed.         Here, the query is used to search for matching files on all         local indexed volumes.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr SimpleFindByQuery (char *query, FBCSearchSession *session) {    OSErr err;    FBCSearchSession newsession;        /* set up locals, check parameters... */    if (query[0] == 0) return paramErr;    if (session == NULL) return paramErr;    newsession = NULL;        /* allocate a new search session */    err = SimpleSetUpSession(&amp;newsession);    if (err != noErr) goto bail;        /* Here is the call that does the actual search,        storing the results in the search session. */    err = FBCDoQuerySearch(newsession, query,                                   NULL, 0, 100, 100);    if (err != noErr) goto bail;        /* save the results and return */    *session = newsession;    return noErr;bail:    if (newsession != NULL)        FBCDestroySearchSession(newsession);    return err;}</pre></TD></TR></TABLE></CENTER>           <p align="center"><B>Listing 8</B>.  A Query based search of all local, indexed volumes.</p>           <P>Searches conducted using either the         routine <CODE>FBCDoExampleSearch</CODE> or the routine         <CODE>FBCBlindExampleSearch</CODE> can be used to locate         files that are similar to other files. Similarity searches         will locate files with similar content to the files         specified as examples. Examples can be specified as indexes         referring to hits obtained from previous searches, or as a         list of <CODE>FSSpec</CODE> records referring to files on         disk.</P>                  <P>All three of the search routines -          <CODE>FBCDoExampleSearch</CODE>,         <CODE>FBCBlindExampleSearch</CODE>, and         <CODE>FBCDoQuerySearch</CODE> - provide support for limiting         the search results to files residing in one or more         directories. To do this, clients provide a list of         <CODE>FSSpec</CODE> records referring to target directories.         The example in Listing 9 illustrates how to limit the         results of a search to a particular set of         directories.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kMaxVols = 20,    maxHits = 10,    maxHitTerms = 10};OSErr RestrictedFindByQuery (char *query, UInt16 dirCount,                                  FSSpec* dirList,                                      FBCSearchSession* session) {    UInt16 vCount, i;    SInt16 vRefNums[kMaxVols], normalVol;    FBCSearchSession newsession;    vCount = 0;    newsession = NULL;    if (dirList == NULL || dirCount == 0) return paramErr;    if (query == NULL) return paramErr;    if (*query == 0) return paramErr;    if (session == NULL) return paramErr;        /* collect all of the unique volume reference numbers        from the list of FSSpecs provided in the parameters. */    for (i=0; i&lt;dirCount; i++) {        Boolean found;        HParamBlockRec pb;            /* ensure the vRefNum is a volume            reference number */        pb.volumeParam.ioVRefNum = dirList[i].vRefNum;        pb.volumeParam.ioNamePtr = NULL;        pb.volumeParam.ioVolIndex = 0;        if ((err = PBHGetVInfoSync(&amp;pb)) != noErr) goto bail;        normalVol = pb.volumeParam.ioVRefNum;            /* make sure it's not already in the list */        for (found = false, j=0; j&lt;vCount; j++)            if (vRefNums[j] == normalVol) {                found = true;                break;            }            /* add the volume to the list */        if (!found &amp;&amp; vCount &lt; kMaxVols)            vRefNums[vCount++] = normalVol;    }        /* set up a session to use the volumes we found */    err = SetUpVolumeSession(&amp;newsession, vCount, vRefNums);    if (err != noErr) goto bail;        /* Here is the call that does the actual search,        storing the results in the search session. */    err = FBCDoQuerySearch(newsession, (char*)queryTxt,                    dirList, dirCount, maxHits, maxHitTerms);    if (err != noErr) goto bail;        /* save the result and return */    *session = newsession;    return noErr;bail:    if (newsession != NULL)        FBCDestroySearchSession(newsession);    return err;}</pre></TD></TR></TABLE></CENTER>          <p align="center"> <B>Listing 9</B>.  Searching a particular set of directories.</p>         <P>Here, volume reference numbers extracted from the array         of <CODE>FSSpec</CODE> records referring to target         directories provided as a parameter are used to configure         the volumes that will be searched by the search session.         Then, the list of target directories is passed to the         <CODE>FBCDoQuerySearch</CODE>.</P>    <A NAME=Anchor3511></A>        <H3>Retrieving Information from a Search Session</H3>                  <P>After a search is conducted using a search session, the         search session may contain information about one or more         matching files. Clients can access information about         individual hits including the file's <CODE>FSSpec</CODE>         record, the words that were matched in the file, the "score"         assigned to the file during the last search operation, and         additional information about the file. Listing 10         illustrates how one could obtain information about each hit         returned by a search.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OSErr (*HitProc) (FSSpec theDoc,                             float score,                             UInt32 nTerms,                             FBCWordList hitTerms);/* SampleHandleHits can be called after a search to enumerate    the search results.  For each search hit, the hitFileProc    function parameter is called with information describing    the target.  */OSErr SampleHandleHits (FBCSearchSession session,                                   HitProc hitFileProc) {    OSErr err;    UInt32 hitCount, i;    FSSpec targetDoc;    float targetScore;    FBCWordList targetTerms;    UInt32 numTerms;        /* set up locals, check parameters */    targetTerms = NULL;    if (hitFileProc == NULL) return paramErr;    if (session == NULL) return paramErr;        /* count the number of hits in this session */    err = FBCGetHitCount(session, &amp;hitCount);    if (err != noErr) goto bail;        /* iterate through the hits */    for (i = 0; i &lt; hitCount; i++) {            /* get the target document's FSSpec */        err = FBCGetHitDocument(session, i, &amp;targetDoc);        if (err != noErr) goto bail;            /* get the score for this document */        err = FBCGetHitScore(session, i, &amp;targetScore);        if (err != noErr) goto bail;            /* get a list of the words matched in            this document */        numTerms = maxHitTerms;        err = FBCGetMatchedWords(session, i, &amp;numTerms,                                            &amp;targetTerms);        if (err != noErr) goto bail;            /* call the call back routine provided as a            parameter to do something with the information. */        err = hitFileProc(&amp;targetDoc, score, numTerms,                                            targetTerms);        if (err != noErr) goto bail;            /* clean up before moving to the next iteration. */        FBCDestroyWordList(targetTerms, numTerms);        targetTerms = NULL;    }    return noErr;bail:    if (targetTerms != NULL)        FBCDestroyWordList(targetTerms, numTerms);    return err;}</pre></TD></TR></TABLE></CENTER>           <p align="center"><B>Listing 10</B>.  Enumerating all of the files found in a search session.</p><p><A HREF = "#top">Back to top</a></p><BR>    <A NAME=Anchor4006></A>         <H2>Find By Content Reference</H2>                  <P>This section provides a description of the CFM-based         interfaces to the PowerPC FBC library. PowerPC applications         using these routines link against the library named "Find By         Content" (without the quotes).</P><p><A HREF = "#top">Back to top</a></p><BR>    <A NAME=Anchor4500></A>             <H3>Data Types</H3>                  <P>FBC provides the following data types. Storage management         for these types is provided by the FBC library. Clients         should not attempt to allocate or deallocate these         structures using calls to the Memory Manager.</P>                         <P><B><CODE>FBCSearchSession</CODE></B></P>                         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct OpaqueFBCSearchSession* FBCSearchSession;</pre></TD></TR></TABLE></CENTER><BR><BR>                                    <blockquote><P>Search sessions created by FBC are referenced through         pointer variables of this type. The internal format of the         data referred to by this pointer is internal to the FBC         library. Clients should not attempt to access or modify this         data directly.</p></blockquote>          <P><B><CODE>FBCWordItem</CODE></B></P>                           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef char* FBCWordItem;</pre></TD></TR></TABLE></CENTER><BR><BR>       <blockquote><P>An ordinary C string. This type is used when retrieving information about hits from a search session.</p></blockquote>                 <P><B><CODE>FBCWordList</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef FBCWordItem* FBCWordList;</pre></TD></TR></TABLE></CENTER><BR><BR>                           <blockquote><P>An array of <CODE>WordItems</CODE>. This type is used         when retrieving information about hits from a search         session.</p></blockquote>         <p><A HREF = "#top">Back to top</a></p><BR>    <A NAME=Anchor4877></A>        <H3>Allocation and Initialization of Search Sessions</H3>                  <blockquote><P>The following routines can be used to allocate and         dispose of search sessions. Storage occupied by search         sessions is owned by the FBC library, and these are the only         routines that should be used to allocate, copy, and dispose         of search sessions.</p></blockquote>                          <P><B><CODE>FBCCreateSearchSession</CODE></B></P>                <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCCreateSearchSession(             FBCSearchSession* searchSession);</pre></TD></TR></TABLE></CENTER><BR><BR>                                    <blockquote><P><CODE>searchSession</CODE> points to a variable of            type <CODE>FBCSearchSession</CODE>.<br><br>    <CODE>FBCCreateSearchSession</CODE> allocates a new         search session and returns a reference to it in the variable         pointed to by <CODE>searchSession</CODE>.</p></blockquote>                 <P><B><CODE>FBCDestroySearchSession</CODE></B></P>                <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCDestroySearchSession(             FBCSearchSession theSession);</pre></TD></TR></TABLE></CENTER><BR><BR>                        <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR><BR>            <CODE>FBCDestroySearchSession</CODE> reclaims the storage         occupied by a search session. This will include any volume         configuration information and hits associated with the         search session.</p></blockquote>                 <P><B><CODE>FBCCloneSearchSession</CODE></B></P>                <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCCloneSearchSession(             FBCSearchSession original,             FBCSearchSession* clone);</pre></TD></TR></TABLE></CENTER><BR><BR>                                   <blockquote><P><CODE>original</CODE> is a pointer to a search            session.<BR><BR>            <CODE>clone</CODE> points to a variable of type            <CODE>FBCSearchSession.</CODE><BR>            <BR>                        <CODE>FBCCloneSearchSession</CODE> creates a new search         session and stores a pointer to it in the variable pointed         to by the clone parameter. Information from the original         search session that is copied to the new session includes         the volumes targeted by the search session and all of the         hits that may have been found in previous searches.</p></blockquote>         <p><A HREF = "#top">Back to top</a></p><BR>    <A NAME=Anchor5386></A>        <H3>Configuring Search Sessions</H3>                  <P>Search sessions can be configured to limit searches to a         particular set of volumes. These routines allow clients         access to the set of volumes that will be searched by         FBC.</P>                          <P><B><CODE>FBCAddAllVolumesToSession</CODE></B></P>            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCAddAllVolumesToSession(             FBCSearchSession theSession,             Boolean includeRemote);</pre></TD></TR></TABLE></CENTER><BR><BR>                           <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR><BR>            <CODE>includeRemote</CODE> is a <CODE>Boolean</CODE>            value.<BR>            <BR><CODE>FBCAddAllVolumesToSession</CODE> configures a         search session to search all mounted volumes that have been         indexed. If <CODE>includeRemote</CODE> is true, then remote         volumes will be included in the search session's list of         target volumes. Volumes that are not indexed are not added         to search session's list of target volumes.</p></blockquote>        <P><B><CODE>FBCSetSessionVolumes</CODE></B></P>               <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCSetSessionVolumes(             FBCSearchSession theSession,             const SInt16 *vRefNums,             UInt16 numVolumes);</pre></TD></TR></TABLE></CENTER><BR><BR>                      <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR><BR><CODE>vRefNums</CODE> is an pointer to an array of volume reference            numbers (16-bit integers).<BR><BR><CODE>numVolumes</CODE> is an integer value containing            the number of volume reference numbers in the array            <CODE>vRefNums</CODE>.<br>         <br><CODE>FBCSetSessionVolumes</CODE> allows clients to add         several volumes to the list of volumes targeted by a search         session in a single call.</p></blockquote>                 <BR>                 <P><B><CODE>FBCAddVolumeToSession</CODE></B></P>               <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCAddVolumeToSession(             FBCSearchSession theSession,             SInt16 vRefNum);</pre></TD></TR></TABLE></CENTER><BR><BR>                                    <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR><BR><CODE>vRefNum</CODE> is a volume reference number.<br>                  <br><CODE>FBCAddVolumeToSession</CODE> adds a volume to the         list of volumes that will be searched by the search session.         If the volume is not indexed, it will not be added to the         list.</p></blockquote>                 <P><B><CODE>FBCRemoveVolumeFromSession</CODE></B></P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCRemoveVolumeFromSession(             FBCSearchSession theSession,             SInt16 vRefNum);</pre></TD></TR></TABLE></CENTER><BR><BR>                     <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR><BR><CODE>vRefNum</CODE> is a volume reference number.<BR><BR><CODE>FBCRemoveVolumeFromSession</CODE> removes the         specified volume from the list of volumes that will be         searched by the search session.</p></blockquote>                 <P><B><CODE>FBCGetSessionVolumeCount</CODE></B></P>               <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCGetSessionVolumeCount(             FBCSearchSession theSession,             UInt16* count);</pre></TD></TR></TABLE></CENTER><BR><BR>                     <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR><BR><CODE>count</CODE> is a pointer to a 16-bit integer where the result is to be stored.<BR><BR><CODE>FBCGetSessionVolumeCount</CODE> returns, in         <CODE>*count</CODE>, the number of volumes in the list of         volumes that will be searched by the search session.</p></blockquote>                          <P><B><CODE>FBCGetSessionVolumes</CODE></B></P>        <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCGetSessionVolumes(             FBCSearchSession theSession,             SInt16 *vRefNums,             UInt16* numVolumes);</pre></TD></TR></TABLE></CENTER><BR><BR>                      <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR><BR><CODE>vRefNums</CODE> is a pointer to an array of volume reference            numbers (16-bit integers).<BR>            <BR><CODE>*numVolumes</CODE> is a pointer to a 16-bit            integer. On input, this will be the number of elements            that can be stored in <CODE>vRefNums</CODE>, and on            output it will be the number of elements actually stored            in <CODE>vRefNums</CODE>.<br><BR><CODE>FBCGetSessionVolumes</CODE> returns the list of         volumes that will be searched by the search session in the         array pointed to by <CODE>vRefNums</CODE>.         <CODE>*numVolumes</CODE> is set to the number of volume         reference numbers returned in the array.</p></blockquote><p><A HREF = "#top">Back to top</a></p><BR><BR>    <A NAME=Anchor5978></A>        <H3>Executing a Search</H3>                  <P>FBC provides three different routines for conducting         searches that are described in this section.</P>                 <BR>                 <P><B><CODE>FBCGetSessionVolumeCount</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCDoQuerySearch(             FBCSearchSession theSession,             char* queryText,             const FSSpec targetDirs[ ],             UInt32 numTargets,             UInt32 maxHits,             UInt32 maxHitWords);</pre></TD></TR></TABLE></CENTER><BR><BR>                        <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR><BR><CODE>queryText</CODE> refers to a C-style string            containing the search terms.<BR><BR><CODE>targetDirs</CODE> points to an array of            <CODE>FSSpec</CODE> records that refer to directories. If            <CODE>numTargets</CODE> is zero, then this parameter can            be set to <CODE>NULL</CODE>.<BR><BR><CODE>numTargets</CODE> contains the number            <CODE>FSSpec</CODE> records in the array pointed to by            <CODE>targetDirs</CODE>.<BR><BR><CODE>maxHits</CODE> the maximum number of hits that            should be returned.<BR><BR><CODE>maxHitWords</CODE> the maximum number of hit            words that will be reported.<BR><BR><CODE>FBCDoQuerySearch</CODE> performs a search based on         the search terms found in <CODE>queryText</CODE>. If the         <CODE>targetDirs</CODE> parameter is present         (<CODE>numTargets</CODE> is not zero), then only files         residing in the directories specified in         <CODE>targetDirs</CODE> will be included in the hits found         by the search.</p></blockquote>        <P><B><CODE>FBCDoExampleSearch</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCDoExampleSearch(             FBCSearchSession theSession,             const UInt32* exampleHitNums,             UInt32 numExamples,             const FSSpec targetDirs[ ],             UInt32 numTargets,             UInt32 maxHits,             UInt32 maxHitWords);</pre></TD></TR></TABLE></CENTER><BR><BR>                            <blockquote><P><CODE>theSession</CODE> contains a pointer to a search            session. This session must contain a hit list generated            by a previous search.<BR><BR><CODE>exampleHitNums</CODE> points to an array of 32            bit integers.<BR><BR><CODE>numExamples</CODE> contains the number of            integers in the array pointed to by            <CODE>exampleHitNums</CODE>.<BR><BR><CODE>targetDirs</CODE> points to an array of            <CODE>FSSpec</CODE> records that refer to directories. If            <CODE>numTargets</CODE> is zero, then this parameter can            be set to <CODE>NULL</CODE>.<BR><BR><CODE>numTargets</CODE> contains the number            <CODE>FSSpec</CODE> records in the array pointed to by            <CODE>targetDirs</CODE>.<BR><BR><CODE>maxHits</CODE> the maximum number of hits that            should be returned.<BR><BR><CODE>maxHitWords</CODE> the maximum number of hit            words that will be reported.<br>                  <br><CODE>FBCDoExampleSearch</CODE> performs an example-based         or "similarity" search using hits found in a previous search         as examples. <CODE>exampleHitNums</CODE> points to an array         of long integers containing the indexes of one or more of         the hits that are to be used as example files. If the         <CODE>targetDirs</CODE> parameter is present         (<CODE>numTargets</CODE> is not zero), then only files         residing in the directories specified in         <CODE>targetDirs</CODE> will be included in the hits found         by the search.</p></blockquote>            <P><B><CODE>FBCBlindExampleSearch</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCBlindExampleSearch(             FSSpec examples[ ],             UInt32 numExamples,             const FSSpec targetDirs[ ],             UInt32 numTargets,             UInt32 maxHits,             UInt32 maxHitWords,             Boolean allIndexes,             Boolean includeRemote,             FBCSearchSession* theSession);</pre></TD></TR></TABLE></CENTER><BR><BR>                                        <blockquote><P><CODE>examples</CODE> is a pointer to an array of            <CODE>FSSpec</CODE> records that refer to files. FBC will            search for files that are similar to these files.<BR><BR><CODE>numExamples</CODE> contains the number of            <CODE>FSSpec</CODE> records in the array pointed to by            examples.<BR><BR><CODE>targetDirs</CODE> points to an array of            <CODE>FSSpec</CODE> records referring to directories. If            <CODE>targetDirs</CODE> is not <CODE>NULL</CODE> and            <CODE>numTargets</CODE> is not zero, then only files            residing in these directories will be included in the hit            list returned by the search.<BR><BR><CODE>targetDirs</CODE> points to an array of            <CODE>FSSpec</CODE> records that refer to directories. If            <CODE>numTargets</CODE> is zero, then this parameter can            be set to <CODE>NULL</CODE>.<BR>        <BR><CODE>numTargets</CODE> contains the number            <CODE>FSSpec</CODE> records in the array pointed to by            <CODE>targetDirs</CODE>.<BR>            <BR><CODE>maxHits</CODE> the maximum number of hits that            should be returned.<BR>            <BR><CODE>maxHitWords</CODE> the maximum number of hit            words that will be reported.<BR>            <BR><CODE>includeRemote</CODE> is a <CODE>Boolean</CODE>            value.<BR>            <BR><CODE>theSession</CODE> points to a variable of type            <CODE>FBCSearchSession</CODE> that will be created by            this routine.<br>                  <br><CODE>FBCBlindExampleSearch</CODE> creates a new search         session and conducts a similarity search using the files         referred to in the array of <CODE>FSSpec</CODE> records         provided in the examples parameter. If the         <CODE>targetDirs</CODE> parameter is present         (<CODE>numTargets</CODE> is not zero), then only files         residing in the directories specified in         <CODE>targetDirs</CODE> will be included in the hits found         by the search. If <CODE>includeRemote</CODE> is true, then         remote volumes will be included in the search session's list         of target volumes.<br>                  <br>If any of the example files are not indexed, then the         search will proceed with the remainder of the files, and the         error code <CODE>kFBCsomeFilesNotIndexed</CODE> will be         returned. In this case, the search session will be created         and a reference to it will be returned in         <CODE>*theSession</CODE>.</p></blockquote>         <p><A HREF = "#top">Back to top</a></p><BR>    <A NAME=Anchor6825></A>        <H3>Getting Information About Hits</H3>                  <P>Once a search is complete, a search session will contain         a list of hits that were found during the search. The         routines described in this section allow clients to access         information about hits stored in a search session. Hit         records are indexed 0 through count-1.</P>                          <P><B><CODE>FBCGetHitCount</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCGetHitCount(             FBCSearchSession theSession,             UInt32* count);</pre></TD></TR></TABLE></CENTER><BR><BR>                                    <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR>            <BR><CODE>count</CODE> is a pointer to a 32-bit            integer.<br>                          <br><CODE>FBCGetHitCount</CODE> sets the variable pointed to         by <CODE>count</CODE> to the number of hits in the search         session. Hit records are indexed 0 through count-1.</p></blockquote>                 <P><B><CODE>FBCGetHitDocument</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCGetHitDocument(             FBCSearchSession theSession,             UInt32 hitNumber,             FSSpec* theDocument);</pre></TD></TR></TABLE></CENTER><BR><BR>                        <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR>            <BR><CODE>hitNumber</CODE> is an index value referring to            a hit record in the search session.<BR>            <BR><CODE>theDocument</CODE> is a pointer to a            <CODE>FSSpec</CODE> record.<br>                 <br><CODE>FBCGetHitDocument</CODE> returns the         <CODE>FSSpec</CODE> record for the hit in the search session         whose index is <CODE>hitNumber</CODE>.</p></blockquote>                 <BR>                 <P><B><CODE>FBCGetHitScore</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCGetHitScore(             FBCSearchSession theSession,             UInt32 hitNumber,             float* score);</pre></TD></TR></TABLE></CENTER><BR><BR>                                    <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR>            <BR><CODE>hitNumber</CODE> is an index value referring to            a hit record in the search session.<BR>            <BR><CODE>score</CODE> is a pointer to a variable of type            <CODE>float</CODE>.<br>                  <br><CODE>FBCGetHitScore</CODE> returns relevance score         assigned to the hit in the search session whose index is         <CODE>hitNumber</CODE>. The score is a direct measure of the         document's relevance to the search criteria in the context         of this particular search. Scores are normalized to the         range 0.0 - 1.0, and the most relevant hit from every search         always has a score of 1.0.</p></blockquote>                 <BR>                 <P><B><CODE>FBCGetMatchedWords</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCGetMatchedWords(             FBCSearchSession theSession,             UInt32 hitNumber,             UInt32* wordCount,             FBCWordList* list);</pre></TD></TR></TABLE></CENTER><BR><BR><br>                             <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR>            <BR><CODE>hitNumber</CODE> is an index value referring to            a hit record in the search session.<BR>            <BR><CODE>wordCount</CODE> is a pointer to a 32-bit            integer.<BR>            <BR><CODE>list</CODE> is a pointer to a variable of type            <CODE>FBCWordList</CODE>.<br>                     <br><CODE>FBCGetMatchedWords</CODE> returns a list of matched         words for the hit in the search session whose index is         <CODE>hitNumber</CODE>. This list of words illustrates why         the hit was returned. On return, <CODE>*list</CODE> will         contain a pointer to a word list structure and         <CODE>*wordCount</CODE> will be set to the number of entries         in that structure. Be sure to call         <CODE>FBCDestroyWordList</CODE> to dispose of the structure         when you are done with it.<br>                  <br>The matched words for a hit are stored in the hit itself,         so retrieving them is fast.</p></blockquote>                 <P><B><CODE>FBCGetTopicWords</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCGetTopicWords(             FBCSearchSession theSession,             UInt32 hitNumber,             UInt32* wordCount,             FBCWordList* list);</pre></TD></TR></TABLE></CENTER><BR><BR>                <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session.<BR>            <BR><CODE>hitNumber</CODE> is an index value referring to            a hit record in the search session.<BR>            <BR><CODE>wordCount</CODE> is a pointer to a 32-bit            integer.<BR>            <BR><CODE>list</CODE> is a pointer to a variable of type            <CODE>FBCWordList</CODE>.<br>                     <br><CODE>FBCGetTopicWords</CODE> returns a list of topical         words for the hit in the search session whose index is         <CODE>hitNumber</CODE>. This list of words provides a clue         about "what the document is about." On return,         <CODE>*list</CODE> will contain a pointer to a word list         structure and <CODE>*wordCount</CODE> will be set to the         number of entries in that structure. Be sure to call         <CODE>FBCDestroyWordList</CODE> to dispose of the structure         when you are done with it.<br>                  <br>The list of topical words for a particular hit must be         generated through the index file, so this call is         significantly slower than         <CODE>FBCGetMatchedWords</CODE>.</p></blockquote>                       <P><B><CODE>FBCDestroyWordList</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCDestroyWordList(             FBCWordList theList,             UInt32 wordCount);</pre></TD></TR></TABLE></CENTER><BR><BR>                            <blockquote><P><CODE>theList</CODE> is a pointer to a word list.<BR>            <BR><CODE>wordCount</CODE> is the number of words in the            list.<br>         <br><CODE>FBCDestroyWordList</CODE> disposes of a word list         allocated by either <CODE>FBCGetMatchedWords</CODE> or         <CODE>FBCGetTopicWords</CODE>.</p></blockquote>                 <P><B><CODE>FBCReleaseSessionHits</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCReleaseSessionHits(             FBCSearchSession theSession);</pre></TD></TR></TABLE></CENTER><BR><BR>                             <blockquote><P><CODE>theSession</CODE> is a pointer to a search            session. This session may contain hits generated by a            search.<br>                     <br><CODE>FBCReleaseSessionHits</CODE> deallocates any         information stored regarding hits from the last search from         the search session. Volume configuration information is         retained and once this call completes, the search session is         ready to perform another search.</p></blockquote>         <p><A HREF = "#top">Back to top</a></p><BR>    <A NAME=Anchor7359></A>        <H3>Summarizing Text</H3>                  <P>This call produces a summary containing the "most         relevant" sentences found in the input text.</P>        <P><B><CODE>FBCSummarize</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCSummarize(             void* inBuf,             UInt32 inLength,             void* outBuf,             UInt32* outLength,             UInt32* numSentences);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <blockquote><P><CODE>inBuf</CODE> points to the text to be            summarized.<BR>            <BR><CODE>inLength</CODE> is the length of the text            pointed to by <CODE>inBuf</CODE>.<BR>            <BR><CODE>outBuf</CODE> points to a buffer where the            summary should be stored.<BR>            <BR><CODE>outLength</CODE> is a pointer to a 32-bit            integer. On input, this value is set to the size of the            buffer pointed to by <CODE>outBuf</CODE>. On output, it            is set to the actual length of the data stored in the            buffer pointed to by <CODE>outBuf</CODE>.<BR>            <BR><CODE>numSentences</CODE> is a pointer to a 32-bit            integer. On input, this value is the maximum number of            sentences desired in the summary. On output, it is set to            the actual number of sentences generated. If            <CODE>numSentences</CODE> is 0 on input, FBC takes the            number of sentences in the input buffer and divides by            10. If the result is 0, then the value 1 is used as the            maximum; otherwise, if the result is greater than 10,            then the value 10 is used as the maximum.</p></blockquote><p><A HREF = "#top">Back to top</a></p>        <A NAME=Anchor7686></A>             <H3>Getting Information About Volumes</H3>                  <P>FBC provides the following utility routines for accessing         information about volumes.</P>        <P><B><CODE>FBCVolumeIsIndexed</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>Boolean FBCVolumeIsIndexed (SInt16 theVRefNum);</pre></TD></TR></TABLE></CENTER><BR><BR>                     <blockquote><P><CODE>theVRefNum</CODE> is a volume reference            number.<br>                 <br><CODE>FBCVolumeIsIndexed</CODE> returns <CODE>true</CODE>         if the indicated volume has been indexed.</p></blockquote>                      <P><B><CODE>FBCVolumeIsRemote</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>Boolean FBCVolumeIsRemote(SInt16 theVRefNum);</pre></TD></TR></TABLE></CENTER><BR><BR>                                <blockquote><P><CODE>theVRefNum</CODE> is a volume reference            number.<br>                  <br><CODE>FBCVolumeIsRemote</CODE> returns <CODE>true</CODE>         if the indicated volume is located on a remote server.         Clients may want to exclude networked volumes from searches         to avoid network delays.</p></blockquote>                   <P><B><CODE>FBCVolumeIndexTimeStamp</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCVolumeIndexTimeStamp(SInt16 theVRefNum,             UInt32* timeStamp);</pre></TD></TR></TABLE></CENTER><BR><BR>                <blockquote><P><CODE>theVRefNum</CODE> is a volume reference number.            <BR><CODE>timeStamp</CODE> is a pointer to an unsigned 32            bit integer.<br>                     <br><CODE>FBCVolumeIndexTimeStamp</CODE> will return the time         when the volume's index was last updated. The value returned         in <CODE>timeStamp</CODE> is the same format as values         returned by <CODE>GetDateTime</CODE>.</p></blockquote>                  <P><B><CODE>FBCVolumeIndexPhysicalSize</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCVolumeIndexPhysicalSize(SInt16 theVRefNum,             UInt32* size);</pre></TD></TR></TABLE></CENTER><BR><BR>                                 <blockquote><P><CODE>theVRefNum</CODE> is a volume reference number.            <BR><CODE>size</CODE> is a pointer to an unsigned 32            bit integer.</p></blockquote>        <br>                  <P><CODE>FBCVolumeIndexPhysicalSize</CODE> returns the size         of the volume's index file in bytes.</P>         <p><A HREF = "#top">Back to top</a></p>        <A NAME=IndexingThings></A>        <H3>Indexing Volumes, Folders, and Files</H3>                 <P>A new API has been added to Find By Content allowing for the        immediate indexing of new or altered files. The        new routine is declared as follows:<BR><BR></P>                 <P><B><CODE>FBCIndexItems</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCIndexItems(     FSSpecArrayPtr theItems,     UInt32 itemCount);</pre></TD></TR></TABLE></CENTER><BR><BR><blockquote><P><CODE>theItems</CODE> is a pointer to an array of file specification records referring to the files to be indexed.            <BR><CODE>itemCount</CODE> is the number of items in                the array of file specification records.<BR>                        <BR><CODE>FBCIndexItems</CODE> indexes (or        re-indexes) the files referred to in the array of file        specification records passed as a pointer in the first        parameter. If the volume containing a file already has an        index, the document is added or re-indexed; and, if the        volume does not contain an index, a new index is created.<BR>                <BR>Normally you will call <CODE>FBCIndexItems</CODE> after        saving a file (or updating a file) on a volume containing        an index. This will allow users to keep their indexes up        to date without any additional effort. For more        information about how to determine if a volume contains        an index, refer to the Sherlock technote.</p></blockquote>            <P><B>COMPATIBILITY NOTE</B><BR>            The symbol <CODE>FBCIndexItems</CODE> is not exported from the original version of the "Find By Content" shared library.  Applications wishing to use this routine should weak link to this symbol and then test for it's presence before attempting to call it.  Techniques for doing this are described in Technote <A HREF = "tn1083.html">TN1083,"Weak-Linking to a CFM-based Shared Library."</A></P>                         <p><A HREF = "#top">Back to top</a></p>    <A NAME=Anchor8305></A>             <H3>Reserving Heap Space</H3>                  <P>Clients of FBC can reserve space in their heap zone for         their callback routine before conducting a search.</P>        <P><B><CODE>FBCSetHeapReservation</CODE></B></P>        <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>void FBCSetHeapReservation(UInt32 bytes);</pre></TD></TR></TABLE></CENTER><BR><BR>                        <blockquote><P><CODE>bytes</CODE> is an integer value containing the number of bytes that should be reserved.<BR>                     <BR><CODE>FBCSetHeapReservation</CODE> sets the number of         bytes FBC should guarantee are available in the client         application's heap whenever the client's call back routine         is called during searches. If you do not explicitly reserve         heap space by calling this routine, then 200K will be         reserved for you.</p></blockquote><p><A HREF = "#top">Back to top</a></p>    <A NAME=Anchor8666></A>    <H3>Application-Defined Routine</H3>                  <P>Clients can provide a routine that will be called         periodically during searches. This routine will provide         clients with both information about the status of a search,         and opportunity to cancel a search before it is         complete.</P>                  <P>Call back routines are defined as follows:</P>                         <BR>                 <P><B><CODE>FBCCallbackProcPtr</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef Boolean (*FBCCallbackProcPtr)(             UInt16 phase,             float percentDone,             void *data);</pre></TD></TR></TABLE></CENTER><BR><BR>                        <blockquote><P><CODE>phase</CODE> is a 16-bit integer containing one            of the following constants indicating the current status            of the search:</p></blockquote>                    <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    enum {        kFBCphSearching             = 6,        kFBCphMakingAccessAccessor  = 7,        kFBCphAccessWaiting         = 8,        kFBCphSummarizing           = 9,        kFBCphIdle                  = 10,        kFBCphCanceling             = 11    };</pre></TD></TR></TABLE></CENTER><BR><BR>            <blockquote><P><CODE>percentDone</CODE> is a progress value in the            range 0.0 - 1.0            <BR><CODE>data</CODE> contains the same value provided to            <CODE>FBCSetCallback</CODE> in the data parameter.</p></blockquote>                   <P>To avoid locking up the system while a search is in         progress, the callback should either directly or indirectly         call <CODE>WaitNextEvent</CODE>.</P>                  <P>An ongoing search will be canceled if the call back         function returns <CODE>true</CODE>.</P>        <P><B><CODE>FBCSetCallback</CODE></B></P>                            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>void FBCSetCallback(FBCCallbackProcPtr fn, void* data);</pre></TD></TR></TABLE></CENTER><BR><BR><blockquote><P><CODE>fn</CODE> is a pointer to your call back            function.<BR>            <CODE>data</CODE> is a value passed through to your            call back function.</p></blockquote>                 <P><CODE>FBCSetCallback</CODE> sets the call back function         that will be called during searches. If a client does not         define a call back function, then the default callback         function is used. The default call back function calls         <CODE>WaitNextEvent</CODE> and returns         <CODE>false</CODE>.</P>        <p><A HREF = "#top">Back to top</a></p>    <A NAME=Anchor9490></A>    <H3>Find By Content C Summary</H3>             <B>Constants</B>                 <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    gestaltFBCIndexingState      = 'fbci',    gestaltFBCindexingSafe       = 0,    gestaltFBCindexingCritical   = 1};enum {    gestaltFBCVersion            = 'fbcv',    gestaltFBCCurrentVersion     = 0x0011};enum { /* error codes */    kFBCvTwinExceptionErr     = -30500,                    /* miscellaneous error */    kFBCnoIndexesFound        = -30501,    kFBCallocFailed           = -30502,                    /*probably low memory*/    kFBCbadParam              = -30503,    kFBCfileNotIndexed        = -30504,    kFBCbadIndexFile          = -30505,                    /*bad FSSpec, or bad data in file*/    kFBCtokenizationFailed    = -30512,                    /*couldn't read from document or query*/    kFBCindexNotFound         = -30518,    kFBCnoSearchSession       = -30519,    kFBCaccessCanceled        = -30521,    kFBCindexNotAvailable     = -30523,    kFBCsearchFailed          = -30524,    kFBCsomeFilesNotIndexed   = -30525,    kFBCillegalSessionChange  = -30526,                    /*tried to add/remove vols */                    /*to a session  that has hits*/    kFBCanalysisNotAvailable  = -30527,    kFBCbadIndexFileVersion   = -30528,    kFBCsummarizationCanceled = -30529,    kFBCbadSearchSession      = -30531,    kFBCnoSuchHit             = -30532};enum { /* codes sent to the callback routine */    kFBCphSearching             = 6,    kFBCphMakingAccessAccessor  = 7,    kFBCphAccessWaiting         = 8,    kFBCphSummarizing           = 9,    kFBCphIdle                  = 10,    kFBCphCanceling             = 11};</pre></TD></TR></TABLE></CENTER><BR><BR>        <B>Data Types</B>             <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    /* A collection of state information for searching*/typedef struct OpaqueFBCSearchSession* FBCSearchSession;    /* An ordinary C string (used for hit/doc terms)*/typedef char* FBCWordItem;    /* An array of WordItems*/typedef FBCWordItem* FBCWordList;</pre></TD></TR></TABLE></CENTER><BR><BR>            <B>Allocation and Initialization of Search Sessions</B>             <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCCreateSearchSession(             FBCSearchSession* searchSession);OSErr FBCDestroySearchSession(             FBCSearchSession theSession);OSErr FBCCloneSearchSession(             FBCSearchSession original,             FBCSearchSession* clone);</pre></TD></TR></TABLE></CENTER><BR><BR>    <B>Configuring Search Sessions</B>             <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCAddAllVolumesToSession(             FBCSearchSession theSession,             Boolean includeRemote);OSErr FBCSetSessionVolumes(             FBCSearchSession theSession,             const SInt16 vRefNums[ ],             UInt16 numVolumes);OSErr FBCAddVolumeToSession(             FBCSearchSession theSession,             SInt16 vRefNum);OSErr FBCRemoveVolumeFromSession(             FBCSearchSession theSession,             SInt16 vRefNum);OSErr FBCGetSessionVolumeCount(             FBCSearchSession theSession,             UInt16* count);OSErr FBCGetSessionVolumes(             FBCSearchSession theSession,             SInt16 vRefNums[ ],             UInt16* numVolumes);</pre></TD></TR></TABLE></CENTER><BR><BR>    <B>Executing a Search</B>             <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCDoQuerySearch(             FBCSearchSession theSession,             char* queryText,             const FSSpec targetDirs[ ],             UInt32 numTargets,             UInt32 maxHits,             UInt32 maxHitWords);OSErr FBCDoExampleSearch(             FBCSearchSession theSession,             const UInt32* exampleHitNums,             UInt32 numExamples,             const FSSpec targetDirs[ ],             UInt32 numTargets,             UInt32 maxHits,             UInt32 maxHitWords);OSErr FBCBlindExampleSearch(             FSSpec examples[ ],             UInt32 numExamples,             const FSSpec targetDirs[ ],             UInt32 numTargets,             UInt32 maxHits,             UInt32 maxHitWords,             Boolean allIndexes,             Boolean includeRemote,             FBCSearchSession* theSession);</pre></TD></TR></TABLE></CENTER><BR><BR>    <B>Getting Information About Hits</B>             <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCGetHitCount(             FBCSearchSession theSession,             UInt32* count);OSErr FBCGetHitDocument(             FBCSearchSession theSession,             UInt32 hitNumber,             FSSpec* theDocument);OSErr FBCGetHitScore(             FBCSearchSession theSession,             UInt32 hitNumber,             float* score);OSErr FBCGetMatchedWords(             FBCSearchSession theSession,             UInt32 hitNumber,             UInt32* wordCount,             FBCWordList* list);OSErr FBCGetTopicWords(             FBCSearchSession theSession,             UInt32 hitNumber,             UInt32* wordCount,             FBCWordList* list);OSErr FBCDestroyWordList(             FBCWordList theList,             UInt32 wordCount);OSErr FBCReleaseSessionHits(             FBCSearchSession theSession);</pre></TD></TR></TABLE></CENTER><BR><BR>    <B>Summarizing Text</B>             <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCSummarize(             void* inBuf,             UInt32 inLength,             void* outBuf,             UInt32* outLength,             UInt32* numSentences);</pre></TD></TR></TABLE></CENTER><BR><BR>     <B>Getting Information About Volumes</B>             <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>Boolean FBCVolumeIsIndexed (SInt16 theVRefNum);Boolean FBCVolumeIsRemote(SInt16 theVRefNum);OSErr FBCVolumeIndexTimeStamp(SInt16 theVRefNum,             UInt32* timeStamp);OSErr FBCVolumeIndexPhysicalSize(SInt16 theVRefNum,             UInt32* size);</pre></TD></TR></TABLE></CENTER><BR><BR>        <B>Indexing files, folders, and volumes</B>             <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FBCIndexItems(             FSSpecArrayPtr theItems,             UInt32 itemCount);</pre></TD></TR></TABLE></CENTER><BR><BR>        <B>Reserving Heap Space</B>             <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>void FBCSetHeapReservation(UInt32 bytes);</pre></TD></TR></TABLE></CENTER><BR><BR>    <br>             <B>Application-Defined Routine</B>             <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef Boolean (*FBCCallbackProcPtr)(             UInt16 phase,             float percentDone,             void *data);void FBCSetCallback(FBCCallbackProcPtr fn, void* data);</pre></TD></TR></TABLE></CENTER><BR><BR>        <p><A HREF = "#top">Back to top</a></p><A NAME="References"></A><H2>References</H2><p>Technote <A HREF = "tn1141.html">TN1141, "Extending and Controlling Sherlock"</A></p><p>Technote <A HREF = "tn1181.html">TN1181, "Sherlock's Find by Content Text Extractor Plug-ins."</A></p>                  <p><A HREF = "#top">Back to top</a> </p><A NAME="Downloads"></A> <h2>Downloadables</h2><center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600"> <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P></TD><td align="left">   <p>Acrobat version of this Note (96K).</P></TD><td width=60 align=left>   <p><A HREF="pdf/tn1180.pdf">Download</A></P></TD>  </TR> </table></center><BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1180.html%3Fid%3DDTS10003019-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1180.html%3Fid%3DDTS10003019-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1180.html%3Fid%3DDTS10003019-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>