<html><head><title>Mac OS X
 Manual Page For ipfw(8)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/8/ipfw" title="Mac OS X
 Manual Page for ipfw(8)"><!-- headerDoc=man; indexgroup=Section 8; uid="//apple_ref/doc/man/8/ipfw"; name=ipfw(8) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
IPFW(8)                   BSD System Manager's Manual                  IPFW(8)

<b>NAME</b>
     <b>ipfw</b> -- IP firewall and traffic shaper control program

<b>SYNOPSIS</b>
     <b>ipfw</b> [<b>-cq</b>] <b>add</b> <u>rule</u>
     <b>ipfw</b> [<b>-acdefnNStT</b>] {<b>list</b> | <b>show</b>} [<u>rule</u> | <u>first-last</u> <u>...</u>]
     <b>ipfw</b> [<b>-f</b> | <b>-q</b>] <b>flush</b>
     <b>ipfw</b> [<b>-q</b>] {<b>delete</b> | <b>zero</b> | <b>resetlog</b>} [<b>set</b>] [<u>number</u> <u>...</u>]
     <b>ipfw</b> <b>enable</b> {<b>firewall</b> | <b>one_pass</b> | <b>debug</b> | <b>verbose</b> | <b>dyn_keepalive</b>}
     <b>ipfw</b> <b>disable</b> {<b>firewall</b> | <b>one_pass</b> | <b>debug</b> | <b>verbose</b> | <b>dyn_keepalive</b>}

     <b>ipfw</b> <b>set</b> [<b>disable</b> <u>number</u> <u>...</u>] [<b>enable</b> <u>number</u> <u>...</u>]
     <b>ipfw</b> <b>set</b> <b>move</b> [<b>rule</b>] <u>number</u> <b>to</b> <u>number</u>
     <b>ipfw</b> <b>set</b> <b>swap</b> <u>number</u> <u>number</u>
     <b>ipfw</b> <b>set</b> <b>show</b>

     <b>ipfw</b> {<b>pipe</b> | <b>queue</b>} <u>number</u> <b>config</b> <u>config-options</u>
     <b>ipfw</b> [<b>-s</b> [<u>field</u>]] {<b>pipe</b> | <b>queue</b>} {<b>delete</b> | <b>list</b> | <b>show</b>} [<u>number</u> <u>...</u>]

     <b>ipfw</b> [<b>-cnNqS</b>] [<b>-p</b> <u>preproc</u> [<u>preproc-flags</u>]] <u>pathname</u>

<b>DESCRIPTION</b>
     The <b>ipfw</b> utility is the user interface for controlling the <!-- a -->ipfw(4)<!-- /a --> firewall and the <a href="../man4/dummynet.4.html#//apple_ref/doc/man/4/dummynet">dummynet(4)</a> traffic
     shaper in FreeBSD.

     An <b>ipfw</b> configuration, or <u>ruleset</u>, is made of a list of <u>rules</u> numbered from 1 to 65535.  Packets are
     passed to <b>ipfw</b> from a number of different places in the protocol stack (depending on the source and
     destination of the packet, it is possible that <b>ipfw</b> is invoked multiple times on the same packet).  The
     packet passed to the firewall is compared against each of the rules in the firewall <u>ruleset</u>.  When a
     match is found, the action corresponding to the matching rule is performed.

     Depending on the action and certain system settings, packets can be reinjected into the firewall at
     some rule after the matching one for further processing.

     An <b>ipfw</b> ruleset always includes a <u>default</u> rule (numbered 65535) which cannot be modified or deleted,
     and matches all packets.  The action associated with the <u>default</u> rule can be either <b>deny</b> or <b>allow</b>
     depending on how the kernel is configured.

     If the ruleset includes one or more rules with the <b>keep-state</b> or <b>limit</b> option, then <b>ipfw</b> assumes a
     <u>stateful</u> behaviour, i.e. upon a match it will create dynamic rules matching the exact parameters
     (addresses and ports) of the matching packet.

     These dynamic rules, which have a limited lifetime, are checked at the first occurrence of a
     <b>check-state</b>, <b>keep-state</b> or <b>limit</b> rule, and are typically used to open the firewall on-demand to legiti-<font color="#ffffff" class="whiteout">mate&nbsp;legitimate</font>
     mate traffic only.  See the <u>STATEFUL</u> <u>FIREWALL</u> and <u>EXAMPLES</u> Sections below for more information on the
     stateful behaviour of <b>ipfw</b>.

     All rules (including dynamic ones) have a few associated counters: a packet count, a byte count, a log
     count and a timestamp indicating the time of the last match.  Counters can be displayed or reset with
     <b>ipfw</b> commands.

     Rules can be added with the <b>add</b> command; deleted individually or in groups with the <b>delete</b> command, and
     globally (except those in set 31) with the <b>flush</b> command; displayed, optionally with the content of the
     counters, using the <b>show</b> and <b>list</b> commands.  Finally, counters can be reset with the <b>zero</b> and <b>resetlog</b>
     commands.

     Also, each rule belongs to one of 32 different <u>sets</u> , and there are <b>ipfw</b> commands to atomically manipu-<font color="#ffffff" class="whiteout">late&nbsp;manipulate</font>
     late sets, such as enable, disable, swap sets, move all rules in a set to another one, delete all rules
     in a set. These can be useful to install temporary configurations, or to test them.  See Section <u>SETS</u>
     <u>OF</u> <u>RULES</u> for more information on <u>sets</u>.

     The following options are available:

     <b>-a</b>      While listing, show counter values.  The <b>show</b> command just implies this option.

     <b>-c</b>      When entering or showing rules, print them in compact form, i.e. without the optional "ip from
             any to any" string when this does not carry any additional information.

     <b>-d</b>      While listing, show dynamic rules in addition to static ones.

     <b>-e</b>      While listing, if the <b>-d</b> option was specified, also show expired dynamic rules.

     <b>-f</b>      Don't ask for confirmation for commands that can cause problems if misused, i.e. <b>flush</b>.  If
             there is no tty associated with the process, this is implied.

     <b>-n</b>      Only check syntax of the command strings, without actually passing them to the kernel.

     <b>-N</b>      Try to resolve addresses and service names in output.

     <b>-q</b>      While <b>add</b>ing, <b>zero</b>ing, <b>resetlog</b>ging or <b>flush</b>ing, be quiet about actions (implies <b>-f</b>).  This is
             useful for adjusting rules by executing multiple <b>ipfw</b> commands in a script (e.g.,
             `sh /etc/rc.firewall'), or by processing a file of many <b>ipfw</b> rules across a remote login ses-<font color="#ffffff" class="whiteout">sion.&nbsp;session.</font>
             sion.  If a <b>flush</b> is performed in normal (verbose) mode (with the default kernel configura-<font color="#ffffff" class="whiteout">tion),&nbsp;configuration),</font>
             tion), it prints a message.  Because all rules are flushed, the message might not be delivered
             to the login session, causing the remote login session to be closed and the remainder of the
             ruleset to not be processed.  Access to the console would then be required to recover.

     <b>-S</b>      While listing rules, show the <u>set</u> each rule belongs to.  If this flag is not specified, dis-<font color="#ffffff" class="whiteout">abled&nbsp;disabled</font>
             abled rules will not be listed.

     <b>-s</b> [<u>field</u>]
             While listing pipes, sort according to one of the four counters (total or current packets or
             bytes).

     <b>-t</b>      While listing, show last match timestamp (converted with ctime()).

     <b>-T</b>      While listing, show last match timestamp (as seconds from the epoch).  This form can be more
             convenient for postprocessing by scripts.

     To ease configuration, rules can be put into a file which is processed using <b>ipfw</b> as shown in the last
     synopsis line.  An absolute <u>pathname</u> must be used.  The file will be read line by line and applied as
     arguments to the <b>ipfw</b> utility.

     Optionally, a preprocessor can be specified using <b>-p</b> <u>preproc</u> where <u>pathname</u> is to be piped through.
     Useful preprocessors include <a href="../man1/cpp.1.html#//apple_ref/doc/man/1/cpp">cpp(1)</a> and <a href="../man1/m4.1.html#//apple_ref/doc/man/1/m4">m4(1)</a>.  If <u>preproc</u> doesn't start with a slash (`/') as its
     first character, the usual PATH name search is performed.  Care should be taken with this in environ-<font color="#ffffff" class="whiteout">ments&nbsp;environments</font>
     ments where not all file systems are mounted (yet) by the time <b>ipfw</b> is being run (e.g. when they are
     mounted over NFS).  Once <b>-p</b> has been specified, any additional arguments as passed on to the preproces-<font color="#ffffff" class="whiteout">sor&nbsp;preprocessor</font>
     sor for interpretation.  This allows for flexible configuration files (like conditionalizing them on
     the local hostname) and the use of macros to centralize frequently required arguments like IP
     addresses.

     The <b>ipfw</b> <b>pipe</b> and <b>queue</b> commands are used to configure the traffic shaper, as shown in the <u>TRAFFIC</u>
     <u>SHAPER</u> <u>(DUMMYNET)</u> <u>CONFIGURATION</u> Section below.

     If the world and the kernel get out of sync the <b>ipfw</b> ABI may break, preventing you from being able to
     add any rules.  This can adversely effect the booting process.  You can use <b>ipfw</b> <b>disable</b> <b>firewall</b> to
     temporarily disable the firewall to regain access to the network, allowing you to fix the problem.

<b>PACKET</b> <b>FLOW</b>
     A packet is checked against the active ruleset in multiple places in the protocol stack, under control
     of several sysctl variables.  These places and variables are shown below, and it is important to have
     this picture in mind in order to design a correct ruleset.

                 ^     to upper layers   V
                 |                       |
                 +-----------&gt;-----------+
                 ^                       V
            [ip_input]              [ip_output]   net.inet.ip.fw.enable=1
                 |                       |
                 ^                       V
           [ether_demux]    [ether_output_frame]  net.link.ether.ipfw=1
                 |                       |
                 +--&gt;--[bdg_forward]--&gt;--+        net.link.ether.bridge_ipfw=1
                 ^                       V
                 |      to devices       |

     As can be noted from the above picture, the number of times the same packet goes through the firewall
     can vary between 0 and 4 depending on packet source and destination, and system configuration.

     Note that as packets flow through the stack, headers can be stripped or added to it, and so they may or
     may not be available for inspection.  E.g., incoming packets will include the MAC header when <b>ipfw</b> is
     invoked from <b>ether_demux()</b>, but the same packets will have the MAC header stripped off when <b>ipfw</b> is
     invoked from <b>ip_input()</b>.

     Also note that each packet is always checked against the complete ruleset, irrespective of the place
     where the check occurs, or the source of the packet.  If a rule contains some match patterns or actions
     which are not valid for the place of invocation (e.g. trying to match a MAC header within <b>ip_input()</b> ),
     the match pattern will not match, but a <b>not</b> operator in front of such patterns <u>will</u> cause the pattern
     to <u>always</u> match on those packets.  It is thus the responsibility of the programmer, if necessary, to
     write a suitable ruleset to differentiate among the possible places.  <b>skipto</b> rules can be useful here,
     as an example:

           # packets from ether_demux or bdg_forward
           ipfw add 10 skipto 1000 all from any to any layer2 in
           # packets from ip_input
           ipfw add 10 skipto 2000 all from any to any not layer2 in
           # packets from ip_output
           ipfw add 10 skipto 3000 all from any to any not layer2 out
           # packets from ether_output_frame
           ipfw add 10 skipto 4000 all from any to any layer2 out

     (yes, at the moment there is no way to differentiate between ether_demux and bdg_forward).

<b>SYNTAX</b>
     In general, each keyword or argument must be provided as a separate command line argument, with no
     leading or trailing spaces. Keywords are case-sensitive, whereas arguments may or may not be case-sen-<font color="#ffffff" class="whiteout">sitive&nbsp;case-sensitive</font>
     sitive depending on their nature (e.g. uid's are, hostnames are not).

     In <b>ipfw2</b> you can introduce spaces after commas ',' to make the line more readable. You can also put the
     entire command (including flags) into a single argument.  E.g. the following forms are equivalent:

           ipfw -q add deny src-ip 10.0.0.0/24,127.0.0.1/8
           ipfw -q add deny src-ip 10.0.0.0/24, 127.0.0.1/8
           ipfw "-q add deny src-ip 10.0.0.0/24, 127.0.0.1/8"

<b>RULE</b> <b>FORMAT</b>
     The format of <b>ipfw</b> rules is the following:

           [<u>rule</u><b>_</b><u>number</u>] [<b>set</b> <u>set</u><b>_</b><u>number</u>] [<b>prob</b> <u>match</u><b>_</b><u>probability</u>]
               <u>action</u> [<b>log</b> [<b>logamount</b> <u>number</u>]] <u>body</u>

     where the body of the rule specifies which information is used for filtering packets, among the follow-<font color="#ffffff" class="whiteout">ing:&nbsp;following:</font>
     ing:

        Layer-2 header fields                 When available
        IPv4 Protocol                         TCP, UDP, ICMP, etc.
        Source and dest. addresses and ports
        Direction                             See Section <u>PACKET</u> <u>FLOW</u>
        Transmit and receive interface        By name or address
        Misc. IP header fields                Version, type of service, datagram length, identification,
                                              fragment flag (non-zero IP offset), Time To Live
        IP options
        Misc. TCP header fields               TCP flags (SYN, FIN, ACK, RST, etc.), sequence number,
                                              acknowledgment number, window
        TCP options
        ICMP types                            for ICMP packets
        User/group ID                         When the packet can be associated with a local socket.

     Note that some of the above information, e.g. source MAC or IP addresses and TCP/UDP ports, could eas-<font color="#ffffff" class="whiteout">ily&nbsp;easily</font>
     ily be spoofed, so filtering on those fields alone might not guarantee the desired results.

     <u>rule</u><b>_</b><u>number</u>
             Each rule is associated with a <u>rule</u><b>_</b><u>number</u> in the range 1..65535, with the latter reserved for
             the <u>default</u> rule.  Rules are checked sequentially by rule number.  Multiple rules can have the
             same number, in which case they are checked (and listed) according to the order in which they
             have been added.  If a rule is entered without specifying a number, the kernel will assign one
             in such a way that the rule becomes the last one before the <u>default</u> rule.  Automatic rule num-<font color="#ffffff" class="whiteout">bers&nbsp;numbers</font>
             bers are assigned by incrementing the last non-default rule number by the value of the sysctl
             variable <u>net.inet.ip.fw.autoinc</u><b>_</b><u>step</u> which defaults to 100.  If this is not possible (e.g.
             because we would go beyond the maximum allowed rule number), the number of the last non-default
             value is used instead.

     <b>set</b> <u>set</u><b>_</b><u>number</u>
             Each rule is associated with a <u>set</u><b>_</b><u>number</u> in the range 0..31.  Sets can be individually dis-<font color="#ffffff" class="whiteout">abled&nbsp;disabled</font>
             abled and enabled, so this parameter is of fundamental importance for atomic ruleset manipula-<font color="#ffffff" class="whiteout">tion.&nbsp;manipulation.</font>
             tion.  It can be also used to simplify deletion of groups of rules.  If a rule is entered with-<font color="#ffffff" class="whiteout">out&nbsp;without</font>
             out specifying a set number, set 0 will be used.
             Set 31 is special in that it cannot be disabled, and rules in set 31 are not deleted by the
             <b>ipfw</b> <b>flush</b> command (but you can delete them with the <b>ipfw</b> <b>delete</b> <b>set</b> <b>31</b> command).  Set 31 is
             also used for the <u>default</u> rule.

     <b>prob</b> <u>match</u><b>_</b><u>probability</u>
             A match is only declared with the specified probability (floating point number between 0 and
             1).  This can be useful for a number of applications such as random packet drop or (in conjunc-<font color="#ffffff" class="whiteout">tion&nbsp;conjunction</font>
             tion with <a href="../man4/dummynet.4.html#//apple_ref/doc/man/4/dummynet">dummynet(4)</a>) to simulate the effect of multiple paths leading to out-of-order packet
             delivery.

             Note: this condition is checked before any other condition, including ones such as keep-state
             or check-state which might have side effects.

     <b>log</b> [<b>logamount</b> <u>number</u>]
             When a packet matches a rule with the <b>log</b> keyword, a message will be logged to <a href="syslogd.8.html#//apple_ref/doc/man/8/syslogd">syslogd(8)</a> with
             a LOG_SECURITY facility.  The logging only occurs if the sysctl variable <u>net.inet.ip.fw.verbose</u>
             is set to 1 (which is the default when the kernel is compiled with IPFIREWALL_VERBOSE ) and the
             number of packets logged so far for that particular rule does not exceed the <b>logamount</b> parame-<font color="#ffffff" class="whiteout">ter.&nbsp;parameter.</font>
             ter.  If no <b>logamount</b> is specified, the limit is taken from the sysctl variable
             <u>net.inet.ip.fw.verbose</u><b>_</b><u>limit</u>.  In both cases, a value of 0 removes the logging limit.

             Once the limit is reached, logging can be re-enabled by clearing the logging counter or the
             packet counter for that entry, see the <b>resetlog</b> command.

             Note: logging is done after all other packet matching conditions have been successfully veri-<font color="#ffffff" class="whiteout">fied,&nbsp;verified,</font>
             fied, and before performing the final action (accept, deny, etc.) on the packet.

   <b>RULE</b> <b>ACTIONS</b>
     A rule can be associated with one of the following actions, which will be executed when the packet
     matches the body of the rule.

     <b>allow</b> | <b>accept</b> | <b>pass</b> | <b>permit</b>
             Allow packets that match rule.  The search terminates.

     <b>check-state</b>
             Checks the packet against the dynamic ruleset.  If a match is found, execute the action associ-<font color="#ffffff" class="whiteout">ated&nbsp;associated</font>
             ated with the rule which generated this dynamic rule, otherwise move to the next rule.
             <b>Check-state</b> rules do not have a body.  If no <b>check-state</b> rule is found, the dynamic ruleset is
             checked at the first <b>keep-state</b> or <b>limit</b> rule.

     <b>count</b>   Update counters for all packets that match rule.  The search continues with the next rule.

     <b>deny</b> | <b>drop</b>
             Discard packets that match this rule.  The search terminates.

     <b>divert</b> <u>port</u>
             Divert packets that match this rule to the <a href="../man4/divert.4.html#//apple_ref/doc/man/4/divert">divert(4)</a> socket bound to port <u>port</u>.  The search
             terminates.

     <b>fwd</b> | <b>forward</b> <u>ipaddr</u>[,<u>port</u>]
             Change the next-hop on matching packets to <u>ipaddr</u>, which can be an IP address in dotted quad
             format or a host name.  The search terminates if this rule matches.

             If <u>ipaddr</u> is a local address, then matching packets will be forwarded to <u>port</u> (or the port num-<font color="#ffffff" class="whiteout">ber&nbsp;number</font>
             ber in the packet if one is not specified in the rule) on the local machine.
             If <u>ipaddr</u> is not a local address, then the port number (if specified) is ignored, and the
             packet will be forwarded to the remote address, using the route as found in the local routing
             table for that IP.
             A <u>fwd</u> rule will not match layer-2 packets (those received on ether_input, ether_output, or
             bridged).
             The <b>fwd</b> action does not change the contents of the packet at all.  In particular, the destina-<font color="#ffffff" class="whiteout">tion&nbsp;destination</font>
             tion address remains unmodified, so packets forwarded to another system will usually be
             rejected by that system unless there is a matching rule on that system to capture them.  For
             packets forwarded locally, the local address of the socket will be set to the original destina-<font color="#ffffff" class="whiteout">tion&nbsp;destination</font>
             tion address of the packet.  This makes the <a href="../man1/netstat.1.html#//apple_ref/doc/man/1/netstat">netstat(1)</a> entry look rather weird but is intended
             for use with transparent proxy servers.

     <b>pipe</b> <u>pipe</u><b>_</b><u>nr</u>
             Pass packet to a <a href="../man4/dummynet.4.html#//apple_ref/doc/man/4/dummynet">dummynet(4)</a> ``pipe'' (for bandwidth limitation, delay, etc.).  See the <u>TRAFFIC</u>
             <u>SHAPER</u> <u>(DUMMYNET)</u> <u>CONFIGURATION</u> Section for further information.  The search terminates; how-<font color="#ffffff" class="whiteout">ever,&nbsp;however,</font>
             ever, on exit from the pipe and if the <a href="sysctl.8.html#//apple_ref/doc/man/8/sysctl">sysctl(8)</a> variable <u>net.inet.ip.fw.one</u><b>_</b><u>pass</u> is not set,
             the packet is passed again to the firewall code starting from the next rule.

     <b>queue</b> <u>queue</u><b>_</b><u>nr</u>
             Pass packet to a <a href="../man4/dummynet.4.html#//apple_ref/doc/man/4/dummynet">dummynet(4)</a> ``queue'' (for bandwidth limitation using WF2Q+).

     <b>reject</b>  (Deprecated).  Synonym for <b>unreach</b> <b>host</b>.

     <b>reset</b>   Discard packets that match this rule, and if the packet is a TCP packet, try to send a TCP
             reset (RST) notice.  The search terminates.

     <b>skipto</b> <u>number</u>
             Skip all subsequent rules numbered less than <u>number</u>.  The search continues with the first rule
             numbered <u>number</u> or higher.

     <b>tee</b> <u>port</u>
             Send a copy of packets matching this rule to the <a href="../man4/divert.4.html#//apple_ref/doc/man/4/divert">divert(4)</a> socket bound to port <u>port</u>.  The
             search terminates and the original packet is accepted (but see Section <u>BUGS</u> below).

     <b>unreach</b> <u>code</u>
             Discard packets that match this rule, and try to send an ICMP unreachable notice with code
             <u>code</u>, where <u>code</u> is a number from 0 to 255, or one of these aliases: <b>net</b>, <b>host</b>, <b>protocol</b>, <b>port</b>,
             <b>needfrag</b>, <b>srcfail</b>, <b>net-unknown</b>, <b>host-unknown</b>, <b>isolated</b>, <b>net-prohib</b>, <b>host-prohib</b>, <b>tosnet</b>,
             <b>toshost</b>, <b>filter-prohib</b>, <b>host-precedence</b> or <b>precedence-cutoff</b>.  The search terminates.

   <b>RULE</b> <b>BODY</b>
     The body of a rule contains zero or more patterns (such as specific source and destination addresses or
     ports, protocol options, incoming or outgoing interfaces, etc.)  that the packet must match in order to
     be recognised.  In general, the patterns are connected by (implicit) <b>and</b> operators -- i.e. all must
     match in order for the rule to match.  Individual patterns can be prefixed by the <b>not</b> operator to
     reverse the result of the match, as in

           ipfw add 100 allow ip from not 1.2.3.4 to any

     Additionally, sets of alternative match patterns ( <u>or-blocks</u> ) can be constructed by putting the pat-<font color="#ffffff" class="whiteout">terns&nbsp;patterns</font>
     terns in lists enclosed between parentheses ( ) or braces { }, and using the <b>or</b> operator as follows:

           ipfw add 100 allow ip from { x or not y or z } to any

     Only one level of parentheses is allowed.  Beware that most shells have special meanings for parenthe-<font color="#ffffff" class="whiteout">ses&nbsp;parentheses</font>
     ses or braces, so it is advisable to put a backslash \ in front of them to prevent such interpreta-<font color="#ffffff" class="whiteout">tions.&nbsp;interpretations.</font>
     tions.

     The body of a rule must in general include a source and destination address specifier.  The keyword <u>any</u>
     can be used in various places to specify that the content of a required field is irrelevant.

     The rule body has the following format:

           [<u>proto</u> <b>from</b> <u>src</u> <b>to</b> <u>dst</u>] [<u>options</u>]

     The first part (proto from src to dst) is for backward compatibility with <b>ipfw1</b>.  In <b>ipfw2</b> any match
     pattern (including MAC headers, IPv4 protocols, addresses and ports) can be specified in the <u>options</u>
     section.

     Rule fields have the following meaning:

     <u>proto</u>: <u>protocol</u> | <b>{</b> <u>protocol</u> <b>or</b> <b>...</b> <b>}</b>

     <u>protocol</u>: [<b>not</b>] <u>protocol-name</u> | <u>protocol-number</u>
             An IPv4 protocol specified by number or name (for a complete list see <u>/etc/protocols</u>).  The <b>ip</b>
             or <b>all</b> keywords mean any protocol will match.

             The <b>{</b> <u>protocol</u> <b>or</b> <b>...</b> <b>}</b> format (an <u>or-block</u>) is provided for convenience only but its use is
             deprecated.

     <u>src</u> and <u>dst</u>: {<b>addr</b> | <b>{</b> <u>addr</u> <b>or</b> <b>...</b> <b>}</b>} [[<b>not</b>] <u>ports</u>]
             An address (or a list, see below) optionally followed by <u>ports</u> specifiers.

             The second format ( <u>or-block</u> with multiple addresses) is provided for convenience only and its
             use is discouraged.

     <u>addr</u>: [<b>not</b>] {<b>any</b> | <b>me</b> | <u>addr-list</u> | <u>addr-set</u>}

     <b>any</b>     matches any IP address.

     <b>me</b>      matches any IP address configured on an interface in the system.  The address list is evaluated
             at the time the packet is analysed.

     <u>addr-list</u>: <u>ip-addr</u>[,<u>addr-list</u>]

     <u>ip-addr</u>:
             A host or subnet address specified in one of the following ways:

             <u>numeric-ip</u> | <u>hostname</u>
                     Matches a single IPv4 address, specified as dotted-quad or a hostname.  Hostnames are
                     resolved at the time the rule is added to the firewall list.

             <u>addr</u>/<u>masklen</u>
                     Matches all addresses with base <u>addr</u> (specified as a dotted quad or a hostname) and
                     mask width of <b>masklen</b> bits.  As an example, 1.2.3.4/25 will match all IP numbers from
                     1.2.3.0 to 1.2.3.127 .

             <u>addr</u>:<u>mask</u>
                     Matches all addresses with base <u>addr</u> (specified as a dotted quad or a hostname) and the
                     mask of <u>mask</u>, specified as a dotted quad.  As an example, 1.2.3.4/255.0.255.0 will
                     match 1.*.3.*.  We suggest to use this form only for non-contiguous masks, and resort
                     to the <u>addr</u>/<u>masklen</u> format for contiguous masks, which is more compact and less error-<font color="#ffffff" class="whiteout">prone.&nbsp;errorprone.</font>
                     prone.

     <u>addr-set</u>: <u>addr</u>[/<u>masklen</u>]<b>{</b><u>list</u><b>}</b>

     <u>list</u>: {<u>num</u> | <u>num-num</u>}[,<u>list</u>]
             Matches all addresses with base address <u>addr</u> (specified as a dotted quad or a hostname) and
             whose last byte is in the list between braces { } .  Note that there must be no spaces between
             braces and numbers (spaces after commas are allowed).  Elements of the list can be specified as
             single entries or ranges.  The <u>masklen</u> field is used to limit the size of the set of addresses,
             and can have any value between 24 and 32. If not specified, it will be assumed as 24.
             This format is particularly useful to handle sparse address sets within a single rule. Because
             the matching occurs using a bitmask, it takes constant time and dramatically reduces the com-<font color="#ffffff" class="whiteout">plexity&nbsp;complexity</font>
             plexity of rulesets.
             As an example, an address specified as 1.2.3.4/24{128,35-55,89} will match the following IP
             addresses:
             1.2.3.128, 1.2.3.35 to 1.2.3.55, 1.2.3.89 .

     <u>ports</u>: {<u>port</u> | <u>port</u>-<u>port</u>}[,<u>ports</u>]
             For protocols which support port numbers (such as TCP and UDP), optional <b>ports</b> may be specified
             as one or more ports or port ranges, separated by commas but no spaces, and an optional <b>not</b>
             operator.  The `-' notation specifies a range of ports (including boundaries).

             Service names (from <u>/etc/services</u>) may be used instead of numeric port values.  The length of
             the port list is limited to 30 ports or ranges, though one can specify larger ranges by using
             an <u>or-block</u> in the <b>options</b> section of the rule.

             A backslash (`\') can be used to escape the dash (`-') character in a service name (from a
             shell, the backslash must be typed twice to avoid the shell itself interpreting it as an escape
             character).

                   ipfw add count tcp from any ftp\\-data-ftp to any

             Fragmented packets which have a non-zero offset (i.e. not the first fragment) will never match
             a rule which has one or more port specifications.  See the <b>frag</b> option for details on matching
             fragmented packets.

   <b>RULE</b> <b>OPTIONS</b> <b>(MATCH</b> <b>PATTERNS)</b>
     Additional match patterns can be used within rules. Zero or more of these so-called <u>options</u> can be
     present in a rule, optionally prefixed by the <b>not</b> operand, and possibly grouped into <u>or-blocks</u>.

     The following match patterns can be used (listed in alphabetical order):

     <b>//</b> <b>this</b> <b>is</b> <b>a</b> <b>comment.</b>
             Inserts the specified text as a comment in the rule.  Everything following // is considered as
             a comment and stored in the rule.  You can have comment-only rules, which are listed as having
             a <b>count</b> action followed by the comment.

     <b>bridged</b>
             Matches only bridged packets.

     <b>dst-ip</b> <u>ip-address</u>
             Matches IP packets whose destination IP is one of the address(es) specified as argument.

     <b>dst-port</b> <u>ports</u>
             Matches IP packets whose destination port is one of the <!-- a -->port(s)<!-- /a --> specified as argument.

     <b>established</b>
             Matches TCP packets that have the RST or ACK bits set.

     <b>frag</b>    Matches packets that are fragments and not the first fragment of an IP datagram. Note that
             these packets will not have the next protocol header (e.g. TCP, UDP) so options that look into
             these headers cannot match.

     <b>gid</b> <u>group</u>
             Matches all TCP or UDP packets sent by or received for a <u>group</u>.  A <u>group</u> may be specified by
             name or number.

     <b>icmptypes</b> <u>types</u>
             Matches ICMP packets whose ICMP type is in the list <u>types</u>.  The list may be specified as any
             combination of individual types (numeric) separated by commas.  <u>Ranges</u> <u>are</u> <u>not</u> <u>allowed.</u> The
             supported ICMP types are:

             echo reply (<b>0</b>), destination unreachable (<b>3</b>), source quench (<b>4</b>), redirect (<b>5</b>), echo request (<b>8</b>),
             router advertisement (<b>9</b>), router solicitation (<b>10</b>), time-to-live exceeded (<b>11</b>), IP header bad
             (<b>12</b>), timestamp request (<b>13</b>), timestamp reply (<b>14</b>), information request (<b>15</b>), information reply
             (<b>16</b>), address mask request (<b>17</b>) and address mask reply (<b>18</b>).

     <b>in</b> | <b>out</b>
             Matches incoming or outgoing packets, respectively.  <b>in</b> and <b>out</b> are mutually exclusive (in
             fact, <b>out</b> is implemented as <b>not</b> <b>in</b>).

     <b>ipid</b> <u>id-list</u>
             Matches IP packets whose <b>ip_id</b> field has value included in <u>id-list</u>, which is either a single
             value or a list of values or ranges specified in the same way as <u>ports</u>.

     <b>iplen</b> <u>len-list</u>
             Matches IP packets whose total length, including header and data, is in the set <u>len-list</u>, which
             is either a single value or a list of values or ranges specified in the same way as <u>ports</u>.

     <b>ipoptions</b> <u>spec</u>
             Matches packets whose IP header contains the comma separated list of options specified in <u>spec</u>.
             The supported IP options are:

             <b>ssrr</b> (strict source route), <b>lsrr</b> (loose source route), <b>rr</b> (record packet route) and <b>ts</b> (time-<font color="#ffffff" class="whiteout">stamp).&nbsp;(timestamp).</font>
             stamp).  The absence of a particular option may be denoted with a `!'.

     <b>ipprecedence</b> <u>precedence</u>
             Matches IP packets whose precedence field is equal to <u>precedence</u>.

     <b>ipsec</b>   Matches packets that have IPSEC history associated with them (i.e. the packet comes encapsu-<font color="#ffffff" class="whiteout">lated&nbsp;encapsulated</font>
             lated in IPSEC, the kernel has IPSEC support and IPSEC_FILTERGIF option, and can correctly
             decapsulate it).

             Note that specifying <b>ipsec</b> is different from specifying <b>proto</b> <u>ipsec</u> as the latter will only
             look at the specific IP protocol field, irrespective of IPSEC kernel support and the validity
             of the IPSEC data.

     <b>iptos</b> <u>spec</u>
             Matches IP packets whose <b>tos</b> field contains the comma separated list of service types specified
             in <u>spec</u>.  The supported IP types of service are:

             <b>lowdelay</b> (IPTOS_LOWDELAY), <b>throughput</b> (IPTOS_THROUGHPUT), <b>reliability</b> (IPTOS_RELIABILITY),
             <b>mincost</b> (IPTOS_MINCOST), <b>congestion</b> (IPTOS_CE).  The absence of a particular type may be
             denoted with a `!'.

     <b>ipttl</b> <u>ttl-list</u>
             Matches IP packets whose time to live is included in <u>ttl-list</u>, which is either a single value
             or a list of values or ranges specified in the same way as <u>ports</u>.

     <b>ipversion</b> <u>ver</u>
             Matches IP packets whose IP version field is <u>ver</u>.

     <b>keep-state</b>
             Upon a match, the firewall will create a dynamic rule, whose default behaviour is to match
             bidirectional traffic between source and destination IP/port using the same protocol.  The rule
             has a limited lifetime (controlled by a set of <a href="sysctl.8.html#//apple_ref/doc/man/8/sysctl">sysctl(8)</a> variables), and the lifetime is
             refreshed every time a matching packet is found.

     <b>layer2</b>  Matches only layer2 packets, i.e. those passed to <b>ipfw</b> from ether_demux() and ether_out-<font color="#ffffff" class="whiteout">put_frame().&nbsp;ether_output_frame().</font>
             put_frame().

     <b>limit</b> {<b>src-addr</b> | <b>src-port</b> | <b>dst-addr</b> | <b>dst-port</b>} <u>N</u>
             The firewall will only allow <u>N</u> connections with the same set of parameters as specified in the
             rule.  One or more of source and destination addresses and ports can be specified.

     <b>{</b> <b>MAC</b> | <b>mac</b> <b>}</b> <u>dst-mac</u> <u>src-mac</u>
             Match packets with a given <u>dst-mac</u> and <u>src-mac</u> addresses, specified as the <b>any</b> keyword (match-<font color="#ffffff" class="whiteout">ing&nbsp;(matching</font>
             ing any MAC address), or six groups of hex digits separated by colons, and optionally followed
             by a mask indicating how many bits are significant, as in

                   MAC 10:20:30:40:50:60/33 any

             Note that the order of MAC addresses (destination first, source second) is the same as on the
             wire, but the opposite of the one used for IP addresses.

     <b>mac-type</b> <u>mac-type</u>
             Matches packets whose Ethernet Type field corresponds to one of those specified as argument.
             <u>mac-type</u> is specified in the same way as <b>port</b> <b>numbers</b> (i.e. one or more comma-separated single
             values or ranges).  You can use symbolic names for known values such as <u>vlan</u>, <u>ipv4,</u> <u>ipv6</u>.  Val-<font color="#ffffff" class="whiteout">ues&nbsp;Values</font>
             ues can be entered as decimal or hexadecimal (if prefixed by 0x), and they are always printed
             as hexadecimal (unless the <b>-N</b> option is used, in which case symbolic resolution will be
             attempted).

     <b>proto</b> <u>protocol</u>
             Matches packets with the corresponding IPv4 protocol.

     <b>recv</b> | <b>xmit</b> | <b>via</b> {<u>ifX</u> | <u>if</u><b>*</b> | <u>ipno</u> | <u>any</u>}
             Matches packets received, transmitted or going through, respectively, the interface specified
             by exact name (<u>ifX</u>), by device name (<u>if*</u>), by IP address, or through some interface.

             The <b>via</b> keyword causes the interface to always be checked.  If <b>recv</b> or <b>xmit</b> is used instead of
             <b>via</b>, then only the receive or transmit interface (respectively) is checked.  By specifying
             both, it is possible to match packets based on both receive and transmit interface, e.g.:

                   ipfw add deny ip from any to any out recv ed0 xmit ed1

             The <b>recv</b> interface can be tested on either incoming or outgoing packets, while the <b>xmit</b> inter-<font color="#ffffff" class="whiteout">face&nbsp;interface</font>
             face can only be tested on outgoing packets.  So <b>out</b> is required (and <b>in</b> is invalid) whenever
             <b>xmit</b> is used.

             A packet may not have a receive or transmit interface: packets originating from the local host
             have no receive interface, while packets destined for the local host have no transmit inter-<font color="#ffffff" class="whiteout">face.&nbsp;interface.</font>
             face.

     <b>setup</b>   Matches TCP packets that have the SYN bit set but no ACK bit.  This is the short form of
             ``tcpflags syn,!ack''.

     <b>src-ip</b> <u>ip-address</u>
             Matches IP packets whose source IP is one of the address(es) specified as argument.

     <b>src-port</b> <u>ports</u>
             Matches IP packets whose source port is one of the <!-- a -->port(s)<!-- /a --> specified as argument.

     <b>tcpack</b> <u>ack</u>
             TCP packets only.  Match if the TCP header acknowledgment number field is set to <u>ack</u>.

     <b>tcpflags</b> <u>spec</u>
             TCP packets only.  Match if the TCP header contains the comma separated list of flags specified
             in <u>spec</u>.  The supported TCP flags are:

             <b>fin</b>, <b>syn</b>, <b>rst</b>, <b>psh</b>, <b>ack</b> and <b>urg</b>.  The absence of a particular flag may be denoted with a `!'.
             A rule which contains a <b>tcpflags</b> specification can never match a fragmented packet which has a
             non-zero offset.  See the <b>frag</b> option for details on matching fragmented packets.

     <b>tcpseq</b> <u>seq</u>
             TCP packets only.  Match if the TCP header sequence number field is set to <u>seq</u>.

     <b>tcpwin</b> <u>win</u>
             TCP packets only.  Match if the TCP header window field is set to <u>win</u>.

     <b>tcpoptions</b> <u>spec</u>
             TCP packets only.  Match if the TCP header contains the comma separated list of options speci-<font color="#ffffff" class="whiteout">fied&nbsp;specified</font>
             fied in <u>spec</u>.  The supported TCP options are:

             <b>mss</b> (maximum segment size), <b>window</b> (tcp window advertisement), <b>sack</b> (selective ack), <b>ts</b>
             (rfc1323 timestamp) and <b>cc</b> (rfc1644 t/tcp connection count).  The absence of a particular
             option may be denoted with a `!'.

     <b>uid</b> <u>user</u>
             Match all TCP or UDP packets sent by or received for a <u>user</u>.  A <u>user</u> may be matched by name or
             identification number.

     <b>verrevpath</b>
             For incoming packets, a routing table lookup is done on the packet's source address.  If the
             interface on which the packet entered the system matches the outgoing interface for the route,
             the packet matches.  If the interfaces do not match up, the packet does not match.  All outgo-<font color="#ffffff" class="whiteout">ing&nbsp;outgoing</font>
             ing packets or packets with no incoming interface match.

             The name and functionality of the option is intentionally similar to the Cisco IOS command:

                   ip verify unicast reverse-path

             This option can be used to make anti-spoofing rules.

<b>SETS</b> <b>OF</b> <b>RULES</b>
     Each rule belongs to one of 32 different <u>sets</u> , numbered 0 to 31.  Set 31 is reserved for the default
     rule.

     By default, rules are put in set 0, unless you use the <b>set</b> <b>N</b> attribute when entering a new rule.  Sets
     can be individually and atomically enabled or disabled, so this mechanism permits an easy way to store
     multiple configurations of the firewall and quickly (and atomically) switch between them.  The command
     to enable/disable sets is

           <b>ipfw</b> <b>set</b> [<b>disable</b> <u>number</u> <u>...</u>] [<b>enable</b> <u>number</u> <u>...</u>]

     where multiple <b>enable</b> or <b>disable</b> sections can be specified.  Command execution is atomic on all the
     sets specified in the command.  By default, all sets are enabled.

     When you disable a set, its rules behave as if they do not exist in the firewall configuration, with
     only one exception:

           dynamic rules created from a rule before it had been disabled will still be active until they
           expire. In order to delete dynamic rules you have to explicitly delete the parent rule which gen-<font color="#ffffff" class="whiteout">erated&nbsp;generated</font>
           erated them.

     The set number of rules can be changed with the command

           <b>ipfw</b> <b>set</b> <b>move</b> {<b>rule</b> <u>rule-number</u> | <u>old-set</u>} <b>to</b> <u>new-set</u>

     Also, you can atomically swap two rulesets with the command

           <b>ipfw</b> <b>set</b> <b>swap</b> <u>first-set</u> <u>second-set</u>

     See the <u>EXAMPLES</u> Section on some possible uses of sets of rules.

<b>STATEFUL</b> <b>FIREWALL</b>
     Stateful operation is a way for the firewall to dynamically create rules for specific flows when pack-<font color="#ffffff" class="whiteout">ets&nbsp;packets</font>
     ets that match a given pattern are detected. Support for stateful operation comes through the
     <b>check-state</b>, <b>keep-state</b> and <b>limit</b> options of <b>rules.</b>

     Dynamic rules are created when a packet matches a <b>keep-state</b> or <b>limit</b> rule, causing the creation of a
     <u>dynamic</u> rule which will match all and only packets with a given <u>protocol</u> between a <u>src-ip/src-port</u>
     <u>dst-ip/dst-port</u> pair of addresses ( <u>src</u> and <u>dst</u> are used here only to denote the initial match
     addresses, but they are completely equivalent afterwards).  Dynamic rules will be checked at the first
     <b>check-state,</b> <b>keep-state</b> or <b>limit</b> occurrence, and the action performed upon a match will be the same as
     in the parent rule.

     Note that no additional attributes other than protocol and IP addresses and ports are checked on
     dynamic rules.

     The typical use of dynamic rules is to keep a closed firewall configuration, but let the first TCP SYN
     packet from the inside network install a dynamic rule for the flow so that packets belonging to that
     session will be allowed through the firewall:

           ipfw add check-state
           ipfw add allow tcp from my-subnet to any setup keep-state
           ipfw add deny tcp from any to any

     A similar approach can be used for UDP, where an UDP packet coming from the inside will install a
     dynamic rule to let the response through the firewall:

           ipfw add check-state
           ipfw add allow udp from my-subnet to any keep-state
           ipfw add deny udp from any to any

     Dynamic rules expire after some time, which depends on the status of the flow and the setting of some
     <b>sysctl</b> variables.  See Section <u>SYSCTL</u> <u>VARIABLES</u> for more details.  For TCP sessions, dynamic rules can
     be instructed to periodically send keepalive packets to refresh the state of the rule when it is about
     to expire.

     See Section <u>EXAMPLES</u> for more examples on how to use dynamic rules.

<b>TRAFFIC</b> <b>SHAPER</b> <b>(DUMMYNET)</b> <b>CONFIGURATION</b>
     <b>ipfw</b> is also the user interface for the <a href="../man4/dummynet.4.html#//apple_ref/doc/man/4/dummynet">dummynet(4)</a> traffic shaper.

     <b>dummynet</b> operates by first using the firewall to classify packets and divide them into <u>flows</u>, using any
     match pattern that can be used in <b>ipfw</b> rules.  Depending on local policies, a flow can contain packets
     for a single TCP connection, or from/to a given host, or entire subnet, or a protocol type, etc.

     Packets belonging to the same flow are then passed to either of two different objects, which implement
     the traffic regulation:

         <u>pipe</u>    A pipe emulates a link with given bandwidth, propagation delay, queue size and packet loss
                 rate.  Packets are queued in front of the pipe as they come out from the classifier, and
                 then transferred to the pipe according to the pipe's parameters.

         <u>queue</u>   A queue is an abstraction used to implement the WF2Q+ (Worst-case Fair Weighted Fair Queue-<font color="#ffffff" class="whiteout">ing)&nbsp;Queueing)</font>
                 ing) policy, which is an efficient variant of the WFQ policy.
                 The queue associates a <u>weight</u> and a reference pipe to each flow, and then all backlogged
                 (i.e., with packets queued) flows linked to the same pipe share the pipe's bandwidth pro-<font color="#ffffff" class="whiteout">portionally&nbsp;proportionally</font>
                 portionally to their weights.  Note that weights are not priorities; a flow with a lower
                 weight is still guaranteed to get its fraction of the bandwidth even if a flow with a
                 higher weight is permanently backlogged.

     In practice, <u>pipes</u> can be used to set hard limits to the bandwidth that a flow can use, whereas <u>queues</u>
     can be used to determine how different flow share the available bandwidth.

     The <u>pipe</u> and <u>queue</u> configuration commands are the following:

           <b>pipe</b> <u>number</u> <b>config</b> <u>pipe-configuration</u>

           <b>queue</b> <u>number</u> <b>config</b> <u>queue-configuration</u>

     The following parameters can be configured for a pipe:

     <b>bw</b> <u>bandwidth</u> | <u>device</u>
             Bandwidth, measured in [<b>K</b>|<b>M</b>]{<b>bit/s</b>|<b>Byte/s</b>}.

             A value of 0 (default) means unlimited bandwidth.  The unit must immediately follow the number,
             as in

                   ipfw pipe 1 config bw 300Kbit/s

             If a device name is specified instead of a numeric value, as in

                   ipfw pipe 1 config bw tun0

             then the transmit clock is supplied by the specified device.  At the moment only the <!-- a -->tun(4)<!-- /a -->
             device supports this functionality, for use in conjunction with <!-- a -->ppp(8)<!-- /a -->.

     <b>delay</b> <u>ms-delay</u>
             Propagation delay, measured in milliseconds.  The value is rounded to the next multiple of the
             clock tick (typically 10ms, but it is a good practice to run kernels with ``options HZ=1000''
             to reduce the granularity to 1ms or less).  Default value is 0, meaning no delay.

     The following parameters can be configured for a queue:

     <b>pipe</b> <u>pipe</u><b>_</b><u>nr</u>
             Connects a queue to the specified pipe.  Multiple queues (with the same or different weights)
             can be connected to the same pipe, which specifies the aggregate rate for the set of queues.

     <b>weight</b> <u>weight</u>
             Specifies the weight to be used for flows matching this queue.  The weight must be in the range
             1..100, and defaults to 1.

     Finally, the following parameters can be configured for both pipes and queues:

     <b>buckets</b> <u>hash-table-size</u>
           Specifies the size of the hash table used for storing the various queues.  Default value is 64
           controlled by the <a href="sysctl.8.html#//apple_ref/doc/man/8/sysctl">sysctl(8)</a> variable <u>net.inet.ip.dummynet.hash</u><b>_</b><u>size</u>, allowed range is 16 to
           65536.

     <b>mask</b> <u>mask-specifier</u>
           Packets sent to a given pipe or queue by an <b>ipfw</b> rule can be further classified into multiple
           flows, each of which is then sent to a different <u>dynamic</u> pipe or queue.  A flow identifier is
           constructed by masking the IP addresses, ports and protocol types as specified with the <b>mask</b>
           options in the configuration of the pipe or queue.  For each different flow identifier, a new
           pipe or queue is created with the same parameters as the original object, and matching packets
           are sent to it.

           Thus, when <u>dynamic</u> <u>pipes</u> are used, each flow will get the same bandwidth as defined by the pipe,
           whereas when <u>dynamic</u> <u>queues</u> are used, each flow will share the parent's pipe bandwidth evenly
           with other flows generated by the same queue (note that other queues with different weights might
           be connected to the same pipe).
           Available mask specifiers are a combination of one or more of the following:

           <b>dst-ip</b> <u>mask</u>, <b>src-ip</b> <u>mask</u>, <b>dst-port</b> <u>mask</u>, <b>src-port</b> <u>mask</u>, <b>proto</b> <u>mask</u> or <b>all</b>,

           where the latter means all bits in all fields are significant.

     <b>noerror</b>
           When a packet is dropped by a dummynet queue or pipe, the error is normally reported to the
           caller routine in the kernel, in the same way as it happens when a device queue fills up. Setting
           this option reports the packet as successfully delivered, which can be needed for some experimen-<font color="#ffffff" class="whiteout">tal&nbsp;experimental</font>
           tal setups where you want to simulate loss or congestion at a remote router.

     <b>plr</b> <u>packet-loss-rate</u>
           Packet loss rate.  Argument <u>packet-loss-rate</u> is a floating-point number between 0 and 1, with 0
           meaning no loss, 1 meaning 100% loss.  The loss rate is internally represented on 31 bits.

     <b>queue</b> {<u>slots</u> | <u>size</u><b>Kbytes</b>}
           Queue size, in <u>slots</u> or <b>KBytes</b>.  Default value is 50 slots, which is the typical queue size for
           Ethernet devices.  Note that for slow speed links you should keep the queue size short or your
           traffic might be affected by a significant queueing delay.  E.g., 50 max-sized ethernet packets
           (1500 bytes) mean 600Kbit or 20s of queue on a 30Kbit/s pipe.  Even worse effect can result if
           you get packets from an interface with a much larger MTU, e.g. the loopback interface with its
           16KB packets.

     <b>red</b> | <b>gred</b> <u>w</u><b>_</b><u>q</u>/<u>min</u><b>_</b><u>th</u>/<u>max</u><b>_</b><u>th</u>/<u>max</u><b>_</b><u>p</u>
           Make use of the RED (Random Early Detection) queue management algorithm.  <u>w</u><b>_</b><u>q</u> and <u>max</u><b>_</b><u>p</u> are
           floating point numbers between 0 and 1 (0 not included), while <u>min</u><b>_</b><u>th</u> and <u>max</u><b>_</b><u>th</u> are integer num-<font color="#ffffff" class="whiteout">bers&nbsp;numbers</font>
           bers specifying thresholds for queue management (thresholds are computed in bytes if the queue
           has been defined in bytes, in slots otherwise).  The <a href="../man4/dummynet.4.html#//apple_ref/doc/man/4/dummynet">dummynet(4)</a> also supports the gentle RED
           variant (gred).  Three <a href="sysctl.8.html#//apple_ref/doc/man/8/sysctl">sysctl(8)</a> variables can be used to control the RED behaviour:

           <u>net.inet.ip.dummynet.red</u><b>_</b><u>lookup</u><b>_</b><u>depth</u>
                   specifies the accuracy in computing the average queue when the link is idle (defaults to
                   256, must be greater than zero)

           <u>net.inet.ip.dummynet.red</u><b>_</b><u>avg</u><b>_</b><u>pkt</u><b>_</b><u>size</u>
                   specifies the expected average packet size (defaults to 512, must be greater than zero)

           <u>net.inet.ip.dummynet.red</u><b>_</b><u>max</u><b>_</b><u>pkt</u><b>_</b><u>size</u>
                   specifies the expected maximum packet size, only used when queue thresholds are in bytes
                   (defaults to 1500, must be greater than zero).

<b>CHECKLIST</b>
     Here are some important points to consider when designing your rules:

     <b></b><b><u>oo</u></b>   Remember that you filter both packets going <b>in</b> and <b>out</b>.  Most connections need packets going in
         both directions.

     <b></b><b><u>oo</u></b>   Remember to test very carefully.  It is a good idea to be near the console when doing this.  If you
         cannot be near the console, use an auto-recovery script such as the one in
         <u>/usr/share/examples/ipfw/change</u><b>_</b><u>rules.sh</u>.

     <b></b><b><u>oo</u></b>   Don't forget the loopback interface.

<b>FINE</b> <b>POINTS</b>
     <b></b><b><u>oo</u></b>   There are circumstances where fragmented datagrams are unconditionally dropped.  TCP packets are
         dropped if they do not contain at least 20 bytes of TCP header, UDP packets are dropped if they do
         not contain a full 8 byte UDP header, and ICMP packets are dropped if they do not contain 4 bytes
         of ICMP header, enough to specify the ICMP type, code, and checksum.  These packets are simply
         logged as ``pullup failed'' since there may not be enough good data in the packet to produce a
         meaningful log entry.

     <b></b><b><u>oo</u></b>   Another type of packet is unconditionally dropped, a TCP packet with a fragment offset of one.
         This is a valid packet, but it only has one use, to try to circumvent firewalls.  When logging is
         enabled, these packets are reported as being dropped by rule -1.

     <b></b><b><u>oo</u></b>   If you are logged in over a network, loading the <!-- a -->kld(4)<!-- /a --> version of <b>ipfw</b> is probably not as
         straightforward as you would think.  I recommend the following command line:

               kldload ipfw &amp;&amp; \
               ipfw add 32000 allow ip from any to any

         Along the same lines, doing an

               ipfw flush

         in similar surroundings is also a bad idea.

     <b></b><b><u>oo</u></b>   The <b>ipfw</b> filter list may not be modified if the system security level is set to 3 or higher (see
         <!-- a -->init(8)<!-- /a --> for information on system security levels).

<b>PACKET</b> <b>DIVERSION</b>
     A <a href="../man4/divert.4.html#//apple_ref/doc/man/4/divert">divert(4)</a> socket bound to the specified port will receive all packets diverted to that port.  If no
     socket is bound to the destination port, or if the kernel wasn't compiled with divert socket support,
     the packets are dropped.

<b>SYSCTL</b> <b>VARIABLES</b>
     A set of <a href="sysctl.8.html#//apple_ref/doc/man/8/sysctl">sysctl(8)</a> variables controls the behaviour of the firewall and associated modules ( <b>dummynet,</b>
     <b>bridge</b> ).  These are shown below together with their default value (but always check with the <a href="sysctl.8.html#//apple_ref/doc/man/8/sysctl">sysctl(8)</a>
     command what value is actually in use) and meaning:

     <u>net.inet.ip.dummynet.expire</u>: 1
             Lazily delete dynamic pipes/queue once they have no pending traffic.  You can disable this by
             setting the variable to 0, in which case the pipes/queues will only be deleted when the thresh-<font color="#ffffff" class="whiteout">old&nbsp;threshold</font>
             old is reached.

     <u>net.inet.ip.dummynet.hash</u><b>_</b><u>size</u>: 64
             Default size of the hash table used for dynamic pipes/queues.  This value is used when no
             <b>buckets</b> option is specified when configuring a pipe/queue.

     <u>net.inet.ip.dummynet.max</u><b>_</b><u>chain</u><b>_</b><u>len</u>: 16
             Target value for the maximum number of pipes/queues in a hash bucket.  The product
             <b>max_chain_len*hash_size</b> is used to determine the threshold over which empty pipes/queues will
             be expired even when <b>net.inet.ip.dummynet.expire=0</b>.

     <u>net.inet.ip.dummynet.red</u><b>_</b><u>lookup</u><b>_</b><u>depth</u>: 256

     <u>net.inet.ip.dummynet.red</u><b>_</b><u>avg</u><b>_</b><u>pkt</u><b>_</b><u>size</u>: 512

     <u>net.inet.ip.dummynet.red</u><b>_</b><u>max</u><b>_</b><u>pkt</u><b>_</b><u>size</u>: 1500
             Parameters used in the computations of the drop probability for the RED algorithm.

     <u>net.inet.ip.fw.autoinc</u><b>_</b><u>step</u>: 100
             Delta between rule numbers when auto-generating them.  The value must be in the range 1..1000.
             This variable is only present in <b>ipfw2</b>, the delta is hardwired to 100 in <b>ipfw1</b>.

     <u>net.inet.ip.fw.curr</u><b>_</b><u>dyn</u><b>_</b><u>buckets</u>: <u>net.inet.ip.fw.dyn</u><b>_</b><u>buckets</u>
             The current number of buckets in the hash table for dynamic rules (readonly).

     <u>net.inet.ip.fw.debug</u>: 1
             Controls debugging messages produced by <b>ipfw</b>.

     <u>net.inet.ip.fw.dyn</u><b>_</b><u>buckets</u>: 256
             The number of buckets in the hash table for dynamic rules.  Must be a power of 2, up to 65536.
             It only takes effect when all dynamic rules have expired, so you are advised to use a <b>flush</b>
             command to make sure that the hash table is resized.

     <u>net.inet.ip.fw.dyn</u><b>_</b><u>count</u>: 3
             Current number of dynamic rules (read-only).

     <u>net.inet.ip.fw.dyn</u><b>_</b><u>keepalive</u>: 1
             Enables generation of keepalive packets for <b>keep-state</b> rules on TCP sessions. A keepalive is
             generated to both sides of the connection every 5 seconds for the last 20 seconds of the life-<font color="#ffffff" class="whiteout">time&nbsp;lifetime</font>
             time of the rule.

     <u>net.inet.ip.fw.dyn</u><b>_</b><u>max</u>: 8192
             Maximum number of dynamic rules.  When you hit this limit, no more dynamic rules can be
             installed until old ones expire.

     <u>net.inet.ip.fw.dyn</u><b>_</b><u>ack</u><b>_</b><u>lifetime</u>: 300

     <u>net.inet.ip.fw.dyn</u><b>_</b><u>syn</u><b>_</b><u>lifetime</u>: 20

     <u>net.inet.ip.fw.dyn</u><b>_</b><u>fin</u><b>_</b><u>lifetime</u>: 1

     <u>net.inet.ip.fw.dyn</u><b>_</b><u>rst</u><b>_</b><u>lifetime</u>: 1

     <u>net.inet.ip.fw.dyn</u><b>_</b><u>udp</u><b>_</b><u>lifetime</u>: 5

     <u>net.inet.ip.fw.dyn</u><b>_</b><u>short</u><b>_</b><u>lifetime</u>: 30
             These variables control the lifetime, in seconds, of dynamic rules.  Upon the initial SYN
             exchange the lifetime is kept short, then increased after both SYN have been seen, then
             decreased again during the final FIN exchange or when a RST is received.  Both <u>dyn</u><b>_</b><u>fin</u><b>_</b><u>lifetime</u>
             and <u>dyn</u><b>_</b><u>rst</u><b>_</b><u>lifetime</u> must be strictly lower than 5 seconds, the period of repetition of
             keepalives. The firewall enforces that.

     <u>net.inet.ip.fw.enable</u>: 1
             Enables the firewall.  Setting this variable to 0 lets you run your machine without firewall
             even if compiled in.

     <u>net.inet.ip.fw.one</u><b>_</b><u>pass</u>: 1
             When set, the packet exiting from the <a href="../man4/dummynet.4.html#//apple_ref/doc/man/4/dummynet">dummynet(4)</a> pipe is not passed though the firewall again.
             Otherwise, after a pipe action, the packet is reinjected into the firewall at the next rule.

     <u>net.inet.ip.fw.verbose</u>: 1
             Enables verbose messages.

     <u>net.inet.ip.fw.verbose</u><b>_</b><u>limit</u>: 0
             Limits the number of messages produced by a verbose firewall.

     <u>net.link.ether.ipfw</u>: 0
             Controls whether layer-2 packets are passed to <b>ipfw</b>.  Default is no.

     <u>net.link.ether.bridge</u><b>_</b><u>ipfw</u>: 0
             Controls whether bridged packets are passed to <b>ipfw</b>.  Default is no.

<b>IPFW2</b> <b>ENHANCEMENTS</b>
     This Section lists the features that have been introduced in <b>ipfw2</b> which were not present in <b>ipfw1</b>.  We
     list them in order of the potential impact that they can have in writing your rulesets.  You might want
     to consider using these features in order to write your rulesets in a more efficient way.

     Syntax and flags
             <b>ipfw1</b> does not support the -n flag (only test syntax), nor it allows spaces after commas or
             supports all rule fields in a single argument.

     Handling of non-IPv4 packets
             <b>ipfw1</b> will silently accept all non-IPv4 packets (which <b>ipfw1</b> will only see when
             <u>net.link.ether.bridge</u><b>_</b><u>ipfw=1</u>).  <b>ipfw2</b> will filter all packets (including non-IPv4 ones) accord-<font color="#ffffff" class="whiteout">ing&nbsp;according</font>
             ing to the ruleset.  To achieve the same behaviour as <b>ipfw1</b> you can use the following as the
             very first rule in your ruleset:

                   ipfw add 1 allow layer2 not mac-type ip

             The <b>layer2</b> option might seem redundant, but it is necessary -- packets passed to the firewall
             from layer3 will not have a MAC header, so the <b>mac-type</b> <b>ip</b> pattern will always fail on them,
             and the <b>not</b> operator will make this rule into a pass-all.

     Addresses
             <b>ipfw1</b> does not supports address sets or lists of addresses.

     Port specifications
             <b>ipfw1</b> only allows one port range when specifying TCP and UDP ports, and is limited to 10
             entries instead of the 15 allowed by <b>ipfw2</b>.  Also, in <b>ipfw1</b> you can only specify ports when the
             rule is requesting <b>tcp</b> or <b>udp</b> packets. With <b>ipfw2</b> you can put port specifications in rules
             matching all packets, and the match will be attempted only on those packets carrying protocols
             which include port identifiers.

             Finally, <b>ipfw1</b> allowed the first port entry to be specified as <u>port:mask</u> where <u>mask</u> can be an
             arbitrary 16-bit mask.  This syntax is of questionable usefulness and it is not supported any-<font color="#ffffff" class="whiteout">more&nbsp;anymore</font>
             more in <b>ipfw2</b>.

     Or-blocks
             <b>ipfw1</b> does not support Or-blocks.

     keepalives
             <b>ipfw1</b> does not generate keepalives for stateful sessions.  As a consequence, it might cause
             idle sessions to drop because the lifetime of the dynamic rules expires.

     Sets of rules
             <b>ipfw1</b> does not implement sets of rules.

     MAC header filtering and Layer-2 firewalling.
             <b>ipfw1</b> does not implement filtering on MAC header fields, nor is it invoked on packets from
             <b>ether_demux()</b> and <b>ether_output_frame().</b> The sysctl variable <u>net.link.ether.ipfw</u> has no effect
             there.

     Options
             In <b>ipfw1</b>, the following options only accept a single value as an argument:

             <b>ipid,</b> <b>iplen,</b> <b>ipttl</b>

             The following options are not implemented by <b>ipfw1</b>:

             <b>dst-ip,</b> <b>dst-port,</b> <b>layer2,</b> <b>mac,</b> <b>mac-type,</b> <b>src-ip,</b> <b>src-port.</b>

             Additionally, the RELENG_4 version of <b>ipfw1</b> does not implement the following options:

             <b>ipid,</b> <b>iplen,</b> <b>ipprecedence,</b> <b>iptos,</b> <b>ipttl,</b> <b>ipversion,</b> <b>tcpack,</b> <b>tcpseq,</b> <b>tcpwin</b>.

     Dummynet options
             The following option for <b>dummynet</b> pipes/queues is not supported: <b>noerror</b>.

<b>EXAMPLES</b>
     There are far too many possible uses of <b>ipfw</b> so this Section will only give a small set of examples.

   <b>BASIC</b> <b>PACKET</b> <b>FILTERING</b>
     This command adds an entry which denies all tcp packets from <u>cracker.evil.org</u> to the telnet port of
     <u>wolf.tambov.su</u> from being forwarded by the host:

           ipfw add deny tcp from cracker.evil.org to wolf.tambov.su telnet

     This one disallows any connection from the entire cracker's network to my host:

           ipfw add deny ip from 123.45.67.0/24 to my.host.org

     A first and efficient way to limit access (not using dynamic rules) is the use of the following rules:

           ipfw add allow tcp from any to any established
           ipfw add allow tcp from net1 portlist1 to net2 portlist2 setup
           ipfw add allow tcp from net3 portlist3 to net3 portlist3 setup
           ...
           ipfw add deny tcp from any to any

     The first rule will be a quick match for normal TCP packets, but it will not match the initial SYN
     packet, which will be matched by the <b>setup</b> rules only for selected source/destination pairs.  All other
     SYN packets will be rejected by the final <b>deny</b> rule.

     If you administer one or more subnets, you can take advantage of the <b>ipfw2</b> syntax to specify address
     sets and or-blocks and write extremely compact rulesets which selectively enable services to blocks of
     clients, as below:

           goodguys="{ 10.1.2.0/24{20,35,66,18} or 10.2.3.0/28{6,3,11} }"
           badguys="10.1.2.0/24{8,38,60}"

           ipfw add allow ip from ${goodguys} to any
           ipfw add deny ip from ${badguys} to any
           ... normal policies ...

     The <b>ipfw1</b> syntax would require a separate rule for each IP in the above example.

     The <b>verrevpath</b> option could be used to do automated anti-spoofing by adding the following to the top of
     a ruleset:

           ipfw add deny ip from any to any not verrevpath in

     This rule drops all incoming packets that appear to be coming to the sytem on the wrong interface. For
     example, a packet with a source address belonging to a host on a protected internal network would be
     dropped if it tried to enter the system from an external interface.

   <b>DYNAMIC</b> <b>RULES</b>
     In order to protect a site from flood attacks involving fake TCP packets, it is safer to use dynamic
     rules:

           ipfw add check-state
           ipfw add deny tcp from any to any established
           ipfw add allow tcp from my-net to any setup keep-state

     This will let the firewall install dynamic rules only for those connection which start with a regular
     SYN packet coming from the inside of our network.  Dynamic rules are checked when encountering the
     first <b>check-state</b> or <b>keep-state</b> rule.  A <b>check-state</b> rule should usually be placed near the beginning
     of the ruleset to minimize the amount of work scanning the ruleset.  Your mileage may vary.

     To limit the number of connections a user can open you can use the following type of rules:

           ipfw add allow tcp from my-net/24 to any setup limit src-addr 10
           ipfw add allow tcp from any to me setup limit src-addr 4

     The former (assuming it runs on a gateway) will allow each host on a /24 network to open at most 10 TCP
     connections.  The latter can be placed on a server to make sure that a single client does not use more
     than 4 simultaneous connections.

     <u>BEWARE</u>: stateful rules can be subject to denial-of-service attacks by a SYN-flood which opens a huge
     number of dynamic rules.  The effects of such attacks can be partially limited by acting on a set of
     <a href="sysctl.8.html#//apple_ref/doc/man/8/sysctl">sysctl(8)</a> variables which control the operation of the firewall.

     Here is a good usage of the <b>list</b> command to see accounting records and timestamp information:

           ipfw -at list

     or in short form without timestamps:

           ipfw -a list

     which is equivalent to:

           ipfw show

     Next rule diverts all incoming packets from 192.168.2.0/24 to divert port 5000:

           ipfw divert 5000 ip from 192.168.2.0/24 to any in

   <b>TRAFFIC</b> <b>SHAPING</b>
     The following rules show some of the applications of <b>ipfw</b> and <a href="../man4/dummynet.4.html#//apple_ref/doc/man/4/dummynet">dummynet(4)</a> for simulations and the like.

     This rule drops random incoming packets with a probability of 5%:

           ipfw add prob 0.05 deny ip from any to any in

     A similar effect can be achieved making use of dummynet pipes:

           ipfw add pipe 10 ip from any to any
           ipfw pipe 10 config plr 0.05

     We can use pipes to artificially limit bandwidth, e.g. on a machine acting as a router, if we want to
     limit traffic from local clients on 192.168.2.0/24 we do:

           ipfw add pipe 1 ip from 192.168.2.0/24 to any out
           ipfw pipe 1 config bw 300Kbit/s queue 50KBytes

     note that we use the <b>out</b> modifier so that the rule is not used twice.  Remember in fact that <b>ipfw</b> rules
     are checked both on incoming and outgoing packets.

     Should we want to simulate a bidirectional link with bandwidth limitations, the correct way is the fol-<font color="#ffffff" class="whiteout">lowing:&nbsp;following:</font>
     lowing:

           ipfw add pipe 1 ip from any to any out
           ipfw add pipe 2 ip from any to any in
           ipfw pipe 1 config bw 64Kbit/s queue 10Kbytes
           ipfw pipe 2 config bw 64Kbit/s queue 10Kbytes

     The above can be very useful, e.g. if you want to see how your fancy Web page will look for a residen-<font color="#ffffff" class="whiteout">tial&nbsp;residential</font>
     tial user who is connected only through a slow link.  You should not use only one pipe for both direc-<font color="#ffffff" class="whiteout">tions,&nbsp;directions,</font>
     tions, unless you want to simulate a half-duplex medium (e.g. AppleTalk, Ethernet, IRDA).  It is not
     necessary that both pipes have the same configuration, so we can also simulate asymmetric links.

     Should we want to verify network performance with the RED queue management algorithm:

           ipfw add pipe 1 ip from any to any
           ipfw pipe 1 config bw 500Kbit/s queue 100 red 0.002/30/80/0.1

     Another typical application of the traffic shaper is to introduce some delay in the communication.
     This can significantly affect applications which do a lot of Remote Procedure Calls, and where the
     round-trip-time of the connection often becomes a limiting factor much more than bandwidth:

           ipfw add pipe 1 ip from any to any out
           ipfw add pipe 2 ip from any to any in
           ipfw pipe 1 config delay 250ms bw 1Mbit/s
           ipfw pipe 2 config delay 250ms bw 1Mbit/s

     Per-flow queueing can be useful for a variety of purposes.  A very simple one is counting traffic:

           ipfw add pipe 1 tcp from any to any
           ipfw add pipe 1 udp from any to any
           ipfw add pipe 1 ip from any to any
           ipfw pipe 1 config mask all

     The above set of rules will create queues (and collect statistics) for all traffic.  Because the pipes
     have no limitations, the only effect is collecting statistics.  Note that we need 3 rules, not just the
     last one, because when <b>ipfw</b> tries to match IP packets it will not consider ports, so we would not see
     connections on separate ports as different ones.

     A more sophisticated example is limiting the outbound traffic on a net with per-host limits, rather
     than per-network limits:

           ipfw add pipe 1 ip from 192.168.2.0/24 to any out
           ipfw add pipe 2 ip from any to 192.168.2.0/24 in
           ipfw pipe 1 config mask src-ip 0x000000ff bw 200Kbit/s queue 20Kbytes
           ipfw pipe 2 config mask dst-ip 0x000000ff bw 200Kbit/s queue 20Kbytes

   <b>SETS</b> <b>OF</b> <b>RULES</b>
     To add a set of rules atomically, e.g. set 18:

           ipfw set disable 18
           ipfw add NN set 18 ...         # repeat as needed
           ipfw set enable 18

     To delete a set of rules atomically the command is simply:

           ipfw delete set 18

     To test a ruleset and disable it and regain control if something goes wrong:

           ipfw set disable 18
           ipfw add NN set 18 ...         # repeat as needed
           ipfw set enable 18; echo done; sleep 30 &amp;&amp; ipfw set disable 18

     Here if everything goes well, you press control-C before the "sleep" terminates, and your ruleset will
     be left active. Otherwise, e.g. if you cannot access your box, the ruleset will be disabled after the
     sleep terminates thus restoring the previous situation.

<b>SEE</b> <b>ALSO</b>
     <a href="../man1/cpp.1.html#//apple_ref/doc/man/1/cpp">cpp(1)</a>, <a href="../man1/m4.1.html#//apple_ref/doc/man/1/m4">m4(1)</a>, <!-- a -->bridge(4)<!-- /a -->, <a href="../man4/divert.4.html#//apple_ref/doc/man/4/divert">divert(4)</a>, <a href="../man4/dummynet.4.html#//apple_ref/doc/man/4/dummynet">dummynet(4)</a>, <a href="../man4/ip.4.html#//apple_ref/doc/man/4/ip">ip(4)</a>, <a href="../man4/ipfirewall.4.html#//apple_ref/doc/man/4/ipfirewall">ipfirewall(4)</a>, <a href="../man5/protocols.5.html#//apple_ref/doc/man/5/protocols">protocols(5)</a>, <a href="../man5/services.5.html#//apple_ref/doc/man/5/services">services(5)</a>,
     <!-- a -->init(8)<!-- /a -->, <!-- a -->kldload(8)<!-- /a -->, <a href="reboot.8.html#//apple_ref/doc/man/8/reboot">reboot(8)</a>, <a href="sysctl.8.html#//apple_ref/doc/man/8/sysctl">sysctl(8)</a>, <a href="syslogd.8.html#//apple_ref/doc/man/8/syslogd">syslogd(8)</a>

<b>BUGS</b>
     The syntax has grown over the years and sometimes it might be confusing.  Unfortunately, backward com-<font color="#ffffff" class="whiteout">patibility&nbsp;compatibility</font>
     patibility prevents cleaning up mistakes made in the definition of the syntax.

     <u>!!!</u> <u>WARNING</u> <u>!!!</u>

     Misconfiguring the firewall can put your computer in an unusable state, possibly shutting down network
     services and requiring console access to regain control of it.

     Incoming packet fragments diverted by <b>divert</b> or <b>tee</b> are reassembled before delivery to the socket.  The
     action used on those packet is the one from the rule which matches the first fragment of the packet.

     Packets that match a <b>tee</b> rule should not be immediately accepted, but should continue going through the
     rule list.  This may be fixed in a later version.

     Packets diverted to userland, and then reinserted by a userland process may lose various packet
     attributes.  The packet source interface name will be preserved if it is shorter than 8 bytes and the
     userland process saves and reuses the sockaddr_in (as does <a href="natd.8.html#//apple_ref/doc/man/8/natd">natd(8)</a>); otherwise, it may be lost.  If a
     packet is reinserted in this manner, later rules may be incorrectly applied, making the order of <b>divert</b>
     rules in the rule sequence very important.

<b>AUTHORS</b>
     Ugen J. S. Antsilevich,
     Poul-Henning Kamp,
     Alex Nash,
     Archie Cobbs,
     Luigi Rizzo.

     API based upon code written by Daniel Boulet for BSDI.

     Work on <a href="../man4/dummynet.4.html#//apple_ref/doc/man/4/dummynet">dummynet(4)</a> traffic shaper supported by Akamba Corp.

<b>HISTORY</b>
     The <b>ipfw</b> utility first appeared in FreeBSD 2.0.  <a href="../man4/dummynet.4.html#//apple_ref/doc/man/4/dummynet">dummynet(4)</a> was introduced in FreeBSD 2.2.8.  Stateful
     extensions were introduced in FreeBSD 4.0.  <b>ipfw2</b> was introduced in Summer 2002.

Darwin                          August 13, 2002                         Darwin
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man8/ipfw.8.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man8/ipfw.8.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man8/ipfw.8.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
