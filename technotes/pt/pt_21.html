<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note PT21: MacApp Segmentation Illuminations</title><meta name="categories" content="Platforms and Tools"><meta name="week-posted" content="Nov 30, 1992 - Dec 4, 1992"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002675" title="MacApp Segmentation Illuminations"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxTools-date.html">Tools</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Java/idxTools-date.html" target="_blank">Reference Library > Tools</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note PT21</div>
<div id="pageheadsub">MacApp Segmentation Illuminations</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Introduction</A><BR><BR><A HREF="#Section2">The Need for Segmentation</A><BR><BR><A HREF="#Section3">Jump Tables and Performance</A><BR><BR><A HREF="#Section4">Strategies</A><BR><BR><A HREF="#Section5">How to Segment MacApp Code</A><BR><BR><A HREF="#Section6">'res!' and 'seg!' Resources Explained</A><BR><BR><A HREF="#Section7">UnloadAllSegments Explained </A><BR><BR><A HREF="#Section8">Development Tools, ModelFar Support</A><BR><BR><A HREF="#Section9">Segments and Fragmentation</A><BR><BR><A HREF="#Section10">Linker Problems and Errors</A><BR><BR><A HREF="#Section11">Resident Segment Dangers</A><BR><BR><A HREF="#Section12">Conclusion</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note describes MacApp segmentation strategies and guidelines. Italso describes performance, runtime, and development tools issues related tosegmentation. Some of the discussion is also relevant to general segmentationstrategies with non-MacApp-based applications. The MacApp techniques are basedon MacApp 3.0; however, many of the issues are also relevant to MacApp 2.0.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Dec 01 1992]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><h2>Introduction</h2><p>Some people consider defining a segmentation strategy for a Macintoshapplication a black art. Well, it is a form of programming art. Like manyproblems in software development, defining a segmentation strategy for aMacintosh application requires choosing between a number of conflictingtradeoffs to meet the performance criteria of a given application. Segmentationstrategies that are optimized for speed generally require a larger footprint inmemory, while strategies that are optimized for memory usage come with aperformance hit. Unfortunately, there are no tools available for automaticallysegmenting applications.</p><p>There are few tools available that help define segmentation strategies. Alsothe information on how to do this is not fully documented.</p><p>This Technical Note will try to cover the most important issues of segmentationwith MacApp programs and to help developers create their own segmentationstrategies.</p><a name="Section2"></a><P><A HREF="#top">Back to top</A></p><h2>The Need for Segmentation</h2><p>Inside Macintosh describes how the Segment Loader works, and why there's a needto create segments that are loaded into memory on demand. The syntax forcreating a segment name is:</p><p>C++: Specify a <code>#pragma segment SegmentName </code>in front of the member function </p><P>Object Pascal:  Specify a <code>{$S SegmentName} </code>in front of the method</p><p>If you forget to place the segment compiler directives in your method, it willinherit the earlier directive (in C++ as well as in Object Pascal) all the wayto the end of the file, so suddenly you'll find many methods inside one of yoursegments. Methods without any defined segment will go into the <code>Main</code>segment, which could get really crowded after a while. So, check yoursegmentation directive for each method. For instance MacBrowse has a functionfor doing this that shows what each segment contains. Also, the <code>Link -map</code>(or the <code>MABuild -LinkMap</code>) flag creates a link map withinformation about what functions belong to what segments.</p><p>Segments are really <code>CODE</code> resources in disguise, so MacApp is able tocontrol the purge and lock bits on segments just as it does on handles orobjects (as in <code>TObject</code>'s <code>Lock</code> and <code>UnLock</code> methods). Alocked handle is also unpurgeable, so you don't need to worry about purgingonce you have locked the object in memory. MacApp marks all code segments asnonpurgeable so that the MacApp memory manager can control when and whichsegments it purges in low memory conditions.</p><p>Methods are the actual routines stored in the <code>CODE</code> resources; data isstored either on the stack, in the application heap, or in the specific part ofthe heap that is the A5-world. In many cases, calling a method whose segment isnot currently stored in memory causes a segment load to occur, which mightcause heap blocks to be moved in order to locate a place to put the newsegment.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>This is one reason calling a new class method can suddenly triggermemory dereferencing bugs.</P></TD></TR></TABLE></CENTER><BR><a name="Section3"></a><P><A HREF="#top">Back to top</A></p><h2>Jump Tables and Performance</h2><p>There is a known relation between jump table sizes and segmentation. For normalprocedures and functions, we don't need a jump table entry if all calls to theroutine are from the same segment (<i>intrasegment call</i>). However, we needjump table entries if there are calls to other segments from the routine(<i>intersegment calls</i>). Examine the segmentation of your code; you mightfind places where a change in segmentation would eliminate jump table entries.With some effort you may shrink big jump tables and improve the performance ofyour application.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Object-oriented code relying on polymorphism makes this approachnearly impossible. This is because we will never know what function is finallycalled via the virtual or method table dispatch.</P></TD></TR></TABLE></CENTER><BR><p>Some programmers worry that many C++ accessor (Get...) and mutator (Set...)methods will increase the jump table entries considerably, but you can avoidthis by using C++ <code>inline</code> functions. Anyway, if your classes have toomany field change and access methods, perhaps it is time to examine the object.Is it really a structure in disguise?</p><p>Caching of member field values inside the class (for instance keeping track offield values using temp variables) decreases the need for Get and Set calls.This design is, however, not purely object-oriented, because the class thenneeds to know about the internal implementation of an object. For instance itneeds to know when the cached value is invalid, and it also assumes too muchabout the internal fields. In addition, we could place the major parts of anobject inside one single segment for further performance improvements. Thishelps mostly if the accessors are providing information to other objects thatreside in the same segment, as in the case where we use accessors internally inthe same object. You can use <code>dumpobj</code> to dump the object file and findinformation about each segment.</p><p>The Segment Loader has to fill the jump table with the right addresses when thesegments are loaded in. When the segment is unloaded, the environment has toreset the jump table with information about the missing segment. MacApp has tomake sure that memory is always available for data and unloaded segments. Allthis takes time, so clever segmentation does improve performance. Also,PowerBook owners don't like applications that spend a lot if time starting thehard disk--for instance for fetching CODE resources frequently! For example, ifwe place functions that call each other in the same segment, we will eliminateother segment loading events.</p><a name="Section4"></a><P><A HREF="#top">Back to top</A></p><h2>Strategies</h2><p>One strategy for organizing segments is based on functionality--functions thatwork together <i>should be placed in the same segment </i>(see reason definedearlier). For example, we need certain routines during an application'sinitialization phase, but after initialization is complete they can reside ondisk until the next launch of the application.</p><P>Another strategy is to organize segments so they are <i>as small aspossible</i>. This means that the application heap will contain only thosesegments that we need, increasing the amount of application heap available. Theproblem with this segmentation strategy has to do with all the Segment Loadercalls that we trigger every time a function is not available in memory. Thishappens only if the segment itself is not initially loaded. Once a segment isloaded, it is marked purgeable when not used by MacApp, and unless we have afull application heap, the segment is still present in memory. Still, if weneed to load a lot of segments from a hard disk, it will cause a lot of diskspinning in the case of portables. And end users don't like disks that spin,because they decrease the battery lifetime.</p><a name="Section5"></a><P><A HREF="#top">Back to top</A></p><h2>How to Segment MacApp Code</h2><p>The strategy presented below is a guideline to MacApp application segmentation,but it should not be taken as a prime directive. However, as this is thecurrent MacApp strategy it is not really feasible to use any other alternatesegmentation strategies with MacApp applications, because MacApp will be a bigpart of the application code. However, feel free to experiment and test withthe other alternative--small CODE segments--in code that you control.</p><p>The MacApp strategy is based on functional groupings, where functions relatedto each other (they call each other) are placed in the same segment. Thefunctional grouping is:</p><P align=center><img src="images/pt_21_001.gif" alt="functional grouping" width=496 height=560></p><p>MacApp has far more segments. We recommend that you do a search of the"<code>pragma segment</code>" string in the MacApp library sources to get the wholepicture of what function groupings MacApp uses. Or use MacBrowse or a similarbrowser that shows segmentation information for each method in the framework.For instance, if you write <code>TAppleEvent</code>-based member functions, checkthe <code>UAppleEvents.cp</code> file to see where various <code>TAppleEvent</code>member functions are placed. If you override any of them, make sure that youplace the overridden method in the same segment as the original one. Forinstance some of the Apple event-related functions and methods should be placedin resident segments; otherwise you could get into trouble. Here MacBrowse alsogives good support for a quick lookup of segment names.</p><h3>Other Issues:</h3><p>Unsure about the placement?</p><P>Place the method in the same segment as other methods that call it.</p><p>Stack-based C++ classes?</p><P>Place the member functions of these classes in the same segment thatcorresponds to the functionality (in the same segment as the routine or memberfunction that use them).</p><P>WDEFs, CDEFs, and similar code segments--should they be part of the classsegment?</p><P>Place these CODE segments into the <code>Main</code> segment. This is because wewant these to be always resident in memory for fast access.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Monitor the size of the <code>Main</code> segment.</P></TD></TR></TABLE></CENTER><BR> <a name="Section6"></a><P><A HREF="#top">Back to top</A></p><h2>'res!' and 'seg!' Resources Explained</h2><p>MacApp programmers sometimes will get puzzled concerning the use of<code>'res!'</code> and <code>'seg!'</code> resources. The <code>'seg!'</code> resourcedefines those segments that are loaded into memory when the program is makingmaximum use of memory. MacApp uses this information when keeping track of thecode reserve to ensure there is room for the <code>'seg!'</code> code segments atthe maximum point of memory use. See Chapter 6 of the <i>Guide to MacAppTools</i> concerning discussion of maximum use of memory.</p><p>The <code>'res!'</code> resource defines those segments that are always resident inthe heap. (Segments are made permanently resident via a global function called<code>SetResidentSegment</code>.)</P><P>One use for making segments permanently resident is for time-critical functionsgrouped together in a special segment. Thus, loading the segment doesn'trequire overhead if the method is suddenly needed. For example, we could usethis technique to reduce overhead for time-critical communication methods.Also, we might have functions that are called during interrupt time that alwaysneed to be resident.</p><p>Here's an example of a <code>'res!'</code> resource defined in the resource file:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>resource 'res!' (kMyMacApp,    purgeable) {    {    &quot;AWriteConn&quot;;        &quot;AReadConn&quot;;        &quot;APoll&quot;;#if qInspector &amp;&amp; !qDebug        &quot;GDebugConn&quot;;#endif#if qPerform        &quot;GPerformanceComms&quot;;#endif    };</pre>	</TD></TR></TABLE></CENTER><p>MacApp will also place internal trap patching code in resident segments, toavoid runtime problems with patches that some entity might suddenly unload.This is also true with programmer-provided trap patches.</p><a name="Section7"></a><P><A HREF="#top">Back to top</A></p><h2>UnloadAllSegments Explained </h2><p>The MacApp programmer should be aware that segments live a dangerous lifeinside the MacApp framework. Unless they are resident, or needed, they arepurged out. This happens both at initialization time, as well as during thelifetime of the application. We don't want to have segments floating around inmemory that we need only during the initialization phase of the application.Likewise, we don't want to have segments in memory that we trigger very fewtimes during the application lifetime.</p><p>So who is taking care of the segmentation cleanup? Your mother? No, it's aglobal function called <code>UnloadAllSegments </code>that is called both duringthe initialization phase and during the idle time of the application. It isalso triggered when the application starts to have little memory space.<code>UnloadAllSegments </code>purges code segments from the memory unless they arelocked, in use, or resident (specified in the <code>res!</code> resource).</p><p>However, we might have situations where we have written code by mistake so that<code>UnloadAllSegments </code>wants suddenly to purge the segment that iscurrently in use. This function could unload a segment containing a method thatyou will return to later. Your stack currently references a method contained inthe segment that <code>UnloadAllSegments </code>wants to unload. Danger, danger.</p><P>Now, if you have SourceBug running in the background, and have the warning flagin the Debug menu entry set for unloading segments, you will get a nice littlewarning from <code>UnloadAllSegments </code>before you get into the binaryArmageddon...</p><a name="Section8"></a><P><A HREF="#top">Back to top</A></p><h2>Development Tools, ModelFar Support</h2><p>For a long time, segments were restricted to 32K sizes due to the A5-relativedata referencing with 16-bit offsets, but MPW 3.2 eliminates this 32K limit onsegment size via new switches to the compilers and the linker.</p><p>The 68020 introduced 32-bit PC-relative branching (<code>BSR.L</code> statements),but that didn't help the Classic and other 68000-based Macintosh computers.Instead, MPW 3.2 makes use of branch islands. This simple, elegant idea isbased on the implementation of PC-relative code-to-code references. The linkersplits a large code segment up into smaller 32K areas by inserting branchislands. These branch islands serve as intermediate points that are withinrange of PC-relative jumps, thus making it possible to make a call across asegment that would otherwise result in a larger-than-32K jump.</p><p>Another new feature is "32-bit everything," which transparently removes thelimitations on code segment and jump table sizes and the size of the globaldata areas. The drawback is a larger code size footprint and some slowdown dueto increased load time for the larger code segments. But hey, look what youget!</P><P>We activate 32-bit everything code generation and linking by using the<code>MABuild</code> <code>-ModelFar</code> flag (supported from with MacApp 3.0forward).The new MPW 3.2 documentation on the runtime architecture explains theimplementation. The trick is that the compilers generate instructions with32-bit addresses (instead of the normal 16-bit offsets), and that these 32-bitaddresses are relocated at load time by the segment load address or by thecontents of A5, as appropriate.</p><p>Finally, one can generate larger than 32K jump tables using the <code>-wrap</code>option. This uses unused space in the global data area for additional jumptable entries when it starts to get crowded inside the 32K segment. However, atbest this utility doubles the jump table size, and if your global data area isalready filled with data, you're out of luck.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>You can't use both the <code>-wrap </code>and the <code>ModelFar</code>flags in order to cheat and create a large global data segment with jump tableentries as well. Use either flag only.</P></TD></TR></TABLE></CENTER><BR><p>See MPW documentation for more information about <code>ModelFar</code> and runtimeissues.</p><p>Also, the MacApp debugger has support for monitoring segment loading andunloading. Please consult the current MacApp documentation for moreinformation.</p><a name="Section9"></a><P><A HREF="#top">Back to top</A></p><h2>Segments and Fragmentation</h2><p>Sometimes we want to move a separate segment back into the <code>Main</code>segment, to avoid too many segments--a condition that can lead to heapfragmentation. This could be the case with libraries that we use with theMacApp application. For instance functions from libraries might reside in smallsegments, and we would like to remap them back to a resident segment, such as<code>Main</code>. The MPW <code>Link</code> and <code>Lib</code> tools can remap thesegmentation with routines to other segment names. The syntax looks likethis:</p><code></code><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Link [options...] objectfile... &gt;= progress.file    -sn=oldSegName1=newSegName1</pre>	</TD></TR></TABLE></CENTER><p>Note that fragmentation is not a problem for MacApp applications. All residentsegments are preloaded and locked high in memory. Nonresident segments that arein use are also locked high. Segments that are not in use but still present arenot locked. This means they can be moved by the Memory Manager (which does notcontribute any fragmentation).</p><p>Another solution is to use the linker to mark code resources from the librariesas locked. These segments will then be loaded into memory as resident segments,avoiding fragmentation problems. To do this, for instance modify the uservariable <code>OtherLinkOptions</code> in the <code>MAMake</code> file:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OtherLinkOptions = [[partialdiff]]    -ra FOOSEGMENT=resLocked [[partialdiff]]</pre>	</TD></TR></TABLE></CENTER><p>Yet again in the case of MacApp this is not necessary. The MacApp way is todefine these segments in the <code>'res!'</code> resource, and MacApp will lock theresources at application startup.</p><p>Finally, you can use the linker to merge old segments into new segments withthe <code>-sg</code> option:</p><a name="Section10"></a><P><A HREF="#top">Back to top</A></p><h2>Linker Problems and Errors</h2><p>A very typical <code>Link</code> error with huge MacApp projects looks like:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>### Link: Error: 16-bit reference offset out of range.[....]### While reading file &quot;Work:Sources:FooBar SuperApp:[....]### Link: Error: 16-bit reference offset out of range. [....]### Link: Error: 16-bit reference offset out of range. [....]</pre>	</TD></TR></TABLE></CENTER><p>This means that the linker can't create 16-bit offset references within thesame code segment, or that we can't do 16-bit PC-relative jumps. The way to gois to start using <code>ModelFar</code> support.</p><p>Sometimes even if we compile and link using <code>-ModelFar</code>, we will stillsee these problems. This has to do with <code>Runtime.o</code> and all otherstandard libraries in MPW that are not compiled with <code>ModelFar</code>.Sometimes the placement of link modules helps, where the module with the mainstub is the first one, <code>Runtime.o </code>is the second one (usually<code>Runtime.o</code> and <code>Main</code> talk with each other a lot), then moststandard libraries and all the other modules last. If you suspect this is thecase, modify the <code>"Build Rules and Definitions"</code> MacApp file, and movethe <code>Runtime.o </code>link instruction nearer the libraries or object filesthat contain <code>Main</code> segments.</p><p>Another trick is to use the -<code>sortsg</code> link flag. The linker will movethe most frequently called routines to the first 32K part of the segment, andin some cases this will solve the offset problem. Finally if you have a lot ofstring literals, if you use the <code>-b2</code> link flag the strings will beembedded in e.</p><a name="Section11"></a><P><A HREF="#top">Back to top</A></p><h2>Resident Segment Dangers</h2><p>Here's an important note to remember. If you make a segment resident (forinstance including it in the '<code>res!'</code> resource), then the MacApp memorymanagement code will call <code>GetNamedResource</code> to load the segment, andalso lock it. However, the jump table still has this segment defined in anunloaded state.</p><p>So the first time you call a routine in the segment, the code will trigger a<code>LoadSeg</code> call. Now the jump table has the segment defined to be in aloaded state (no more need for <code>LoadSeg</code> calls).</p><p>This works fine during a safe period of segment loading. However, if you callthe routine during a critical time when it's not safe to call <code>LoadSeg</code>(for instance from a VBL task), you might get into trouble.</p><p>One workaround is to make sure to call the first routine from this residentsegment during a safe time. For instance you could call the function itselffrom another segment (as in the initialization phase, from <code>Main</code>). Thiswill cause the Segment Loader to convert the function's jump table entry, sothis function could be used at more dangerous times. You need to define aspecific way to inform your function that it's only been called to load itsentry, and not to do any useful work (until later).</p><a name="Section12"></a><P><A HREF="#top">Back to top</A></p><h2>Conclusion</h2><p>It is hoped that these suggestions will improve the segmentation strategies inyour application. Future new runtime models (the Shared Library Manager,PowerPC runtime environments, Bedrock) might radically change the waydevelopers segment code. Stay tuned for more news.</p><a name="References"></a><P><A HREF="#top">Back to top</A></p><h2>References</h2><P><i>Inside Macintosh,</i> Volume II, Chapter 2 (Segment Loader)</p><P><i>MPW Command Reference</i> (forthcoming)</p><P><i>Building and Managing Programs in MPW</i> (forthcoming)</p><P>MPW 3.2 Release Notes</p><P><i>Guide to MacApp Tools</i> (MacApp 3.0)</p><P><i>MADA 92 Orlando Conference CD,</i> Presentation on the MacApp 3.0</p><P>Memory Manager</p>         <a name=Downloads></A>                  <P><A HREF="#top">Back to top</A></p><h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/pt_21.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/pt/pt_21.html%3Fid%3DDTS10002675-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/pt/pt_21.html%3Fid%3DDTS10002675-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/pt/pt_21.html%3Fid%3DDTS10002675-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>