<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>OTRcvReply</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING188></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-187.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-189.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-81.html"><B>Part 2 - Open Transport Reference</B></A><BR><DD><A HREF="NetworkingWOT-127.html"><B>Chapter 22 - Endpoints Reference</B></A> / <A HREF="NetworkingWOT-146.html"><B>Functions</B></A><BR><DL><DD><A HREF="NetworkingWOT-184.html"><B>Functions for Connection-Oriented Transaction-Based Endpoints</B></A> / </DL></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING188-0></A>
<H3><A NAME=MARKER-9-226></A>OTRcvReply</H3>
 Reads a transaction reply sent by a connection-oriented responder.<P>
<A NAME=HEADING188-2></A>
<H5>C INTERFACE</H5>
<PRE>
<A NAME=MARKER-11-227></A>OSStatus OTRcvReply(EndpointRef ref,
                     TReply* reply, 
                                         OTFlags* replyFlags);
</PRE>
<A NAME=HEADING188-4></A>
<H5>C++ INTERFACE</H5>
<PRE>
<A NAME=MARKER-12-228></A>OSStatus TEndpoint::RcvReply(TReply* reply, 
                     OTFlags* replyFlags);
</PRE>
<A NAME=HEADING188-6></A>
<H5>PARAMETERS</H5>
<DL>
<DT><CODE>ref</CODE>
<DD> The endpoint reference of the endpoint reading the reply.<P>
<DT><CODE>reply</CODE>
<DD> A pointer to a <A HREF=NetworkingWOT-144.html#MARKER-9-109><CODE>TReply</CODE></A> structure that specifies where to store the reply information. You must allocate buffers to contain the reply data, option values, and the transaction ID of the request to which the reply is being sent, and you must specify the maximum size of this data.<P>
<DT>
<DD> The <CODE>reply-&gt;data.buf</CODE> field points to a buffer in which the reply data is to be stored. Set the <CODE>reply-&gt;data.maxlen</CODE> field to the maximum size of the reply data.<P>
<DT>
<DD> The <CODE>reply-&gt;opt.buf</CODE> field points to a buffer in which option values are stored. Set the <CODE>reply-&gt;opt.maxlen </CODE>field to the maximum size of this data.<P>
<DT>
<DD> The <CODE>reply-&gt;sequence </CODE>field specifies the transaction ID of the transaction to which the reply is sent. If you have sent out multiple requests, you can examine this field to match replies to requests.<P>
<DT><CODE>replyFlags</CODE>
<DD> A bitmapped 32-bit value specifying <CODE>T_MORE</CODE> or <CODE>T_PARTIALDATA</CODE>. A value of <CODE>T_MORE</CODE> indicates that the buffer pointed to by <CODE>reply-&gt;data.buf </CODE>is too small to contain the reply. A value of <CODE>T_PARTIALDATA</CODE> indicates that the data unit being read does not contain the complete reply and that the next data unit might belong to a different transaction.<P>
<DT><I>function result</I>
<DD> An error code. See <A HREF=NetworkingWOT-479.html#MARKER-9-72>Appendix B</A>, and Discussion.
</DL>
<A NAME=HEADING188-14></A>
<H5>DISCUSSION</H5>
 You use the <CODE>OTRcvReply</CODE> function to read the reply to a request that you sent using the <A HREF=NetworkingWOT-185.html#MARKER-9-217><CODE>OTSndRequest</CODE></A> function.<P>
 If the endpoint is in asynchronous mode, the endpoint provider issues the <CODE>T_REPLY</CODE> event to let you know that incoming reply data is available. After you retrieve this event, using the <A HREF=NetworkingWOT-156.html#MARKER-9-143><CODE>OTLook</CODE></A> function or your notifier function, you must call the <CODE>OTRcvReply</CODE> function repeatedly to read the reply data until it returns <CODE>kOTNoDataErr</CODE>. The endpoint provider does not generate additional <CODE>T_REPLY</CODE> events until you have read the complete reply.<P>
 If a transaction has timed out awaiting reply data, the <CODE>OTRcvReply</CODE> function returns a <CODE>kETIMEDOUTErr</CODE> result; the <CODE>sequence</CODE> field of the <CODE>reply</CODE> parameter specifies which request has timed out. <P>
 If you have issued multiple requests, it is not possible to know ahead of time how incoming replies match your requests. You must be prepared to receive a reply to any outstanding request. One way to manage this situation is to call the <CODE>OTRcvReply</CODE> function with the <CODE>reply-&gt;udata.maxlen</CODE> field set to 0. The rest of the information returned by the function on this first call lets you know the sequence number of the reply as well as the <CODE>replyFlags</CODE> setting. Once you determine the matching request and the appropriate reply buffer, you can call the <CODE>OTRcvReply</CODE> function a second time to read the actual reply data. On the second and subsequent reads, Open Transport sets the <CODE>reply-&gt;opt.len</CODE> field to 0. It is guaranteed that once a reply has been partially read, subsequent calls to <CODE>OTRcvReply</CODE> read from that same reply until all the available data has been read. The <CODE>T_PARTIALDATA</CODE> event might be returned if the entire reply is not available.<P>
 If the <CODE>T_MORE</CODE> bit is set in the <CODE>replyFlags</CODE> parameter, this means your buffer is not large enough to hold the entire reply. You must call the <CODE>OTRcvRequest</CODE> function again to retrieve more request data. Open Transport ignores the <CODE>addr</CODE> and <CODE>opt</CODE> fields of the <CODE>reply</CODE> parameter for subsequent calls to the function. The <CODE>T_MORE</CODE> flag is not set for the last reply packet to let you know that this is the last packet. <P>
 If the <CODE>T_PARTIALDATA </CODE>bit is set in the <CODE>replyFlags</CODE> parameter, this means that the data you are about to read with the <CODE>OTRcvReply</CODE> function does not constitute the entire reply and that more data is coming, but it has not yet arrived. You must call the function again to read more, or the rest, of the reply.<P>
 If the <CODE>T_MORE</CODE> and the <CODE>T_PARTIALDATA</CODE> bits are both set, this means that the data you are about to read constitutes only part of the reply and that your buffer is too small to contain even this chunk. In this case, you must call the function again until the <CODE>T_MORE</CODE> flag is clear. The <CODE>T_PARTIALDATA</CODE> bit is set only on the first call to the function.<P>
 If you are communicating with multiple responders and if the <CODE>OTRcvUReply</CODE> function returns with the <CODE>T_PARTIALDATA</CODE> flag set, it is possible that your next call to the function might not read the rest of the reply because the next data unit coming in belongs to a different reply. One way to handle this situation is to use the next call to the <CODE>OTRcvReply</CODE> function to determine the sequence number of the incoming reply (by setting <CODE>req-&gt;udata.maxlen</CODE> to 0) and then, having determined which reply data is coming in, read the data into the appropriate buffer. <P>
<A NAME=HEADING188-23></A>
<H5>SEE ALSO</H5>
 The <A HREF=NetworkingWOT-185.html#MARKER-9-217><CODE>OTSndRequest</CODE></A> function.<P>
 <A HREF=NetworkingWOT-27.html#MARKER-9-12>Table 4-4</A>.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="NetworkingWOT-187.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-189.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
