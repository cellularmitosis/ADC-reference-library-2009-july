<html><head><title>Advanced Enterprise Object Modeling</title></head><body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOF Developer's Guide</font><br><br><!--end of path --> <a href="EOsII.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="EOsII3.html"><IMG SRC="ArrowLeft.gif">Previous Section</a><P> <a name="10458"><h1> Designing Database-Savvy Enterprise Objects</h1></a><a name="251">The main function of a class object is to act as a factory for its instances, so a class method is a natural place to implement custom instantiation. When instances are initialized with data fetched from a database, why not implement common database queries in the class object as creation methods? For example, a video rental store application based on the sample Rentals database might have a requirement to fetch all overdue rentals. To fulfill this requirement, you could write a Rental class method such as the following that fetches all its overdue instances:<p></a><a name="11649">In Java:<p></a><pre><a name="11807">public static NSArray overdueRentalsWithEditingContext(<br>	EOEditingContext ec)<br>{<br>	NSGregorianDate today = new NSGregorianDate();<br>	EOQualifier qualifer = new EOKeyValueQualifier(<br>		"dueDate",<br>		EOQualifier.QualifierOperatorLessThan,<br>		today);<br>	EOFetchSpecification fetchSpec = new EOFetchSpecification(<br>		@"Rental",<br>		qualifer,<br>		null);<br><br>	return ec.objectsWithFetchSpecification(fetchSpec);<br>}</a></pre><a name="11650">In Objective-C:<p></a><pre><a name="263">+ (NSArray *)<br>	overdueRentalsWithEditingContext:(EOEditingContext *)ec<br>{<br>	NSCalendarDate *today = [NSCalendarDate calendarDate];<br>	EOQualifier *qualifer =<br>		[EOQualifier qualifierWithQualifierFormat:<br>			@"dueDate &lt; %@",<br>			today];<br>	EOFetchSpecification *fetchSpec =<br>		[EOFetchSpecification<br>			fetchSpecificationWithEntityName:@"Rental"<br>			qualifier:qualifer sortOrderings:nil];<br><br>	return [ec objectsWithFetchSpecification:fetchSpec];<br>}</a></pre><a name="281">You would then invoke the method as follows:<p></a><a name="11946">In Java:<p></a><pre><a name="11958">rentalArray = Rental.overdueRentalsWithEditingContext(ec);</a></pre><a name="11947">In Objective-C:<p></a><pre><a name="284">rentalArray = [Rental overdueRentalsWithEditingContext:ec];</a></pre><a name="9104">Note that <strong>overdueRentalsWithEditingContext</strong> takes an EOEditingContext as an argument. This is because enterprise objects are fetched into a &#32;particular EOEditingContext. An EOEditingContext establishes a &#32;single, internally consistent "object view" of the database, and an enterprise object in one editing context shouldn't have references to enterprise objects in another one. Consequently, methods that fetch enterprise objects must fetch them using the correct EOEditingContext.<p></a><a name="9105">Because a class object is global, its static methods (class methods in Objective-C) can be invoked from anywhere in an application. Thus, a &#32;class method that returns enterprise objects fetched from the database needs to receive the correct EOEditingContext as an argument.<p></a><a name="8708"><B>Note: </B> While the Rental class in this example closely resembles the Rental class for the sample Rentals database, <strong>dueDate</strong> has been added here to simplify the qualifier for fetching overdue rentals. The Rental class for the sample Rentals database doesn't have a <strong>dueDate</strong> attribute.<p></a><a href="EOsII.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="AppConfs.html"><IMG SRC="ArrowRight.gif">Next Section</a><P></body></html>