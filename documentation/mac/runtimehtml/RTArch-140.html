<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Segment Manager Hooks</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING140></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="RTArch-139.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-141.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="RTArch-2.html"><B>Mac OS Runtime Architectures</B></A> / <BR><DD><A HREF="RTArch-137.html"><B>Appendix B - The RTLib.o and NuRTLib.o Libraries</B></A> / <A HREF="RTArch-139.html"><B>Runtime Operations</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING140-0></A>
<H2>Segment Manager Hooks</H2>
 Several <CODE>Runtime</CODE> operations allow the application to take control and execute a user-defined handler routine during the segment loading or unloading process. These operations are<P>
<UL>
<LI><CODE><A NAME=MARKER-2-19></A>kRTSetPreLoad</CODE> and <CODE>kRTSetPreLoadA5</CODE>, which pass control to the handler before loading a segment
<LI><CODE><A NAME=MARKER-2-20></A>kRTSetSegLoadErr</CODE> and <CODE>kRTSetSegLoadErrA5</CODE>, which pass control to the handler if the segment load fails
<LI><CODE><A NAME=MARKER-2-21></A>kRTSetPostLoad</CODE> and <CODE>kRTSetPostLoadA5</CODE>, which pass control to the handler after loading a segment
<LI><CODE><A NAME=MARKER-2-22></A>kRTSetPreUnload</CODE> and <CODE>kRTSetPreUnloadA5</CODE>, which pass control to the handler before calling <CODE>_UnloadSeg</CODE><P>
</UL>
 In each of these cases, control is passed by replacing the null user vector (set up by the patched Segment Manager) with a user handler. <P>
 The <CODE>fRTParams</CODE> structure used with these operations is as follows:<P>
<PRE>
struct RTSetSegLoadParam {
   SegLoadHdlrPtr fUserHdlr;
   SegLoadHdlrPtr fOldUserHdlr;
   };
typedef struct RTSetSegLoadParam RTSetSegLoadParam;
</PRE>
 The pointer <CODE>fUserHdlr</CODE> points to the user handler to be called at the time indicated by the operation. A pointer to the original (bypassed) handler is returned in <CODE>fOldUserHdlr</CODE>.<P>
<A NAME=HEADING140-10></A>
<H3>User Handlers</H3>
 <A NAME=MARKER-2-23></A>A user handler is defined as follows:<P>
<PRE>
typedef pascal short (*SegLoadHdlrPtr)(RTState* state)
</PRE>
 The handler may return a result code of type <CODE>short</CODE>. This code is ignored by the Segment Manager except in the case of the error handler. See <A HREF=#MARKER-9-27>"Error Handling With kRTSetSegLoadErr" (page B-7)</A> for more details. <P>
<DL>
<DT><B>WARNING</B>
<DD>User handlers must be defined within the segment to be loaded into memory when the handler is invoked (usually the main segment). Also, the user handler must not call any routines in unloaded segments as this may result in a system crash.<EM></EM><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Information about the Segment Manager operation is passed to the user handler <A NAME=MARKER-2-24></A>through the <CODE>RTState</CODE> structure. This structure has the following form:<P>
<PRE>
struct RTState {
   unsigned short   fVersion;/* runtime version */
   void*     fSP;       /* SP: address of user return address */
   void*     fJTAddr;   /* PC: address of jump table entry */
                        /*    or  (see fCallType) */
                        /*    address of a transition vector*/
   long      fRegisters[15];/* registers D0-D7 and A0-A6 */
   short     fSegNo;    /* segment number */
   ResType   fSegType;  /* segment type (normally 'CODE') */
   long      fSegSize;  /* segment size */
   Boolean   fSegInCore;/* true if segment is in memory */
   Boolean   fCallType; /* 0 = _LoadSeg, */
                        /* 1 = fJTAddr, address of TVector */
   OSErr     fOSErr;    /* error number */
   long      fReserved2;/* (reserved for future use) */
   };
typedef struct RTState RTState;
</PRE>
 The fields in the structure are as follows:<P>
<UL>
<LI><CODE>fVersion</CODE> is the version number from the A5 or fA5 runtime world.
<LI><CODE>fSP</CODE> has the value of the stack pointer when either <CODE>_LoadSeg</CODE> or <CODE>_UnloadSeg</CODE> was executed. <P>
<UL>
<LI>In the case of <CODE>_LoadSeg</CODE>, if the jump table entry was reached using a <CODE>JSR</CODE> instruction, <CODE>fSP</CODE> is a pointer to the user return address. You can modify the stack pointer value within an error handler to change the return address if you want to continue execution after trapping an error. See <A HREF=#MARKER-9-27>"Error Handling With kRTSetSegLoadErr" (page B-7)</A> for more information. However, this is not recommended since there may not be a user return address on the stack. 
<LI>In the case of <CODE>_UnloadSeg</CODE>, <CODE>fSP</CODE> points to the return adress from the <CODE>_UnloadSeg</CODE> call. <P>
</UL>
<LI><CODE>fJTAddr</CODE> points to either a jump table entry or a transition vector depending on the runtime environment and the value of <CODE>fCallType</CODE>:<P>
<UL>
<LI>In a <CODE>_LoadSeg</CODE> call (<CODE>fCallType</CODE> is <CODE>0</CODE>), <CODE>fJTAddr</CODE> points to the jump table entry called by the user code prior to the <CODE>_LoadSeg</CODE> call. You can modify the value of <CODE>fJTAddr</CODE> within an error handler if you want to retry the segment load procedure. 
<LI>In an <CODE>_UnloadSeg</CODE> call, <CODE>fJTAddr</CODE> points to the function address passed to <CODE>_UnloadSeg</CODE>. 
<LI>In the CFM-68K runtime environment, the <CODE>fJTAddr</CODE> field is always the address of a transition vector. You cannot modify this field when <CODE>fCallType</CODE> is <CODE>1</CODE>.<P>
Note that you should not make any assumptions about the layout of the jump table entry since it varies between the far model and CFM-68K runtme environments and may change in the future.<P>
</UL>
<LI><CODE>fRegisters</CODE> is an array of long integers that contains the register values at the time <CODE>_LoadSeg</CODE> was called. The registers are saved in the order D0 through D7, then A0 through A6.
<LI><CODE>fSegType</CODE> and <CODE>fSegNo</CODE> contain the segment's resource type and ID. <CODE>fSegType</CODE> is usually <CODE>'CODE'</CODE> but this may change in the future. 
<LI><CODE>fSegSize</CODE> contains the size of the segment, in bytes. 
<LI><CODE>fSegInCore</CODE> indicates whether the segment is in memory. If <CODE>fSegInCore</CODE> is <CODE>true</CODE>, the segment is already in the heap but has not been locked. (If the segment is resident, no memory needs to be allocated for it.)
<LI>The <CODE>fCallType</CODE> field is used by other fields whose meanings are dependent on how the segment load was invoked. If <CODE>fCallType</CODE> is <CODE>1</CODE>, the segment load was invoked through a function call by a pointer (or by a virtual method dispatch in C++).
<LI><CODE>fOSErr</CODE> contains an error number. This field is valid only when this structure is passed to an error handler. <P>
</UL>
 All attempts to modify the <CODE>RTState</CODE> structure are ignored except for alterations of <CODE>fJTAddr</CODE> by the user error handle<A NAME=MARKER-2-25></A>r. <A NAME=MARKER-2-26></A><P>
<A NAME=HEADING140-34></A>
<H3><A NAME=MARKER-9-27></A>Error Handling With kRTSetSegLoadErr</H3>
 <A NAME=MARKER-2-28></A>When <CODE>kRTSetSegLoadErr</CODE> invokes the user error handler (that is, when a segment loading error occurs), the stack has the form shown in <A HREF=#MARKER-9-29>Figure B-1</A>.<P>
<B>Figure B-1  <A NAME=MARKER-9-29></A>The stack when a user error handler is called</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-09.jpg"> <P>
 The error handler should use the information at the following locations:<P>
<UL>
<LI>The word at <CODE>8(SP)</CODE> is reserved for the error handler's action code (as described later in this section).
<LI>The value at <CODE>4(SP)</CODE> points to the <CODE>RTState</CODE> structure, which contains information about the error. 
<LI>The value at <CODE>(SP)</CODE> is the return address from the error handler. This value may or may not be used depending on how the routine handles the error.<P>
</UL>
 Items on the stack labeled as optional may not actually appear. For example, a simple <CODE>JMP</CODE> instruction would not push user parameters or a return address onto the stack. <P>
 The error handler should examine the <CODE>RTState</CODE> structure and then take appropriate action (for example, release some memory). After doing so, the handler can do one of the following:<P>
<UL>
<LI>Return an action code on the stack for the Segment Manager and then return. Current action codes are shown in <A HREF=#MARKER-9-5>Table B-3</A>. Attempts to pass any other value to the Segment Manager results in the system error <CODE>daLoadErr</CODE>. 
<LI>use a <CODE>LONGJMP</CODE> (or the equivalent) instruction to pass control to another error handler set up in a parent stack frame. This second handler could save the current document, alert the end user, and quit the application. 
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-5></A><B>Table B-3 Error handler action codes</B></CAPTION>
<TH>Value<TH>Action<TR>
<TD><CODE><A NAME=MARKER-2-6></A>kRTRetry</CODE><TD>Retry. This action restores the stack to its state before the call to <CODE>_LoadSeg</CODE> and reexecutes the jump table entry. If no errors occur this second time, execution continues normally. If the handler modified <CODE>fJTAddr</CODE> in the <CODE>RTState</CODE> structure, execution resumes at the new address.<P>Note that this technique can easily create an infinite loop if the segment loading attempt always fails. Your routine should include a retry counter to break out of the loop after a specified number of tries. <TR>
<TD><CODE>kRTContinue</CODE><TD>Continue. This action restores the stack to its state before the <CODE>_LoadSeg</CODE> call and sets the program counter (PC) to the user return address in the stack. Note that this action is risky since a return address may not always be present on the stack. <A NAME=MARKER-2-7></A></TABLE>
<P>
</UL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="RTArch-139.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-141.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="RTArch-3.html">&copy; Apple Computer, Inc.</A><br>11 MARCH 1997<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
