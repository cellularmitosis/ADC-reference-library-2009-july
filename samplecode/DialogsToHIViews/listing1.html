<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DialogsToHIViews - /main.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxHumanInterfaceToolbox-date.html">Human Interface Toolbox</a> &gt; <A HREF="javascript:location.replace('index.html');">DialogsToHIViews</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DialogsToHIViews</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/main.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/main.c</option></select>
				</p>
				</form>
				<p><strong><a href="DialogsToHIViews.zip">Download Sample</a></strong> (&#147;DialogsToHIViews.zip&#148;, 44.7K)<BR>
<strong><a href="DialogsToHIViews.dmg">Download Sample</a></strong> (&#147;DialogsToHIViews.dmg&#148;, 102.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
*  File:    main.c of DialogsToHIViews
* 
*  Contains:  Shows how to convert from an old-style resource-based dialog to
*              a modern nib-based window with HIViews.
*
*  Note:    The project is set up so that the DEBUG macro is set to one when the &quot;Development&quot;
*        build style is chosen and not at all when the &quot;Deployment&quot; build style is chosen.
*        Thus, all the require asserts &quot;fire&quot; only in &quot;Development&quot;.
*  
*  Version:  1.0
* 
*  Created:  March 22nd, 2004
*
*  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
*        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
*        use, installation, modification or redistribution of this Apple software
*        constitutes acceptance of these terms.  If you do not agree with these terms,
*        please do not use, install, modify or redistribute this Apple software.
*
*        In consideration of your agreement to abide by the following terms, and subject
*        to these terms, Apple grants you a personal, non-exclusive license, under Apple\xCDs
*        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
*        reproduce, modify and redistribute the Apple Software, with or without
*        modifications, in source and/or binary forms; provided that if you redistribute
*        the Apple Software in its entirety and without modifications, you must retain
*        this notice and the following text and disclaimers in all such redistributions of
*        the Apple Software.  Neither the name, trademarks, service marks or logos of
*        Apple Computer, Inc. may be used to endorse or promote products derived from the
*        Apple Software without specific prior written permission from Apple.  Except as
*        expressly stated in this notice, no other rights or licenses, express or implied,
*        are granted by Apple herein, including but not limited to any patent rights that
*        may be infringed by your derivative works or by other works in which the Apple
*        Software may be incorporated.
*
*        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
*        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
*        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
*        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
*        COMBINATION WITH YOUR PRODUCTS.
*
*        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
*        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
*        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
*        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
*        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
*        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
*        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*  Copyright:  Copyright &copy; 2004 Apple Computer, Inc, All Rights Reserved
*/
// ****************************************************
#pragma mark * compilation directives *
// ----------------------------------------------------
// ****************************************************
#pragma mark -
#pragma mark * includes &amp; imports *
// ----------------------------------------------------
#include &lt;Carbon/Carbon.h&gt;
// ****************************************************
#pragma mark -
#pragma mark * typedef's, struct's, enums, defines, etc. *
// ----------------------------------------------------

// ****************************************************
#pragma mark -
#pragma mark * local (static) function prototypes *
// ----------------------------------------------------

static pascal OSStatus CommandProcess(EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void* inUserData);
static void StartTheDialogs(void);

static DialogRef DrawDialogTheSystem6or7Way(void);
static DialogRef DrawDialogTheMacOS8or9Way(void);
static WindowRef DrawDialogTheMacOSXWay(void);
static void RunDialogTheSystem6or7Way(DialogRef theDialog);
static void RunDialogTheMacOS8or9Way(DialogRef theDialog);
static void RunDialogTheMacOSXWay(WindowRef window);
// ****************************************************
#pragma mark -
#pragma mark * exported globals *
// ----------------------------------------------------

// ****************************************************
#pragma mark -
#pragma mark * local (static) globals *
// ----------------------------------------------------
static SInt16 gUserH, gUserV;
// ****************************************************
#pragma mark -
#pragma mark * exported function implementations *
// ----------------------------------------------------

/*****************************************************
*
* Routine:  main (argc, argv)*
* Purpose:  main program entry point
*
* Inputs:  argc   - the number of elements in the argv array
*      argv   - an array of pointers to the parameters to this application
*
* Returns:  int     - error code (0 == no error)
*/
int main(int argc, char* argv[])
{
  IBNibRef nibRef;
  OSStatus err;
  
  // Create a Nib reference passing the name of the nib file (without the .nib extension)
  // CreateNibReference only searches into the application bundle.
  err = CreateNibReference(CFSTR(&quot;main&quot;), &amp;nibRef);
  require_noerr(err, CantGetNibRef);
  
  // Once the nib reference is created, set the menu bar. &quot;MainMenu&quot; is the name of the menu bar
  // object. This name is set in InterfaceBuilder when the nib is created.
  err = SetMenuBarFromNib(nibRef, CFSTR(&quot;MenuBar&quot;));
  require_noerr(err, CantSetMenuBar);
  
  // A bit of an explanation...
  WindowRef window;
  CreateWindowFromNib(nibRef, CFSTR(&quot;Explain&quot;), &amp;window);
  ShowWindow(window);
  
  // We don't need the nib reference anymore.
  DisposeNibReference(nibRef);
  
  // Let's react to User's commands.
  EventTypeSpec eventTypeCP = {kEventClassCommand, kEventCommandProcess};
  InstallEventHandler(GetApplicationEventTarget(), CommandProcess, 1, &amp;eventTypeCP, NULL, NULL);
  
  // And start our dialogs
  StartTheDialogs();
  
  // Call the event loop
  RunApplicationEventLoop();
  
CantSetMenuBar:
CantGetNibRef:
    return err;
}

// ****************************************************
#pragma mark -
#pragma mark * local (static) function implementations *
// ----------------------------------------------------

/*****************************************************
*
* Routine:  CommandProcess(inHandlerCallRef, inEvent, inUserData)*
* Purpose:  called to process commands from Carbon events
*
* Inputs:  inHandlerCallRef  - reference to the current handler call chain
*      inEvent        - the event
*      inUserData      - app-specified data you passed in the call to InstallApplicationEventHandler
*
* Returns:  OSStatus      - noErr indicates the event was handled
*                  eventNotHandledErr indicates the event was not handled and the Toolbox should take over
*/
static pascal OSStatus CommandProcess(EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void* inUserData)
{
  HICommand aCommand;
  OSStatus status = eventNotHandledErr;
  
  GetEventParameter(inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof(HICommand), NULL, &amp;aCommand);
  
  switch (aCommand.commandID)
  {
    case kHICommandNew:
      StartTheDialogs();
      status = noErr;
      break;
  }
  return status;
}


static void StartTheDialogs(void)
{
  WindowRef macOSXWindow = DrawDialogTheMacOSXWay();
  DialogRef macOS8or9Dialog = DrawDialogTheMacOS8or9Way();
  DialogRef macOS6or7Dialog = DrawDialogTheSystem6or7Way();

  RunDialogTheSystem6or7Way(macOS6or7Dialog);
  RunDialogTheMacOS8or9Way(macOS8or9Dialog);
  RunDialogTheMacOSXWay(macOSXWindow);
}

#pragma mark -
#pragma mark * DialogTheSystem6or7Way *

/*
*
 *
 * ---------------- DialogTheSystem6or7Way -----------------------------------
 *
 *
 */

static Boolean MySystem6or7DialogFilter(DialogRef theDialog, EventRecord *inEvent, DialogItemIndex *itemHit)
{
  if ((inEvent-&gt;what == keyDown) || (inEvent-&gt;what == autoKey))
  {
    char c = (inEvent-&gt;message &amp; charCodeMask);
    
    // return or enter key?
    if ((c == kReturnCharCode) || (c == kEnterCharCode))
    {
      *itemHit = 1;
      return true;
    }
    
    // tab key or arrow keys?
    if (c == kTabCharCode) return false;
    if (c == kLeftArrowCharCode) return false;
    if (c == kRightArrowCharCode) return false;
    if (c == kUpArrowCharCode) return false;
    if (c == kDownArrowCharCode) return false;
    
    // digits only for edittext box item #9 ?
    // pre-Carbon, this would have been: ((DialogPeek)theDialog)-&gt;editField+1 == 9
    if (GetDialogKeyboardFocusItem(theDialog) == 9)
    {
      if ((c &lt; '0') || (c &gt; '9'))
      {
        SysBeep(1);
        return true;
      }
    }
  }
  
  // we got a click!
  if (inEvent-&gt;what == mouseDown)
  {
    DialogItemType itemType;
    Handle itemHandle;
    Rect itemBox;
    GetDialogItem(theDialog, 13, &amp;itemType, &amp;itemHandle, &amp;itemBox);
    
    // is the user item enabled?
    if (!(itemType &amp; itemDisable))
    {
      CGrafPtr savePort;
      GetPort(&amp;savePort);
      SetPortDialogPort(theDialog);
      Point thePoint = inEvent-&gt;where;
      GlobalToLocal(&amp;thePoint);
      Boolean inside = PtInRect(thePoint, &amp;itemBox);
      
      // is the click inside the user item?
      if (inside)
      {
        // let's constrain and move the spot!
        // it's possible to track the spot here but it's complex
        // so we just move on the click and don't track.
        // that's typical of dialog's user items of that era.
        Rect userRect1 = {gUserV-4, gUserH-4, gUserV+4, gUserH+4};
        EraseRect(&amp;userRect1);
        InvalWindowRect(GetDialogWindow(theDialog), &amp;userRect1);
        gUserH = thePoint.h;
        gUserV = thePoint.v;
        if (gUserH &lt; itemBox.left+4) gUserH = itemBox.left+4;
        if (gUserH &gt; itemBox.right-4) gUserH = itemBox.right-4;
        if (gUserV &lt; itemBox.top+4) gUserV = itemBox.top+4;
        if (gUserV &gt; itemBox.bottom-4) gUserV = itemBox.bottom-4;
        Rect userRect2 = {gUserV-4, gUserH-4, gUserV+4, gUserH+4};
        InvalWindowRect(GetDialogWindow(theDialog), &amp;userRect2);
      }
      SetPort(savePort);
    }
  }
  
  return false;
}

static void ScrollBarActionProc(ControlRef theControl, ControlPartCode partCode)
{
  SInt16 oldValue = GetControlValue(theControl);
  switch (partCode)
  {
    case kControlUpButtonPart:    SetControlValue(theControl, oldValue - 1); break;
    case kControlDownButtonPart:  SetControlValue(theControl, oldValue + 1); break;
    case kControlPageUpPart:    SetControlValue(theControl, oldValue - 10); break;
    case kControlPageDownPart:    SetControlValue(theControl, oldValue + 10); break;
  }
}

static void MyDrawUserItem(DialogRef theDialog, DialogItemIndex itemNo)
{
  DialogItemType itemType;
  Handle itemHandle;
  Rect itemBox;
  GetDialogItem(theDialog, itemNo, &amp;itemType, &amp;itemHandle, &amp;itemBox);
  
  CGrafPtr savePort;
  GetPort(&amp;savePort);
  SetPortDialogPort(theDialog);
  
  PenState penState;
  GetPenState(&amp;penState);
  
  PenSize(3, 3);
  if (itemType &amp; itemDisable)
  {
    Pattern gray;
    PenPat(GetQDGlobalsGray(&amp;gray));
  }
  FrameRect(&amp;itemBox);
  Rect userRect = {gUserV-4, gUserH-4, gUserV+4, gUserH+4};
  PaintRect(&amp;userRect);
  
  SetPenState(&amp;penState);
  SetPort(savePort);
}

static DialogRef DrawDialogTheSystem6or7Way(void)
{
  DialogItemType itemType;
  Handle itemHandle;
  Rect itemBox;
  
  DialogRef theDialog = GetNewDialog(256, NULL, (WindowRef)-1L);
  if (theDialog == NULL) return(NULL);
  
  // Move it!
  MoveWindow(GetDialogWindow(theDialog), 10, 271, false);
  
  // Setting the check box
  GetDialogItem(theDialog, 2, &amp;itemType, &amp;itemHandle, &amp;itemBox);
  SetControlValue((ControlHandle)itemHandle, 1);
  
  // Setting a radio button
  GetDialogItem(theDialog, 3, &amp;itemType, &amp;itemHandle, &amp;itemBox);
  SetControlValue((ControlHandle)itemHandle, 1);
  
  // Setting the draw proc for the user item
  GetDialogItem(theDialog, 13, &amp;itemType, &amp;itemHandle, &amp;itemBox);
  gUserH = (itemBox.left + itemBox.right) / 2;
  gUserV = (itemBox.top + itemBox.bottom) / 2;
  SetDialogItem(theDialog, 13, itemType, (Handle)&amp;MyDrawUserItem, &amp;itemBox);
  
  // Setting the action proc for the scroll bar so that the PageUp/PageDown/Up/Down buttons work
  GetDialogItem(theDialog, 14, &amp;itemType, &amp;itemHandle, &amp;itemBox);
  SetControlAction((ControlHandle)itemHandle, ScrollBarActionProc);
  
  ShowWindow(GetDialogWindow(theDialog));
  
  return(theDialog);
}

static void RunDialogTheSystem6or7Way(DialogRef theDialog)
{
  SInt16 itemHit;
  DialogItemType itemType;
  Handle itemHandle;
  Rect itemBox;
  
  BringToFront(GetDialogWindow(theDialog));
  
  do {
    ModalDialog(MySystem6or7DialogFilter, &amp;itemHit);
    switch (itemHit)
    {
      case 2:
      {
        // we enable or disable the user item depending on whether the box is checked or not
        GetDialogItem(theDialog, itemHit, &amp;itemType, &amp;itemHandle, &amp;itemBox);
        SInt16 enable = GetControlValue((ControlHandle)itemHandle);
        SetControlValue((ControlHandle)itemHandle, 1 - enable);
        GetDialogItem(theDialog, 13, &amp;itemType, &amp;itemHandle, &amp;itemBox);
        SetDialogItem(theDialog, 13, enable?userItem+itemDisable:userItem, itemHandle, &amp;itemBox);
        HideDialogItem(theDialog, 13);
        ShowDialogItem(theDialog, 13);
      }
        break;
      case 3: case 4: case 5: case 6: case 7:
      {
        // one radio button was chosen, let's adjust them all (we could also remember the last one...)
        int i;
        for (i = 3; i &lt;= 7; i++)
        {
          GetDialogItem(theDialog, i, &amp;itemType, &amp;itemHandle, &amp;itemBox);
          SetControlValue((ControlHandle)itemHandle, (i == itemHit)?1:0);
        }
      }
        break;
      case 14:
      {
        // the indicator of the scroll bar was moved so let's display the value in the first edit box
        // this is System 6 or 7 style so the controls can only handle 16 bits value (hence a max of 32767)
        GetDialogItem(theDialog, itemHit, &amp;itemType, &amp;itemHandle, &amp;itemBox);
        SInt16 newValue = GetControlValue((ControlHandle)itemHandle);
        Str255 theStr;
        NumToString(newValue, theStr);
        GetDialogItem(theDialog, 9, &amp;itemType, &amp;itemHandle, &amp;itemBox);
        SetDialogItemText(itemHandle, theStr);
        SelectDialogItemText(theDialog, 9, 0, 32767);
      }
        break;
    }
  } while (!(itemHit == ok));
  
  DisposeDialog(theDialog);
}

#pragma mark -
#pragma mark * DialogTheMacOS8or9Way *

/*
*
 *
 * ---------------- DialogTheMacOS8or9Way -----------------------------------
 *
 *
 */

static void ScrollBar32BitActionProc(ControlRef theControl, ControlPartCode partCode)
{
  // this is Mac OS 8 or 9 style so the controls can now handle 32 bits value (hence a max of 2147483647)
  SInt32 oldValue = GetControl32BitValue(theControl);
  switch (partCode)
  {
    case kControlUpButtonPart:    SetControl32BitValue(theControl, oldValue - 1); break;
    case kControlDownButtonPart:  SetControl32BitValue(theControl, oldValue + 1); break;
    case kControlPageUpPart:    SetControl32BitValue(theControl, oldValue - 10); break;
    case kControlPageDownPart:    SetControl32BitValue(theControl, oldValue + 10); break;
  }
  SInt32 newValue = GetControl32BitValue(theControl);
  
  // let's display the value in the edit text control associated with this control
  theControl = (ControlRef)GetControlReference(theControl);
  Str255 theStr;
  NumToString(newValue, theStr);
  SetControlData(theControl, kControlEntireControl, kControlEditTextTextTag, theStr[0], &amp;theStr[1]);
}

static Boolean MyMacOS8or9DialogFilter(DialogRef theDialog, EventRecord *inEvent, DialogItemIndex *itemHit)
{
  // this ModalFilterProc is much simpler than its System 6 or 7 ancestor
  // the controls used instead of the dialog items are a bit smarter and more self-standing
  if ((inEvent-&gt;what == keyDown) || (inEvent-&gt;what == autoKey))
  {
    char c = (inEvent-&gt;message &amp; charCodeMask);
    
    // return or enter key?
    if ((c == kReturnCharCode) || (c == kEnterCharCode)) { *itemHit = 1; return true; }
    
    // tab key?
    if (c == kTabCharCode) { AdvanceKeyboardFocus(GetDialogWindow(theDialog)); return true; }
  }
  
  return false;
}

static ControlKeyFilterResult MyEditKeyFilter(ControlRef theControl, SInt16 *keyCode, SInt16 *charCode, EventModifiers *modifiers)
{
  // the edit text control can filter keys on his own
  if ((*charCode &lt; '0') || (*charCode &gt; '9'))
  {
    SysBeep(1);
    return kControlKeyFilterBlockKey;
  }
  return kControlKeyFilterPassKey;
}

static void MyUserPaneDrawProc(ControlRef control, SInt16 part)
{
  // we now use a User Pane Control instead of a dialog user item
  // the draw, hit test, and track are more separated
  Rect bounds;
  GetControlBounds(control, &amp;bounds);
  
  PenSize(3, 3);
  if (!IsControlActive(control))
  {
    RGBColor gray = {32767, 32767, 32767};
    RGBForeColor(&amp;gray);
  }
  FrameRect(&amp;bounds);
  Rect userRect = {gUserV-4, gUserH-4, gUserV+4, gUserH+4};
  PaintRect(&amp;userRect);
}

static ControlPartCode MyUserPaneHitTestProc(ControlRef control, Point where)
{
  Rect bounds;
  GetControlBounds(control, &amp;bounds);
  ControlPartCode partCode = (PtInRect(where, &amp;bounds))?kControlButtonPart:kControlNoPart;
  return partCode;
}

static void MoveSpotActionProc(ControlRef theControl, ControlPartCode partCode)
{
  Rect bounds;
  GetControlBounds(theControl, &amp;bounds);
  Point thePoint;
  if (partCode == kControlButtonPart)
  {
    GetMouse(&amp;thePoint);
    gUserH = thePoint.h;
    gUserV = thePoint.v;
    if (gUserH &lt; bounds.left+4) gUserH = bounds.left+4;
    if (gUserH &gt; bounds.right-4) gUserH = bounds.right-4;
    if (gUserV &lt; bounds.top+4) gUserV = bounds.top+4;
    if (gUserV &gt; bounds.bottom-4) gUserV = bounds.bottom-4;
    
    // the erasing/drawing management is very complex to do properly
    // unless we just Hide and Show. This technique is OK if the control
    // is not too big on the screen and the machine is fast enough to
    // prevent flicker. If not then a better tracking would require
    // clipping management and calling the User Pane Draw Proc.
    HideControl(theControl);
    ShowControl(theControl);
  }
}

static DialogRef DrawDialogTheMacOS8or9Way(void)
{
  short    i;
  ControlRef theControl;
  
  DialogRef theDialog = GetNewDialog(257, NULL, (WindowRef)-1L);
  if (theDialog == NULL) return(NULL);
  
  // Let's get a pulsing blue default button!
  GetDialogItemAsControl(theDialog, 1, &amp;theControl);
  SetWindowDefaultButton(GetDialogWindow(theDialog), theControl);
  
  // Setting the check box
  GetDialogItemAsControl(theDialog, 2, &amp;theControl);
  SetControl32BitValue(theControl, 1);
  
  // We need to autoembed our radio buttons in the radio group
  // so that they work automatically
  for (i = 4; i &lt;= 8; i++)
  {
    GetDialogItemAsControl(theDialog, i, &amp;theControl);
    AutoEmbedControl(theControl, GetDialogWindow(theDialog));
  }
  
  // we assign a key filter on our edit text box so that only digits can be entered
  ControlRef theTextControl;
  ControlKeyFilterUPP keyFilter = MyEditKeyFilter;
  GetDialogItemAsControl(theDialog, 9, &amp;theTextControl);
  SetKeyboardFocus(GetDialogWindow(theDialog), theTextControl, kControlFocusNextPart);
  SetControlData(theTextControl, kControlEntireControl, kControlEditTextKeyFilterTag, sizeof(keyFilter), &amp;keyFilter);
  
  // Setting the action proc for the scroll bar so that the PageUp/PageDown/Up/Down buttons work
  // We also associate the previous edit text box with the scroll bar so it gets updated
  GetDialogItemAsControl(theDialog, 14, &amp;theControl);
  SetControlAction(theControl, ScrollBar32BitActionProc);
  SetControl32BitMaximum(theControl, 0x7fffffff);
  SetControlReference(theControl, (SInt32)theTextControl);
  
  // The static text control is created as a resource but we could only set its title and
  // not its content. We set the content now!
  GetDialogItemAsControl(theDialog, 15, &amp;theControl);
  Str255 theTitle;
  GetControlTitle(theControl, theTitle);
  SetControlData(theControl, kControlEntireControl, kControlStaticTextTextTag, theTitle[0], &amp;theTitle[1]);
  
  // We set up our User Pane Control with the draw, hit test, and track (actually action) procs
  GetDialogItemAsControl(theDialog, 13, &amp;theControl);
  Rect bounds;
  GetControlBounds(theControl, &amp;bounds);
  gUserH = (bounds.left + bounds.right) / 2;
  gUserV = (bounds.top + bounds.bottom) / 2;  
  ControlUserPaneDrawUPP userPaneDraw = MyUserPaneDrawProc;
  SetControlData(theControl, kControlEntireControl, kControlUserPaneDrawProcTag, sizeof(userPaneDraw), &amp;userPaneDraw);
  ControlUserPaneHitTestUPP userPaneHitTest = MyUserPaneHitTestProc;
  SetControlData(theControl, kControlEntireControl, kControlUserPaneHitTestProcTag, sizeof(userPaneHitTest), &amp;userPaneHitTest);
  SetControlAction(theControl, MoveSpotActionProc);
  
  ShowWindow(GetDialogWindow(theDialog));
  
  return(theDialog);
}

static void RunDialogTheMacOS8or9Way(DialogRef theDialog)
{
  SInt16 itemHit;
  ControlRef theControl;
  ControlRef  theTextControl;
  
  BringToFront(GetDialogWindow(theDialog));
  
  do {
    ModalDialog(MyMacOS8or9DialogFilter, &amp;itemHit);
    switch (itemHit)
    {
      case 2:
      {
        // we still enable or disable the user pane depending on whether the box is checked or not
        GetDialogItemAsControl(theDialog, itemHit, &amp;theControl);
        SInt32 enable = GetControl32BitValue(theControl);
        SetControl32BitValue(theControl, 1 - enable);
        GetDialogItemAsControl(theDialog, 13, &amp;theControl);
        if (!enable)
          ActivateControl(theControl);
        else
          DeactivateControl(theControl);
      }
        break;
      case 9: case 10:
      {
        // we got a click in an edit text control, if didn't have the focus, let's set it
        GetDialogItemAsControl(theDialog, itemHit, &amp;theTextControl);
        ControlRef currentFocus;
        GetKeyboardFocus(GetDialogWindow(theDialog), &amp;currentFocus);
        if (currentFocus != theTextControl)
          SetKeyboardFocus(GetDialogWindow(theDialog), theTextControl, kControlFocusNextPart);
      }
        break;
    }
  } while (!(itemHit == ok));
  
  DisposeDialog(theDialog);
}

#pragma mark -
#pragma mark * DialogTheMacOSXWay *

/*
*
 *
 * ---------------- DialogTheMacOSXWay -----------------------------------
 *
 *
 */

static pascal OSStatus MacOSXDialogCommandProcess(EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void* inUserData)
{
  HICommand aCommand;
  OSStatus status = eventNotHandledErr;
  
  GetEventParameter(inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof(HICommand), NULL, &amp;aCommand);
  
  switch (aCommand.commandID)
  {
    case kHICommandOK:
      // we got a valid click on the OK button so let's quit our local run loop
      QuitAppModalLoopForWindow((WindowRef) inUserData);
      break;
    case 'CBED':
    {
      // we still enable or disable the custom spot view depending on whether the box is checked or not
      HIViewRef checkBox = ((HICommandExtended *)&amp;aCommand)-&gt;source.control;
      SInt32 enable = GetControl32BitValue(checkBox);
      HIViewID hidcsv = {0, 13};
      HIViewRef customSpotView;
      HIViewFindByID(HIViewGetRoot(GetControlOwner(checkBox)), hidcsv, &amp;customSpotView);
      if (enable)
        ActivateControl(customSpotView);
      else
        DeactivateControl(customSpotView);
      HIViewSetNeedsDisplay(customSpotView, true);
    }
      break;
  }
  
  return status;
}

//
// We could still have used the previous UserPane control, slightly modified to
// handle the change in the coordinate system due to the fact that the window
// is now compositing, but we take the opportunity to replace it by a custom
// HIView so that we can take advantage of the CarbonEvents handling.
// As it is, we now have a custom spot view which is not &quot;erasing&quot; anymore, which
// can be used on top of any kind of background, and whose tracking is more
// flicker-free thanks to the delayed updating.
//
// This custom spot view necessitates a bit more code than the User Pane control
// required but most of it is common to all custom HIViews so the actual code to
// write is all in the kEventControlDraw, kEventControlBoundsChanged,
// kEventControlHitTest, and kEventControlTrack handlers.
//

#define kCustomSpotViewClassID CFSTR(&quot;com.apple.sample.dts.HICustomSpotView&quot;)

typedef struct {
  HIViewRef  view;
  HIPoint    spot;
} CustomSpotViewData;

static pascal OSStatus CustomSpotViewHandler(EventHandlerCallRef inCaller, EventRef inEvent, void* inRefcon)
{
  OSStatus result = eventNotHandledErr;
  CustomSpotViewData* myData = (CustomSpotViewData*)inRefcon;
  
  switch (GetEventClass(inEvent))
  {
    case kEventClassHIObject:
      switch (GetEventKind(inEvent))
      {
        case kEventHIObjectConstruct:
        {
          myData = (CustomSpotViewData*) calloc(1, sizeof(CustomSpotViewData));
          GetEventParameter(inEvent, kEventParamHIObjectInstance, typeHIObjectRef, NULL, sizeof(myData-&gt;view), NULL, &amp;myData-&gt;view);
          result = SetEventParameter(inEvent, kEventParamHIObjectInstance, typeVoidPtr, sizeof(myData), &amp;myData);
          break;
        }
          
        case kEventHIObjectInitialize:
        {
          HIRect bounds;
          GetEventParameter(inEvent, kEventParamBounds, typeHIRect, NULL, sizeof(bounds), NULL, &amp;bounds);
          myData-&gt;spot.x = CGRectGetMidX(bounds) - CGRectGetMinX(bounds);
          myData-&gt;spot.y = CGRectGetMidY(bounds) - CGRectGetMinY(bounds);
          HIViewSetVisible(myData-&gt;view, true);
          break;
        }
          
        case kEventHIObjectDestruct:
        {
          free(myData);
          result = noErr;
          break;
        }
          
        default:
          break;
      }
      break;
      
    case kEventClassControl:
      switch (GetEventKind(inEvent))
      {
        case kEventControlDraw:
        {
          CGContextRef  context;
          HIRect      bounds;
          result = GetEventParameter(inEvent, kEventParamCGContextRef, typeCGContextRef, NULL, sizeof(context), NULL, &amp;context);
          HIViewGetBounds(myData-&gt;view, &amp;bounds);
          
          if (!IsControlActive(myData-&gt;view))
          {
            CGContextSetGrayStrokeColor(context, 0.5, 0.3);
            CGContextSetGrayFillColor(context, 0.5, 0.3);
          }
          else
          {
            CGContextSetRGBStrokeColor(context, 0.0, 0.0, 0.0, 0.7);
            CGContextSetRGBFillColor(context, 0.0, 0.0, 0.0, 0.7);
          }
          
          CGContextSetLineWidth(context, 3.0);
          CGContextStrokeRect(context, bounds);
          
          HIRect spot = { {myData-&gt;spot.x - 4.0, myData-&gt;spot.y - 4.0}, {8.0, 8.0} };
          CGContextFillRect(context, spot);
          
          result = noErr;
          break;
        }
          
        case kEventControlBoundsChanged:
        {
          HIRect newHIBounds;
          GetEventParameter(inEvent, kEventParamCurrentBounds, typeHIRect, NULL, sizeof(newHIBounds), NULL, &amp;newHIBounds);
          myData-&gt;spot.x = CGRectGetMidX(newHIBounds) - CGRectGetMinX(newHIBounds);
          myData-&gt;spot.y = CGRectGetMidY(newHIBounds) - CGRectGetMinY(newHIBounds);
          break;
        }
          
        case kEventControlHitTest:
        {
          HIPoint  pt;
          HIRect  bounds;
          GetEventParameter(inEvent, kEventParamMouseLocation, typeHIPoint, NULL, sizeof(pt), NULL, &amp;pt);
          HIViewGetBounds(myData-&gt;view, &amp;bounds);
          ControlPartCode part = (CGRectContainsPoint(bounds, pt))?kControlButtonPart:kControlNoPart;
          result = SetEventParameter(inEvent, kEventParamControlPart, typeControlPartCode, sizeof(part), &amp;part);
          break;
        }
          
        case kEventControlTrack:
        {
          Point qdPoint;
          Rect qdWindowBounds;
          HIPoint hiPoint;
          HIRect hiViewBounds;
          MouseTrackingResult mouseStatus = kMouseTrackingMouseDown;
          
          HIViewGetBounds(myData-&gt;view, &amp;hiViewBounds);
          GetWindowBounds(GetControlOwner(myData-&gt;view), kWindowStructureRgn, &amp;qdWindowBounds);
          
          // handle the first mouseDown before moving
          GetEventParameter(inEvent, kEventParamMouseLocation, typeHIPoint, NULL, sizeof(hiPoint), NULL, &amp;hiPoint);
          
          while (mouseStatus != kMouseTrackingMouseUp)
          {
            if (CGRectContainsPoint(hiViewBounds, hiPoint))
            {
              if (hiPoint.x &lt; hiViewBounds.origin.x+4) hiPoint.x = hiViewBounds.origin.x+4;
              if (hiPoint.x &gt; hiViewBounds.origin.x+hiViewBounds.size.width-4) hiPoint.x = hiViewBounds.origin.x+hiViewBounds.size.width-4;
              if (hiPoint.y &lt; hiViewBounds.origin.y+4) hiPoint.y = hiViewBounds.origin.y+4;
              if (hiPoint.y &gt; hiViewBounds.origin.y+hiViewBounds.size.height-4) hiPoint.y = hiViewBounds.origin.y+hiViewBounds.size.height-4;
              myData-&gt;spot = hiPoint;
              HIViewSetNeedsDisplay(myData-&gt;view, true);
            }
            
            // a -1 GrafPtr to TrackMouseLocation yields global coordinates
            TrackMouseLocation((GrafPtr)-1L, &amp;qdPoint, &amp;mouseStatus);            
            
            // convert to window-relative coordinates
            hiPoint.x = qdPoint.h - qdWindowBounds.left;
            hiPoint.y = qdPoint.v - qdWindowBounds.top;
            
            // convert to view-relative coordinates
            HIViewConvertPoint(&amp;hiPoint, NULL, myData-&gt;view);
          }
          break;
        }
          
          
        default:
          break;
      }
      break;
      
    default:
      break;
  }
  
  return result;
}

static WindowRef DrawDialogTheMacOSXWay(void)
{
  // Create a window. &quot;DLOG:257&quot; is the name of the window object. This name is set in 
  // InterfaceBuilder when the resource file is imported.
  
  OSStatus status = noErr;
  IBNibRef nibRef;
  WindowRef window  = NULL;
  
  static HIObjectClassRef  theClass;
  if (theClass == NULL)
  {
    static EventTypeSpec kFactoryEvents[] =
  {
        { kEventClassHIObject, kEventHIObjectConstruct },
        { kEventClassHIObject, kEventHIObjectInitialize },
        { kEventClassHIObject, kEventHIObjectDestruct },
        { kEventClassControl, kEventControlHitTest },
        { kEventClassControl, kEventControlTrack },
        { kEventClassControl, kEventControlBoundsChanged },
        { kEventClassControl, kEventControlDraw }
  };
    HIObjectRegisterSubclass(kCustomSpotViewClassID, kHIViewClassID, 0, CustomSpotViewHandler, GetEventTypeCount(kFactoryEvents), kFactoryEvents, 0, &amp;theClass);
  }
  
  status = CreateNibReference(CFSTR(&quot;main&quot;), &amp;nibRef);
  require_noerr(status, CantGetNibRef);
  
  status = CreateWindowFromNib(nibRef, CFSTR(&quot;DLOG:257&quot;), &amp;window);
  require_noerr(status, CantCreateWindow);
  
  // Let's react to User's commands.
  EventTypeSpec eventTypeCP = {kEventClassCommand, kEventCommandProcess};
  InstallEventHandler(GetWindowEventTarget(window), MacOSXDialogCommandProcess, 1, &amp;eventTypeCP, window, NULL);
  
  // we still assign the key filter on our edit text box so that only digits can be entered
  HIViewID hidnst = {0, 9};
  HIViewRef numEditText;
  HIViewFindByID(HIViewGetRoot(window), hidnst, &amp;numEditText);
  ControlKeyFilterUPP keyFilter = MyEditKeyFilter;
  SetControlData(numEditText, kControlEntireControl, kControlEditTextKeyFilterTag, sizeof(keyFilter), &amp;keyFilter);
  SetKeyboardFocus(window, numEditText, kControlFocusNextPart);
  
  // we still set the action proc for the scroll bar so that the PageUp/PageDown/Up/Down buttons work
  // and still associate the previous edit text box with the scroll bar so it gets updated
  HIViewID hidsb = {0, 14};
  HIViewRef scrollBar;
  HIViewFindByID(HIViewGetRoot(window), hidsb, &amp;scrollBar);
  SetControlAction(scrollBar, ScrollBar32BitActionProc);
  SetControlReference(scrollBar, (SInt32)numEditText);
  
  // Move it!
  MoveWindow(window, 854, 271, false);
  
  // and use the replacement for ModalDialog
  // one good thing is that our behaviors are no longer half-done at the dialog level
  // and half-done at the control level, they are all handled by the view handlers
  ShowWindow(window);
  
CantCreateWindow:
CantGetNibRef:
    return (window);
}

static void RunDialogTheMacOSXWay(WindowRef window)
{
  BringToFront(window);
  RunAppModalLoopForWindow(window);
  DisposeWindow(window);
  
  return;
}

</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DialogsToHIViews/listing1.html%3Fid%3DDTS10003344-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DialogsToHIViews/listing1.html%3Fid%3DDTS10003344-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DialogsToHIViews/listing1.html%3Fid%3DDTS10003344-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>