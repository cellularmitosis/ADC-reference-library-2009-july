<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Customizing the User Interface (IM: F)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING308></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Files-307.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-309.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Files-2.html"><B>Files</B></A> / <BR><DD><A HREF="Files-302.html"><B>Chapter 3 - Standard File Package</B></A> / <A HREF="Files-306.html"><B>Using the Standard File Package</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING308-0></A>
<H2><A NAME=MARKER-9-91></A>Customizing the User Interface</H2>
 <A NAME=MARKER-2-92></A><A NAME=MARKER-2-54></A>If your application requires it, you can customize the user interface for identifying files. To customize a dialog box, you should<P>
<UL>
<LI>design your dialog box and create the resources that describe it
<LI>write callback routines, if necessary, to process user actions in the dialog box
<LI>call the Standard File Package using the <CODE>CustomPutFile</CODE> and <CODE>CustomGetFile</CODE> procedures, passing the resource IDs of the customized dialog boxes and pointers to the callback routines<P>
</UL>
 Depending on the level of customizing you require in your dialog box, you may need to write as many as four different callback routines:<A NAME=MARKER-2-8></A><P>
<UL>
<LI>a file filter function for determining which files the user can open
<LI>a dialog hook function for handling user actions in the dialog boxes
<LI>a modal-dialog filter function for handling user events received from the <BR>Event Manager
<LI>an activation procedure for highlighting the display when keyboard input is directed at a customized field defined by your application<P>
</UL>
 To provide the interface illustrated in <A HREF=Files-305.html#MARKER-9-48>Figure 3-7</A>, for example, you could replace the definition of <CODE>DoOpenCmd</CODE> given earlier in <A HREF=Files-307.html#MARKER-9-87>Listing 3-1</A> by the definition given in <A HREF=#MARKER-9-95>Listing 3-3</A>. <P>
 In addition to the information passed to <CODE>StandardGetFile</CODE>, <CODE>CustomGetFile</CODE> requires the resource ID of the customized dialog box, the location of the dialog box on the screen, and pointers to any callback routines and private data you are using. <P>
<B>Listing 3-3  <A NAME=MARKER-9-95></A>Presenting a customized Open dialog box</B><P>
<PRE>
FUNCTION DoOpenCmd: OSErr;
VAR
   myReply:    StandardFileReply;   {Standard File reply record}
   myTypes:    SFTypeList;          {types of files to display}
   myPoint:    Point;               {upper-left corner of box}
   myErr:      OSErr;
CONST
   kCustomGetDialog = 4000;         {resource ID of custom dialog}
BEGIN
   myErr := noErr;
   SetPt(myPoint, -1, -1);          {center the dialog}
   myTypes[0] := 'SRFD';            {SurfDraw files}
   myTypes[1] := 'STUP';            {startup screens}
   myTypes[2] := 'PICT';            {picture files}
   myTypes[3] := 'RTFT';            {rich text format}

   CustomGetFile(@MyCustomFileFilter, 4, myTypes, myReply, 
                  kCustomGetDialog, myPoint, @MyDlgHook, 
                  NIL, NIL, NIL, NIL);
   IF myReply.sfGood THEN
      myErr := DoOpenFile(myReply.sfFile);
   DoOpenCmd := myErr;
END;
</PRE>
 In <A HREF=#MARKER-9-95>Listing 3-3</A>, <CODE>CustomGetFile</CODE> is passed two callback routines, a file filter function (MyCustomFileFilter) and a dialog hook function (MyDlgHook). See <A HREF=#MARKER-9-119>Listing 3-8</A> (<A HREF=#MARKER-9-119>page 3-21</A>) and <A HREF=#MARKER-9-166>Listing 3-9</A> (<A HREF=#MARKER-9-166>page 3-27</A>) for sample definitions of these functions.<P>
 You can also supply data of your own to the callback routines through a new parameter, <CODE>yourDataPtr</CODE>, which you pass to <CODE>CustomGetFile</CODE> and <CODE>CustomPutFile</CODE>.<P>
<A NAME=HEADING308-16></A>
<H3>Customizing Dialog Boxes</H3>
 To describe a dialog box, you supply a <CODE>'DLOG'</CODE> resource that defines the box itself and a <CODE>'DITL'</CODE> resource that defines the items in the dialog box.<A NAME=MARKER-2-96></A><P>
 <A HREF=#MARKER-9-101>Listing 3-4</A> shows the resource definition of the default Open dialog box, in Rez input format. (Rez is the resource compiler provided with Apple's Macintosh Programmer's Workshop [MPW]. For a description of Rez format, see the manual that accompanies the MPW software, MPW: Macintosh Programmer's Development Environment.)<A NAME=MARKER-2-97></A><A NAME=MARKER-2-98></A><A NAME=MARKER-2-99></A><A NAME=MARKER-2-100></A><P>
<B>Listing 3-4  <A NAME=MARKER-9-101></A>The definition of the default Open dialog box</B><P>
<PRE>
resource 'DLOG' (-6042, purgeable)
   {
      {0, 0, 166, 344}, dBoxProc, invisible, noGoAway, 0,
       -6042, &quot;&quot;, noAutoCenter
   };
</PRE>
 <A HREF=#MARKER-9-102>Listing 3-5</A> shows the resource definition of the default Save dialog box, in Rez <BR>input format.<P>
<B>Listing 3-5  <A NAME=MARKER-9-102></A>The definition of the default Save dialog box</B><P>
<PRE>
resource 'DLOG' (-6043, purgeable)
   {
      {0, 0, 188, 344}, dBoxProc, invisible, noGoAway, 0,
       -6043, &quot;&quot;, noAutoCenter
   };
</PRE>
<DL>
<DT><B>Note</B>
<DD>You can also use the stand-alone resource editor ResEdit, available from Apple Computer, Inc., or other resource-editing utilities available from third-party developers to create customized dialog box and dialog item list resources.<EM></EM><A NAME=MARKER-2-103></A><A NAME=MARKER-2-104></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 You must provide an item list (in a <CODE>'DITL'</CODE> resource with the ID specified in the <BR><CODE>'DLOG'</CODE> resource) for each dialog box you define. Add new items to the end of the default lists. <CODE>CustomGetFile</CODE> expects the first 9 items in a customized dialog box to have the same functions as the corresponding items in the <CODE>StandardGetFile</CODE> dialog box; <CODE>CustomPutFile</CODE> expects the first 12 items to have the same functions as the corresponding items in the <CODE>StandardPutFile</CODE> dialog box. If you want to eliminate <BR>one of the standard items from the display, leave it in the item list but place its coordinates outside the bounds of the dialog box rectangle.<P>
 <A HREF=#MARKER-9-105>Listing 3-6</A> shows the dialog item list for the default Open dialog box, in Rez input format. See <A HREF=#MARKER-9-122>"Writing a Dialog Hook Function"</A> beginning on <A HREF=#MARKER-9-122>page 3-21</A> for a list of the dialog box elements these items represent.<P>
<B>Listing 3-6  <A NAME=MARKER-9-105></A>The item list for the default Open dialog box</B><P>
<PRE>
resource 'DITL'(-6042)
   {  {
      {135, 252, 155, 332}, Button { enabled, &quot;Open&quot; },
      {104, 252, 124, 332}, Button { enabled, &quot;Cancel&quot; },
      {0, 0, 0, 0}, HelpItem { disabled, HMScanhdlg {-6042}},
      {8, 235, 24, 337}, UserItem { enabled },
      {32, 252, 52, 332}, Button { enabled, &quot;Eject&quot; },
      {60, 252, 80, 332}, Button { enabled, &quot;Desktop&quot; },
      {29, 12, 159, 230}, UserItem { enabled },
      {6, 12, 25, 230}, UserItem { enabled },
      {91, 251, 92, 333}, Picture  { disabled, 11 },
   }  };
</PRE>
 <A HREF=#MARKER-9-106>Listing 3-7</A> shows the dialog item list for the default Save dialog box, in Rez input format.<P>
<B>Listing 3-7  <A NAME=MARKER-9-106></A>The item list for the default Save dialog box</B><P>
<PRE>
resource 'DITL'(-6043)
   {  {
      {161, 252, 181, 332}, Button { enabled, &quot;Save&quot; },
      {130, 252, 150, 332}, Button { enabled, &quot;Cancel&quot; },
      {0, 0, 0, 0}, HelpItem { disabled, HMScanhdlg {-6043}},
      {8, 235, 24, 337}, UserItem { enabled },
      {32, 252, 52, 332}, Button { enabled, &quot;Eject&quot; },
      {60, 252, 80, 332}, Button { enabled, &quot;Desktop&quot; },
      {29, 12, 127, 230}, UserItem { enabled },
      {6, 12, 25, 230}, UserItem { enabled },
      {119, 250, 120, 334}, Picture { disabled, 11 },
      {157, 15, 173, 227}, EditText { enabled, &quot;&quot; },
      {136, 15, 152, 227}, StaticText { disabled, &quot;Save as:&quot; },
      {88, 252, 108, 332}, UserItem { disabled },
   }  };
</PRE>
 <A NAME=MARKER-2-107></A><A NAME=MARKER-2-108></A>The third item in each list (<CODE>HelpItem</CODE>) supplies Apple's Balloon Help for items in the dialog box. This third item specifies the resource ID of the <CODE>'hdlg'</CODE> resource that contains the help strings for the standard dialog items. If you want to modify the help text of an existing dialog item, you should copy the original <CODE>'hdlg'</CODE> resource from the System <BR>file into your application's resource fork and modify the text in the copied resource as desired; then you must change the resource ID specified in <CODE>HelpItem</CODE> to the resource ID of the copied and modified resource. To provide Balloon Help for your own items, supply a second <CODE>'hdlg'</CODE> resource and reference it with another help item at the end <BR>of the list. The existing items retain their default text (unless you change that text, <BR>as described).<A NAME=MARKER-2-109></A><P>
 The default dialog item lists used by the original Standard File Package routines do not contain help items, but the Standard File Package does provide Balloon Help when you call those routines in system software version 7.0 and later. If you call one of the original routines and the specified dialog item list does not contain any help items, the Standard File Package uses its default help text for the standard dialog items. If, however, the dialog item list does contain a help item, the Standard File Package assumes that your application provides the text for all help items, including the standard dialog items.<P>
<DL>
<DT><B>Note</B>
<DD>The default Standard File Package dialog boxes support color. The System file contains <CODE>'dctb'</CODE> resources with the same resource IDs as <BR>the default dialog boxes, so that the Dialog Manager uses color graphics ports for the default dialog boxes. (See the chapter "Dialog Manager" <BR>of <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for a description of <BR>the <CODE>'dctb'</CODE> resource.) If you create your own dialog boxes, include <CODE>'dctb'</CODE> resources.<EM></EM><A NAME=MARKER-2-29></A><A NAME=MARKER-2-111></A><A NAME=MARKER-2-112></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING308-35></A>
<H3><A NAME=MARKER-9-113></A>Writing a File Filter Function</H3>
 <A NAME=MARKER-2-114></A><A NAME=MARKER-2-115></A><A NAME=MARKER-2-23></A>A file filter function determines which files appear in the displayed list when the user <BR>is opening a file. Both <CODE>StandardGetFile</CODE> and <CODE>CustomGetFile</CODE> recognize file <BR>filter functions.<A NAME=MARKER-2-55></A><A NAME=MARKER-2-57></A><P>
 When the Standard File Package is displaying the contents of a volume or folder, it checks the file type of each file and filters out files whose types do not match your application's specifications. (Your application can specify which file types are to be displayed through the <CODE>typeList</CODE> parameter to either <CODE>StandardGetFile</CODE> or <CODE>CustomGetFile</CODE>, as described in <A HREF=Files-307.html#MARKER-9-85>"Presenting the Standard User Interface" beginning on page 3-14</A>.) If your application also supplies a file filter function, the Standard File Package calls that function each time it identifies a file of an acceptable type.<P>
 The file filter function receives a pointer to the file's catalog information record (described in the chapter "File Manager" in this book). The function evaluates the catalog entry and returns a Boolean value that determines whether the file is filtered (that is, a value of <CODE>TRUE</CODE> suppresses display of the filename, and a value of <CODE>FALSE</CODE> <BR>allows the display). If you do not supply a file filter function, the Standard File Package displays all files of the specified types.<P>
 A file filter function to be called by <CODE>StandardGetFile</CODE> must use this syntax:<P>
<PRE>
FUNCTION MyStandardFileFilter (pb: CInfoPBPtr): Boolean;
</PRE>
 The single parameter passed to your standard file filter function is the address of a catalog information parameter block; see the chapter "File Manager" in this book for a description of the fields of that parameter block.<P>
 When <CODE>CustomGetFile</CODE> calls your file filter function, it can also receive a pointer to any data that you passed in through the call to <CODE>CustomGetFile</CODE>. A file filter function to be called by <CODE>CustomGetFile</CODE> must use this syntax:<P>
<PRE>
FUNCTION MyCustomFileFilter (pb: CInfoPBPtr; myDataPtr: Ptr):
                               Boolean;
</PRE>
 <A HREF=#MARKER-9-119>Listing 3-8</A> shows a sample file filter function to be called by <CODE>CustomGetFile</CODE>. You might define a file filter function like this to support the custom dialog box illustrated in <A HREF=Files-305.html#MARKER-9-48>Figure 3-7</A>, which lists files of the type shown in the pop-up box.<P>
<B>Listing 3-8  <A NAME=MARKER-9-119></A>A sample file filter function</B><P>
<PRE>
FUNCTION MyCustomFileFilter (pb: CInfoPBPtr; myDataPtr: Ptr): Boolean;
BEGIN
   MyCustomFileFilter := TRUE;               {default: don't show the file}
   IF pb^.ioFlFndrInfo.fdType = gTypesArray[gCurrentType] THEN
      MyCustomFileFilter := FALSE;           {show the file}
END;
</PRE>
 In <A HREF=#MARKER-9-119>Listing 3-8</A>, the application global variable <CODE>gCurrentType</CODE> contains the index in <BR>the array <CODE>gTypesArray</CODE> of the currently selected file type. If the type of a file passed in for evaluation matches the current file type, the filter returns <CODE>FALSE</CODE>, indicating that <CODE>StandardGetFile</CODE> should put it in the list. See <A HREF=#MARKER-9-166>Listing 3-9</A> (<A HREF=#MARKER-9-166>page 3-27</A>) for an example <BR>of how you can use a dialog hook function to change the value of <CODE>gCurrentType</CODE> according to user selections in the pop-up menu control.<A NAME=MARKER-2-121></A><P>
<A NAME=HEADING308-48></A>
<H3><A NAME=MARKER-9-122></A>Writing a Dialog Hook Function</H3>
 A dialog hook function handles item selections in a dialog box. It receives a pointer to the dialog record and an item number from the <CODE>ModalDialog</CODE> procedure via the Standard File Package each time the user selects one of the dialog items. Your dialog hook function checks the item number of each selected item, and then either handles the selection or passes it back to the Standard File Package.<A NAME=MARKER-2-39></A><A NAME=MARKER-2-439></A><P>
 If you provide a dialog hook function, <CODE>CustomPutFile</CODE> and <CODE>CustomGetFile</CODE> call <BR>your function immediately after calling <CODE>ModalDialog</CODE>. They pass your function the <BR>item number returned by <CODE>ModalDialog</CODE>, a pointer to the dialog record, and a pointer <BR>to the data received from your application, if any. The dialog hook function must use <BR>this syntax:<P>
<PRE>
FUNCTION MyDlgHook (item: Integer; theDialog: DialogPtr;
                     myDataPtr: Ptr): Integer;
</PRE>
 Your dialog hook function returns as its function result an integer that is either the item number passed to it or some other item number. If it returns one of the item numbers in the following list of constants, the Standard File Package handles the selected item as described later in this section. If your dialog hook function does not handle a selection, it should pass the item number back to the Standard File Package for processing by setting its return value equal to the item number.<P>
<PRE>
CONST {items that appear in both the Open and Save dialog boxes}
   sfItemOpenButton        =  1;       {Save or Open button}
   sfItemCancelButton      =  2;       {Cancel button}
   sfItemBalloonHelp       =  3;       {Balloon Help}
   sfItemVolumeUser        =  4;       {volume icon and name}
   sfItemEjectButton       =  5;       {Eject button}
   sfItemDesktopButton     =  6;       {Desktop button}
   sfItemFileListUser      =  7;       {display list}
   sfItemPopUpMenuUser     =  8;       {directory pop-up menu}
   sfItemDividerLinePict   =  9;       {dividing line between buttons}

   {items that appear in Save dialog boxes only}
   sfItemFileNameTextEdit  =  10;      {filename field}
   sfItemPromptStaticText  =  11;      {filename prompt text area}
   sfItemNewFolderUser     =  12;      {New Folder button}
</PRE>
 You must write your own dialog hook function to handle any items you have added to the dialog box.<P>
<DL>
<DT><B>Note</B>
<DD>The constants that represent disabled items (<CODE>sfItemBalloonHelp</CODE>, <CODE>sfItemDividerLinePict</CODE>, and <CODE>sfItemPromptStaticText</CODE>) have no effect, but they are defined in the header files for the sake of completeness.<EM></EM><A NAME=MARKER-2-125></A><A NAME=MARKER-2-126></A><A NAME=MARKER-2-127></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The Standard File Package also recognizes a number of constants that do not represent any actual item in the dialog list; these constants are known as <B>pseudo-items.</B> There are two kinds of pseudo-items:<A NAME=MARKER-2-17></A><P>
<UL>
<LI>pseudo-items passed to your dialog hook function by the Standard File Package
<LI>pseudo-items passed to the Standard File Package by your dialog hook function<P>
</UL>
 The sfHookFirstCall constant is an example of the first kind of pseudo-item. The Standard File Package sends this pseudo-item to your dialog hook function immediately before it displays the dialog box. Your function typically reacts to this item number by performing any necessary initialization.<P>
 You can pass back other pseudo-items to indicate that you've handled the user selection or to request some action by the Standard File Package. For example, if the list of <BR>files and folders must be rebuilt because of a user selection, you can pass back the pseudo-item sfHookRebuildList. Similarly, when your application handles the selection and needs no further action by the Standard File Package, it should return <CODE>sfHookNullEvent</CODE>. When the dialog hook function passes either <CODE>sfHookNullEvent</CODE> or an item number that the Standard File Package doesn't recognize, it does nothing.<P>
 <A NAME=MARKER-2-129></A>The Standard File Package recognizes these pseudo-item numbers:<A NAME=MARKER-2-123></A><P>
<PRE>
CONST {pseudo-items available prior to version 7.0}
   sfHookFirstCall         =  -1;      {initialize display}
   sfHookCharOffset        =  $1000;   {offset for character input}
   sfHookNullEvent         =  100;     {null event}
   sfHookRebuildList       =  101;     {redisplay list}
   sfHookFolderPopUp       =  102;     {display parent-directory menu}
   sfHookOpenFolder        =  103;     {display contents of }
                                       { selected folder or volume}

   {additional pseudo-items introduced in version 7.0}
   sfHookLastCall          =  -2;      {clean up after display}
   sfHookOpenAlias         =  104;     {resolve alias}
   sfHookGoToDesktop       =  105;     {display contents of desktop}
   sfHookGoToAliasTarget   =  106;     {select target of alias}
   sfHookGoToParent        =  107;     {display contents of parent}
   sfHookGoToNextDrive     =  108;     {display contents of next drive}
   sfHookGoToPrevDrive     =  109;     {display contents of previous drive}
   sfHookChangeSelection   =  110;     {select target of reply record}
   sfHookSetActiveOffset   =  200;     {switch active item}
</PRE>
 The Standard File Package uses a set of modal-dialog filter functions (described in <A HREF=#MARKER-9-169>"Writing a Modal-Dialog Filter Function" on page 3-28</A>) to map user actions during <BR>the dialog onto the defined item numbers. Some of the mapping is indirect. A click of <BR>the Open button, for example, is mapped to <CODE>sfItemOpenButton</CODE> only if a file is selected in the display list. If a folder or volume is selected, the Standard File Package maps the selection onto the pseudo-item <CODE>sfHookOpenFolder</CODE>.<A NAME=MARKER-2-131></A><P>
 The lists that follow summarize when various items and pseudo-items are generated <BR>and how they are handled. The descriptions indicate the simplest mouse action that generates each item; many of the items can also be generated by keyboard actions, as described in <A HREF=Files-304.html#MARKER-9-31>"Keyboard Equivalents" on page 3-7</A>.<P>
<DL>
<DT><B>Note</B>
<DD>Any indicated effects of passing back these constants do not occur until the Standard File Package receives the constant back from your dialog hook function.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<B>Constant descriptions</B><P>
<DL>
<DT><CODE>sfItemOpenButton</CODE>
<DD> <BR>Generated when the user clicks Open or Save while a filename is selected. The Standard File Package fills in the reply record (setting <CODE>sfGood</CODE> to <CODE>TRUE</CODE>), removes the dialog box, and returns.<A NAME=MARKER-2-132></A>
<DT><CODE>sfItemCancelButton</CODE>
<DD> <BR>Generated when the user clicks Cancel. The Standard File Package sets <CODE>sfGood</CODE> to <CODE>FALSE</CODE>, removes the dialog box, and returns.<A NAME=MARKER-2-133></A>
<DT><CODE>sfItemVolumeUser</CODE>
<DD> <BR>Generated when the user clicks the volume icon or its name. The Standard File Package rebuilds the display list to show the contents of the folder that is one level up the hierarchy (that is, the parent directory of the current parent directory).<A NAME=MARKER-2-134></A>
<DT><CODE>sfItemEjectButton</CODE>
<DD> <BR>Generated when the user clicks Eject. The Standard File Package ejects the volume that is currently selected.<A NAME=MARKER-2-135></A>
<DT><CODE>sfItemDesktopButton</CODE> 
<DD> <BR>Generated when the user clicks the Drive button in a customized dialog box defined by one of the earlier procedures. You never receive this item number with the new procedures; when the user clicks the Desktop button, the action is mapped to the item <CODE>sfHookGoToDesktop</CODE>, described later in this section. The Standard File Package displays the contents of the next drive.<A NAME=MARKER-2-124></A>
<DT><CODE>sfItemFileListUser</CODE>
<DD> <BR>Generated when the user clicks an item in the display list. The Standard File Package updates the selection and generates this <BR>item for your information.<A NAME=MARKER-2-44></A>
<DT><CODE>sfItemPopUpMenuUser</CODE>
<DD> <BR>Never generated. The Standard File Package's modal-dialog filter function maps clicks on the directory pop-up menu to <CODE>sfHookFolderPopUp</CODE>, described later in this section.<A NAME=MARKER-2-138></A>
<DT><CODE>sfItemFileNameTextEdit</CODE>
<DD> <BR>Generated when the user clicks the filename field. TextEdit and the Standard File Package process mouse clicks in the filename field, but the item number is generated for your information.<A NAME=MARKER-2-82></A>
<DT><CODE>sfItemNewFolderUser</CODE>
<DD> <BR>Generated when the user clicks New Folder. The Standard File Package displays the New Folder dialog box.<A NAME=MARKER-2-140></A>
</DL>
 The pseudo-items are messages that allow your application and the Standard File Package to communicate and support various features added since the original design <BR>of the Standard File Package.<P>
 The Standard File Package generates three pseudo-items that give your application the chance to control a customized display.<P>
<B>Constant descriptions</B><P>
<DL>
<DT><CODE>sfHookFirstCall</CODE>
<DD> <BR>Generated by the Standard File Package as a signal to your dialog hook function that it is about to display a dialog box. If you <BR>want to initialize the display, do so when you receive this item. <BR>You can specify the current directory either by returning <CODE>sfHookGoToDesktop</CODE> or by changing the reply record and returning <CODE>sfHookChangeSelection</CODE>.<A NAME=MARKER-2-37></A>
<DT><CODE>sfHookLastCall</CODE>
<DD> Generated by the Standard File Package as a signal to your dialog hook function that it is about to remove a dialog box. If you created any structures when the dialog box was first displayed, remove them when you receive this item.<A NAME=MARKER-2-94></A>
<DT><CODE>sfHookNullEvent</CODE> 
<DD> <BR>Issued periodically by the Standard File Package if no user action has taken place. Your application can use this null event to perform any updating or periodic processing that might be necessary.<A NAME=MARKER-2-69></A>
</DL>
 Your application can generate three pseudo-items to request services from the Standard File Package.<P>
<B>Constant descriptions</B><P>
<DL>
<DT><CODE>sfHookRebuildList</CODE>
<DD> <BR>Returned by your dialog hook function to the Standard File Package when it needs to redisplay the file list. Your application might need to redisplay the list if, for example, it allows the user to change the file types to be displayed<EM>. </EM>The Standard File Package<EM> </EM>rebuilds and displays the<EM> </EM>list of files that can be<EM> </EM>opened.<A NAME=MARKER-2-144></A>
<DT><CODE>sfHookChangeSelection</CODE>
<DD> <BR>Returned by your application to the Standard File Package after your application changes the reply record so that it describes a different file or folder. (You'll need to pass the address of the reply record in the <CODE>yourDataPtr</CODE> field if you want to do this.) The Standard File Package rebuilds the display list to show the contents of the folder or volume containing the object described in the reply record. It selects the item described in the reply record.<A NAME=MARKER-2-145></A>
<DT><CODE>sfHookSetActiveOffset</CODE>
<DD> <BR>Your application adds this constant to an item number and sends the result to the Standard File Package. The Standard File Package activates that item in the dialog box, making it the target of keyboard input. This constant allows your application to activate a specific field in the dialog box without explicit input from the user.<A NAME=MARKER-2-146></A>
</DL>
 The Standard File Package's own modal-dialog filter functions generate a number of pseudo-items that allow its dialog hook functions to support various features introduced since the original design of the standard file dialog boxes. Except under extraordinary circumstances, your dialog hook function always passes any of these item numbers back to the Standard File Package for processing.<P>
<B>Constant descriptions</B><P>
<DL>
<DT><CODE>sfHookCharOffset</CODE>
<DD> <BR>The Standard File Package adds this constant to the value of an ASCII character when it's using keyboard input for item selection. The Standard File Package uses the decoded ASCII character to select an entry in the display list.<A NAME=MARKER-2-147></A>
<DT><CODE>sfHookFolderPopUp</CODE>
<DD> <BR>Generated when the user clicks the directory pop-up menu. The Standard File Package displays the pop-up menu showing all parent directories.<A NAME=MARKER-2-148></A>
<DT><CODE>sfHookOpenFolder</CODE>
<DD> <BR>Generated when the user clicks the Open button while a folder <BR>or volume is selected in the display list. The Standard File Package rebuilds the display list to show the contents of the folder <BR>or volume.<A NAME=MARKER-2-149></A>
<DT><CODE>sfHookOpenAlias</CODE>
<DD> <BR>Generated by the Standard File Package as a signal that the selected item is an alias for another file, folder, or volume. If the selected item is an alias for a file, the Standard File Package resolves the alias, places the file system specification record of the target in the reply record, and returns. 
<DT>
<DD> If the selected item is an alias for a folder or volume, the Standard File Package resolves the alias and rebuilds the display list to show the contents of the alias target.<A NAME=MARKER-2-150></A>
<DT><CODE>sfHookGoToDesktop</CODE>
<DD> <BR>Generated when the user clicks the Desktop button. The Standard File Package displays the contents of the desktop in the display list.<A NAME=MARKER-2-151></A>
<DT><CODE>sfHookGoToAliasTarget</CODE>
<DD> <BR>Generated when the user presses the Option key while opening an item that is an alias. The Standard File Package rebuilds the display list to display the volume or folder containing the alias target and selects the target.<A NAME=MARKER-2-152></A>
<DT><CODE>sfHookGoToParent</CODE>
<DD> <BR>Generated when the user presses Command-Up Arrow (or <BR>clicks the volume icon). The Standard File Package rebuilds the display list to show the contents of the folder that is one level <BR>up the hierarchy (that is, the parent directory of the current <BR>parent directory).<A NAME=MARKER-2-153></A>
<DT><CODE>sfHookGoToNextDrive</CODE>
<DD> <BR>Generated when the user presses Command-Right Arrow. The Standard File Package displays the contents of the next volume.<A NAME=MARKER-2-154></A>
<DT><CODE>sfHookGoToPrevDrive</CODE>
<DD> <BR>Generated when the user presses Command-Left Arrow. The Standard File Package displays the contents of the previous volume.<A NAME=MARKER-2-155></A><A NAME=MARKER-2-76></A>
</DL>
 The <CODE>CustomGetFile</CODE> and <CODE>CustomPutFile</CODE> procedures call your dialog hook <BR>function for item selections in both the main dialog box and any subsidiary dialog <BR>boxes (such as the dialog box for naming a new folder while saving a document <BR>through <CODE>CustomPutFile</CODE>). To determine whether the dialog record describes the <BR>main dialog box or a subsidiary dialog box, check the value of the <CODE>refCon</CODE> field in <BR>the window record in the dialog record.<A NAME=MARKER-2-79></A><P>
<DL>
<DT><B>Note</B>
<DD>Prior to system software version 7.0, the Standard File Package did not call your dialog hook function during subsidiary dialog boxes. Dialog hook functions for the new <CODE>CustomGetFile</CODE> and <CODE>CustomPutFile</CODE> procedures must check the dialog window's <CODE>refCon</CODE> field to determine the target of the dialog record.<EM></EM><A NAME=MARKER-9-623></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The defined values for the <CODE>refCon</CODE> field represent the Standard File dialog boxes.<P>
<PRE>
CONST
   sfMainDialogRefCon      =  'stdf';  {main dialog box}
   sfNewFolderDialogRefCon =  'nfdr';  {New Folder dialog box}
   sfReplaceDialogRefCon   =  'rplc';  {name conflict dialog box}
   sfStatWarnDialogRefCon  =  'stat';  {stationery warning}
   sfErrorDialogRefCon     =  'err ';  {general error report}
   sfLockWarnDialogRefCon  =  'lock';  {software lock warning}
</PRE>
<B>Constant descriptions</B><P>
<DL>
<DT><CODE>sfMainDialogRefCon</CODE>
<DD> The main dialog box, either Open or Save.<A NAME=MARKER-2-159></A>
<DT><CODE>sfNewFolderDialogRefCon</CODE>
<DD> The New Folder dialog box.<A NAME=MARKER-2-160></A>
<DT><CODE>sfReplaceDialogRefCon</CODE>
<DD> The dialog box requesting verification for replacing a file of the same name.<A NAME=MARKER-2-161></A>
<DT><CODE>sfStatWarnDialogRefCon</CODE>
<DD> The dialog box warning that the user is opening <BR>the master copy of a stationery pad, not a piece <BR>of stationery.<A NAME=MARKER-2-162></A>
<DT><CODE>sfErrorDialogRefCon</CODE>
<DD> A dialog box reporting a general error.<A NAME=MARKER-2-163></A>
<DT><CODE>sfLockWarnDialogRefCon</CODE>
<DD> The dialog box warning that the user is opening a locked file and won't be allowed to save any changes.<CODE><A NAME=MARKER-2-164></A><A NAME=MARKER-2-165></A></CODE>
</DL>
 <A HREF=#MARKER-9-166>Listing 3-9</A> defines a dialog hook function that handles user selections in the customized Open dialog box illustrated in <A HREF=Files-305.html#MARKER-9-48>Figure 3-7</A>. Note that this dialog hook function handles selections only in the main dialog box, not in any subsidiary dialog boxes.<P>
<B>Listing 3-9  <A NAME=MARKER-9-166></A>A sample dialog hook function</B><P>
<PRE>
FUNCTION MyDlgHook (item: Integer; theDialog: DialogPtr; myDataPtr: Ptr):
                   Integer;
VAR
   myType:        Integer;       {menu item selected}
   myHandle:      Handle;        {needed for GetDItem}
   myRect:        Rect;          {needed for GetDItem}
   myIgnore:      Integer;       {needed for GetDItem; ignored}
CONST
   kMyPopUpItem = 10;            {item number of File Type pop-up menu}
BEGIN
   MyDlgHook := item;            {by default, return the item passed in}
   IF GetWRefCon(WindowPtr(theDialog)) &lt;&gt; LongInt(sfMainDialogRefCon) THEN
      Exit(MyDlgHook);           {this function is only for main dialog}

   {Do processing of pseudo-items and your own additional item.}
   CASE item OF 
      sfHookFirstCall:           {pseudo-item: first time function called}
         BEGIN
            GetDItem(theDialog, kPopUpItem, myType, myHandle, myRect);
            SetCtlValue(ControlHandle(myHandle), gCurrentType);
            MyDlgHook := sfHookNullEvent;
         END;
      kMyPopUpItem:              {user selected File Type pop-up menu}
         BEGIN
            GetDItem(theDialog, item, myIgnore, myHandle, myRect);
            myType := GetCtlValue(ControlHandle(myHandle));
            IF myType &lt;&gt; gCurrentType THEN
               BEGIN
                  gCurrentType := myType;
                  MyDlgHook := sfHookRebuildList;
               END;
         END;
      OTHERWISE
         ;                       {ignore all other items}
   END;
END;
</PRE>
 The pop-up menu is stored as a control in the application's resource fork. Values stored in the resource determine the appearance of the control, such as the pop-up title text and the menu associated with the control. The Dialog Manager's <CODE>ModalDialog</CODE> procedure takes care of drawing the box around the pop-up menu and the title of the dialog box. When the dialog hook function is first called, it simply retrieves a handle to that control and sets the value of the pop-up control to the current menu item (stored in the global variable <CODE>gCurrentType</CODE>). The <CODE>MyDlgHook</CODE> function then returns <CODE>sfHookNullEvent</CODE> to indicate that no further processing is required.<P>
 When the user clicks the pop-up menu control, <CODE>ModalDialog</CODE> calls the standard control definition function associated with it. If the user makes a selection in the pop-up menu, <CODE>MyDlgHook</CODE> is called with the <CODE>item</CODE> parameter equal to kPopUpItem. Your dialog hook function needs simply to determine the current value of the control and respond accordingly. In this case, if the user has selected a new file type, the global variable <CODE>gCurrentType</CODE> is updated to reflect the new selection, and <CODE>MyDlgHook</CODE> returns sfHookRebuildList to cause the Standard File Package to rebuild the list of files and folders displayed in the dialog box.<P>
 For complete details on handling pop-up menus, see the chapters "Control Manager" and "Menu Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>.<A NAME=MARKER-2-77></A><P>
<A NAME=HEADING308-116></A>
<H3><A NAME=MARKER-9-169></A>Writing a Modal-Dialog Filter Function</H3>
 <A NAME=MARKER-2-170></A><A NAME=MARKER-2-103></A>A modal-dialog filter function controls events closer to their source by filtering the events received from the Event Manager. The Standard File Package itself contains <BR>an internal modal-dialog filter function that maps keypresses and other user input <BR>onto the equivalent dialog box items. If you also want to process events at this level, <BR>you can supply your own filter function.<A NAME=MARKER-2-105></A><P>
<DL>
<DT><B>Note</B>
<DD>You can supply a modal-dialog filter function only when you use one of the procedures that displays a customized dialog box (that is, <CODE>CustomGetFile</CODE>, <CODE>CustomPutFile</CODE>, <CODE>SFPGetFile</CODE>, or <CODE>SFPPutFile</CODE>).<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 Your modal-dialog filter function determines how the Dialog Manager procedure <CODE>ModalDialog</CODE> filters events. The <CODE>ModalDialog</CODE> procedure retrieves events by calling the Event Manager function <CODE>GetNextEvent</CODE>. As just indicated, the Standard File Package contains an internal filter function that performs some preliminary processing on each event it receives. If you provide a modal-dialog filter function, <CODE>ModalDialog</CODE> calls your filter function after it calls the internal Standard File Package filter function and before it sends the event to your dialog hook function.<P>
 You might provide a modal-dialog filter function for several reasons. If you have customized the Open or Save dialog boxes by adding one or more items, you might want to map some of the user's keypresses to those items in the same way that the internal filter function maps certain keypresses to existing items.<P>
 Another reason to provide a modal-dialog filter function is to avoid a problem that <BR>can arise if an update event is received for one of your application's windows while <BR>a Standard File Package dialog box is displayed.<P>
<DL>
<DT><B>Note</B>
<DD>The problem described in the following paragraph occurs only in system software versions earlier than version 7.0. The internal modal-dialog filter function installed by the Standard File Package when running in version 7.0 and later avoids the problem by passing the update event to your dialog filter and, if your filter doesn't handle the event, mapping it to a null event.<B><EM></EM></B>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 When <CODE>ModalDialog</CODE> calls <CODE>GetNextEvent</CODE> and receives the update event, <CODE>ModalDialog</CODE> does not know how to respond to it and therefore passes the update event to the Standard File Package's internal filter function. The internal filter function cannot handle the update event either. As a result, if you do not provide your own modal-dialog filter function that handles the update event, that event is never cleared. The next time <CODE>ModalDialog</CODE> calls <CODE>GetNextEvent</CODE>, it receives the same update event. <CODE>ModalDialog</CODE> never receives a null event, so your dialog hook function never performs any processing in response to the <CODE>sfHookNullEvent</CODE> pseudo-item. You can solve this problem by providing a modal-dialog filter function that handles the update event or changes it to a null event. See <A HREF=#MARKER-9-175>Listing 3-10</A> for details.<A NAME=MARKER-2-2></A><P>
 A modal-dialog filter function used with <CODE>SFPGetFile</CODE> and <CODE>SFPPutFile</CODE> is declared like any filter function passed to <CODE>ModalDialog</CODE>. Your function is passed a pointer to the dialog record, a pointer to the event record, and the item number. (The modal-dialog filter function is described in the chapter "Dialog Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>.) <P>
<PRE>
FUNCTION MyModalFilter (theDialog: DialogPtr; 
                        VAR theEvent: EventRecord; 
                        VAR itemHit: Integer): Boolean;
</PRE>
 The modal-dialog filter function used with <CODE>CustomGetFile</CODE> and <CODE>CustomPutFile</CODE> requires an additional parameter, a pointer (<CODE>myDataPtr</CODE>) to the data received from <BR>your application, if any.<P>
<PRE>
FUNCTION MyModalFilterYD (theDialog: DialogPtr; 
                           VAR theEvent: EventRecord; 
                           VAR itemHit: Integer; 
                           myDataPtr: Ptr): Boolean;
</PRE>
 Your modal-dialog filter function returns a Boolean value that reports whether it handled the event. If your function returns a value of <CODE>FALSE</CODE>, <CODE>ModalDialog</CODE> <BR>processes the event through its own filters. If your function returns a value of <CODE>TRUE</CODE>, <CODE>ModalDialog</CODE> returns with no further action.<P>
 The <CODE>CustomGetFile</CODE> and <CODE>CustomPutFile</CODE> procedures call your filter function to process events in both the main dialog box and any subsidiary dialog boxes (such as the dialog box for naming a new folder while saving a document through <CODE>CustomPutFile</CODE>). To determine whether the dialog record describes the main dialog box or a subsidiary dialog box, check the value of the <CODE>refCon</CODE> field in the window record in the dialog record, as described in <A HREF=#MARKER-9-122>"Writing a Dialog Hook Function"</A> beginning on <A HREF=#MARKER-9-122>page 3-21</A>.<P>
 <A HREF=#MARKER-9-175>Listing 3-10</A> shows how to define a modal-dialog filter function that prevents update events from clogging the event queue.<P>
<B>Listing 3-10  <A NAME=MARKER-9-175></A>A sample modal-dialog filter function</B><P>
<PRE>
FUNCTION MyModalFilter (theDialog: DialogPtr; VAR theEvent: EventRecord;
                        VAR itemHit: Integer): Boolean;
BEGIN
   MyModalFilter := FALSE;             {we haven't handled the event yet}
   IF theEvent.what = updateEvt THEN
      IF IsAppWindow(WindowPtr(theEvent.message)) THEN
         BEGIN
            DoUpdateEvent(WindowPtr(theEvent.message));
            MyModalFilter := TRUE;     {we have handled the event}
         END;
END;
</PRE>
 If this filter function receives an update event for a window other than the Standard File Package dialog box, it calls the application's routine for handling update events (<CODE>DoUpdateEvent</CODE>) and returns <CODE>TRUE</CODE> to indicate that the event has been handled. See <BR>the chapters "Event Manager" and "Window Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for complete details on handling update events.<A NAME=MARKER-2-176></A><A NAME=MARKER-2-177></A><A NAME=MARKER-2-178></A><P>
<A NAME=HEADING308-134></A>
<H3><A NAME=MARKER-9-179></A>Writing an Activation Procedure</H3>
 The activation procedure controls the highlighting of dialog items that are defined by your application and can receive keyboard input. Ordinarily, you need to supply an activation procedure only if your application builds a list from which the user can select entries. The Standard File Package supplies the activation procedure for the file display list and for all TextEdit fields. You can also use the activation procedure to keep track of which field is receiving keyboard input, if your application needs that information.<A NAME=MARKER-2-59></A><A NAME=MARKER-2-109></A><P>
 The target of keyboard input is called the active field. The two standard keyboard-input fields are the filename field (present only in Save dialog boxes) and the display list. Unless you override it through your own dialog hook function, the Standard File Package handles the highlighting of its own items and TextEdit fields. When the user changes the keyboard target by pressing the mouse button or the Tab key, the Standard File Package calls your activation procedure twice: the first call specifies which field is being deactivated, and the second specifies which field is being activated. Your application is responsible for removing the highlighting when one of its fields becomes inactive and for adding the highlighting when one of its fields becomes active. The Standard File Package can handle the highlighting of all TextEdit fields, even those defined by your application.<A NAME=MARKER-2-182></A><P>
 The activation procedure receives four parameters: a dialog pointer, a dialog item number, a Boolean value that specifies whether the field is being activated (<CODE>TRUE</CODE>) or deactivated (<CODE>FALSE</CODE>), and a pointer to your own data.<P>
<PRE>
PROCEDURE MyActivateProc (theDialog: DialogPtr; itemNo: Integer;
                           activating: Boolean; myDataPtr: Ptr);
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Files-307.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-309.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Files-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
