<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Measuring and Drawing Lines of Text(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING139></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-138.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-140.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-126.html"><B>Chapter 3 - QuickDraw Text</B></A> / <A HREF="Text-133.html"><B>Using QuickDraw Text</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING139-0></A>
<H2><A NAME=MARKER-2-409></A><A NAME=MARKER-9-136></A>Measuring and Drawing Lines of Text</H2>
 This section describes how to lay out and draw a line of text <A NAME=MARKER-2-45></A>consisting of a single style run or <A NAME=MARKER-2-237></A>multiple style runs. A line of text all in the same font, script, and character attributes constitutes a single style run. A new style run begins when any of these textual characteristics change. QuickDraw relies on the construct of style runs to track these text attribute changes throughout a line of text. Before you measure or draw a text segment that constitutes a new style run, you need to set the text-related graphics port fields for that style run.<P>
 This section also describes how to draw text lines that are right or left aligned, or justified. Finally, it explains how to draw explicitly scaled text, whether the lines of text are justified or not.<P>
 To draw a line of text, you first need to lay it out. If the text does not contain mixed directions, the text layout process consists of a single step: determining where to break the line. If the text contains mixed directions, the order in which you display the style runs may be different from their storage order, so you also need to determine the drawing order.<A NAME=MARKER-9-237></A><P>
 Moreover, if you want to draw a line of justified text, the process entails additional steps: you need to determine the total amount of extra pixels that remains to be distributed throughout the line of text and how to distribute these extra pixels throughout the style runs.<P>
 If you want to draw a line of text that is not justified, you can position the pen according to its alignment. You align text by positioning the pen appropriately so that the first glyph of the text line is flush against the display line's margin: at the left margin for left-aligned text, or at the right margin for right-aligned text.<P>
 Your application loops through these steps for each style run and each line of text that it measures and draws, and it needs to track the text in memory as it proceeds through each loop. Each time you measure or draw a text segment, you need to pass the beginning byte offset and its length to the QuickDraw routine. Before you call a QuickDraw measuring or drawing routine, you need to set the graphics port text-related fields to reflect the new style run's values.<P>
 These steps summarize the line layout and drawing process:<P>
<OL>
<LI>Determine where to break the line.
<LI>Determine the display order of the style runs (mixed-directional text).
<LI>Eliminate trailing spaces (justified text).
<LI>Calculate the slop value (justified text).
<LI>Distribute the slop (justified text).
<LI>Position the pen.
<LI>Draw the text.<P>
</OL>
 Each step covers the basics, plus any additional information you need to know to perform the step for justified or scaled text. The following sections elaborate these steps.<P>
<A NAME=HEADING139-16></A>
<H3>Determining Where to Break the Line</H3>
 For text that spans <A NAME=MARKER-9-298></A>multiple lines, you are responsible for controlling where a text line starts and ends. To determine where to break a line of text, first you need to know the screen pixel width of the display line. Then, taking into account all the text characteristics, you need to assess how much of the text you can display on the line, and the appropriate point to break the text.<P>
 You should always break a line on a word boundary. To allow for text in different languages, use the QuickDraw and the Text Utilities routines that identify the appropriate place to break a line in any script system.<P>
 The two routines you use for unscaled text are the <CODE>StyledLineBreak</CODE> and <CODE>TextWidth</CODE> functions; <CODE>StyledLineBreak</CODE> is described in the chapter Text Utilities in this book. Each time you call <CODE>StyledLineBreak</CODE> for a style run, first you need to set the graphics port text characteristics for that style run.<P>
<DL>
<DT><B>Saving the screen pixel width of each style run</B>
<DD>To draw justified text, you need to determine the amount of extra pixels to allocate to each style run in the text line. To determine this value, you need to know the screen pixel width of each style run. You can avoid having to measure the width of each style run twice in the text-layout process by using the <CODE>textWidth</CODE> parameter of the <CODE>StyledLineBreak</CODE> function to get and save the screen pixel width of each style run. The <CODE>StyledLineBreak</CODE> function maintains the value of the <CODE>textWidth</CODE> parameter, which you initially set to the length of the display line. When you call <CODE>StyledLineBreak</CODE> for each style run in the script run, it decrements this value by the width of the style run. You can calculate the screen pixel width of a style run by subtracting the current value of <CODE>textWidth</CODE> from the display line length each time through your <CODE>StyledLineBreak</CODE> loop, and save the value to be used later.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 If you do not want to use <CODE>StyledLineBreak</CODE>, you can use the<A NAME=MARKER-2-848></A> <CODE>TextWidth</CODE> function to measure each style run, adding the returned values until the sum exceeds the display line length. You can next use the Text Utilities <CODE>FindWordBreaks</CODE> procedure on the last style run to identify the ending location of the appropriate word in the style run, then break the text accordingly.<A NAME=MARKER-2-11></A><P>
 If a space character occurs at a line's end, and more space characters follow it in memory, <CODE>StyledLineBreak</CODE> breaks the line after the final space character in memory. This obviates the need for you to check for space characters in memory, when you lay out the next line of text. However, if you do not use <CODE>StyledLineBreak</CODE>, you need to check for space characters at the beginning of a line of text, and increment the memory pointer beyond these space characters. You can use the <A NAME=MARKER-2-407></A><CODE>CharacterType</CODE> function to identify space characters. For more information about <CODE>CharacterType</CODE>, see the chapter "Script Manager" in this book.<P>
 <A HREF=#MARKER-9-144>Listing 3-2</A> calculates line breaks using <CODE>StyledLineBreak</CODE>. The procedure sets the local variables, the display line length, and a value to control the line-breaking loop. Then it iterates through the text for each style run, setting the graphics port text fields for the style run and calling <CODE>StyledLineBreak</CODE> to identify where to break the line.<P>
<B>Listing 3-2  <A NAME=MARKER-9-144></A>Calling <CODE>StyledLineBreak</CODE> to identify where to break the text line</B><P>
<PRE>
   PROCEDURE MyBreakTextIntoLines (window: WindowPtr);
   VAR
      thetextPtr: Ptr;
      thetextLength: LongInt;
      pixelWidth: Fixed;
      textOffset: LONGINT;
      StartOfLine: Point;
      index: Integer;
      tempRect: Rect;
      lineData: myLineArray;
      lineIndex: Integer;
      theBreakCode: StyledLineBreakCode;
      theStartOffset: Integer;
   BEGIN
      thetextPtr := gText.textPtr;
      index := 0;
      SetPort(window);
      tempRect := window^.portRect;
      InsetRect(tempRect, 4, 4);
      SetPt(StartOfLine, 10, 4);
      MoveTo(StartOfLine.h, StartOfLine.v);
         {Set up our local flags and variables.}
      lineIndex := 0;   {This is the index into the line data.}
      index := 0;       {This is the index into the style data.}
      WITH gText.runData[index] DO 
      BEGIN
         thetextPtr := Ptr(ORD(gText.textPtr) + runStart);
         thetextLength := gText.textLength;
         theStartOffset := 0;
      END;
         {Start walking through the textblock.}
      REPEAT
            {For the first style run in a line, textOffset must be non-zero.}
         textOffset := -1;
            {smBreakOverFlow means that the whole style run fits on the }
            { line with space remaining. The routine uses that condition to }
            { control the loop.}
         theBreakCode := smBreakOverflow;
            {StyledLineBreak expects the width of the display area }
            { to be expressed as a fixed value.}
         pixelWidth := BSL((tempRect.right - tempRect.left), 16);
         WITH gText DO 
            BEGIN 
               WHILE (theBreakCode = smBreakOverflow) DO 
                  BEGIN WITH gText.runData[index] DO 
                     BEGIN
                           {set the port}
                        TextFont(font);
                        TextFace(face);
                        TextSize(size);
                           {call StyledLineBreak to break the line}
                        theBreakCode := StyledLineBreak(thetextPtr,
                                       thetextLength, theStartOffset,
                                       runEnd, 0, pixelWidth, textOffset);
                           {now remember the information returned}
            lineData[lineIndex].textStartOffset := theStartOffset;
                  {remember the beginning of this run}
            lineData[lineIndex].textLength := textOffset - theStartOffset;
                  {and the length of this run length}
            lineData[lineIndex].styleIndex := index;
                  {since the style information is global, just remember }
                  { the index to that information}
            lineIndex := lineIndex + 1;
         END;


            {If textoffset == the end of the run, increment the }
            { rundata index and set theStartOffset to be the beginning }
            {of the next run.}
         IF (textOffset = gText.runData[index].runend) THEN 
            BEGIN
               index := index + 1;
               theStartOffset := gText.runData[index].runStart;
            END
         ELSE
               {If textOffset &lt;&gt; the end of the run, the routine splits }
               { a run, so set theStartOffset appropriately}
            theStartOffset := theStartOffset + (textOffset - theStartOffset);
               {If there is more text, reset the offset value }
               { returned by StyledLineBreak}
            IF textOffset = thetextLength THEN LEAVE
                  {if textOffset == the textLength there is no more}
                  { text, so jump out of the loop}
               ELSE
                  textOffset := 0;
                     {we haven't found the line break yet, }
                     { textOffset must be zero for all runs after }
                     { the first in a line}
      END; {of while loop}
   END;
</PRE>
 If the text is explicitly scaled, you cannot use <CODE>StyledLineBreak</CODE> to determine where to break the line. This is because the <CODE>StyledLineBreak</CODE> function does not accept scaling factors. To determine where to break a line of scaled text, you can directly call the routines that <CODE>StyledLineBreak</CODE> uses. The section <A HREF=#MARKER-9-186>"Using Scaled Text" on page 3-43</A> describes these steps.<P>
<A NAME=HEADING139-29></A>
<H3><A NAME=MARKER-9-145></A>Determining the Display Order for Style Runs</H3>
 Now that you know where to break the line, you need to determine the display order of the style runs that constitute the line when the text contains mixed <A NAME=MARKER-2-255></A>directions; if your text does not contain mixed directions, you can skip this step.<P>
 You draw style runs in their <A NAME=MARKER-2-253></A>display order, which may be different from how the text is stored if it contains mixed directions. (For more information about storage order and display order, see the chapter "Introduction to Text on the Macintosh" in this book.) To determine the correct order, use <CODE>GetFormatOrder</CODE>; this procedure returns the order, from left to right, in which to draw the style runs on a line.<A NAME=MARKER-9-376></A><P>
 To use <CODE>GetFormatOrder</CODE>, you must have organized your style runs sequentially in storage order. You pass <A NAME=MARKER-2-249></A><CODE>GetFormatOrder</CODE> the numbers of the first and last style runs on the line, and the primary line direction of the text to be drawn. If you do not explicitly define the primary line direction, you can base it on the value of the <CODE>SysDirection</CODE> global variable. (The <CODE>SysDirection</CODE> global variable is set to -1 if the system direction is right to left, and 0 if the system direction is left to right.)<P>
 You pass <CODE>GetFormatOrder</CODE> a pointer to an application-defined Boolean function that calculates the correct direction for each style run and a pointer to an application-defined information block, containing font and script information, that the Boolean function uses to determine the style run direction. The <CODE>GetFormatOrder</CODE> procedure calls your Boolean function for each style run on the line.<P>
 <A HREF=#MARKER-9-151>Listing 3-3</A> shows an example Boolean function that calculates the line direction of a style run. Here is the type declaration for the <CODE>MyLineDrawingInfo</CODE> records, which are created as the application calculates line breaks:<P>
<PRE>
TYPE MyLineDrawingInfo = 
RECORD
   textPtr: Ptr;
   textLength: Integer;
   styleIndex: Integer:
END;

MyLineArray = ARRAY[0 ..MaxNumberofStyleRuns] OF
    MyLineDrawingInfo;
myLineDrawingInfoPtr = ^MyLineDrawingInfo;
</PRE>
 The <CODE>styleIndex</CODE> field of each record of type <CODE>MyLineDrawingInfo</CODE> points to an entry in an array of style run records of type <CODE>MyStyleRun</CODE>. A style run record contains style information including font, size, style, and scaling factors. The declaration for <CODE>MyStyleRun</CODE> follows:<P>
<PRE>
MyStyleRun = 
RECORD
   runStart: Integer;
   runEnd: Integer;
   size: Integer;
   font: Integer;
   face: Style;
   numer: Point;
   denom: Point;
END;

{This sample program uses a static array to store style run }
{ information. Typically, a program would use a dynamic }
{ data structure.}
</PRE>
 The <CODE>MyDirectionProc</CODE> function checks the font of the style run to determine if the font belongs to a right-to-left script system. If it does, the function returns <CODE>TRUE</CODE>; otherwise it returns <CODE>FALSE</CODE>. When <CODE>GetFormatOrder</CODE> calls <CODE>MyDirectionProc</CODE>, it passes an integer identifying the style run and a pointer to an application-defined parameter block. In <A HREF=#MARKER-9-151>Listing 3-3</A>, the pointer indicates the <CODE>MyLineArray</CODE> array. The <CODE>MyDirectionProc</CODE> function uses the style run identifier and the size of a <CODE>MyLineDrawingInfo</CODE> record to find the right <CODE>MyLineDrawingInfo</CODE> record in the array. It uses the <CODE>styleIndex</CODE> field of the <CODE>MyLineDrawingInfo</CODE> record to locate the right style run record in the array of <CODE>MyStyleRun</CODE> records. The font field of the style run record contains a font family ID that the function uses to determine the script code. The function calls the Script Manager with the script code to determine the script direction<A NAME=MARKER-2-150></A><P>
<B>Listing 3-3  <A NAME=MARKER-9-151></A>An application-defined run direction function called by <CODE>GetFormatOrder</CODE></B><P>
<PRE>
FUNCTION MyDirectionProc(theFormat: Integer;
                           myDirectionParam: Ptr):Boolean;
   VAR
      scriptCode:    Integer;
      p:             myLineDrawingInfoPtr;
      offset:        LongInt;
BEGIN
   offset := SIZEOF(MyLineDrawingInfo) * theFormat;
   p := myLineDrawingInfoPtr(ORD(myDirectionParam) + offset);
   scriptCode := FontToScript(gText.runData[p^.styleIndex].font); 
   IF Boolean(GetScriptVariable(scriptCode, smScriptRight)) = TRUE
      THEN MyDirectionProc := TRUE
   ELSE
      MyDirectionProc := FALSE;
END;
</PRE>
 You reference the format order array to determine the display order when you draw the text. To draw a line of text that is not justified, after you determine the display order of the style runs, you can position the pen and draw the text. (To draw a line of text that is not justified, see <A HREF=#MARKER-9-173>"Drawing the Line of Text" on page 3-41</A>.) To draw text that is scaled, you can skip ahead to <A HREF=#MARKER-9-186>"Using Scaled Text" on page 3-43</A>. If you are drawing a line of justified text, you must complete some additional steps before positioning the pen and actually drawing the text. These steps are described in the next three sections.<P>
 <A HREF=#MARKER-9-152>Listing 3-4</A> shows an application-defined procedure that declares a format order array; it passes a pointer to that array when it calls <CODE>GetFormatOrder</CODE> for a line of text containing style runs with mixed directions. Using the information that <CODE>GetFormatOrder</CODE> returns in the format order array, the procedure iterates through the style runs in display order, setting the graphics for each style run, then drawing the text.<P>
<B>Listing 3-4  <A NAME=MARKER-9-152></A>Determining the style run display order and drawing the line</B><P>
<PRE>
PROCEDURE MyGetDisplayOrderAndDrawLine (theLineData: myLineArray; VAR
                                        index: Integer);
VAR
   FormatOrderArray: ARRAY[0..kMaximumNumberOfStyleRuns] OF Integer;
   I: Integer;
BEGIN
   GetFormatOrder(FormatOrderPtr(@FormatOrderArray), 0, index,
                   Boolean(GetSysDirection), @DirectionProc, @theLineData);
      {we know the display order, now we are ready to draw}
   FOR I := FormatOrderArray[0] TO FormatOrderArray[index] DO 
      BEGIN
      {Set the port.}
            WITH gText.runData[theLineData[i].styleIndex] DO 
               BEGIN
                  TextFont(font);
                  TextFace(face);
                  TextSize(size);
               END;
            DrawText(theTextPtr, lineData[i].textStartOffset,
                     theLineData[i].textLength);
         END;
         index := 0;
            {we found a line, so bump the index into the line data}
   END;  
</PRE>
<A NAME=HEADING139-45></A>
<H3><A NAME=MARKER-9-153></A>Eliminating Trailing Spaces (for Justified Text)</H3>
 If you are justifying text, after you know the line break and display order for your text, you must determine the total amount of extra pixels that remain to be distributed throughout the line, and how to <A NAME=MARKER-2-260></A>spread the extra pixels throughout the style runs. To get the correct total number of extra pixels, first you need to eliminate any trailing spaces from the last style run in memory order.<P>
 The <CODE>VisibleLength</CODE> function returns the length in bytes of the style run minus any trailing spaces; this is the byte length that you must use for the style run in any calculations necessary to determine the line layout, and for drawing the text.<P>
 The <CODE>VisibleLength</CODE> function behaves differently for various script systems. For simple script systems, such as Roman and Cyrillic, and 2-byte script systems, such as Japanese, <CODE>VisibleLengt</CODE>h does not include in the byte count it returns trailing spaces that occur at the display end of the text segment. For 2-byte script systems, <CODE>VisibleLength</CODE> does not count them, whether they are 1-byte or 2-byte space characters.<P>
 <A HREF=#MARKER-9-155>Figure 3-5</A> shows that <CODE>VisibleLength</CODE> eliminates trailing spaces at the right end of Roman text when the primary line direction is left to right. However, if you change the primary line direction, <CODE>VisibleLength</CODE> assumes the left end as the display end of the text, and does not eliminate the spaces on the right.<P>
<B>Figure 3-5  <A NAME=MARKER-9-155></A>Calling <CODE>VisibleLength</CODE> for a Roman style run</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/QT_L-19.jpg">
 For 1-byte complex script systems, <CODE>VisibleLength</CODE> does not include in the byte count that it returns spaces whose character direction is the same as the primary line direction. The primary line direction is determined by the <CODE>SysDirection</CODE> global variable. By default, the value of <CODE>SysDirection</CODE> is the direction of the system script. You can change this value. Some word processors that allow users to change the primary line direction, for example, to create a document entirely in English when the system script is Hebrew, change the value of <CODE>SysDirection</CODE>. If you modify the <CODE>SysDirection</CODE> global value, be sure to first save the original value and restore it before your program terminates.<P>
 <A HREF=#MARKER-9-156>Figure 3-6</A> shows a Hebrew style run with trailing spaces at the left end, which <CODE>VisibleLength</CODE> eliminates. In this case, the primary line direction is right to left; if it were left to right, <CODE>VisibleLength</CODE> would return 5.<P>
<B>Figure 3-6  <A NAME=MARKER-9-156></A>Calling <CODE>VisibleLength</CODE> for a Hebrew style run</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/QT_L-21.jpg">
 For those 1-byte complex script systems that support bidirectional text, Roman spaces take on a character direction based on the primary line direction. If the Roman spaces then fall at the end of the text, <CODE>VisibleLength</CODE> does not include them in the returned byte count. <A HREF=#MARKER-9-157>Figure 3-7</A> shows Roman spaces following Hebrew text in storage order. In the first part of the example, the Roman spaces take on the primary line direction of right to left, and follow the Hebrew text in display order also. Because they fall at the end of the display line, <CODE>VisibleLength</CODE> does not count them. The second part of the example shows what happens when the primary line direction is changed to left to right: the Roman spaces fall at the end of the line again and are not counted.<P>
<B>Figure 3-7  <A NAME=MARKER-9-157></A>Calling <CODE>VisibleLength</CODE> for Hebrew text with Roman space characters</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/QT_L-22.jpg">
<A NAME=HEADING139-59></A>
<H3><A NAME=MARKER-9-698></A><A NAME=MARKER-9-159></A>Calculating the Slop Value (for Justified Text)</H3>
 To draw justified text, after you eliminate trailing spaces from the line's last style run in memory order, you need to <A NAME=MARKER-2-275></A>determine the amount of remaining extra space to be distributed throughout the line. This is called the <I>slop value</I>; it is measured in pixels, and is the difference between the width of the text and the width of the display line. After you add the widths of all the style runs on the line to get the total width of the text, you can use the following statement to determine the slop value. Be sure to use the value returned by <CODE>VisibleLength</CODE> for the last style run in memory order when you add the style run widths.<A NAME=MARKER-2-276></A><P>
<PRE>
TotalSlop := DisplayLineLength -- SumofStyleRunWidths
</PRE>
 If you saved the screen pixel width of each style run when you called <CODE>StyledLineBreak</CODE>, then all you need to do is sum the total of the style run widths and subtract that total from the display line length to get the total slop value.<P>
 If you did not use <CODE>StyledLineBreak</CODE> or you did not save the screen pixel width of each style run when you called <CODE>StyledLineBreak</CODE>, first measure the width of each style run, using <A NAME=MARKER-2-8></A><CODE>TextWidth</CODE>, then add the widths to get the total. (Remember that each time you measure a style run, first you need to set the text-related graphics port fields for that style run.)<P>
 The <CODE>TextWidth</CODE> function returns the width in pixels of a style run. You pass <CODE>TextWidth</CODE> the number of bytes of the text to be measured. For script systems containing 2-byte characters, be certain that you pass the correct number of bytes; 2-byte script systems can contain a mix of one-byte and two-byte characters.<P>
 For scaled text, you cannot use the <CODE>TextWidth</CODE> function to get the screen pixel width of a style run. Instead, you can call the <A NAME=MARKER-2-71></A><CODE>StdTxMeas</CODE> function, which accepts and returns scaling parameters. Whenever you call <CODE>StdTxMeas</CODE> directly, first you must check the graphics port <CODE>grafProc</CODE> field to determine if the bottleneck routines have been customized, and if so, use the customized version. See <A HREF=Text-175.html#MARKER-9-365>"Low-Level QuickDraw Text Routines" on page 3-94</A> for more information.<P>
<DL>
<DT><B>Using a negative slop value</B>
<DD><A NAME=MARKER-21-111></A>You can pass the justification routines a positive or negative <A NAME=MARKER-2-10></A>slop value. Word processing programs can use a negative slop value to justify a line of text more smoothly by condensing it, when it only slightly exceeds the display line length.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING139-68></A>
<H3><A NAME=MARKER-9-166></A>Allocating the Slop to Each Style Run (for Justified Text)</H3>
 Once you have assessed the total amount of <A NAME=MARKER-2-282></A>slop to be distributed throughout the line of text, you need to determine the portion to apply to each style run. When you draw a style run that is part of a line of justified text, you pass this number as the value of the slop parameter.<P>
 To determine the actual number of pixels for each style run, first you determine the percentage of slop to attribute to the style run, and then apply that percentage to the total slop to get the number of pixels. To get the percentage of slop for a style run, you compute what percentage each portion is of the sum of all portions.<P>
 The following steps summarize this process:<P>
<OL>
<LI>Call <A NAME=MARKER-2-5></A><CODE>PortionLine</CODE> for each style run on the line. The <CODE>PortionLine</CODE> function returns a "magic number" which is the correct proportion of extra space to apply to a style run.
<LI>Add the returned values together.
<LI>For each style run, divide the value returned by <CODE>PortionLine</CODE> for that style run by the sum of the values returned for all of the style runs on the line.
<LI>For each style run, multiply the result of step 3 by the total slop value for the line.<P>
</OL>
 For example, suppose that there are three style runs on a line: style run A, style run B, and style run C. The total slop = 11; the line needs to be widened by 11 pixels to be justified. If you call <CODE>PortionLine</CODE> for each of the style runs, it produces the following results:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Style run<TH>Value returned by <CODE>PortionLine</CODE><TR>
<TD>A<TD>5.4<TR>
<TD>B<TD>7.3<TR>
<TD>C<TD>8.2</TABLE>
<P>
 Summing the three values together produces a total of 20.9. Now you need to convert the values into percentages by dividing each by the total. This produces the following results:<BR>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Style <BR>run<TH>Proportion<BR><TH>Percentage<BR>of total<TR>
<TD>A<TD>5.4/20.9<TD>25.84%<TR>
<TD>B<TD>7.3/20.9<TD>34.93%<TR>
<TD>C<TD>8.2/20.9<TD>39.23%</TABLE>
<P>
 The final step is to multiply the total slop value--11 pixels--by each percentage and round off to compute the actual number of pixels (slop) allocated to each style run. (To correct for the roundoff error, add the remainder to the pixels for the final style run.) This produces these results:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Style<BR>run<TH>Amount of slop<BR>(in pixels)<TR>
<TD>A<TD>3<TR>
<TD>B<TD>4<TR>
<TD>C<TD>4</TABLE>
<P>
 <A HREF=#MARKER-9-170>Listing 3-5</A> provides a code fragment that illustrates how you can use the <CODE>PortionLine</CODE> function to do this. The application-defined <CODE>MyCalcJustAmount</CODE> routine expects an array of the following type of records.<P>
<PRE>
Type RunRecord =
      Record
         tPtr:          Ptr;              {ptr to the text}
         tLength:       LongInt;          {length of run}
         tFace:         style;            {txFace of run}
         tFont:         Integer;          {font family ID}
         tSize:         Integer;          {pt size}
         tPlaceOnLine:  JustStyleCode;
         tnumer,tdenom: Point;            {scaling factors}
         tJustAmount:   Fixed;            {this value }
                                          { calculated here}
      END;
RunArray = ARRAY[1..MaxRuns] OF RunRecord;
</PRE>
 The <CODE>MyCalcJustAmount</CODE> routine also takes as a parameter a count of the total number of records that the array contains. Finally, the extra screen pixel width to be distributed is passed in as the <CODE>TotalPixelSlop</CODE> parameter. The routine calculates the amount of slop to be allocated to each run, and assigns that value to the field <CODE>tJustAmount<A NAME=MARKER-2-169></A></CODE>.<P>
<B>Listing 3-5  <A NAME=MARKER-9-170></A><A NAME=MARKER-21-171></A>Distributing slop value among style runs</B><P>
<PRE>
PROCEDURE MyCalcJustAmount(rArray: RunArray; NRuns: Integer; 
                           TotalPixelSlop: Integer);
VAR
   I:                   Integer;
   TotalSlopProportion: Fixed;
   PixelSlopRemainder:  Fixed;
   
BEGIN
{Find the proportion for each run, temporarily storing}
{ it in the tJustAmount field, and sum the }
{ returned values in TotalSlopProportion.}
   TotalSlopProportion := 0;
   FOR I := 1 TO NRuns DO 
      WITH rArray[I] DO BEGIN
         {Set the graphics port's fields for each style run}
         { to this style run}
         TextFace(tFace);
         TextFont(tFont);
         TextSize(tSize);
         tJustAmount := 
PortionLine(tPtr,tLength,tstyleRunPosition,tnumer,tdenom);
         TotalSlopProportion := TotalSlopProportion + tJustAmount;
         END;
{ Normalize the slop to be allocated to each run }
{ ( runportion / totalportion), and then convert that value to }
{ UnRounded Pixels: } 
{ (runportion / totalportion) * TotalPixelSlop ).}
   PixelSlopRemainder := Fixed(TotalPixelSlop);
      IF NRuns &gt; 1 THEN
         FOR I := 1 TO NRuns-1 DO
            WITH rArray[I] DO BEGIN
               {Use the FixRound routine to round this value.} 
               tJustAmount := FixMul(FixDiv(tJustAmount,
                           TotalSlopProportion),TotalPixelSlop);
               PixelSlopRemainder := PixelSlopRemainder -
                                       tJustAmount;
               END; 
      rArray[NRuns].tJustAmount := PixelSlopRemainder;
END; 
</PRE>
<A NAME=HEADING139-84></A>
<H3><A NAME=MARKER-9-175></A><A NAME=MARKER-9-173></A>Drawing the Line of Text</H3>
 Once you have laid out a line of text, drawing it is fairly simple. Your application's text-drawing routine needs to loop through the text, following these steps:<P>
<OL>
<LI>To position the pen correctly at the beginning of a new line, set the <A NAME=MARKER-2-88></A><CODE>pnLoc</CODE> graphics port field to the local coordinates representing the point where you want to begin drawing the text. You <A NAME=MARKER-2-693></A>use the QuickDraw <CODE>MoveTo</CODE> or <A NAME=MARKER-2-139></A><CODE>Move</CODE> procedure to reposition <A NAME=MARKER-2-286></A>the pen. (For more information about <CODE>Move</CODE> or <CODE>MoveTo</CODE>, see the QuickDraw chapters in <I><A HREF="../QuickDraw/QuickDraw-2.html">Inside Macintosh: Imaging</A></I>.) Within a line of text, after you draw a text segment, QuickDraw increments the pen location for you and positions the pen appropriately for the next text segment.
<LI>Before you draw each text run, set the text-related fields of the current graphics port to the text characteristics for that style run, if the text segment begins a new style run.
<LI>Draw the text segment.<P>
<UL>
<LI>If your text is not justified, use <A NAME=MARKER-2-308></A><CODE>DrawText</CODE> or <CODE>StdText</CODE> to draw it. The <CODE><A NAME=MARKER-2-311></A>StdText</CODE> procedure also allows you to draw scaled text that is not justified. If you use <CODE>StdText</CODE>, first you must determine whether the standard routine has been customized. If so, you must use the customized version. For more information, see <A HREF=Text-175.html#MARKER-9-365>"Low-Level QuickDraw Text Routines" on page 3-94</A>. <BR><BR><A HREF=#MARKER-9-152>Listing 3-4 on page 3-36</A> shows how to draw the text using <CODE>DrawText</CODE> after determining the display order.
<LI>If your text is justified, use the <CODE>DrawJustified</CODE> procedure to draw it. This procedure takes a parameter, <CODE>styleRunPosition</CODE>, that identifies the location of the style run in the line of text. You must specify the same value for this parameter that you used for it when you called the <CODE>PortionLine</CODE> function for this style run. The <CODE>DrawJustified</CODE> and <CODE>PortionLine</CODE> routines also take <CODE>numer</CODE> and <CODE>denom</CODE> parameters for scaling factors. For unscaled text, specify values of 1, 1 for both of these parameters.<P>
</UL>
<LI>After you draw each text segment, increment the pointer in memory to the beginning of the next text segment to be drawn.<P>
</OL>
 To position the pen horizontally, remember that QuickDraw always draws text from left to right:<P>
<UL>
<LI>For left-aligned text, position the pen at the left margin of the display line.
<LI>For right-aligned text, indent the pen from the left margin by the difference between the display line length and the total width of all the style runs. If you have set a <CODE>CharExtra</CODE> value, after you sum the total width of all the style runs, subtract the value that you passed to <CODE>CharExtra</CODE> from the total so that the rightmost character will be flush against the right margin.
<LI>For justified text, set the pen at the left margin. <P>
</UL>
 To determine the vertical coordinate of the <A NAME=MARKER-2-329></A>pen position when you <A NAME=MARKER-2-264></A>draw lines of text rendered in varying fonts and styles, you need to assess the required line height for each new style. You base this on the style run that requires the greatest number of vertical pixels. You can use the <A NAME=MARKER-2-278></A><CODE>GetFontInfo</CODE> procedure, which fills a record with information describing the current font's ascent, descent, and the width measurements of the largest glyph in the font, and leading. You can determine the line height by adding the values of these fields. For outline fonts, you can use the <CODE>OutlineMetrics</CODE> function to get the font measurements. For more information about <CODE>OutlineMetrics</CODE>, see the chapter "Font Manager" in this book. <A HREF=#MARKER-9-184>Listing 3-6</A> shows how to call <CODE>GetFontInfo</CODE>, and use the information it returns in the font information record to determine the line height.<A NAME=MARKER-2-542></A><P>
<B>Listing 3-6  <A NAME=MARKER-9-184></A>Calling <CODE>GetFontInfo</CODE> to determine the line height</B><P>
<PRE>
FUNCTION MyGetMaximumLineHeight (VAR mylineData: myLineArray;
                                     lastStyleIndex: Integer): Integer;
   VAR
      info: fontInfo;
      I: Integer;
      ignore: Integer;
      maxHeight: Integer;
   BEGIN
      maxHeight := 0;
      FOR i := 0 TO lastStyleIndex DO
         WITH gText.rundata[mylineData[i].styleIndex] DO 
            BEGIN
               {set the grafport up}
               TextFont(font);
               TextFace(face);
               TextSize(size);
               {Get the vertical metrics}
               GetFontInfo(info);
               {If this style run is taller than any others measured, }
               { remember the height.}
                  WITH info DO
                     IF (ascent + leading &gt; maxHeight) THEN
                        maxHeight := ascent + leading;
            END;
      MyGetMaximumLineHeight := maxHeight;
   END;
</PRE>
<A NAME=HEADING139-99></A>
<H3><A NAME=MARKER-2-887></A><A NAME=MARKER-9-186></A>Using Scaled Text</H3>
 This section describes how to determine where to break a line of scaled text. Then it describes how to draw scaled text, whether aligned or justified.<P>
 You cannot call <CODE>StyledLineBreak</CODE> for scaled text. To determine where to break a line of scaled text, you can directly call the routines that <CODE>StyledLineBreak</CODE> uses. The <CODE>StyledLinedBreak</CODE> function uses the <CODE><A NAME=MARKER-2-339></A>PixelToChar</CODE> function to locate the byte offset that corresponds to the pixel location marking the end of the display line.<P>
 <A NAME=MARKER-9-33></A>The primary use of <CODE>PixelToChar</CODE> is to locate a caret position associated with a mouse-down event. For this purpose, the <CODE>PixelToChar</CODE> function reorders the text when the text belongs to a right-to-left script system; this ensures that <CODE>PixelToChar</CODE> returns the correct byte offset associated with the pixel location of a mouse-down event.<P>
 If right-to-left text is reordered when you use <CODE>PixelToChar</CODE> to determine where to break a line, it returns the wrong byte offset. For right-to-left text, the end of a line in memory order can occur either at the left end of a display line or in the middle of one. To get the correct result, <CODE>StyledLineBreak</CODE> turns off reordering before it calls <CODE>PixelToCha</CODE>r. Your application must also do this.<P>
 You can define a routine that turns off reordering if the font's script system is right to left, and call your routine just before you call <CODE>PixelToChar</CODE>. Remember to restore reordering after you have determined where to break the line.<P>
 <A HREF=#MARKER-9-190>Listing 3-7</A> shows an application-defined routine that turns off reordering of text in a right-to-left script system. It tests to determine whether the reordering bit is on or off so that the application can restore it to its current state, then it clears the reordering bit (<CODE><A NAME=MARKER-2-13></A>smsfReverse</CODE>), and sets the script flag with the <CODE>SetScriptVariable</CODE> function. See the chapter "Script Manager" in this book for more information.<P>
<B>Listing 3-7  <A NAME=MARKER-9-190></A>Turning off reordering of right-to-left text before calling <CODE>PixelToChar</CODE> for line-breaking<A NAME=MARKER-2-949></A></B><P>
<PRE>
FUNCTION MySetReordering(font: integer): Boolean
   VAR
      flags: LongInt;
      err:  OSErr;
BEGIN
   flags := GetScriptVariable(smCurrentScript, smScriptFlags);
   MySetReordering := BTST(flags, smsfReverse);
   BCLR(flags, smsfReverse);
   err := SetScriptVariable(smCurrentScript, smScriptFlags,
                            flags);
END;
</PRE>
 Here are the steps you take to determine where to break a line of scaled text:<P>
<OL>
<LI>Call <CODE>PixelToChar</CODE> to determine the byte offset that <A NAME=MARKER-2-356></A>corresponds to the pixel location where you want to break the line. You pass the pixel location of the end of the display line to <CODE>PixelToChar</CODE> as the value of the <CODE>pixelWidth</CODE> parameter. The <CODE>PixelToChar</CODE> function returns the byte offset corresponding to the pixel location of the end of the display line, if the corresponding byte offset falls with the style run that you call <CODE>PixelToChar</CODE> for.<P>
If the byte offset corresponding to this pixel location does not fall within the style run, on return the <CODE>widthRemaining</CODE> parameter contains the number of pixels from the right edge of the text string for which you called <CODE>PixelToChar</CODE> to the end of the display line. You can loop through your text, calling <CODE>PixelToChar</CODE> for each style run until you encounter the byte offset that corresponds to the pixel location of the end of the display line.
<LI>Call the Text Utilities <CODE>FindWordBreaks</CODE> procedure with an <CODE>nbreaks</CODE> parameter of -1 to determine the boundaries of the word containing the byte offset that corresponds to the pixel location of the end of the display line. If the byte offset that <CODE>PixelToChar</CODE> returns is the beginning boundary or interior to the word, you should break the text before this word, or after the preceding word.<A NAME=MARKER-2-10></A>
<LI>If the byte offset that falls at the end of the display line is a space character, you should check to determine if there are succeeding space characters in memory; <CODE>StyledLineBreak</CODE> does this. You can use the Script Manager's <CODE>CharType</CODE> function for this purpose. If there are additional space characters, increment the text pointer beyond them in memory to determine the starting offset for the next line of text.<A NAME=MARKER-2-900></A><P>
</OL>
 <A NAME=MARKER-2-948></A>The steps that you follow to draw scaled text are the same as those for unscaled text, described under <A HREF=#MARKER-9-173>"Drawing the Line of Text" on page 3-41</A>. However, you perform some steps differently for scaled text. The steps are summarized here, and the differences are elaborated.<P>
<OL>
<LI>Set the <A NAME=MARKER-2-113></A><CODE>pnLoc</CODE> graphics port field to the local coordinates representing the point to begin drawing the text. You use <A NAME=MARKER-2-205></A><CODE>StdTxMeas</CODE> to get the font metrics for scaled text in order to determine the line height, instead of using <CODE>GetFontInfo</CODE>, which doesn't support scaling. Using the information that <CODE>StdTxMeas</CODE> returns, you can scale the vertical metrics. <A HREF=#MARKER-9-199>Listing 3-8</A> shows one way to do this.<A NAME=MARKER-2-901></A>
<LI>Before you draw each style run, set the text-related fields of the current graphics port to the text characteristics for that style run. This step is the same as for drawing unscaled text.
<LI>Use <CODE>DrawJustified</CODE> or <CODE>StdText</CODE> to draw the scaled text a style run at a time. To draw scaled text that is not justified, you call <CODE>StdText</CODE> or you can call <CODE>DrawJustified</CODE> and pass in <CODE>onlyStyleRun</CODE> for the <CODE>styleRunPosition</CODE> parameter.<P>
</OL>
 <A HREF=#MARKER-9-199>Listing 3-8</A> shows how to measure scaled text using <CODE>StdTxMeas</CODE>, and use the information returned in the font information (<CODE>fontInfo</CODE>) record to determine the line height. The <CODE>gText</CODE> global variable is initialized before the routine is called.<P>
 The application of which this routine is a part stores style runs in a text block, which is defined by the <CODE>TextBlock</CODE> data type.<P>
<PRE>
TextBlock = RECORD
   textPtr: Ptr;
   textLength: Integer;
   runData: StyleRunArray;
END;
</PRE>
<B>Listing 3-8  <A NAME=MARKER-9-199></A>Using <CODE>StdTxMeas</CODE> to get the font metrics for determining the line height of scaled text</B><P>
<PRE>
FUNCTION MyGetMaximumLineHeight(VAR lineData: LineArray;
                     lastStyleIndex: Integer): Integer;
   VAR
   info: fontInfo;
   i: Integer;
   ignore:Integer;
   MaxHeight:Integer;
   localNumer, localDenom: Point;
   size, font: Integer;
   face: Style;
BEGIN
   MaxHeight := 0;
   FOR i := 0 TO lastStyleIndex DO
    WITH gText.runData[lineData[i].styleIndex] DO BEGIN
   {Set up the graphics port}
      TextFont(font);
      TextFace(face);
      TextSize(size);
   {measure the text}
      localNumer := numer;
      localDenom := denom;
      ignore := StdTxMeas(lineData[i].textlength,
       lineData[i].textPtr, localNumer, localDenom, info);
   {scale the vertical metrics based on the StdTxMeas }
         { returned values of numer and denom}
      info.ascent := FixRound(FixMul(BSL(info.ascent, 16),
               FixRatio(localNumer.v, localDenom.v)));
      info.leading := FixRound(FixMul(BSL(info.leading, 16),
               FixRatio(localNumer.v, localDenom.v)));
      WITH info DO
         IF (ascent + leading &gt; maxHeight) THEN
            maxHeight := ascent + leading;
   END;
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-138.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-140.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
