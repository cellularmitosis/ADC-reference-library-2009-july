<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1182: NewGWorlds in VRAM and AGP Memory</title>       <meta name="keywords" content="NewGWorld, useDistantHdwrMem,  useLocalHdwrMem, flags, keepLocal, VRAM, AGP">    <meta name="Description" content="Technical Note TN1182: This Technote describes the changesin NewGWorld with the release of Mac OS 9.  These changesadd support for creating NewGWorlds in VRAM and AGP memory."><meta name="categories" content="QuickDraw"><meta name="week-posted" content="Sep 27, 1999 - Oct 1, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003021" title="NewGWorlds in VRAM and AGP Memory"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Carbon/idxGraphicsImaging-date.html" target="_blank">Carbon > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1182</div>
<div id="pageheadsub">NewGWorlds in VRAM and AGP Memory</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">   <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr><td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <span id="menutitle">CONTENTS   <br>  <br> </span>   </td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <!-- begin_toc -->         <P id = "menutext">         <A HREF = "#Section1">The New NewGWorld ()</A><BR><BR>                  <A HREF = "#Section2">Using the New NewGWorld ()</A><BR><BR>                  <A HREF = "#Section3">A Sample Implementation</A><BR><BR>                    <A HREF = "#Summary">Summary</A><BR><BR>        <A HREF = "#References">References</A><BR><BR><A HREF = "#Downloads">Downloadables</A></p> <!-- end_toc --></td>  </tr>  <tr>   <td width=300 align=left scope="row"> <img src="images/tnmenubottom.gif" alt="" width=300 height=16>   </td>  </tr>    </table></td>  <td width=300 valign="top" align=left>            <!-- begin_intro_text --><P id = "introtext">This Technote describes the changes in <code>NewGWorld</code> with the release of Mac OS 9.</p><P id = "introtext">The <code>NewGWorld</code> routine now supports allocation of offscreen <CODE>GWorld</CODE>'s in AGP memory and VRAM.  This allows the application programmer much more flexibility in deciding how to allocate their off-screen images.  It also adds more complexity and can, if used incorrectly, result in significantly poorer application performance.</P><P id = "introtext">This Technote describes the new selectors, covers their basic use, then goes on to illustrate some of the basic problems associated with their use.  Finally, the note discusses basic performance figures from a sample implementation.</P>    <!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Oct 5 1999]</h3><!-- end_date --></TD> </TR>    </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><A name="Section1"></A><H2 ALIGN=LEFT>The New NewGWorld ()</H2><H3 ALIGN=LEFT>NewGWorld</H3><P>Use the <code>NewGWorld</code> function to create an offscreen graphics world.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>QDErr NewGWorld     (GWorldPtr   *   offscreenGWorld,                              short           pixelDepth,                              const Rect  *   boundsRect,                              CTabHandle      cTable,    /* can be NULL */                              GDHandle        aGDevice,  /* can be NULL */                              GWorldFlags     flags)</pre></TD></TR></TABLE></CENTER><BR><BR> <CODE>offscreenGWorld</CODE><BR><UL><LI><CODE>offscreenGWorld</CODE> is a pointer to the offscreen graphics world created by this routine. </li></UL><code>pixelDepth</code><BR><UL><LI><code>pixelDepth</code> is the pixel depth of the offscreen world; possible depths are 1, 2, 4, 8, 16, and 32 bits per pixel. The <code>NewGWorld</code> function uses the pixel depth of the screen with the greatest pixel depth from among all screens whose boundary rectangles intersect the rectangle that you specify in the <code>boundsRect</code> parameter. If you specify zero in this parameter, <code>NewGWorld</code> also uses the <CODE>GDevice</CODE> record from this device instead of creating a new <CODE>GDevice</CODE> record for the offscreen world. If you use <code>NewGWorld</code> on a computer that supports only basic QuickDraw, you may specify only zero or one in this parameter.</li> </UL><code>boundsRect</code> <BR><UL><LI><CODE>boundsRect</CODE> is the boundary rectangle and port rectangle for the offscreen pixel map. This becomes the boundary rectangle for the <CODE>GDevice</CODE> record, if <code>NewGWorld</code> creates one. If you specify zero in the <code>pixelDepth</code> parameter, <code>NewGWorld</code> interprets the boundaries in global coordinates that it uses to determine which screens intersect the rectangle. (<code>NewGWorld</code> then uses the pixel depth, color table, and <CODE>GDevice</CODE> record from the screen with the greatest pixel depth from among all screens whose boundary rectangles intersect this rectangle.) Typically, your application supplies this parameter with the port rectangle for the onscreen window into which your application will copy the pixel image from this offscreen world.</li>  </UL><code>cTable</code><BR><UL><LI><code>cTable</code> is handle to a ColorTable record. If you pass <CODE>NULL</CODE> in this parameter, <code>NewGWorld</code> uses the default color table for the pixel depth that you specify in the <code>pixelDepth</code> parameter. If you set the <code>pixelDepth</code> parameter to 0, <code>NewGWorld</code> ignores the <code>cTable</code> parameter, and instead copies and uses the color table of the graphics device with the greatest pixel depth among all graphics devices whose boundary rectangles intersect the rectangle that you specify in the <code>boundsRect</code> parameter. If you use <code>NewGWorld</code> on a computer that supports only basic QuickDraw, you may specify only <CODE>NULL</CODE> in this parameter. </li> </UL><code>aGDevice</code><BR><UL><LI><code>aGDevice</code> is a handle to a <code>GDevice</code> record that is used in only two cases.  First, when you specify the <code>noNewDevice</code> flag in the <code>flags</code> parameter, in which case <code>NewGWorld</code> attaches this <code>GDevice</code> record to the new offscreen graphics world. Second, when you specify <code>useDistantHdwrMem</code> and/or <code>useLocalHdwrMem</code> flags in the <code>flags</code> parameter, in which case <code>NewGWorld</code> uses this <code>GDevice</code>'s VRAM or AGP memory to store the <code>GWorld</code>.  If you set the <code>pixelDepth</code> parameter to zero, or if you do not set the <code>noNewDevice, </code>noNewDevice flag,<code>useDistantHdwrMem</code>, and/or <code>useLocalHdwrMem</code> flag(s), <code>NewGWorld</code> ignores the <code>aGDevice</code> parameter, so you should set it to <CODE>NULL</CODE>. If you set the <code>pixelDepth</code> parameter to zero, <code>NewGWorld</code> uses the <code>GDevice</code> record for the graphics device with the greatest pixel depth among all graphics devices whose boundary rectangles intersect the rectangle that you specify in the <code>boundsRect</code> parameter. You should pass <CODE>NULL</CODE> in this parameter if the computer supports only basic QuickDraw. Generally, your application should never create <code>GDevice</code> records for offscreen graphics worlds.  Lastly, if you set <code>useDistantHdwrMem</code> and/or <code>useLocalHdwrMem</code> flags you should always specify a <code>GDevice</code>, otherwise the behavior and device associated with the <code>GWorld</code>, is indeterminate.</li> </UL><code>flags</code><BR><UL><LI><code>flags</code> describes options available to your application. You can set almost any combination of the flags <code>pixPurge</code>, <code>noNewDevice</code>, <code>useTempMem</code>, <code>keepLocal</code>, <code>useDistantHdwrMem</code>, and <code>useLocalHdwrMem</code>. If you don't wish to use any of these flags, pass 0 in this parameter, in which case you get the default behavior for <code>NewGWorld</code> - that is, it creates an offscreen graphics world where the base address for the offscreen pixel image is unpurgeable, it uses an existing <code>GDevice</code> record (if you pass 0 in the depth parameter) or creates a new <code>GDevice</code> record, it uses memory in your application heap, and it allows graphics accelerators to cache the offscreen pixel image. You should not use <code>keepLocal</code> with either <code>useDistantHdwrMem</code> or <code>useLocalHdwrMem</code>, the results are in determinate.  The available flags are described here:</li> </UL>       <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum{     pixPurge           = 1L &lt;&lt; pixPurgeBit,     noNewDevice        = 1L &lt;&lt; noNewDeviceBit,     useTempMem         = 1L &lt;&lt; useTempMemBit,     keepLocal          = 1L &lt;&lt; keepLocalBit,     useDistantHdwrMem  = 1L &lt;&lt; useDistantHdwrMemBit,     useLocalHdwrMem    = 1L &lt;&lt; useLocalHdwrMemBit,};typedef unsigned longGWorldFlags;</pre></TD></TR></TABLE></CENTER><BR><BR><CODE>pixPurge</CODE><BR><UL><LI>Makes base address for offscreen pixel image purgeable.</li> </UL><code>noNewDevice</code><BR><UL><LI>Stops the creation of an offscreen <code>GDevice</code> record.</li> </UL><code>useTempMem</code><BR><UL><LI>Create base address for offscreen pixel image in temporary memory.</li> </UL><code>keepLocal</code><BR><UL><LI>Keeps offscreen pixel image in main memory where it cannot be cached to a graphics accelerator card.</li> </UL><code>useDistantHdwrMem</code><BR><UL><LI>Attempts to create the offscreen pixel image in VRAM.</li> </UL><code>useLocalHdwrMem</code><BR><UL><LI>Attempts to create the offscreen pixel image in AGP memory.</li> </UL><H3>DESCRIPTION</H3><P>The <code>NewGWorld</code> function creates an offscreen graphics world with the pixel depth you specify in the <code>pixelDepth</code> parameter, the boundary rectangle you specify in the <code>boundsRect</code> parameter, the color table you specify in the <code>cTable</code> parameter, and the options you specify in the <code>flags</code> parameter. The <code>NewGWorld</code> function returns a pointer to the new offscreen graphics world in the <code>offscreenGWorld</code> parameter. You use this pointer when referring to this new offscreen world in other routines described in this chapter.</P><P>Typically, you pass 0 in the <code>pixelDepth</code> parameter, a window's port rectangle in the <code>boundsRect</code> parameter, <CODE>NULL</CODE> in the <code>cTable</code> and <code>aGDevice</code> parameters, and - in the <code>flags</code> parameter - an empty set ([ ]) for Pascal code or 0 for C code. This provides your application with the default behavior of <code>NewGWorld</code>, and it supports computers running basic QuickDraw. This also allows QuickDraw to optimize the <CODE>CopyBits</CODE>, <CODE>CopyMask</CODE>, and <CODE>CopyDeepMask</CODE> procedures when your application copies the image in an offscreen graphics world into an onscreen graphics port.</P><P>The <code>NewGWorld</code> function allocates memory for an offscreen graphics port and its pixel map. On computers that support only basic QuickDraw, <code>NewGWorld</code> creates a 1-bit pixel map that your application can manipulate using other relevant routines described in this chapter. Your application can copy this 1-bit pixel map into basic graphics ports.</P><P>Unless you specify zero in the <code>pixelDepth</code> parameter--or pass the <CODE>noNewDevice</CODE> flag in the <code>flags</code> parameter and supply a <code>GDevice</code> record in the <code>aGDevice</code> parameter--<code>NewGWorld</code> also allocates a new offscreen <code>GDevice</code> record.</P><P>When creating an image, your application can use the <code>NewGWorld</code> function to create an offscreen graphics world that is optimized for an image's characteristics--for example, its best pixel depth. After creating the image, your application can then use the <CODE>CopyBits</CODE>, <CODE>CopyMask</CODE>, or <CODE>CopyDeepMask</CODE> procedure to copy that image to an onscreen graphics port. Color QuickDraw automatically renders the image at the best available pixel depth for the screen. Creating an image in an offscreen graphics port and then copying it to the screen in this way prevents the visual choppiness that would otherwise occur if your application were to build a complex image directly onscreen.</P><P>The <code>NewGWorld</code> function initializes the offscreen graphics port by calling the <code>OpenCPort</code> function. The <code>NewGWorld</code> function sets the offscreen graphics port's visible region to a rectangular region coincident with its boundary rectangle. The <code>NewGWorld</code> function generates an inverse table with the Color Manager procedure <code>MakeITable</code>, unless one of the <code>GDevice</code> records for the screens has the same color table as the <code>GDevice</code> record for the offscreen world, in which case <code>NewGWorld</code> uses the inverse table from that <code>GDevice</code> record.</P><P>The address of the offscreen pixel image is not directly accessible from the <CODE>PixMap</CODE> record for the offscreen graphics world. However, you can use the <code>GetPixBaseAddr</code> function (described in <CITE>Inside Macintosh</CITE>, pages 6-38) to get a pointer to the beginning of the offscreen pixel image.</P><P>For purposes of estimating memory use, you can compute the size of the offscreen pixel image by using this formula:</P>        <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>rowBytes * (boundsRect.bottom - boundsRect.top)</pre></TD></TR></TABLE></CENTER><BR><BR><P>In the <code>flags</code> parameter, you can specify several options that are defined by the <code>GWorldFlags</code> data type. If you don't wish to use any of these options, pass zero here.</P><P>If you specify the <code>pixPurge</code> flag, <code>NewGWorld</code> stores the offscreen pixel image in a purgeable block of memory. In this case, before drawing to or from the offscreen pixel image, your application should call the <code>LockPixels</code> function (described in <a href="../../documentation/mac/QuickDraw/QuickDraw-2.html">Inside Macintosh: Imaging With QuickDraw</A>) and ensure that it returns <code>TRUE</code>. If <code>LockPixels</code> returns <code>FALSE</code>, the memory for the pixel image has been purged, and your application should either call <code>UpdateGWorld</code> to reallocate it and then reconstruct the pixel image, or draw directly in a window instead of preparing the image in an offscreen graphics world. Never draw to or copy from an offscreen pixel image that has been purged without reallocating its memory and then reconstructing it. If you specify the <code>noNewDevice</code> flag, <code>NewGWorld</code> does not create a new offscreen <code>GDevice</code> record. Instead, it uses the <code>GDevice</code> record that you specify in the <code>aGDevice</code> parameter - and its associated pixel depth and color table - to create the offscreen graphics world. (If you set the <code>pixelDepth</code> parameter to 0, <code>NewGWorld</code> uses the <code>GDevice</code> record for the screen with the greatest pixel depth among all screens whose boundary rectangles intersect the rectangle that you specify in the <code>boundsRect</code> parameter - even if you specify the <CODE>noNewDevice</CODE> flag.) The <code>NewGWorld</code> function keeps a reference to the <code>GDevice</code> record for the offscreen graphics world, and the <code>SetGWorld</code> procedure (described in <a href="../../documentation/mac/QuickDraw/QuickDraw-2.html">Inside Macintosh: Imaging With QuickDraw</a>) uses that record to set the current graphics device. If you set the <code>useTempMem</code> flag, <code>NewGWorld</code> creates the base address for an offscreen pixel image in temporary memory. You generally would not use this flag, because you should use temporary memory only for fleeting purposes and only with the <code>AllowPurgePixels</code> procedure (described in <a href="../../documentation/mac/QuickDraw/QuickDraw-2.html">Inside Macintosh: Imaging With QuickDraw</a>). If you specify the <code>keepLocal</code> flag, your offscreen pixel image is kept in Macintosh main memory and is not cached to a graphics accelerator card. Use this flag carefully, as it negates the advantages provided by any graphics acceleration card that might be present.  Specifying <code>useDistantHdwrMem</code> and/or <code>useLocalHdwrMem</code> attempts to allocate the offscreen pixel image in VRAM or AGP memory respectively.  If both flags are specified <code>NewGWorld</code> will first attempt to allocate in AGP memory, if that fails, it will attempt to allocate in VRAM.  When using <code>useDistantHdwrMem</code>, <code>useLocalHdwrMem</code> or both and <code>NewGWorld</code> cannot allocate the offscreen pixel image in the requested area of memory <code>NewGWorld</code> will fail and return a <code>memFullErr</code> error code.</P><P>As its function result, <code>NewGWorld</code> returns one of four result codes enumerated below.  <code>noErr</code> will always be returned from successful calls to <code>NewGWorld</code> any other returns values should be considered a failure to allocate the requested offscreen pixel image.</P><H3>SPECIAL CONSIDERATIONS</H3><P>If you supply a handle to a <code>ColorTable</code> record in the <code>cTable</code> parameter, <code>NewGWorld</code> makes a copy of the record and stores its handle in the offscreen <CITE>PixMap</CITE> record. It is your application's responsibility to make sure that the <code>ColorTable</code> record you specify in the <code>cTable</code> parameter is valid for the offscreen graphics port's pixel depth.</P><P>If when using <code>NewGWorld</code> you specify a pixel depth, color table, or <code>GDevice</code> record that differs from those used by the window into which you copy your offscreen image, the <code>CopyBits</code>, <code>CopyMask</code>, and <code>CopyDeepMask</code> procedures require extra time to complete.  These will likely cause buffers allocated in AGP memory or VRAM to be unable to utilize hardware blitting acceleration, possibly resulting in extremely poor copy performance.</P><P>There are two important things to note about <code>GWorld</code>'s allocated in VRAM.  First, the base address retrieved through <code>GetPixBaseAddr</code> or read directly from the <CODE>PixMap</CODE> structure can become invalid anytime memory is allocated in VRAM.  This can occur either by explicit allocations, such as calls to <code>NewGWorld</code>, or by implicit ones, such as those associated with the internal texture allocation of OpenGL.  The stored pixel images themselves will still be valid but may have been moved in VRAM, thus rendering any stored base addresses invalid.  You should never store an image's base address for longer than is necessary and especially never across calls to <code>NewGWorld</code> or texture-creation routines.</P><P>Secondly, an offscreen pixel image allocated in VRAM can be purged at system task time by the display driver.  This means any time your application yields time such by calling <code>WaitNextEvent</code> or <code>SystemTask</code> you can lose your VRAM <code>GWorld</code> contents.  While this happens infrequently, usually associated with display resolution or pixel depth changes you must code for this eventuality.  This purge can occur whether or not the <code>GWorld</code> is locked or not.  A return value of false from <code>LockPixels</code>, a NULL return value from <code>GetPixBaseAddr</code> or NULL in the baseAddr field of the <CODE>PixMap</CODE> mean that the pixel image has been purged.  To reallocate it you can either call <code>UpdateGWorld</code> or <CODE>Dispose</CODE> your current <code>GWorld</code> through <code>DisposeGWorld</code> and reallocate it via <code>NewGWorld</code>.  Either way you must then rebuild the pixel image.</P><P>To use a custom color table in an offscreen graphics world, you need to create the associated offscreen <code>GDevice</code> record, because Color QuickDraw needs its inverse table.</P><P>Currently, <code>NewGWorld</code> does not do exhaustive error checking on the combination of parameters you supply to it.  It assumes these parameters make sense.  This is especially true when working with the new flag parameters.  For example, you could legally pass <code>keepLocal, useDistantHdwrMem</code>, and <code>useLocalHdwrMem</code> in <code>flags</code> and <CODE>NULL</CODE> in <code>aGDevice</code>, although this makes no sense and the behavior is undefined.  You must ensure the flags and other parameters supplied to <code>NewGWorld</code> actually work together and not rely on the OS checking these kinds of errors.  </P><P>The <code>NewGWorld</code> function may move or purge memory blocks in the application heap. Your application should not call this function at interrupt time.</P>       <H3 ALIGN=LEFT>RESULT CODES</H3>     <TABLE cellpadding=2>        <TR>        <td width=75 align=left><code>noErr</code></TD> <TD align=right width=75 align="left">0</TD> <td width=75 align=left></TD><td align="left">No error </TD>    </TR>    <TR>        <td width=75 align=left><code>paramErr</code></TD> <TD align=right width=75 align="left">-50</TD> <td width=75 align=left></TD><td align="left">Illegal parameter </TD>    </TR>    <TR>        <td width=75 align=left><code>memFullErr</code></TD> <TD align=right width=75 align="left">-108</TD> <td width=75 align=left></TD><td align="left">Out of memory error</TD>    </TR>    <TR>        <td width=75 align=left><code>cDepthErr</code></TD> <TD align=right width=75 align="left">-157</TD> <td width=75 align=left></TD><td align="left">Invalid pixel depth</TD>    </TR></TABLE><BR><P>See also <a href="../../documentation/mac/QuickDraw/QuickDraw-2.html">Inside Macintosh: Imaging With QuickDraw.</a></p><P>Listing 6-1 on page 6-5 and Listing 6-2 on page 6-10 illustrate how to use <code>NewGWorld</code> to create offscreen graphics worlds.</P><P>If your application needs to change the pixel depth, boundary rectangle, or color table for an offscreen graphics world, use the <code>UpdateGWorld</code> function, described on pages 6-23 of <I>Inside Macintosh.</I></P><p><A HREF = "#top">Back to top</a></p><BR><A NAME="Section2"></A><h2>Using the New <code>NewGWorld ()</code></h2><P>The basics of using the new <code>NewGWorld</code> remain the same.  The two additional flags <code>useDistantHdwrMem</code> and <code>useLocalHdwrMem </code>allow the user to control where the offscreen pixel image is allocated.  If you use either <code>useDistantHdwrMem</code> or <code>useLocalHdwrMem </code>by themselves, <code>NewGWorld</code> will attempt to allocate the image on the device specified in <code>aGDevice</code> in only VRAM or AGP memory respectively.  If this allocation fails, <code>NewGWorld</code> will fail and return a <code>memFullErr </code>error.  If both <code>useDistantHdwrMem</code> and <code>useLocalHdwrMem</code> are specified, <code>NewGWorld</code> will first attempt to allocate in VRAM first, then AGP memory of the device specified in <code>aGDevice</code>.  If both fail, <code>NewGWorld</code> will fail and return a <code>memFullErr </code>error.  <code>aGDevice</code> should never be <CODE>NULL</CODE> when allocating in AGP memory or VRAM since the device used for the allocation will be indeterminate, which is almost never what the developer intended. </P><P><code>useDistantHdwrMem</code> is useful to allocate pixel images that are set once (or few) and used many times.  It is relatively slow to write to a VRAM pixel image from system memory, but it is very quick to do a hardware copy from VRAM to VRAM or VRAM to the screen.  Since there is currently no mechanism to determine if a copy operation will use hardware acceleration, it is recommended that all pixel images allocated in VRAM be the same bit depth and have the same color table as the screen.  Additionally, you should use simple copy operations that do not use masks or resizing to maximize the possibility of a specific copy being accelerated.</P><P><code>useLocalHdwrMem</code> attempts to allocate the pixel image in AGP memory.  If the system does not have an AGP graphics system or <code>NewGWorld</code> is unable to allocate the pixel image, the allocation will fail, returning a <code>memFullErr </code>error.  Since AGP allocations are in system memory, these do not suffer from the same problems associated with pixel images allocated in VRAM.  AGP memory can however have some limitations, such as being uncacheable, that make it slightly slower than regular system memory in copies to and other system memory.  While this is minor, developers should be aware of the slight performance degradation.</P><P>It is very important to understand where allocations happen and the general caveats (described in the preceding paragraphs) associated with allocations in other than standard system memory.  The key to improving an application's performance using offscreen <code>GWorld</code>'s with <code>useDistantHdwrMem</code> or <code>useLocalHdwrMem</code> flags is identifying which pixel images are used often and can be transferred with hardware accelerated copies.  Images used very often and modified infrequently can be placed in VRAM to optimize their copy performance.  For general purposes, you can use AGP memory.  Since the amount of AGP memory is limited and other graphics services, such as OpenGL, use it, care should be used to allocate more frequently used images first.  In addition, note that AGP memory is not swapped out to disk by the virtual memory system and the amount available may vary with the amount of physical memory installed on a system.</P><P>To recap, if a copy does not use hardware acceleration, performance from AGP memory to the screen can be expected at best to be equal to system memory.  In the same non-accelerated case performance from VRAM to the screen will be significantly slower than from system memory.  So allocate you images carefully and use AGP memory and VRAM judiciously.</P><P>As a final note, when <code>NewGWorld</code> allocates memory outside of your application heap (i.e., in AGP memory space or VRAM) it is extremely important that you properly dispose of that memory with <code>DisposeGWorld</code> prior exiting your application.  Failure to do so will leak memory, making either the  VRAM or AGP memory unavailable for future use.  In many cases, this leaked memory will only be recovered at restart.</P><P>One more reminder: when developing your implementation, ensure you note the above special considerations for <code>GWorld</code>'s allocated in VRAM.  It is critical that you handle moved and purged pixel images for <code>GWorld</code>'s in VRAM correctly, ensuring you will not display garbage or access invalid memory when trying to use VRAM <code>GWorld</code>'s.</P><p><A HREF = "#top">Back to top</a></p><BR><A NAME="Section3"></A><H2>A Sample Implementation</H2><P>Implementing this is actually very easy.  Below is some simple code that will assist you.  First, we will test for the availability of the new flags.  In this case, we just need to look at the system version (since there are no specific selectors for the new version of <code>NewGWorld</code>).  If the Mac OS in use is later than 8.6, we can expect <code>useDistantHdwrMem</code> and <code>useLocalHdwrMem</code> to be available.</P>              <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>Boolean gNewNewGWorld = false;long versionSystem;// this will only work with Mac OS later than 8.6Gestalt ('sysv', &amp;versionSystem);if (0x00000860 &lt; (versionSystem &amp; 0x00000FFFF))     gNewNewGWorld = true; // system is greater than version 8.6</pre></TD></TR></TABLE></CENTER><BR><BR>       <P>Next, we want to encapsulate the functions required to allocate and reallocate our <code>GWorld</code>.  We can use the same logic for both, checking the <CODE>GWorldPtr</CODE>, then checking the pixel image's <CODE>baseAddr</CODE> and finally checking to see if the window's <code>GDevice</code> is still the same as the offscreen's <code>GDevice</code>.  When allocating the <code>GWorld</code> we take the location input parameter and use this to determine in which memory space to allocate (VRAM, AGP memory, or application heap).  If an allocation fails, we fall through to the next type.  Obviously, you can modify this behavior to suit your needs.  The function returns true if the <code>GWorld</code> is allocated or reallocated and false if the existing <code>GWorld</code> is valid. This is shown in the following listing.</P>        <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>Boolean BuildOffscreen (GWorldPtr * ppGWorld, WindowPtr pWindow,                        short * plocation){     GDHandle hgdWindow = NULL;     Boolean fMustRebuild = false;if (NULL == *ppGWorld) // if GWorld passed in is not allocated     fMustRebuild = true;else{     PixMapHandle hPixmap = GetGWorldPixMap (*ppGWorld);     // if pixmap handle is NULL or pixmap base address is NULL     if ((NULL == hPixmap) || (!GetPixBaseAddr (hPixmap)))         fMustRebuild = true;     // if GWorld not on same device as window         else if (GetGWorldDevice(*ppGWorld) != GetWindowDevice (pWindow))         fMustRebuild = true;}if (fMustRebuild) // must rebuild{     // window pixel depth     short wPixDepth = (**((CGrafPtr)pWindow)-&gt;portPixMap).pixelSize;     GDHandle hgdWindow = GetWindowDevice (pWindow);// window GDevice     if (NULL != *ppGWorld) // if we have an allocated GWorld     {         DisposeGWorld (*ppGWorld);// dump our current GWorld         *ppGWorld = NULL;     }     switch (*plocation) // where to we want to put it     {         case kInVRAM:             if (noErr == NewGWorld (ppGWorld, wPixDepth, &amp;pWindow-&gt;portRect,                                     NULL, hgdWindow,                                     noNewDevice | useDistantHdwrMem))              break;         // we failed with VRAM, signal that and drop to AGP         SysBeep (30);         *plocation = kInAGP;     case kInAGP:         if (noErr == NewGWorld (ppGWorld, wPixDepth, &amp;pWindow-&gt;portRect,                                 NULL, hgdWindow,                                 noNewDevice | useLocalHdwrMem))              break;         // we failed with AGP, signal that and drop to system memory         SysBeep (30);         *plocation = kInSystem;     case kInSystem:     default:         if (noErr != NewGWorld (ppGWorld, wPixDepth,                                 &amp;pWindow-&gt;portRect, NULL, hgdWindow,                                 keepLocal | noNewDevice))          {              // we failed with system thus, we can't allocate our GWorld,              // signal that, indicate no location and drop to debugger              SysBeep (30);              *plocation = kNoWhere;              DebugStr ("\pUnable to allocate off screen image");              return false; // nothing was allocated         }         *plocation = kInSystem;    }     return true; // we rebuilt our GWorld   }   return false; // everything is okay}</pre></TD></TR></TABLE></CENTER><BR><BR><P>This previous function uses standard Macintosh Toolbox functions except the call to <code>GetWindowDevice</code> that determines the <code>GDevice</code> on which the majority of the window resides.  Note that it is up to the individual application developer to handle the case where windows span multiple devices.  <code>GetWindowDevice</code> is listed below.</P>      <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>GDHandle GetWindowDevice (WindowPtr pWindow){     Rect rectWind, rectSect;     short wFrameHeight, wTitleHeight;     long greatestArea, sectArea;     GDHandle hgdNthDevice, hgdZoomOnThisDevice;     rectWind = pWindow-&gt;portRect;     LocalToGlobal ((Point*)&amp; rectWind.top); // convert to global coordinates     LocalToGlobal ((Point*)&amp; rectWind.bottom);     // calculate height of window's title bar     wFrameHeight = rectWind.left - 1  -                   (**(((WindowPeek)pWindow)-&gt;strucRgn)).rgnBBox.left;     wTitleHeight = rectWind.top - 1  -                   (**(((WindowPeek)pWindow)-&gt;strucRgn)).rgnBBox.top;     rectWind.top = rectWind.top - wTitleHeight;     hgdNthDevice = GetDeviceList ();     greatestArea = 0; // initialize to 0     // check window against all gdRects in GDevice list and remember     //  which gdRect contains largest area of window}     while (hgdNthDevice)     {         if (TestDeviceAttribute (hgdNthDevice, screenDevice))              if (TestDeviceAttribute (hgdNthDevice, screenActive))              {                   // The SectRect routine calculates the intersection                   //  of the window rectangle and this GDevice                   //  rectangle and returns TRUE if the rectangles intersect,                   //  FALSE if they don't.                   SectRect(&amp;rectWind, &amp;(**hgdNthDevice).gdRect, &amp;rectSect);                   // determine which screen holds greatest window area                   //  first, calculate area of rectangle on current device                   sectArea = (long)(rectSect.right - rectSect.left) *  (rectSect.bottom - rectSect.top);                   if ( sectArea &gt; greatestArea )                   {                        greatestArea = sectArea;// set greatest area so far                        hgdZoomOnThisDevice = hgdNthDevice;// set zoom device                   }                   hgdNthDevice = GetNextDevice(hgdNthDevice);              }         } // of while     return hgdZoomOnThisDevice;}</pre></TD></TR></TABLE></CENTER><BR><BR>              <P>Once we have the buffer allocated, we just need to fill it and blit it to our window.  The process to do this remains unchanged.  The following listings demonstrate this.  Note, <code>FillOffscreen</code> assumes the <CODE>GWorldPtr</CODE> passed in is valid, while <code>BlitToWindow</code> is more general purpose and runs a check on the <code>GWorld</code>.</P>              <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// fills offscreen buffer with random bright colorvoid FillOffscreen (GWorldPtr pGWorld){     GDHandle hGDSave;     CGrafPtr pCGrafSave;     Rect rectSource = (pGWorld-&gt;portRect);     RGBColor rgbColor;     rgbColor.red   = (Random () + 32767) / 2 + 32767;     rgbColor.green = (Random () + 32767) / 2 + 32767;     rgbColor.blue  = (Random () + 32767) / 2 + 32767;     GetGWorld (&amp;pCGrafSave, &amp;hGDSave);     SetGWorld (pGWorld, NULL);     if (LockPixels (GetGWorldPixMap (pGWorld)))     {         // draw some background         EraseRect (&amp;rectSource);         RGBForeColor (&amp;rgbColor);         PaintRect (&amp;rectSource);         UnlockPixels (GetGWorldPixMap (pGWorld));     }     SetGWorld (pCGrafSave, hGDSave);}// checks offscreen and blits it to the frontvoid BlitToWindow (GWorldPtr pGWorld, WindowPtr pWindow, short * pLocation){    Rect rectDest = ((GrafPtr)pWindow)-&gt;portRect;     Rect rectSource = ((GrafPtr)pWindow)-&gt;portRect;     GrafPtr pCGrafSave;     // check to ensure we have a valid offscreen and rebuild if required     if (BuildOffscreen (&amp;pGWorld, pWindow, pLocation))     FillOffscreen (pGWorld);     // blit     GetPort (&amp;pCGrafSave);     SetPort ((GrafPtr) pWindow);     if (LockPixels (GetGWorldPixMap (pGWorld)))     {         CopyBits (&amp;((GrafPtr)pGWorld)-&gt;portBits,                   &amp;pWindow-&gt;portBits, &amp;rectSource, &amp;rectDest, srcCopy, NULL);         UnlockPixels (GetGWorldPixMap (pGWorld));     }     SetPort (pCGrafSave);}</pre></TD></TR></TABLE></CENTER><BR><BR><P>Lastly, we need to ensure the memory allocated by <code>NewGWorld</code> is disposed of properly.  The follow code demonstrates this.</P>                <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// this is VERY important since the <code>GWorld</code> may not be in the application heapif (pGWorld)     DisposeGWorld (pGWorld);pGWorld = NULL;</pre></TD></TR></TABLE></CENTER><BR><BR>        <p><A HREF = "#top">Back to top</a></p><BR><A NAME="Summary"></A><H2>Summary</H2><P>Using the new <code>NewGWorld</code> greatly enhances your options for creating performance-oriented applications.  By allocating pixel images in either VRAM or AGP memory space, one can achieve levels of graphics performance previously unavailable.  Using these new features though does impose some requirements on the application developer to ensure their code functions properly under all conditions.  A checklist to consider when using the new <code>NewGWorld</code> is as follows:</P><UL><LI>Check system version for availability of <code>useDistantHdwrMem</code> and <code>useLocalHdwrMem</code> flags.</LI><LI>Provide a <code>GDevice</code> when using <code>useDistantHdwrMem</code> and/or <code>useLocalHdwrMem</code>.</LI><LI>Check your return values for errors.</LI><LI>When retrieving your pixel image's base address check for <CODE>NULL</CODE>.</LI><LI>Implement a restoration scheme to handle purged pixel images.</LI><LI>Do not cache base address across functions that yield time to the system or that could allocate or deallocate VRAM.</LI><LI>Ensure <CODE>GWorlds</CODE> are disposed of properly to prevent memory leaks in VRAM or AGP memory.</LI></UL>        <P>The flags <code>useDistantHdwrMem</code> and <code>useLocalHdwrMem</code> provide the developer with more options for handling offscreen graphics but must be used with complete understanding of the additional burdens placed on the application.</P><p><A HREF = "#top">Back to top</a> </p><BR><a name="References"></a><H2>References</H2>        <p>Apple's <a href="../index.html">Technote web site</a></p>        <p><a href="../../documentation/mac/QuickDraw/QuickDraw-302.html">Inside Macintosh: Imaging With QuickDraw; Chapter 6: Offscreen Graphics Worlds</A></p>         <p><A HREF = "#top">Back to top</a> </p><BR><A NAME="Downloads"></A> <h2>Downloadables</h2><center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600"> <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P></TD><td align="left">   <p>Acrobat version of this Note (80K).</P></TD><td width=60 align=left>   <p><A HREF="pdf/tn1182.pdf">Download</A></P></TD>  </TR> </table></center><BR><BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1182.html%3Fid%3DDTS10003021-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1182.html%3Fid%3DDTS10003021-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1182.html%3Fid%3DDTS10003021-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>