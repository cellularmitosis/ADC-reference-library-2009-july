<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ProcDoggie - /UGlobals.p</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">ProcDoggie</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxProcessManagement-date.html" target="_blank">Carbon > Process Management</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ProcDoggie</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/UGlobals.p</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ProcDoggie.p</option>
<option value="listing2.html">/StubLDEF/StubLDEF.p</option>
<option value="listing3.html">/UDialogUtils.p</option>
<option value="listing4.html">/UEmergMem.p</option>
<option value="listing5.html">/UEvents.p</option>
<option value="listing6.html">/UGlobals.p</option>
<option value="listing7.html">/UMenuHandler.p</option>
<option value="listing8.html">/UProcessGuts.p</option>
<option value="listing9.html">/UProcessLDEF.p</option>
<option value="listing10.html">/UProcessUtils.p</option></select>
				</p>
				</form>
				<p><strong><a href="ProcDoggie.zip">Download Sample</a></strong> (&#147;ProcDoggie.zip&#148;, 94.4K)<BR>
<strong><a href="ProcDoggie.dmg">Download Sample</a></strong> (&#147;ProcDoggie.dmg&#148;, 163.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">{  File:    UGlobals.p  Contains:  This unit contains declarations and routines that didn't seem to fit into any        other unit in this application.  Written by: Forrest Tanaka    Copyright:  Copyright &copy; 1988-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/27/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        }UNIT UGlobals;{[j=20/57/1$] Pasmat Options}INTERFACE(******************************************************************************** Used Units*******************************************************************************)  USES    Dialogs    ;    (******************************************************************************** Constants*******************************************************************************)  CONST    rMemErrMessages        = 1000; {Resource ID of memory error message STR#}    kMemErrAppOpenMsg      = 1;    {Not enough memory to open application}    kMemErrProcListOpenMsg = 2;    {Not enough mem to open process list wind}    kMemErrLowMemWarnMsg   = 3;    {Free memory is low; proceed with caution}    kMemErrProcInfoOpenMsg = 4;    {Not enough mem to open process info wind}    rResErrMessages     = 1001; {Resource ID of resource error message STR#}    kResErrAppDamageMsg = 1;    {Application is damaged}    rMiscErrMessages   = 1002; {Resource ID of misc. error message STR#}    kMiscErrUnknownMsg = 1;    {Unknown error}    kMiscSystemTooSmall = 2;    {Unknown error}    rMiscWrnMessages     = 2000; {Resource ID of misc. warning message STR#}    kMiscWrnUncleanMsg   = 1;    {Application not 32-bit clean warning}    kMiscWrnLaunchMemMsg = 2;    {Not enough memory to launch}    kMiscWrnQuitSureMsg   = 3;    {Sure you want to Quit?}    kMaxSleepTime = 60; {Max WNE sleep time in ticks, 1 second in this case}(******************************************************************************** Global Variables*******************************************************************************)  VAR    gError:        Integer; {Generic application error code}    gQuitting:     Boolean; {TRUE if user chose Quit command}(******************************************************************************** DoQuit - Handle Quit command** This routine is called when this application should quit.  It's called* when the user chooses the Quit command from the file menu or when a 'quit'* AppleEvent is received.  It puts up a quit confirm dialog and returns noErr if* the user OKs the quit.*******************************************************************************)  FUNCTION DoQuit: OSErr;(******************************************************************************** HasColourQuickDraw - Returns true if we have Colour QuickDraw*******************************************************************************)  FUNCTION HasColourQuickDraw : Boolean;(******************************************************************************** ShowStopAlert - Show a stop alert** This routine puts up a standard stop alert with just an OK button and a* specified message.  messageClass specifies the STR# resource ID which contains* the message to display and messageIndex specifies the index (the first message* is index 1) into that STR# of the message to display.*******************************************************************************)  FUNCTION ShowStopAlert (messageClass: Integer;                          messageIndex: Integer; VAR itemHit: Integer): OSErr;(******************************************************************************** ShowCautionOKCancelAlert - Show a caution alert with an OK and Cancel button** This routine puts up a standard caution alert with just an OK button, a Cancel* button, and a specified message.  messageClass specifies the STR# resource ID* which contains the message to display and messageIndex specifies the index* (the first message is index 1) into that STR# of the message to display.*******************************************************************************)  FUNCTION ShowCautionOKCancelAlert (messageClass: Integer;                                     messageIndex: Integer; VAR itemHit: Integer): OSErr;(******************************************************************************** ShowCautionOKAlert - Show a caution alert with just an OK button** This routine puts up a standard caution alert with just an OK button and a* specified message.  messageClass specifies the STR# resource ID which contains* the message to display and messageIndex specifies the index (the first message* is index 1) into that STR# of the message to display.*******************************************************************************)  FUNCTION ShowCautionOKAlert (messageClass: Integer;                               messageIndex: Integer; VAR itemHit: Integer): OSErr;(******************************************************************************** ShowAboutBox - Show the About box** The About box for this application is displayed.  This is just a simple alert* box with an OK button.  The name of this application is displayed as is its* version number.*******************************************************************************)  PROCEDURE ShowAboutBox;(******************************************************************************** CreateWindow - Create a window** This routine creates a window using the WIND resource template with a resource* ID of windowTmplID in front of all existing windows.  A pointer to this window* is returned.  If we're running on a Color QuickDraw machine, the window is* created as a color window.  This window must be disposed of by calling* CloseWindow followed by DisposePtr on the window's WindowRecord.  The window* shouldn't be closed using DisposeWindow.  When this routine returns, the new* window is the current GrafPort.** The window isn't explicitly repositioned from its position as defined by the* resource definition.  Instead, I use the window-positioning utilities.  This* isn't documented at this time and it isn't even certain the these utilities* will be implemented in the final release of system software 7.0.  Use ResEdit* 2.1's WIND editor to control the window-positioning utilities.** If there isn't enough memory for the window, then gError global is set to* memFullErr.  If the WIND resource couldn't be loaded, gError is set to* resNotFound.  If anything else went wrong while creating the window, then* gError is set to dsSysErr.*******************************************************************************)  FUNCTION CreateWindow (windowTmplID: Integer): WindowPtr;(******************************************************************************** CreateDialog - Create a dialog window** This routine creates a dialog window using the WIND resource template with a* resource ID of windowTmplID in front of all existing windows.  A pointer to* this window is returned.  If we're running on a Color QuickDraw machine, the* window is created as a color window.  This window must be disposed of by* calling CloseWindow followed by DisposePtr on the window's DialogRecord.  The* window shouldn't be closed using DisposeWindow.  When this routine returns,* the new dialog is the current GrafPort.** The window isn't explicitly repositioned from its position as defined by the* resource definition.  Instead, I use the window-positioning utilities.  This* isn't documented at this time and it isn't even certain the these utilities* will be implemented in the final release of system software 7.0.  Use ResEdit* 2.1's WIND editor to control the window-positioning utilities.** If there isn't enough memory for the window, then gError global is set to* memFullErr.  If the WIND resource couldn't be loaded, gError is set to* resNotFound.  If anything else went wrong while creating the window, then* gError is set to dsSysErr.*******************************************************************************)  FUNCTION CreateDialog (dialogTmplID: Integer): DialogPtr;(******************************************************************************** InitGlobals - Initialise this module*******************************************************************************)  PROCEDURE InitGlobals;IMPLEMENTATION  USES    Notification    ,Resources    ,TextUtils    ,GestaltEqu    ,AppleEvents        ,UEmergMem    ,UEvents    ;(******************************************************************************** Constants*******************************************************************************)  CONST    rOKAlertID       = 6010; {Resource ID of alert with OK button}    rOKCancelAlertID = 6011; {Resource ID of alert with OK and Cancel buttons}    rIconSuiteID   = 128; {Resource ID of application icon suite}    rAppNameString = 0;   {Resource ID of application name}    rAboutAlert    = 258; {Resource ID of About alert}(******************************************************************************** Variables*******************************************************************************)  VAR    gNotifyAlertIdleUPP: AEIdleUPP;  VAR    gNotification: NMRec; {Notification record}{$S Main}(******************************************************************************** Public: DoQuit** The gQuitting global variable is set to TRUE.  This causes the main event loop* to terminate on the next iteration.*******************************************************************************)  FUNCTION DoQuit: OSErr;    VAR      error: OSErr;      itemHit: Integer;  BEGIN    error := ShowCautionOKCancelAlert (rMiscWrnMessages, kMiscWrnQuitSureMsg, itemHit);    IF error = noErr THEN      if itemHit = ok THEN        gQuitting := TRUE      ELSE        error := userCanceledErr;    DoQuit := error;  END;{$S Main}(******************************************************************************** HasColourQuickDraw** Returns true if we have Colour QuickDraw.  Note we do not use * gestaltQuickdrawFeatures -&gt; gestaltHasColor because that bit is set* on a 68000 machine running System 7.*******************************************************************************)  FUNCTION HasColourQuickDraw : Boolean;    VAR      qdVersion : LongInt;  BEGIN    HasColourQuickDraw := ( ( Gestalt (gestaltQuickdrawVersion, (*&lt;*)qdVersion) = noErr) &amp;        (qdVersion &gt; gestaltOriginalQD) );  END;{$S Main}(******************************************************************************** Private: NotifyAlert - Present a notification for an alert** This routine is called to present a notification to the user in the form of a* flashing icon in the application menu whenever an alert from this program is* displayed and the application is in the background.  We do this by calling* AEInteractWithUser, which is very useful utility routine provided by the* AppleEvent Manager for this very purpose.*******************************************************************************)  FUNCTION NotifyAlertIdleProc(VAR theEvent: EventRecord; VAR sleepTime: LONGINT; VAR mouseRgn: RgnHandle): BOOLEAN;  BEGIN    {$unused sleepTime}    {$unused mouseRgn}    CASE theEvent.what OF      updateEvt,         activateEvt,         osEvt:        BEGIN          DoEvent(theEvent);        END;      OTHERWISE        (* do nothing *)    END;    NotifyAlertIdleProc := FALSE;    (* Continue waiting. *)  END;  FUNCTION NotifyAlert : OSErr;    VAR      iconSuite: Handle;      {Handle to the icon suite}      error:     OSErr;  BEGIN    (* If this application isn't in front, post a notification *)    (* Get the small icon for this application *)    iconSuite := Get1Resource ('SICN', rIconSuiteID);    WITH gNotification DO      BEGIN        (*WITH*)qType := ORD (nmtype);        (*WITH*)nmMark := 1;        (*WITH*)nmIcon := iconSuite;        (*WITH*)nmSound := Handle(-1);        (*WITH*)nmStr := NIL;        (*WITH*)nmResp := NIL;        (*WITH*)nmRefCon := 0      END;    error := AEInteractWithUser(kAEDefaultTimeout, @gNotification, gNotifyAlertIdleUPP);    IF error = noErr THEN      InitCursor;    NotifyAlert := error;  END;{$S Main}(******************************************************************************** Public: ShowStopAlert** NotifyAlert is called to present a notification to the user in case this* application is in the background at the time of the alert.  This routine then* removes the notification after StopAlert is called.*******************************************************************************)  FUNCTION ShowStopAlert (messageClass: Integer;                          messageIndex: Integer; VAR itemHit: Integer): OSErr;    VAR      aMessage: Str255; {Contents of message to place in alert}      error: OSErr;        BEGIN    (* Put the specified message into the dialog parameter text *)    GetIndString ((*&lt;*)aMessage, messageClass, messageIndex);    ParamText (aMessage, '', '', '');    (* Show the stop alert *)    error := NotifyAlert;    IF error = noErr THEN      itemHit := StopAlert (rOKAlertID, NIL);            ShowStopAlert := error;  END;{$S Main}(******************************************************************************** Public: ShowCautionOKCancelAlert** NotifyAlert is called to present a notification to the user in case this* application is in the background at the time of the alert.  This routine then* removes the notification after ShowCautionOKCancelAlert is called.*******************************************************************************)  FUNCTION ShowCautionOKCancelAlert (messageClass: Integer;                                     messageIndex: Integer; VAR itemHit: Integer): OSErr;    VAR      aMessage: Str255; {Contents of message to place in alert}      error: OSErr;  BEGIN    (* Put the specified message into the dialog parameter text *)    GetIndString ((*&lt;*)aMessage, messageClass, messageIndex);    ParamText (aMessage, '', '', '');    (* Show the stop alert *)    error := NotifyAlert;    IF error = noErr THEN      itemHit := CautionAlert (rOKCancelAlertID, NIL);    ShowCautionOKCancelAlert := error;  END;{$S Main}(******************************************************************************** Public: ShowCautionOKAlert** NotifyAlert is called to present a notification to the user in case this* application is in the background at the time of the alert.  This routine then* removes the notification after ShowCautionOKAlert is called.*******************************************************************************)  FUNCTION ShowCautionOKAlert (messageClass: Integer;                               messageIndex: Integer; VAR itemHit: Integer): OSErr;    VAR      aMessage: Str255; {Contents of message to place in alert}      error:    OSErr;  BEGIN    (* Put the specified message into the dialog parameter text *)    GetIndString ((*&lt;*)aMessage, messageClass, messageIndex);    ParamText (aMessage, '', '', '');    (* Show the stop alert *)    error := NotifyAlert;    IF error = noErr THEN      itemHit := CautionAlert (rOKAlertID, NIL);        ShowCautionOKAlert := error;  END;{$S Main}(******************************************************************************** Public: ShowAboutBox** The name and the version number of this application are retrieved from* resources.  They're then displayed in the About box using the ParamText* mechanism.*******************************************************************************)  PROCEDURE ShowAboutBox;    VAR      appNameRes: StringHandle; {Handle to name of application}      curVersion: VersRecHndl;  {Handle to version record of this app}      appName:    Str255;       {Name of this application}      verNum:     Str255;       {Long version number of this application}      itemHit:    Integer;      {Item number of clicked alert item; ignored}  BEGIN    (* Get the name of this application *)    appNameRes := GetString (rAppNameString);    IF appNameRes &lt;&gt; NIL THEN      appName := appNameRes^^    ELSE      appName := '?';    (* Get the version information of this application *)    curVersion := VersRecHndl (Get1Resource ('vers', 1));    IF curVersion &lt;&gt; NIL THEN      (* Get the long version number *)      verNum := StringPtr(ORD(@curVersion^^.shortVersion) +          ORD(curVersion^^.shortVersion[0]) + 1)^    ELSE      verNum := '?';    (* Show the About alert *)    ParamText(appName, verNum, '', '');    itemHit := Alert (rAboutAlert, NIL);  END;{$S Main}(******************************************************************************** Public: CreateWindow** A WindowRecord is allocated on the heap before GetNewWindow is called.  This* is done to reduce heap fragmentation.*******************************************************************************)  FUNCTION CreateWindow (windowTmplID: Integer): WindowPtr;    VAR      windStore: Ptr;       {Pointer to window record}      aWindow:   WindowPtr; {Pointer to the new window}    PROCEDURE RecoverError (error: Integer);    BEGIN      IF aWindow &lt;&gt; NIL THEN        CloseWindow (aWindow);      IF windStore &lt;&gt; NIL THEN        DisposePtr (windStore);      gError := error;      CreateWindow := NIL;      EXIT (CreateWindow)    END;  BEGIN    windStore := NIL;    aWindow := NIL;    (* Allocate window record *)    windStore := NewPtrMargin (SIZEOF (WindowRecord), kAllocApp,        NOT kAllocClr);    (* Create the new window *)    IF windStore = NIL THEN      RecoverError (memFullErr)    ELSE      BEGIN        (* Create the new window *)        IF NOT HasColourQuickDraw THEN          aWindow := GetNewWindow (windowTmplID, windStore, WindowPtr(-1))        ELSE          aWindow := GetNewCWindow (windowTmplID, windStore,               WindowPtr(-1));        IF FailLowMemory (0) THEN          RecoverError (memFullErr)        ELSE IF ResError &lt;&gt; noErr THEN          IF ResError = memFullErr THEN            RecoverError (memFullErr)          ELSE IF (ResError = noErr) | (ResError = resNotFound) THEN            RecoverError (resNotFound)          ELSE            RecoverError (dsSysErr);        SetPort (aWindow);        SetWRefCon (aWindow, 0)      END;    CreateWindow := aWindow  END;{$S Main}(******************************************************************************** Public: CreateDialog** A DialogRecord is allocated on the heap before GetNewWindow is called.  This* is done to reduce heap fragmentation.*******************************************************************************)  FUNCTION CreateDialog (dialogTmplID: Integer): DialogPtr;    VAR      dlogStore: Ptr;       {Pointer to dialog record}      aDialog:   DialogPtr; {Pointer to the new dialog window}    PROCEDURE RecoverError (error: Integer);    BEGIN      IF aDialog &lt;&gt; NIL THEN        CloseWindow (aDialog);      IF dlogStore &lt;&gt; NIL THEN        DisposePtr (dlogStore);      gError := error;      CreateDialog := NIL;      EXIT (CreateDialog)    END;  BEGIN    dlogStore := NIL;    aDialog := NIL;    (* Allocate window record *)    dlogStore := NewPtrMargin (SizeOf (DialogRecord), kAllocApp,        NOT kAllocClr);    (* Create the new window *)    IF dlogStore = NIL THEN      RecoverError (memFullErr)    ELSE      BEGIN        IF NOT HasColourQuickDraw THEN          aDialog := GetNewWindow (dialogTmplID, dlogStore, WindowPtr(-1))        ELSE          aDialog := GetNewCWindow (dialogTmplID, dlogStore,              WindowPtr(-1));        IF FailLowMemory (0) THEN          RecoverError (memFullErr)        ELSE IF ResError &lt;&gt; noErr THEN          IF ResError = memFullErr THEN            RecoverError (memFullErr)          ELSE IF (ResError = noErr) | (ResError = resNotFound) THEN            RecoverError (resNotFound)          ELSE            RecoverError (dsSysErr);        SetPort (aDialog);        SetWRefCon (aDialog, 0)      END;    CreateDialog := aDialog  END;{$S Startup}(******************************************************************************** Public: InitGlobals*******************************************************************************)  PROCEDURE InitGlobals;  BEGIN    gNotifyAlertIdleUPP := NewAEIdleProc(@NotifyAlertIdleProc);  END;END.</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ProcDoggie/listing6.html%3Fid%3DDTS10000315-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ProcDoggie/listing6.html%3Fid%3DDTS10000315-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ProcDoggie/listing6.html%3Fid%3DDTS10000315-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>