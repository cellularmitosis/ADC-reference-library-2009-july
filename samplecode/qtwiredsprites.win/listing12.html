<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>qtwiredsprites.win - /Common Files/SpriteUtilities.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxWiredMoviesandSprites-date.html">Wired Movies and Sprites</a> &gt; <A HREF="javascript:location.replace('index.html');">qtwiredsprites.win</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">qtwiredsprites.win</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Common Files/SpriteUtilities.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Application Files/ComApplication.c</option>
<option value="listing2.html">/Application Files/ComApplication.h</option>
<option value="listing3.html">/Application Files/ComResource.h</option>
<option value="listing4.html">/Common Files/ComFramework.c</option>
<option value="listing5.html">/Common Files/ComFramework.h</option>
<option value="listing6.html">/Common Files/EndianUtilities.c</option>
<option value="listing7.html">/Common Files/EndianUtilities.h</option>
<option value="listing8.html">/Common Files/ImageCompressionUtilities.c</option>
<option value="listing9.html">/Common Files/ImageCompressionUtilities.h</option>
<option value="listing10.html">/Common Files/QTUtilities.c</option>
<option value="listing11.html">/Common Files/QTUtilities.h</option>
<option value="listing12.html">/Common Files/SpriteUtilities.c</option>
<option value="listing13.html">/Common Files/SpriteUtilities.h</option>
<option value="listing14.html">/Common Files/WinFramework.c</option>
<option value="listing15.html">/Common Files/WinFramework.h</option>
<option value="listing16.html">/Common Files/WinPrefix.h</option>
<option value="listing17.html">/QTWiredSprites.c</option>
<option value="listing18.html">/QTWiredSprites.h</option>
<option value="listing19.html">/QTWiredSprites.r</option>
<option value="listing20.html">/README.txt</option>
<option value="listing21.html">/WiredSpriteUtilities.c</option>
<option value="listing22.html">/WiredSpriteUtilities.h</option></select>
				</p>
				</form>
				<p><strong><a href="qtwiredsprites.win.zip">Download Sample</a></strong> (&#147;qtwiredsprites.win.zip&#148;, 328.5K)<BR>
<strong><a href="qtwiredsprites.win.dmg">Download Sample</a></strong> (&#147;qtwiredsprites.win.dmg&#148;, 699.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//////////
//
//  File:    SpriteUtilities.c
//
//  Contains:  Utilities for adding sprite tracks to QuickTime movies.
//
//  Written by:  Sean Allen
//  Revised by:  Chris Flick and Tim Monroe
//
//  Copyright:  &copy; 1997-1998 by Apple Computer, Inc., all rights reserved.
//
//  Change History (most recent first):
//
//     &lt;5&gt;     06/11/01  rtm    fixed bug in SpriteUtils_AddCompressedSpriteSampleToMedia (don't flip decompressorType)
//     &lt;4&gt;     11/10/00  rtm    general clean-up to bring this file into conformance with style of other
//                  sample code
//     &lt;3&gt;     03/27/98  rtm    added error checking to AddPICTImageToKeyFrameSample to prevent crashes
//                  if PICT resources not found
//     &lt;2&gt;     03/27/98  cf    further fixes for Windows compiles
//     &lt;1&gt;     03/26/98  rtm    made fixes for Windows compiles
//     
//
//////////

#ifndef _SPRITEUTILITIES_
#include &quot;SpriteUtilities.h&quot;
#endif


//////////
//
// SpriteUtils_SetSpriteData
// Set sprite properties for non-NULL parameters, overriding or adding atoms as necessary.
//
// Keep in mind that all data in an atom container must be in big-endian format.
//
//////////

OSErr SpriteUtils_SetSpriteData (QTAtomContainer theSprite, Point *theLocation, short *theVisible, short *theLayer, short *theImageIndex, ModifierTrackGraphicsModeRecord *theGraphicsMode, StringPtr theSpriteName, QTAtomContainer theActionAtoms)
{
  QTAtom        myPropertyAtom;
  OSErr        myErr = noErr;
  
  if (theSprite == NULL)
    return(paramErr);
    
  // set the sprite location data
  if (theLocation != NULL) {
    MatrixRecord  myMatrix;
    
    SetIdentityMatrix(&amp;myMatrix);
    myMatrix.matrix[2][0] = ((long)theLocation-&gt;h &lt;&lt; 16);
    myMatrix.matrix[2][1] = ((long)theLocation-&gt;v &lt;&lt; 16);
    EndianUtils_MatrixRecord_NtoB(&amp;myMatrix);

    myPropertyAtom = QTFindChildByIndex(theSprite, kParentAtomIsContainer, kSpritePropertyMatrix, 1, NULL);
    if (myPropertyAtom == 0)
      myErr = QTInsertChild(theSprite, kParentAtomIsContainer, kSpritePropertyMatrix, 1, 0, sizeof(MatrixRecord), &amp;myMatrix, NULL);
    else
      myErr = QTSetAtomData(theSprite, myPropertyAtom, sizeof(MatrixRecord), &amp;myMatrix);
      
    if (myErr != noErr)
      goto bail;
  }
  
  // set the sprite visibility state
  if (theVisible != NULL) {
    short       myVisible = *theVisible;
    
    myVisible = EndianS16_NtoB(myVisible);
    
    myPropertyAtom = QTFindChildByIndex(theSprite, kParentAtomIsContainer, kSpritePropertyVisible, 1, NULL);
    if (myPropertyAtom == 0)
      myErr = QTInsertChild(theSprite, kParentAtomIsContainer, kSpritePropertyVisible, 1, 0, sizeof(short), &amp;myVisible, NULL);
    else
      myErr = QTSetAtomData(theSprite, myPropertyAtom, sizeof(short), &amp;myVisible);
      
    if (myErr != noErr)
      goto bail;
  }
  
  // set the sprite layer
  if (theLayer != NULL) {
    short       myLayer = *theLayer;
    
    myLayer = EndianS16_NtoB(myLayer);

    myPropertyAtom = QTFindChildByIndex(theSprite, 0, kSpritePropertyLayer, 1, NULL);
    if (myPropertyAtom == 0)
      myErr = QTInsertChild(theSprite, 0, kSpritePropertyLayer, 1, 0, sizeof(short), &amp;myLayer, NULL);
    else
      myErr = QTSetAtomData(theSprite, myPropertyAtom, sizeof(short), &amp;myLayer);
      
    if (myErr != noErr)
      goto bail;
  }
  
  // set the sprite image index
  if (theImageIndex != NULL) {
    short       myImageIndex = *theImageIndex;

    myImageIndex = EndianS16_NtoB(myImageIndex);
    
    myPropertyAtom = QTFindChildByIndex(theSprite, kParentAtomIsContainer, kSpritePropertyImageIndex, 1, NULL);
    if (myPropertyAtom == 0)
      myErr = QTInsertChild(theSprite, kParentAtomIsContainer, kSpritePropertyImageIndex, 1, 0, sizeof(short), &amp;myImageIndex, NULL);
    else
      myErr = QTSetAtomData(theSprite, myPropertyAtom, sizeof(short), &amp;myImageIndex);
      
    if (myErr != noErr)
      goto bail;
  }
  
  // set the sprite graphics mode
  if (theGraphicsMode != NULL) {
    ModifierTrackGraphicsModeRecord    myGraphicsMode;
    
    myGraphicsMode.graphicsMode = EndianU32_NtoB(theGraphicsMode-&gt;graphicsMode);
    myGraphicsMode.opColor.red = EndianU16_NtoB(theGraphicsMode-&gt;opColor.red);
    myGraphicsMode.opColor.green = EndianU16_NtoB(theGraphicsMode-&gt;opColor.green);
    myGraphicsMode.opColor.blue = EndianU16_NtoB(theGraphicsMode-&gt;opColor.blue);

    myPropertyAtom = QTFindChildByIndex(theSprite, kParentAtomIsContainer, kSpritePropertyGraphicsMode, 1, NULL);
    if (myPropertyAtom == 0)
      myErr = QTInsertChild(theSprite, kParentAtomIsContainer, kSpritePropertyGraphicsMode, 1, 0, sizeof(myGraphicsMode), &amp;myGraphicsMode, NULL);
    else
      myErr = QTSetAtomData(theSprite, myPropertyAtom, sizeof(myGraphicsMode), &amp;myGraphicsMode);
      
    if (myErr != noErr)
      goto bail;
  }
  
  // set the sprite name
  if (theSpriteName != NULL) {
    QTAtom     mySpriteNameAtom;
    
    mySpriteNameAtom = QTFindChildByIndex(theSprite, kParentAtomIsContainer, kSpriteNameAtomType, 1, NULL);
    if (mySpriteNameAtom == 0)
      myErr = QTInsertChild(theSprite, kParentAtomIsContainer, kSpriteNameAtomType, 1, 0, theSpriteName[0] + 1, theSpriteName, NULL);
    else
      myErr = QTSetAtomData(theSprite, mySpriteNameAtom, theSpriteName[0] + 1, theSpriteName);

    if (myErr != noErr)
      goto bail;
  }
  
  // set the action atoms
  if (theActionAtoms != NULL)
    myErr = QTInsertChildren(theSprite, kParentAtomIsContainer, theActionAtoms);
  
bail:
  if ((myErr != noErr) &amp;&amp; (theSprite != NULL))
    QTRemoveChildren(theSprite, 0);

  return(myErr);
}


//////////
//
// SpriteUtils_AddSpriteToSample
// Add a sprite to a sample.
//
//////////

OSErr SpriteUtils_AddSpriteToSample (QTAtomContainer theSample, QTAtomContainer theSprite, QTAtomID theSpriteID)
{
  QTAtom        mySpriteAtom = 0;
  OSErr        myErr = paramErr;
  
  // see if the sample already contains a sprite atom of the specified ID
  mySpriteAtom = QTFindChildByID(theSample, kParentAtomIsContainer, kSpriteAtomType, theSpriteID, NULL);
  if (mySpriteAtom != 0)
    goto bail;
  
  // here, the index 0 means to append the sprite to the sample
  myErr = QTInsertChild(theSample, kParentAtomIsContainer, kSpriteAtomType, theSpriteID, 0, 0, NULL, &amp;mySpriteAtom);
  if (myErr != noErr)
    goto bail;

  myErr = QTInsertChildren(theSample, mySpriteAtom, theSprite);
  
bail:
  return(myErr);
}


//////////
//
// SpriteUtils_AddSpriteSampleToMedia
// Add a sprite sample to a sprite track's media.
//
//////////

OSErr SpriteUtils_AddSpriteSampleToMedia (Media theMedia, QTAtomContainer theSample, TimeValue theDuration, Boolean isKeyFrame, TimeValue *theSampleTime)
{
  SampleDescriptionHandle   mySampleDesc = NULL;
  OSErr            myErr = noErr;
  
  mySampleDesc = (SampleDescriptionHandle)NewHandleClear(sizeof(SpriteDescription));
  if (mySampleDesc == NULL) {
    myErr = MemError();
    goto bail;
  }
  
  myErr = AddMediaSample(theMedia,
              (Handle)theSample,
              0,
              GetHandleSize(theSample),
              theDuration,
              mySampleDesc,
              1,
              (short)(isKeyFrame ? 0 : mediaSampleNotSync),
              theSampleTime);
              
bail:
  if (mySampleDesc != NULL)
    DisposeHandle((Handle) mySampleDesc);
  return(myErr);
}


//////////
//
// SpriteUtils_AddCompressedSpriteSampleToMedia
// Add a compressed sprite sample to a sprite track's media.
//
//////////

OSErr SpriteUtils_AddCompressedSpriteSampleToMedia (Media theMedia, QTAtomContainer theSample, TimeValue theDuration, Boolean isKeyFrame, OSType theDataCompressorType, TimeValue *theSampleTime)
{
  SpriteDescriptionHandle    mySampleDesc = NULL;
  Handle            myCompressedSample = NULL;
  ComponentInstance      myComponent = NULL;
  OSErr            myErr = noErr;
  
  myErr = OpenADefaultComponent(DataCompressorComponentType, theDataCompressorType, &amp;myComponent);
  if (myErr != noErr)
    goto bail;

  mySampleDesc = (SpriteDescriptionHandle)NewHandleClear(sizeof(SpriteDescription));
  if (mySampleDesc == NULL) {
    myErr = MemError();
    goto bail;
  }
  
  if (myComponent != NULL) {
    UInt32          myCompressBufferSize, myActualCompressedSize, myDecompressSlop = 0;
    UInt32          myUncompressedSize;
    SignedByte         mySaveState = HGetState(theSample);
    
    myErr = (OSErr)DataCodecGetCompressBufferSize(myComponent, GetHandleSize(theSample), &amp;myCompressBufferSize);
    if (myErr != noErr)
      goto bail;
    
    myCompressedSample = NewHandle(sizeof(UInt32) + myCompressBufferSize);
    myErr = MemError();
    if (myErr != noErr)
      goto bail;
    
    HLockHi(theSample);
    HLockHi(myCompressedSample);
    myErr = (OSErr)DataCodecCompress(myComponent, 
                    *theSample, 
                    GetHandleSize(theSample), 
                    *myCompressedSample + sizeof(UInt32),     // room for size at beginning
                    myCompressBufferSize, 
                    &amp;myActualCompressedSize,
                    &amp;myDecompressSlop);
    
    HSetState(theSample, mySaveState);
    HUnlock(myCompressedSample);
    
    if (myErr != noErr)
      goto bail;
    
    SetHandleSize(myCompressedSample, sizeof(UInt32) + myActualCompressedSize);
    myErr = MemError();
    if (myErr != noErr)
      goto bail;

    (**mySampleDesc).decompressorType = theDataCompressorType;
  
    myUncompressedSize = GetHandleSize(theSample);
    (*(UInt32*) *myCompressedSample) = EndianU32_NtoB(myUncompressedSize);    // add uncompressed size at beginning
    
    myErr = AddMediaSample(theMedia,
                (Handle)myCompressedSample,
                0,
                GetHandleSize(myCompressedSample),
                theDuration,
                (SampleDescriptionHandle)mySampleDesc,
                1,
                (short)(isKeyFrame ? 0 : mediaSampleNotSync),
                theSampleTime);
  } else {
    myErr = AddMediaSample(theMedia,
                (Handle)theSample,
                0,
                GetHandleSize(theSample),
                theDuration,
                (SampleDescriptionHandle)mySampleDesc,
                1,
                (short)(isKeyFrame ? 0 : mediaSampleNotSync),
                theSampleTime);
  }
  
bail:
  if (myCompressedSample != NULL)
    DisposeHandle(myCompressedSample);
    
  if (mySampleDesc != NULL)
    DisposeHandle((Handle)mySampleDesc);
    
  if (myComponent != NULL)
    CloseComponent(myComponent);
  
  return(myErr);
}


//////////
//
// SpriteUtils_AddPICTImageToKeyFrameSample
// Compress a PICT with the animation compressor and add the image data to a sprite key sample's images container atom.
//
//////////

OSErr SpriteUtils_AddPICTImageToKeyFrameSample (QTAtomContainer theKeySample, short thePictID, RGBColor *theKeyColor, QTAtomID theID, FixedPoint *theRegistrationPoint, StringPtr theImageName)
{
  PicHandle        myPicture = NULL;
  Handle          myCompressedPicture = NULL;
  ImageDescriptionHandle  myImageDesc = NULL;
  OSErr          myErr = noErr;
  
  // get picture from resource
  myPicture = (PicHandle)GetPicture(thePictID);
  if (myPicture == NULL)
    myErr = resNotFound;

  if (myErr != noErr)
    goto bail;
  
  DetachResource((Handle)myPicture);
  
  // convert it to image data compressed by the animation compressor
  myErr = ICUtils_RecompressPictureWithTransparency(myPicture, theKeyColor, NULL, &amp;myImageDesc, &amp;myCompressedPicture);
  if (myErr != noErr)
    goto bail;

  // add it to the key sample
  HLock(myCompressedPicture);
  myErr = SpriteUtils_AddCompressedImageToKeyFrameSample(theKeySample, myImageDesc, GetHandleSize(myCompressedPicture), *myCompressedPicture, theID, theRegistrationPoint, theImageName);
  
bail:
  if (myPicture != NULL)
    KillPicture(myPicture);
    
  if (myCompressedPicture != NULL)
    DisposeHandle(myCompressedPicture);
    
  if (myImageDesc != NULL)
    DisposeHandle((Handle)myImageDesc);
    
  return(myErr);
}


//////////
//
// SpriteUtils_AddCompressedImageToKeyFrameSample
// Add compressed image data to a sprite key sample's images container atom.
//
//////////

OSErr SpriteUtils_AddCompressedImageToKeyFrameSample (QTAtomContainer theKeySample, ImageDescriptionHandle theImageDesc, long theDataSize, Ptr theCompressedDataPtr, QTAtomID theImageID, FixedPoint *theRegistrationPoint, StringPtr theImageName)
{
  Handle            myImageData = NULL;
  QTAtom            myDefaultsAtom, myImagesContainerAtom, myImageAtom;
  ImageDescriptionHandle    myImageDesc = NULL;
  OSErr            myErr = noErr;

#if TARGET_RT_LITTLE_ENDIAN
  myImageDesc = (ImageDescriptionHandle)NewHandle(GetHandleSize((Handle)theImageDesc));
  BlockMoveData(*theImageDesc, *myImageDesc, GetHandleSize((Handle)theImageDesc));
  EndianUtils_ImageDescription_NtoB(myImageDesc);
#else
  myImageDesc = theImageDesc;      // already is big endian
#endif

  // append compressed picture data to myImageDesc to obtain sprite image data
  myImageData = NewHandle(0);
  myErr = MemError();
  if (myErr != noErr)
    goto bail;
  
  myErr = HandAndHand((Handle)myImageDesc, myImageData);
  if (myErr != noErr)
    goto bail;
  
  myErr = PtrAndHand(theCompressedDataPtr, myImageData, theDataSize);
  if (myErr != noErr)
    goto bail;
  
  myDefaultsAtom = QTFindChildByIndex(theKeySample, 0, kSpriteSharedDataAtomType, 1, NULL);
  if (myDefaultsAtom == 0) {
    myErr = QTInsertChild(theKeySample, kParentAtomIsContainer, kSpriteSharedDataAtomType, 1, 0, 0, NULL, &amp;myDefaultsAtom);
    if (myErr != noErr)
      goto bail;
  }
    
  myImagesContainerAtom = QTFindChildByIndex(theKeySample, myDefaultsAtom, kSpriteImagesContainerAtomType, 1, NULL);
  if (myImagesContainerAtom == 0) {
    myErr = QTInsertChild(theKeySample, myDefaultsAtom, kSpriteImagesContainerAtomType, 1, 0, 0, NULL, &amp;myImagesContainerAtom);
    if (myErr != noErr)
      goto bail;
  }

  myErr = QTInsertChild(theKeySample, myImagesContainerAtom, kSpriteImageAtomType, theImageID, 0, 0, NULL, &amp;myImageAtom);
  if (myErr != noErr)
    goto bail;

  HLock(myImageData);
  myErr = QTInsertChild(theKeySample, myImageAtom, kSpriteImageDataAtomType, 1, 0, GetHandleSize(myImageData), *myImageData, NULL);
  if (myErr != noErr)
    goto bail;
  HUnlock(myImageData);
  
  if (theRegistrationPoint != NULL) {
    FixedPoint       myRegistrationPoint;
    
    myRegistrationPoint.x = EndianS32_NtoB(theRegistrationPoint-&gt;x);
    myRegistrationPoint.y = EndianS32_NtoB(theRegistrationPoint-&gt;y);
    
    myErr = QTInsertChild(theKeySample, myImageAtom, kSpriteImageRegistrationAtomType, 1, 0, sizeof(myRegistrationPoint), &amp;myRegistrationPoint, NULL);
    if (myErr != noErr)
      goto bail;
  } else {
    FixedPoint       myRegistrationPoint = { 0, 0 };    // flipping {0,0} doesn't change anything so we don't flip
    
    myErr = QTInsertChild(theKeySample, myImageAtom, kSpriteImageRegistrationAtomType, 1, 0, sizeof(myRegistrationPoint), &amp;myRegistrationPoint, NULL);
    if (myErr != noErr)
      goto bail;
  }
  
  if (theImageName != NULL) {
    myErr = QTInsertChild(theKeySample, myImageAtom, kSpriteImageNameAtomType, 1, 0, theImageName[0], &amp;theImageName[1], NULL);
    if (myErr != noErr)
      goto bail;
  }

bail:
#if TARGET_RT_LITTLE_ENDIAN
  if (myImageDesc != NULL)
    DisposeHandle((Handle)myImageDesc);
#else
  // myImageDesc is still theImageDesc, so don't dispose of it
#endif

  if (myImageData != NULL)
    DisposeHandle(myImageData);
    
  return(myErr);
}


//////////
//
// SpriteUtils_AssignImageGroupIDsToKeyFrame
// Assign image group IDs to the images in a key frame sample.
//
//////////

OSErr SpriteUtils_AssignImageGroupIDsToKeyFrame (QTAtomContainer theKeySample)
{
  QTAtom            myDefaultsAtom, myImagesContainerAtom;
  ImageDescriptionHandle    myFirstImageDesc = NULL;
  ImageDescriptionHandle    mySecondImageDesc = NULL;
  short            myFirstIndex, mySecondIndex, myNumImages;
  CodecType          myFirstImageType, mySecondImageType;
  long            myGroupID = 0, myTestID;
  OSErr            myErr = noErr;
  
  myDefaultsAtom = QTFindChildByIndex(theKeySample, 0, kSpriteSharedDataAtomType, 1, NULL);
  if (myDefaultsAtom == 0)
    goto bail;
  
  myImagesContainerAtom = QTFindChildByIndex(theKeySample, myDefaultsAtom, kSpriteImagesContainerAtomType, 1, NULL);
  if (myImagesContainerAtom == 0)
    goto bail;
  
  myFirstImageDesc = (ImageDescriptionHandle)NewHandle(0);
  if (myFirstImageDesc == NULL) {
    myErr = memFullErr;
    goto bail; 
  }

  mySecondImageDesc = (ImageDescriptionHandle)NewHandle(0);
  if (mySecondImageDesc == NULL) {
    myErr = memFullErr;
    goto bail; 
  }

  myNumImages = QTCountChildrenOfType(theKeySample, myImagesContainerAtom, kSpriteImageAtomType);
  for (myFirstIndex = 1; myFirstIndex &lt;= myNumImages; myFirstIndex++) {
    myErr = SpriteUtils_SetImageGroupID(theKeySample, myImagesContainerAtom, myFirstIndex, 0);
    if (myErr != noErr)
      goto bail;
  }
  
  for (myFirstIndex = 1; myFirstIndex &lt;= (myNumImages - 1); myFirstIndex++) {
    myErr = SpriteUtils_GetImageGroupID(theKeySample, myImagesContainerAtom, myFirstIndex, &amp;myTestID);
    if (myErr != noErr)
      goto bail;
    
    if (myTestID == 0) {
      myGroupID++;
      myErr = SpriteUtils_SetImageGroupID(theKeySample, myImagesContainerAtom, myFirstIndex, myGroupID);
      if (myErr != noErr)
        goto bail;
      
      myErr = SpriteUtils_GetImageDescription(theKeySample, myImagesContainerAtom, myFirstIndex, myFirstImageDesc);
      myFirstImageType = (**myFirstImageDesc).cType;
      if (myErr != noErr)
        goto bail;

      for (mySecondIndex = (myFirstIndex + 1); mySecondIndex &lt;= myNumImages; mySecondIndex++) {
        myErr = SpriteUtils_GetImageGroupID(theKeySample, myImagesContainerAtom, mySecondIndex, &amp;myTestID);
        if (myErr != noErr)
          goto bail;
          
        if (myTestID == 0) {
          myErr = SpriteUtils_GetImageDescription(theKeySample, myImagesContainerAtom, mySecondIndex, mySecondImageDesc);
          if (myErr != noErr)
            goto bail;
          mySecondImageType = (**mySecondImageDesc).cType;
        
          if (myFirstImageType == mySecondImageType) {
            ImageSequence  mySeqID;
            Boolean      isEquivalent;
            
            myErr = DecompressSequenceBegin(&amp;mySeqID, myFirstImageDesc, NULL, NULL, NULL, NULL, ditherCopy, (RgnHandle)NULL,  0, codecNormalQuality, anyCodec);
            if (myErr != noErr)
              goto bail;
                   
            CDSequenceEquivalentImageDescription(mySeqID, mySecondImageDesc, &amp;isEquivalent);
            CDSequenceEnd(mySeqID);
            
            if (isEquivalent) {
              myErr = SpriteUtils_SetImageGroupID(theKeySample, myImagesContainerAtom, mySecondIndex, myGroupID);
              if (myErr != noErr)
                goto bail;
            }
          }
        }
      }
    }
  }
  
  // assign an ID to the last image
  myErr = SpriteUtils_GetImageGroupID(theKeySample, myImagesContainerAtom, myNumImages, &amp;myTestID);
  if (myErr != noErr)
    goto bail;
    
  if (myTestID == 0) {
    myGroupID++;
    myErr = SpriteUtils_SetImageGroupID(theKeySample, myImagesContainerAtom, myNumImages, myGroupID);
  }
  
bail:
  if (myFirstImageDesc != NULL)
    DisposeHandle((Handle)myFirstImageDesc);
    
  if (mySecondImageDesc != NULL)
    DisposeHandle((Handle)mySecondImageDesc);
    
  return(myErr);
}


//////////
//
// SpriteUtils_AssignImageGroupIDsToKeyFrame
// Assign image group IDs to the images in a key frame sample.
//
//////////

static OSErr SpriteUtils_GetImageDescription (QTAtomContainer theKeySample, QTAtom theImagesContainerAtom, short theImageIndex, ImageDescriptionHandle theImageDesc)
{
  QTAtom            myImageAtom, myImageDataAtom;
  UInt8            mySaveState;
  UInt32            mySize;
  OSErr            myErr = noErr;

  myImageAtom = QTFindChildByIndex(theKeySample, theImagesContainerAtom, kSpriteImageAtomType, theImageIndex, NULL);
  if (myImageAtom == 0)  { 
    myErr = cannotFindAtomErr; 
    goto bail;
  }

  myImageDataAtom = QTFindChildByIndex(theKeySample, myImageAtom, kSpriteImageDataAtomType, 1, NULL);
  if (myImageDataAtom == 0)  { 
    myErr = cannotFindAtomErr; 
    goto bail;
  }

  mySaveState = HGetState((Handle)theImageDesc);
  HUnlock((Handle)theImageDesc);

  // copy the data (ImageDescription followed by image data) to a handle
  myErr = QTCopyAtomDataToHandle(theKeySample, myImageDataAtom, (Handle)theImageDesc);
  if (myErr != noErr)
    goto bail;

  mySize = EndianU32_BtoN((**theImageDesc).idSize);

  // pull off anything following the image description (&amp; its color table, if any, and any image description extensions)
  SetHandleSize((Handle)theImageDesc, mySize);

#if TARGET_RT_LITTLE_ENDIAN
  EndianUtils_ImageDescription_BtoN(theImageDesc);
#endif

  HSetState((Handle)theImageDesc, mySaveState);
  myErr = MemError();
  
bail:
  return(myErr);
}


//////////
//
// SpriteUtils_SetImageGroupID
// Set the group ID of an image group.
//
//////////

static OSErr SpriteUtils_SetImageGroupID (QTAtomContainer theKeySample, QTAtom theImagesContainerAtom, short theImageIndex, long theGroupID)
{
  QTAtom      myImageAtom, myImageGroupAtom;
  OSErr      myErr = noErr;
  
  myImageAtom = QTFindChildByIndex(theKeySample, theImagesContainerAtom, kSpriteImageAtomType, theImageIndex, NULL);
  if (myImageAtom == 0)  { 
    myErr = cannotFindAtomErr;
    goto bail;
  }

  myImageGroupAtom = QTFindChildByIndex(theKeySample, myImageAtom, kSpriteImageGroupIDAtomType, 1, NULL);
  if (myImageGroupAtom == 0) {
    myErr = QTInsertChild(theKeySample, myImageAtom, kSpriteImageGroupIDAtomType, 1, 1, 0, NULL, &amp;myImageGroupAtom);
    if (myErr != noErr)
      goto bail;
  }

  theGroupID = EndianU32_NtoB(theGroupID);
  myErr = QTSetAtomData(theKeySample, myImageGroupAtom, sizeof(theGroupID), &amp;theGroupID);

bail:
  return(myErr);
}
 

//////////
//
// SpriteUtils_GetImageGroupID
// Get the group ID of an image group.
//
//////////

static OSErr SpriteUtils_GetImageGroupID (QTAtomContainer theKeySample, QTAtom theImagesContainerAtom, short theImageIndex, long *theGroupID)
{
  QTAtom      myImageAtom, myImageGroupAtom;
  OSErr      myErr = noErr;

  myImageAtom = QTFindChildByIndex(theKeySample, theImagesContainerAtom, kSpriteImageAtomType, theImageIndex, NULL);
  if (myImageAtom == 0)  { 
    myErr = cannotFindAtomErr;
    goto bail;
  }

  myImageGroupAtom = QTFindChildByIndex(theKeySample, myImageAtom, kSpriteImageGroupIDAtomType, 1, NULL);
  
  if (myImageGroupAtom == 0)
    *theGroupID = 0;
  else {
    myErr = QTCopyAtomDataToPtr(theKeySample, myImageGroupAtom, false, sizeof(*theGroupID), (Ptr)theGroupID, NULL);
    if (myErr != noErr)
      goto bail;

    *theGroupID = EndianU32_BtoN(*theGroupID);    // return native endian long
  }
  
bail:
  return(myErr);
}
 
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/qtwiredsprites.win/listing12.html%3Fid%3DDTS10001077-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/qtwiredsprites.win/listing12.html%3Fid%3DDTS10001077-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/qtwiredsprites.win/listing12.html%3Fid%3DDTS10001077-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>