<html><head><title></title></head>

<body bgcolor="#ffffff">

 

 

<h1>

<FONT COLOR="#000066">

<a name="45">

 <a name="//apple_ref/occ/cl/NSSerializer">NSSerializer</a>

</a>

</FONT>

</h1>

<p><B>Inherits From:</B><BR>  

 NSObject



<p><B>Conforms To:</B><BR>

 NSObject (NSObject)



<p><B>Declared In:	</B><BR>

 Foundation/NSSerialization.h



<p><a name="76"></a>

<a name="description"></a>

<H2>Class Description 

</H2>

The NSSerializer class provides a mechanism for creating an abstract representation of a property list. (In OpenStep, property lists are defined to be-and to contain-objects of these classes: NSDictionary, NSArray, NSString, NSData). The NSSerializer class stores this representation in an NSData object in an architecture-independent format, so that property lists can be used with distributed applications. NSSerializer's companion class NSDeserializer declares methods that take the abstract representation and recreate the property list in memory.<p>

In contrast to archiving (see the NSArchiver class specification), the serialization process preserves only structural information, not class information. Thus, if a property list is serialized and then deserialized, the objects in the resulting property list might not be of the same class as the objects in the original property list. However, the structure and interrelationships of the data in the resulting property list are identical to that in the original, with one possible exception.<p>

The exception is that when an object graph is serialized, the mutability of the containers objects (NSDictionary and NSArray objects) is preserved only down to the highest node in the graph that has an immutable container. Thus, if an NSArray contains an NSMutableDictionary, the serialized version of this object graph would not preserve the mutability of the dictionary or any of the mutable objects it contained. Since serialization doesn't preserve class information or-in some cases-mutability, coding (as implemented by NSCoder and NSArchiver) is the preferred way to make object graphs persistent.<p>

The NSSerializer class object provides the interface to the serialization process; you don't create instances of NSSerializer. You might subclass NSSerializer to modify the representation it creates, for example, to encrypt the data or add authentication information.<p>

Other types of data besides property lists can be serialized using methods declared by the NSData and NSMutableData classes (see <code>serializeDataAt:ofObjCType:context:</code> and <code>deserializeDataAt:ofObjCType:atCursor:context:</code>), allowing these types to be represented in an architecture-independent format. Furthermore, the NSObjCTypeSerializationCallBack protocol allows you to serialize and deserialize objects that aren't property lists.<p>

<HR WIDTH=50% ALIGN=LEFT>

<a name="82"></a>

<a name="clm"></a>

<h2>Class Methods</h2>  

 



<a name="83"></a>

<h3>

 <a name="//apple_ref/occ/clm/NSSerializer/serializePropertyList:">serializePropertyList:</a>

</h3>

+ (NSData *)<code>serializePropertyList:</code>(id)<em>aPropertyList</em> 

<P>Creates a data object, serializes <em>aPropertyList</em> into it, and returns the data object. <em>aPropertyList</em> must be a kind of NSData, NSString, NSArray, or NSDictionary.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="86"></a>

<h3> <a name="//apple_ref/occ/clm/NSSerializer/serializePropertyList:intoData:">serializePropertyList:intoData:</a></h3>

+ (void)<code>serializePropertyList:</code>(id)<em>aPropertyList</em> <code>intoData:</code>(NSMutableData *)<em>mdata</em> 

<P>Serializes the property list <em>aPropertyList</em> in the mutable data object<em> mdata . aPropertyList</em> must be a kind of NSData, NSString, NSArray, or NSDictionary.<p>



 

 





<i>Copyright &#169; 1997, Apple Computer, Inc.   All rights

reserved.</i>



<!-- Last updated: 06/17/97 16:52:28 -->



</body>

</html>

