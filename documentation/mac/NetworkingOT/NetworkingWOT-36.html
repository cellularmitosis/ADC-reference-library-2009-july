<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Using Mappers</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING36></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-35.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-37.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-10.html"><B>Part 1 - Open Transport Essentials</B></A><BR><DD><A HREF="NetworkingWOT-34.html"><B>Chapter 6 - Mappers</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING36-0></A>
<H1><A NAME=MARKER-9-33></A>Using Mappers</H1>
 <A NAME=MARKER-13-34></A>This section begins by describing how the general provider functions that govern a provider's mode of operation apply to mapper providers. It goes on to discuss information you need to know in order to use mapper functions: how you format names and addresses specified in parameters to mapper functions and how you handle processing when calling mapper functions asynchronously. This section concludes with a discussion of different techniques you can use when using the mapper to search for a name pattern.<P>
<A NAME=HEADING36-2></A>
<H2><A NAME=MARKER-9-35></A>Setting Modes of Operation for Mappers</H2>
 Like all Open Transport providers, mappers can use different modes of operation. A mapper can execute synchronously or asynchronously. You set the mapper's default mode of execution by using the appropriate function to open it; for example, you can create a mapper that executes asynchronously by calling the <CODE>OTAsyncOpenMapper</CODE> function. After opening the mapper, you can change its mode of execution by calling the <CODE>OTSetSynchronous</CODE> or <CODE>OTSetAsynchronous</CODE> functions. To determine how mapper functions execute, you call the <CODE>OTIsSynchronous</CODE> function. <P>
 Mappers use one asynchronous event and four completion events. <A HREF=#MARKER-9-1>Table 6-1</A> lists the <A NAME=MARKER-13-36></A>event codes that the mapper provider can pass to your application and explains the meaning of the <CODE>cookie</CODE> parameter to the notifier for each function. For more detailed information, see the descriptions of the mapper functions in <A HREF=NetworkingWOT-232.html#MARKER-9-37>"Functions"</A>.<P>
<B>Table 6-1  Completion events for asynchronous mapper functions </B>
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-1></A></CAPTION>
<TH>Completion code<TH>Meaning<TR>
<TD><CODE><A NAME=MARKER-13-1></A>T_OPENCOMPLETE</CODE><TD>The <CODE>OTAsyncOpenMapper</CODE> function has completed. The <CODE>cookie</CODE> parameter contains the mapper reference.<TR>
<TD><CODE><A NAME=MARKER-13-49></A>T_REGNAMECOMPLETE</CODE><TD>The <CODE>OTRegisterName</CODE> function has completed. The <CODE>cookie</CODE> parameter contains the <CODE>reply</CODE> parameter, unless it was <CODE>NULL</CODE>, in which case it contains the <CODE>request</CODE> parameter.<TR>
<TD><CODE><A NAME=MARKER-13-50></A>T_DELNAMECOMPLETE</CODE><TD>The <CODE>OTDeleteName</CODE> or the <CODE>OTDeleteNameByID</CODE> functions have completed. For the <CODE>OTDeleteName</CODE> function, the <CODE>cookie</CODE> parameter holds a pointer to the <CODE>name</CODE> parameter. For the <CODE>OTDeleteNameByID</CODE> function, the <CODE>cookie</CODE> parameter contains the <CODE>id</CODE> parameter.<TR>
<TD><CODE><A NAME=MARKER-13-52></A>T_LKUPNAMERESULT</CODE><TD>The <CODE>OTLookupName</CODE> function has returned a name, but it has not yet completed because there might be more names to retrieve. <TR>
<TD><CODE><A NAME=MARKER-13-51></A>T_LKUPNAMECOMPLETE&nbsp;&nbsp;</CODE><TD>The <CODE>OTLookupName</CODE> function has completed. The <CODE>cookie</CODE> parameter contains the <CODE>reply</CODE> parameter.</TABLE>
 <A NAME=MARKER-13-37></A><P>
 The only way to cancel an asynchronous mapper function is to call the <CODE>OTCloseProvider</CODE> function, passing the mapper reference for which the function was executed. The <CODE>OTCloseProvider</CODE> function is described in the chapter <A HREF=NetworkingWOT-23.html#MARKER-9-28>"Providers"</A> in this book.<P>
 By default, mappers do not block and do not acknowledge sends. You can change a mapper's blocking status by using the <CODE>OTSetBlocking</CODE> function. Mapper providers are not affected by their send-acknowledgment status. However, a mapper provider's blocking status might affect the behavior of mapper functions. For example, if a mapper is blocking, heavy network traffic might cause mapper functions to wait before sending or receiving data. If a mapper is nonblocking and you are doing a lot of name lookups, the <A NAME=MARKER-13-41></A><CODE>OTLookupName</CODE> function might return with the <CODE>kOTFlowErr</CODE> result. In this case, you can try executing the function later.<A NAME=MARKER-13-39></A><P>
<A NAME=HEADING36-7></A>
<H2>Specifying Name and Address Information </H2>
 Several mapper functions require that you specify a name or address. This might be a name to register or to look up. Specifying a name or address means that you have to create a buffer that contains the information and then create a <CODE>TNetbuf</CODE> structure that specifies the size and location of this buffer. The format that you use to store a name or an address is specific to the name-registration protocol that underlies the mapper and is exactly the same as the name and address formats that you can use to bind an endpoint. For information about name and address formats, please consult the documentation provided for the protocol you are using. <P>
 If the protocol supports it, you can specify a name pattern rather than a name when calling the <CODE>OTLookupName</CODE> function. Different protocols might use different wildcard characters to define name patterns. Please consult the documentation provided for your protocol to determine valid wildcard characters and how you use these to specify name patterns.<P>
<A NAME=HEADING36-10></A>
<H2><A NAME=MARKER-9-40></A>Searching for Names</H2>
 You use the <A NAME=MARKER-13-41></A><CODE>OTLookupName</CODE> function to search for a registered name or for a list of names if your protocol supports name pattern matching. You use the <CODE>req</CODE> parameter to specify the name or name pattern to search for. When the function returns, it uses the <CODE>reply</CODE> parameter to pass back the matching name or names.<A NAME=MARKER-13-42></A><P>
 The <CODE>req</CODE> parameter is a pointer to a <CODE>TLookupRequest</CODE> structure containing the name or name pattern to be found and additional information that the mapper can use in conducting the search. You use the <CODE>maxcnt</CODE> field to specify the number of names you expect to be returned. If you are looking for a specific name, set this field to 1. If you are looking for a name pattern, you can use this field to indicate the number of matches you expect the <CODE>OTLookupName</CODE> function to return. You use the <CODE>timeout</CODE> field to specify the amount of time (in milliseconds) available for this search. If a match is not found within the specified time, the function returns with the <A NAME=MARKER-15-14></A><CODE>kOTNoDataErr</CODE>. If the number you specify for the <CODE>maxcnt</CODE> field is larger than the number of names that match the given pattern, the mapper provider uses the value given in the <CODE>timeout</CODE> field to determine when to stop the search.<P>
 The <CODE>reply</CODE> parameter is a pointer to a <CODE>TLookupReply</CODE> structure that contains two fields. The <CODE>names</CODE> field describes the size and location of the buffer in which the replies are placed when the function returns; the <CODE>rspcount</CODE> field specifies the number of matching entries found. <A HREF=#MARKER-9-44>Figure 6-1</A> shows how the contents of a reply buffer containing two entries are stored. The section <A HREF=#MARKER-9-50>"Code Sample: Using OTLookupName"</A> provides and describes a sample program that uses the <CODE>OTLookupName</CODE> function. See especially, <A HREF=#MARKER-9-55>Listing 6-3</A>.<P>
<B>Figure 6-1  <A NAME=MARKER-9-44></A>Format of entries in <CODE>OTLookupName</CODE> reply buffer </B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/OTMA-L-01.gif"><P>
 The first two bytes of each entry specify the length of the address; the second two bytes specify the length of the name. The address is stored next and then the name, padded to a four byte boundary.<P>
<A NAME=HEADING36-17></A>
<H3><A NAME=MARKER-9-45></A>Retrieving Entries in Asynchronous Mode</H3>
 If you call the <A NAME=MARKER-13-46></A><CODE>OTLookupName</CODE> function asynchronously, you can use an alternate method for retrieving matching entries. In asynchronous mode, this function sends two event codes: it sends the <A NAME=MARKER-13-52></A><CODE>T_LKUPNAMERESULT</CODE> code each time it stores a name in the reply buffer, and it sends the <A NAME=MARKER-13-51></A><CODE>T_LKUPNAMECOMPLETE</CODE> code when it has stored the last name in the reply buffer--that is, when the function as a whole completes execution. Each time the <CODE>T_LKUPNAMERESULT</CODE> event is passed to your notification function, you can do the following:<P>
<OL>
<P><LI>Copy the name and address information from the reply buffer to some other location.<P>
<P><LI>From inside the notifier function, set the <CODE>reply-&gt;names.len</CODE> field or the <CODE>reply-&gt;rspcount</CODE> field to 0. <P>
When you set either of these fields to 0, Open Transport automatically sets the other field to 0. It's important, however, that you reset these values from within the notifier or the results might be unpredictable. You can also do it from code bracketed by the <CODE>OTEnterNotifier</CODE> and <CODE>OTLeaveNotifier</CODE> functions. For more information, see <A HREF=NetworkingWOT-120.html#MARKER-9-122>"OTEnterNotifier"</A>.<P>
<P><LI>Repeat the first two steps until the event passed to your notifier function is <CODE>T_LKUPNAMECOMPLETE</CODE>.<P>
</OL>
 This method saves you the trouble of guessing how large a reply buffer to allocate. It might also save you some memory if you are expecting many matches to be returned and are interested in only some of them.<A NAME=MARKER-13-49></A><P>
<DL>
<DT><B>Note</B>
<DD>The <CODE>T_LKUPNAMECOMPLETE</CODE> event might have stored a name in the buffer. Be sure to check for this possibility.  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING36-25></A>
<H3><A NAME=MARKER-9-50></A>Code Sample: Using OTLookupName</H3>
 This section discusses the program OTLookupNameTest, which demonstrates how you open an NBP mapper provider, issue an NBP lookup request, and print out the resulting information. <A HREF=#MARKER-9-51>Listing 6-1</A> shows the preprocessor directives and the main function of the program. <P>
<B>Listing 6-1  <A NAME=MARKER-9-51></A>The main function to OTLookupNameTest</B><P>
<PRE>
<A NAME=MARKER-0-95></A>#ifndef qDebug    /* variable set for OT debugging macros */
#define qDebug1
#endif

#include &lt;OpenTransport.h&gt;
#include &lt;OpenTptAppleTalk.h&gt;
#include &lt;OTDebug.h&gt; /* Need OTDebugBreak &amp; OTAssert macros */
#include &lt;stdio.h&gt;

/* OTDebugStr is not defined in OT header files, but it is
exported by the libraries, so we define the prototype here. */
extern pascal void OTDebugStr(const char* str);

static UInt32 gLastPrinted = 0; /* Global var to track printing */

void main(void)
{  OSStatus err;
   char     requestAddress[] = &quot;=:AFPServer@*&quot;;
   
   printf(&quot;Hello World!\n&quot;);

   err = InitOpenTransport();
   if (err == noErr) {
      err = LookupAndPrint(requestAddress);
      CloseOpenTransport();
   }
   if (err == noErr) {
      printf(&quot;Success.\n&quot;);
   } else {
      printf(&quot;Failed with error %d.\n&quot;, err);
   }
   printf(&quot;Done.  Press command-Q to Quit.\n&quot;);
}
</PRE>
 The main function initializes Open Transport, calls the user-defined function <CODE>LookupAndPrint</CODE> (passing a value for the requested address), and then closes Open Transport. <P>
 The <CODE>LookupAndPrint</CODE> function is the key function to the OTLookupNameTest program. However, because it calls Open Transport functions synchronously, it also uses a notifier to yield time to other processes. <A HREF=#MARKER-9-53>Listing 6-2</A> shows the notifier, which calls <CODE>printf</CODE> periodically in response to a <CODE>kOTSyncIdle</CODE> event. (The <CODE>printf</CODE> function calls <CODE>WaitNextEvent</CODE>, thus our synchronous calls to Open Transport will yield time to other processes. A real world application would probably use threads to do this.<P>
<B>Listing 6-2  <A NAME=MARKER-9-53></A>Notifier that yields time to other processes</B><P>
<PRE>
<A NAME=MARKER-0-95></A>static pascal void YieldingNotifier(EndpointRef ep, OTEventCode code, 
                              OTResult result, void* cookie)
{
   #pragma unused(ep)
   #pragma unused(result)
   #pragma unused(cookie)
   
   switch (code) {
      case kOTSyncIdleEvent:
         if (TickCount() &gt; gLastPrinted + 10) {
            printf(&quot;.&quot;);
            fflush(stdout);
            gLastPrinted = TickCount();
         }
         break;
      default:
         /* do nothing */
         break;
   }
}
</PRE>
 For more information on using threads to yield time, see <A HREF=NetworkingWOT-30.html#MARKER-9-22>"Using Synchronous Processing With Threads"</A>.<P>
 <A HREF=#MARKER-9-55>Listing 6-3</A> shows the <CODE>LookupAndPrint</CODE> function. This function takes one parameter, a pointer to an NBP address. This address must have the form<P>
 &lt;name&gt;:&lt;type&gt;@&lt;zone&gt;<P>
 The function begins by opening an NBP mapper provider and switching it into synchronous/blocking mode. It uses <CODE>kOTSyncIdle</CODE> events (and the notifier shown in <A HREF=#MARKER-9-53>Listing 6-2</A>) to yield time to other processes. Then it issues an NBP lookup request, using the <A HREF=NetworkingWOT-241.html#MARKER-9-54><CODE>OTLookUpName</CODE></A> function . When the request completes, the function calls the user-defined <CODE>PrintAddress</CODE> and <CODE>PrintName</CODE> functions to display the results.<P>
<B>Listing 6-3  <A NAME=MARKER-9-55></A>The LookupAndPrint function</B><P>
<PRE>
<A NAME=MARKER-0-95></A>static OSStatus LookupAndPrint(char *requestAddress)
{
   OSStatus    err;
   OSStatus    junk;
   MapperRef   nbpMapper;
   TLookupRequest lookupRequest;
   TLookupReply lookupReply;
   UInt8       *responseBuffer;
   TLookupBuffer*currentLookupReplyBuffer;
   UInt32       nameIndex;
   
   err = noErr;
   nbpMapper = kOTInvalidMapperRef; /* for error checking */
   
   /* Create the responseBuffer. */
   
   responseBuffer = OTAllocMem(kResponseBufferSize);
   if (responseBuffer == nil) 
      err = kENOMEMErr;
   
   /* Create an NBP mapper and set it to up for threaded processing. */
   
   if (err == noErr)
      nbpMapper = OTOpenMapper(OTCreateConfiguration(kNBPName),
                                       0, &amp;err);
   if (err == noErr) {
      junk = OTSetSynchronous(nbpMapper);
      OTAssert(&quot;LookupAndPrint: Could not set synchronous mode
                                 on mapper&quot;, junk == noErr);
      junk = OTSetBlocking(nbpMapper);
      OTAssert(&quot;LookupAndPrint: Could not set blocking mode 
                              on mapper&quot;, junk == noErr);
      junk = OTUseSyncIdleEvents(nbpMapper, true);
      OTAssert(&quot;LookupAndPrint: Could not enable sync idle events
                              on mapper&quot;, junk == noErr);
      junk = OTInstallNotifier(nbpMapper, YieldingNotifier, nil);
      OTAssert(&quot;LookupAndPrint: Could not install notifier
                              for mapper&quot;, junk == noErr);
   }
   
   /* Call OTLookupName synchronously. */
   
   if (err == noErr) {
      
      /* Set up the TLookupRequest structure. */

      OTMemzero(&amp;lookupRequest, sizeof(lookupRequest));
      lookupRequest.name.buf = (UInt8 *) requestAddress;
      lookupRequest.name.len = OTStrLength(requestAddress);
      lookupRequest.timeout = 1000;// 1 second in milliseconds
      lookupRequest.maxcnt = kResponseBufferSize /
                           kNBPEntityBufferSize;

      /* Set up the TLookupReply structure. */
      
      OTMemzero(&amp;lookupReply, sizeof(lookupReply));
      lookupReply.names.buf = responseBuffer;
      lookupReply.names.maxlen = kResponseBufferSize;
      
      /* Now do the lookup. */
      
      err = OTLookupName(nbpMapper, &amp;lookupRequest, &amp;lookupReply);
   }
   
   /* Print out the contents of the responseBuffer. */
   
   if (err == noErr) {
      printf(&quot;\n&quot;);
      
      /* Start by pointing to the beginning of the response buffer. */
      
      currentLookupReplyBuffer = (TLookupBuffer *) responseBuffer;
      
      /* For each response in the buffer... */
      
      for (nameIndex = 0; nameIndex &lt; lookupReply.rspcount;
                                 nameIndex++) {

      /*... print the name and address and... */
      
         printf(&quot;%3d &quot;, nameIndex);
         PrintAddress( (DDPAddress *)
                  &amp;currentLookupReplyBuffer-&gt;fAddressBuffer[0]);
         PrintName( (char *)&amp;currentLookupReplyBuffer-&gt;
                  fAddressBuffer[currentLookupReplyBuffer-&gt;
                                    fAddressLength], 
                     currentLookupReplyBuffer-&gt;fNameLength);
         printf(&quot;\n&quot;);
         
         /*... use OTNextLookupBuffer to get from the current
                                 buffer to the next. */
         
         currentLookupReplyBuffer =
               OTNextLookupBuffer(currentLookupReplyBuffer);
      }
   }
   
   /* Clean up. */
   
   if (responseBuffer != nil) {
      OTFreeMem(responseBuffer);
   }
   if (nbpMapper != kOTInvalidMapperRef) {
      junk = OTCloseProvider(nbpMapper);
      OTAssert(&quot;LookupAndPrint: Failed closing mapper&quot;, junk == noErr);
   }
   
   return err;
}
</PRE>
 The function <CODE>LookupAndPrint</CODE> calls two functions, PrintName and PrintAddress, to print names and addresses; <A HREF=#MARKER-9-57>Listing 6-4</A> shows the two functions.<P>
<B>Listing 6-4  <A NAME=MARKER-9-57></A>Printing names and addresses</B><P>
<PRE>
<A NAME=MARKER-0-95></A>static void PrintName(const char *name, UInt32 length)
{
   char nameForPrinting[256];
   
   OTMemzero(nameForPrinting, 256);
   OTMemcpy(nameForPrinting, name, length);

   printf(&quot;"%s"&quot;, nameForPrinting);
}
static void PrintAddress( DDPAddress *addr )
{
	OTAssert( &quot;PrintAddress: Expected a DDPNBPADdress&quot;,
						addr-&gt;fAddressType == AF_ATALK_DDP );
	printf(&quot;Net = $%04x, Node = $%02x, Socket = $%02x &quot;, 
				addr-&gt;fNetwork, 
				addr-&gt;fNodeID, 
				addr-&gt;fSocket);
}


</PRE>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="NetworkingWOT-36.html#HEADING36-2">Setting Modes of Operation for Mappers</A>
<DD>
<DT><A HREF="NetworkingWOT-36.html#HEADING36-7">Specifying Name and Address Information </A>
<DD>
<DT><A HREF="NetworkingWOT-36.html#HEADING36-10">Searching for Names</A>
<DD>
<DT><A HREF="NetworkingWOT-36.html#HEADING36-17">Retrieving Entries in Asynchronous Mode</A>
<DD>
<DT><A HREF="NetworkingWOT-36.html#HEADING36-25">Code Sample: Using OTLookupName</A>
<DD>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="NetworkingWOT-35.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-37.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
