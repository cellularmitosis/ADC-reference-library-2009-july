<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note QD21: Of Time and Space and _CopyBits</title><meta name="keywords" content="Mac OS 8 _CopyBits QuickDraw performance speed pixel alignment ctSeed"><meta name="Description" content="Technical Note QD21: This Technical Note describes the variousfactors that can influence the speed of _CopyBits so thatdevelopers can set up conditions to achieve the best performancefor the particular situation. This Note talks about everyfactor that affects the speed of _CopyBits, and tries togive real-life examples showing the effect of each factor.Factors include: Dimensions of the Copied Area; Shape andSize of the Clip, Visible, and Mask Regions; Transfer Modes;Pixel Alignment; Depth of Pixel Maps; and Color Mapping.">                                                                              <meta name="categories" content="QuickDraw"><meta name="week-posted" content="May 28, 1990 - Jun 1, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002734" title="Of Time and Space and _CopyBits"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Carbon/idxGraphicsImaging-date.html" target="_blank">Carbon > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note QD21</div>
<div id="pageheadsub">Of Time and Space and _CopyBits</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Can You Influence the Speed of _CopyBits</A><BR><BR><A HREF="#Section2">Influences on the Speed of _CopyBits</A><BR><BR><A HREF="#Section3">Dimensions of the Copied Area</A><BR><BR><A HREF="#Section4">Shape and Size of the Clip, Visible, and Mask Regions</A><BR><BR><A HREF="#Section5">Transfer Modes</A><BR><BR><A HREF="#Section6">Colorization</A><BR><BR><A HREF="#Section7">Pixel Alignment</A><BR><BR><A HREF="#Section8">Speed of the Hardware, Of Course</A><BR><BR><A HREF="#Section9">Depth of Pixel Maps</A><BR><BR><A HREF="#Section10">Color Mapping</A><BR><BR><A HREF="#Section11">Scaling</A><BR><BR><A HREF="#Section12">Of Time and Space</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note describes the various factors that can influence the speedof <code>_CopyBits</code> so that developers can set up conditions to achieve thebest performance for the particular situation.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Jun 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><H2>Can You Influence the Speed of _CopyBits?</h2><p><code>_CopyBits</code> has never been an "easy" QuickDraw routine, like<code>_LineTo</code> or even <code>_OpenPort</code>.  Most programmers who are justbeginning to adjust themselves to the Macintosh usually have to give<code>_CopyBits</code> a few tries before the right bits copy to the right places.Even many who feel that they have <i>become</i> Macintosh programmers still seereflections in their monitors of furrows between their eyebrows as they beginto press the key labelled "C."</p><p><code>_CopyBits</code> is one of those routines that is so full of subtlety, it has thebeginnings of something that could be considered to be personality.  Onesubtlety involves the second most important thought that's on the minds of anycomputer programmer:  execution speed.  Why is <code>_CopyBits</code> fast?  Why isit slow?  Can I influence its speed?  Is there really a clandestine state ofreason?  Is there a price to speed?</p><P><A HREF="#top">Back to top</A></p><a id="Section2"></a><H2>Influences on the Speed of _CopyBits</h2><p>Yes, you can influence the speed of <code>_CopyBits</code>.  Yes, it's evenpredictable.  And yes, it's possible that you have to compromise to get themaximum speed.  This Note is intended to give you a deeper understanding of theways that the speed of <code>_CopyBits</code> can be affected; and hopefully youcan then set up conditions for a <code>_CopyBits</code> call without the disturbingnotion that someone else might be doing the same thing just a little bit betterthan you.</p><p>This Note talks about every factor that affects the speed of <code>_CopyBits</code>that I can think of and that can be reasonably controlled by a programmer orthe person using an application.  There are other factors not mentioned in thisNote because I felt that they were just too esoteric to describe with anymeaning.</p><p>In each case, this Note tries to give real-life examples showing the effect ofeach factor.  These examples are just to give you a relative idea of theimportance of each effect.  In real life, the effects of the different factorsgive results that could be a lot different from the results presented in thisNote.  Each example is based on 100 <code>_CopyBits</code> calls from an off-screenpixel map to the screen on a Macintosh IIcx with an Apple Extended Video Cardwhich is running System Software 6.0.5 and 32-Bit QuickDraw 1.2.  Theoff-screen pixel map is eight bits deep with the standard eight-bit color tableand 256 pixels high by 256 pixels wide.  The screen is also in eight-bit colormode.  Calling <code>_CopyBits</code> to copy the entire off-screen pixel map tothe screen 100 times takes 204 ticks, and this Note refers to this figure asthe "standard test."  Since a tick on a Macintosh is approximately 1/60 of asecond, the standard test runs at slightly less than 30 frames per second.  Asthis Note discusses each factor, it presents an example with that factorchanging and all other factors remaining the same as the standard test, whichallows you to compare performance of the changed factor to that of the standardtest of 204 ticks.</p><p>What follows is a discussion of each factor that can influence the speed of<code>_CopyBits</code>, in no particular order.</p><P><A HREF="#top">Back to top</A></p><a id="Section3"></a><H2>Dimensions of the Copied Area</h2><p>One of the most obvious factors has to do with the dimensions of the copiedarea.  <code>_CopyBits</code> takes as parameters two rectangles which specify theportion of the source pixel map from which you want to copy and the portion ofthe destination pixel map to which you want to copy it.  All other factorsbeing equal, the larger the rectangles, the more pixels <code>_CopyBits</code> hasto copy and the longer it takes to do the job.  To keep <code>_CopyBits</code> asfast as possible, copy the smallest rectangle possible.</p><p>Modifying the standard test so that <code>_CopyBits</code> only copies a 128-pixelwide by 128-pixel tall area produces a result of 109 ticks, which compares tothe 204 tick performance for a 256-pixel wide by 256-pixel tall area.</p><p>QuickDraw is usually faster drawing wide things than it is drawing tall things,because consecutive pixels in memory are displayed horizontally.  Drawing aseries of pixels that are next to each other horizontally is easy becauseQuickDraw simply has to set consecutive memory locations, while drawing aseries of pixels that are next to each other vertically is just a little bitharder because the address of each pixel must be calculated. <code>_CopyBits</code> is no exception to this general rule; it copies a row of pixels, goes to the next row, copies that row, goes to the next row, and so on. The time spent going between rows is a lot more than the time going between pixels on one row, so the effect is that <code>_CopyBits</code> is faster copying a short and wide section of a pixel map than it is copying a tall and narrow one. To keep <code>_CopyBits</code> as fast as possible, copy the shortest rectangle possible.</p><p>Modifying the standard test again so that the source and destination rectanglesare 256 pixels wide by 50 pixels tall produces a result of 110 ticks, whilemodifying it so that the source and destination rectangles are 50 pixels wideby 256 pixels tall results in a time of 123 ticks.  These 13 ticks may not seemlike a big deal, but combined with other factors, there may be a case wherethey make a big difference.</p><P><A HREF="#top">Back to top</A></p><a id="Section4"></a><H2>Shape and Size of the Clip, Visible, and Mask Regions</h2><p><code>_CopyBits</code> always makes sure that it stays within the lines, so to speak.<code>_CopyBits</code> copies pixels clipped to the <code>maskRgn</code> that you passas the last parameter to the call.  If the destination is the current<code>GrafPort</code>, <code>_CopyBits</code> additionally clips to a region that's theintersection of the <code>clipRgn</code> and <code>visRgn</code> of the port.  If theintersection of these three regions is not rectangular, then <code>_CopyBits</code>has to check each pixel to make sure it falls within the intersection, and thischeck slows <code>_CopyBits</code> down.  If the intersection of these threeregions is rectangular, then <code>_CopyBits</code> takes the fast case of copyingconstant-sized rows.  To keep <code>_CopyBits</code> as fast as possible, make surethe intersection of the <code>clipRgn</code> and <code>visRgn</code> of the destination<code>GrafPort</code> and the <code>maskRgn</code> is rectangular.  Of course, if thedestination <code>GrafPort</code> is a window, then the <code>visRgn</code> is underthe user's control.</p><p>In general, if the region that you are copying into has straight vertical edgesfor the most part, the time penalty of using a non-rectangular region is notthat bad.  Regions that only have small portions that are straight and verticalare the ones that slow <code>_CopyBits</code> down in a big way.  Regions that aretwisted or that have holes or islands can also have a big effect upon thespeed, depending upon how complicated they are.  As a rule of thumb, if aregion looks like it slows <code>_CopyBits</code>, it probably does.</p><p>Modifying the standard test so the <code>maskRgn</code> is set to a circle thatinscribes the example pixel map results in a time of 303 ticks, which isconsiderably longer than the standard test result of 204 ticks that involvedcopying a much larger area.  Modifying the <code>maskRgn</code> to a square with226 pixels per side, which has about the same total area of the circle justused, results in a time of 176 ticks.</p><P><A HREF="#top">Back to top</A></p><a id="Section5"></a><H2>Transfer Modes</h2><p>Macintoshes without Color QuickDraw have eight transfer modes that work with<code>_CopyBits</code>, while those Macintoshes with Color QuickDraw get anadditional nine modes.  Because the algorithms for each of these modes can bepretty different from the others, the time it takes <code>_CopyBits</code> to workwith each of these modes can vary radically.  For several of these modes, thespeed of <code>_CopyBits</code> can vary a lot depending upon the particular imagebeing copied and the image over which this image is copied.  It can also varynon-linearly depending upon the depth of the pixel maps.  The arithmetic modesin particular are highly optimized for 32-bit deep pixel maps.</p><p>The standard test copies a fairly average-looking ray-traced image to a whitebackground.  Modifying the standard test to erase the background between eachof the 100 calls to <code>_CopyBits</code> produced the following results for themodes listed (the tests were obviously also changed to reflect the proper mode.In addition, to make the results a little more meaningful, the time it took toerase the background has been subtracted from each result.</p><p><code>srcCopy    204    notSrcCopy 469 addOver 1500 adMax 1504</code></p><p><code>srcOr 436 notSrcOr 444 addPin 1514 adMin 1501</code></p><p><code>ssrcBic 441 notSrcBic 441 subOver 1493 blend 1553</code></p><p><code>srcXor 438 notSrcXor 436 subPin 1525 transparent 1107</code></p><p><code>hilite 3127</code></p><p>Of course, the amount of time taken by some of these modes can be changed bychanging the image to copy and the image over which it is copied.  Thesefigures are just to give an idea of how fast or slow some of these modes are inthis particular situation.</p><p>There is actually one more mode which is not mentioned:  <code>ditherCopy</code>.Apple introduced this mode with 32-Bit QuickDraw, and it makes<code>_CopyBits</code> do error-diffusion dithering when copying a pixel map fromone depth to a pixel map of a lesser depth or to a pixel map of the same depthwith a different color table.  The speed of this transfer mode can be very fastor very slow, depending upon what pixel depths and colors are used and theparticular image being copied.  The <code>ditherCopy</code> mode is not included inthe table since the range of figures is potentially very large; play with itand see for yourself.  For more information about this mode, refer to the ColorQuickDraw chapter in <i>Inside Macintosh</i>, Volume VI and the 32-BitQuickDraw Developers' Notes.</p><P><A HREF="#top">Back to top</A></p><a id="Section6"></a><H2>Colorization</h2><p>There is a variation of <code>_CopyBits</code> if the destination pixel map is thecurrent port and the foreground color is not black or the background color isnot white.  If this is the case, then the source image is colorized when it'scopied.  For details, see Technical Note #163, Adding Color with _CopyBits.Because this colorization requires extra processing, <code>_CopyBits</code> slowsdown.  To keep <code>_CopyBits</code> as fast as possible, make sure the foregroundcolor is black, the background color is white, and that the current<code>GDevice</code> pixel map's color table has white in the first position andblack in the last position.</p><p>Modifying the standard test so that the foreground color is pure red and thebackground color pure blue produces a result of 579 ticks.</p><P><A HREF="#top">Back to top</A></p><a id="Section7"></a><H2>Pixel Alignment</h2><p>The alignment of pixels in the source pixel map relative to their alignment thedestination pixel map can be surprisingly important to the speed of<code>_CopyBits</code>, but what is pixel alignment?  Following is an example todemonstrate the concept of pixel alignment.  Imagine you want to perform a<code>_CopyBits</code> on a one-bit-per-pixel off-screen pixel map into a window ona one-bit-per-pixel screen, and the window is three pixels from the left edgeof the screen.</p><p>If you copy the entire off-screen pixel map to the left edge of the window,then <code>_CopyBits</code> must realign the pixels.  Since the leftmost pixels ofthe off-screen pixel map are on a byte boundary, but the left edge of thewindow is three pixels away from a byte boundary, <code>_CopyBits</code> has toshift (or realign) each byte from the off-screen pixel map by three pixelsbefore placing it on the screen.  The process of aligning the pixels slows down<code>_CopyBits</code>.</p><p>Figure 1 shows an example of this realignment.  An off-screen bit map specifiedby a pointer to a <code>BitMap</code> called <code>offScreen</code> is being copied toa window specified by a <code>WindowPtr</code> called <code>window</code>.<code>window</code>, which is 256 pixels wide and 256 pixels high, is positioned 50pixels from the top of the screen and three pixels from the left edge of thescreen.  The screen has 512 pixels horizontally and 342 pixels vertically.  The source rectangle that is passed to <code>_CopyBits</code> is <code>sourceRect</code>and the destination rectangle is <code>destinationRect</code>.  Because <code>offScreen</code> is misaligned by three pixels, <code>_CopyBits</code> has to shift <code>offScreen</code> by three pixels before placing the image on the screen.</p><p align=center><img src="images/qd_21_001.gif" alt="Figure 1" width=416 height=468></p><p align=center><b>Figure 1</b>. Offscreen Needs Realignment</p><p>By adjusting the off-screen pixel map so that its leftmost pixels are alsothree pixels away from a byte boundary, <code>_CopyBits</code> can just copy thebytes without shifting, which is a lot faster.  This example holds true on allMacintosh models, whether they have Color QuickDraw or not.  To keep<code>_CopyBits</code> as fast as possible, make sure the pixels in memory arealigned with the pixels on the screen.  Figure 2 shows the same situation asFigure 1, except that <code>offScreen</code> is now properly aligned to <code>window</code>.</p><p align=center><img src="images/qd_21_002.gif" alt="Figure 2" width=416 height=468></p><p align=center><b>Figure 2</b>. Offscreen Aligned</p><p>Many, if not most, Color QuickDraw Macintoshes have video cards that candisplay one pixel per byte, so one would think that pixel alignment does notapply in these cases, since all pixels are at byte boundaries.  This statementis true enough, but there is still another kind of alignment that should bedone on these machines.  Macintoshes with Color QuickDraw generally have full32-bit microprocessors, and these microprocessors are at their fastest whenthey can transfer long words aligned on long-word boundaries in memory.</p><p>Modifying the last example so that the off-screen pixel map and the screen areboth eight-bits-per-pixel, the pixel at the extreme top left corner of theoff-screen pixel map is located at a long-word boundary, because the MacintoshMemory Manager forces it to be located there; however, the pixel at the extremetop left corner of the window is located three bytes away from the previouslong-word boundary.  No bit shifting is needed, because each pixel takes up awhole byte, but <code>_CopyBits</code> does have to take the non-optimum case ofcopying long words on non-long-word boundaries.  This case works fine, but itis not quite as fast as it could be.  To keep <code>_CopyBits</code> as fast aspossible, make sure pixels in the source and destination pixel maps are alignedon long-word boundaries.</p><p>Since 1984, Macintosh programmers have been told that <code>rowBytes</code> must beeven.  That is still true, but to allow <code>_CopyBits</code> to copy an entirepixel map on long-word boundaries, <code>rowBytes</code> must be a multiple of fourso that every line in a pixel map begins on a long-word boundary.  Thefollowing formula can be used to find the minimum <code>rowBytes</code> needed fora pixel map's <code>bounds</code> rectangle with right and left coordinates of<code>bounds.right</code> and <code>bounds.left</code>, and a pixel depth of<code>pixelDepth</code>:</p><p>Off-screen <code>GWorld</code> support, which was introduced with 32-Bit QuickDraw,can automatically set up a pixel map so that it's properly aligned to any partof the destination pixel map or bit map.  You can specify that you want this bypassing zero for the pixel depth and passing the rectangle of the destinationarea in global coordinates.  See the 32-Bit QuickDraw Developers' Notes and"Braving Offscreen Worlds" in <i>develop</i>, January 1990 for details.</p><p>The way that <code>_NewGWorld</code> aligns a <code>GWorld</code> is to set up theoff-screen pixel map so that its <code>rowBytes</code> is four bytes wider than onewould normally calculate.  Four bytes is the maximum amount that any pixel mapwould have to be realigned at any pixel depth.  The <code>bounds</code> rectangle'sleft coordinate is set to the negative of the left coordinate of thedestination rectangle in global coordinates modulo (32 / pixel depth), becausethis is maximum amount that a pixel map must be shifted to achieve perfectalignment.  To build on the earlier example, assume you have a 128-pixel wide,eight-bit deep, off-screen pixel map to copy to a window that is three pixelsaway from the left edge of an eight-bit color screen.</p><p>First, the <code>rowBytes</code> for the off-screen pixel map is set to 131 toallow room for realignment.  To align the off-screen pixel map to the on-screenwindow, the left coordinate of the off-screen bit map's <code>bounds</code> is setto -3 and the right coordinate is still at 128.  Notice that the off-screenpixel map's <code>bounds</code> is now 131 pixels wide.  Now, the pixels in theoff-screen pixel map with a horizontal coordinate of 0 are located three bytesaway from the previous long-word boundary.  The pixels on the left edge of thewindow are also located three bytes away from the previous long-word boundary,so <code>_CopyBits</code> can copy long words on long-word boundaries.</p><p>If a user moves the window so that it's two pixels from the left edge of thescreen, the off-screen pixel map must be realigned.  <code>_UpdateGWorld</code> isused to do this.  It changes the left coordinate of the off-screen pixel map's<code>bounds</code> rectangle to -2 and then it shifts all the pixels in theoff-screen pixel map one pixel to the left.  The extra four bytes in each rowprovide the room for this shifting.  (Gives you some new respect for theoff-screen support, doesn't it?)</p><p>This same discussion applies to any pixel depth, though shallower pixel depthsrequire bit shifting rather than byte shifting.  The same principles apply,though.  Notice that in a 32-bit deep pixel map, all pixels are aligned onlong-word boundaries, so no bit shifting or byte shifting ever needs to be doneon one of those.  <code>_NewGWorld</code> still adds four to <code>rowBytes</code> evenin this case, however.</p><p>Modifying the standard test so that the source and destination pixel maps arefour bits deep with perfect pixel alignment produces a result of 78 ticks;however, if the destination pixel map is one pixel left of perfect alignment,the result is 228 ticks.</p><P><A HREF="#top">Back to top</A></p><a id="Section8"></a><H2>Speed of the Hardware, Of Course</h2><p>Obviously, the speed of the machine your application is running on affects thespeed of <code>_CopyBits</code>.  To make <code>_CopyBits</code> as fast as possible,spend a lot of money.  However, there is more to the speed of<code>_CopyBits</code> than the speed of the Macintosh itself.  When the Macintosh128K was released, there was only one place for pixel images: main memory.Today, the situation is more complicated.  If you have a modular Macintosh, thepixel image for the screen is in the memory of a NuBus(TM) video card.  If youhave a Macintosh IIci, you can optionally abandon the NuBus video card and useon-board video which takes up part of main memory.  If you have an 8*24 GC cardwith enough memory, the pixel images can be cached in the card's memory alongwith the screen's pixel image.</p><p>All of these different locations have different access speeds, and that canaffect the speed of <code>_CopyBits</code>.  Additionally, different Macintosheshave different RAM access speeds.  The Macintosh II, IIx, IIcx, and SE/30 havefaster RAM than the Macintosh Plus or SE.  The Macintosh IIci RAM access speedis faster still, and the Macintosh IIfx has faster RAM access than the IIci.Different video cards have different access speeds.  The IIci has a cache cardoption which can vastly speed up on-board video RAM access speed.  Third-partyvideo cards that work in the Processor Direct Slot of the Macintosh SE andSE/30 have their own speed characteristics as well.</p><p>There can also be a speed cost for crossing the different areas.  If<code>_CopyBits</code> copies between main memory and a NuBus video card, the imagedata has to be transferred across NuBus.  NuBus is a speed bottleneck, socopying an image across NuBus is slower than copying the image from one part ofthe screen to another or copying from one part of main memory to another.Modifying the standard test to create two windows and two off-screen pixelmaps--all eight bits deep with the standard color table then doing everycombination of copying between off-screens, between windows, and betweenoff-screens and windows produces the following results:</p><p>Off-screen to off-screen: 147</p><p>Screen to screen: 188</p>                <p>Off-screen to screen: 204</p>                <p>Screen to off-screen: 201</p><p>Performing the standard test on a Macintosh IIfx running System Software 6.0.5with an Apple Extended Video Card yields a result of 153 ticks, which is nottoo shabby considering that the transfer is still going through NuBus.</p><P><A HREF="#top">Back to top</A></p><a id="Section9"></a><H2>Depth of Pixel Maps</h2><p>This factor is pretty obvious and is sort of similar to the effect of thedimensions of the copied area:  the more bits per pixel there are in the pixelmap to copy, the more memory that <code>_CopyBits</code> has to move and the longerit takes to get the job done, assuming that the source and destination pixelmaps have the same depth.  To make <code>_CopyBits</code> as fast as possible, makesure the pixel maps are as shallow as possible.</p><p>If <code>_CopyBits</code> has to copy to a pixel map that has a different depthfrom the source pixel map, the relationship between speed and depth becomesmore complicated.  There is a tradeoff between the time taken to change thedepth of an image and the absolute amount of data that has to be processed.Copying from a 1-bit deep pixel map to a 32-bit deep pixel map is not that slowbecause the amount of image data in the 1-bit deep pixel map is so small.</p><p>Modifying the standard test to transfer a four-bit deep pixel map to anotherfour-bit deep pixel map produces a result of 78 ticks.</p><P><A HREF="#top">Back to top</A></p><a id="Section10"></a><H2>Color Mapping</h2><p>Color QuickDraw expects a color table attached to every indexed pixel map.Color tables specify what color each pixel value in the pixel map represents.When an application calls <code>_CopyBits</code> to copy a pixel map into anotherpixel map, <code>_CopyBits</code> reproduces the colors of the image in the sourcepixel map as closely as possible--even if the colors available in the destination pixel map are different than those available in the source pixel map.  This reproduction is done through a process called "color mapping."</p><p>When color mapping is done, the source pixel values are transformed into<code>RGBColor</code> records using the source pixel map's color table.  These<code>RGBColor</code> records are passed to <code>_Color2Index</code> which finds thepixel values of the closest available colors in the current <code>GDevice</code>pixel map's color table.  This same process is done when the source anddestination pixel maps have differing depths.  The color table attached to thedestination pixel map is not used in color mapping.  The colors available inthe current <code>GDevice</code> pixel map's color table are used instead.  So, thedestination pixel map must have the same colors for the same pixel values asthe current <code>GDevice</code>.  Otherwise, the resulting image in thedestination pixel map gets the wrong colors.  See <i>Inside Macintosh</i>,Volume V-141, The Color Manager, for a description of <code>_Color2Index</code>.It's also helpful to read the "Inverse Tables" section in the same chapter onpage V-137.</p><p>Now, if the source color table contains virtually the same colors for the samepixel values as the current <code>GDevice</code> pixel map's color table, then anyparticular pixel value has the same color regardless of whether it is in thesource or destination pixel map.  In this case, color mapping is a waste oftime, because the pixels can be copied directly from the source pixel map tothe destination pixel map without a loss of color fidelity.  <code>_CopyBits</code>takes advantage of this special case to yield some big speed improvements.  Howis this special case detected?  Before this question is answered, it's usefulto understand how Color QuickDraw uses color tables.</p><h3>The ctSeed Field</h3><p>The first field in a color table is the <code>ctSeed</code> field.  This <code>LongInt</code> can be thought of as the color table's version of the <code>scrapCount</code> field of the desk scrap.  Whenever an application calls <code>_ZeroScrap</code>, the desk scrap's <code>scrapCount</code> is changed.  An application can tell that the desk scrap has changed by checking to see if the <code>scrapCount</code> has changed.  Similarly, whenever the contents of a color table are changed in any way, the <code>ctSeed</code> field should be changed to indicate to anyone using that color table that it has been modified.</p><p>Additionally, Color QuickDraw often uses the <code>ctSeed</code> as a fast checkfor color table equality.  If two color tables have the same <code>ctSeed</code>,then Color QuickDraw often assumes that their contents are equivalent.</p><p>After creating a new color table, an application has to get a valid value forthe <code>ctSeed</code> field, and it can do so with the _<code>GetCTSeed</code>routine.  This routine generates a valid <code>ctSeed</code> value suitable for anew color table.  See <i>Inside Macintosh</i>, Volume V-143, The Color Manager,for a description of <code>_GetCTSeed</code>.</p><p>System Software 7.0 and 32-Bit QuickDraw each offer a routine called_<code>CTabChanged</code> which should be called after a color table is modified.It takes a handle to the changed color table as a parameter.  If the<code>_CTabChanged</code> routine is not available, then the application shouldinstead change <code>ctSeed</code> to a different valid value by calling<code>_GetCTSeed</code> and assigning the result to <code>ctSeed</code>, just like it'sdone when the application creates a new color table.  You must use either oneof these methods to tell Color QuickDraw that the color table has changed, orelse the modified color table could be confused with the old color table, orwith some other color table--this is especially critical if an 8*24 GC card isbeing used.  See the 32-Bit QuickDraw Developers' Notes for details about the<code>_CTabChanged</code> routine.</p><h3>The ctFlags Field</h3><p>The <code>ctFlags</code> field is used as a set of flags that indicate somecharacteristics of the color table.  Currently, only the top two bits of<code>ctFlags</code> are of any interest to developers.  The most significant bitof <code>ctFlags</code> (bit 15) indicates whether the color table is a sequentialcolor table or an indexed color table.  Bit 14 indicates that the color tableis a special kind of sequential table if it is set.  In these kinds of colortables, the <code>value</code> fields indicate a palette entry in the destinationwindow's palette.  See the Palette Manager section of the 32-Bit QuickDrawDevelopers' Notes for a discussion about this capability.</p><h3>Sequential Color Tables</h3><p>If bit 15 of <code>ctFlags</code> is set, the color table is a sequential colortable.  Sequential color tables are usually found attached to <code>GDevice</code>pixel maps and to <code>GWorld</code> pixel maps.</p><p>In sequential color tables, the position of each color in the color tableindicates the pixel value to which it corresponds.  For example, the fifthentry in a sequential color table always has a pixel value of four (pixelvalues start at zero).  The <code>value</code> field of each <code>ColorSpec</code> isnot defined in sequential color tables, though they are used in color tablesfor screen <code>GDevice</code> records to indicate that a particular color isreserved, protected, or both.</p><h3>Indexed Color Tables</h3><p>If bit 15 and 14 of <code>ctFlags</code> are clear, the color table is an indexedcolor table.  In indexed color tables, the <code>value</code> field of each <code>ColorSpec</code> indicates the pixel value of the RGB in that <code>ColorSpec</code>. For example, if the fifth <code>ColorSpec</code> in the color table has a <code>value</code> field containing 10, then that color has a pixelvalue of 10, not 4, as it would have been if this were a sequential color table.</p><h3>Color Mapping or Non-Color Mapping</h3><p>As noted before, <code>_CopyBits</code> can detect whether it has to do colormapping or not, so that it can take advantage of the speed benefits of no colormapping if possible.  How is this done?  First, <code>_CopyBits</code> checks tosee if the <code>ctSeed</code> field of the source and destination color tables arethe same and if the source and destination pixel maps have the same depths.  Ifboth of these conditions are true, then <code>_CopyBits</code> assumes that the twocolor tables are identical and it just copies the pixels directly without colormapping.  If the <code>ctSeed</code> fields are different, <code>_CopyBits</code>checks manually through all of the colors in the source pixel map's color tablemap to see if they map to the same pixel values in the current <code>GDevice</code>pixel map's color table as they do in their own color table.  If they do, then<code>_CopyBits</code> again takes the fast case.</p><p>So to keep <code>_CopyBits</code> as fast as possible, make sure that the sourceand destination color tables have virtually the same colors for the same pixelvalues.  This applies even if one color table is an indexed color table and theother is a sequential color table, or if the source and destination colortables are both indexed but the order of the <code>ColorSpec</code> records differ.</p><p>Modifying the standard test so that the source pixel map has a color table thatis the reverse of the standard eight-bit system color table (the grays have lowpixel values and the light pinks and yellows have high pixel values) and thedestination pixel map has the standard eight-bit system color table produces aresult of 470 ticks.</p><p>By the way, color tables do not make any sense for direct pixel maps, so thisdiscussion does not apply to them.  Direct pixel maps do have a color tableattached to them, but they're just there so that an application that assumesthat a color table is attached does not bomb.</p><P><A HREF="#top">Back to top</A></p><a id="Section11"></a><H2>Scaling</h2><p>If the source and destination rectangles are the same size, <code>_CopyBits</code>has the fairly easy task of just transferring the pixels from the source pixel map to the destination pixel map; however, if the source and destination rectangles are different sizes, <code>_CopyBits</code> has to scale the copied image, which slows it down a <i>lot</i>.  To keep <code>_CopyBits</code> as fast as possible, make sure the source and destination rectangles have the exact same dimensions.</p><p>Modifying the standard test to copy a 128 by 128 pixel portion of the sourcepixel map to the whole 256 by 256 pixel window produces a result of 1,159 ticks.</p><P><A HREF="#top">Back to top</A></p><a id="Section12"></a><H2>Of Time and Space</h2><p>Hopefully, this Note makes it a lot clearer to you how to set up a situation inwhich your <code>_CopyBits</code> calls are as fast as your situation allows.  It'simportant to realize that this Note does not cover every single factor that hasan influence on the speed of <code>_CopyBits</code>.  There are many more factorswhich are just too unpredictable.  For example, <code>_CopyBits</code> is highlyoptimized for many special cases, and those optimizations can have a big effecton the speed of the copy.  Also, the speed of <code>_CopyBits</code> can beaffected by interrupt-level tasks.  It's up to you to fine tune your programsto your particular situations.</p><P><A HREF="#top">Back to top</A></p><a id="References"></a><h2>References</h2><P><i>Inside Macintosh</i>, Volume I, QuickDraw</p><P><i>Inside Macintosh</i>, Volume V, The Color Manager</p><P><i>Inside Macintosh</i>, Volume VI, Color QuickDraw</p><P>Technical Note M.IM.ColorCopyBits, <u><A HREF = "qd_04.html">Adding Color With _CopyBits</a></u></p><P><i>develop</i>, January 1990, "Realistic Color for Real-World Applications"</p><P><i>develop</i>, January 1990, "Braving Offscreen GWorlds"</p><P>32-Bit QuickDraw Developers' Notes</p><p>NuBus is a trademark of Texas Instruments</p><a name="Downloads"></a>         <P><A HREF="#top">Back to top</A></p><H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (520K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/qd_21.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/qd/qd_21.html%3Fid%3DDTS10002734-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/qd/qd_21.html%3Fid%3DDTS10002734-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/qd/qd_21.html%3Fid%3DDTS10002734-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>