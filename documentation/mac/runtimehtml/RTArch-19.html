<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Using Code Fragment Manager Options</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING19></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="RTArch-18.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-20.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="RTArch-2.html"><B>Mac OS Runtime Architectures</B></A> / <BR><DD><A HREF="RTArch-14.html"><B>Chapter 1 - CFM-Based Runtime Architecture</B></A> / <A HREF="RTArch-16.html"><B>Closures</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING19-0></A>
<H2>Using Code Fragment Manager Options</H2>
 <A NAME=MARKER-2-46></A>If you prepare and release fragments explicitly from your code, you should be aware of the different options available. These options are available (as the <CODE>CFragLoadOptions</CODE> parameter) for the following Code Fragment Manager routines:<P>
<UL>
<LI><CODE>GetSharedLibrary</CODE>
<LI><CODE>GetDiskFragment</CODE>
<LI><CODE>GetMemFragment</CODE><P>
</UL>
 If you are calling one of these Code Fragment Manager routines to prepare a plug-in, you should generally specify the <CODE>kReferenceCFrag</CODE> option when invoking it. The Code Fragment Manager then prepares the fragment (and any required import libraries) if a connection is not already present, adds a new closure, and increments the reference count of any import libraries that the new closure shares with others already in memory. The Code Fragment Manager then returns a closure ID which you can use to access the symbols in the closure.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Code Fragment Manager routines that do not create a new closure return a connection ID rather than a closure ID. The Code Fragment Manager increments reference counts on existing connections only when a new closure is created.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 You can also use the <CODE>kReferenceCFrag</CODE> option to gain access to symbols in an already instantiated connection. For example, say you have an application <CODE>mooApp</CODE> as shown in <A HREF=#MARKER-9-47>Figure 1-5</A> A. The application <CODE>mooApp</CODE> prepares the plug-in <CODE>mooPlug</CODE> as shown in B, and <CODE>mooPlug</CODE> sometime later programmatically prepares the shared library <CODE>dogLib</CODE> (shown in C). If you wanted to access the symbols in <CODE>dogLib</CODE> from <CODE>mooApp</CODE>, you could do so by calling the Code Fragment Manager to prepare <CODE>dogLib</CODE> using the <CODE>kReferenceCFrag</CODE> option. The Code Fragment Manager adds a new closure and increases reference counts to reflect the presence of the new closure. <A HREF=#MARKER-9-47>Figure 1-5</A> D shows the effect of using <CODE>kReferenceCFrag</CODE> to prepare the shared library <CODE>dogLib</CODE>, which requires the library <CODE>cowLib</CODE>.<P>
<DL>
<DT><B>Note</B>
<DD><CODE>kReferenceCFrag</CODE> was previously called <CODE>kLoadCFrag</CODE>.<EM></EM><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<B>Figure 1-5  <A NAME=MARKER-9-47></A>Using <CODE>kReferenceCFrag</CODE></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-99.jpg"> <P>
 In some cases you may only want to determine if a connection associated with a fragment exists. In such cases, you can use the <CODE>kFindCFrag</CODE> option to return a connection ID of an existing connection. However, using the <CODE>kFindCFrag</CODE> option does not add a closure or increase the connection's reference count. You can theoretically access the symbols it contains, but if the reference count drops to 0, the Code Fragment Manager might release the connection while your program is still using it. For example, in <A HREF=#MARKER-9-48>Figure 1-6</A>, say that <CODE>mooApp</CODE> prepares the plug-in <CODE>mooPlug</CODE>, and <CODE>mooPlug</CODE> programmatically prepares the shared library <CODE>dogLib</CODE>. Later, <CODE>mooApp</CODE> uses <CODE>kFindCFrag</CODE> to access symbols in <CODE>dogLib</CODE>. If <CODE>mooPlug</CODE> releases <CODE>dogLib</CODE>, then any references to symbols in <CODE>dogLib</CODE> are left dangling. <P>
<B>Figure 1-6  <A NAME=MARKER-9-48></A>Using <CODE>kFindCFrag</CODE></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-98.jpg"> <P>
 Another useful option is <CODE>kPrivateCFragCopy</CODE>. Using the <CODE>kPrivateCFragCopy</CODE> option when calling a Code Fragment Manager routine, you can create a new connection for each request to prepare the fragment, even if the same application makes multiple preparation requests. That is, you can have multiple connections (each with its own private data section) from the same shared library that all serve the same client fragment. <A NAME=MARKER-2-49></A>Such a connection is called a private connection. A fragment prepared in this manner, however, is not visible as an import library (that is, the Code Fragment Manager does not recognize its name as an import library and you cannot find it using the <CODE>GetSharedLibrary</CODE> routine or the <CODE>kFindCFrag</CODE> option.) <P>
<DL>
<DT><B>Note</B>
<DD>A private connection is also known as a per-load instantiation.<EM></EM><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 For example, the application <CODE>mooApp</CODE> in <A HREF=#MARKER-9-50>Figure 1-7</A> has created two "copies" of the plug-in <CODE>mooPlug</CODE>. Each instance of <CODE>mooPlug</CODE> has its own data, but they all share the same code. Note that <CODE>cowLib</CODE> is not duplicated for each instance of <CODE>mooPlug</CODE>; any import libraries that are part of a private connection's closure are treated normally. <P>
<B>Figure 1-7  <A NAME=MARKER-9-50></A>Using private connections</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-100.jpg"> <P>
 You can specify a private connection, for example, if you have a communications application that uses a shared library to implement a tool for connecting to a serial port. By requesting private connections, you can ensure that your tool can connect to two or more serial ports simultaneously by maintaining separate copies of the tool's data. The tool itself can then be ignorant of how many ports it is handling. <A NAME=MARKER-2-51></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="RTArch-18.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-20.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="RTArch-3.html">&copy; Apple Computer, Inc.</A><br>11 MARCH 1997<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
