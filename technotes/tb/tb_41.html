<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TB41: Translation Manager 1.1</title>                                       <meta name="categories" content="Human Interface Toolbox"><meta name="week-posted" content="May 30, 1994 - Jun 3, 1994"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002792" title="Translation Manager 1.1"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Carbon/idxHumanInterfaceToolbox-date.html" target="_blank">Carbon > Human Interface Toolbox</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TB41</div>
<div id="pageheadsub">Translation Manager 1.1</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Introduction</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note discusses changes to the Translation Manager which areavailable in Macintosh Easy Open version 1.1 and later.  The informationcontained here is in addition to what is discussed in <i>Inside Macintosh</i>More Macintosh Toolbox, Translation Manager chapter, as well as in the<i>APDA</i> Macintosh Easy Open Developers Kit.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Jun 01 1994]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><h2>Introduction</h2><p>The document assumes that you are somewhat familiar with the TranslationManager API.</p><p>Some of the new API's are available only in Translation Manager 1.1 and somehave always been available.  Use <code>Gestalt()</code> as appropriate to check forthe existence of some of the new API's (discussed later in this document).</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>     gestaltTranslationMgrHintOrder = 1</pre>	</TD></TR></TABLE></CENTER><p>The previous bit will be set if the Translation Manager hint order fix is ineffect.  In Translation Manager version 1.0.1 (fixed in version 1.0.2 andlater) there is a bug where the hints in <code>DoTranslateScrap()</code> arereversed - the <code>dstTypeHint</code> is actually the <code>srcTypeHint</code> andvice-versa.  If you want your Translation Extension to work with the earlyversions of the Translation Manager, and you're these using these scrap hints,then you need to check this bit to see where your destination and source hintsare.</p><p><code>     gestaltTranslationPPCAvail = 2</code></p><p>If <code>gestaltTranslationPPCAvail</code> bit is set then that is an indicatorthat the native PowerPC Translation Manager library is available.  This meansthat it's safe to make a call to the Translation Manager from native PowerPCcode.</p><p><code>     gestaltTranslationGetPathAPIAvail = 3</code></p><p>The new API's <code>GetFileTranslationPath()</code> and<code>GetPathTranslationDialog()</code> calls are available if the<code>gestaltTranslationGetPathAPIAvail</code>  bit is set.</p><p><code>GetDocumentKindString()</code> is available in all versions of the TranslationManager, therefore no gestalt selector is needed to check for its existence.</p><p>The new Translation Extension routine <code>DoGetTranslatedFilename()</code> doesnot have a gestalt selector since there is no compatibility problem running aTranslation Extension that supports the call on an earlier version of theTranslation Manager.  In that case, the function will simply not be called.</p><h3>The New Translation Manager API's</h3><p>One of the most glaring limitations of the 1.0 Translation Manager API was thatthe function <code>CanDocBeOpened()</code> couldn't be used in the case where atranslation preference did not exist.  You would have to set the translationpreference manually using the automatic translation user interface in theFinder or Standard File.  This meant for all purposes, that you could notprogrammatically use the Translation Manager.</p><p>Starting with Translation Manager 1.1 this limitation has been removed with twonew API's <code>GetPathFromTranslationDialog()</code> and<code>GetFileTranslationPaths()</code>.  The function<code>GetPathFromTranslationDialog()</code> allows you to post the TranslationDialog box programmatically while the function<code>GetFileTranslationPaths()</code> is a low level access routine allowing youto get all the translation capabilities of the Translation Manager.</p><p>Additional API's have been added to provide access to the kind strings, thename of Translation Extensions, as well as to programmatically execute scraptranslations.  These will be discussed later in this section.</p><h3>Displaying The Translation Dialog Box Programmatically</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>      pascal OSErr GetPathFromTranslationDialog(          const FSSpec* theDocument,          const FSSpec* theApplication,          const TypesBlockPtr typeList,          DocOpenMethod* howToOpen,          FileTranslationSpec* howToTranslate)          </pre>	</TD></TR></TABLE></CENTER><p>As mentioned in the earlier, <code>GetPathFromTranslationDialog()</code> is used toprogrammatically display the Translation Dialog box.  This has the"side-effect" of setting a preference so next time   <code>CanDocBeOpened()</code>is called it will have the preference and succeed.</p><p><code>GetPathFromTranslationDialog()</code> targets the file specified by the<code>theDocument</code> and attempts to generate a list of translation pathsresulting in a document readable by the target application specified by the<code>theApplication</code>.  The parameter <code>typeList</code> specifies, in a<code>0L</code> terminated form, a list of file types to translate the targetdocument into.  The order in the list is important.  The first item should bethe file type most desired and the last item should be the file type leastwanted.  The following two parameters <code>howToOpen</code> and<code>howToTranslate</code> are returned once the user has interacted with theTranslation Dialog box and will contain the translation open method and thetranslation specification.  It's important to point out the<code>howToTranslate</code> is only valid if <code>howToOpen</code> is equal to<code>domTranslateFirst</code>, otherwise it's undefined.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>None of the parameters are optional and <code>NULL</code> cannot bepassed in place of them.</P></TD></TR></TABLE></CENTER><BR><p>A common way of using this routine along with <code>CanDocBeOpened()</code> can beseen in the following snippet of code:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>     /* Translate        This routine translates a file.  It assumes that the        application has the signature 'ttxt' and can only can        read the document types 'ttro' and 'TEXT' */     OSErr Translate(const FSSpec* targetDocument,                     const FSSpec* destinationDocument,                     const FSSpec* theApplication)     {     OSType               typeList[3] = { 'ttro', 'TEXT', 0L };     DocOpenMethod        howToOpen;     FileTranslationSpec  howToTranslate;     OSErr                result;        /* Try to get the translation path based on the        preference (if one is set) */     result = CanDocBeOpened(targetDocument,                             theApplication-&gt;vRefNum,                             'ttxt',                             typeList,                             false,                             &amp;howToOpen,                             &amp;howToTranslate);        /* Did it work? */     if (result == noPrefAppErr) {            /* Couldn't find a path, run the Translation            Dialog box to get the path and set the preference */       result = GetPathFromTranslationDialog(targetDocument,                                             theApplication,                                             typeList,                                             &amp;howToOpen,                                             &amp;howToTranslate);       }            /* Did we get a path from either CanDocBeOpened            GetPathFromTranslationDialog, and does the            translation path specified require translation? */     if ((result == noErr)     &amp;&amp; (howToOpen == domTranslateFirst)) {            /* Translate the file */       result = TranslateFile(targetDocument,                              destinationDocument,                              &amp;howToTranslate);       }     return result;     }     </pre>	</TD></TR></TABLE></CENTER><h3>Getting All The Translation Paths</h3><p>At the low level, the new routine <code>GetFileTranslationPaths()</code> can beused to get raw translation paths.  The paths are each of the translation pathsthat allow a specific document to be translated to the target type (under someconstraints that are discussed later).  A specific translation may have one ormany paths - that depends on the translation itself and the capabilities of theTranslation Extensions installed.</p><p><code>GetFileTranslationPaths()</code> is defined as:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>      pascal short GetFileTranslationPaths(        FSSpec* srcDocument,        FileType dstDocType,        unsigned short maxResultCnt,        FileTranslationSpecArrayPtr resultBuffer)        </pre>	</TD></TR></TABLE></CENTER><p>Both <code>srcDocument</code> and <code>dstDocType</code> are optional parameters.<code>srcDocument</code> is the source document (if any) and <code>dstDocType</code> isthe desired document type to which you would like <code>srcDocument</code>translated.  Depending on what is passed, the routine returns a different setof translation paths, as seen in Figure 1.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>srcDocumentdstDocType</pre>	</TD></TR></TABLE></CENTER><h3>Translation Paths Returned</h3>    <table>	<tr>		<td align="left" scope="row">valid</td> <td align="left">valid</td> <td align="left">All paths to translate <code>srcDocument</code> to <code>dstDocType</code>    </td>	</tr>	<tr>		<td align="left" scope="row"></td>	</tr>	<tr>		<td align="left" scope="row">NULL</td> <td align="left">valid</td> <td align="left">All paths to tranlsate to <code>dstDocType</code>    </td>	</tr>	<tr>		<td align="left" scope="row"></td>	</tr>	<tr>		<td align="left" scope="row">valid</td> <td align="left">0</td> <td align="left">All paths from <code>srcDocument</code>    </td>	</tr>	<tr>		<td align="left" scope="row"></td>	</tr>	<tr>		<td align="left" scope="row">NULL</td> <td align="left">0</td> <td align="left">All translation paths </td>	</tr></table>   <h3>Figure 1</h3><p>The parameter <code>maxResultCnt</code> is the maximum number of entries your<code>resultBuffer</code> can hold.</p><p>The final parameter <code>resultBuffer</code> is returned with the requestedtranslation information.  This buffer's type is defined as:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>     struct FileTranslationSpec {       OSType           componentSignature;    const void*      translationSystemInfo;    FileTypeSpec     src;    FileTypeSpec     dst;       };     typedef struct FileTranslationSpec FileTranslationSpec;     typedef FileTranslationSpec *FileTranslationSpecArrayPtr;</pre>	</TD></TR></TABLE></CENTER><p>The function returns the number of translation paths, or a result code if thevalue is negative.</p><p>The following example shows a how to get the list of translation paths to opena specific document and how to translate using the first path in the list.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>     /* TranslateUsingFirstPath     This routine translates a file to 'SYLK' using the     first translation path in the Translation Manager     path list. */     OSErr Translate(FSSpec* targetDocument,                     FSSpec* destinationDocument,                     FSSpec* theApplication) {     FileTranslationSpec ts[10];     OSErr               result;     short               numberPaths;        /* Try to get the translation path */     numberPaths =  GetFileTranslationPaths(targetDocument,                                            'SYLK',                                            10,                                            &amp;ts[0]);     if (numberPaths &gt; 0)       {       result = TranslateFile(targetDocument, destinationDocument, ts);       }     else       result = noTypeErr;     return result;     }     </pre>	</TD></TR></TABLE></CENTER><h3>Getting Kind Strings</h3><p>Kind strings describe documents; for instance "FreeHand graphic".  Previouslythe kind strings were displayed in the Finder, but there was no programmaticway of accessing them.  The Translation Manager now provides the means to getto the kind strings, as well as the names of the Translation Extensionsinstalled.</p><p>The routine to get a kind string looks like:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>     OSErr GetDocumentKindString(short  docVRefNum,                                 OSType docType,                                 OSType docCreator,                                 Str63  kindString)</pre>	</TD></TR></TABLE></CENTER><p>This routine takes in the <code>docVRefNum</code> parameter, the volume containingthe document.  This is a hint to the Translation Manager where to look for thekind string.  If it doesn't find the string on that volume, it will use aninternal search path to look on other volumes for the string.  In<code>docType</code> and <code>docCreator</code> you pass the type and creator of thedocument you want to query.  When the function returns, <code>kindString</code>contains the kind string to display for that specific document.</p><p>If you have a <code>FileTranslationSpec</code> and you want to find out the name ofthe Translation Extension that's performing the translation, you call:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>     pascal OSErr GetTranslationExtensionName(         const FileTranslationSpec* translationMethod,         Str31 extensionName)         </pre>	</TD></TR></TABLE></CENTER><p>This routine takes a <code>FileTranslationSpec</code> (returned from<code>CanDocBeOpened()</code> or <code>GetFileTranslationPaths()</code>) and returns,in <code>extensionName</code>, the name of the Translation Extension performing thetranslation.</p><p>Both of these routines can be used, for example when using<code>GetFileTranslationPaths()</code> to create your own Translation Dialog box.Using these will allow you to generate strings like "MacWrite II document withXYZZY translation" and so forth.</p><h3>Scrap Translation</h3><p>An additional routine has been made public in the Translation Manager allowingyou to perform Scrap translation.  The name scrap translation is somewhatmisleading; rather it's in-memory translation.  Scrap translation is used bythe Scrap Manager, Edition Manager, Drag Manager, and OpenDoc to name a fewclients for in-memory translation.  Scrap translation can be used any time youwant to translate a buffer of information.</p><p>The routine to call when you want to perform scrap translation is:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>      pascal OSErr TranslateScrap(        GetScrapDataProcPtr sourceDataGetter,        void*               sourceDataGetterRefCon,        ScrapType           destinationFormat,        Handle              destinationData,        short               progressDialogID)        </pre>	</TD></TR></TABLE></CENTER><p>The routine is designed in a way to use a callback you provide to get thesource data to translate.  That information is then translated and placed intoa destination handle.</p><p>The parameter <code>sourceDataGetter</code> and <code>sourceDataGetterRefCon</code> arethe two parameters dealing with your callback routine.<code>sourceDataGetterRefCon</code> is for your own use - allowing you to passinformation to your callback.  The parameter <code>souceDataGetter</code> isdefined as:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>      typedef pascal OSErr (*GetScrapDataProcPtr)(        ScrapType requestedFormat,        Handle    dataH,        void* srcDataGetterRefCon);        </pre>	</TD></TR></TABLE></CENTER><p>The callback routine has two responsibilities.  The first is to tell the callerwhat source types are available for translating (if you are the Scrap Managerfor example you would pass all the different formats already on the deskscrap).  The other responsibility is to actually provide the data requested.</p><p>For the first case, if the parameter <code>requestedFormat</code> is<code>'fmts'</code>, then it's the responsibility of the callback routine to returnin <code>dataH</code> a list of pairs containing the <code>ScrapType</code> and thesize of the that <code>ScrapType</code>'s data.  The handle should be re-sizedaccordingly.</p><p>For the second case, the Translation Manager will call the callback routinewith one of the types it had provided earlier in response to <code>'fmts'</code>.The callback in that case is responsible for re-sizing the <code>dataH</code> andplacing in it the data of type <code>requstedFormat</code>.</p><p>In the callback, the parameter <code>sourceDataRefCon</code> is the same as whatyou had passed in the <code>sourceDataGetterRefCon</code> field in<code>TranslateScrap()</code>.</p><p>Back in <code>TranslateScrap()</code>, the third parameter,<code>destinationFormat</code> is the desired format you would like the informationtranslated into.  <code>destinationData</code> is a handle you provide.  TheTranslation Extension will automatically re-size it as necessary duringtranslation.  Upon exit, if the routine successfully executes, it will containthe translated information.</p><p>The final parameter is <code>progressDialogID</code>.  At this time that parametershould always be assigned the value<code>TranslationScrapProgressDialogID</code>.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>      struct FmtsRecord      {        ScrapType theType;        Size      dataSize;      };      typedef struct FmtsRecord FmtsRecord;      typedef FmtsRecord *FmtsRecordPtr;      pascal OSErr PStringGetter(            ScrapType requestedFormat,            Handle    dataH,            void*     srcDataGetterRefCon)      {      OSErr      result;      Str63      thePString;      /* Build an internal buffer to the PString we can get      BlockMove(&quot;\pHello there, this is lower case&quot;,            &amp;thePString, sizeof(Str63));        /* See if we are being requested to tell what         source format's we have available */      if (requestedFormat == 'fmts') {        /* Size the handle to contain our one source        format */        SetHandleSize(dataH, sizeof(FmtsRecord));        if ((result = MemError()) == noErr) {            /* Stuff our data into the fmts handle */          ((FmtsRecordPtr)*dataH)-&gt;theType = 'PSTR';          ((FmtsRecordPtr)*dataH)-&gt;dataSize = thePString[0]+1;          }      } else {            /* If we're here, we've been asked to get the            source data.   Stuff data into handle */        SetHandleSize(dataH, thePString[0]+1);        if ((result = MemError()) == noErr)          BlockMove(&amp;thePString, *dataH, thePString[0]+1);        }      return result;      }     void TranslatePSTRToUPPR(void)     {          Handle      destinationData;          OSErr       result;          /* A handle to fill with the translated data */          if (destinationData = NewHandle(0))              result = TranslateScrap(PStringGetter,                  0,                  'UPPR',                  destinationData,                  TranslationScrapProgressDialogID);          /* Do something with the translated information */     }    </pre>	</TD></TR></TABLE></CENTER><p>The preceding example shows how to use the <code>TranslateScrap()</code> routineand how to implement a data-getter.  In the above example,<code>TranslateScrap()</code> is called requesting type <code>'UPPR'</code> (uppercase) and providing the source data through the data-getter referenced in<code>PStringGetter</code>.</p><h3>New Translation Extension Capabilities</h3><p>Beginning with Translation Manager 1.1, Translation Extensions now have thecapability of generating the filenames of documents created by a documentconverter.  This is useful, for example, if your Translation Extension wants toprovide a DOS compatible filename for generated documents.  Name generation isdone by implementing the new Translation Extension routine (selector<code>kTranslateGetTranslatedFilename</code>).</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>      pascal ComponentResult DoGetTranslatedFilename(        ComponentInstance self,        FileType dstType,        long dstTypeHint,        FSSpec* theDocument);        </pre>	</TD></TR></TABLE></CENTER><p>This routine is called after <code>DoIdentifyFile()</code>, but before<code>DoTranslateFile()</code>.</p><p>The first parameter, like all other references to self in the ComponentManager, is a reference to this instance of the component.  <code>dstType</code> isthe target type and <code>dstTypeHint</code> is the hint that goes with that type -they are the same that will be passed to <code>DoTranslateFile()</code> when thatcall is made by the Translation Manager.  The final parameter,<code>theDocument</code> is the document to generate a name on - and where to storeyour generated name.</p><p>It's important to not modify <code>theDocument</code> unless your routinesuccessfully completes because whatever is returned will be used (even if youreturn an error).</p><p>Your Translation Extension should verify the uniqueness of the filename in thetarget location before returning.</p><p>The Translation Manager will not call your Translation Extension with thismessage unless you have the translation flags correctly set.  That is done bymodifying the <code>'thng'</code> resources <code>Flags</code> field, and setting the<code>kTranslatorCanGenerateFilename</code> bit.</p><h3>PowerPC Translation Extensions</h3><p>Native Translation Extensions are pretty much the same as 68K ones.  Thebiggest difference is putting a wrapper around the code.  You have severaloptions when writing a translator.  Your translator can be 68K, your translatorcan be PowerPC only, or your translator can be fat (both 68K and PowerPC).</p><p>The best of both worlds is the third case.  Your translator is a bit bigger,but a user can simply drag it from machine to machine without worrying aboutthe platform.  To implement a native PowerPC translator, simply replace yourcode referred by your <code>'thng'</code> resource (usually type <code>'xlat'</code>)with a reference to a resource wrapped by a <code>'sdes'</code> resource (seeMixedMode.r).  An <code>'sdes'</code> includes both your 68K and PowerPC code intoa single resource and automatically dispatches to the correct 68K or PowerPCcode depending on what platform you are on.</p><p>For specific examples on putting together a fat resource, please consult<i>Inside Macintosh</i>, specifically, the chapter on the Mixed Mode Manager.</p>      <P><A HREF="#top">Back to top</A></p><a name="References"></a><h2>References</h2><P><i>Inside Macintosh</i>, More Macintosh Toolbox, Translation Manager</p><P><i>Inside Macintosh</i>, More Macintosh Toolbox, Component Manager</p><P><i>Inside Macintosh</i>, PowerPC System Software, Mixed Mode Manager</p><P><i>APDA</i>, Macintosh Easy Open Developers Kit</P>         <a name="Downloads"></a>       <P><A HREF="#top">Back to top</A></p><h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (56K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tb_41.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tb/tb_41.html%3Fid%3DDTS10002792-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tb/tb_41.html%3Fid%3DDTS10002792-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tb/tb_41.html%3Fid%3DDTS10002792-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>