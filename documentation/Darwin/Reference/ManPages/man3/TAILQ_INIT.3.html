<html><head><title>Mac OS X
 Manual Page For TAILQ_INIT(3)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3/TAILQ_INIT" title="Mac OS X
 Manual Page for TAILQ_INIT(3)"><!-- headerDoc=man; indexgroup=Section 3; uid="//apple_ref/doc/man/3/TAILQ_INIT"; name=TAILQ_INIT(3) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
QUEUE(3)                 BSD Library Functions Manual                 <!-- a -->QUEUE(3)<!-- /a -->

<b>NAME</b>
     <b>SLIST_EMPTY</b>, <b>SLIST_ENTRY</b>, <b>SLIST_FIRST</b>, <b>SLIST_FOREACH</b>, <b>SLIST_FOREACH_SAFE</b>, <b>SLIST_HEAD</b>,
     <b>SLIST_HEAD_INITIALIZER</b>, <b>SLIST_INIT</b>, <b>SLIST_INSERT_AFTER</b>, <b>SLIST_INSERT_HEAD</b>, <b>SLIST_NEXT</b>,
     <b>SLIST_REMOVE_HEAD</b>, <b>SLIST_REMOVE</b>, <b>STAILQ_CONCAT</b>, <b>STAILQ_EMPTY</b>, <b>STAILQ_ENTRY</b>, <b>STAILQ_FIRST</b>,
     <b>STAILQ_FOREACH</b>, <b>STAILQ_FOREACH_SAFE</b>, <b>STAILQ_HEAD</b>, <b>STAILQ_HEAD_INITIALIZER</b>, <b>STAILQ_INIT</b>,
     <b>STAILQ_INSERT_AFTER</b>, <b>STAILQ_INSERT_HEAD</b>, <b>STAILQ_INSERT_TAIL</b>, <b>STAILQ_LAST</b>, <b>STAILQ_NEXT</b>,
     <b>STAILQ_REMOVE_HEAD</b>, <b>STAILQ_REMOVE</b>, <b>LIST_EMPTY</b>, <b>LIST_ENTRY</b>, <b>LIST_FIRST</b>, <b>LIST_FOREACH</b>, <b>LIST_FOREACH_SAFE</b>,
     <b>LIST_HEAD</b>, <b>LIST_HEAD_INITIALIZER</b>, <b>LIST_INIT</b>, <b>LIST_INSERT_AFTER</b>, <b>LIST_INSERT_BEFORE</b>, <b>LIST_INSERT_HEAD</b>,
     <b>LIST_NEXT</b>, <b>LIST_REMOVE</b>, <b>TAILQ_CONCAT</b>, <b>TAILQ_EMPTY</b>, <b>TAILQ_ENTRY</b>, <b>TAILQ_FIRST</b>, <b>TAILQ_FOREACH</b>,
     <b>TAILQ_FOREACH_SAFE</b>, <b>TAILQ_FOREACH_REVERSE</b>, <b>TAILQ_FOREACH_REVERSE_SAFE</b>, <b>TAILQ_HEAD</b>,
     <b>TAILQ_HEAD_INITIALIZER</b>, <b>TAILQ_INIT</b>, <b>TAILQ_INSERT_AFTER</b>, <b>TAILQ_INSERT_BEFORE</b>, <b>TAILQ_INSERT_HEAD</b>,
     <b>TAILQ_INSERT_TAIL</b>, <b>TAILQ_LAST</b>, <b>TAILQ_NEXT</b>, <b>TAILQ_PREV</b>, <b>TAILQ_REMOVE</b> -- implementations of singly-linked
     lists, singly-linked tail queues, lists and tail queues

<b>SYNOPSIS</b>
     <b>#include</b> <b>&lt;sys/queue.h&gt;</b>

     <b>SLIST_EMPTY</b>(<u>SLIST</u><b>_</b><u>HEAD</u> <u>*head</u>);

     <b>SLIST_ENTRY</b>(<u>TYPE</u>);

     <b>SLIST_FIRST</b>(<u>SLIST</u><b>_</b><u>HEAD</u> <u>*head</u>);

     <b>SLIST_FOREACH</b>(<u>TYPE</u> <u>*var</u>, <u>SLIST</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>SLIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>SLIST_FOREACH_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>SLIST</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>SLIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp</u><b>_</b><u>var</u>);

     <b>SLIST_HEAD</b>(<u>HEADNAME</u>, <u>TYPE</u>);

     <b>SLIST_HEAD_INITIALIZER</b>(<u>SLIST</u><b>_</b><u>HEAD</u> <u>head</u>);

     <b>SLIST_INIT</b>(<u>SLIST</u><b>_</b><u>HEAD</u> <u>*head</u>);

     <b>SLIST_INSERT_AFTER</b>(<u>TYPE</u> <u>*listelm</u>, <u>TYPE</u> <u>*elm</u>, <u>SLIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>SLIST_INSERT_HEAD</b>(<u>SLIST</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>SLIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>SLIST_NEXT</b>(<u>TYPE</u> <u>*elm</u>, <u>SLIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>SLIST_REMOVE_HEAD</b>(<u>SLIST</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>SLIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>SLIST_REMOVE</b>(<u>SLIST</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>TYPE</u>, <u>SLIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>STAILQ_CONCAT</b>(<u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head1</u>, <u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head2</u>);

     <b>STAILQ_EMPTY</b>(<u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>);

     <b>STAILQ_ENTRY</b>(<u>TYPE</u>);

     <b>STAILQ_FIRST</b>(<u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>);

     <b>STAILQ_FOREACH</b>(<u>TYPE</u> <u>*var</u>, <u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>STAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>STAILQ_FOREACH_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>STAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp</u><b>_</b><u>var</u>);

     <b>STAILQ_HEAD</b>(<u>HEADNAME</u>, <u>TYPE</u>);

     <b>STAILQ_HEAD_INITIALIZER</b>(<u>STAILQ</u><b>_</b><u>HEAD</u> <u>head</u>);

     <b>STAILQ_INIT</b>(<u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>);

     <b>STAILQ_INSERT_AFTER</b>(<u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*listelm</u>, <u>TYPE</u> <u>*elm</u>, <u>STAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>STAILQ_INSERT_HEAD</b>(<u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>STAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>STAILQ_INSERT_TAIL</b>(<u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>STAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>STAILQ_LAST</b>(<u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TYPE</u>, <u>STAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>STAILQ_NEXT</b>(<u>TYPE</u> <u>*elm</u>, <u>STAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>STAILQ_REMOVE_HEAD</b>(<u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>STAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>STAILQ_REMOVE</b>(<u>STAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>TYPE</u>, <u>STAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>LIST_EMPTY</b>(<u>LIST</u><b>_</b><u>HEAD</u> <u>*head</u>);

     <b>LIST_ENTRY</b>(<u>TYPE</u>);

     <b>LIST_FIRST</b>(<u>LIST</u><b>_</b><u>HEAD</u> <u>*head</u>);

     <b>LIST_FOREACH</b>(<u>TYPE</u> <u>*var</u>, <u>LIST</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>LIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>LIST_FOREACH_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>LIST</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>LIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp</u><b>_</b><u>var</u>);

     <b>LIST_HEAD</b>(<u>HEADNAME</u>, <u>TYPE</u>);

     <b>LIST_HEAD_INITIALIZER</b>(<u>LIST</u><b>_</b><u>HEAD</u> <u>head</u>);

     <b>LIST_INIT</b>(<u>LIST</u><b>_</b><u>HEAD</u> <u>*head</u>);

     <b>LIST_INSERT_AFTER</b>(<u>TYPE</u> <u>*listelm</u>, <u>TYPE</u> <u>*elm</u>, <u>LIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>LIST_INSERT_BEFORE</b>(<u>TYPE</u> <u>*listelm</u>, <u>TYPE</u> <u>*elm</u>, <u>LIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>LIST_INSERT_HEAD</b>(<u>LIST</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>LIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>LIST_NEXT</b>(<u>TYPE</u> <u>*elm</u>, <u>LIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>LIST_REMOVE</b>(<u>TYPE</u> <u>*elm</u>, <u>LIST</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>TAILQ_CONCAT</b>(<u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head1</u>, <u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head2</u>, <u>TAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>TAILQ_EMPTY</b>(<u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>);

     <b>TAILQ_ENTRY</b>(<u>TYPE</u>);

     <b>TAILQ_FIRST</b>(<u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>);

     <b>TAILQ_FOREACH</b>(<u>TYPE</u> <u>*var</u>, <u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>TAILQ_FOREACH_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp</u><b>_</b><u>var</u>);

     <b>TAILQ_FOREACH_REVERSE</b>(<u>TYPE</u> <u>*var</u>, <u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>HEADNAME</u>, <u>TAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>TAILQ_FOREACH_REVERSE_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>HEADNAME</u>, <u>TAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp</u><b>_</b><u>var</u>);

     <b>TAILQ_HEAD</b>(<u>HEADNAME</u>, <u>TYPE</u>);

     <b>TAILQ_HEAD_INITIALIZER</b>(<u>TAILQ</u><b>_</b><u>HEAD</u> <u>head</u>);

     <b>TAILQ_INIT</b>(<u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>);

     <b>TAILQ_INSERT_AFTER</b>(<u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*listelm</u>, <u>TYPE</u> <u>*elm</u>, <u>TAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>TAILQ_INSERT_BEFORE</b>(<u>TYPE</u> <u>*listelm</u>, <u>TYPE</u> <u>*elm</u>, <u>TAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>TAILQ_INSERT_HEAD</b>(<u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>TAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>TAILQ_INSERT_TAIL</b>(<u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>TAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>TAILQ_LAST</b>(<u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>HEADNAME</u>);

     <b>TAILQ_NEXT</b>(<u>TYPE</u> <u>*elm</u>, <u>TAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>TAILQ_PREV</b>(<u>TYPE</u> <u>*elm</u>, <u>HEADNAME</u>, <u>TAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

     <b>TAILQ_REMOVE</b>(<u>TAILQ</u><b>_</b><u>HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>TAILQ</u><b>_</b><u>ENTRY</u> <u>NAME</u>);

<b>DESCRIPTION</b>
     These macros define and operate on four types of data structures: singly-linked lists, singly-linked
     tail queues, lists, and tail queues.  All four structures support the following functionality:
           1.   Insertion of a new entry at the head of the list.
           2.   Insertion of a new entry after any element in the list.
           3.   <!-- a -->O(1)<!-- /a --> removal of an entry from the head of the list.
           4.   <!-- a -->O(n)<!-- /a --> removal of any entry in the list.
           5.   Forward traversal through the list.

     Singly-linked lists are the simplest of the five data structures and support only the above functional-<font color="#ffffff" class="whiteout">ity.&nbsp;functionality.</font>
     ity.  Singly-linked lists are ideal for applications with large datasets and few or no removals, or for
     implementing a LIFO queue.

     Singly-linked tail queues add the following functionality:
           1.   Entries can be added at the end of a list.
           2.   They may be concatenated.
     However:
           1.   All list insertions must specify the head of the list.
           2.   Each head entry requires two pointers rather than one.
           3.   Code size is about 15% greater and operations run about 20% slower than singly-linked lists.

     Singly-linked tailqs are ideal for applications with large datasets and few or no removals, or for
     implementing a FIFO queue.

     All doubly linked types of data structures (lists and tail queues) additionally allow:
           1.   Insertion of a new entry before any element in the list.
           2.   <!-- a -->O(1)<!-- /a --> removal of any entry in the list.
     However:
           1.   Each elements requires two pointers rather than one.
           2.   Code size and execution time of operations (except for removal) is about twice that of the
                singly-linked data-structures.

     Linked lists are the simplest of the doubly linked data structures and support only the above function-<font color="#ffffff" class="whiteout">ality&nbsp;functionality</font>
     ality over singly-linked lists.

     Tail queues add the following functionality:
           1.   Entries can be added at the end of a list.
           2.   They may be traversed backwards, from tail to head.
           3.   They may be concatenated.
     However:
           1.   All list insertions and removals must specify the head of the list.
           2.   Each head entry requires two pointers rather than one.
           3.   Code size is about 15% greater and operations run about 20% slower than singly-linked lists.

     In the macro definitions, <u>TYPE</u> is the name of a user defined structure, that must contain a field of
     type SLIST_ENTRY, STAILQ_ENTRY, LIST_ENTRY, or TAILQ_ENTRY, named <u>NAME</u>.  The argument <u>HEADNAME</u> is the
     name of a user defined structure that must be declared using the macros SLIST_HEAD, STAILQ_HEAD,
     LIST_HEAD, or TAILQ_HEAD.  See the examples below for further explanation of how these macros are used.

<b>SINGLY-LINKED</b> <b>LISTS</b>
     A singly-linked list is headed by a structure defined by the <b>SLIST_HEAD</b> macro.  This structure contains
     a single pointer to the first element on the list.  The elements are singly linked for minimum space
     and pointer manipulation overhead at the expense of <!-- a -->O(n)<!-- /a --> removal for arbitrary elements.  New elements
     can be added to the list after an existing element or at the head of the list.  An <u>SLIST</u><b>_</b><u>HEAD</u> structure
     is declared as follows:

           SLIST_HEAD(HEADNAME, TYPE) head;

     where <u>HEADNAME</u> is the name of the structure to be defined, and <u>TYPE</u> is the type of the elements to be
     linked into the list.  A pointer to the head of the list can later be declared as:

           struct HEADNAME *headp;

     (The names head and headp are user selectable.)

     The macro <b>SLIST_HEAD_INITIALIZER</b> evaluates to an initializer for the list <u>head</u>.

     The macro <b>SLIST_EMPTY</b> evaluates to true if there are no elements in the list.

     The macro <b>SLIST_ENTRY</b> declares a structure that connects the elements in the list.

     The macro <b>SLIST_FIRST</b> returns the first element in the list or NULL if the list is empty.

     The macro <b>SLIST_FOREACH</b> traverses the list referenced by <u>head</u> in the forward direction, assigning each
     element in turn to <u>var</u>.

     The macro <b>SLIST_FOREACH_SAFE</b> traverses the list referenced by <u>head</u> in the forward direction, assigning
     each element in turn to <u>var</u>.  However, unlike <b>SLIST_FOREACH</b>() here it is permitted to both remove <u>var</u>
     as well as free it from within the loop safely without interfering with the traversal.

     The macro <b>SLIST_INIT</b> initializes the list referenced by <u>head</u>.

     The macro <b>SLIST_INSERT_HEAD</b> inserts the new element <u>elm</u> at the head of the list.

     The macro <b>SLIST_INSERT_AFTER</b> inserts the new element <u>elm</u> after the element <u>listelm</u>.

     The macro <b>SLIST_NEXT</b> returns the next element in the list.

     The macro <b>SLIST_REMOVE_HEAD</b> removes the element <u>elm</u> from the head of the list.  For optimum efficiency,
     elements being removed from the head of the list should explicitly use this macro instead of the
     generic <u>SLIST</u><b>_</b><u>REMOVE</u> macro.

     The macro <b>SLIST_REMOVE</b> removes the element <u>elm</u> from the list.

<b>SINGLY-LINKED</b> <b>LIST</b> <b>EXAMPLE</b>
     SLIST_HEAD(slisthead, entry) head =
         SLIST_HEAD_INITIALIZER(head);
     struct slisthead *headp;                /* Singly-linked List head. */
     struct entry {
             ...
             SLIST_ENTRY(entry) entries;     /* Singly-linked List. */
             ...
     } *n1, *n2, *n3, *np;

     SLIST_INIT(&amp;head);                      /* Initialize the list. */

     n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
     SLIST_INSERT_HEAD(&amp;head, n1, entries);

     n2 = malloc(sizeof(struct entry));      /* Insert after. */
     SLIST_INSERT_AFTER(n1, n2, entries);

     SLIST_REMOVE(&amp;head, n2, entry, entries);/* Deletion. */
     free(n2);

     n3 = SLIST_FIRST(&amp;head);
     SLIST_REMOVE_HEAD(&amp;head, entries);      /* Deletion from the head. */
     free(n3);
                                             /* Forward traversal. */
     SLIST_FOREACH(np, &amp;head, entries)
             np-&gt; ...
                                             /* Safe forward traversal. */
     SLIST_FOREACH_SAFE(np, &amp;head, entries, np_temp) {
             np-&gt;do_stuff();
             ...
             SLIST_REMOVE(&amp;head, np, entry, entries);
             free(np);
     }

     while (!SLIST_EMPTY(&amp;head)) {           /* List Deletion. */
             n1 = SLIST_FIRST(&amp;head);
             SLIST_REMOVE_HEAD(&amp;head, entries);
             free(n1);
     }

<b>SINGLY-LINKED</b> <b>TAIL</b> <b>QUEUES</b>
     A singly-linked tail queue is headed by a structure defined by the <b>STAILQ_HEAD</b> macro.  This structure
     contains a pair of pointers, one to the first element in the tail queue and the other to the last ele-<font color="#ffffff" class="whiteout">ment&nbsp;element</font>
     ment in the tail queue.  The elements are singly linked for minimum space and pointer manipulation
     overhead at the expense of <!-- a -->O(n)<!-- /a --> removal for arbitrary elements.  New elements can be added to the tail
     queue after an existing element, at the head of the tail queue, or at the end of the tail queue.  A
     <u>STAILQ</u><b>_</b><u>HEAD</u> structure is declared as follows:

           STAILQ_HEAD(HEADNAME, TYPE) head;

     where HEADNAME is the name of the structure to be defined, and TYPE is the type of the elements to be
     linked into the tail queue.  A pointer to the head of the tail queue can later be declared as:

           struct HEADNAME *headp;

     (The names head and headp are user selectable.)

     The macro <b>STAILQ_HEAD_INITIALIZER</b> evaluates to an initializer for the tail queue <u>head</u>.

     The macro <b>STAILQ_CONCAT</b> concatenates the tail queue headed by <u>head2</u> onto the end of the one headed by
     <u>head1</u> removing all entries from the former.

     The macro <b>STAILQ_EMPTY</b> evaluates to true if there are no items on the tail queue.

     The macro <b>STAILQ_ENTRY</b> declares a structure that connects the elements in the tail queue.

     The macro <b>STAILQ_FIRST</b> returns the first item on the tail queue or NULL if the tail queue is empty.

     The macro <b>STAILQ_FOREACH</b> traverses the tail queue referenced by <u>head</u> in the forward direction, assign-<font color="#ffffff" class="whiteout">ing&nbsp;assigning</font>
     ing each element in turn to <u>var</u>.

     The macro <b>STAILQ_FOREACH_SAFE</b> traverses the tail queue referenced by <u>head</u> in the forward direction,
     assigning each element in turn to <u>var</u>.  However, unlike <b>STAILQ_FOREACH</b>() here it is permitted to both
     remove <u>var</u> as well as free it from within the loop safely without interfering with the traversal.

     The macro <b>STAILQ_INIT</b> initializes the tail queue referenced by <u>head</u>.

     The macro <b>STAILQ_INSERT_HEAD</b> inserts the new element <u>elm</u> at the head of the tail queue.

     The macro <b>STAILQ_INSERT_TAIL</b> inserts the new element <u>elm</u> at the end of the tail queue.

     The macro <b>STAILQ_INSERT_AFTER</b> inserts the new element <u>elm</u> after the element <u>listelm</u>.

     The macro <b>STAILQ_LAST</b> returns the last item on the tail queue.  If the tail queue is empty the return
     value is NULL.

     The macro <b>STAILQ_NEXT</b> returns the next item on the tail queue, or NULL this item is the last.

     The macro <b>STAILQ_REMOVE_HEAD</b> removes the element at the head of the tail queue.  For optimum effi-<font color="#ffffff" class="whiteout">ciency,&nbsp;efficiency,</font>
     ciency, elements being removed from the head of the tail queue should use this macro explicitly rather
     than the generic <u>STAILQ</u><b>_</b><u>REMOVE</u> macro.

     The macro <b>STAILQ_REMOVE</b> removes the element <u>elm</u> from the tail queue.

<b>SINGLY-LINKED</b> <b>TAIL</b> <b>QUEUE</b> <b>EXAMPLE</b>
     STAILQ_HEAD(stailhead, entry) head =
         STAILQ_HEAD_INITIALIZER(head);
     struct stailhead *headp;                /* Singly-linked tail queue head. */
     struct entry {
             ...
             STAILQ_ENTRY(entry) entries;    /* Tail queue. */
             ...
     } *n1, *n2, *n3, *np;

     STAILQ_INIT(&amp;head);                     /* Initialize the queue. */

     n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
     STAILQ_INSERT_HEAD(&amp;head, n1, entries);

     n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */
     STAILQ_INSERT_TAIL(&amp;head, n1, entries);

     n2 = malloc(sizeof(struct entry));      /* Insert after. */
     STAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);
                                             /* Deletion. */
     STAILQ_REMOVE(&amp;head, n2, entry, entries);
     free(n2);
                                             /* Deletion from the head. */
     n3 = STAILQ_FIRST(&amp;head);
     STAILQ_REMOVE_HEAD(&amp;head, entries);
     free(n3);
                                             /* Forward traversal. */
     STAILQ_FOREACH(np, &amp;head, entries)
             np-&gt; ...
                                             /* Safe forward traversal. */
     STAILQ_FOREACH_SAFE(np, &amp;head, entries, np_temp) {
             np-&gt;do_stuff();
             ...
             STAILQ_REMOVE(&amp;head, np, entry, entries);
             free(np);
     }
                                             /* TailQ Deletion. */
     while (!STAILQ_EMPTY(&amp;head)) {
             n1 = STAILQ_FIRST(&amp;head);
             STAILQ_REMOVE_HEAD(&amp;head, entries);
             free(n1);
     }
                                             /* Faster TailQ Deletion. */
     n1 = STAILQ_FIRST(&amp;head);
     while (n1 != NULL) {
             n2 = STAILQ_NEXT(n1, entries);
             free(n1);
             n1 = n2;
     }
     STAILQ_INIT(&amp;head);

<b>LISTS</b>
     A list is headed by a structure defined by the <b>LIST_HEAD</b> macro.  This structure contains a single
     pointer to the first element on the list.  The elements are doubly linked so that an arbitrary element
     can be removed without traversing the list.  New elements can be added to the list after an existing
     element, before an existing element, or at the head of the list.  A <u>LIST</u><b>_</b><u>HEAD</u> structure is declared as
     follows:

           LIST_HEAD(HEADNAME, TYPE) head;

     where <u>HEADNAME</u> is the name of the structure to be defined, and <u>TYPE</u> is the type of the elements to be
     linked into the list.  A pointer to the head of the list can later be declared as:

           struct HEADNAME *headp;

     (The names head and headp are user selectable.)

     The macro <b>LIST_HEAD_INITIALIZER</b> evaluates to an initializer for the list <u>head</u>.

     The macro <b>LIST_EMPTY</b> evaluates to true if there are no elements in the list.

     The macro <b>LIST_ENTRY</b> declares a structure that connects the elements in the list.

     The macro <b>LIST_FIRST</b> returns the first element in the list or NULL if the list is empty.

     The macro <b>LIST_FOREACH</b> traverses the list referenced by <u>head</u> in the forward direction, assigning each
     element in turn to <u>var</u>.

     The macro <b>LIST_FOREACH_SAFE</b> traverses the list referenced by <u>head</u> in the forward direction, assigning
     each element in turn to <u>var</u>.  However, unlike <b>LIST_FOREACH</b>() here it is permitted to both remove <u>var</u> as
     well as free it from within the loop safely without interfering with the traversal.

     The macro <b>LIST_INIT</b> initializes the list referenced by <u>head</u>.

     The macro <b>LIST_INSERT_HEAD</b> inserts the new element <u>elm</u> at the head of the list.

     The macro <b>LIST_INSERT_AFTER</b> inserts the new element <u>elm</u> after the element <u>listelm</u>.

     The macro <b>LIST_INSERT_BEFORE</b> inserts the new element <u>elm</u> before the element <u>listelm</u>.

     The macro <b>LIST_NEXT</b> returns the next element in the list, or NULL if this is the last.

     The macro <b>LIST_REMOVE</b> removes the element <u>elm</u> from the list.

<b>LIST</b> <b>EXAMPLE</b>
     LIST_HEAD(listhead, entry) head =
         LIST_HEAD_INITIALIZER(head);
     struct listhead *headp;                 /* List head. */
     struct entry {
             ...
             LIST_ENTRY(entry) entries;      /* List. */
             ...
     } *n1, *n2, *n3, *np, *np_temp;

     LIST_INIT(&amp;head);                       /* Initialize the list. */

     n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
     LIST_INSERT_HEAD(&amp;head, n1, entries);

     n2 = malloc(sizeof(struct entry));      /* Insert after. */
     LIST_INSERT_AFTER(n1, n2, entries);

     n3 = malloc(sizeof(struct entry));      /* Insert before. */
     LIST_INSERT_BEFORE(n2, n3, entries);

     LIST_REMOVE(n2, entries);               /* Deletion. */
     free(n2);
                                             /* Forward traversal. */
     LIST_FOREACH(np, &amp;head, entries)
             np-&gt; ...

                                             /* Safe forward traversal. */
     LIST_FOREACH_SAFE(np, &amp;head, entries, np_temp) {
             np-&gt;do_stuff();
             ...
             LIST_REMOVE(np, entries);
             free(np);
     }

     while (!LIST_EMPTY(&amp;head)) {            /* List Deletion. */
             n1 = LIST_FIRST(&amp;head);
             LIST_REMOVE(n1, entries);
             free(n1);
     }

     n1 = LIST_FIRST(&amp;head);                 /* Faster List Deletion. */
     while (n1 != NULL) {
             n2 = LIST_NEXT(n1, entries);
             free(n1);
             n1 = n2;
     }
     LIST_INIT(&amp;head);

<b>TAIL</b> <b>QUEUES</b>
     A tail queue is headed by a structure defined by the <b>TAILQ_HEAD</b> macro.  This structure contains a pair
     of pointers, one to the first element in the tail queue and the other to the last element in the tail
     queue.  The elements are doubly linked so that an arbitrary element can be removed without traversing
     the tail queue.  New elements can be added to the tail queue after an existing element, before an
     existing element, at the head of the tail queue, or at the end of the tail queue.  A <u>TAILQ</u><b>_</b><u>HEAD</u> struc-<font color="#ffffff" class="whiteout">ture&nbsp;structure</font>
     ture is declared as follows:

           TAILQ_HEAD(HEADNAME, TYPE) head;

     where HEADNAME is the name of the structure to be defined, and TYPE is the type of the elements to be
     linked into the tail queue.  A pointer to the head of the tail queue can later be declared as:

           struct HEADNAME *headp;

     (The names head and headp are user selectable.)

     The macro <b>TAILQ_HEAD_INITIALIZER</b> evaluates to an initializer for the tail queue <u>head</u>.

     The macro <b>TAILQ_CONCAT</b> concatenates the tail queue headed by <u>head2</u> onto the end of the one headed by
     <u>head1</u> removing all entries from the former.

     The macro <b>TAILQ_EMPTY</b> evaluates to true if there are no items on the tail queue.

     The macro <b>TAILQ_ENTRY</b> declares a structure that connects the elements in the tail queue.

     The macro <b>TAILQ_FIRST</b> returns the first item on the tail queue or NULL if the tail queue is empty.

     The macro <b>TAILQ_FOREACH</b> traverses the tail queue referenced by <u>head</u> in the forward direction, assigning
     each element in turn to <u>var</u>.  <u>var</u> is set to NULL if the loop completes normally, or if there were no
     elements.

     The macro <b>TAILQ_FOREACH_REVERSE</b> traverses the tail queue referenced by <u>head</u> in the reverse direction,
     assigning each element in turn to <u>var</u>.

     The macros <b>TAILQ_FOREACH_SAFE</b> and <b>TAILQ_FOREACH_REVERSE_SAFE</b> traverse the list referenced by <u>head</u> in
     the forward or reverse direction respectively, assigning each element in turn to <u>var</u>.  However, unlike
     their unsafe counterparts, <b>TAILQ_FOREACH</b> and <b>TAILQ_FOREACH_REVERSE</b> permit to both remove <u>var</u> as well as
     free it from within the loop safely without interfering with the traversal.

     The macro <b>TAILQ_INIT</b> initializes the tail queue referenced by <u>head</u>.

     The macro <b>TAILQ_INSERT_HEAD</b> inserts the new element <u>elm</u> at the head of the tail queue.

     The macro <b>TAILQ_INSERT_TAIL</b> inserts the new element <u>elm</u> at the end of the tail queue.

     The macro <b>TAILQ_INSERT_AFTER</b> inserts the new element <u>elm</u> after the element <u>listelm</u>.

     The macro <b>TAILQ_INSERT_BEFORE</b> inserts the new element <u>elm</u> before the element <u>listelm</u>.

     The macro <b>TAILQ_LAST</b> returns the last item on the tail queue.  If the tail queue is empty the return
     value is NULL.

     The macro <b>TAILQ_NEXT</b> returns the next item on the tail queue, or NULL if this item is the last.

     The macro <b>TAILQ_PREV</b> returns the previous item on the tail queue, or NULL if this item is the first.

     The macro <b>TAILQ_REMOVE</b> removes the element <u>elm</u> from the tail queue.

<b>TAIL</b> <b>QUEUE</b> <b>EXAMPLE</b>
     TAILQ_HEAD(tailhead, entry) head =
         TAILQ_HEAD_INITIALIZER(head);
     struct tailhead *headp;                 /* Tail queue head. */
     struct entry {
             ...
             TAILQ_ENTRY(entry) entries;     /* Tail queue. */
             ...
     } *n1, *n2, *n3, *np;

     TAILQ_INIT(&amp;head);                      /* Initialize the queue. */

     n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
     TAILQ_INSERT_HEAD(&amp;head, n1, entries);

     n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */
     TAILQ_INSERT_TAIL(&amp;head, n1, entries);

     n2 = malloc(sizeof(struct entry));      /* Insert after. */
     TAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);

     n3 = malloc(sizeof(struct entry));      /* Insert before. */
     TAILQ_INSERT_BEFORE(n2, n3, entries);

     TAILQ_REMOVE(&amp;head, n2, entries);       /* Deletion. */
     free(n2);
                                             /* Forward traversal. */
     TAILQ_FOREACH(np, &amp;head, entries)
             np-&gt; ...
                                             /* Safe forward traversal. */
     TAILQ_FOREACH_SAFE(np, &amp;head, entries, np_temp) {
             np-&gt;do_stuff();
             ...
             TAILQ_REMOVE(&amp;head, np, entries);
             free(np);
     }
                                             /* Reverse traversal. */
     TAILQ_FOREACH_REVERSE(np, &amp;head, tailhead, entries)
             np-&gt; ...
                                             /* TailQ Deletion. */
     while (!TAILQ_EMPTY(&amp;head)) {
             n1 = TAILQ_FIRST(&amp;head);
             TAILQ_REMOVE(&amp;head, n1, entries);
             free(n1);
     }
                                             /* Faster TailQ Deletion. */
     n1 = TAILQ_FIRST(&amp;head);
     while (n1 != NULL) {
             n2 = TAILQ_NEXT(n1, entries);
             free(n1);
             n1 = n2;
     }
     TAILQ_INIT(&amp;head);

<b>HISTORY</b>
     The <b>queue</b> functions first appeared in 4.4BSD.

BSD                            January 24, 1994                            BSD
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/TAILQ_INIT.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/TAILQ_INIT.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/TAILQ_INIT.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
