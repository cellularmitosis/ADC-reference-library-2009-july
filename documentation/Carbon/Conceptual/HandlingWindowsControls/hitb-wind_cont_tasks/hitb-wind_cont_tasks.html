<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Handling Carbon Windows and Controls: Window and Control Tasks</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Window and Control Tasks"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001004-CH206" title="Window and Control Tasks"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../UserExperience-date.html#//apple_ref/doc/uid/TP30000440-TP30000420-TP30000465" target="_top">User Experience</a> &gt; <a href="../hitb-wind_cont_intro/hitb-wind_cont_intro.html#//apple_ref/doc/uid/TP30001004-CH204-DontLinkElementID_93">Handling Carbon Windows and Controls</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../hitb-wind_cont_concept/hitb-wind_cont_concept.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../hitb-apdx_a_msgs/hitb-apdx_a_msgs.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_94" title="Window and Control Tasks"></a><h1><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF101" title="Window and Control Tasks"></a>Window and Control Tasks</h1><p>This chapter describes how to implement windows and controls in your application using one of the following methods:</p><ul class="ul"><li class="li"><p>By creating nib files using Interface Builder. This method is the most straightforward and intuitive. If you are a new developer or want to minimize the amount of programming you need to do, you should choose this option. Nib file support is easy to add to older applications, so you should consider this option even if you are working with legacy code. </p></li><li class="li"><p>By calling various Window Manager, Control Manager, and Dialog Manager functions. This method gives you more control, but in most cases it is a lot more work than creating nib files and requires more knowledge on your part. </p></li></ul><p>Several sections also describe commonly used Control Manager and Window Manager functions, as well as functions that reproduce features found in Interface Builder. In addition, this chapter includes implementation details about special features such as</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-TPXREF173">“Adding Window Proxy Icons”</a></span></p></li><li class="li"><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIHHBAB">“Window Groups (Mac OS X Only)”</a></span></p></li><li class="li"><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIHIBJA">“Manipulating Drawers (Mac OS X 10.2 and later)”</a></span></p></li><li class="li"><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-CJBCBCJF">“Live Scrolling”</a></span></p></li><li class="li"><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-CJBIECCF">“Using Tab Controls”</a></span></p></li><li class="li"><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIBBCBG">“Custom Windows and Controls”</a></span></p></li></ul><p>In addition, if you are interested in learning more about the new object-oriented model that underlies all Carbon user interface elements, see <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGBJHE">“Introducing HIObject and HIView (Mac OS X 10. 2 and Later).”</a></span>)</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_95" title="Note"></a><p><strong>Note:</strong>&nbsp;Unless specifically indicated otherwise, all the functions described in this section belong to either the Window Manager or Control Manager. </p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-TPXREF120">Using Interface Builder</a>
				
			<br/>
			
        
			
			
				<a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIIEDHF">Handling Events</a>
				
			<br/>
			
        
			
			
				<a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-TPXREF147">Calling Functions to Create Windows and Controls</a>
				
			<br/>
			
        
			
			
				<a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-TPXREF156">Basic Window Manipulation</a>
				
			<br/>
			
        
			
			
				<a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-TPXREF162">Basic Control Manipulation</a>
				
			<br/>
			
        
			
			
				<a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-TPXREF168">Control Implementation Examples</a>
				
			<br/>
			
        
			
			
				<a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIBBCBG">Custom Windows and Controls</a>
				
			<br/>
			
        
			
			
				<a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGBJHE">Introducing HIObject and HIView (Mac OS X 10. 2 and Later)</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF120" title="Using Interface Builder"></a><h2>Using Interface Builder</h2><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_388"></a>Interface Builder is Apple’s graphical user interface layout tool. In true WYSIWYG fashion, you simply drag user interface elements onto windows, menus, and controls to create your interfaces. This information is stored in a <strong>nib file</strong>, which your application can access using a few simple function calls. </p><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_389"></a>Interface Builder has many advantages over other layout methods:</p><ul class="ul"><li class="li"><p>The WYSIWYG interface makes it easy to visualize your interface objects.</p></li><li class="li"><p>Its ease of use allows for experimenting and rapid prototyping.</p></li><li class="li"><p>Special guides makes it easy to conform to Aqua’s layout guidelines.</p></li><li class="li"><p>Simple APIs make it easy to create interface objects from nib files. </p></li></ul><div class="importantbox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_96" title="Important:"></a><p><strong>Important:</strong>&nbsp;Interface Builder is often associated with Project Builder, Apple’s development environment. However, you do not need Project Builder to take advantage of Interface Builder’s nib files. </p><p></p></div><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_390"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_391"></a>You can use Interface Builder’s nib files even if you are working with legacy code. Applications can support both nib-based and older resource-based windows and controls at the same time, so you can make the transition as gradual as you like. Nib file support is available back to Mac OS 8.6 using CarbonLib. </p><p>Interface Builder is included on the Developer Tools CD available with Mac OS X. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_97" title="Note"></a><p><strong>Note:</strong>&nbsp;Although Interface Builder lets you create menus as well as windows and controls, this document focuses only on the latter elements.</p></div><p>Interface Builder also makes it easy to associate controls and windows with Carbon event handlers, again minimizing the amount of work required to implement your user interface. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF121" title="The Nib File"></a><h3>The Nib File</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_392"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_393"></a>Interface Builder stores all the information about your application’s windows, menus, and controls in a nib file (typically named <em>filename</em>.<em>nib</em> ). When creating a new file, Interface Builder gives you the option of selecting what type of nib file you want to create. When creating interfaces for Carbon applications, you should always select one of the Carbon options, as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCICGGAA">Figure 3-1</a></span>. </p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_98" title="Figure 2-1Opening dialog for new nib files"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCICGGAA" title="Figure 2-1Opening dialog for new nib files"></a><strong>Figure 2-1&nbsp;&nbsp;</strong>Opening dialog for new nib files</p><img src = "../art/newnibstart.gif" alt = "Opening dialog for new nib files" width="286" height="300"></div><br/><p>Interface Builder always displays the windows shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIFCEAD">Figure 3-2</a></span> for an open nib file.</p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_99" title="Figure 2-2Nib file windows"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIFCEAD" title="Figure 2-2Nib file windows"></a><strong>Figure 2-2&nbsp;&nbsp;</strong>Nib file windows</p><img src = "../art/nibwindows.gif" alt = "Nib file windows" width="551" height="257"></div><br/><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_394"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_395"></a>The main nib window. This window contains two panes: Instances and Images. The Instances pane displays icons representing the interface objects (windows, menus, and so on) in your nib file. The Images pane shows the images that are available for you to use in your interface. </p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_396"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_397"></a>The palettes window. For Carbon applications, the palettes window holds all the interface objects that you can add to your application. You select a palette by clicking in the top toolbar, and then you can add objects by dragging them to your interface. </p></li></ul><p>If you chose to create a particular interface object (menu bar, dialog, or window) in the opening dialog, Interface Builder also creates empty versions of the objects.</p><p>For example, to create a simple dialog you can do the following:</p><ul class="spaceabove"><li class="li"><p>Open a new empty nib file.</p></li><li class="li"><p>Select the Windows palette in the palettes window toolbar, and drag out an empty window. </p></li><li class="li"><p>Select the Controls palette and drag a static text field and a button to the empty window. </p></li></ul><p>Laying out your window is essentially as simple as dragging and placing the interface objects you want.</p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF122" title="The Layout Palettes"></a><h3>The Layout Palettes</h3><p>For Carbon applications, Interface Builder provides five different layout palettes, which are displayed in the Carbon palettes window. If the window is not already open, you can do so by choosing Palettes from Interface Builder’s Tools menu. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_100" title="Note"></a><p><strong>Note:</strong>&nbsp;The Carbon layout palettes differ from those used for Cocoa applications.. Make sure that you select a Carbon-based nib when creating a new nib file. </p></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF123" title="The Menus Palette"></a><h4>The Menus Palette</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_398"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_399"></a>The Menus palette allows you to build menus. Although it is not covered in this document, Interface Builder lets you build menus using the same simple drag-and-drop method you use for creating windows. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF124" title="The Controls Palette"></a><h4>The Controls Palette</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_400"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_401"></a>The Controls palette, as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGGCIH">Figure 3-3</a></span>, contains the most commonly used controls. </p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_101" title="Figure 2-3The Controls palette"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIGGCIH" title="Figure 2-3The Controls palette"></a><strong>Figure 2-3&nbsp;&nbsp;</strong>The Controls palette</p><img src = "../art/controlspalette.gif" alt = "The Controls palette" width="265" height="205"></div><br/><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF125" title="The Enhanced Controls Palette"></a><h4>The Enhanced Controls Palette</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_402"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_403"></a>The Enhanced Controls palette, shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGFAHC">Figure 3-4</a></span>, contains more specialized controls, many of which are used in combination with other controls. For example, the separator lines are used to isolate controls from each other. </p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_102" title="Figure 2-4The Enhanced Controls palette"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIGFAHC" title="Figure 2-4The Enhanced Controls palette"></a><strong>Figure 2-4&nbsp;&nbsp;</strong>The Enhanced Controls palette</p><img src = "../art/othercntrlpalette.gif" alt = "The Enhanced Controls palette" width="265" height="201"></div><br/><p>The PICT box is used as a container for an image you want to add to the interface. You use the custom box to place a custom (that is, application-defined) control. See <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIBBCBG">“Custom Windows and Controls”</a></span> for information about creating custom controls. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF126" title="The Data Views Palette"></a><h4>The Data Views Palette</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_404"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_405"></a>The Data Views palette, shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIBJBEB">Figure 3-5</a></span>, contains special controls that are specifically designed to organize information for the user in list or column format. </p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_103" title="Figure 2-5The Data Views palette"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIBJBEB" title="Figure 2-5The Data Views palette"></a><strong>Figure 2-5&nbsp;&nbsp;</strong>The Data Views palette</p><img src = "../art/dataviewpalette.gif" alt = "The Data Views palette" width="354" height="263"></div><br/><p>The table viewer and browser are subsets of the data browser control, while the tabs are simply a tab control paired with panes. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF127" title="The Windows Palette"></a><h4>The Windows Palette</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_406"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_407"></a>The Windows palette, shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIFIEAI">Figure 3-6</a></span>, holds windows that you can use to interact with the user.</p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_104" title="Figure 2-6The windows palette"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIFIEAI" title="Figure 2-6The windows palette"></a><strong>Figure 2-6&nbsp;&nbsp;</strong>The windows palette</p><img src = "../art/windowpalette.gif" alt = "The windows palette" width="263" height="198"></div><br/><p>The standard window (containing the close, minimize, and zoom buttons) should be used for documents, dialogs, and any other windows that the user can close or minimize. </p><p>The buttonless window should be used for windows that must remain open while the application is running (such as a status window), or those that are dismissed in other ways, such as an alert. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF128" title="The Info Window"></a><h3>The Info Window</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_408"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_409"></a>Aside from the palettes, the Interface Builder window you will use the most is the Info window, which displays information about the currently selected object (such as a window or control) and lets you set attributes and other information that determine how the object behaves and appears to the user. </p><p>To display the Info window, choose the Show Info menu item in the Tools menu of Interface Builder. </p><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIFJDCG">Figure 3-7</a></span> shows an Info window for a window object. </p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_105" title="Figure 2-7The Info window for a window object"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIFJDCG" title="Figure 2-7The Info window for a window object"></a><strong>Figure 2-7&nbsp;&nbsp;</strong>The Info window for a window object</p><img src = "../art/infowindow.gif" alt = "The Info window for a window object" width="238" height="345"></div><br/><p>The pop-up menu at the top of the Info window lets you choose between four different panes:</p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_410"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_411"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_412"></a>Attributes. Controls in this pane let you set the display or behavior characteristics of the interface object. For windows, for example, you can set the window title and window class, among other attributes. For controls, attributes vary depending on the control. For example, for a checkbox, you can set the title, the initial state (checked, unchecked, and so on), and whether it should toggle automatically. </p></li><li class="li"><p>Control. This pane lets you set control-specific attributes, such as control IDs and command IDs. See <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-TPXREF130">“Designing a Simple Preferences Window”</a></span> for an example of its usage. This pane doesn’t apply for windows. </p></li><li class="li"><p>Size. This pane lets you adjust the size and position of the interface object with pixel accuracy, which is often more convenient than trying to size or align objects by eye. </p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_413"></a>Help. This pane lets you enter optional help tag text as well as the position in which the tag appears. Help tags are the little yellow pop-up fields that appear near a control or window when the user hovers the cursor over it for a few seconds. This pane provides a much simpler way to add help tags than making calls from your application. </p></li></ul><p>The available selections vary depending on which interface object you have selected. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF129" title="The Layout Menu and the Aqua Guides "></a><h3>The Layout Menu and the Aqua Guides </h3><p>Although Interface Builder lets you manually drag and place interface components into your windows, it also provides tools for more precise placement. </p><p>The Alignment submenu in the Layout menu (as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIFDFHG">Figure 3-8</a></span>) lets you align groups of objects by their edges or centers. </p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_106" title="Figure 2-8The Alignment submenu "></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIFDFHG" title="Figure 2-8The Alignment submenu "></a><strong>Figure 2-8&nbsp;&nbsp;</strong>The Alignment submenu </p><img src = "../art/alignmenu.gif" alt = "The Alignment submenu" width="378" height="328"></div><br/><p>For more sophisticated layout options, you can choose the <a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_414"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_415"></a>Alignment panel (chosen from the Alignment submenu) as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIEGJGG">Figure 3-9</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_107" title="Figure 2-9The Alignment panel"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIEGJGG" title="Figure 2-9The Alignment panel"></a><strong>Figure 2-9&nbsp;&nbsp;</strong>The Alignment panel</p><img src = "../art/alignpalette.gif" alt = "The Alignment panel" width="158" height="199"></div><br/><ul class="spaceabove"><li class="li"><p>By using the Align controls, you can align the selected controls to a particular edge, or center them. Choose the type of alignment from the pop-up menu and then use the bevel buttons for the actual placement. Each button has help tags that provide additional information. </p></li><li class="li"><p>The Spread controls let you space the selected controls evenly between themselves or across the container (the window, group box, pane, and so on) that holds them. Each button has help tags. </p></li><li class="li"><p>The Offset controls let you space controls with a given offset. Each button has help tags.</p></li></ul><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_416"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_417"></a>In addition, Interface Builder also provides special Aqua guides, which you can use to make sure your window conforms to the Aqua placement guidelines. For example, when dragging a control near the edge of a window, dotted blue lines appear indicating the proper placement for Aqua compliance. Releasing the control makes it snap to the specified placement. <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIIJHDI">Figure 3-10</a></span> shows the Aqua guides suggesting the proper placement for a checkbox. </p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_108" title="Figure 2-10Aqua guides"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIIJHDI" title="Figure 2-10Aqua guides"></a><strong>Figure 2-10&nbsp;&nbsp;</strong>Aqua guides</p><img src = "../art/aquaguides.gif" alt = "Aqua guides" width="226" height="167"></div><br/><p>The Guides submenu in the Layout menu contains options for the Aqua guides. </p><ul class="spaceabove"><li class="li"><p>Show/Hide Guides enables or disables both custom and Aqua guides. </p></li><li class="li"><p>Lock Guides locks any custom guides you have placed so they cannot be moved. </p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_418"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_419"></a>Add Horizontal/Vertical Guides creates custom guides (designated by unbroken blue lines), which you can position as needed. These guides are useful if you want to align objects to some arbitrary position. </p></li><li class="li"><p>Enable/Disable Aqua Guidelines enables or disables only the Aqua guides. </p></li></ul><div class="importantbox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_109" title="Important:"></a><p><strong>Important:</strong>&nbsp;Although the Aqua guides can simplify layout of your windows and dialogs, you should not rely on them as a substitute for reading the Aqua human interface guidelines. The Aqua look-and-feel contains subtleties that the Aqua guides may not be able to predict. </p><p></p></div><p>Finally, there are additional commands available in the Layout menu that you might find useful:</p><ul class="spaceabove"><li class="li"><p>Bring to Front and Send to Back rearrange the order of controls in the interface.</p></li><li class="li"><p>Same Size ensures that two objects have exactly the same dimensions. Using this command is simpler than typing in sizes and much more accurate than trying to size by eye. </p></li><li class="li"><p>Size to Fit is often useful for objects that contain text. Choosing Size to Fit makes the object large enough to fit the text and also ensures that the space around the text complies with the Aqua human interface guidelines. </p></li><li class="li"><p>Transpose changes rows to columns and vice versa. You can use this command for radio button groups. </p></li><li class="li"><p>Group lets you embed two or more objects in a container such as a pane or a group box. This command is handy when you have already created a number of containers and then decide you want to group some of them together. </p></li></ul><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF130" title="Designing a Simple Preferences Window"></a><h3>Designing a Simple Preferences Window</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_420"></a>This section gives a step-by-step example of how you would lay out a window in Interface Builder. While not particularly complex, the ideas and methods used here apply to any type of window. </p><p>This example creates a preferences window containing a few checkboxes and radio buttons, along with push buttons that allow the user to save or cancel the preferences. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF131" title="Creating the Window"></a><h4>Creating the Window</h4><p>To create the initial window, you can either select a Carbon window or dialog when creating a new nib file (as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCICGGAA">Figure 3-1</a></span>) or drag a window from the Windows palette of an existing nib file. By bringing up the Info window and choosing the Attributes pane (using the pop-up menu), you can do the following:</p><ul class="spaceabove"><li class="li"><p>Set the window’s title to “MyGuitar Preferences” (or whatever you choose).</p></li><li class="li"><p>Make sure the window’s class is set to Document. (Normal dialogs and document windows both share this window.)</p></li><li class="li"><p>Set the Theme Brush to Dialog.</p></li><li class="li"><p>Make sure the you choose Alert Position in the Position pop-up menu. </p></li><li class="li"><p>As this is a dialog, you don’t need any of the standard document window buttons, so make sure the Close, Zoom, Minimize, and Toolbar checkboxes in the Buttons group are unselected. </p></li><li class="li"><p>The dialog does not need to be resizable, so the Resizable checkbox should not be selected. In fact, the only option in the Attribute group that should be selected is the<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_421"></a> Standard Handler, as that simplifies the event handling code. </p></li><li class="li"><p>The Receives options (signifying update events and activate events) should both be selected. </p></li></ul><p>In the Size pane, set the size of the window to be 175 pixels high and 480 pixels wide. </p><p>Finally, in the Instances pane of the nib file, double-click the text below the window’s icon and assign it a unique name (such as “GuitarPrefs”). This is the name that an application uses to load the window from the nib file. </p><p>Your simple dialog should now look like <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIHGIIB">Figure 3-11</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_110" title="Figure 2-11An empty dialog"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIHGIIB" title="Figure 2-11An empty dialog"></a><strong>Figure 2-11&nbsp;&nbsp;</strong>An empty dialog</p><img src = "../art/blankdialog.gif" alt = "An empty dialog" width="265" height="250"></div><br/><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF132" title="Adding Controls"></a><h4>Adding Controls</h4><p>Most Preferences dialogs (and many dialogs in general) contain push buttons in the lower-right corner: OK to close the dialog, accepting any changes that were made, and Cancel, which closes without accepting changes. To add these buttons, drag two push button objects from the Controls palette to your window. If you have the Aqua guides turned on, they indicate the proper placement in the lower-right corner. </p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_111" title="Figure 2-12Using the Aqua guides to place push buttons "></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF172" title="Figure 2-12Using the Aqua guides to place push buttons "></a><strong>Figure 2-12&nbsp;&nbsp;</strong>Using the Aqua guides to place push buttons </p><img src = "../art/addbutton.gif" alt = "Using the Aqua guides to place push buttons" width="425" height="239"></div><br/><p>After placing the buttons, you can specify the following using the Attributes pane of the Info window:</p><ul class="spaceabove"><li class="li"><p>Change the titles of the buttons to “OK” and “Cancel.”</p></li><li class="li"><p>Change the button type of the OK button to Default by selecting the appropriate radio button under Button Type. As the default button , the button pulses blue and the user can trigger it by pressing the Return or Enter keys. </p></li><li class="li"><p>Change the button type of the Cancel button to Cancel. The user can trigger the Cancel button by pressing the Esc key. </p></li></ul><p>In the Control pane, you can add the following:</p><ul class="spaceabove"><li class="li"><p>Add an application signature and control ID for each button. The application signature is typically your application’s creator code (for example, <code>'surF'</code>). The control ID should uniquely identify the control within your application. </p></li><li class="li"><p>Set command IDs for each button. These IDs are sent to your application as part of a command event, as described in <span class="content_text"><a href="../hitb-wind_cont_concept/hitb-wind_cont_concept.html#//apple_ref/doc/uid/TP30001004-CH205-CJBFDABG">“Command Events.”</a></span> As the functions of these buttons are predefined, you can just choose them in the pop-up menu (that is, OK and Cancel) as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIIBJHA">Figure 3-13</a></span>. If you wanted to create a new command ID, you would choose &lt;other> and then enter a unique four-character ID to identify the command. </p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_112" title="Figure 2-13Assigning a command ID from the Info window"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIIBJHA" title="Figure 2-13Assigning a command ID from the Info window"></a><strong>Figure 2-13&nbsp;&nbsp;</strong>Assigning a command ID from the Info window</p><img src = "../art/assigncommandid.gif" alt = "Assigning a command ID from the Info window" width="238" height="412"></div><br/><p>Next you can add some preference controls. This example includes four different types of controls:</p><ul class="spaceabove"><li class="li"><p>Radio buttons to select the guitar type. These buttons are aligned at the top according to the Aqua guides., but otherwise spaced to balance out the checkboxes. </p></li><li class="li"><p>Checkboxes to select optional effects. These boxes are also top-aligned according to the Aqua guides. </p></li><li class="li"><p>A slider to choose the amount of echo. </p></li><li class="li"><p>Static text to label the slider and indicate the amount of echo. </p></li></ul><p>To view the dialog as it would actually appear in an application, choose the Test Interface command in the File menu. The completed preferences dialog appears in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIECAIF">Figure 3-14</a></span>. <a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_422"></a></p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_113" title="Figure 2-14A preferences dialog"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIECAIF" title="Figure 2-14A preferences dialog"></a><strong>Figure 2-14&nbsp;&nbsp;</strong>A preferences dialog</p><img src = "../art/prefdialog.gif" alt = "A preferences dialog" width="409" height="183"></div><br/><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF133" title="Creating a Window From a Nib file"></a><h3>Creating a Window From a Nib file</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_423"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_424"></a>After you have created a nib file containing your windows, you can access them from your application. </p><p>Note that while a nib file can contain multiple windows, menus, and so on, to make the best use of resources, you may want to break up your user interface elements among several nib files. For example, you can put only the most commonly used windows in one nib file and the rarely used ones in another. </p><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_425"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_426"></a>To make sure your application can find the nib file, you should place it in the Resources folder of your application’s bundle hierarchy, as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCICBFCI">Figure 3-15</a></span>. For information about creating application bundles, see <em>Inside Mac OS X: System Overview</em>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_114" title="Note"></a><p><strong>Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_427"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_428"></a>If your nib files contain localizable text, you should create separate nib files for each language you want to support. Each nib should be placed in the appropriate <code>.lproj</code> folder within the Resources folder.</p></div><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_115" title="Figure 2-15The nib file in an application bundle"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCICBFCI" title="Figure 2-15The nib file in an application bundle"></a><strong>Figure 2-15&nbsp;&nbsp;</strong>The nib file in an application bundle</p><img src = "../art/nibfile.gif" alt = "The nib file in an application bundle" width="279" height="215"></div><br/><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIBCDFB">Listing 3-1</a></span> shows how you use these functions to create a window. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_116" title="Listing 2-1Creating a window from a nib file"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIBCDFB" title="Listing 2-1Creating a window from a nib file"></a><strong>Listing 2-1&nbsp;&nbsp;</strong>Creating a window from a nib file</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus err;<span></span></pre></td></tr><tr><td scope="row"><pre>IBNibRef theNib;<span></span></pre></td></tr><tr><td scope="row"><pre>WindowRef theWindow;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>err = CreateNibReference (CFSTR("MyGuitar"), &amp;theNib); <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>if (!err)<span></span></pre></td></tr><tr><td scope="row"><pre>    CreateWindowFromNib (theNib, CFSTR("GuitarPrefs"), &amp;theWindow); <span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ShowWindow(theWindow); <span>// 3</span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>The Interface Builder Services function <code>CreateNibReference<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_429"></a></code> simply creates a nib reference that points to the specified file. In this case, the file is <code>MyGuitar.nib</code> (you don’t need to specify the <code>.nib</code> extension when calling this function). The <code>CFSTR</code> function converts the string into a Core Foundation string, which is the format that <code>CreateNibReference</code> expects. </p></li><li class="li"><p>The Interface Builder Services function <code>CreateWindowFromNib</code><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_430"></a> uses the nib reference to access a window within the nib file. The name of the window (<code>GuitarPrefs</code> in this example) is the name you assigned to it in the Instances pane of the nib file window. As with the <code>CreateNibReference</code> function, <code>CreateWindowFromNib</code> expects a Core Foundation string for the window name, so it must first be converted using <code>CFSTR</code>. The created window is stored as a window reference in <code>theWindow</code>. </p></li><li class="li"><p>Windows are normally hidden when first created, so you should call <code>ShowWindow</code><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_431"></a> to make them visible. </p></li></ol><p>The complete window can now appear in your application. However, while the facade is there (and many of the controls are functional), this window does not do anything useful. To make the windows and controls do useful work, you must attach Carbon event handlers, which are described in detail in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIIEDHF">“Handling Events.”</a></span><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_432"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_433"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_434"></a></p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIIEDHF" title="Handling Events"></a><h2>Handling Events</h2><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_435"></a>After you have created your windows and controls, you need to make them functional, which means that they must be able to respond to events<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_436"></a>. To do so, you must install one or more Carbon event handlers. To get the most out of this section, you should be familiar with the workings of the Carbon Event Manager, as described in the document <em>Inside Mac OS X: Handling Carbon Events</em>. </p><p>This document assumes that you are installing your handler on the specific control or window it is intended to act upon, but this is not a requirement. The Carbon Event Manager lets you install your handlers anywhere up the containment hierarchy from your specified object. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_117" title="Note"></a><p><strong>Note:</strong>&nbsp;Some Apple technologies install additional event handlers to take care of basic window events. For example, beginning with Mac OS X version 10.1, the Multilingual Text Engine (MLTE) installs default handlers that take care of drawing the content region and content clicks, so you don’t have to call specific MLTE functions to accomplish these tasks within your own event handlers. These default handlers are added to the handler stack for the particular event when the MLTE object is created. See <em>Inside Mac OS X: Setting Up MLTE to Use Carbon Events</em> for more details. </p></div><p>You install your event handlers using the <code>InstallEventHandler<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_437"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus InstallEventHandler (EventTargetRef target,<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>                                EventHandlerUPP handlerProc,<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                                UInt32 numTypes,<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>                                const EventTypeSpec* typeList,<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>                                void* userData,<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>                                EventHandlerRef handlerRef);<span>// 6</span></pre></td></tr></table></div><ol class="ol"><li class="li"><p>The <code>target</code> parameter is an event reference indicating which object you want to install your handler on. You obtain an event reference by calling <code>GetWindowEventTarget</code> or <code>GetControlEventTarget</code>, passing in the appropriate window or control reference. Similar functions also exist for menu and application event targets (<code>GetMenuEventTarget</code> and <code>GetApplicationEventTarget</code>) respectively.</p></li><li class="li"><p>The <code>handlerProc</code> parameter is a universal procedure pointer (UPP) to your event handling function. To convert a normal procedure pointer to a UPP, call the <code>NewEventHandlerUPP</code> function. </p></li><li class="li"><p>The <code>numTypes</code> parameter indicates the number of events you want to register. If you don’t want to hard code this value, you can call the Carbon Event Manager macro <code>GetEventTypeCount</code>, passing in the array of events desired. </p></li><li class="li"><p>The <code>typeList</code> parameter is an array describing the events you want to register. Each event is defined by its class (such as <code>kEventWindowClass</code>) and its kind (such as <code>kEventWindowDrawContent</code>).</p></li><li class="li"><p>If you have any arbitrary data that you want passed to your handler, store it in the <code>userData</code> parameter. This data is passed to your handler each time it is called. </p></li><li class="li"><p>If you want a reference to your installed event handler, pass a pointer here. On return, <code>handlerRef</code> contains a reference to your event handler. </p></li></ol><p>The Carbon Event Manager includes macros that make it simpler to install event handlers by eliminating the need to create the event target reference. For example, the <code>InstallControlEventHandler</code> macro requires only that you pass the control reference where you would pass the event target reference in <code>InstallEventHandler</code>; the macro converts the control reference by calling <code>GetControlEventTarget</code> for you. </p><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGIIBI">Listing 3-2</a></span><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_438"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_439"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_440"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_441"></a>shows how you would install a window event handler named <code>MyWindowEventHandler</code> for two events using the <code>InstallWindowEventHandler</code> macro. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_118" title="Listing 2-2Installing a window event handler"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIGIIBI" title="Listing 2-2Installing a window event handler"></a><strong>Listing 2-2&nbsp;&nbsp;</strong>Installing a window event handler</p><div class="codesample"><table><tr><td scope="row"><pre>EventHandlerUPP myHandlerUPP;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EventTypeSpec eventList[] = {<span></span></pre></td></tr><tr><td scope="row"><pre>                    {kEventClassWindow, kEventWindowDrawContent},<span></span></pre></td></tr><tr><td scope="row"><pre>                    {kEventClassWindow, kEventWindowBoundsChanged}};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>myHandlerUPP = NewEventHandlerUPP (MyWindowEventHandler);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>InstallWindowEventHandler(theWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>                        myHandlerUPP,<span></span></pre></td></tr><tr><td scope="row"><pre>                        GetEventTypeCount(eventList),<span></span></pre></td></tr><tr><td scope="row"><pre>                        eventList, theWindow, NULL);<span></span></pre></td></tr></table></div><p>This example passes the window reference as user data.</p><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIFHBAG">Listing 3-3</a></span> shows a sample function to handle the events registered in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGIIBI">Listing 3-2</a></span>.</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_119" title="Listing 2-3A sample window event handling function"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIFHBAG" title="Listing 2-3A sample window event handling function"></a><strong>Listing 2-3&nbsp;&nbsp;</strong>A sample window event handling function</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_442"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_443"></a><div class="codesample"><table><tr><td scope="row"><pre>static pascal OSStatus MyWindowEventHandler (<span></span></pre></td></tr><tr><td scope="row"><pre>                            EventHandlerCallRef myHandler, <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>                            EventRef theEvent, <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                            void* userData)<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    #pragma unused (myHandler)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus result = eventNotHandledErr;<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    WindowRef theWindow = (WindowRef) userData;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 whatHappened;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    whatHappened = GetEventKind (theEvent);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch (whatHappened)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventWindowDrawContent:<span>// 6</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            DoMyWindowDrawing (window); // dummy drawing function<span></span></pre></td></tr><tr><td scope="row"><pre>            result = noErr;<span>// 7</span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventWindowBoundsChanged:<span>// 8</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            DoMyWindowBoundsChange (theWindow); // dummy bounds function<span></span></pre></td></tr><tr><td scope="row"><pre>            result = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return (result);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>The Carbon Event Manager passes three parameters to your event-handling callback function. The <code>myHandler</code> parameter is a reference to the next event handler in the calling chain. That is, the event handler that will be called next if your handler chooses not to take this event.</p></li><li class="li"><p>The <code>theEvent</code> parameter is an event reference; it points to an opaque data structure that describes the event that occurred. </p></li><li class="li"><p> The <code>userData</code> parameter is the user data you specified when you registered your handler (in this case it contains the window reference). </p></li><li class="li"><p>If your event handler chooses not to handle the event for any reason, you should return <code>eventNotHandledErr</code> to give other handlers in the calling chain a chance to take it. </p></li><li class="li"><p>The <code>GetEventKind</code> function returns a constant that corresponds to the type of event that occurred. You can also call the related function <code>GetEventClass</code> to obtain the event class, but in this case, you know that it’s a window event. </p></li><li class="li"><p>If the event kind indicates a draw content event, call your function to draw the window. See <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-TPXREF138">“The Drawing Event”</a></span> for more information about what to do for this event. </p></li><li class="li"><p>Set <code>result</code> to <code>noErr</code> to tell the Carbon Event Manager that you handled the event. </p></li><li class="li"><p>If the event kind indicates that the window bounds changed, call your function to change the bounds. See <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-TPXREF137">“Window Bounds Changed Events”</a></span> for more information about how to handle this event. </p></li></ol><p>In this example, you receive the window reference as user data. However, you can also obtain parameters such as the window reference from the event reference. See <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-TPXREF134">“Event Parameters”</a></span> for information on how to do this. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF134" title="Event Parameters"></a><h3>Event Parameters</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_444"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_445"></a>Every event has event parameters associated with it. For example, when your application receives a <code>kEventWindowActivated</code> event, the event reference structure also contains a window reference indicating which window received the activate event. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_120" title="Note"></a><p><strong>Note:</strong>&nbsp;You can also pass information to your event handler using the <code>userData</code> parameter when you install your event handler. For example, when installing a window handler, you could store the window reference as user data. For events that don’t store the window reference in the event structure, this may be the only way to determine in which window an event occurred. </p></div><p>To obtain the associated parameters, you call the Carbon Event Manager function <code>GetEventParameter<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_446"></a></code>, indicating which parameter you wish to obtain (see <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGDAAC">Listing 3-4</a></span> for an example). Often you want to specify <code>kEventParamDirectObject<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_447"></a></code>, which indicates the object on which the event was directed. For example, for a window event, the direct object would be a reference to the window in which the event occurred. </p><p>For a list of the permissible parameters (and associated constants to pass to <code>GetEventParameter</code>), see the Carbon Event Manager documentation or the <code>CarbonEvents.h</code> header file. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF135" title="Window Events"></a><h3>Window Events</h3><p>This section describes how to implement handlers to handle the most common window events: </p><ul class="spaceabove"><li class="li"><p>window activation and deactivation events: <code>kEventWindowActivated</code> and <code>kEventWindowDeactivated</code></p></li><li class="li"><p>window bounds changed events: <code>kEventWindowBoundsChanged</code> and <code>kEventWindowBoundsChanging</code></p></li><li class="li"><p>the drawing event: <code>kEventDrawContent</code></p></li><li class="li"><p>the window content click event (<code>kEventWindowContentClick</code>)</p></li><li class="li"><p>the close event (<code>kEventWindowClose</code>)</p></li></ul><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF136" title="Window Activation and Deactivation Events "></a><h4>Window Activation and Deactivation Events </h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_448"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_449"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_450"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_451"></a>When your window is activated or deactivated, it receives the events <code>kEventWindowActivated<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_452"></a></code> and <code>kEventWindowDeactivated<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_453"></a></code> respectively. The standard handler automatically activates and deactivates the title bar. </p><p>In response to the activation event, your handler must handle any requisite changes to the content region. For example, if your content region holds text, you may need to set the keyboard focus to the text field and begin blinking the insertion cursor. Any controls in the window receive their own activate events, so you do not need to handle them in your window activation handler. </p><p>For deactivate events, your handler should do the reverse of your activation handler. That is, stop blinking the cursor, relinquish keyboard focus, and so on. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF137" title="Window Bounds Changed Events"></a><h4>Window Bounds Changed Events</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_454"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_455"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_456"></a>Your window receives a <code>kEventWindowBoundsChanged<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_457"></a></code> event when the user moves or resizes a window. </p><p>If the window is merely moved, the standard handler can handle the repositioning of both the title bar and the content region. If it is resized, usually because the user dragged the resize control or clicked the zoom button, the standard handler automatically resizes the title bar and the content region.</p><p>If the <code>kEventWindowBoundsChanged</code> event indicates the window size is changing, your handler should adjust the content region to reflect the new size. For example, you may need to expose or hide more of an image, or word wrap text to conform to the new size. Note that your handler should not redraw the new content. If the update region is nonempty, your application will receive a drawing event, and you can draw the content from that handler. </p><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_458"></a>In Mac OS X you should constrain the resize to make sure that it does not overwrite the Dock. You should call the function <code>GetAvailableWindowPositioningBounds<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_459"></a></code> to determine the largest allowable bounding rectangle for a given screen device (that is, the largest rectangle that does not overwrite the menu bar or the Dock):</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus GetAvailableWindowPositioningBounds (<span></span></pre></td></tr><tr><td scope="row"><pre>                                    GDHandle inDevice.<span></span></pre></td></tr><tr><td scope="row"><pre>                                    Rect *availableRect);<span></span></pre></td></tr></table></div><p>To constrain the size of a window, you can get the <code>kEventParamCurrentBounds</code> parameter from the <code>kEventWindowBoundsChanged</code> event, modify the bounds and then replace the bounds parameter using the Carbon Event Manager function <code>SetEventParameter</code>. </p><p>If you want your window to support live resizing, you must specify the live resize attribute either in the nib file or by setting the <code>kWindowLiveResizeAttribute</code> bit in your application. If you do this, your application receives the <code>kEventWindowBoundsChanged</code> event whenever a <code>kEventMouseMoved</code> event is sent. By updating your content each time, the window then resizes on the fly. </p><p>To determine which action is occurring when the bounds changed event is sent (that is, whether the window is being resized or merely moved), you call <code>GetEventParameter</code>, specifying the <code>kEventParamAttributes</code> bit field as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGDAAC">Listing 3-4</a></span>.</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_121" title="Listing 2-4Obtaining parameter attributes for a kEventWindowBoundsChanged event"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIGDAAC" title="Listing 2-4Obtaining parameter attributes for a kEventWindowBoundsChanged event"></a><strong>Listing 2-4&nbsp;&nbsp;</strong>Obtaining parameter attributes for a kEventWindowBoundsChanged event</p><div class="codesample"><table><tr><td scope="row"><pre>EventRef theEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 Attributes;<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus err;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>err = GetEventParameter (theEvent, kEventParamAttributes, typeUInt32,<span></span></pre></td></tr><tr><td scope="row"><pre>                            NULL, sizeof(UInt32), NULL, &amp;Attributes);<span></span></pre></td></tr><tr><td scope="row"><pre>if (!err)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>     if (attributes &amp; kWindowBoundsChangeSizeChanged)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Window is being resized<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>     else if (attributes &amp; kWindowBoundsChangeOriginChanged)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Window is being moved<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr></table></div><p>If you want to intercept the resize or move before it actually begins, you should install your handler on the <code>kEventWindowBoundsChanging<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_460"></a></code> event. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF138" title="The Drawing Event"></a><h4>The Drawing Event</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_461"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_462"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_463"></a>Whenever elements in your content region are hidden or shown, you must redraw those portions that are now visible. Typically you do so by creating a handler to handle the <code>kEventWindowDrawContent<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_464"></a></code> event. </p><p>When you receive the <code>kEventWindowDrawContent</code> event, the standard handler has already called the QuickDraw functions <code>BeginUpdate<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_465"></a></code> and <code>SetPort<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_466"></a></code>, and it will call <code>EndUpdate<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_467"></a></code> after you finish handling the event. These functions simplify the updating process by setting the visible region of the window to be the intersection of the visible region and the update region during the redraw. When your drawing handler executes, it automatically draws only those visible portions that have changed. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_122" title="Note"></a><p><strong>Note:</strong>&nbsp;In the rare case where you want to draw directly to into a window by modifying a port’s pixmap data (as opposed to using standard QuickDraw calls), you must call the QuickDraw function <code>QDAddRectToDirtyRegion</code> in your draw handle to tell the system that a portion of the window changed. Otherwise, your drawing is not guaranteed to appear. </p></div><p>If your update region contains any system-defined controls, the standard handler also calls <code>DrawControls</code> to redraw them before your handler is called. </p><p>If for some reason you want to call the <code>BeginUpdate</code>, <code>EndUpdate</code>, and <code>SetPort</code> functions yourself, you should register your handler to be called for the <code>kEventWindowUpdate</code> function instead. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_123" title="Note"></a><p><strong>Note:</strong>&nbsp;The standard handler for <code>kEventWindowUpdate</code> calls <code>BeginUpdate</code> ,<code>SetPort</code>, and (if necessary) <code>DrawControls</code>, then sends a <code>kEventWindowDrawContent</code> event to your window. After your handler handles the draw event, the standard handler then calls <code>EndUpdate</code>. </p></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF139" title="The Content Region Click Event"></a><h4>The Content Region Click Event</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_468"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_469"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_470"></a>When the user presses in the content region of a window, your application receives a <code>kEventWindowContentClick<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_471"></a></code> event. At this point, the mouse is still down, so typically you want to determine where the mouse press occurred and begin tracking. Doing so may require your application to present visual feedback, such as highlighting a selection or dragging an object. You do so using the Carbon Event Manager function <code>TrackMouseLocation</code>.</p><p>Note that if the initial mouse press occurred in a control, the events are sent to the control, not the window. In most cases, you can let the standard handler handle the tracking of the mouse in the control and take action only after the mouse is released.</p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF140" title="The Window Close Event"></a><h4>The Window Close Event</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_472"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_473"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_474"></a>The user can close a window by </p><ul class="spaceabove"><li class="li"><p>clicking the window’s close button</p></li><li class="li"><p> activating a control that ends the window’s usefulness (for example, an OK or Save Settings button in a dialog)</p></li><li class="li"><p>choosing the Close command in the File menu (typically only for document windows)</p></li><li class="li"><p>entering the keyboard equivalent for the Close command (typically Command-W)</p></li></ul><p>In all of these cases, the window to be closed is sent a <code>kEventWindowClose<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_475"></a></code> event. In response to this event your application should do the following:</p><ul class="spaceabove"><li class="li"><p>For unsaved documents, bring up a Save Changes sheet.</p></li><li class="li"><p>Perform any application-specific clean up (for example, disposing of text objects associated with the window).</p></li><li class="li"><p>Call the <code>DisposeWindow</code> function to remove the window. </p></li></ul><p>The <code>DisposeWindow</code> function sends an additional event, <code>kEventWindowClosed</code>, before actually disposing of the window.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_124" title="Note"></a><p><strong>Note:</strong>&nbsp;The standard handler for the <code>kEventWindowClose</code> event automatically calls <code>DisposeWindow</code>; do not call <code>DisposeWindow</code> unless you are overriding the standard handler. </p></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF141" title="Control Events"></a><h3>Control Events</h3><p>This section describes some common control events. Note that in most cases, the standard handler (if it is installed on the owning window) automatically handles most of the work required to respond to these events. That is, the visual cues that accompany button presses, toggling, scroller and slider dragging, and so on, are taken care of for you. </p><p>Control events are of the class <code>kEventClassControl</code>. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF142" title="Control Activation and Deactivation Events"></a><h4>Control Activation and Deactivation Events</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_476"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_477"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_478"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_479"></a>The <code>kEventControlActivate<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_480"></a></code> and <code>kEventControlDeactivate<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_481"></a></code> events are analogous to the activation and deactivation events for windows. These events are sent to your control when <code>ActivateControl</code> or <code>DeactivateControl</code> is called on the control or any higher control in its embedding hierarchy. </p><p>For system-defined controls, the standard handler automatically redraws the control to reflect its new state (for example, graying out the control when deactivated.)</p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF143" title="The Control Hit Event"></a><h4>The Control Hit Event</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_482"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_483"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_484"></a>When the user clicks a control, that control receives a <code>kEventControlHit<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_485"></a></code> event. The standard handler can take care of the visual details (such as making a checkbox appear to toggle), but your application must address the consequences of the action. For example, if the user selects a checkbox, you must update your application to reflect the new state.</p><p>If you don’t need to take any action until the mouse is released, it is simpler to assign a command ID to the control and then install a handler for the <code>kEventProcessCommand</code> event. See <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-CJBDCBCF">“Command Events”</a></span> for more details. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF144" title="The Control Track Event (Mac OS X Only)"></a><h4>The Control Track Event (Mac OS X Only)</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_486"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_487"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_488"></a>When the user presses and holds down the mouse to adjust a control (such as a pop-up menu or the scroller of a scroll bar), the Carbon Event Manager sends the <code>kEventControlTrack<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_489"></a></code> event continuously while the mouse is down. The standard handler automatically adjusts system-defined controls (moving the scroller, highlighting a button, and so on), so in most cases you don’t need to register for this event. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF145" title="The Control Draw Event"></a><h4>The Control Draw Event</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_490"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_491"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_492"></a>When a control needs to be redrawn, it receives a <code>kEventControlDraw<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_493"></a></code> event. The drawing of system-defined controls is taken care of by the standard handler, so you need to register for this event only if you are using a custom control. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF146" title="The Control Bounds Changed Event"></a><h4>The Control Bounds Changed Event</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_494"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_495"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_496"></a>When a control is resized or moved, the control receives a <code>kEventControlBoundsChanged<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_497"></a></code> event. Typically this happens only when you move or resize an embedding control; that is, if you move a group box, the controls embedded within in receive a bounds changed event. For system-defined controls, the standard handler automatically takes care of scaling and redrawing the control, so you usually don’t need to take any additional action. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_125" title="Note"></a><p><strong>Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_498"></a>You often want to resize or move your controls when the owning window changes size. For example, an editable text field often changes size to maintain a size proportional to that of its owning window. For such cases, your window handler should take the window bounds changing event and call <code>SetControlBounds</code> to move or resize the control accordingly. </p></div><a name="//apple_ref/doc/uid/TP30001004-CH206-CJBDCBCF" title="Command Events"></a><h3>Command Events</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_499"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_500"></a>If you assigned a command ID to your control, your application is sent command events whenever the control is activated. Command events are of the class <code>kEventClassCommand</code>. </p><p>The Carbon Event Manager defines command ID’s for many common commands, such as OK, Cancel, Cut, Paste, and so on. You can also define your own for application-specific commands. You assign the command ID to a control in the Control pane of Interface Builder’s Info window, as shown previously in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIIBJHA">Figure 3-13</a></span>. You can also call the Control Manager function <code>SetControlCommandID</code>. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_126" title="Note"></a><p><strong>Note:</strong>&nbsp;You can also assign command IDs to menu items by using Interface Builder or by calling the Menu Manager function <code>SetMenuItemCommandID</code>.</p></div><p>The <code>kEventCommandProcess<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_501"></a></code> event (which is identical to the <code>kEventProcessCommand</code> event) indicates that your control was triggered. The actual command ID is stored within an <code>HICommand</code> structure in the event reference, so you must call the Carbon Event Manager function <code>GetEventParameter</code> to retrieve it, as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIECIFI">Listing 3-5</a></span>. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_127" title="Listing 2-5Obtaining the command ID from the event reference"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIECIFI" title="Listing 2-5Obtaining the command ID from the event reference"></a><strong>Listing 2-5&nbsp;&nbsp;</strong>Obtaining the command ID from the event reference</p><div class="codesample"><table><tr><td scope="row"><pre>HICommand commandStruct;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 the CommandID;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>GetEventParameter (event, kEventParamDirectObject, <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>                    typeHICommand, NULL, sizeof(HICommand),<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL, &amp;commandStruct);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>theCommandID = commandStruct.commandID;<span>// 2</span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>When calling <code>GetEventParameter</code>, you must specify which parameter you want to obtain. For command events, the direct object (<code>kEventParamDirectObject</code>) is the <code>HICommand</code> structure, which describes the command that occurred. </p></li><li class="li"><p>The command ID of the control (or menu) that generated the event is stored in the <code>commandID</code> field of the <code>HICommand</code> structure. </p></li></ol><p>Note that because command events may be triggered from either a control or a menu item, you may want to install your command event handler at the application level to make sure that the handler can take events coming from either location. </p><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_502"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_503"></a>After handling a command, your application may need to change the state of a control or menu item. For example, after saving a document, the Save menu item should be disabled until the document changes. Whenever the status of a command item might be in question, the system makes a note of it. When the user takes an action that may require updating the status (such as pulling down a menu), your application receives a <code>kEventCommandUpdate<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_504"></a></code> event. To make sure that the states of your controls and menus are properly synchronized, you should install a handler for the <code>kEventCommandUpdate</code> event. This handler should check the attributes bit of the command event to determine which items may need updating. Some examples of possible updates include</p><ul class="spaceabove"><li class="li"><p>enabling or disabling menu items</p></li><li class="li"><p>changing the text of a menu item (for example, from Show xxxx to Hide xxxx).</p></li></ul><p>If the <code>kHICommandFromMenu</code> bit in the <code>attributes</code> field of the <code>HICommand</code> structure (shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCICECEE">Listing 3-6</a></span>) is set, then you should check the menu item in question to see if you need to update it. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_128" title="Listing 2-6The HICommand structure"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCICECEE" title="Listing 2-6The HICommand structure"></a><strong>Listing 2-6&nbsp;&nbsp;</strong>The HICommand structure</p><div class="codesample"><table><tr><td scope="row"><pre>struct HIComamnd<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32  attributes;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32  commandID;<span></span></pre></td></tr><tr><td scope="row"><pre>    struct<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        MenuRef         menuRef;<span></span></pre></td></tr><tr><td scope="row"><pre>        MenuItemIndex   menuItemIndex;<span></span></pre></td></tr><tr><td scope="row"><pre>    } menu;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF147" title="Calling Functions to Create Windows and Controls"></a><h2>Calling Functions to Create Windows and Controls</h2><p>Interface Builder lets you easily create and lay out windows and controls. However, in theory your application can create and lay out windows and controls solely by calling Window Manager and Control Manager functions. In most cases, this method is more involved, requires much more work on your part, and makes your application much more difficult to localize. However, if you are working with large amounts of legacy code, familiarity with the programmatic methods of window and control creation may be useful. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_129" title="Note"></a><p><strong>Note:</strong>&nbsp;As the Mac OS has evolved, many functions were added to create and manipulate window and controls. Although many of these functions are still usable, this document describes only those that represent the preferred way of creating windows and controls today. </p></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF148" title="Creating Windows and Controls From Resources"></a><h3>Creating Windows and Controls From Resources</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_505"></a>Historically, windows and controls were stored as <strong>resources</strong> in the <strong>resource fork</strong> of an executable file. This storage method made it relatively easy to create and access these interface elements as well as to localize them. Today, data fork–based nib files provide the same easy accessibility while also providing the layout benefits of Interface Builder. However, if you have older legacy code that uses resources, you can still use them and call <code>CreateWindowFromResource<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_506"></a></code> to add them into your application. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_130" title="Important:"></a><p><strong>Important:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_507"></a>For Carbon applications, resources should no longer be stored in the resource fork of your application. Instead, you should store them as data fork–based <code>.rsrc</code> files in the Resources folder of the application bundle. Localized nib files should go into the <code>.lproj</code> language folders within the Resources folder. </p><p></p></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF149" title="Window Creation Functions"></a><h3>Window Creation Functions</h3><p>To programmatically create a window, the preferred method is to call the function <code>CreateNewWindow<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_508"></a></code>. </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus CreateNewWindow (<span></span></pre></td></tr><tr><td scope="row"><pre>                WindowClass windowClass,<span></span></pre></td></tr><tr><td scope="row"><pre>                WindowAttributes attributes,<span></span></pre></td></tr><tr><td scope="row"><pre>                const Rect * contentBounds,<span></span></pre></td></tr><tr><td scope="row"><pre>                WindowRef * outWindow);<span></span></pre></td></tr></table></div><p>You specify the type of window you want in the <code>windowClass</code>and <code>attributes</code> parameters. The <code>contentBounds</code> parameter is a structure describing the global coordinates of the content region (that is, both the dimensions of the content region and its location onscreen).</p><p>While you probably would use nib files to create dialogs and other complex windows, <code>CreateNewWindow</code> is useful for creating windows that have no application-unique features. A good example would be a plain document window. <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-CJBHJHBC">Listing 3-7</a></span> shows how you can create one. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_131" title="Listing 2-7Creating a document window"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-CJBHJHBC" title="Listing 2-7Creating a document window"></a><strong>Listing 2-7&nbsp;&nbsp;</strong>Creating a document window</p><div class="codesample"><table><tr><td scope="row"><pre> WindowRef         theWindow;<span></span></pre></td></tr><tr><td scope="row"><pre> WindowAttributes  windowAttrs;<span></span></pre></td></tr><tr><td scope="row"><pre> Rect              contentRect;<span></span></pre></td></tr><tr><td scope="row"><pre> CFStringRef       titleKey;<span></span></pre></td></tr><tr><td scope="row"><pre> CFStringRef       windowTitle;<span></span></pre></td></tr><tr><td scope="row"><pre> OSStatus          result;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> windowAttrs = kWindowStandardDocumentAttributes <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>                       | kWindowStandardHandlerAttribute<span></span></pre></td></tr><tr><td scope="row"><pre>                       | kWindowInWindowMenuAttribute;<span></span></pre></td></tr><tr><td scope="row"><pre> SetRect (&amp;contentRect, kWindowLeft,  kWindowTop, <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                        kWindowRight, kWindowBottom);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> CreateNewWindow (kDocumentWindowClass, windowAttrs,<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>                        &amp;contentRect, &amp;theWindow);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> titleKey    = CFSTR(kMyWindowTitleKey); <span>// 4</span></pre></td></tr><tr><td scope="row"><pre> windowTitle = CFCopyLocalizedString(titleKey, NULL); <span>// 5</span></pre></td></tr><tr><td scope="row"><pre> result = SetWindowTitleWithCFString (theWindow, windowTitle); <span>// 6</span></pre></td></tr><tr><td scope="row"><pre> myErrorCheck (result);                              // Check for error<span></span></pre></td></tr><tr><td scope="row"><pre> CFRelease (titleKey); <span>// 7</span></pre></td></tr><tr><td scope="row"><pre> CFRelease (windowTitle);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Add application-specific window initialization here *<span>// 8</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> RepositionWindow (theWindow, NULL, <span>// 9</span></pre></td></tr><tr><td scope="row"><pre>                    kWindowCascadeOnMainScreen);<span></span></pre></td></tr><tr><td scope="row"><pre> ShowWindow (theWindow); <span>// 10</span></pre></td></tr></table></div><p>Here is what the code does: </p><ol class="ol"><li class="li"><p>The <code>windowAttrs</code> parameter is a bit field that you can set with all the attributes you want for your window. This window has the standard document window controls, uses the standard window handler, and appears in the Window menu of the application. </p></li><li class="li"><p>You specify the dimensions of the window and its location by setting a structure of type <code>Rect</code>, which contains the coordinates of the top left and bottom right corners of the window’s content region. The constants included here are simply examples (although you could define actual values for them in the file). </p></li><li class="li"><p>When calling <code>CreateNewWindow</code>, you pass the window class of the desired window, its attributes, and its dimensions. On return <code>theWindow</code> contains a reference to the new window. </p></li><li class="li"><p>The next several lines let you assign a localized title to the new document window. The <code>myWindowTitleKey</code> string is the name of the key that defines the title in your localized property list (<code>plist</code>) file.</p></li><li class="li"><p><code>CFCopyLocalizedString</code> gets the actual localized title string using the title’s key.</p></li><li class="li"><p>After getting the title string, <code>SetWindowTitleWithCFString</code> sets the window title.</p></li><li class="li"><p>You should dispose of your Core Foundation objects when you no longer need them. </p></li><li class="li"><p>This is where you would add application-specific initializations for your window (such as registering event handlers, initializing the Multilingual Text Engine (MLTE), and so on.)</p></li><li class="li"><p>Call <code>RepositionWindow<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_509"></a></code> to specify where you want the window to appear onscreen. Passing <code>kWindowCascadeOnMainScreen</code> indicates that you want the window to appear on the main screen, offset to overlap the currently frontmost application window (this is the usual setting for document windows).</p></li><li class="li"><p>Display the window. </p></li></ol><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF150" title="Creating an Alert"></a><h4>Creating an Alert</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_510"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_511"></a>To create a simple alert, you can call the Dialog Manager functions <code>CreateStandardAlert<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_512"></a></code> and <code>RunStandardAlert<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_513"></a></code>, as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCICFAFB">Listing 3-8</a></span>. This method is convenient for on-the-fly alert messages that require only minimal user interaction, such as to click on only the OK or Cancel buttons. Alerts created with these functions are automatically Aqua-compliant in look and placement. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_132" title="Note"></a><p><strong>Note:</strong>&nbsp;<code>CreateStandardAlert</code> and <code>RunStandardAlert</code> are available only in Mac OS X. If are writing a Mac OS 9–compatible Carbon application, you should use the function <code>StandardAlert<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_514"></a></code> instead. </p></div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_133" title="Listing 2-8Creating a simple alert"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCICFAFB" title="Listing 2-8Creating a simple alert"></a><strong>Listing 2-8&nbsp;&nbsp;</strong>Creating a simple alert</p><div class="codesample"><table><tr><td scope="row"><pre>DialogRef theItem;<span></span></pre></td></tr><tr><td scope="row"><pre>DialogItemIndex itemIndex;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CreateStandardAlert(kAlertStopAlert, <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>                CFSTR("Oh dear, the penguin’s disappeared."), <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                CFSTR("I hope you weren’t planning to open source him."),<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL, &amp;theItem);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>RunStandardAlert (theItem, NULL, &amp;itemIndex); <span>// 4</span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p> When calling <code>CreateStandardAlert</code>, passing <code>kAlertStopAlert</code> specifies that you want the Stop alert icon to be used. Other possible constants you can pass are <code>kAlertNoteAlert</code>, <code>kAlertCautionAlert</code>, and <code>kAlertPlainAlert</code>. Your application icon is automatically added to the alert icon in accordance with the Aqua guidelines. </p></li><li class="li"><p>The Core Foundation strings (created using <code>CFSTR</code>) specify the alert message you want displayed. The second string contains the smaller, informative text. </p></li><li class="li"><p>If you have a custom parameter block describing how to create the alert, you would pass it here. Otherwise pass <code>NULL</code>. On return, <code>theItem</code> contains a reference to the new alert. </p></li><li class="li"><p><code>RunStandardAlert</code> displays the alert and puts the window in an application-modal state. When the user exits the alert (by clicking OK or Cancel), <code>itemIndex</code> contains the index of the control the user clicked. </p></li></ol><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIHEAJE">Figure 3-16</a></span> shows the alert created by the code in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCICFAFB">Listing 3-8</a></span>. </p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_134" title="Figure 2-16A simple alert "></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIHEAJE" title="Figure 2-16A simple alert "></a><strong>Figure 2-16&nbsp;&nbsp;</strong>A simple alert </p><img src = "../art/penguinalert.gif" alt = "A simple alert" width="363" height="102"></div><br/><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF152" title="Creating and Displaying Sheets"></a><h4>Creating and Displaying Sheets</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_515"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_516"></a>A sheet is simply a window with the window class <code>kSheetWindowClass</code> or <code>kAlertSheetWindowClass</code>, and as such you can create one from a nib, from a resource, or by using a window creation function. You should attach event handlers to the sheet, just as any other window. </p><p>Here are some cases where you should use sheets:</p><ul class="spaceabove"><li class="li"><p>You want to display a modal dialog that is specific to a particular document, such as saving or printing. </p></li><li class="li"><p>You want to display a modal dialog that is specific to a single-window application that does not create documents. For example, a single-window utility application might use a sheet to request acceptance of a licensing agreement.</p></li><li class="li"><p>You want to display a dialog that benefits from being associated with a document window, even if the dialog could also have been implemented as a modeless dialog. </p></li></ul><p>Here are some cases when you should not use sheets:</p><ul class="spaceabove"><li class="li"><p>You want to display a dialog that pertains to several windows. </p></li><li class="li"><p>Your dialog needs to be left open to let the user observe the effects of changes applied. Such tasks are better suited to modeless dialogs, utility windows, or drawers. </p></li><li class="li"><p>Your window does not have a title bar. Sheets should emerge from a definite visual edge. </p></li></ul><p>Only one sheet should be open for a document at any time. If the user’s response to a sheet requires another sheet to open, you must close the first sheet before opening the second. </p><p>To display a sheet, you call the function <code>ShowSheetWindow<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_517"></a></code> (analogous to the <code>ShowWindow</code> function used for other window types), passing the window references of the sheet to be displayed and the window to associate with the sheet. If you have installed the standard handler on the sheet, the window contents are automatically drawn before display; otherwise your sheet receives a <code>kEventWindowDrawContent</code> event requesting the same. The now-visible sheet is grouped with its parent window (so that they move and activate/deactivate together).</p><p>To remove a sheet, you call the <code>HideSheetWindow<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_518"></a></code> function, which you typically do from one of the event handlers attached to the window. For example, you can call <code>HideSheetWindow</code> when the user clicks the OK button or otherwise signals that he or she is done with the sheet. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_135" title="Note"></a><p><strong>Note:</strong>&nbsp;Mac OS 9 does not support the visual look or window-modality of sheets. If you use <code>ShowSheetWindow</code> for a sheet class window in Mac OS 9 (using CarbonLib 1.3 or later), the sheet is displayed as a movable application-modal dialog or alert, depending on which sheet class (<code>kSheetWindowClass</code> or <code>kAlertSheetWindowClass</code>) you specified.</p></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF151" title="Creating a Sheet Alert"></a><h4>Creating a Sheet Alert</h4><p>If you want to create a simple alert that appears as a sheet, you can call the function <code>CreateStandardSheet<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_519"></a></code>. This function is analogous in format to the <code>CreateStandardAlert</code> function. However, it includes an additional parameter to specify an event target. When the user dismisses the sheet alert (by clicking OK or Cancel), the system sends a command event (<code>kEventClassCommand</code>, type <code>kEventCommandProcess</code>) to the specified event target. You can use this event to determine which control the user clicked. </p><p>To make the sheet alert visible, you call <code>ShowSheetWindow</code>, just as you would for any other sheet.<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_520"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_521"></a></p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF170" title="Creating Controls"></a><h3>Creating Controls</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_522"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_523"></a>The Control Manager has a creation function for each system-defined control, as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIDAJBE">Table 3-1</a></span>. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_136" title="Table 2-1Control creation functions"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIDAJBE" title="Table 2-1Control creation functions"></a><strong>Table 2-1&nbsp;&nbsp;</strong>Control creation functions</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Control type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Creation function</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Notes</p></th></tr><tr><td  scope="row"><p>Root control</p></td><td ><p><code>CreateRootControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Push button</p></td><td ><p><code>CreatePushButtonControl</code> or <code>CreatePushButtonWithIconControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Checkbox</p></td><td ><p><code>CreateCheckboxControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Radio button</p></td><td ><p><code>CreateRadioButtonControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Bevel button</p></td><td ><p><code>CreateBevelButtonControl</code></p></td><td ><p>You set the button behavior when calling the function. Additional bevel button functions exist to set the alignment of text or images within the button, set or obtain menu information, and so on. </p></td></tr><tr><td  scope="row"><p>Round button</p></td><td ><p><code>CreateRoundButtonControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Pop-up menu</p></td><td ><p><code>CreatePopUpButtonControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Scroll bar</p></td><td ><p><code>CreateScrollBarControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Slider</p></td><td ><p><code>CreateSliderControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>List box</p></td><td ><p><code>CreateListBoxControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Scroll text field</p></td><td ><p><code>CreateScrollingTextBoxControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Progress indicator</p></td><td ><p><code>CreateProgressBarControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Chasing arrows</p></td><td ><p><code>CreateChasingArrowsControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Relevance control</p></td><td ><p><code>CreateRelevanceBarControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Static text</p></td><td ><p><code>CreateStaticTextControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Editable text field</p></td><td ><p><code>CreateEditTextControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Editable Unicode text field </p></td><td ><p><code>CreateEditUnicodeTextControl</code></p></td><td ><p>Mac OS X only</p></td></tr><tr><td  scope="row"><p>Icon control</p></td><td ><p><code>CreateIconControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Picture control</p></td><td ><p><code>CreatePictureControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Image well</p></td><td ><p><code>CreateImageWellControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Group box</p></td><td ><p><code>CreateGroupBoxControl</code>, <code>CreateCheckGroupBoxControl</code>, or <code>CreatePopupGroupBoxControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Radio group</p></td><td ><p><code>CreateRadioGroupControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Pane</p></td><td ><p><code>CreateUserPaneControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Tabs</p></td><td ><p><code>CreateTabsControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Disclosure triangle</p></td><td ><p><code>CreateDisclosureTriangleControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Disclosure button</p></td><td ><p><code>CreateDisclosureButtonControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Little arrows</p></td><td ><p><code>CreateLittleArrowsControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Separator lines</p></td><td ><p><code>CreateVisualSeparatorControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Data browser</p></td><td ><p><code>CreateDataBrowserControl</code></p></td><td ><p>This complex control also requires a number of additional configuration and manipulation functions. </p></td></tr><tr><td  scope="row"><p>Placard</p></td><td ><p><code>CreatePlacardControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Window header</p></td><td ><p><code>CreateWindowHeaderControl</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Clock</p></td><td ><p><code>CreateClockControl</code></p></td><td ><p>The clock automatically contains a little arrows control to adjust the date or time. </p></td></tr></table></div><p>These functions let you specify all the attributes or options necessary for creating the appropriate control. In addition, most control creation functions require you to specify the bounds of the control. This is the bounding rectangle (specified by the <code>Rect</code> data type) that defines the position (in the window’s local coordinates) and size of the control. Note if the bounds you specify are smaller than the minimum control size, the control will exceed the requested bounds. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF153" title="Functions That Correspond to Interface Builder Options"></a><h3>Functions That Correspond to Interface Builder Options</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_524"></a>Most of the options for Carbon windows and controls are handled by calling Window and Control Manager functions. If you want to reproduce or modify functionality that you see in Interface Builder, you can call the underlying functions yourself. This section describes the correspondence between options found in the Interface Builder Info windows and their Control and Window Manager counterparts.</p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF154" title="Window Options"></a><h4>Window Options</h4><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIIFCEG">Table 3-2</a></span> describes the correspondence between Interface Builder window options and Window Manager functions</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_137" title="Table 2-2Window Manager functions for setting window options"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIIFCEG" title="Table 2-2Window Manager functions for setting window options"></a><strong>Table 2-2&nbsp;&nbsp;</strong>Window Manager functions for setting window options</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Interface Builder Window Option</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Window Manager equivalent</p></th></tr><tr><td  scope="row"><p>Title</p></td><td ><p><code>SetWindowTitleWithCFString</code></p></td></tr><tr><td  scope="row"><p>Class</p></td><td ><p>Set when you call <code>CreateNewWindow</code>. You can also call <code>SetWindowGroup</code> or <code>GetWindowClass</code> after creation. Do not use <code>SetWindowClass</code>.</p></td></tr><tr><td  scope="row"><p>Theme brush</p></td><td ><p>Set using the Appearance Manager function <code>SetThemeWindowBackground</code>. </p></td></tr><tr><td  scope="row"><p>Position</p></td><td ><p>Set when you specify the <code>contentBounds</code> parameter in <code>CreateNewWindow</code>. You can also pass window position constants (type <code>WindowPositionMethod</code>) to <code>RepositionWindow</code>.</p></td></tr><tr><td  scope="row"><p>Buttons</p></td><td ><p>Attributes you can set when calling <code>CreateNewWindow</code> or by calling <code>ChangeWindowAttributes</code>.</p></td></tr><tr><td  scope="row"><p>Attributes</p></td><td ><p>Attributes you can set when calling <code>CreateNewWindow</code> or by calling <code>ChangeWindowAttributes</code>.</p></td></tr><tr><td  scope="row"><p>Receives</p></td><td ><p>Attributes you can set when calling <code>CreateNewWindow</code> or by calling <code>ChangeWindowAttributes</code>.</p></td></tr><tr><td  scope="row"><p>Size</p></td><td ><p>Set in the <code>contentBounds</code> parameter when calling <code>CreateNewWindow</code>.</p></td></tr><tr><td  scope="row"><p>Help tags</p></td><td ><p>Implemented by calling the Carbon Help Manager. See the Carbon Help Manager documentation for more details. </p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF155" title="Control Options"></a><h4>Control Options</h4><p>Options unique to a control type (for example, specifying a determinate or indeterminate progress indicator) are usually specified in the control’s creation function. See <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIDAJBE">Table 3-1</a></span> for the list of control creation functions. </p><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIBAFGA">Table 3-3</a></span> describes the correspondence between general Interface Builder control options and Control Manager functions.<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_525"></a></p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_138" title="Table 2-3Control options"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIBAFGA" title="Table 2-3Control options"></a><strong>Table 2-3&nbsp;&nbsp;</strong>Control options</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Interface Builder Control Option</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Control Manager equivalent</p></th></tr><tr><td  scope="row"><p>Control ID</p></td><td ><p><code>SetControlID</code></p></td></tr><tr><td  scope="row"><p>Signature</p></td><td ><p><code>SetControlID</code></p></td></tr><tr><td  scope="row"><p>Command</p></td><td ><p><code>SetControlCommandID</code></p></td></tr><tr><td  scope="row"><p>Enabled checkbox</p></td><td ><p><code>EnableControl</code> and <code>DisableControl</code></p></td></tr><tr><td  scope="row"><p>Hidden checkbox</p></td><td ><p><code>HideControl</code> and <code>ShowControl</code></p></td></tr><tr><td  scope="row"><p>Small checkbox</p></td><td ><p>Pass <code>kControlSizeSmall</code> in <code>SetControlData</code> to specify the small control variant.</p></td></tr><tr><td  scope="row"><p>Size</p></td><td ><p>Set in the <code>inBoundsRect</code> parameter of the particular control creation function. You can also set the size by calling <code>SetControlBounds</code>.</p></td></tr><tr><td  scope="row"><p>Help tags</p></td><td ><p>Implemented by calling the Carbon Help Manager. See the Carbon Help Manager documentation for more details. </p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF156" title="Basic Window Manipulation"></a><h2>Basic Window Manipulation</h2><p>This section describes some common window manipulation functions that you may want to use in your application. You can use these functions with windows created in any manner. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF157" title="Window Activation"></a><h3>Window Activation</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_526"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_527"></a>Activating a window typically brings it forward, gives it keyboard focus, and deactivates the previously active window. However, because of floating windows, the active window may not always be the frontmost window on the screen. </p><ul class="spaceabove"><li class="li"><p>To obtain the window reference of the currently active window, call the <code>ActiveNonFloatingWindow<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_528"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef ActiveNonFloatingWindow(void);<span></span></pre></td></tr></table></div></li><li class="li"><p>To determine if a window is active, call the <code>IsWindowActive<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_529"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>Boolean IsWindowActive(WindowRef inWindow);<span></span></pre></td></tr></table></div></li><li class="li"><p>To activate or deactivate a window, call the <code>ActivateWindow<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_530"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus ActivateWindow (WindowRef inWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>                            Boolean inActivate);<span></span></pre></td></tr></table></div><p>You do not have to call <code>ActivateWindow</code> in response to typical user actions (such as clicking in a window) as the standard handler will do so for you. <code>ActivateWindow</code> also causes the appropriate window activation or deactivation event to be sent to your window.</p></li></ul><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF158" title="Finding Windows"></a><h3>Finding Windows</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_531"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_532"></a>The Carbon Window Manager provides a number of functions to find particular windows. </p><ul class="spaceabove"><li class="li"><p>To obtain the frontmost window, call the <code>FrontWindow<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_533"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef FrontWindow(void);<span></span></pre></td></tr></table></div></li><li class="li"><p>To obtain the frontmost window that is not a floating window, call the <code>FrontNonFloatingWindow<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_534"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef FrontNonfloatingWindow (void);<span></span></pre></td></tr></table></div></li><li class="li"><p>To find the frontmost window of a particular class, call the <code>GetFrontWindowOfClass<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_535"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef GetFrontWindowOfClass (WindowClass inWindowClass<span></span></pre></td></tr><tr><td scope="row"><pre>                                    Boolean mustBeVisible);<span></span></pre></td></tr></table></div></li><li class="li"><p>To find the next window of a particular class, call the <code>GetNextWindowOfClass<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_536"></a></code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef GetNextWindowOfClass (WindowRef inWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    WindowClass inClass,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    Boolean mustBeVisible);<span></span></pre></td></tr></table></div></li></ul><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF159" title="Window Visibility"></a><h3>Window Visibility</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_537"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_538"></a>At times you may want to change the visibility of your windows. For example, if the user closes a floating palette that is used often, it may be better to hide it rather than dispose of it, as doing so avoids the overhead of disposing of the window and recreating it later. On the other hand, keeping many windows available does use up memory, so use your judgment in determining which windows to hide and which to dispose of. </p><ul class="spaceabove"><li class="li"><p>To make a window visible, call the <code>ShowWindow</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>void ShowWindow (WindowRef window);<span></span></pre></td></tr></table></div><p>Note that all windows are invisible when first created. </p></li><li class="li"><p>To hide a window, call the <code>HideWindow<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_539"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>void HideWindow (WindowRef window);<span></span></pre></td></tr></table></div></li><li class="li"><p>To determine whether a window is visible or not, use the <code>IsWindowVisible<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_540"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>Boolean IsWindowVisible (WindowRef window);<span></span></pre></td></tr></table></div></li></ul><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIBBFJI" title="Changing the Modification State"></a><h3>Changing the Modification State</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_541"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_542"></a>When a document window is in an unsaved state, the close button should display a small dot in its center, and the proxy icon (if there is one) should be disabled. (Disabled proxy icons cannot be dragged because unsaved documents cannot be moved or copied in a manner predictable to the user.) You accomplish both of these tasks by calling the <code>SetWindowModified<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_543"></a></code> function to change the modification state:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus SetWindowModified (WindowRef window, Boolean modified);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIBJCGE" title="Ordering Windows"></a><h3>Ordering Windows</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_544"></a>At times you may want to change the layering order of the windows in your application. </p><ul class="spaceabove"><li class="li"><p>To bring a window forward and make it active, call the <code>SelectWindow<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_545"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>void SelectWindow (WindowRef window);<span></span></pre></td></tr></table></div><p>The previously frontmost window is automatically deactivated. </p></li><li class="li"><p>To send one window behind another, call the <code>SendBehind<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_546"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>void SendBehind (WindowRef window, WindowRef behindWindow);<span></span></pre></td></tr></table></div><p>If the window sent behind is the active window, it is deactivated and the next higher window is activated. </p></li></ul><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIEFFHE" title="Cycling Through Windows (Mac OS X 10.2 and Later)"></a><h3>Cycling Through Windows (Mac OS X 10.2 and Later)</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_547"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_548"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_549"></a>Beginning in Mac OS X version 10.2, the user should be able to cycle through the open document windows of an application by entering Command-tilde (~) to rotate forward, or Command-Shift-tilde to rotate backwards. The standard handler provides default support for these keyboard shortcuts, so you do not need to add any additional code. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_139" title="Note"></a><p><strong>Note:</strong>&nbsp;The standard handler for window cycling intercepts the <code>kEventRawKeyDown</code> Carbon event at the application level. If your application has its own raw key event handler, you should avoid processing the event before the standard handler can act on it. </p></div><p>If you use the standard window menu (see <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-TPXREF160">“The Standard Window Menu”</a></span>), you can specify the option <code>kWindowMenuIncludeRotate<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_550"></a></code> when calling <code>CreateStandardWindowMenu<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_551"></a></code> to place a “Cycle Windows” menu item in the Window menu. Doing so makes window cycling an explicit, rather than hidden, feature in the application.</p><p>If you want to add menu items for window cycling, and you want to use the standard handler’s cycling code, you can assign the following command IDs to your menu items:</p><div class="codesample"><table><tr><td scope="row"><pre>kHICommandRotateWindowsForward = 'rotw',<span></span></pre></td></tr><tr><td scope="row"><pre>kHICommandRotateWindowsBackward = 'rotb'<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF160" title="The Standard Window Menu"></a><h3>The Standard Window Menu</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_552"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_553"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_554"></a>Most applications that handle document windows should have a Window menu, which allows the user to choose among any of the currently open windows. The easiest way to implement this menu is to call the <code>CreateStandardWindowMenu<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_555"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus CreateStandardWindowMenu (OptionBits inOptions,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    MenuRef *outMenu);<span></span></pre></td></tr></table></div><p>Each open window that has the <code>kWindowInWindowMenuAttribute</code> attribute set automatically appears in the Window menu. </p><p>At times, the window title that shows up in the Window menu may not be expressive enough to identify the window. In those cases, you can set an alternate title for the window that will appear only in the Window menu by calling the <code>SetWindowAlternateTitle</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus SetWindowAlternateTitle (WindowRef inWindow<span></span></pre></td></tr><tr><td scope="row"><pre>                                    CFStringRef inTitle);<span></span></pre></td></tr></table></div><p>To get an existing alternate window title, use the <code>CopyWindowAlternateTitle</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus CopyWindowAlternateTitle (WindowRef InWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    CFStringRef *outTitle);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF161" title="Window Reference Constants"></a><h3>Window Reference Constants</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_556"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_557"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_558"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_559"></a>If desired, you can assign arbitrary data to your windows by calling the <code>SetWindowProperty<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_560"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus SetWindowProperty (<span></span></pre></td></tr><tr><td scope="row"><pre>                        WindowRef window,<span></span></pre></td></tr><tr><td scope="row"><pre>                        PropertyCreator PropertyCreator,<span></span></pre></td></tr><tr><td scope="row"><pre>                        PropertyTag PropertyTag,<span></span></pre></td></tr><tr><td scope="row"><pre>                        UInt32 PropertySize,<span></span></pre></td></tr><tr><td scope="row"><pre>                        void* PropertyBuffer);<span></span></pre></td></tr></table></div><p>You assign a creator code (typically the application’s signature) and a unique four-character tag to identify the data; this way you can associate multiple pieces of data with a window. To retrieve particular data, call the <code>GetWindowProperty<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_561"></a></code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus GetWindowProperty (<span></span></pre></td></tr><tr><td scope="row"><pre>                        WindowRef window,<span></span></pre></td></tr><tr><td scope="row"><pre>                        PropertyCreator PropertyCreator,<span></span></pre></td></tr><tr><td scope="row"><pre>                        PropertyTag PropertyTag,<span></span></pre></td></tr><tr><td scope="row"><pre>                        UInt32 bufferSize,<span></span></pre></td></tr><tr><td scope="row"><pre>                        UInt32 *actualSize, // can be NULL<span></span></pre></td></tr><tr><td scope="row"><pre>                        void *propertyBuffer);<span></span></pre></td></tr></table></div><p>If you need to set only one value, (such as a pointer to a data structure), you can also use the <code>SetWRefCon<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_562"></a></code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>void SetWRefCon (WindowRef window, UInt32 data);<span></span></pre></td></tr></table></div><p>To retrieve the stored data, call the <code>GetWRefCon<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_563"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>long GetWRefCon (WindowRef window);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF173" title="Adding Window Proxy Icons"></a><h3>Adding Window Proxy Icons</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_564"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_565"></a>If you create a document window, you should add a proxy icon to the title bar. This icon, which appears next to the window’s title, serves as a proxy for the document’s icon in the Finder. This proxy icon should appear and behave the way the document's icon does in the Finder.</p><p>Your application can call the function <code>SetWindowProxyCreatorAndType<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_566"></a></code> when you want to establish a proxy icon for a window, but the window's data has not yet been saved to a file. By passing <code>SetWindowProxyCreatorAndType</code> the creator and type of the file that the window is to contain, you can provide visual consistency with other windows that have saved files with the Finder. If the window's data has been saved to a file, your application can call the functions <code>SetWindowProxyFSSpec</code> or <code>SetWindowProxyAlias</code> to associate the file with the window and thereby establish the proxy icon.</p><p>Once a window has a proxy icon, the user should be able to manipulate it as if he or she were performing actions with a Finder icon for the window's file. For example, if a user drags a proxy icon to a folder, Finder window, the desktop, or another volume, the file represented by the proxy icon should be moved or copied accordingly, as if the user had dragged the file's icon in the Finder.</p><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_567"></a>If your window has the standard event handler installed, then the Window Manager automatically handles any proxy icon dragging feedback. Note that standard handler sends you <code>kEventWindowProxyBeginDrag</code> and <code>kEventWindowProxyEndDrag</code> events so that you can modify or obtain information from the drag reference structure if you desire. For more detailed information about drag-and-drop actions, see the Drag Manager documentation. </p><p>Because a user can so readily use a proxy icon to manipulate a document file while the document is itself open, your application should be sure to synchronize the file data for all of its document windows on an ongoing basis. Because a proxy icon is much more prominent to a user than a Finder icon when the user is working in an open document, it is more likely that the user may move the file represented by the proxy icon while the document is open.</p><p>For example, if a user opens "My Document" in an application, then drags the proxy icon for "My Document" to a different folder, the application may still expect "My Document" to be in its original location. Additionally, the user may change the name of "My Document" to "Your Document" or place "My Document" in the Trash folder while "My Document" is open.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_140" title="Note"></a><p><strong>Note:</strong>&nbsp;See the document <em>Programming with the Mac OS 8.5 Window Manager</em> for an example of how you might search the file system to determine if document locations have changed. </p></div><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_568"></a>If a document window contains unsaved changes, you should disable the proxy icon by calling the <code>SetWindowModified</code> function described in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIBBFJI">“Changing the Modification State.”</a></span> Doing so prevents the user from dragging the proxy icon to another location. Your application should not disable the proxy icon at any other time.</p><p>Finally, when the user drags content that your application can accept into the content area of one of its windows, the window's structure region, including the proxy icon, should become highlighted. This gives visual feedback that the window is a valid destination for the content. Applications typically call the Drag Manager functions <code>ShowDragHilite</code> and <code>HideDragHilite</code> to indicate that a window is a valid drag-and-drop destination. If your application does not do this—that is, if your application implements any type of custom drag highlighting, such as highlighting more than one area of a window at a time—it must call the function <code>HiliteWindowFrameForDrag</code>.<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_569"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_570"></a></p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIHHBAB" title="Window Groups (Mac OS X Only)"></a><h3>Window Groups (Mac OS X Only)</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_571"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_572"></a>The Window Manager supports the concept of window groups, which is essentially a way to associate windows together. Depending on which attributes you set for the group, windows in a group can share one or more of the following behaviors as if they were a single window:</p><ul class="spaceabove"><li class="li"><p>Activate and deactivate</p></li><li class="li"><p>Change layers (that is, if one window is brought forward, all the windows in the group are brought forward)</p></li><li class="li"><p>Move </p></li><li class="li"><p>Collapse or hide</p></li></ul><p>Using window groups, you can link several different classes of window together. For example, you could lock a toolbar window to a document window so that when one moved the other would also move. </p><p>Each window group is associated with a layer in the window layering hierarchy. In fact, in Mac OS X, the Window Manager defines each of the standard window classes (document, floating, and so on) as a window group. Window groups can contain other window groups, so you can create hierarchies of groups. </p><p>A document window with a sheet is an example of a window group. The sheet (when visible) is locked to a particular document window, and it moves, collapses, and changes layers along with the document. Here are some other examples of when you might want to group windows together:</p><ul class="spaceabove"><li class="li"><p>You want to create a window overlay that you can modify without affecting the window’s contents. </p></li><li class="li"><p>You want to create multiple layers within a particular window class. For example, using window groups you could ensure that certain floating windows always remain above other floating windows. </p></li><li class="li"><p>You want to toggle a floating window in a utility application from “stay behind mode” (where the window stays behind other applications’ windows) to “keep-in-front mode” (where the window is above all other windows). </p></li></ul><p>To create a window group, call the <code>CreateWindowGroup<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_573"></a></code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus CreateWindowGroup (<span></span></pre></td></tr><tr><td scope="row"><pre>                    WindowGroupAttributes inAttributes<span></span></pre></td></tr><tr><td scope="row"><pre>                    WindowGroupRef *outGroup);<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_574"></a>The attribute bits you pass to <code>CreateWindowGroup</code> determine which grouping properties windows in the group will have. <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCICCDHH">Table 3-4</a></span> shows the possible constants you can pass. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_141" title="Table 2-4Window group attribute bits"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCICCDHH" title="Table 2-4Window group attribute bits"></a><strong>Table 2-4&nbsp;&nbsp;</strong>Window group attribute bits</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Constant</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>kWindowGroupAttrSelectAsLayer<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_575"></a></code></p></td><td ><p>All windows in this group act as if they occupy the same layer. However, the user can change the ordering of the windows within the group.</p></td></tr><tr><td  scope="row"><p><code>kWindowGroupAttrMoveTogether<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_576"></a></code></p></td><td ><p>The positions of each window in the group with respect to each other is locked; moving one window also moves the others. </p></td></tr><tr><td  scope="row"><p><code>kWindowGroupAttrLayerTogether<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_577"></a></code></p></td><td ><p>The ordering of the windows within the group is locked; if the user attempts to bring one window forward, all the windows in the group are brought forward. </p></td></tr><tr><td  scope="row"><p><code>kWindowGroupAttrSharedActivation<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_578"></a></code></p></td><td ><p>All windows within the group activate and deactivate together. </p></td></tr><tr><td  scope="row"><p><code>kWindowGroupAttrHideOnCollapse<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_579"></a></code></p></td><td ><p>All windows within the group collapse into the Dock together. If any subgroup of this group has the <code>kWindowGroupAttrHideOnCollapse</code> attribute set, that group’s windows are collapsed as well. </p></td></tr></table></div><p>For example, to obtain the proper behavior for a window displaying a sheet, you would group the window and sheet together specifying the following attributes:</p><ul class="spaceabove"><li class="li"><p><code>kWindowGroupAttrMoveTogether</code> (the two windows should move together) </p></li><li class="li"><p><code>kWindowGroupAttrLayerTogether</code> (the user should not be able to bring the document window in front of the sheet) </p></li></ul><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIJABHC">Listing 3-9</a></span> shows an example of grouping two windows together, a toolbar window and a document window. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_142" title="Listing 2-9Grouping two windows together"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIJABHC" title="Listing 2-9Grouping two windows together"></a><strong>Listing 2-9&nbsp;&nbsp;</strong>Grouping two windows together</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef myDocWindow, myToolbar;<span></span></pre></td></tr><tr><td scope="row"><pre>WindowGroupRef myGroup;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Create your two windows here and show them */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CreateWindowGroup (0, &amp;myGroup);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>SetWindowGroupParent (myGroup, <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                GetWindowGroupOfClass (kDocumentWindowClass));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>SetWindowGroup (myDocWindow, myGroup);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>SetWindowGroup (myToolbar, myGroup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ChangeWindowGroupAttributes (myGroup,<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>            kWindowGroupAttrMoveTogether | kWindowGroupAttrLayerTogether,<span></span></pre></td></tr><tr><td scope="row"><pre>            0);<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>Call the <code>CreateWindowGroup<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_580"></a></code> function to create a new group. The first parameter specifies any attributes you want to set (none in this case), and on return <code>myGroup</code> references the newly-created group. </p></li><li class="li"><p>Assign a parent group for the new group. As described earlier, groups can contain other groups, and in this case you assign your group to the group containing document class windows. To obtain a group reference from a window class, you call <code>GetWindowGroupOfClass<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_581"></a></code>. </p><p>Note that currently you cannot assign a parent to a group if the group already contains windows. </p></li><li class="li"><p>To add windows to your group, call the <code>SetWindowGroup<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_582"></a></code> function. Note that you can only assign a window to one group. If the window is already in a group, <code>SetWindowGroup</code> removes the window from the old group and assigns it to the new one. </p></li><li class="li"><p>Now set attributes for the window group by calling <code>ChangeWindowGroupAttributes<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_583"></a></code>. The second parameter indicates attributes to set, the third indicates those to remove. In this case, you specify that the windows in the group should move together and layer together. </p></li></ol><p>The resulting pair of windows acts as though they were a single document window. </p><p>If you wanted to change the window ordering within the group, you can call functions such as <code>SelectWindow</code> and <code>SendBehind</code> on individual windows. </p><p>Some other useful window grouping functions include the following:</p><ul class="spaceabove"><li class="li"><p>To release (or dispose of ) a window group, call the <code>ReleaseWindowGroup<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_584"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus ReleaseWindowGroup (WindowGroupRef, inGroup);<span></span></pre></td></tr></table></div><p>Calling <code>ReleaseWindowGroup</code> decrements the reference count of the group. If the reference count drops to zero, the group is disposed. </p></li><li class="li"><p>To increment the reference count for a group, call the <code>RetainWindowGroup<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_585"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus RetainWindowGroup (WindowGroupRef inGroup);<span></span></pre></td></tr></table></div></li><li class="li"><p>To get the group that contains a window, call the <code>GetWindowGroup<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_586"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>WindowGroupRef GetWindowGroup (WindowRef inWindow);<span></span></pre></td></tr></table></div></li><li class="li"><p>You can associate a window group with a particular window. To do so, call the <code>SetWindowGroupOwner<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_587"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus SetWindowGroupOwner (WindowGroupRef inGroup,<span></span></pre></td></tr><tr><td scope="row"><pre>                                WindowRef inWindow);<span></span></pre></td></tr></table></div></li><li class="li"><p>To determine which window owns a particular group, call the <code>GetWindowGroupOwner<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_588"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef GetWindowGroupOwner (WindowGroupRef inGroup);<span></span></pre></td></tr></table></div></li><li class="li"><p>As mentioned earlier window groups can contain other groups. To change the ordering of a group within another window group, call the <code>SendWindowGroupBehind<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_589"></a></code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus SendWindowGroupBehind (WindowGroupRef inGroup, WindowGroupRef behindGroup);<span></span></pre></td></tr></table></div><p>This function works much like the <code>SendBehind</code> function for windows. Both groups must have the same parent group. </p></li><li class="li"><p>If you want to set the window level for a group, call the <code>SetWindowGroupLevel<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_590"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus SetWindowGroupLevel (WindowGroupRef inGroup,<span></span></pre></td></tr><tr><td scope="row"><pre>                                SInt32 inLevel);<span></span></pre></td></tr></table></div><p>The window levels you can specify here are a superset of the window class hierarchy. See the Core Graphics frameworks header <code>CGWindowLevel.h</code> for a listing of window levels. </p></li><li class="li"><p>To get the window level for a group, call the <code>GetWindowGroupLevel<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_591"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus GetWindowGroupLevel (WindowGroupRef inGroup<span></span></pre></td></tr><tr><td scope="row"><pre>                                SInt32 *outLevel);<span></span></pre></td></tr></table></div></li></ul><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_592"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_593"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIHIBJA" title="Manipulating Drawers (Mac OS X 10.2 and later)"></a><h3>Manipulating Drawers (Mac OS X 10.2 and later)</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_594"></a>Drawers are a special class of window that appear to slide out from behind another window. You use drawers to hold commonly used items or controls that do not have to be visible all the time. For example, a drawer could hold bookmarks for a web browser, or mailboxes for an email program. Figure shows a drawer attached to a document window.</p><p>You create a drawer just as you would any other type of window, except that you specify that its window class be a drawer. That is, you specify a drawer when creating your window in Interface Builder (need to confirm this) or you pass <code>kDrawerWindowClass</code> for the window class when calling <code>CreateNewWindow</code>. When creating your drawer, you must also specify the window compositing attribute, <code>kWindowCompositingAttribute</code>. </p><p>In most cases you should specify the standard event handler when creating a drawer. You can then add controls to the drawer just as you would for any other type of window. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_143" title="Note"></a><p><strong>Note:</strong>&nbsp;Because the height and position of the drawer is determined by the parent window, the only aspect of the bounds you pass into <code>CreateNewWindow</code> that is used is the drawer width.</p></div><p>If you want the drawer to have the default background for drawers, call the Appearance Manager function <code>SetThemeWindowBackground</code>, specifying <code>kThemeBrushDrawerBackground</code>. </p><ul class="spaceabove"><li class="li"><p>After creating the drawer, you must attach it to a parent window by calling the <code>SetDrawerParent<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_595"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus SetDrawerParent (WindowRef inDrawerWindow,                             WindowRef inParent);<span></span></pre></td></tr></table></div></li><li class="li"><p>Unless you specify otherwise, the height of the drawer is the same as that of the parent window. If you want to change the height and relative position of the drawer with respect to its parent, use the <code>SetDrawerOffsets<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_596"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus SetDrawerOffsets (WindowRef inDrawerWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>                            float inLeadingOffset,<span></span></pre></td></tr><tr><td scope="row"><pre>                            float inTrailingOffset);<span></span></pre></td></tr></table></div><p>The leading offset is the number of pixels to offset the drawer from the top of the parent. The trailing offset is the number of pixels from the bottom of the drawer to the bottom edge of the parent.</p></li><li class="li"><p>To toggle the drawer call the <code>ToggleDrawer<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_597"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus ToggleDrawer (WindowRef inDrawerWindow);<span></span></pre></td></tr></table></div><p>This function call is asynchronous; <code>ToggleDrawer</code> installs a Carbon event timer to toggle the drawer and then returns. Therefore, the calling thread must be running its event loop for the drawer to actually open or close. </p></li><li class="li"><p>Alternatively, to specifically open or close a drawer, call the <code>OpenDrawer<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_598"></a></code> or <code>CloseDrawer<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_599"></a></code> functions respectively. </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus OpenDrawer (WindowRef inDrawerWindow                        OptionBits inEdge,                        Boolean inAsync);<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus CloseDrawer (WindowRef inDrawerWindow                        Boolean inAsync);<span></span></pre></td></tr></table></div><p>For the <code>inEdge</code> parameter you must pass a constant specifying the edge (that is, <code>kWindowEdgeTop</code>/<code>Left</code>/<code>Bottom</code>/<code>Right</code> or <code>kWindowEdgeDefault</code>).</p><p>If you pass <code>False</code> in the <code>inAsync</code> parameter, the drawer opening or closing occurs synchronously; otherwise the action is asynchronous, as with the <code>ToggleDrawer</code> function. </p></li></ul><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIHJHEE">Listing 3-10</a></span> shows the code to set up and attach a simple drawer.</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_144" title="Listing 2-10Displaying a simple drawer"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIHJHEE" title="Listing 2-10Displaying a simple drawer"></a><strong>Listing 2-10&nbsp;&nbsp;</strong>Displaying a simple drawer</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef myDrawer, parentWindow;<span></span></pre></td></tr><tr><td scope="row"><pre>Rect drawerBounds = {0,0,250,150};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Assume that the parent window exists already and is visible */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CreateNewWindow (kDrawerWindowClass, kWindowStandardHandlerAttribute |<span></span></pre></td></tr><tr><td scope="row"><pre>                kWindowCompositingAttribute, &amp;drawerBounds, &amp;myDrawer);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>SetThemeWindowBackground (myDrawer, kThemeBrushDrawerBackground, true);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>SetDrawerParent(myDrawer, parentWindow);<span></span></pre></td></tr><tr><td scope="row"><pre>SetDrawerOffsets (myDrawer, 0.0, 25.0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ToggleDrawer (myDrawer);<span></span></pre></td></tr></table></div><p>By default, the edge of the parent window where the drawer appears is determined by the current script system. If the script reads left to right, the drawer appears on the left side. For right to left scripts (such as Arabic), the drawer appears on the right side. If there is not enough screen space for the drawer, the drawer appears on the opposite edge. If space is constrained on both sides, the drawer appears on the preferred side, but possibly obscured (for example, partly offscreen or hidden by the Dock). </p><ul class="spaceabove"><li class="li"><p>If you want to override the preferred edge for the drawer, call the <code>SetDrawerPreferredEdge<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_600"></a></code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus SetDrawerPreferredEdge (WindowRef inDrawerWindow,                                    OptionBits inEdge);<span></span></pre></td></tr></table></div><p>The edge you specify becomes the new default edge (that is, the one chosen when you pass <code>kWindowEdgeDefault</code> into <code>OpenDrawer</code>. </p></li><li class="li"><p>To get the preferred edge for a drawer, call the <code>GetDrawerPreferredEdge<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_601"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OptionBits GetDrawerPreferredEdge (WindowRef inDrawerWindow);<span></span></pre></td></tr></table></div></li><li class="li"><p>To get the current window edge on which a drawer is displayed, call the <code>GetDrawerCurrentEdge<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_602"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OptionBits GetDrawerCurrentEdge (WindowRef inDrawerWindow);<span></span></pre></td></tr></table></div><p>Note that this edge is not necessarily the preferred edge because of screen space constraints.<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_603"></a></p></li></ul><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF162" title="Basic Control Manipulation"></a><h2>Basic Control Manipulation</h2><p>This section describes various control manipulation functions that you may want to use in your application. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF164" title="Activating Controls"></a><h3>Activating Controls</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_604"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_605"></a>You can use the following functions to activate or deactivate your controls:</p><ul class="spaceabove"><li class="li"><p>To activate a control, call the <code>ActivateControl<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_606"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSErr ActivateControl (ControlRef inControl);<span></span></pre></td></tr></table></div></li><li class="li"><p>To deactivate a control, call the <code>DeactivateControl<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_607"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSErr DeactivateControl (ControlRef inControl);<span></span></pre></td></tr></table></div></li><li class="li"><p>To determine whether a control is active, use the <code>IsControlActive<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_608"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>Boolean IsControlActive (ControlRef inControl);<span></span></pre></td></tr></table></div></li></ul><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_609"></a>In general, a control’s active state should match that of its owning window (that is, when a window is active, all of its controls should likewise be active). However, the Control Manager does not enforce this matching; your application is responsible for maintaining this correspondence. The simplest way to do so is to activate or deactivate the window’s root control as the window’s state changes. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_145" title="Note"></a><p><strong>Note:</strong>&nbsp;In earlier versions of Mac OS system software, you would deactivate controls to make them nonfunctional in an active window. However, currently the preferred method is to disable them instead. </p></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF165" title="Enabling Controls"></a><h3>Enabling Controls</h3><p>You can use the following functions to enable or disable your controls. Disabled controls are “grayed out" and do not receive user events. </p><ul class="spaceabove"><li class="li"><p>To enable a control, call the <code>EnableControl<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_610"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus EnableControl (ControlRef inControl);<span></span></pre></td></tr></table></div></li><li class="li"><p>To disable a control, call the <code>DisableControl<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_611"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus DisableControl (ControlRef inControl);<span></span></pre></td></tr></table></div></li><li class="li"><p>To determine whether a control is enabled, use the <code>IsControlEnabled<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_612"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>Boolean IsControlEnabled (ControlRef inControl);<span></span></pre></td></tr></table></div></li></ul><p>You disable controls if you do not want them to function for a particular reason. For example, in the standard Save dialog, the Save button is disabled until the user enters a name for the file to be saved. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF166" title="Showing and Hiding Controls"></a><h3>Showing and Hiding Controls</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_613"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_614"></a>You use the following functions to show or hide a control:</p><ul class="spaceabove"><li class="li"><p>To show or hide a control, use the <code>SetControlVisibility<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_615"></a></code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>OSErr SetControlVisibility (ControlRef inControl,<span></span></pre></td></tr><tr><td scope="row"><pre>                                Boolean inIsVisible,<span></span></pre></td></tr><tr><td scope="row"><pre>                                Boolean inDoDraw);<span></span></pre></td></tr></table></div></li><li class="li"><p>To determine whether a control is visible, use the <code>IsControlVisible<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_616"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>Boolean IsControlVisible (ControlRef inControl):<span></span></pre></td></tr></table></div></li></ul><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF167" title="Drawing Controls"></a><h3>Drawing Controls</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_617"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_618"></a>In certain cases (such as when draw content events or update events occur) you may want to redraw your controls.</p><p>If you want to redraw all the controls associated with a window, call the <code>DrawControls<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_619"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>void DrawControls (WindowRef theWindow);<span></span></pre></td></tr></table></div><p>In most cases, however, you want to redraw only those controls that were added to the update region. In response to the draw content event or update event, you should call <code>UpdateControls<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_620"></a></code>:</p><div class="codesample"><table><tr><td scope="row"><pre>void UpdateControls (WindowRef the Window, RgnHandle updateRegion);<span></span></pre></td></tr></table></div><p>If you want to redraw only a particular control (say a scroll bar after the user resized a window), you call the <code>Draw1Control<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_621"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>void Draw1Control (ControlRef theControl);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF163" title="Embedding Controls"></a><h3>Embedding Controls</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_622"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_623"></a>All controls are embedded in one or more other controls, so you may need to use these functions to manipulate them properly:</p><ul class="spaceabove"><li class="li"><p>To create a root control for a window, call the <code>CreateRootControl<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_624"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSErr CreateRootControl (WindowRef inWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>                            ControlRef *outControl);<span></span></pre></td></tr></table></div></li><li class="li"><p>To get an existing root control, call the <code>GetRootControl<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_625"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSErr GetRootControl (WindowRef inWindow<span></span></pre></td></tr><tr><td scope="row"><pre>                            ControlRef *outControl);<span></span></pre></td></tr></table></div></li><li class="li"><p>To embed one control in another, use the <code>EmbedControl<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_626"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSErr EmbedControl (ControlRef inControl,<span></span></pre></td></tr><tr><td scope="row"><pre>                        ControlRef, inContainer);<span></span></pre></td></tr></table></div></li><li class="li"><p>You can also embed controls using the <code>AutoEmbedControl<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_627"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSErr AutoEmbedControl ControlRef inControl, WindowRef inWindow);<span></span></pre></td></tr></table></div><p>If you specify auto-embedding for a control, then the Control Manager assumes embedding if the control lies within the bounds of another control. For example, say you have a group box within a window. If you designate a checkbox as being auto-embedding and place it so that its physical coordinates lie within the group box, the Control Manager embeds your checkbox within that control. The bounds of the root control is the content region of the window, so auto-embedded controls are always embedded within the root control (in addition to whatever other controls might contain it). </p></li><li class="li"><p>To get the immediate owner of an embedded control, call the <code>GetSuperControl<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_628"></a></code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>OSErr GetSuperControl (ControlRef inControl,<span></span></pre></td></tr><tr><td scope="row"><pre>                            ControlRef *outParent);<span></span></pre></td></tr></table></div></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_146" title="Note"></a><p><strong>Note:</strong>&nbsp;On Mac OS X (but not Mac OS 9 and earlier), you can embed controls from one window into another window. For example, you might want to create and store controls outside your current window and move them in as needed. </p></div><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF168" title="Control Implementation Examples"></a><h2>Control Implementation Examples</h2><p>This section contains some examples of how to implement functions to handle the following tasks:</p><ul class="ul"><li class="li"><p>Live scrolling in windows with proportional scrollers </p></li><li class="li"><p>Using tab controls to switch between panes</p></li></ul><a name="//apple_ref/doc/uid/TP30001004-CH206-CJBCBCJF" title="Live Scrolling"></a><h3>Live Scrolling</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_629"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_630"></a>Scroll bars have been a part of the user interface since the first Macintosh computer. All Mac OS X applications should support live scrolling, meaning that the window’s contents should update on the fly as the user manipulates the scroll bars. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF174" title="Scrolling and the Control Action Callback Function"></a><h4>Scrolling and the Control Action Callback Function</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_631"></a>You implement live scrolling by assigning a control action callback to your scroll controls. The callback function is called periodically as the user interacts with the scroll bar, giving your application the opportunity to update the contents of the window. </p><p>You register a callback for a control using the <code>SetControlAction<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_632"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>void SetControlAction (ControlRef theControl,                         ControlActionUPP actionProc);<span></span></pre></td></tr></table></div><p>Note that you can attach control action callbacks to any type of control. Typically you use them whenever you need to do some sort of update on the fly. For example, a size-control slider could use an action callback to update the size of an image as it is moved. </p><p>The scrolling action itself is relatively straightforward if you understand conceptually what is happening to the window’s contents. The simplest way to look at scrolling is to imagine a window as the rectangular cutout in a sheet of opaque paper resting on a two-dimensional image, such as a photograph. Moving the horizontal scroller to the right moves the window to the right, exposing more of what is on that side. Moving the vertical scroller downwards effectively moves the window down.</p><p>The tricky part is translating the apparent movement of the window in a manner that you can implement in your application. For example, when displaying a picture onscreen, the window actually remains stationary while scrolling. Therefore, to accomplish the same relative movement across the picture, you must move the picture in the opposite direction. That is, as the user moves a scroller to the right, you must move the picture to the left. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF169" title="Scrolling a Simple Picture"></a><h4>Scrolling a Simple Picture</h4><p>This section describes how to create a window containing an image that you can scroll vertically or horizontally. For this example, assume the following:</p><ul class="spaceabove"><li class="li"><p>The window is not resizable, and its content region is 200 pixels wide by 150 pixels high. The window (“Scroller”) is contained in a nib file named <code>simpleScroller.nib</code>, and it uses the standard window handler. </p></li><li class="li"><p>The window contains vertical and horizontal scroll bars with control IDs of 128 and 129 respectively. The application signature for the controls <a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_633"></a>is <a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_634"></a><code>'Moof'</code>.</p></li><li class="li"><p>The picture to display in the window is 500 pixels wide by 350 pixels high. The picture is stored in a data fork–based resource. </p></li></ul><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIJDEEB">Listing 3-11</a></span> shows an initialization function that creates a window from a nib file, loads the picture, and then displays the picture in the window. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_147" title="Listing 2-11Creating a window and displaying a picture"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIJDEEB" title="Listing 2-11Creating a window and displaying a picture"></a><strong>Listing 2-11&nbsp;&nbsp;</strong>Creating a window and displaying a picture</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_635"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_636"></a><div class="codesample"><table><tr><td scope="row"><pre>/* First define various global variables */<span></span></pre></td></tr><tr><td scope="row"><pre>PicHandle myPict;<span></span></pre></td></tr><tr><td scope="row"><pre>Rect pictRect;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 picWidth, picHeight;<span></span></pre></td></tr><tr><td scope="row"><pre>Point picOffset;<span></span></pre></td></tr><tr><td scope="row"><pre>ControlActionUPP myLiveScrollerUPP;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ControlID vScrollID, hScrollID;<span></span></pre></td></tr><tr><td scope="row"><pre>ControlRef horizontalScroller, verticalScroller;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 contentWidth, contentHeight;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyInitializeScrollWindow (void)<span></span></pre></td></tr><tr><td scope="row"><pre> {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IBNibRef theNib;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus err;<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowRef scrollWindow;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect theBounds;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = CreateNibReference (CFSTR("simpleScroller"),&amp;theNib);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    CreateWindowFromNib(theNib, CFSTR("Scroller"), &amp;scrollWindow);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Install your window event handlers here *<span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ShowWindow(scrollWindow);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    hScrollID.signature = 'Moof';<span></span></pre></td></tr><tr><td scope="row"><pre>    vScrollID.signature = 'Moof';<span></span></pre></td></tr><tr><td scope="row"><pre>    hScrollID.id = 129;<span></span></pre></td></tr><tr><td scope="row"><pre>    vScrollID.id = 128;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    GetControlByID (scrollWindow, &amp;vScrollID, &amp;verticalScroller);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    GetControlByID (scrollWindow, &amp;hScrollID, &amp;horizontalScroller);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    myPict = GetPicture (10001); // get picture from resource<span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (myPict == NULL) SysBeep(1);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Get dimensions of the picture */<span></span></pre></td></tr><tr><td scope="row"><pre>    picWidth = (**myPict).picFrame.right - (**myPict).picFrame.left;<span></span></pre></td></tr><tr><td scope="row"><pre>    picHeight = (**myPict).picFrame.bottom - (**myPict).picFrame.top;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetPortWindowPort(scrollWindow);                    <span>// 6</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    GetWindowBounds (scrollWindow, kWindowContentRgn, &amp;theBounds); <span>// 7</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    contentWidth = theBounds.right -theBounds.left - 15;<span>// 8</span></pre></td></tr><tr><td scope="row"><pre>    contentHeight = theBounds.bottom - theBounds.top - 15;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetControl32BitMaximum (verticalScroller,<span></span></pre></td></tr><tr><td scope="row"><pre>                             picHeight - contentHeight);<span>// 9</span></pre></td></tr><tr><td scope="row"><pre>    SetControl32BitMaximum (horizontalScroller, picWidth - contentWidth);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetControl32BitMinimum (verticalScroller, 0);<span>// 10</span></pre></td></tr><tr><td scope="row"><pre>    SetControl32BitMinimum (horizonalScroller, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetControlViewSize (verticalScroller, contentHeight);<span>// 11</span></pre></td></tr><tr><td scope="row"><pre>    SetControlViewSize (horizontalScroller, contentWidth);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetControl32BitValue (verticalScroller, 0);<span>// 12</span></pre></td></tr><tr><td scope="row"><pre>    SetControl32BitValue (horizontalScroller, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Assign initial offset of picture */<span></span></pre></td></tr><tr><td scope="row"><pre>    picOffset.v = 0<span>// 13</span></pre></td></tr><tr><td scope="row"><pre>    picOffset.h = 0<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    myLiveScrollerUPP = NewControlActionUPP (MyLiveScrollProc);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetControlAction (verticalScroller,myLiveScrollerUPP);<span>// 14</span></pre></td></tr><tr><td scope="row"><pre>    SetControlAction (horizontalScroller, myLiveScrollerUPP);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    MyDrawThePic (scrollWindow); <span>// 15</span></pre></td></tr><tr><td scope="row"><pre> }<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>First obtain a nib reference and load the window from the nib file. </p></li><li class="li"><p>In a real window initialization function, you would probably want to install any custom event handlers here. Live scrolling requires only the standard event handler. </p></li><li class="li"><p>Display the window. </p></li><li class="li"><p>Call the <code>GetControlByID</code> function twice to obtain the control references for the two scroll controls. These control references are stored globally. In a more flexible case, you may want to pass these references as parameters into your scrolling function. </p></li><li class="li"><p>Obtain the image from a resource. The image is stored as a PICT resource in the data fork with (in this example) resource ID 10001.</p></li><li class="li"><p>Call <code>SetPortWindowPort</code> to set the graphics port to be the content region of the window. Once set, all drawing is directed to this window, with the pixel coordinates (0,0) corresponding to the upper-left corner of the content region. </p></li><li class="li"><p>Pass the <code>kWindowContentRgn</code> constant into <code>GetWindowBounds<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_637"></a></code> to obtain a rectangle that defines the boundaries of the content region. </p></li><li class="li"><p>Note that the content region obtained by <code>GetWindowBounds</code> also includes the area currently occupied by the scroll controls. Because you don’t want to draw over the controls, subtract the width of the scroll controls (15 pixels) to obtain the true dimensions of allowable drawing region. </p></li><li class="li"><p>Call <code>SetControl32BitMaximum</code> twice to set the maximum allowable values for the scrollers (which are the indicators for the scroll bars). In this example, the values that the scrollers can take correspond to pixels. The maximum horizontal scroll value is the difference between the picture width (500 pixels) and the drawing region width (185 pixels). When the scroller value is 0, the window displays the leftmost portion of the picture. When the value is at its maximum (315), the window displays the rightmost portion. Similarly, the maximum vertical scroller value is the difference between the picture height and the drawing region height, or 215 pixels.</p></li><li class="li"><p>Similarly, you call <code>SetControl32BitMinimum</code> twice to set the minimum scroller values to 0. </p></li><li class="li"><p>Call <code>SetControlViewSize<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_638"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_639"></a></code> to set the correct proportional scroller size. The value you pass indicates how much of the actual image is visible in the window, in terms of the units you specified in <code>SetControl32BitMaximum</code>. For example, because the units are pixels, the value to set for the horizontal scroller corresponds to the number of horizontal pixels that are visible in the window, which is the value of <code>contentWidth</code>.</p><p>For resizable windows, you must update the sizes of the scrollers whenever the window dimensions change. </p></li><li class="li"><p>Call <code>SetControl32BitValue</code> to assign initial values to the scrollers. Setting these to their minimum values means that the scrollers are positioned at the left and top of their respective scroll bars. </p></li><li class="li"><p>Because the initial scroller values are 0, the initial picture offsets should also be 0. Note however, that as the scroller’s value is increased, the picture must be displaced in the opposite direction to create the illusion of movement.</p></li><li class="li"><p>Using the control references obtained earlier, call <code>SetControlAction</code> for each scroll control to assign an action callback, <code>MyLiveScrollProc</code>. This callback is called whenever the user activates a scroll control. </p></li><li class="li"><p>Call the function <code>MyDrawThePic</code> to draw the picture inside the window. </p></li></ol><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIDHHFH">Listing 3-12</a></span> shows the implementation for the <code>MyDrawThePic</code> function, which draws the picture in the window. <a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_640"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_641"></a>Much of the graphical manipulation relies on QuickDraw function calls. Their usage and functionality are described briefly, but if you want more details, you should consult the QuickDraw documentation available in Carbon Graphics and Imaging documentation. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_148" title="Note"></a><p><strong>Note:</strong>&nbsp;QuickDraw is deprecated in Mac OS X v10.4 and later. If you are building for Mac OS X v10.4 or later, you should implement drawing using Quartz instead. </p></div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_149" title="Listing 2-12The picture-drawing function"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIDHHFH" title="Listing 2-12The picture-drawing function"></a><strong>Listing 2-12&nbsp;&nbsp;</strong>The picture-drawing function</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_642"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_643"></a><div class="codesample"><table><tr><td scope="row"><pre>void MyDrawThePic (WindowRef theWindow)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    RgnHandle saveClip;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect theBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGrafPtr thePort;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    thePort = GetWindowPort(theWindow);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    GetPortBounds(thePort, &amp;theBounds);     <span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    saveClip = NewRgn(); // allocate new region<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    GetClip (saveClip); // save old clip region<span>// 4</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theBounds.bottom = theBounds.bottom -15;<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>    theBounds.right = theBounds.right -15;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ClipRect (&amp;theBounds); <span>// 6</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    pictRect.left = picOffset.h ;<span>// 7</span></pre></td></tr><tr><td scope="row"><pre>    pictRect.top = picOffset.v;<span></span></pre></td></tr><tr><td scope="row"><pre>    pictRect.right = pictRect.left + picWidth;<span></span></pre></td></tr><tr><td scope="row"><pre>    pictRect.bottom = pictRect.top + picHeight;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    DrawPicture (myPict, &amp;pictRect ); <span>// 8</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetClip (saveClip); <span>// 9</span></pre></td></tr><tr><td scope="row"><pre>    DisposeRgn (saveClip);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>Call <code>GetWindowPort</code> to obtain the graphics port associated with the window. This <code>CGrafPtr</code> pointer references a structure containing information about the current drawing area. </p></li><li class="li"><p>Calling the QuickDraw function <code>GetPortBounds</code> obtains the boundaries of the current drawing area (both in size and location). For system-defined windows, this area is equivalent to the window’s content region. </p></li><li class="li"><p>Allocate space for a new clip region by calling the QuickDraw function <code>NewRgn</code>. The clip region is an arbitrary region within which drawing is allowed. For example, while the actual drawing region (as defined by the graphics port) may be arbitrarily large, the only drawing that actually appears onscreen is that which intersects the clip region. </p></li><li class="li"><p>Only one clip region is defined at any time, so you must store the previously defined clip region in <code>saveClip</code> by calling the QuickDraw function <code>GetClip</code>. Doing so ensures that you don’t corrupt the clip region used by a different application. </p></li><li class="li"><p>Reduce the obtained bounds for the content region by 15 pixels in each dimension to exclude the window’s scroll bars from the drawing area. </p></li><li class="li"><p>Set the clip region for the window’s graphics environment to be the reduced bounds. </p></li><li class="li"><p>Set the coordinates in which to draw the picture. These coordinates define a rectangle the size of the actual picture, offset from the local origin by an amount determined by the scroller values. For example, if there is no offset (because both scrollers are at their minimum values) then the top-left corner of the picture is at the window’s local origin. </p></li><li class="li"><p>Draw the picture using the QuickDraw function <code>DrawPicture</code> , which is a simple way to draw images of type PICT. Because the clip region is confined to the area inside the window, only the portion of the picture within that region actually appears onscreen. </p></li><li class="li"><p>After drawing, restore the old clip region using the <code>SetClip</code> function, and dispose of the memory used to store it by calling <code>DisposeRgn</code>. </p></li></ol><p>Your drawing function may be more complex, but the basic principles still apply. Because the clip region defines the area within which the picture is visible, you change what portion is visible by moving the picture around “behind the window,” so to speak. Scrolling merely gives you a measured way to change the position of the picture. <a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_644"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_645"></a></p><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIFFHEB">Figure 3-17</a></span> shows the relative positions of the window and the image when the scroller values are 0. </p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_150" title="Figure 2-17Picture in window for the minimum scroll control values "></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIFFHEB" title="Figure 2-17Picture in window for the minimum scroll control values "></a><strong>Figure 2-17&nbsp;&nbsp;</strong>Picture in window for the minimum scroll control values </p><img src = "../art/scrollexample.gif" alt = "Picture in window for the minimum scroll control values" width="438" height="261"></div><br/><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGDGGE">Listing 3-13</a></span> shows the live scrolling callback function. This function takes two parameters indicating the control and the part of the control that activated the action callback. </p><p>Note that the standard event handlers take care of moving the scrollers, tracking the mouse, and any other feedback related to control itself; our scrolling callback function only has to adjust the position of the image based on the actions taken by the user. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_151" title="Listing 2-13The live scrolling callback function"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIGDGGE" title="Listing 2-13The live scrolling callback function"></a><strong>Listing 2-13&nbsp;&nbsp;</strong>The live scrolling callback function</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_646"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_647"></a><div class="codesample"><table><tr><td scope="row"><pre>static pascal void MyLiveScrollProc (ControlHandle control, SInt16 part)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt16 currentValue, min, max, delta;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    currentValue = GetControl32BitValue (control);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    min = GetControl32BitMinimum (control);<span></span></pre></td></tr><tr><td scope="row"><pre>    max = GetControl32BitMaximum (control);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    delta = 0;<span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch (part)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kControlUpButtonPart:<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>            if (currentValue >min)<span></span></pre></td></tr><tr><td scope="row"><pre>                    delta = (currentValue-min &lt; 5 ?<span></span></pre></td></tr><tr><td scope="row"><pre>                                    -(currentValue-min): -5);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kControlDownButtonPart:<span></span></pre></td></tr><tr><td scope="row"><pre>            if (currentValue &lt; max)<span></span></pre></td></tr><tr><td scope="row"><pre>                    delta =  (max - currentValue > 5 ?<span></span></pre></td></tr><tr><td scope="row"><pre>                                    5 : max - currentValue);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kControlPageUpPart:<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>            if (currentValue >min)<span></span></pre></td></tr><tr><td scope="row"><pre>                    {<span></span></pre></td></tr><tr><td scope="row"><pre>                    if (control == horizontalScroller)<span></span></pre></td></tr><tr><td scope="row"><pre>                            delta = ( currentValue-min >contentWidth-1 ?<span></span></pre></td></tr><tr><td scope="row"><pre>                                -(contentWidth-1) : -(currentValue-min));<span></span></pre></td></tr><tr><td scope="row"><pre>                    else<span></span></pre></td></tr><tr><td scope="row"><pre>                            delta = ( currentValue-min >contentHeight-1 ?<span></span></pre></td></tr><tr><td scope="row"><pre>                                -(contentHeight-1) : -(currentValue-min));<span></span></pre></td></tr><tr><td scope="row"><pre>                    }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kControlPageDownPart:<span></span></pre></td></tr><tr><td scope="row"><pre>            if (currentValue &lt; max)<span></span></pre></td></tr><tr><td scope="row"><pre>                    {<span></span></pre></td></tr><tr><td scope="row"><pre>                    if (control == horizontalScroller)<span></span></pre></td></tr><tr><td scope="row"><pre>                            delta = (contentWidth-1 &lt; max-currentValue ?<span></span></pre></td></tr><tr><td scope="row"><pre>                                contentWidth-1: max-currentValue);<span></span></pre></td></tr><tr><td scope="row"><pre>                    else<span></span></pre></td></tr><tr><td scope="row"><pre>                            delta = (contentHeight-1 &lt; max-currentValue ?<span></span></pre></td></tr><tr><td scope="row"><pre>                                contentHeight-1 : max-currentValue));<span></span></pre></td></tr><tr><td scope="row"><pre>                    }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (delta != 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        SetControl32BitValue (control, currentValue + delta);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (control == horizontalScroller)<span>// 6</span></pre></td></tr><tr><td scope="row"><pre>                picOffset.h -= delta;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (control == verticalScroller)<span></span></pre></td></tr><tr><td scope="row"><pre>                picOffset.v -= delta;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        MyDrawThePic(GetControlOwner(control));<span>// 7</span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    else if (part == kControlIndicatorPart)<span>// 8</span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (control == horizontalScroller)<span></span></pre></td></tr><tr><td scope="row"><pre>                picOffset.h = -(currentValue - min);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (control == verticalScroller)<span></span></pre></td></tr><tr><td scope="row"><pre>                picOffset.v = -(currentValue - min);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        MyDrawThePic (GetControlOwner (control));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>First obtain the values assigned to the control. The maximum and minimum values are those that were set in the <code>MyInitializeScrollWindow</code> function. The current value is determined by the position of the scroller. </p></li><li class="li"><p>The <code>delta</code> variable indicates the distance (in pixels) to move the picture in response to the scroll bar manipulation. This value is also used to set the new value of the scroller. </p></li><li class="li"><p>The <code>switch</code> statement assigns the <code>delta</code> value depending on which part of the scroll control was manipulated. The <code>kControlUpButtonPart</code> and <code>kControlDownButtonPart</code> constants refer to the scroll arrows. Clicking one of these arrows once scrolls the content by a small fixed amount. The incremental amount chosen for this example is 5 pixels. Note that if the scroller value is less than 5 away from its minimum or maximum, it <code>delta</code> is adjusted to be only the amount necessary to reach the endpoint. </p></li><li class="li"><p>The <code>kControlPageUpPart</code> and <code>kControlPageDownPart</code> constants refer to the white track area of the scroll control within which the Aqua scrollers move. If the user has the scroll bar preference in the General pane of System Preferences set to to “Jump to next page, “ a click in the track area causes the content to shift by the corresponding window content dimension. For example, clicking above the vertical scroller moves the image up by the height of the window’s content region. A click below the scroller moves the image down by the same amount. As with the scroll arrows, in the end cases where a full page shift would take you beyond the end of the picture, <code>delta</code> is set to be only enough to reach the edge. </p></li><li class="li"><p>If <code>delta</code> is not zero, add it to the appropriate scroller value (horizontal or vertical).</p></li><li class="li"><p>Because the control value is in the same units as the offset (pixels), you also adjust the offset to reflect the new picture position. Note that you subtract <code>delta</code> from the offset because the control values and picture offset move in opposite directions. For example, as you increase the horizontal scroller value (that is, as the scroller moves to the right), the picture must move left to show the proper portion.</p></li><li class="li"><p>Call the <code>MyDrawThePic</code> function to update the picture. Because you don’t currently have a window reference, use the function <code>GetControlOwner</code> to obtain one. </p><p>Note that updating the entire picture each time is not necessarily the most efficient way to update the window contents. A more sophisticated application might determine how much of the picture has actually changed, move the picture using a function such as <code>ScrollWindowRect</code> or <code>ScrollWindowRegion</code>, ) and update only the portion that is new. </p></li><li class="li"><p>The final scroll bar part that the user can manipulate is the scroller. Typically the user drags the scroller to a new position. In such cases, rather than changing the picture’s offset by an incremental amount, you simply set the offset based on the new value of the scroller and call <code>MyDrawThePic</code> to redraw the picture. </p><p>If the user has the “Scroll to here” system preference set, a click in the track area moves the scroller to that point and sets the scroller value, just as if the user had actually dragged the scroller. </p></li></ol><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIEBCEI">Figure 3-18</a></span> shows the relative positions of the window and the image when the horizontal and vertical scroller values are each set to 100. <a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_648"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_649"></a></p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_152" title="Figure 2-18Picture in window when scroller values are set to (100,100)"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIEBCEI" title="Figure 2-18Picture in window when scroller values are set to (100,100)"></a><strong>Figure 2-18&nbsp;&nbsp;</strong>Picture in window when scroller values are set to (100,100)</p><img src = "../art/offsetscroll.gif" alt = "Picture in window when scroller values are set to (100,100)" width="398" height="222"></div><br/><a name="//apple_ref/doc/uid/TP30001004-CH206-CJBIECCF" title="Using Tab Controls"></a><h3>Using Tab Controls</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_650"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_651"></a>You typically use tab controls to switch between several panes. Interface Builder lets you place panes and tabs together as one unit. However, while each tab looks as though it is attached to a particular pane, this appearance is actually an illusion that you must implement using code in your control event handlers. This section gives an example of how to do this. For this example, assume the following:</p><ul class="spaceabove"><li class="li"><p>The window is contained in a nib file and uses the standard handler. It contains a tab control with two panes (that is, the tabs let you switch between two panes).</p></li><li class="li"><p>The application signature is <code>'Moof'</code>. The control ID for the tab control is 128. The control IDs for the panes are 129 and 130. </p></li></ul><p>First you should install an event handler on the tab control that determines which tab was clicked and then switch panes accordingly. </p><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIIGCIF">Listing 3-14</a></span> shows how you would install your tab event handler. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_153" title="Listing 2-14Installing the tab control event handler"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIIGCIF" title="Listing 2-14Installing the tab control event handler"></a><strong>Listing 2-14&nbsp;&nbsp;</strong>Installing the tab control event handler</p><div class="codesample"><table><tr><td scope="row"><pre>ControlID   tabControlID;<span></span></pre></td></tr><tr><td scope="row"><pre>ControlRef  tabControl;<span></span></pre></td></tr><tr><td scope="row"><pre>EventHandlerUPP myTabHandlerUPP;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>tabControlID.signature = 'Moof';<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>tabControlID.id = 128;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static const EventTypeSpec tabControlEvents[] =<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    {kEventClassControl, kEventControlHit}<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>GetControlByID (theWindow, &amp;tabControlID, &amp;tabControl);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>myTabHandlerUPP = NewEventHandlerUPP (MyTabEventHandlerProc);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>err = InstallControlEventHandler (tabControl, <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>                            myTabHandlerUPP,<span></span></pre></td></tr><tr><td scope="row"><pre>                            GetEventTypeCount (tabControlEvents),<span></span></pre></td></tr><tr><td scope="row"><pre>                            tabControlEvents,<span></span></pre></td></tr><tr><td scope="row"><pre>                            theWindow, NULL);<span>// 6</span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>First, define the tab control’s signature and control ID. These should be the same values that you set for the tab control in your nib file. </p></li><li class="li"><p>Define the events for which you want the tab event handler to be called. In this example, there is only one, the control hit event. The system sends this event whenever the user clicks the control. </p></li><li class="li"><p>Call <code>GetControlByID<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_652"></a></code> to get the control reference for the tab control. The <code>theWindow</code> parameter is a reference to the window containing the control. You would have obtained this reference when creating the window from the nib file (that is, when calling <code>CreateWindowFromNib</code>).</p></li><li class="li"><p>When designating the tab event handler, you must call <code>NewEventHandlerUPP</code> on the function pointer to convert it to a universal procedure pointer.</p></li><li class="li"><p>The function <code>InstallControlEventHandler</code> is the macro that combines the standard <code>InstallEventHandler</code> call with <code>GetControlEventTarget</code> so you don’t have to call the latter function yourself.</p></li><li class="li"><p>You pass the window reference <code>theWindow</code> as arbitrary data to make it easy to obtain the control references for the panes.</p></li></ol><p>The actual tab event handler, <code>MyTabEventHandlerProc</code>, determines whether the user has switched tabs. If so, it calls another function to switch panes. <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIEDBBF">Listing 3-15</a></span> shows the event handler. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_154" title="Listing 2-15The tab control event handler"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIEDBBF" title="Listing 2-15The tab control event handler"></a><strong>Listing 2-15&nbsp;&nbsp;</strong>The tab control event handler</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_653"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_654"></a><div class="codesample"><table><tr><td scope="row"><pre>static pascal OSStatus MyTabEventHandlerProc(<span></span></pre></td></tr><tr><td scope="row"><pre>                                EventHandlerCallRef inCallRef,<span></span></pre></td></tr><tr><td scope="row"><pre>                                EventRef inEvent, void* inUserData )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ControlRef          tabControl;<span></span></pre></td></tr><tr><td scope="row"><pre>    static short        lastTabIndex;<span></span></pre></td></tr><tr><td scope="row"><pre>    short               controlValue;<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowRef           window  = (WindowRef)inUserData;<span></span></pre></td></tr><tr><td scope="row"><pre>    ControlID           tabControlID;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    tabControlID.signature = 'Moof';<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    tabControlID.id = 128;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    GetControlByID( window, &amp;tabControlID, &amp;tabControl );<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    controlValue = GetControlValue( tabControl );<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    if ( controlValue != lastTabIndex )<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        MySwitchItemOfTabControl( window, tabControl, controlValue );<span></span></pre></td></tr><tr><td scope="row"><pre>        lastTabIndex = controlValue;<span></span></pre></td></tr><tr><td scope="row"><pre>        return (noErr);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        return( eventNotHandledErr );<span></span></pre></td></tr><tr><td scope="row"><pre>     }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>Redefine the tab control’s signature and control ID. Alternatively, you could define the control ID in a global variable. </p></li><li class="li"><p>Obtain the control reference for the tab control by calling <code>GetControlByID</code>. Note that you used the window reference passed into the event handler as custom data.</p></li><li class="li"><p>Now that you have the tab control reference, you can obtain the value of the control. This value indicates which of the tabs the user selected. </p></li><li class="li"><p>Compare the obtained tab value with the “current” tab value. If they are the same, that means that the user clicked the tab that was currently active, so you don’t need to do anything; the handler simply returns <code>eventNotHandledErr</code>. If they differ, then call the function to switch panes (<code>mySwitchItemOfTabControl</code>), update the current tab value, and then return. </p></li></ol><p>Note that this event handler doesn’t have to call <code>GetEventParameter</code> to obtain any needed information; the value of the tab control is set automatically by the Control Manager when the user clicks a specific tab. </p><p>The actual function to switch panes is shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIIAFCI">Listing 3-16</a></span>.</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_155" title="Listing 2-16The tab switching function"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIIAFCI" title="Listing 2-16The tab switching function"></a><strong>Listing 2-16&nbsp;&nbsp;</strong>The tab switching function</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_655"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_656"></a><div class="codesample"><table><tr><td scope="row"><pre>static  void    MySwitchItemOfTabControl( WindowRef window,<span></span></pre></td></tr><tr><td scope="row"><pre>                            ControlRef tabControl, short currentTabIndex )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ControlID       controlID;<span></span></pre></td></tr><tr><td scope="row"><pre>    ControlRef      userPaneControl;<span></span></pre></td></tr><tr><td scope="row"><pre>    short           i;<span></span></pre></td></tr><tr><td scope="row"><pre>    ControlRef      selectedPaneControl = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>     int            tabList[]           = {2, 129, 130};<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    controlID.signature = 'Moof';<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    for ( i=1 ; i&lt;tabList[0]+1 ; i++ )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        controlID.id    = tabList[i];<span></span></pre></td></tr><tr><td scope="row"><pre>        GetControlByID( window, &amp;controlID, &amp;userPaneControl );<span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if ( i == currentTabIndex )<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>            selectedPaneControl = userPaneControl;<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>            SetControlVisibility( userPaneControl, false, true );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( selectedPaneControl != NULL )<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        (void) ClearKeyboardFocus( window );<span></span></pre></td></tr><tr><td scope="row"><pre>        SetControlVisibility( selectedPaneControl, true, true );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Draw1Control( tabControl );         //  Redraw the tab control itself<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>The <code>tabList</code> array contains the number of tabs (two in this case) followed by the control IDs assigned to each of the panes (called user pane IDs in the nib file).</p></li><li class="li"><p>Obtain the control reference for the pane indexed by the counter <code>i</code>.</p></li><li class="li"><p>If the index is the same as that for the current pane, then save the corresponding control reference. Otherwise, call <code>SetControlVisibility</code> to set the pane visibility to <code>false</code> (hidden) and update the display (by passing <code>true</code>). </p></li><li class="li"><p>If saved control reference is valid, then make that pane visible and update the display. If the previous pane had keyboard focus, you should clear it by calling the <code>ClearKeyboardFocus</code> function.</p></li></ol><p>When you create the window with the tab controls, you should call your tab switching function to initialize the tab settings. Your code might look something like <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCICFFII">Listing 3-17</a></span>.<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_657"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_658"></a></p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_156" title="Listing 2-17Initalializing the tab control setting when creating the window"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCICFFII" title="Listing 2-17Initalializing the tab control setting when creating the window"></a><strong>Listing 2-17&nbsp;&nbsp;</strong>Initalializing the tab control setting when creating the window</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef   tabWindow;<span></span></pre></td></tr><tr><td scope="row"><pre>ControlRef  tabControl;<span></span></pre></td></tr><tr><td scope="row"><pre>ControlID   tabControlID;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>tabControlID.signature = 'Moof';<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>tabControlID.id =128;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CreateWindowFromNib (theNib, CFSTR("Tabs"), &amp;tabWindow);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>GetControlByID (tabWindow, &amp;tabControlID, &amp;tabControl);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>SetControlValue (tabControl, 1);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>MySwitchItemOfTabControl (tabWindow, tabControl, <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>                            GetControlValue (tabControl));<span></span></pre></td></tr><tr><td scope="row"><pre>ShowWindow(tabWindow);<span></span></pre></td></tr></table></div><ol class="ol"><li class="li"><p>First, set the tab control signature and ID so you can obtain the tab control.</p></li><li class="li"><p>After calling <code>GetControlbyID</code> to obtain the tab control reference, call <code>SetControlValue</code> to set its index. This value corresponds to the first, or leftmost, tab. </p></li><li class="li"><p>Call <code>MySwitchItemOfTabControl</code> to make the corresponding pane visible. </p></li></ol><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIBBCBG" title=" Custom Windows and Controls"></a><h2> Custom Windows and Controls</h2><p>For specialized applications you may want to create your own windows or controls. An example might be an immersive science-fiction game with a customized look-and-feel (that is, one that does not rely on Aqua).</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_157" title="Important:"></a><p><strong>Important:</strong>&nbsp;The system-defined controls and windows have a great deal of flexibility in implementing the Aqua user interface. You should not introduce new elements into the Aqua look-and-feel unless you are sure you need functionality that it does not provide.</p><p></p></div><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_659"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_660"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_661"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_662"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_663"></a>The Carbon Event Manager lets you implement custom objects such as windows and controls by creating toolbox object classes for them. A <strong>toolbox object class</strong> is similar to a class in object-oriented programming, except that instead of methods you have event handlers to create and define your objects. </p><p>For example, when first creating a window, the Carbon Event Manager sends an event requesting that you draw the window outline. If a mouse click occurs in the window, an event is sent to determine what part of the window was hit, and so on. Your custom window is essentially a collection of event handlers that define its appearance and behavior. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_158" title="Note"></a><p><strong>Note:</strong>&nbsp;Mac OS systems before Mac OS X relied on message-based custom definitions. The principle was similar: You registered a callback function to handle your custom implementation, and the system could then call your function with specific message parameters that specified what was required. For a list of tables that map the older window and control messages to Carbon events, see <span class="content_text"><a href="../hitb-apdx_a_msgs/hitb-apdx_a_msgs.html#//apple_ref/doc/uid/TP30001004-CH207-BCIDGAJJ">“Carbon Events Versus Classic DefProc Messages”</a></span></p></div><p>The standard system-defined controls and windows are also described by event handlers. The only difference for custom objects is that you must supply the implementation code to handle the events. </p><p>You register your collection of event handlers as a custom object using the <code>RegisterToolboxObjectClass<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_664"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus RegisterToolboxObjectClass (<span></span></pre></td></tr><tr><td scope="row"><pre>                            CFStringRef inClassID<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>                            ToolboxObjectClassRef inBaseClass<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                            UInt32 inNumEvents<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>                            const EventTypeSpec* inEventList<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>                            EventHandlerUPP inEventHandler<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>                            void* inEventHandlerData<span>// 6</span></pre></td></tr><tr><td scope="row"><pre>                            ToolboxObjectClassRef *outClassRef);<span>// 7</span></pre></td></tr></table></div><ol class="ol"><li class="li"><p>The <code>inClassID</code> parameter lets you assign a Core Foundation string to label this class of object. You must assign a unique class name; Apple suggests that you follow the standard naming convention <code>com</code>.<em>CompanyName</em>.<em>Application</em>.<em>ClassName</em>.</p></li><li class="li"><p>If you are subclassing this object from another class, you can specify the base class in the <code>inBaseClass</code> parameter. In true object-oriented fashion, the new object retains the event handlers registered for the base class, although you can override them if you like. </p></li><li class="li"><p>The <code>inNumEvents</code> parameter specifies the number of events you want to register for this object class. </p></li><li class="li"><p>The <code>inEventList</code> array contains the events to register for this object. You define these just as you would for any other Carbon Event handler. In addition to your custom definition events, you should also install the usual event handlers required for the object (such as <code>kEventWindowDrawContent</code> for a window). </p></li><li class="li"><p>The <code>inEventHandler</code> parameter is a universal procedure pointer to the event handler for this object class. </p></li><li class="li"><p>The <code>inEventHandlerData</code> parameter contains any special data you want to pass to your event handler.</p></li><li class="li"><p>On return, <code>outClassRef</code> contains a reference to the new object class. </p></li></ol><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIJIJHF" title="Drawing Using the Appearance Manager"></a><h3>Drawing Using the Appearance Manager</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_665"></a>In cases where you want to add a specialized control or window to the standard interface, you can use Appearance Manager functions to ensure that whatever you draw matches the current theme. </p><p>For example, if you use the Appearance Manager function <code>DrawThemeWindowFrame</code> to draw your window’s frame region, then the frame automatically has the proper look for the type of window you specified. The function <code>SetThemeWindowBackground</code> ensures that your window’s background has the proper look for its type given the current theme. Similar functions exist for drawing controls or parts of controls. For example, even if you use nonstandard controls, you may want to use the Appearance Manager to draw focus rings, obtain the preferred font type and size, and so on. <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIEAFBE">“Creating a Custom Control”</a></span> uses a call to the Appearance Manager function <code>DrawThemeButton</code> to draw a bevel button. </p><p>The Appearance Manager also includes functions to obtain the fonts appropriate for a given theme. For example, you could call <code>GetThemeFont</code> passing <code>kThemePushButtonFont</code> and the appropriate script encoding to obtain the proper font for drawing push button text. </p><p>On Mac OS X, applications are automatically registered with the Appearance Manager, so you do not need to call <code>RegisterAppearanceClient</code> before calling Appearance Manager functions (but there is no penalty if you do). </p><p>For more detailed information, see <em><a href="../../ProgAppearance_Manager/index.html#//apple_ref/doc/uid/TP40001038" target="_top">Programming with the Appearance Manager</a></em> in Carbon Human Interface Toolbox documentation.<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_666"></a></p><a name="//apple_ref/doc/uid/TP30001004-CH206-TPXREF171" title="Creating a Custom Window "></a><h3>Creating a Custom Window </h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_667"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_668"></a>To create a custom window, you must write handlers to respond to a number of different events. <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIHGCIF">Table 3-5</a></span> lists the most common events.</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_159" title="Table 2-5Custom window events"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIHGCIF" title="Table 2-5Custom window events"></a><strong>Table 2-5&nbsp;&nbsp;</strong>Custom window events</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Event</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Required Action </p></th></tr><tr><td  scope="row"><p><code>kEventWindowDrawFrame<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_669"></a></code></p></td><td ><p>Draw the frame region, including any controls within it.</p></td></tr><tr><td  scope="row"><p><code>kEventWindowDrawPart<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_670"></a></code></p></td><td ><p>Draw a specific part in the window, such as the close button. The part to be drawn is specified by the <code>kEventParamWindowDefPart</code> parameter. </p></td></tr><tr><td  scope="row"><p><code>kEventWindowPaint<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_671"></a></code></p></td><td ><p>Draw the frame region and the content region. In cases where you need to draw both at the same time, acting on this event is more efficient than handling both <code>kEventWindowDrawFrame</code> and <code>kEventWindowDrawPart</code> (specifying the content region). </p></td></tr><tr><td  scope="row"><p><code>kEventWindowGetRegion<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_672"></a></code></p></td><td ><p>Return the region specified by <code>kEventParamWindowRegionCode</code> in the <code>kEventParamRgnHandle</code> parameter. The window region codes are defined in <code>MacWindows.h</code>.</p></td></tr><tr><td  scope="row"><p><code>kEventWindowHitTest<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_673"></a></code></p></td><td ><p>Based on the mouse location passed into <code>kEventParamMouseLocation</code>, return the part hit (close button, size button, drag region, and so on) in the <code>kEventParamWindowDefPart</code> parameter. </p></td></tr><tr><td  scope="row"><p><code>kEventWindowInit<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_674"></a></code></p></td><td ><p>Perform any specific window initialization. Return the features of the window in the <code>kEventParamWindowFeatures</code> parameter. The window feature bits are defined in <code>MacWindows.h</code>.</p></td></tr><tr><td  scope="row"><p><code>kEventWindowDispose<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_675"></a></code></p></td><td ><p>Perform any cleanup required before disposing of the window. Note that you do not dispose of the window in this handler. </p></td></tr><tr><td  scope="row"><p><code>kEventWindowStateChanged<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_676"></a></code></p></td><td ><p>Any changes required to reflect the new state-change flag settings (passed in the <code>kEventParamWindowStateChangedFlags</code>parameter. An example would be if the title changed for a document window. </p></td></tr><tr><td  scope="row"><p><code>kEventWindowDragHilite<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_677"></a></code></p></td><td ><p>Depending on the state of the Boolean <code>kEventParamWindowDragHiliteFlag</code> parameter, draw or erase any highlighting associated with a dragged object (such as when the user attempts to drag a selection into the window). Needed only if your window supports drag-and-drop. </p></td></tr><tr><td  scope="row"><p><code>kEventWindowModified<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_678"></a></code></p></td><td ><p>Redraw the window to reflect whether this document window is in its modified or unmodified state, depending on the value of the <code>kEventParamWindowModififiedFlag</code> parameter. For example, for Aqua document windows, if the content has been modified but not saved, the close button contains a small black dot. </p></td></tr></table></div><p>Implementing the event handlers is the most involved part of creating a custom window; all the drawing, hit-testing, and similar manipulation that was previously performed by the Window Manager is now your responsibility. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_160" title="Important:"></a><p><strong>Important:</strong>&nbsp;The events in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIHGCIF">Table 3-5</a></span> indicate handlers you should implement in addition to the usual window event handlers. Also, some of the usual handlers may need to accomplish additional tasks. For example, the <code>kEventWindowDeactivated</code> handler must now gray out or otherwise change the look of the window to indicate its inactive state. </p><p></p></div><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIDADIE">Listing 3-18</a></span> shows the handler for a very simple custom window. It creates a 200 pixel x 200 pixel box with a 10 pixel wide black border which the user can drag around the screen. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_161" title="Listing 2-18A simple custom window event handler"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIDADIE" title="Listing 2-18A simple custom window event handler"></a><strong>Listing 2-18&nbsp;&nbsp;</strong>A simple custom window event handler</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_679"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_680"></a><div class="codesample"><table><tr><td scope="row"><pre>static pascal OSStatus MyCustomWindowEventHandler (<span></span></pre></td></tr><tr><td scope="row"><pre>                                EventHandlerCallRef myHandler,<span></span></pre></td></tr><tr><td scope="row"><pre>                                EventRef theEvent, void* userData)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    #pragma unused (myHandler,userData)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus result = eventNotHandledErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 whatHappened;<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowDefPartCode where;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    GrafPtr thePort;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect windBounds;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    whatHappened = GetEventKind (theEvent);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch (whatHappened)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventWindowInit:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            GetEventParameter (theEvent, kEventParamDirectObject,                                typeWindowRef, NULL, sizeof(WindowRef),                                NULL, &amp;newWindow);<span></span></pre></td></tr><tr><td scope="row"><pre>            SetThemeWindowBackground (newWindow,                            kThemeBrushMovableModalBackground, true);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>            result = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventWindowDrawFrame:<span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            GetPort (&amp;thePort);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>            GetPortBounds (thePort, &amp;windBounds);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            PenNormal();<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>            PenSize (10,10);<span></span></pre></td></tr><tr><td scope="row"><pre>            FrameRect (windBounds);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            result = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventWindowHitTest:<span>// 6</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            /* determine what part of the window the user hit */<span></span></pre></td></tr><tr><td scope="row"><pre>            where = wInDrag;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            SetEventParameter (theEvent, kEventParamWindowDefPart,<span>// 7</span></pre></td></tr><tr><td scope="row"><pre>                                typeWindowDefPartCode,<span></span></pre></td></tr><tr><td scope="row"><pre>                                sizeof(WindowDefPartCode), &amp;where);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            result = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return (result);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>When your event handler receives the <code>kEventWindowInit</code> event, it should do any one time initialization. This example uses the Carbon Event Manager function <code>GetEventParameter</code> to obtain the reference to the new window, and then calls the Appearance Manager function <code>SetThemeWindowBackground</code> to set the window’s background pattern. The <code>kThemeBrushMovableModalBackground</code> specifies the gray striped background associated with Mac OS X dialogs and alerts. </p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_681"></a>When your handler receives the <code>kEventWindowDrawFrame</code> event, it should draw (or redraw) the frame region of the window (That is, the area of the window that is not part of the content region). You can do so using QuickDraw or Quartz (Core Graphics) function calls. This example uses QuickDraw. While this document briefly describes the functions required, for more detailed information, you should consult the QuickDraw documentation. </p><p>Note that prior to Mac OS X, if an object required a fair amount of drawing to render, you would first draw it offscreen and then copy the completed object to the screen when you are finished. (An offscreen graphics world is simply a drawing environment that is not part of the visible screen.) However, because Mac OS X automatically provides window buffering, you no longer need to draw offscreen. All drawing is directed to a window back buffer which is then copied to the screen as necessary. In fact, buffering the window yourself can actually affect performance. </p></li><li class="li"><p>Call the QuickDraw functions <code>GetPort</code> and <code>GetPortBounds</code> to find the bounds of the current graphics world. These are the bounds you specify when calling <code>CreateCustomWindow</code> to create the window. </p></li><li class="li"><p>The QuickDraw function <code>PenNormal</code> sets the drawing “pen” to its default state. In default mode, the pen size is 1x1 pixel and it draws in solid black. The QuickDraw function <code>PenSize</code> sets the pen size to be 10 pixels wide by 10 pixels high.</p></li><li class="li"><p>The QuickDraw function <code>FrameRect</code> draws an outline of the specified rectangle using the current pen values.</p></li><li class="li"><p>When your handler receives the <code>kEventWindowHitTest</code> event, it should check to see what part of the window the mouse is in. Your application receives this event whether the mouse is up or down. See <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIJCJBF">Table 3-6</a></span> for a list of possible part constants. This example simply returns <code>wInDrag</code> indicating that the mouse is in the drag region, which means that the user can drag the window if the mouse is down. If your window uses the standard window handler, then the actual dragging is done for you. </p><p>To determine the location of the mouse, you should call the Carbon Event Manager function <code>GetEventParameter</code>, specifying the <code>kEventParamMouseLocation</code> parameter. </p></li><li class="li"><p>To return the part in which the mouse is located, call the Carbon Event Manager function <code>SetEventParameter</code>, setting the appropriate part constant in the <code>kEventParamWindowDefPart</code> parameter.<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_682"></a></p></li></ol><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_162" title="Table 2-6Window part definition constants"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIJCJBF" title="Table 2-6Window part definition constants"></a><strong>Table 2-6&nbsp;&nbsp;</strong>Window part definition constants</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Constant</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Mouse location</p></th></tr><tr><td  scope="row"><p><code>wNoHit</code></p></td><td ><p>No part hit.</p></td></tr><tr><td  scope="row"><p><code>wInContent</code></p></td><td ><p>In content region</p></td></tr><tr><td  scope="row"><p><code>wInDrag</code></p></td><td ><p>In the drag region</p></td></tr><tr><td  scope="row"><p><code>wInGrow</code></p></td><td ><p>In the resize control</p></td></tr><tr><td  scope="row"><p><code>wInGoAway</code></p></td><td ><p>In the Close button</p></td></tr><tr><td  scope="row"><p><code>wInZoomIn</code></p></td><td ><p>In the Size button (for zooming in)</p></td></tr><tr><td  scope="row"><p><code>wZoomOut</code></p></td><td ><p>In the Size button (for zooming out)</p></td></tr><tr><td  scope="row"><p><code>wInCollapseBox</code></p></td><td ><p>In the Minimize button</p></td></tr><tr><td  scope="row"><p><code>wInProxyIcon</code></p></td><td ><p>In the proxy icon</p></td></tr><tr><td  scope="row"><p><code>wInA</code></p></td><td ><p>Used if you want to define a nonstandard region or control</p></td></tr><tr><td  scope="row"><p><code>wInB</code></p></td><td ><p>Used if you want to define a nonstandard region or control</p></td></tr></table></div><p>After you have created your window definition handlers, you register them as a toolbox object by calling <code>RegisterToolboxObjectClass</code>. Then, to instantiate one of your custom windows, you call the <code>CreateCustomWindow</code> function. <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIJACJB">Listing 3-19</a></span> gives an example of registering and creating a custom window. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_163" title="Listing 2-19Registering a toolbox object class and instantiating a custom window"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIJACJB" title="Listing 2-19Registering a toolbox object class and instantiating a custom window"></a><strong>Listing 2-19&nbsp;&nbsp;</strong>Registering a toolbox object class and instantiating a custom window</p><div class="codesample"><table><tr><td scope="row"><pre>ToolboxObjectClassRef customWindow;<span></span></pre></td></tr><tr><td scope="row"><pre>WindowRef myWindow;<span></span></pre></td></tr><tr><td scope="row"><pre>WindowDefSpec myCustomWindowSpec;<span></span></pre></td></tr><tr><td scope="row"><pre>EventHandlerUPP myCustomWindowUPP;<span></span></pre></td></tr><tr><td scope="row"><pre>Rect theBounds = {200,200,400,400};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EventTypeSpec eventList[] = {{kEventClassWindow, kEventClassWindowInit},<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>                            {kEventClassWindow, kEventWindowDrawFrame},<span></span></pre></td></tr><tr><td scope="row"><pre>                            {kEventClassWindow, kEventWindowHitTest}};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>myCustomWindowUPP = NewEventHandlerUPP(MyCustomWindowEventHandler;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>RegisterToolboxObjectClass ( CFSTR("com.myCompany.myApp.customWindow"),<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                        NULL, EventTypeCount(eventList), eventList,<span></span></pre></td></tr><tr><td scope="row"><pre>                        myCustomWindowUPP), NULL, &amp;customWindow);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>myCustomWindowSpec.defType = kWindowDefObjectClass;<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>myCustomWindowSpec.u.classRef = customWindow;<span>// 4</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CreateCustomWindow (&amp;myCustomWindowSpec,kMovableModalWindowClass,<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>                    kWindowStandardHandlerAttribute,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;theBounds,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;myWindow);<span></span></pre></td></tr><tr><td scope="row"><pre>ShowWindow(myWindow);<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>You set up your <code>EventTypeSpec</code> array just as if you were specifying events for a system-defined window. The only difference is that you also want to register for the events required for custom windows. In this simple example, you register for only three events: <code>kEventWindowInit</code> for initialization, <code>kEventWindowDrawFrame</code> to draw the window’s frame region, and <code>kEventWindowHitTest</code>, to determine which part of the window the mouse is in</p></li><li class="li"><p>Call <code>RegisterToolboxObjectClass</code>, passing your event list and specifying the UPP of the event handler to be called (<code>MyCustomWindowEventHandler</code>, in this case). The object class reference is stored in <code>customWindow</code>.</p></li><li class="li"><p>The <code>CreateCustomWindow<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_683"></a></code> function requires you to pass a window definition specification structure (type <code>WindowDefSpec</code>) which describes the window definition you are passing. The first field, <code>defType</code>, indicates the kind of window definition you are using. <code>kWindowDefObjectClass</code> specifies a toolbox object class. Other options are <code>kWindowDefProcPtr</code>, for a pointer to a window definition function, and <code>kWindowDefProcID</code>, indicating a resource-based window definition. Note that the latter two are supported mostly for legacy purposes. </p></li><li class="li"><p>The <code>WindowDefSpec</code> structure also includes a union which, depending on the constant you passed in the <code>defType</code> field, can be either a toolbox object reference (as in this example), a pointer to a window definition function, or the ID of a window definition resource.</p></li><li class="li"><p>The <code>CreateCustomWindow</code> function is similar to the <code>CreateNewWindow</code> function, except that you pass your <code>WindowDefSpec</code> structure in addition to the usual document class, window attributes, and window bounds. The window class you specify is partly determined by the type of window you defined, but it also defines other behaviors (such as in which window layer your custom window will appear). Specifying the standard window handler gives us some additional functionality, such as window dragging, for free. </p><p>On return <code>CreateCustomWindow</code> gives you a window reference, which you can then manipulate as desired. <a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_684"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_685"></a></p></li></ol><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIFDDEC" title="Drawing Using Quartz"></a><h3>Drawing Using Quartz</h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_686"></a>Most of the <a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_687"></a>examples in this document assume you are using QuickDraw to draw your windows. However, if you are targeting Mac OS X only, you can also use Quartz (sometimes called Core Graphics) to draw, or draw into, your windows. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_164" title="Note"></a><p><strong>Note:</strong>&nbsp;If you plan to use Quartz as your primary graphics engine, you should think about adopting the new HIView-based control model. See <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGBJHE">“Introducing HIObject and HIView (Mac OS X 10. 2 and Later)”</a></span> for details. </p></div><p>Drawing using Quartz is similar to drawing with QuickDraw except that you draw into a Core Graphics context instead of a graphics port. The coordinate system is also different. <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGFEIC">Listing 3-20</a></span> shows how you would draw the rectangular custom window in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIDADIE">Listing 3-18</a></span> if you were using Quartz.</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_165" title="Listing 2-20Drawing a simple custom window with Quartz"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIGFEIC" title="Listing 2-20Drawing a simple custom window with Quartz"></a><strong>Listing 2-20&nbsp;&nbsp;</strong>Drawing a simple custom window with Quartz</p><div class="codesample"><table><tr><td scope="row"><pre>GrafPtr thePort;<span></span></pre></td></tr><tr><td scope="row"><pre>Rect windBounds;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGContextRef theCGContext;<span></span></pre></td></tr><tr><td scope="row"><pre>CGRect myCGRect;<span></span></pre></td></tr><tr><td scope="row"><pre>…<span></span></pre></td></tr><tr><td scope="row"><pre>case kEventWindowDraw:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        GetPort (&amp;thePort);<span></span></pre></td></tr><tr><td scope="row"><pre>        GetPortBounds(thePort, &amp;windBounds);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        QDBeginCGContext(thePort, &amp;theCGContext);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        CGContextTranslateCTM(theCGContext, 0, <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                        (float)(windBounds.bottom - windBounds.top));<span></span></pre></td></tr><tr><td scope="row"><pre>        CGContextScaleCTM(theCGContext, 1, -1);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        myCGRect.origin.x = (float) windBounds.left + 5.0 ;<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>        myCGRect.origin.y = (float) windBounds.top + 5.0 ;<span></span></pre></td></tr><tr><td scope="row"><pre>        myCGRect.size.width =<span></span></pre></td></tr><tr><td scope="row"><pre>                    (float)(windBounds.right - windBounds.left) - 10.0;<span></span></pre></td></tr><tr><td scope="row"><pre>        myCGRect.size.height =<span></span></pre></td></tr><tr><td scope="row"><pre>                    (float)(windBounds.bottom -windBounds.top) - 10.0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        CGContextStrokeRectWithWidth (theCGContext, myCGRect,10.0);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>        QDEndCGContext(thePort, &amp;theCGContext);<span>// 6</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        result = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr></table></div><p>Here is how the code works:</p><ol class="ol"><li class="li"><p>After obtaining the window’s graphics port as usual, you then pass it into the QuickDraw function <code>QDBeginContext</code> to create the Core Graphics context. </p></li><li class="li"><p>The Quartz coordinate system is different from that for QuickDraw, so for convenience you can transform the context to accept QuickDraw-style coordinates. Quartz assumes the origin to be at the bottom left of the context, while QuickDraw assumes the upper left. The Core Graphics function <code>CGContextTranslateCTM</code> function shifts all y coordinates up by the height of the context (equivalent to the height of the port).</p></li><li class="li"><p>As increasing y coordinate values in Quartz move in the opposite direction to QuickDraw coordinates, you call the Core Graphics function <code>CGContextScaleCTM</code> to invert the coordinate system. Note that doing so means that any text you draw will be inverted!</p></li><li class="li"><p>The <code>myCGRect</code> rectangle (essentially the Quartz equivalent of a QuickDraw Rect structure) defines the rectangular window to be drawn. Because the rectangle defines the center lines of the 10-pixel wide border, you need to “inset” the rectangle by 5 pixels on each side. The resulting rectangle then fills out to the edges of the context. </p></li><li class="li"><p>Call the <code>CGContextStrokeRectWithWidth</code> function to draw the rectangle. Note that all Quartz functions take floating-point coordinates and values. </p></li><li class="li"><p>After drawing, call the QuickDraw function <code>QDEndCGContext</code> to remove the graphics context. Any drawing you do after this call is in the QuickDraw graphics port. </p></li></ol><p>For more information about Quartz, see <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em> in Carbon Graphics and Imaging documentation. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIEAFBE" title="Creating a Custom Control "></a><h3>Creating a Custom Control </h3><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_688"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_689"></a>You create custom controls in a manner similar to creating custom windows: you write event handlers to take care of drawing and manipulating your control, and then you register your control as a custom toolbox object. However, the variety of control events available is much larger, because controls have a much wider range of functionality than windows. One thing you can assume, however, is that you must now implement more control functionality that was previously handled by the standard handler. <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIEHEIJ">Table 3-7</a></span> indicates additional steps your custom control must take for the common control events described in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-TPXREF141">“Control Events.”</a></span></p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_166" title="Table 2-7Actions required for common control events"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIEHEIJ" title="Table 2-7Actions required for common control events"></a><strong>Table 2-7&nbsp;&nbsp;</strong>Actions required for common control events</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Event</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Required Action</p></th></tr><tr><td  scope="row"><p><code>kEventControlActivate<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_690"></a></code></p></td><td ><p>Draw your control to reflect its active state</p></td></tr><tr><td  scope="row"><p><code>kEventControlDeactivate<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_691"></a></code></p></td><td ><p>Gray out or otherwise change the appearance of your control to reflect its inactive state. </p></td></tr><tr><td  scope="row"><p><code>kEventControlHitTest<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_692"></a></code></p></td><td ><p>Based on the mouse location passed into <code>kEventParamMouseLocation</code>, return the part hit (indicator, inactive, or disabled part, application-defined part, and so on) in the <code>kEventParamControlPart</code> parameter. </p></td></tr><tr><td  scope="row"><p><code>kEventControlHit<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_693"></a></code></p></td><td ><p>Make changes to the control to reflect the state after it was hit (for example, putting a check in a checkbox).</p></td></tr><tr><td  scope="row"><p><code>kEventControlTrack<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_694"></a></code></p></td><td ><p>Provide any visual feedback required while the mouse is down. For example, you must move scroll bars, highlight or unhighlight buttons, and so on. Even if you are using a control action callback to perform live updates, you should handle any control-related changes during this tracking event. Note that you may not need to handle this event for simple controls (see <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIFFJDD">Listing 3-21</a></span> for an example). </p></td></tr><tr><td  scope="row"><p><code>kEventControlDraw<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_695"></a></code></p></td><td ><p>Draw your control or (if the <code>kEventParamControlPart</code> parameter is present) a specific part of your control.</p></td></tr><tr><td  scope="row"><p><code>kEventControlBoundsChanged<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_696"></a></code></p></td><td ><p>Resize your control to reflect its new size. The Control Manager will send you a <code>kEventControlDraw</code> event to redraw the control (assuming that it is visible). </p></td></tr></table></div><p>In addition, <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIBJIBE">Table 3-8</a></span> lists some additional control events that your custom control may need to handle. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_167" title="Table 2-8Additional custom control events"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIBJIBE" title="Table 2-8Additional custom control events"></a><strong>Table 2-8&nbsp;&nbsp;</strong>Additional custom control events</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Event</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Required Action</p></th></tr><tr><td  scope="row"><p><code>kEventControlInitialize<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_697"></a></code></p></td><td ><p>Perform any initializations required before creating the control. </p></td></tr><tr><td  scope="row"><p><code>kEventControlDispose<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_698"></a></code></p></td><td ><p>Perform any required cleanup before the control is disposed. Note that you do not dispose of the control in this handler. </p></td></tr><tr><td  scope="row"><p><code>kEventControlSimulateHit<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_699"></a></code></p></td><td ><p>Provide visual feedback as if the control was actually hit. You normally receive this event in response to some other action, such as a Return key being hit as a default button. </p></td></tr><tr><td  scope="row"><p><code>kEventControlSetFocusPart<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_700"></a></code></p></td><td ><p>Change the keyboard focus to reflect what was sent in the <code>kEventParamControlPart</code> parameter. </p></td></tr><tr><td  scope="row"><p><code>kEventControlGetFocusPart<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_701"></a></code></p></td><td ><p>Set the <code>kEventParamControlPart</code> parameter to the part that currently has the keyboard focus. </p></td></tr><tr><td  scope="row"><p><code>kEventControlGetPartRegion<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_702"></a></code></p></td><td ><p>Set the region handle passed in the <code>kEventParamControlRegion</code> parameter to the region of the part specified in the <code>kEventParamControlPart</code> parameter. </p></td></tr></table></div><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIFFJDD">Listing 3-21</a></span> shows a handler for creating a very simple custom control. This example simply handles the hit test, draw, and hit control events, and relies on the standard handler to take care of mouse tracking. It uses Appearance Manager functions to draw the actual control. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_168" title="Listing 2-21A simple custom control handler"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIFFJDD" title="Listing 2-21A simple custom control handler"></a><strong>Listing 2-21&nbsp;&nbsp;</strong>A simple custom control handler</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_703"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_704"></a><div class="codesample"><table><tr><td scope="row"><pre>static pascal OSStatus MyCustomControlHandler (<span></span></pre></td></tr><tr><td scope="row"><pre>                                    EventHandlerCallRef myHandler,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    EventRef theEvent, void* userData)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    #pragma unused (myHandler, userData)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus result = eventNotHandledErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 whatHappened;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ControlRef theControl;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect controlBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>    ControlPartCode whatPart;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16 hiliteState;<span></span></pre></td></tr><tr><td scope="row"><pre>    RgnHandle controlRegion;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Point mouseLocation;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ThemeButtonDrawInfo myButtonInfo;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    myButtonInfo.state = kThemeStateActive;<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    myButtonInfo.value = kThemeButtonOff;<span></span></pre></td></tr><tr><td scope="row"><pre>    myButtonInfo.adornment = kThemeAdornmentDefault;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    hiliteState = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    whatHappened = GetEventKind (theEvent);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch (whatHappened)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventControlHitTest:<span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            GetEventParameter (theEvent, kEventParamDirectObject,<span></span></pre></td></tr><tr><td scope="row"><pre>                                typeControlRef, NULL, sizeof(ControlRef),<span></span></pre></td></tr><tr><td scope="row"><pre>                                NULL, &amp;theControl);<span></span></pre></td></tr><tr><td scope="row"><pre>            GetEventParameter (theEvent, kEventParamMouseLocation,<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>                                typeQDPoint, NULL, sizeof (Point), NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                                &amp;mouseLocation);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            GetControlBounds(theControl, &amp;controlBounds);<span></span></pre></td></tr><tr><td scope="row"><pre>            GetThemeButtonRegion (&amp;controlBounds,<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>                            kThemeRoundedBevelButton,<span></span></pre></td></tr><tr><td scope="row"><pre>                            &amp;myButtonInfo, controlRegion);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            if (PtInRgn(mouseLocation, controlRegion) == true<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>                    whatPart = 5; // == kSomeAppDefinedPart<span></span></pre></td></tr><tr><td scope="row"><pre>                else<span></span></pre></td></tr><tr><td scope="row"><pre>                    whatPart = kControlNoPart;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            SetEventParameter (theEvent, kEventParamControlPart,<span>// 6</span></pre></td></tr><tr><td scope="row"><pre>                                typeControlPartCode,<span></span></pre></td></tr><tr><td scope="row"><pre>                                sizeof(ControlPartCode),<span></span></pre></td></tr><tr><td scope="row"><pre>                                &amp;whatPart);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            result = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventControlDraw:<span>// 7</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            GetEventParameter (theEvent, kEventParamDirectObject,<span>// 8</span></pre></td></tr><tr><td scope="row"><pre>                                typeControlRef, NULL, sizeof(ControlRef),<span></span></pre></td></tr><tr><td scope="row"><pre>                                NULL, &amp;theControl);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            GetControlBounds (theControl, &amp;controlBounds);<span>// 9</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            hiliteState = GetControlHilite (theControl);<span>// 10</span></pre></td></tr><tr><td scope="row"><pre>            if (hiliteState !=0)<span>// 11</span></pre></td></tr><tr><td scope="row"><pre>                    myButtonInfo.value = kThemeButtonOn;<span></span></pre></td></tr><tr><td scope="row"><pre>                else<span></span></pre></td></tr><tr><td scope="row"><pre>                    myButtonInfo.value = kThemeButtonOff;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            DrawThemeButton (&amp;controlBounds, kThemeRoundedBevelButton,<span>// 12</span></pre></td></tr><tr><td scope="row"><pre>                             &amp;myButtonInfo,NULL, NULL, NULL,0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            result = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventControlHit:<span>// 13</span></pre></td></tr><tr><td scope="row"><pre>            SysBeep (1);<span></span></pre></td></tr><tr><td scope="row"><pre>            result = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return (result);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_705"></a>When calling the Appearance Manager function <code>DrawThemeButton</code>, you must pass a <code>ThemeButtonDrawInfo</code> structure describing the state of the button. The <code>kThemeStateActive</code> constant indicates the control is active. <code>kThemeButtonOff</code> indicates that the button is in its off (that is, unpressed) state. <code>kThemeAdornmentDefault</code> specifies that you want the default look for the type of button. </p></li><li class="li"><p>Whenever the Control Manager needs to know which part of the control the mouse is in, it sends the <code>kEventHitTest</code> event. Your application should determine the part the mouse is in and then return a part code in the event reference. Note that you receive the hit test event whenever the user presses the mouse within the control’s bounding rectangle; if the control does not fully occupy the rectangle (for example if it is round), it is possible that the control itself was not hit. </p></li><li class="li"><p>First, use <code>GetEventParameter</code> to obtain the control reference and the mouse location. </p></li><li class="li"><p>After obtaining the control bounds, pass this value into the Appearance Manager function <code>GetThemeButtonRegion</code>. This function returns the area of any standard Appearance-compliant button as a region. You specify the button type and a button info structure (which you filled out in step 1.)</p></li><li class="li"><p>Now that you have both the mouse location and the region of the button, call the QuickDraw function <code>PtInRgn</code> to determine if the mouse point is within the control. If so, set the part code to be some nonnegative value in the range 1-127. Note that the actual part code can be arbitrary, depending on your control. For example, if your control has multiple states, you can assign specific values for each. If the control has several subparts, you can assign values specifying each subpart as well as highlight states for each subpart. <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGADGA">Table 3-9</a></span> shows some standard constants defined for control parts. (Apple reserves all negative part codes.) If the mouse is outside the control, set the part code to <code>kControlNoPart</code>. </p><p>Note that if you knew that your control entirely filled the control bounds (that is, the control was rectangular), you could use the QuickDraw function <code>PtInRect</code> to determine if the mouse was within the bounds without having to obtain a region. </p></li><li class="li"><p>Use the <code>SetEventParameter</code> function to return the part code in the event reference. The value you pass is set as the control’s highlight value, which you can access later from your drawing routine. </p></li><li class="li"><p>When the <code>kEventControlDraw</code> event occurs, you must draw your control. This example draws an Appearance-compliant bevel button within the control bounds. </p></li><li class="li"><p>Call the Carbon Event Manager function <code>GetEventParameter</code> to get the control reference. </p></li><li class="li"><p>With the control reference, you can call <code>GetControlBounds</code> to get the bounds of your control. </p></li><li class="li"><p>Call the <code>GetControlHilite</code> function to get the highlight state of the button. This value is simply the part code you passed back in your hit test routine. While some controls may have several states, a simple push button has only two: the unpressed state, and the highlighted (pressed) state. </p></li><li class="li"><p>If the button is to be in its highlighted state, change the value in the button info structure to specify that it should be drawn in its “on” state. </p></li><li class="li"><p>Call the Appearance Manager function <code>DrawThemeButton</code> to draw your button. You pass the bounds within which to draw the control, a constant specifying the type of button, and the button info structure, just as you did for the <code>GetThemeButtonRegion</code> function. </p><p>Note that while the bounds you pass are the “base” bounds used to draw the control, the control may not always be wholly within those bounds. For example, a control’s drop shadow is drawn outside of the bounds. If the bounds are too small, much of the control may appear outside of them. Some Appearance Manager calls actually draw entirely outside the specified bounds. For example, the <code>DrawThemeWindowFrame</code> function assumes the bounds you pass define the content region, so it draws the frame outside those bounds. </p><p><code>DrawThemeButton</code> also takes additional parameters (set to <code>NULL</code> in this example) that you may find useful:</p><ul class="ul"><li class="li"><p>A second <code>ThemeButtonDrawInfo</code> structure that describes the previously-drawn button. This state information is useful if you are drawing a control that uses transition animation, such as a disclosure triangle, to switch between states. </p></li><li class="li"><p>A universal procedure pointer to a custom erase function. </p></li><li class="li"><p>A universal procedure pointer to a custom draw function. </p></li></ul><p>The final parameter (set to 0 in this example) is for any custom data you may want to assign to the button. </p></li><li class="li"><p>If the user releases the mouse while in the control, the Carbon Event Manager sends a <code>kEventControlHit</code> event to the control, and your handler can take appropriate action. This example simply beeps to indicate a hit. </p></li></ol><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_169" title="Table 2-9Control part constants"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIGADGA" title="Table 2-9Control part constants"></a><strong>Table 2-9&nbsp;&nbsp;</strong>Control part constants</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Constant</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Mouse location</p></th></tr><tr><td  scope="row"><p><code>kControlNoPart</code> = 0</p></td><td ><p>Not in the control </p></td></tr><tr><td  scope="row"><p><code>kControlIndicatorPart</code> = 129</p></td><td ><p>In the indicator</p></td></tr><tr><td  scope="row"><p><code>kControlDisabledPart</code> = 254</p></td><td ><p>In a part that is disabled (the control is disabled)</p></td></tr><tr><td  scope="row"><p><code>kControlInactivePart</code> = 255</p></td><td ><p>In an inactive part (the control is deactivated)</p></td></tr><tr><td  scope="row"><p>Any other positive value</p></td><td ><p>In an application-defined part</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIHHIDI" title="Custom Control Tracking"></a><h4>Custom Control Tracking</h4><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_706"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_707"></a>In <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIFFJDD">Listing 3-21</a></span>, all of the actual mouse tracking is handled by the standard event handler, and in most cases that is all you need. However, if you want more control over the tracking behavior, you must incorporate a <code>kEventControlTrack</code> event handler into your application. The basic event sequence that occurs during mouse tracking is as follows:</p><ol class="ol"><li class="li"><p>When the user presses the mouse in a control’s bounding area (that is, the rectangle containing the control, that control receives a <code>kEventControlHitTest</code> event. </p></li><li class="li"><p>The control then needs to determine what part of itself was hit, and return a part code (using the Carbon Event Manager function <code>SetEventParameter</code>). If no part of the control was actually hit (that is, the mouse-down occurred within the control’s bounding rectangle, but not actually within the control), the part hit should be <code>kControlNoPart</code>. This step is essentially implemented in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIFFJDD">Listing 3-21</a></span>. </p></li><li class="li"><p>If a valid part of the control was hit (that is, the part code was not <code>kControlNoPart</code>), the control then receives a <code>kEventControlTrack<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_708"></a></code> event. </p></li><li class="li"><p>Upon receiving the tracking event, the control must then track the mouse by calling the Carbon Event Manager function <code>TrackMouseLocation<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_709"></a></code> or <code>TrackMouseRegion<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_710"></a></code>. If you need to redraw your control in response to the tracking, you must do so within this handler. </p><p>If your control has an action callback associated with it, the callback is called continuously during tracking. </p><p>When mouse tracking ends, your tracking handler should call <code>SetEventParameter</code> to indicate which part of the control the mouse was in when it was released.</p></li><li class="li"><p>If the mouse was released in a valid part of the control, the control is sent a <code>kEventControlHit</code> event indicating which part was hit. The handler for the control hit event can then take any required action. </p></li></ol><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_170" title="Note"></a><p><strong>Note:</strong>&nbsp; The above sequence assumes that you are using the standard window handler. If you did not specify the standard handler, you must intercept the original <code>kEventMouseDown</code> event and perform the initial hit testing yourself. If the hit test was valid, you must call <code>HandleControlClick<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_711"></a></code> on the control , which sends a <code>kEventControlTrack</code> event to the control. You can then handle steps 4 and 5 as before. </p></div><p><span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGAAAF">Listing 3-22</a></span> shows a template for what your control tracking event handler might look like: </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_171" title="Listing 2-22A template for a custom tracking handler"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIGAAAF" title="Listing 2-22A template for a custom tracking handler"></a><strong>Listing 2-22&nbsp;&nbsp;</strong>A template for a custom tracking handler</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_712"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_713"></a><div class="codesample"><table><tr><td scope="row"><pre>static pascal OSStatus MyCustomControlTrackingHandler (<span></span></pre></td></tr><tr><td scope="row"><pre>                                    EventHandlerCallRef myHandler,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    EventRef theEvent, void* userData)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    #pragma unused (myHandler, userData)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus result = eventNotHandledErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    ControlPartCode whatPart;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ControlRef theControl;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect controlBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>    RgnHandle controlRegion;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean IsInRegion;<span></span></pre></td></tr><tr><td scope="row"><pre>    MouseTrackingResult trackingResult;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    GetEventParameter (theEvent, kEventParamDirectObject,<span></span></pre></td></tr><tr><td scope="row"><pre>                        typeControlRef, NULL, sizeof(ControlRef), NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                        &amp;theControl);<span></span></pre></td></tr><tr><td scope="row"><pre>    GetControlBounds (theControl, &amp;controlBounds);<span></span></pre></td></tr><tr><td scope="row"><pre>    /* obtain a region based on the control bounds here *<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    trackingResult = kMouseTrackingMouseEntered;<span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while (trackingResult != kMouseTrackingMouseUp)<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>        switch (trackingResult)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>             case kMouseTrackingMouseEntered:<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>                /* Mouse has entered the region */<span></span></pre></td></tr><tr><td scope="row"><pre>                 break;<span></span></pre></td></tr><tr><td scope="row"><pre>             case kMouseTrackingMouseExited:<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>                /* Mouse has exited the region */<span></span></pre></td></tr><tr><td scope="row"><pre>                 break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>             case kMouseTrackingMouseDragged:<span>// 6</span></pre></td></tr><tr><td scope="row"><pre>                /* Mouse moved while still down*/<span></span></pre></td></tr><tr><td scope="row"><pre>                 break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>         TrackMouseRegion (NULL, controlRegion, &amp;isInRegion,<span></span></pre></td></tr><tr><td scope="row"><pre>                         &amp;trackingResult);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    if (isInRegion == true)<span>// 7</span></pre></td></tr><tr><td scope="row"><pre>             whatPart = kMyPartCode; // application-defined<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>             whatPart = kControlNoPart;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetEventParameter (theEvent, kEventParamControlPart,<span></span></pre></td></tr><tr><td scope="row"><pre>                                typeControlPartCode,<span></span></pre></td></tr><tr><td scope="row"><pre>                                sizeof(ControlPartCode),<span></span></pre></td></tr><tr><td scope="row"><pre>                                &amp;whatPart);<span></span></pre></td></tr><tr><td scope="row"><pre>    result = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>This tracking handler uses the Carbon Event Manager function <code>TrackMouseRegion</code>, which requires you to pass a region handle that indicates the valid control area. Typically you need to calculate a region based on the bounds of the control. </p></li><li class="li"><p>You can assume that the initial state is that the mouse is down and within the control region (otherwise you would never have gotten the tracking event in the first place). </p></li><li class="li"><p>The tracking loop continually calls <code>TrackMouseLocation</code> while the user keeps the mouse down and takes action based on what that function returns.</p></li><li class="li"><p>When the tracking result is <code>kMouseTrackingMouseEntered</code>, the mouse has reentered the designated region. Typically you would highlight the control (or control part) when this occurs. </p></li><li class="li"><p>When the tracking result is <code>kMouseTrackingMouseExited</code>, the mouse has left the region. You usually want to unhighlight your control (or control part) when this happens.</p></li><li class="li"><p>When the tracking result is <code>kMouseTrackingMouseDragged</code>, the mouse has moved within the designated region while still being pressed. For simple controls such as buttons, you probably don’t need to handle this result, but if the region is a scrollbar or slider indicator, you should drag the indicator. Your control action callback should handle any changes to settings or content that result from this drag. </p></li><li class="li"><p>After the user releases the mouse, you should return the part code indicating where the mouse-up occurred in the event reference by calling <code>SetEventParameter</code>.<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_714"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_715"></a></p></li></ol><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIIJEIH" title="Registering Your Custom Control"></a><h4>Registering Your Custom Control</h4><p>After you have written the handlers for your custom control, you register them as a toolbox object class, just as you would for a custom window. <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIEBIEI">Listing 3-23</a></span> shows an example of registering <code>MyCustomControlHandler</code>.</p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_172" title="Listing 2-23Registering your custom control handler"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIEBIEI" title="Listing 2-23Registering your custom control handler"></a><strong>Listing 2-23&nbsp;&nbsp;</strong>Registering your custom control handler</p><div class="codesample"><table><tr><td scope="row"><pre>ToolboxObjectClassRef customControl;<span></span></pre></td></tr><tr><td scope="row"><pre>EventHandlerUPP myCustomControlUPP;<span></span></pre></td></tr><tr><td scope="row"><pre>EventTypeSpec CEventList[] = {{kEventClassControl, kEventControlDraw},<span></span></pre></td></tr><tr><td scope="row"><pre>                            {kEventClassControl, kEventControlHitTest}};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>myCustomControlUPP = NewEventHandlerUPP (MyCustomControlHandler);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>RegisterToolboxObjectClass (CFSTR ("com.Moof.MyApp.cntrl"), NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                            GetEventTypeCount(CEventList), CEventList,<span></span></pre></td></tr><tr><td scope="row"><pre>                            myCustomControlUPP, NULL, &amp;customControl);<span></span></pre></td></tr></table></div><p>To create your control, you have two options:</p><ul class="spaceabove"><li class="li"><p>Use Interface Builder to add a custom control to your nib file</p></li><li class="li"><p>Call <code>CreateCustomControl</code> to create an instance of the control from your application. </p></li></ul><p>The simplest way is to add a custom control to your nib file. You do so by dragging a Custom object from the Enhanced Controls palette (previously shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIGFAHC">Figure 3-4</a></span> to your window. The dimensions of the custom object should be the desired bounds of your control. </p><p>In the Attributes pane of the Info panel for the custom object, you can set the class ID of the toolbox object class corresponding to your control, as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIJEDIB">Figure 3-19</a></span>. You should specify an event-based control definition type. </p><br/><div><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_173" title="Figure 2-19Assigning the class ID and name for a custom control"></a><p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIJEDIB" title="Figure 2-19Assigning the class ID and name for a custom control"></a><strong>Figure 2-19&nbsp;&nbsp;</strong>Assigning the class ID and name for a custom control</p><img src = "../art/customcontrolpanel.gif" alt = "Assigning the class ID and name for a custom control" width="235" height="350"></div><br/><p>If your control requires a title, you can set that in this panel. (Doing so is the same as calling the function <code>SetControlTitle</code>; your application can obtain the title by calling <code>GetControlTitle</code>). If your control has minimum, maximum, and initial control values, you can set these as well. Later, when you call <code>CreateWindowFromNib</code> from your application, your custom control is automatically created and placed within the window. </p><p>If you want to create your custom control within your application, you use the <code>CreateCustomControl</code> function as shown in <span class="content_text"><a href="hitb-wind_cont_tasks.html#//apple_ref/doc/uid/TP30001004-CH206-BCIJCDDI">Listing 3-24</a></span>. </p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_174" title="Listing 2-24Creating controls using CreateCustomControl"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIJCDDI" title="Listing 2-24Creating controls using CreateCustomControl"></a><strong>Listing 2-24&nbsp;&nbsp;</strong>Creating controls using CreateCustomControl</p><div class="codesample"><table><tr><td scope="row"><pre>ToolboxObjectClassRef customControl;<span></span></pre></td></tr><tr><td scope="row"><pre>ControlDefSpec myCustomControlSpec;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>WindowRef theWindow;<span></span></pre></td></tr><tr><td scope="row"><pre>ControlRef myControl;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Rect controlBounds = {100, 100, 200, 300};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>myCustomControlSpec.defType = kControlDefObjectClass;<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>myCustomControlSpec.u.classRef = customControl;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CreateCustomControl (theWindow, &amp;controlBounds, &amp;myCustomControlSpec,<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                        NULL, &amp;myControl);<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>The <code>CreateCustomControl<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_716"></a></code> function requires you to pass a control definition specification structure to describe the type of control definition you want to use. This structure is analogous to the <code>WindowDefSpec</code> structure used in <code>CreateCustomWindow</code>. In this case, you set the <code>defType</code> field to <code>kControlDefObjectClass</code> to indicate an event-based toolbox object class. Then you set the <code>classRef</code> field of the union to specify the class reference you obtained from calling <code>RegisterToolboxObjectClass</code>.</p></li><li class="li"><p>When calling <code>CreateCustomControl</code>, you pass </p><ul class="ul"><li class="li"><p>the reference of the window to contain the control (<code>theWindow</code>). </p></li><li class="li"><p>the bounds of the control, in the window’s local coordinates (<code>controlBounds</code>). </p></li><li class="li"><p>the control definition specification structure (<code>myCustomControlSpec</code>).</p></li><li class="li"><p>any specialized data to associate with the control. In this example you pass <code>NULL</code> to indicate no data. </p></li></ul><p>On return, <code>myControl</code> contains a reference to the newly-created control. </p></li></ol><p>After you create the control, you still need to embed it within a root control or other control by calling <code>EmbedControl</code> or <code>AutoEmbedControl</code>.<a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_717"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_718"></a></p><a name="//apple_ref/doc/uid/TP30001004-CH206-BCIGBJHE" title="Introducing HIObject and HIView (Mac OS X 10. 2 and Later)"></a><h2>Introducing HIObject and HIView (Mac OS X 10. 2 and Later)</h2><p><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_719"></a><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_720"></a>HIObject is a common base class for all user interface objects. That is, for Mac OS X version 10.2 and later, all menus, windows, controls, toolbars, and so on, are subclasses of HIObject. </p><p>Essentially the HIObject model brings an object-oriented approach to the Mac OS Human Interface Toolbox, where the HIObject is the data store (instance) and  the Carbon event handlers are the methods. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001004-CH206-DontLinkElementID_175" title="Note"></a><p><strong>Note:</strong>&nbsp;HIObjects are actually Core Foundation–based types (type <code>CFType</code>) and as such are subject to CFRetain/Release and other functions. </p></div><p>Use of HIObject is entirely optional. Windows, controls (views), menus and so on are built on top of the HIObject base class, but you can continue to use the various toolbox managers to manipulate them. However, HIObjects make it easy to create custom objects as you can simply subclass them from the standard classes. </p><p>HIView is an object-oriented view system subclassed from HIObject. All controls are implemented as HIView objects ("views"). You can easily subclass HIView classes, making it easy to implement custom controls. Over time the HIView API will replace the current Control Manager. </p><p>Using the HIView model, every item within a window is a view: the root control, controls, and even the standard window "widgets" (close, zoom, and minimize buttons, resize control, and so on). </p><p>Current Control Manager function calls are layered on top of this HIView model and will be supported for the foreseeable future.</p><p>Additional benefits of the new HIView model include the following:</p><ul class="ul"><li class="li"><p>Quartz is the native drawing system, but you can still use QuickDraw if desired. </p></li><li class="li"><p>Modern coordinate system not bounded by the 16-bit space of QuickDraw. Floating point coordinates are valid.</p></li><li class="li"><p> Simplified coordinate system for view bounds and the position of a view within  its parent. </p></li><li class="li"><p>Views can be ordered within a hierarchy layer; that is, it is easy to place controls in front or behind other controls.</p></li><li class="li"><p>Views can be easily attached and detached from windows. You can even retain a view separate from an owning window if desired.</p></li></ul><p>For more details, see the separate HIObject and HIView documentation grouped under HIToolbox on the Carbon Developer documentation site. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../hitb-wind_cont_concept/hitb-wind_cont_concept.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../hitb-apdx_a_msgs/hitb-apdx_a_msgs.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2005 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2005-07-07<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/HandlingWindowsControls/hitb-wind_cont_tasks/hitb-wind_cont_tasks.html%3Fid%3DTP30001004-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/HandlingWindowsControls/hitb-wind_cont_tasks/hitb-wind_cont_tasks.html%3Fid%3DTP30001004-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/HandlingWindowsControls/hitb-wind_cont_tasks/hitb-wind_cont_tasks.html%3Fid%3DTP30001004-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>