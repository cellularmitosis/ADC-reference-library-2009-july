<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE>Creating and Accessing UNIX Storage Objects</TITLE></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><H1 CLASS="RH3.RoutineHd3"><A NAME="pgfId=3531"> </A>Creating and Accessing UNIX Storage Objects</H1><P CLASS="T1.Text1"><A NAME="pgfId=3536"> </A><A NAME="marker=3532"> </A>QuickDraw&nbsp;3D provides routines for creating and managing UNIX storage objects.</P><P CLASS="Note"><A NAME="pgfId=1700"> </A>You need to link your application with the standard I/O library to use these functions. </P><DIV><H2 CLASS="RoH.RoutineHeading"><A NAME="pgfId=3537"> </A>Q3UnixStorage_New</H2><P CLASS="T1.Text1"><A NAME="pgfId=3538"> </A><A NAME="marker=961"> </A>You can use the <TT CLASS="cv">Q3UnixStorage_New</TT> function to create a new UNIX storage object.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=5874"> </A>TQ3StorageObject Q3UnixStorage_New (FILE *stdFile);<BR></CODE><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=5876"> </A><TT CLASS="cv">stdFile</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3540"> </A>A pointer to a file. This file must already be open.</DD></DL COMPACT><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=3541"> </A>DESCRIPTION</H3><P CLASS="T1.Text1"><A NAME="pgfId=3542"> </A>The <TT CLASS="cv">Q3UnixStorage_New</TT> function returns, as its function result, a new UNIX storage object associated with the file specified by the <TT CLASS="cv">stdFile</TT> parameter. The specified file is assumed to be open, and it must remain open as long as you use the returned storage object. In addition, you are responsible for closing the file once the associated storage object has been closed or disposed of. If <TT CLASS="cv">Q3UnixStorage_New</TT> cannot create a new storage object, it returns the value <TT CLASS="cv">NULL</TT>.</P></DIV><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=3543"> </A>ERRORS</H3><P CLASS="T1.Text1"><A NAME="pgfId=3544"> </A><TT CLASS="cv">kQ3ErrorOutOfMemory kQ3ErrorNULLParameter</TT></P></DIV></DIV><DIV><H2 CLASS="RoH.RoutineHeading"><A NAME="pgfId=3545"> </A>Q3UnixStorage_Get</H2><P CLASS="T1.Text1"><A NAME="pgfId=3546"> </A><A NAME="marker=971"> </A>You can use the <TT CLASS="cv">Q3UnixStorage_Get</TT> function to get information about a UNIX storage object.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=5890"> </A>TQ3Status Q3UnixStorage_Get (TQ3StorageObject storage, FILE **stdFile);<BR></CODE><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=5892"> </A><TT CLASS="cv">storage</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3548"> </A>A UNIX storage object.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=5901"> </A><TT CLASS="cv">stdFile</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3549"> </A>On entry, a pointer to a <TT CLASS="cv">FILE</TT> structure. On exit, a pointer to the <TT CLASS="cv">FILE</TT> structure associated with the specified UNIX storage object.</DD></DL COMPACT><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=3550"> </A>DESCRIPTION</H3><P CLASS="T1.Text1"><A NAME="pgfId=3551"> </A>The <TT CLASS="cv">Q3UnixStorage_Get</TT> function returns, through the <TT CLASS="cv">stdFile</TT> parameter, the <TT CLASS="cv">FILE</TT> structure associated with the UNIX storage object specified by the <TT CLASS="cv">storage</TT> parameter.</P></DIV><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=3552"> </A>ERRORS</H3><P CLASS="T1.Text1"><A NAME="pgfId=3553"> </A><TT CLASS="cv">kQ3ErrorAccessRestricted kQ3ErrorInvalidObjectParameter</TT></P></DIV></DIV><DIV><H2 CLASS="RoH.RoutineHeading"><A NAME="pgfId=3554"> </A>Q3UnixStorage_Set</H2><P CLASS="T1.Text1"><A NAME="pgfId=3555"> </A><A NAME="marker=982"> </A>You can use the <TT CLASS="cv">Q3UnixStorage_Set</TT> function to set information about a UNIX storage object.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=5915"> </A>TQ3Status Q3UnixStorage_Set (TQ3StorageObject storage, FILE *stdFile);<BR></CODE><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=5917"> </A><TT CLASS="cv">storage</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3557"> </A>A UNIX storage object.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=5926"> </A><TT CLASS="cv">stdFile</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3558"> </A>A pointer to a <TT CLASS="cv">FILE</TT> structure.</DD></DL COMPACT><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=3559"> </A>DESCRIPTION</H3><P CLASS="T1.Text1"><A NAME="pgfId=3560"> </A>The <TT CLASS="cv">Q3UnixStorage_Set</TT> function sets the <TT CLASS="cv">FILE</TT> structure associated with the UNIX storage object specified by the <TT CLASS="cv">storage</TT> parameter to the structure specified by the <TT CLASS="cv">stdFile</TT> parameter.</P></DIV><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=3561"> </A>SPECIAL CONSIDERATIONS</H3><P CLASS="T1.Text1"><A NAME="pgfId=3562"> </A>You must not use <TT CLASS="cv">Q3UnixStorage_Set</TT> with an open UNIX storage object.</P></DIV><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=3563"> </A>ERRORS</H3><P CLASS="T1.Text1"><A NAME="pgfId=3564"> </A><TT CLASS="cv">kQ3ErrorAccessRestricted kQ3ErrorInvalidObjectParameter kQ3ErrorStorageIsOpen</TT></P></DIV></DIV><DIV><H2 CLASS="RoH.RoutineHeading"><A NAME="pgfId=3565"> </A>Q3UnixStorage_GetType</H2><P CLASS="T1.Text1"><A NAME="pgfId=3566"> </A><A NAME="marker=995"> </A>You can use the <TT CLASS="cv">Q3UnixStorage_GetType</TT> function to get the type of a UNIX storage object.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=5943"> </A>TQ3ObjectType Q3UnixStorage_GetType (TQ3StorageObject storage);<BR></CODE><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=5945"> </A><TT CLASS="cv">storage</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3568"> </A>A UNIX storage object.</DD></DL COMPACT><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=3569"> </A>DESCRIPTION</H3><P CLASS="T1.Text1"><A NAME="pgfId=3570"> </A>The <TT CLASS="cv">Q3UnixStorage_GetType</TT> function returns, as its function result, the type of the UNIX storage object specified by the <TT CLASS="cv">storage</TT> parameter. The types of UNIX storage objects currently supported by QuickDraw&nbsp;3D are defined by this constant:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=5956"> </A>kQ3UnixStorageTypePath<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=3575"> </A>If the specified memory storage object is invalid or is not of this type, <TT CLASS="cv">Q3UnixStorage_GetType</TT> returns the value <TT CLASS="cv">kQ3ObjectTypeInvalid</TT>.</P></DIV><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=3576"> </A>ERRORS</H3><P CLASS="T1.Text1"><A NAME="pgfId=3577"> </A><TT CLASS="cv">kQ3ErrorNoSubclass kQ3ErrorInvalidObjectParameter kQ3ErrorNULLParameter</TT><A NAME="marker=3578"> </A></P></DIV></DIV><hr>&#169; 1997 Apple Computer, Inc.</DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>