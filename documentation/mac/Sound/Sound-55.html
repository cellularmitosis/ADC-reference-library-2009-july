<!-- legacy work start -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- legacy work end -->


<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)

LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Playing Sounds Asynchronously  (IM: S)  (deprecated)</Title>

<!-- legacy work start -->
        <META NAME="Generator" CONTENT="manual">
        <META http-equiv="content-type" CONTENT="text/html;charset=utf-8">
        <META NAME = "Copyright" CONTENT="Copyright 2007 Apple Inc. All Rights Reserved.">
        <META NAME="IndexTitle" CONTENT="Inside Macintosh: Sound (Not Recommended)">
        <meta name="xcode-display" content="render">

        <LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css"> <!-- before submitting, globally replace ".." with "developer.apple.com" -->
        <script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
<!-- legacy work end -->

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<A NAME=HEADING55></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Sound-54.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-56.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Sound-2.html"><B>Sound</B></A> / <BR><DD><A HREF="Sound-44.html"><B>Chapter 2 - Sound Manager</B></A> / <A HREF="Sound-50.html"><B>Using the Sound Manager</B></A></DL></FONT><P>
<HR>

<!-- legacy work start -->
<script type="text/javascript"> placeWatermark()</script>
<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
<i>Inside Macintosh: Sound</i> is deprecated as of Mac OS X v10.5. For new audio development in Mac OS X, use Core Audio. See the <a href="http://developer.apple.com/referencelibrary/MusicAudio/" target="_top">Audio</a> page in the ADC Reference Library.</p></div></div></div>
<!-- legacy work end -->


<BLOCKQUOTE>
<A NAME=HEADING55-0></A>
<H2><A NAME=MARKER-9-292></A>Playing Sounds Asynchronously<A NAME=MARKER-2-19></A> <A NAME=MARKER-2-56></A><A NAME=MARKER-2-295></A></H2>
 The Sound Manager currently allows you to play sounds asynchronously only if you allocate sound channels yourself, using techniques described in <A HREF=Sound-51.html#MARKER-9-136>"Managing Sound Channels" on page 2-19</A>. But if you use such a technique, your application will need to dispose of a sound channel whenever the application finishes playing a sound. In addition, your application might need to release a sound resource that you played on a sound channel.<P>
 To avoid the problem of not knowing when to dispose of a sound channel playing a sound asynchronously, your application could simply allocate a single sound channel when it starts up (or receives a resume event) and dispose of the channel when the user quits (or the application receives a suspend event). However, this solution will not work if you need to release a resource when a sound finishes playing. Also, you might not want to keep a sound channel allocated when you are not using it. For instance, you might want to use the memory taken up by a sound channel for other tasks when no sound is playing.<P>
 Your application could call the <CODE>SndChannelStatus</CODE> function once each time through its main event loop to determine if a channel is still making sound. When the <CODE>scBusy</CODE> field of the sound channel status record becomes <CODE>FALSE</CODE>, your application could then dispose of the channel. This technique is easy, but calling <CODE>SndChannelStatus</CODE> frequently uses up processing time unnecessarily.<A NAME=MARKER-2-57></A><P>
 The Sound Manager provides other mechanisms that allow your application to find out when a sound finishes playing, so that your application can arrange to dispose of sound channels no longer being used and of other data (such as a sound resource) that you no longer need after disposing of a channel. If you are using the <CODE>SndPlay</CODE> function or low-level commands to play sound in a channel, then you can use callback procedures. If you are using the <CODE>SndStartFilePlay</CODE> function to play sound in a channel, then you can use completion routines. The following sections illustrate how to use callback procedures and completion routines.<P>
<DL>
<DT><B>Note</B>
<DD>Callback procedures are a form of completion routine. However, for clarity, this section uses the terminology "completion routine" only for the routines associated with the <CODE>SndStartFilePlay</CODE> function.<EM></EM><A NAME=MARKER-2-245></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING55-6></A>
<H3><A NAME=MARKER-9-299></A>Using Callback Procedures</H3>
 This section shows how you can use callback procedures to play one sound asynchronously at a given time. <A HREF=#MARKER-9-333>"Managing Multiple Sound Channels" on page 2-53</A> expands the techniques in this section to show how you can play several asynchronous sounds simultaneously.<P>
 The <CODE>SndNewChannel</CODE> function allows you to associate a callback procedure with a sound channel. For example, the following code opens a new sound channel for which memory has already been allocated and associates it with the callback procedure <CODE>MyCallBack</CODE>:<P>
<PRE>
myErr := SndNewChannel(gSndChan, sampledSynth, initMono, @MyCallback);
</PRE>
 After filling a channel created by <CODE>SndNewChannel</CODE> with various commands to create sound, you can then issue a <CODE>callBackCmd</CODE> command to the channel. When the Sound Manager encounters a <CODE>callBackCmd</CODE> command, it executes your callback procedure. Thus, by placing the <CODE>callBackCmd</CODE> command last in a channel, you can ensure that the Sound Manager executes your callback procedure only after it has processed all of the channel's other sound commands.<P>
<DL>
<DT><B>Note</B>
<DD>Be sure to issue <CODE>callBackCmd</CODE> commands with the <CODE>SndDoCommand</CODE> function and not the <CODE>SndDoImmediate</CODE> function. If you issue a <CODE>callBackCmd</CODE> command with <CODE>SndDoImmediate</CODE>, your callback procedure might be called before other sound commands you have issued finish executing.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 A callback procedure has the following syntax:<P>
<PRE>
PROCEDURE MyCallBack (chan: SndChannelPtr; cmd: SndCommand);
</PRE>
 Because the callback procedure executes at interrupt time, it cannot access its application global variables unless the application's A5 world is set correctly. (For more information on the A5 world, see the chapter "Memory Management Utilities" in <I><A HREF="../Memory/Memory-2.html">Inside Macintosh: Memory</A></I>.) When called, the callback procedure is passed two parameters: a pointer to the sound channel that received the <CODE>callBackCmd</CODE> command and the sound command that caused the callback procedure to be called. Applications can use <CODE>param1</CODE> or <CODE>param2</CODE> of the sound command as flags to pass information or instructions to the callback procedure. If your callback procedure is to use your application's global data storage, it must first reset A5 to your application's A5 and then restore it on exit. For example, <A HREF=#MARKER-9-301>Listing 2-18</A> illustrates how to set up a <CODE>callBackCmd</CODE> command that contains the required A5 information in the <CODE>param2</CODE> field. The <CODE>MyInstallCallback</CODE> function defined there must be called at a time when your application's A5 world is known to be valid.<A NAME=MARKER-2-266></A><P>
<B>Listing 2-18  <A NAME=MARKER-9-301></A>Issuing a callback command</B><P>
<PRE>
FUNCTION MyInstallCallback (mySndChan: SndChannelPtr): OSErr;
CONST
   kWaitIfFull = TRUE;           {wait for room in queue}
VAR
   mySndCmd:   SndCommand;       {a sound command}
BEGIN
   WITH mySndCmd DO
   BEGIN
      cmd := callBackCmd;        {install the callback command}
      param1 := kSoundComplete;  {last command for this channel}
      param2 := SetCurrentA5;    {pass the callback the A5}
   END;
   MyInstallCallback := SndDoCommand(mySndChan, mySndCmd, kWaitIfFull);
END;
</PRE>
 In this function, <CODE>kSoundComplete</CODE> is an application-defined constant that indicates that the requested sound has finished playing. You could define it like this:<P>
<PRE>
CONST
   kSoundComplete          = 1;     {sound is done playing}
</PRE>
 Because <CODE>param2</CODE> of a sound command is a long integer, <A HREF=#MARKER-9-301>Listing 2-18</A> uses it to pass the application's A5 to the callback procedure. That allows the callback procedure to gain access to the application's A5 world.<P>
<DL>
<DT><B>Note</B>
<DD>You can also pass information to a callback routine in the <CODE>userInfo</CODE> field of the sound channel.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The sample callback procedure defined in <A HREF=#MARKER-9-302>Listing 2-19</A> can thus set A5 to access the application's global variables.<P>
<B>Listing 2-19  <A NAME=MARKER-9-302></A>Defining a callback procedure</B><P>
<PRE>
PROCEDURE MyCallback (theChan: SndChannelPtr; theCmd: SndCommand);
VAR
   myA5:          LongInt;
BEGIN
   IF theCmd.param1 = kSoundComplete THEN
   BEGIN
      myA5 := SetA5(theCmd.param2);    {set my A5}
      gCallbackPerformed := TRUE;      {set a global flag}
      myA5 := SetA5(myA5);             {restore the original A5}
   END;
END;
</PRE>
<DL>
<DT><B>WARNING</B>
<DD>Callback procedures are called at interrupt time and therefore must not attempt to allocate, move, or dispose of memory, dereference an unlocked handle, or call other routines that do so. Also, assembly-language programmers should note that a callback procedure is a Pascal procedure and must preserve all registers other than A0-A1 and D0-D2.<EM></EM><A NAME=MARKER-2-390></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Callback procedures cannot dispose of channels themselves, because that involves disposing of memory. To circumvent this restriction, the callback procedure in <A HREF=#MARKER-9-302>Listing 2-19</A> simply sets the value of a global flag variable that your application defines. Then, once each time through its main event loop, your application must call a routine that checks to see if the flag is set. If the flag is set, the routine should dispose of the channel, release any other memory allocated specifically for use in the channel, and reset the flag variable. <A HREF=#MARKER-9-304>Listing 2-20</A> defines such a routine. Your application should call it once each time through its main event loop.<P>
<B>Listing 2-20  <A NAME=MARKER-9-304></A>Checking whether a callback procedure has executed</B><P>
<PRE>
PROCEDURE MyCheckSndChan;
CONST
   kQuietNow = TRUE;                {need to quiet channel?}
VAR
   myErr:   OSErr;
BEGIN
   IF gCallbackPerformed THEN       {check global flag}
   BEGIN                            {channel is done}
      gCallbackPerformed := FALSE;  {reset global flag}
      IF gSndChan^.userInfo &lt;&gt; 0 THEN
      BEGIN                         {release sound data}
         HUnlock(Handle(gSndChan^.userInfo));
         HPurge(Handle(gSndChan^.userInfo));
      END;
      myErr := MyDisposeSndChannel(gSndChan, kQuietNow);
      gSndChan := NIL;              {set pointer to NIL}
   END;
END;
</PRE>
 The <CODE>MyCheckSndChan</CODE> procedure defined in <A HREF=#MARKER-9-304>Listing 2-20</A> checks the <CODE>userInfo</CODE> field of the sound channel to see if it contains the address of a handle. Thus, if you would like the <CODE>MyCheckSndChan</CODE> procedure to release memory associated with a sound handle, you need only put the address of the handle in the <CODE>userInfo</CODE> field of the sound channel. (If you do not want the <CODE>MyCheckSndChan</CODE> procedure to release memory associated with a handle, then you should set the <CODE>userInfo</CODE> field to 0 when you allocate the channel. The <CODE>MyCreateSndChannel</CODE> function defined in <A HREF=Sound-51.html#MARKER-9-140>Listing 2-1 on page 2-20</A> automatically sets this field to 0.) After releasing the memory associated with the sound handle, the <CODE>MyCheckSndChan</CODE> procedure calls the <CODE>MyDisposeSndChannel</CODE> function (defined in <A HREF=Sound-51.html#MARKER-9-164>Listing 2-3 on page 2-25</A>) to release the memory occupied by both the sound channel and the sound channel record.<P>
 To ensure that the <CODE>MyCheckSndChan</CODE> procedure defined in <A HREF=#MARKER-9-304>Listing 2-20</A> does not attempt to dispose a channel before you have created one, you should initialize the <CODE>gCallbackPerformed</CODE> variable to <CODE>FALSE</CODE>. Also, you should initialize the <CODE>gSndChan</CODE> variable to <CODE>NIL</CODE>, so that other parts of your application can check to see if a sound is playing simply by checking this variable. For example, if your application must play a sound but another sound is currently playing, you might ensure that the application gives priority to the newer sound by stopping the old one. <A HREF=#MARKER-9-305>Listing 2-21</A> defines a procedure that stops the sound that is playing.<P>
<B>Listing 2-21  <A NAME=MARKER-9-305></A>Stopping a sound that is playing asynchronously</B><P>
<PRE>
PROCEDURE MyStopPlaying;
BEGIN
   IF gSndChan &lt;&gt; NIL THEN          {is sound really playing?}
      gCallbackPerformed := TRUE;   {set global flag}
   MyCheckSndChan;                  {call routine to do disposing}
END;
</PRE>
 Once you have defined a callback procedure, a routine that installs the callback procedure, a routine that checks the status of the callback procedure, and a routine that can stop sound play, you need only allocate a sound channel, call the <CODE>SndPlay</CODE> function, and install your callback procedure to start an asynchronous sound play. <A HREF=#MARKER-9-307>Listing 2-22</A> defines a procedure that starts an asynchronous play.<A NAME=MARKER-2-65></A><P>
<B>Listing 2-22  <A NAME=MARKER-9-307></A>Starting an asynchronous sound play</B><P>
<PRE>
PROCEDURE MyStartPlaying (mySndID: Integer);
CONST
   kAsync = TRUE;             {play is asynchronous}
VAR
   mySndHandle:   Handle;     {handle to an 'snd ' resource}
   myErr:         OSErr;
BEGIN
   IF gSndChan &lt;&gt; NIL THEN                {check if channel is active}
      MyStopPlaying;
   gSndChan := MyCreateSndChannel(0, 0, @MyCallbackProc, stdQLength);
   mySndHandle := GetResource('snd ', mySndID);
   IF (mySndHandle &lt;&gt; NIL) AND (gSndChan &lt;&gt; NIL) THEN
   BEGIN                      {start sound playing}
      DetachResource(mySndHandle);        {detach resource from file}
                                          {remember to release sound handle}
      gSndChan^.userInfo := LongInt(mySndHandle);
      HLock(mySndHandle);                 {lock the resource data}
      myErr := SndPlay(gSndChan, mySndHandle, kAsync);
      IF myErr = noErr THEN
         myErr := MyInstallCallback(gSndChan);
      IF myErr &lt;&gt; noErr THEN
         DoError(myErr);
   END;
END;
</PRE>
 The <CODE>MyStartPlaying</CODE> procedure uses the <CODE>MyCreateSndChannel</CODE> function defined in <A HREF=Sound-51.html#MARKER-9-140>Listing 2-1</A> to create a sound channel, requesting that the function allocate a standard-sized sound channel command queue. By using such a queue, you can be sure that your application can play any sound resource that contains up to 127 sound commands. If you are sure that your application will play only sampled-sound resources created by the Sound Input Manager, you should request a queue of only two sound commands, thereby leaving enough room for just the <CODE>bufferCmd</CODE> command contained within the sound resource and the <CODE>callBackCmd</CODE> command that your application issues. <P>
 Before playing the sound, the <CODE>MyStartPlaying</CODE> procedure defined in <A HREF=#MARKER-9-307>Listing 2-22</A> detaches the sound resource from its resource file after loading it. This is important if the resource file could close while the sound is still playing, or if your application might create another sound channel to play the same sound resource while the sound is still playing.<A NAME=MARKER-9-578></A> <A NAME=MARKER-2-40></A><P>
<A NAME=HEADING55-37></A>
<H3>Synchronizing Sound With Other Actions<A NAME=MARKER-2-11></A></H3>
 If your application uses callback procedures to play sound asynchronously, you might wish to synchronize sound play with other activity, such as an onscreen animation.<P>
 Callback procedures allow your application to do that by using different constant values in the <CODE>param1</CODE> field of the callback command. For example, you could define a constant <CODE>kFirstSoundFinished</CODE> to signal to your application that the first of a series of sounds has finished playing. Then, your callback procedure could set an appropriate global flag depending on whether the <CODE>param1</CODE> field equals <CODE>kFirstSoundFinished</CODE>, <CODE>kSoundComplete</CODE>, or some other constant that your application defines. Finally, a procedure that you call once each time through your application's event loop could check to see which of the various global flag variables are set and respond appropriately. Meanwhile, sound continues to play.<A NAME=MARKER-2-311></A><A NAME=MARKER-2-312></A><P>
<A NAME=HEADING55-40></A>
<H3><A NAME=MARKER-9-313></A>Managing an Asynchronous Play From Disk</H3>
 <A NAME=MARKER-2-109></A><A NAME=MARKER-2-33></A><A NAME=MARKER-2-316></A>The Sound Manager allows you to play a sound file asynchronously with the <CODE>SndStartFilePlay</CODE> function by defining a completion routine that sets a global flag to alert the application to dispose of the sound channel when the sound is done playing. Completion routines are thus similar to callback procedures, but they are easier to use in that you do not need to install them. The Sound Manager automatically executes them when a play from disk ends, whether it has ended because the application called the <CODE>SndStopFilePlay</CODE> function, because the application disposed of the sound channel in which the sound was playing, or because the sound has finished playing.<A NAME=MARKER-2-317></A><P>
 You define a completion routine like this:<P>
<PRE>
PROCEDURE MySoundCompletionRoutine (chan: SndChannelPtr);
</PRE>
 Note that unlike callback procedures, completion routines have only one parameter, a pointer to a sound channel. Thus, for the completion routine to set the application's A5 world properly, you should pass the value of the application's A5 in the <CODE>userInfo</CODE> field of the sound channel, like this:<P>
<PRE>
gSndChan^.userInfo := SetCurrentA5;
</PRE>
 Then your completion routine can look in the <CODE>userInfo</CODE> field of the sound channel to set A5 correctly before it can access any application global variables. <A HREF=#MARKER-9-318>Listing 2-23</A> defines a completion routine that sets A5 correctly.<P>
<B>Listing 2-23  <A NAME=MARKER-9-318></A>Defining a completion routine</B><P>
<PRE>
PROCEDURE MySoundCompletionRoutine (chan: SndChannelPtr);
VAR
   myA5:    LongInt;
BEGIN
   myA5 := SetA5(chan^.userInfo);      {set my A5}
   gCompletionPerformed := TRUE;       {set a global flag}
   myA5 := SetA5(myA5);                {restore the original A5}
END;
</PRE>
 The completion routine defined in <A HREF=#MARKER-9-318>Listing 2-23</A> sets a global flag variable to indicate that the completion routine has been called. To start a sound file playing, you can use a routine analogous to that defined in <A HREF=#MARKER-9-307>Listing 2-22</A>, but when allocating a sound channel, you need only allocate a queue of a single sound command. You can than use a procedure analogous to that defined in <A HREF=#MARKER-9-304>Listing 2-20</A> to check the flag once each time through the application's event loop and dispose of the sound channel if the flag is set.<A NAME=MARKER-2-241></A><P>
 If you do use the <CODE>SndStartFilePlay</CODE> function to play sounds asynchronously, then you can pause, restart, and stop play simply by using the <CODE>SndPauseFilePlay</CODE> and <CODE>SndStopFilePlay</CODE> functions.<P>
 You use <CODE>SndPauseFilePlay</CODE> to temporarily suspend a sound from playing. If a sound is playing and you call <CODE>SndPauseFilePlay</CODE>, then the sound is paused. If the sound is paused and you call <CODE>SndPauseFilePlay</CODE> again, then the sound resumes playing. Hence, the <CODE>SndPauseFilePlay</CODE> routine acts like a pause button on a tape player, which toggles the tape between playing and pausing. (You can determine the current state of a play from disk by using the <CODE>SndChannelStatus</CODE> function. See <A HREF=Sound-53.html#MARKER-9-245>"Obtaining Information About a Single Sound Channel" on page 2-37</A> for more details.) Finally, you can use <CODE>SndStopFilePlay</CODE> to stop the file from playing.<A NAME=MARKER-9-46></A><A NAME=MARKER-2-506></A><A NAME=MARKER-9-139></A><A NAME=MARKER-2-316></A><P>
<A NAME=HEADING55-52></A>
<H3>Playing Selections<A NAME=MARKER-2-324></A><A NAME=MARKER-2-325></A></H3>
 The sixth parameter passed to the <CODE>SndStartFilePlay</CODE> function is a pointer to an <B>audio selection record,</B> which allows you to specify that only part of the sound be played. If that parameter has a value different from <CODE>NIL</CODE>, then <CODE>SndStartFilePlay</CODE> plays only a specified selection of the entire sound. You indicate which part of the entire sound to play by giving two offsets from the beginning of the sound, a time at which to start the selection and a time at which to end the selection. Currently, both time offsets must be specified in seconds.<P>
 Here is the structure of an audio selection record:<P>
<PRE>
TYPE AudioSelection =
PACKED RECORD
   unitType:   LongInt;    {type of time unit}
   selStart:   Fixed;      {starting point of selection}
   selEnd:     Fixed;      {ending point of selection}
END;
</PRE>
 To play a selection, you should specify in the <CODE>selStart</CODE> and <CODE>selEnd</CODE> fields the starting and ending point in seconds of the sound to play. Also, you must set the <CODE>unitType</CODE> field to the constant <CODE>unitTypeSeconds</CODE>.<P>
 If you wish to play an entire sound, you can simply pass <CODE>NIL</CODE> to the <CODE>SndStartFilePlay</CODE> function. Alternatively, you can set the <CODE>unitType</CODE> field to the constant <CODE>unitTypeNoSelection</CODE>, in which case the values in the <CODE>selStart</CODE> and <CODE>selEnd</CODE> fields are ignored.<A NAME=MARKER-4-327></A><A NAME=MARKER-4-328></A><A NAME=MARKER-2-329></A> <A NAME=MARKER-2-331></A><A NAME=MARKER-2-332></A><P>
<A NAME=HEADING55-58></A>
<H3><A NAME=MARKER-9-333></A>Managing Multiple Sound Channels</H3>
 <A NAME=MARKER-2-334></A>If you are writing an application that can play multiple channels of sound on Macintosh computers that support that feature, you can use the Sound Manager's asynchronous playing abilities, but you might encounter some special obstacles. The technique for playing sounds asynchronously described in <A HREF=#MARKER-9-292>"Playing Sounds Asynchronously" on page 2-46</A> has a limitation if you are using multiple sound channels. Using that technique without modification, you would need to define each separate sound channel in a different global variable, and you would need to use several global flags in your callback procedure to signal which sound channels have finished processing sound commands.<P>
 Although it is easy to modify the code in <A HREF=#MARKER-9-292>"Playing Sounds Asynchronously"</A> to use several flags, this solution might not be satisfactory for an application in which the number of sound channels open can vary. For example, suppose that you are writing entertainment software with dozens of sound effects that correspond to actions on the screen and you wish to use the Sound Manager asynchronously so that several sound effects can be played at once. It would be cumbersome to associate a separate global sound channel variable with each sound and create a flag variable for each of these sound channels. Also, you might wish to play the same sound simultaneously in two separate channels. It would be better to write code that manages a global list of sound channels and then provides a simple routine that allows you to add a channel to the list. This section shows how you might implement such a list of sound channels. <A HREF=#MARKER-9-335>Listing 2-24</A> defines a data structure that you could use to track multiple sound channels.<P>
<B>Listing 2-24  <A NAME=MARKER-9-335></A>Defining a data structure to track many sound channels</B><P>
<PRE>
CONST
   kMaxNumSndChans = 20;            {max number of sound channels}
TYPE
   SCInfo = 
   RECORD
      sndChan:       SndChannelPtr; {NIL or pointer to channel}
      mustDispose:   Boolean;       {flag to dispose channel}
      itsData:       Handle;        {data to dispose with channel}
   END;
   SCList = ARRAY[1..kMaxNumSndChans] OF SCInfo;
VAR
   gSndChans:        SCList;
</PRE>
 The <CODE>SCInfo</CODE> data structure defined in <A HREF=#MARKER-9-335>Listing 2-24</A> allows you to keep track of which channels in the collection are being used and which were being used but currently need disposal; it also allows you to associate data with a sound channel so that you can dispose of the data when you dispose of the sound channel. Note that the value of the <CODE>kMaxNumSndChans</CODE> constant might vary from application to application. Having defined the data structure, you must initialize it (so that the <CODE>sndChan</CODE> and <CODE>itsData</CODE> fields are <CODE>NIL</CODE> and the <CODE>mustDispose</CODE> field is <CODE>FALSE</CODE>). You must also write a procedure that finds an available channel. You might declare such a procedure like this:<P>
<PRE>
PROCEDURE DoTrackChan (chanToTrack: SndChannelPtr; associatedData: Handle);
</PRE>
 Using such a procedure, you could simply create sound channels by using local variables and then add them to the tracking list so that your application disposes of them when they finish executing. The exact implementation of such a procedure would depend on the needs of your application. For example, if there are no channels available in the global list of sound channels, your application might report an error, stop sound on all active channels, or stop sound on the channel that has been playing the longest. If you want your application to be compatible with computers that do not support multichannel sound, this procedure could check whether multichannel sound is supported, and if not, would stop any sound playing on other channels. This is particularly useful if your application plays sound effects in response to actions on the screen; overlapping sound effects sound best, but if this is unattainable, the newest sound should have the highest priority.<P>
 One advantage of maintaining a list of sound channels is that you can use it in conjunction with both callback procedures and completion routines. <A HREF=#MARKER-9-336>Listing 2-25</A> defines a procedure that either your callback procedure or completion routine could call after setting the application's A5 world correctly.<P>
<B>Listing 2-25  <A NAME=MARKER-9-336></A>Marking a channel for disposal</B><P>
<PRE>
PROCEDURE MySetTrackChanDispose (mySndChannel: SndChannelPtr);
VAR
   index:      Integer;       {channel index}
   found:      Boolean;       {flag variable}
BEGIN
   index := 1;                {start at first spot}
   found := FALSE;            {initialize flag variable}
   WHILE (index &lt;= kMaxNumSndChans) AND (NOT found) DO
      IF gSndChans[index].sndChan = mySndChannel THEN
         found := TRUE        {proper channel found}
      ELSE
         index := index + 1;  {move to next spot}
   IF found THEN
      gSndChans[index].mustDispose := TRUE;
END;
</PRE>
 The final thing you need to do is to define a procedure that your application calls once each time through its main event loop. This procedure must dispose of sound channels that are marked for disposal. <A HREF=#MARKER-9-337>Listing 2-26</A> defines such a routine.<P>
<B>Listing 2-26  <A NAME=MARKER-9-337></A>Disposing of channels that have been marked for disposal</B><P>
<PRE>
PROCEDURE MyCleanUpTrackedChans;
CONST
   kQuietNow = TRUE;                            {need to quiet channel?}
VAR
   index:      Integer;
   myErr:      OSErr;
BEGIN
   FOR index := 1 TO kMaxNumSndChans DO         {go through all channels}
   WITH gSndChans[index] DO
      IF mustDispose THEN                       {check global flag}
      BEGIN                                     {channel needs disposal}
         IF gSndChans[index].itsData &lt;&gt; NIL THEN
         BEGIN                                  {release other data}
            HUnlock(gSndChans[index].itsData);
            HPurge(gSndChans[index].itsData);
         END;
                                                {free channel-related memory}
         myErr := MyDisposeSndChannel(sndChan, kQuietNow);
         sndChan := NIL;                        {set pointer to NIL}
         mustDispose := FALSE;                  {reset global flag}
         IF myErr &lt;&gt; noErr THEN 
            DoError(myErr);
      END;
END;
</PRE>
 The <CODE>MyCleanUpTrackedChans</CODE> procedure defined in <A HREF=#MARKER-9-337>Listing 2-26</A> works just like the <CODE>MyCheckSndChan</CODE> procedure defined in <A HREF=#MARKER-9-304>Listing 2-20</A>, but instead of checking a single global flag, it checks the flag associated with each allocated sound channel. Now that you have defined such a procedure, you can easily write a routine to stop sound in all active channels (for example, if your application receives a suspend event). Simply set the <CODE>mustDispose</CODE> flag on all sound channels that are allocated (that is for all channels that are not <CODE>NIL</CODE>) and then call <CODE>MyCleanUpTrackedChans</CODE>. Note, however, that when the <CODE>MyCleanUpTrackedChans</CODE> procedure disposes of a sound channel processing a play from disk, the completion routine will be called and will thus set the <CODE>mustDispose</CODE> flag to <CODE>TRUE</CODE>. Thus, the <CODE>mustDispose</CODE> flag must be reset to <CODE>FALSE</CODE> <I>after</I> the sound channel has been disposed. Otherwise, the <CODE>MyCleanUpTrackedChans</CODE> procedure would try to dispose of the same sound channel again when the application called it from its main event loop.<A NAME=MARKER-2-338></A><A NAME=MARKER-2-339></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Sound-54.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-56.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Sound-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
