<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ADSP Chat - /ADSP.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">ADSP Chat</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ADSP Chat</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/ADSP.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ADSP Chat.h</option>
<option value="listing2.html">/ADSP Chat.r</option>
<option value="listing3.html">/ADSP.c</option>
<option value="listing4.html">/Atalk.c</option>
<option value="listing5.html">/Main.c</option>
<option value="listing6.html">/PreCompletion.a</option></select>
				</p>
				</form>
				<p><strong><a href="ADSP_Chat.zip">Download Sample</a></strong> (&#147;ADSP_Chat.zip&#148;, 44.1K)<BR>
<strong><a href="ADSP_Chat.dmg">Download Sample</a></strong> (&#147;ADSP_Chat.dmg&#148;, 106.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*****************************************************************  Program:  &lt; ADSP Chat &gt;  File:    &lt; adsp.c &gt;    Written by  Pete Helm, Scott Kuechle  of &lt;Apple Macintosh Developer Technical Support&gt;    modified by Scott Kuechle  10/92 SRK Converted from Pascal to C  8/94 SRK Modified to use a queue of parameter           blocks.  Copyright &copy; 1992, 1994 Apple Computer, Inc.  All rights reserved.  *****************************************************************//*****************************************************************//*  I N C L U D E S/*****************************************************************/#include  &quot;ADSP Chat.h&quot;/********************************************************************/*  G L O B A L   V A R I A B L E   D E C L A R A T I O N S/********************************************************************/char myLocalSocket;Ptr receiveQBuffer;Ptr sendQBuffer;Ptr attnBuffer;Ptr outAttnBuff;Ptr receiveBuffer;Ptr outgoingDataBuffer;TRCCB  gMyCCB;        /* our ccb */short   gADSPDrvrRefNum;  /* adsp driver reference number */short   gCCBRefNum;      /* ccb reference number returned by adsp on a dspInit */Boolean gJustConnected;    /* dspOpen ocRequest was successfully accepted */QHdr  gAvailQueue;QHdr  gDoneQueue;QHdr  gReadQueue;/*****************************************************************//*/* E X T E R N A L S/*/*****************************************************************/extern void removeMyName();extern Boolean  registerMyName();extern void ShowError(short index);extern void DisplayCurrentStatus(Ptr displayStr);extern void HiliteConnectButton (short mode);extern void Exit(short message);extern Str255 gZoneString, gObjStr, gTypeStr;extern Str32 myName;extern DialogPtr myDialog;extern QHdr freeQHdr,saveErrorQHdr;extern AddrBlock ourNetworkAddress;extern void CopyPstr(Ptr pSource, Ptr pDest);extern void PStrCat(Ptr sourceStr, Ptr destinationStr);extern void zeroOutStrings();extern void PreCompletion();#pragma segment adsp// *****************************************************************// *  doADSPinit// *// *  calls dspInit, saves the socket and ccb refnum returned// *****************************************************************Boolean doADSPinit(unsigned char *localSocket,          short *ccbRefNum,          TPCCB ccbPtr){TRinitParams *initParmsPtr;DSPParamBlock dspPB;    /* allocate connection end */  dspPB.ioCRefNum   = gADSPDrvrRefNum;  dspPB.csCode     = dspInit;    initParmsPtr = &amp;dspPB.u.initParams;    initParmsPtr-&gt;ccbPtr     = ccbPtr;    /* poll in main event loop instead of using user routine */  initParmsPtr-&gt;userRoutine  = NULL;  initParmsPtr-&gt;sendQSize   = Qsize;  initParmsPtr-&gt;sendQueue   = sendQBuffer;  initParmsPtr-&gt;recvQSize   = Qsize;  initParmsPtr-&gt;recvQueue   = receiveQBuffer;  initParmsPtr-&gt;attnPtr     = attnBuffer;  initParmsPtr-&gt;localSocket   = 0;         /* dynamically allocate a socket for us */  if (PBControl((ParmBlkPtr)&amp;dspPB, false) != noErr)    Exit(DrvrErr);  else if ( dspPB.ioResult == noErr)  /* any errors? */  {      /* save socket returned to us by ADSP */    *localSocket = initParmsPtr-&gt;localSocket;      /* save ccb reference number returned to us by ADSP */    *ccbRefNum = dspPB.ccbRefNum;    return true;  }  else  /* got an error on the dspInit */  {    *ccbRefNum = 0;    ShowError(dspInitErr);    return false;  }}// *****************************************************************// *  initializeADSP// *// *  opens the adsp driver, allocates memory for our adsp buffers// *  then issues a passive open call// *****************************************************************void initializeADSP(){    /* set up the ADSP connection end. */  gJustConnected = false;  gCCBRefNum = 0;  changeConnectButtonState();      /* open the ADSP driver here - we need the reference number      for all ADSP calls */  if (OpenDriver(&quot;\p.DSP&quot;, &amp;gADSPDrvrRefNum) != noErr)    Exit(atalkErr);      if (InitQueues() == noErr)  {      /* allocate memory for our buffers and then        issue a passive open */    if (setUpADSPbuffers() == true)    {        /* issue a passive open */      if (WaitForConnectionRequest() != true)      {          /* oops! got an error so deallocate our buffers */        removeADSPBuffers();        Exit(memErr);      }    }    else      Exit(noMemErr);  }  else    Exit(memErr);}// *****************************************************************// *  SetOurCompletionRoutine// *// *    Sets the &quot;real&quot; completion routine for our async. calls// *****************************************************************void SetOurCompletionRoutine(ProcPtr procPtr,              DSPPBPtr dspPBPtr){Ptr p;myDSPParamBlockPtr myDSPPBPtr;  p = (Ptr)dspPBPtr;    /* the &quot;ourCompletion&quot; field is offset      8 bytes above the DSPParmBlock in      our definition */  myDSPPBPtr = (myDSPParamBlockPtr)(p - 8);  myDSPPBPtr-&gt;ourCompletion = procPtr;  }// *****************************************************************// *  GetQElement// *// *  retrieve a queue element from the specified queue// *****************************************************************DSPPBPtr GetQElement(QHdrPtr qHdrPtr){OSErr err;QElemPtr qElemPtr;  CheckDoneQueue();  qElemPtr = qHdrPtr-&gt;qHead;  if (qElemPtr != NULL)  {    err = Dequeue((QElemPtr)qElemPtr,qHdrPtr);    if (err != noErr)    {      return NULL;    }    else    {      return (DSPPBPtr)(qElemPtr);    }  }  else    return NULL;}// *****************************************************************// *  InitQueues// *// *  initialize our &quot;Available&quot; , &quot;Done&quot; and &quot;Read&quot; queues// *****************************************************************OSErr InitQueues(){short i;OSErr err;long myA5;myDSPParamBlockPtr myQElem;  gAvailQueue.qHead = NULL;  gAvailQueue.qTail = NULL;  gDoneQueue.qHead = NULL;  gDoneQueue.qTail = NULL;  gReadQueue.qHead = NULL;  gReadQueue.qTail = NULL;    err = noErr;  myA5 = *(long *)CurrentA5;    for (i=0; (i &lt; maxQElements) || (err != noErr); ++i)  {    myQElem = (myDSPParamBlockPtr)NewPtr(sizeof(myDSPParamBlock));    if (myQElem != NULL)    {      myQElem-&gt;myA5 = myA5;      myQElem-&gt;u.ioCompletion = (ProcPtr)&amp;PreCompletion;      Enqueue((QElemPtr)&amp;myQElem-&gt;u,&amp;gAvailQueue);    }    else    {      err = MemError();    }  }  return err;}// *****************************************************************// *  setUpADSPbuffers// *// *  allocates memory for our adsp buffers// *****************************************************************Boolean setUpADSPbuffers(){    receiveQBuffer = NewPtr(Qsize);  if ( receiveQBuffer == nil) return false;  sendQBuffer = NewPtr(Qsize);    if ( sendQBuffer == nil) return false;    attnBuffer = NewPtr(attnBufSize);  if ( attnBuffer == nil) return false;    outAttnBuff = NewPtr(attnBufSize);  if ( outAttnBuff == nil) return false;    receiveBuffer = NewPtr(attnBufSize);  if ( receiveBuffer == nil) return false;    outgoingDataBuffer = NewPtr(Qsize);  if ( outgoingDataBuffer == nil) return false;    return true;  }// *****************************************************************// *  changeConnectButtonState// *// *  sets the correct state for our connect button// *****************************************************************void changeConnectButtonState(){  /* this procedure reflects the state of our connection in the control */  Rect r;  short kind;  Handle h;    GetDItem(myDialog, kConnectButtonID, &amp;kind, &amp;h, &amp;r);        if ( (gCCBRefNum == 0) ||      ((gCCBRefNum != 0) &amp;&amp; (gMyCCB.state == sClosed)) )      SetCTitle((ControlHandle)h, &quot;\pConnect&quot;);    else    {      SetCTitle((ControlHandle)h, &quot;\pDisconnect&quot;);      HiliteConnectButton(0);    }}// *****************************************************************// *  DisplayTime// *// *  this procedure responds to an attention message from the remote// *  Mac which contains the time of that Mac.  Silly yes, but it does// *  show how to use the attnMsg stuff.// *****************************************************************void DisplayTime(){  Rect r;  short kind;  Handle h;  long dateTime;  Str255 str, str2;    GetDItem(myDialog, kRemoteMacsTimeID, &amp;kind, &amp;h, &amp;r);    GetIText(h, str2);    BlockMove(attnBuffer, &amp;dateTime, 4);    IUTimeString(dateTime, true, str);    /* this just checks to see that we're not already displaying this time already */    /* flashing text sucks... so sayeth me */    if (IUCompString(str,str2) != 0)      SetIText(h, str);}// *****************************************************************// *  DisplayTheirName// *// *  this procedure responds to an attention message from the remote// *  Mac which contains the remote Mac's Chooser name.// *****************************************************************void DisplayTheirName(){    Rect r;  short kind;  Handle h;  Str255 str;      GetDItem(myDialog, kRemoteMacsNameID, &amp;kind, &amp;h, &amp;r);    BlockMove(attnBuffer, &amp;str, 255);    SetIText(h, str);}// *****************************************************************// *  DisplayIncomingText// *// *  this procedure takes the text written to our receive buffer from// *  the remote Mac and displays the text in a dialog item// *****************************************************************void DisplayIncomingText(DSPPBPtr dspPBPtr){  Rect r;  short kind;  Handle h;  Str255 str;    GetDItem(myDialog, kIncomingTextID, &amp;kind, &amp;h, &amp;r);    BlockMove(dspPBPtr-&gt;u.ioParams.dataPtr, (Ptr)(&amp;str[1]), 255);    str[0] = (char)dspPBPtr-&gt;u.ioParams.actCount;    SetIText(h, &amp;str);}// *****************************************************************// *  removeADSPBuffers// *// *  this procedure deallocates the memory for our adsp buffers.// *****************************************************************void removeADSPBuffers(){  if (receiveQBuffer != NULL)    DisposPtr(receiveQBuffer);  if (sendQBuffer != NULL)    DisposPtr(sendQBuffer);  if (attnBuffer != NULL)    DisposPtr(attnBuffer);  if (outAttnBuff != NULL)    DisposPtr(outAttnBuff);  if (receiveBuffer != NULL)    DisposPtr(receiveBuffer);  if (outgoingDataBuffer != NULL)    DisposPtr(outgoingDataBuffer);}// *****************************************************************// *  CloseTheConnection// *// *  calls dspClose to close the connection end.// *****************************************************************void CloseTheConnection(short ccbRefNum){  DSPParamBlock pb;    pb.ioCRefNum       = gADSPDrvrRefNum;    pb.csCode         = dspClose;    pb.ccbRefNum       = ccbRefNum;    pb.u.closeParams.abort   = 1;    /* non zero value aborts any outstanding calls */    if (PBControl((ParmBlkPtr)&amp;pb, false) != noErr)      Exit(DrvrErr);}// *****************************************************************// *  removeConnectionEnd// *// *  calls dspRemove to eliminate the connection end.// *****************************************************************void removeConnectionEnd(short ccbRefNum){  DSPParamBlock pb;    pb.ioCRefNum       = gADSPDrvrRefNum;    pb.csCode         = dspRemove;    pb.ccbRefNum       = ccbRefNum;    pb.u.closeParams.abort   = 1;    /* non zero value aborts any outstanding calls */    if (PBControl((ParmBlkPtr)&amp;pb, false) != noErr)      Exit(DrvrErr);    if (pb.ioResult != noErr)      ShowError(dspRemoveErr);}// *****************************************************************// *  WaitForConnectionRequest// *// *  calls dspInit to establish a connection end. Then registers// *  our name on the net and does a passive open.// *****************************************************************Boolean WaitForConnectionRequest(){DSPPBPtr dspPBPtr;    /* first issue a dspInit */  if (doADSPinit(&amp;myLocalSocket,          &amp;gCCBRefNum,          &amp;gMyCCB) == true)  {      /* save our socket for comparison purposes later */    ourNetworkAddress.aSocket = myLocalSocket;      /* now register our nbp name with type &quot;moof&quot; */    if (registerMyName() == true)    {        /* get QElement for the dspInit call */      dspPBPtr = GetQElement(&amp;gAvailQueue);      if (dspPBPtr != NULL)      {          /* do a passive open, waiting for open requests */        DoPassiveOpen(dspPBPtr,                gCCBRefNum);        return true;      }    }    else  /* we got an error! */    {    /* remove connection end with dspRemove */      removeConnectionEnd(gCCBRefNum);        /* de-allocate memory we got for our buffers */      removeADSPBuffers();    }  }  return false;}// *****************************************************************// *  CloseConnection// *// *  calls dspRemove to eliminate the connection end. Then removes// *  our nbp name from the net and re-issues a passive open.// *****************************************************************void CloseConnection(){    /* do a dspRemove to close the connection end */  removeConnectionEnd(gCCBRefNum);      /* remove our nbp name &quot;moof&quot; */  removeMyName();  changeConnectButtonState();  zeroOutStrings();    /* at this point, we have closed the connection so let's issue      an asynchronous passive open. This call will complete whenever      we receive an open connection request from another machine. */  WaitForConnectionRequest();}// *****************************************************************// *  sendAttnMsgCompRoutine// *// *  when our send attention message call completes this procedure// *  will get called.// *****************************************************************pascal void sendAttnMsgCompRoutine(DSPPBPtr dspPBPtr){  if (dspPBPtr-&gt;ioResult == noErr)      /* place parameter block back into the &quot;Available&quot; queue */    Enqueue((QElemPtr)dspPBPtr,&amp;gAvailQueue);  else  /* some kind of error was returned */      /* place parameter block back into the &quot;Done&quot; queue */    Enqueue((QElemPtr)dspPBPtr,&amp;gDoneQueue);}// *****************************************************************// *  sendAttnMsg// *// *  this is a generic attention message sending routine.  all // *  attention messages are sent async using a shared buffer.   // *  the message code and the size of the message are passed to// *  this proc.// *****************************************************************void sendAttnMsg(DSPPBPtr dspPBPtr,         short buffSize,         Ptr attnData,         short msg,         short ccbRefNum){TRattnParams *attnParmsPtr;/* this is a generic attention message sending routine.  all attention messages are sent*//* async using a shared buffer.  the message code and the size of the message are passed to *//* this proc.*/  SetOurCompletionRoutine((ProcPtr)&amp;sendAttnMsgCompRoutine,              dspPBPtr);                dspPBPtr-&gt;ioCRefNum   = gADSPDrvrRefNum;  dspPBPtr-&gt;csCode     = dspAttention;  dspPBPtr-&gt;ccbRefNum   = ccbRefNum;    attnParmsPtr = &amp;dspPBPtr-&gt;u.attnParams;  attnParmsPtr-&gt;attnCode     = (unsigned short)msg;  attnParmsPtr-&gt;attnSize     = buffSize;  attnParmsPtr-&gt;attnData     = attnData;  attnParmsPtr-&gt;attnInterval   = 10;  if (PBControl((ParmBlkPtr)dspPBPtr, true) != noErr)    Exit(DrvrErr);}// *****************************************************************// *  OpenPassiveCompletionRtn// *// *  when our passive open call completes this procedure// *  will get called.// *****************************************************************pascal void OpenPassiveCompletionRtn(DSPPBPtr dspPBPtr){      if (dspPBPtr-&gt;ioResult == noErr)  {    gJustConnected = true;      /* issue a read so we can catch        any messages sent to us */    readIncoming(dspPBPtr,          gCCBRefNum);    }  else      /* place parameter block back into the &quot;Done&quot; queue */    Enqueue((QElemPtr)dspPBPtr,&amp;gDoneQueue);}// *****************************************************************// *  DoPassiveOpen// *// *  issues an asynchronous passive open call. Any machine wishing// *  to connect to us must only send us an open request (dspOpen, // *  ocRequest mode). Once we get a request, our completion routine// *  is called and the connection is established.// *****************************************************************void DoPassiveOpen(DSPPBPtr dspPBPtr,          short ccbRefNum){  AddrBlock filterAddress;  TRopenParams *openPBPtr;      /* send an open request */    SetOurCompletionRoutine((ProcPtr)&amp;OpenPassiveCompletionRtn,                dspPBPtr);    dspPBPtr-&gt;ioCRefNum   = gADSPDrvrRefNum;    dspPBPtr-&gt;csCode     = dspOpen;    dspPBPtr-&gt;ccbRefNum   = ccbRefNum; /* refNum of connection end    */      /* accept open requests from anyone */    filterAddress.aNet     = 0;    filterAddress.aNode   = 0;    filterAddress.aSocket   = 0;        openPBPtr = &amp;dspPBPtr-&gt;u.openParams;    openPBPtr-&gt;filterAddress   = filterAddress;    openPBPtr-&gt;ocMode       = ocPassive;    openPBPtr-&gt;ocInterval     = 0;  /* use default value of 6 (1 second) */    openPBPtr-&gt;ocMaximum     = 255;  /* retransmit indefinitely */    if (PBControl((ParmBlkPtr)dspPBPtr, true) != noErr)      Exit(dspOpenErr);    }// *****************************************************************// *  adspOpenRqstCompletionRtn// *// *  when our open request call completes this procedure// *  will get called. If we dont get back any errors then the// *  connection is established with the target.// *****************************************************************pascal void adspOpenRqstCompletionRtn(DSPPBPtr dspPBPtr){  if (dspPBPtr-&gt;ioResult == noErr)  {    gJustConnected = true;      /* issue a read so we can catch        any messages sent to us */    readIncoming(dspPBPtr,          gCCBRefNum);    }  else      /* place parameter block back into the &quot;Done&quot; queue */    Enqueue((QElemPtr)dspPBPtr,&amp;gDoneQueue);  }// *****************************************************************// *  sendAnOpenConnReq// *// *  issues an open request call to the target.// *****************************************************************void sendAnOpenConnReq (DSPPBPtr dspPBPtr,            AddrBlock theirAddress,            short ccbRefNum){  AddrBlock filterAddress;  TRopenParams *openPBPtr;      /* make a connection only with the selected target */    filterAddress = theirAddress;      /* send an open request */    SetOurCompletionRoutine((ProcPtr)&amp;adspOpenRqstCompletionRtn,                dspPBPtr);    dspPBPtr-&gt;ioCRefNum   = gADSPDrvrRefNum;    dspPBPtr-&gt;csCode     = dspOpen;    dspPBPtr-&gt;ccbRefNum   = ccbRefNum;          /* refNum of connection end    */    openPBPtr = &amp;dspPBPtr-&gt;u.openParams;    openPBPtr-&gt;remoteAddress   = theirAddress;    openPBPtr-&gt;filterAddress   = filterAddress;    openPBPtr-&gt;ocMode       = ocRequest;    openPBPtr-&gt;ocInterval     = 6;    openPBPtr-&gt;ocMaximum     = 5;    if (PBControl((ParmBlkPtr)dspPBPtr, true) != noErr)      Exit(dspOpenErr);    }// *****************************************************************// *  connectToPeer// *// *  first checks to see if the target is still there. Next, it// *  issues an open request to the target (but it first closes// *  the connection end which forces any prior passive open calls to// *  complete).// *****************************************************************void connectToPeer(){  NBPparms     *nbpParms;  MPPParamBlock   pbLKP;  char       returnBuffer[kLookupBufSize];  EntityName     abEntity;  AddrBlock     address;  NamesTableEntry namesTableEntry;  DSPPBPtr     dspPBPtr;      if (gMyCCB.state == sClosed ||      gMyCCB.state == sPassive)    {      NBPSetEntity((Ptr)&amp;namesTableEntry, gObjStr, gTypeStr, gZoneString);            nbpParms = &amp;pbLKP.NBP;            nbpParms-&gt;interval           = 3;      nbpParms-&gt;count           = 3;      nbpParms-&gt;NBPPtrs.entityPtr     = (Ptr)&amp;namesTableEntry;      nbpParms-&gt;parm.Lookup.retBuffSize   = kLookupBufSize;      nbpParms-&gt;parm.Lookup.retBuffPtr   = &amp;returnBuffer;      nbpParms-&gt;parm.Lookup.maxToGet     = 1;        /* see if the target still exists */      if (PLookupName(&amp;pbLKP, false) == noErr)      {        if ( nbpParms-&gt;parm.Lookup.numGotten &gt; 0)        {            /* look for the target in our return buffer */          if (NBPExtract(returnBuffer,                   nbpParms-&gt;parm.Lookup.numGotten,                  1,                  &amp;abEntity,                  &amp;address) == noErr)          {              /* if a passive open has been issued, we must first close the connection end (which                will cancel the open) before we can issue an open request to the target */            if (gMyCCB.state == sPassive)            {              CloseTheConnection(gCCBRefNum);            }                        dspPBPtr = GetQElement(&amp;gAvailQueue);            if (dspPBPtr != NULL)            {                /*  issue an open request to the target */              sendAnOpenConnReq(dspPBPtr,                        address,                        gCCBRefNum);            }          }                      }        else  /* target not found */          ShowError(noTargetErr);      }          }    else    /* disconnect */    {      CloseConnection();    }}// *****************************************************************// *  readIncomingComp// *// *  this routine is called when our asynchronous dspRead call// *  completes.// *****************************************************************pascal void readIncomingComp(DSPPBPtr dspPBPtr){  if (dspPBPtr-&gt;ioResult == noErr)  {      /* place parameter block back into the &quot;Read&quot; queue */    Enqueue((QElemPtr)dspPBPtr,&amp;gReadQueue);  }  else  /* error occurred */  {      /* place parameter block back into the &quot;Done&quot; queue */    Enqueue((QElemPtr)dspPBPtr,&amp;gDoneQueue);  }  }// *****************************************************************// *  readIncoming// *// *  issues an asynchronous dspRead to read any incoming messages// *****************************************************************void readIncoming(DSPPBPtr dspPBPtr,          short ccbRefNum){TRioParams *ioPBPtr;  SetOurCompletionRoutine((ProcPtr)&amp;readIncomingComp,              dspPBPtr);  dspPBPtr-&gt;ioCRefNum   = gADSPDrvrRefNum;  dspPBPtr-&gt;csCode     = dspRead;  dspPBPtr-&gt;ccbRefNum   = ccbRefNum;    ioPBPtr = &amp;dspPBPtr-&gt;u.ioParams;  ioPBPtr-&gt;reqCount     = Qsize;  ioPBPtr-&gt;dataPtr     = receiveBuffer;  if (PBControl((ParmBlkPtr)dspPBPtr, true) != noErr)    Exit(DrvrErr);    }// *****************************************************************// *  writeComp// *// *  when our asynchronous dspWrite completes this routine will get// *  called.// *****************************************************************pascal void writeComp(DSPPBPtr dspPBPtr){    /* place parameter block back into the &quot;Done&quot; queue */  Enqueue((QElemPtr)dspPBPtr,&amp;gDoneQueue);  }// *****************************************************************// *  writeOutgoing// *// *  issues an asynchronous dspWrite which sends any text that has// *  been entered to the target machine.// *****************************************************************void writeOutgoing(DSPPBPtr dspPBPtr,          short ccbRefNum,          Ptr dataPtr,          short reqCount){  TRioParams *ioPBPtr;    SetOurCompletionRoutine((ProcPtr)&amp;writeComp,                dspPBPtr);    dspPBPtr-&gt;ioCRefNum   = gADSPDrvrRefNum;    dspPBPtr-&gt;csCode     = dspWrite;    dspPBPtr-&gt;ccbRefNum   = ccbRefNum;        ioPBPtr = &amp;dspPBPtr-&gt;u.ioParams;    ioPBPtr-&gt;reqCount     = reqCount;    ioPBPtr-&gt;dataPtr     = dataPtr;    ioPBPtr-&gt;eom       = 1;    ioPBPtr-&gt;flush      = 1;    if (PBControl((ParmBlkPtr)dspPBPtr, true) != noErr)      Exit(DrvrErr);}// *****************************************************************// *  sendTime// *// *  this procedure sends an attention message packet with our// *  time to the remote Mac.// *****************************************************************void sendTime(){  unsigned long secs;  DSPPBPtr dspPBPtr;    GetDateTime(&amp;secs);    BlockMove(&amp;secs, outAttnBuff, 4);    dspPBPtr = GetQElement(&amp;gAvailQueue);    if (dspPBPtr != NULL)    {      sendAttnMsg(dspPBPtr,          4,          outAttnBuff,          kDisplayTime,          gCCBRefNum);    }}// *****************************************************************// *  sendMyName// *// *  this procedure sends an attention message packet with our // *  Chooser name to the remote Mac.// *****************************************************************void sendMyName(){  DSPPBPtr dspPBPtr;  Str255 str;    BlockMove(myName,str,myName[0]+1);    BlockMove(&amp;str, outAttnBuff, 256);        dspPBPtr = GetQElement(&amp;gAvailQueue);    if (dspPBPtr != NULL)    {      sendAttnMsg(dspPBPtr,            256,            outAttnBuff,            kDisplayTheirName,            gCCBRefNum);    }}// *****************************************************************// *  signalConnect// *// *  after our passive open call has completed with an open request, // *  or after an open request that we have issued to the target has// *  completed, we set a flag which causes this routine to get called.// *  This routine then sends the Chooser name of our machine to the// *  target.// *****************************************************************void signalConnect(){  SysBeep(1);  changeConnectButtonState();      /* send our machine's name to the other end */  sendMyName();    /*Change selection to outgoing text TERecord */  SelIText(myDialog, kOutgoingTextID, 0, 32767);}// *****************************************************************// *  checkAttnMsgs// *// *  If an attention message has been sent, we process it here.// *****************************************************************void checkAttnMsgs(){  switch(gMyCCB.attnCode)  {    case kDisplayTime:      DisplayTime();      break;    case kDisplayTheirName:      DisplayTheirName();      break;  }}// *****************************************************************// *  DoConnectionEvents// *// *  This routine checks for unsolicited connection events and// *  processes them accordingly.// *****************************************************************void DoConnectionEvents(){  short state;  Byte flags;    state = gMyCCB.state;    flags = gMyCCB.userFlags;    if (state == sOpen)      DisplayCurrentStatus(&quot;\pConnection established.&quot;);    else if (state == sClosed)      DisplayCurrentStatus(&quot;\pNot currently connected.&quot;);    else if (state == sPassive)      DisplayCurrentStatus(&quot;\pWaiting to accept connection.&quot;);        if (flags &amp; eAttention)    {      checkAttnMsgs();        /* we must clear the bit after we have used it or we wont          get any more messages */      BitClr(&amp;gMyCCB.userFlags,2);    }    else if (flags &amp; eClosed)    {      DisplayCurrentStatus(&quot;\pConnection was closed.&quot;);        /* we must clear the bit after we have used it or we wont          get any more messages */      BitClr(&amp;gMyCCB.userFlags,0);      CloseConnection();    }        /* after two minutes or so if the connection has broken we'll be notified by */        /* the .DSP driver with an eTearDown message */    else if (flags &amp; eTearDown)    {      SysBeep(2);      SysBeep(2);      DisplayCurrentStatus(&quot;\pConnection torn down.&quot;);        /* we must clear the bit after we have used it or we wont          get any more messages */      BitClr(&amp;gMyCCB.userFlags,1);      CloseConnection();    }}// *****************************************************************// *  CheckDoneQueue// *// *  This routine looks through the &quot;Done&quot; queue for calls that// *  have completed and reports any errors.// *****************************************************************void CheckDoneQueue(){QElemPtr qElemPtr;DSPPBPtr dspPBPtr;OSErr err;    /* have any Writes completed? */  if (gDoneQueue.qHead != nil)  {    qElemPtr = gDoneQueue.qHead;    err = Dequeue((QElemPtr)qElemPtr,&amp;gDoneQueue);    if (err == noErr)    {      dspPBPtr = (DSPPBPtr)qElemPtr;        /* were there any errors on this particular call? */      if (dspPBPtr-&gt;ioResult != noErr)      {        ShowADSPError(dspPBPtr);      }        /* place queue element back into the &quot;available&quot; queue */      Enqueue((QElemPtr)qElemPtr,&amp;gAvailQueue);    }  }}// *****************************************************************// *  CheckCompletedReads// *// *  This routine looks through the &quot;Read&quot; queue for calls that// *  have completed, displays the text that was read and re-issues// *    another asynchronous read call.// *****************************************************************void CheckCompletedReads(){QElemPtr qElemPtr;DSPPBPtr dspPBPtr;OSErr err;    /* have any reads completed? */  if (gReadQueue.qHead != nil)  {    qElemPtr = gReadQueue.qHead;    err = Dequeue((QElemPtr)qElemPtr,&amp;gReadQueue);    if (err == noErr)    {      dspPBPtr = (DSPPBPtr)qElemPtr;        /* were there any errors on this particular read call? */      if (dspPBPtr-&gt;ioResult == noErr)      {          /* show the text */        DisplayIncomingText(dspPBPtr);      }      else      {        ShowADSPError(dspPBPtr);      }        /* go ahead and issue another asynchronous read */      readIncoming(dspPBPtr,            gCCBRefNum);    }  }}// *****************************************************************// *  ADSPLoop// *// *  This is called from our idle procedure in our main event// *  loop. If a connection is made, we learn about it here. If we// *  do detect that a connection has been made, we check for// *  connection events and issue read and write calls here.// *****************************************************************void ADSPLoop(){    /* check to see if our passive open completed with an open      request from another machine OR if an open request that      we issued to the target has completed */  if (gJustConnected == true)  {      /* reset our flag */    gJustConnected = false;      /* set status message to indicate we have a connection */    signalConnect();  }    /* check for connection events */  DoConnectionEvents();  if (gMyCCB.state != sClosed)  {      /* have any read calls completed? */    CheckCompletedReads();        /* check for all other calls that have completed */    CheckDoneQueue();  }    /* do we currently have a connection? */  if (gMyCCB.state == sOpen)  {      /* we have a connection so send our clock time        to the other machine */    sendTime();  }}// *****************************************************************// *  SetUpADSPError// *// *  sets our error string for the desired error code// *****************************************************************void SetUpADSPError(OSErr err, StringPtr displayStr){  switch (err)  {    case errAborted:      PStrCat(&quot;\pControl call was aborted.&quot;,(Ptr)displayStr);      break;          case errState:      PStrCat(&quot;\pBad connection state for this operation.&quot;,(Ptr)displayStr);      break;    case errOpening:      PStrCat(&quot;\pOpen connection request failed.&quot;,(Ptr)displayStr);      break;          case errOpenDenied:      PStrCat(&quot;\pOpen connection request was denied.&quot;,(Ptr)displayStr);      break;          default:      NumToString(err,(Ptr)displayStr);      }}// *****************************************************************// *  ShowADSPError// *// *  If one of our asynchronous adsp calls returned an error, the// *  parameter block gets stuffed into an error OSQueue by the completion// *  routine. This error queue is checked periodically by this routine.// *  If the queue is not empty, then we got an error so we display it here// *  and do any processing of the error that we want.// *****************************************************************void ShowADSPError(DSPPBPtr dspPBPtr){  short itemHit;  Str255 displayStr,theError;        displayStr[0] = 0;              /*  Use cscode field of the parameter block           to see which call this error is for*/            switch (dspPBPtr-&gt;csCode)      {        case dspRead:            /* We'll ignore the &quot;errState&quot; error for now,              since you'll get this when you close a               connection (and we don't really need to              report it in that case) */          if (dspPBPtr-&gt;ioResult != errState)          {            CopyPstr(&quot;\pdspRead error. &quot;,&amp;displayStr);            SetUpADSPError(dspPBPtr-&gt;ioResult, &amp;displayStr);          }         break;          case dspWrite:          CopyPstr(&quot;\pdspWrite error. &quot;,&amp;displayStr);          SetUpADSPError(dspPBPtr-&gt;ioResult, &amp;displayStr);         break;              case dspAttention:            /* ignore aborts that were caused by dspRemove or dspClose */          if ((dspPBPtr-&gt;ioResult != errAborted)             &amp;&amp; (dspPBPtr-&gt;ioResult != errState))          {            CopyPstr(&quot;\pdspAttention error. &quot;,&amp;displayStr);            SetUpADSPError(dspPBPtr-&gt;ioResult, &amp;displayStr);          }         break;        case dspOpen:            /* ignore errAborted (-1279), request aborted by dspRemove or              dspClose - the reason being that if we have a dspOpen (ocPassive              mode) issued and then we want to connect to another machine, we              must first close the connection end (cancelling the passive open)              which would result in this error */          if (dspPBPtr-&gt;ioResult != errAborted)          {            CopyPstr(&quot;\pdspOpen error. &quot;,&amp;displayStr);            SetUpADSPError(dspPBPtr-&gt;ioResult, &amp;displayStr);          }         break;        case dspCLListen:          CopyPstr(&quot;\pdspCLListen error. &quot;,&amp;displayStr);          SetUpADSPError(dspPBPtr-&gt;ioResult, &amp;displayStr);         break;          default:          CopyPstr(&quot;\pError: &quot;,&amp;displayStr);          NumToString(dspPBPtr-&gt;ioResult,theError);          PStrCat(theError,(Ptr)displayStr);      }        /* if we have a message we want to show, put up a dialog          for the user */      if (displayStr[0] != 0)      {        ParamText(displayStr,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);        itemHit = Alert(rErrorDialog, nil);      }    }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ADSP_Chat/listing3.html%3Fid%3DDTS10000224-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ADSP_Chat/listing3.html%3Fid%3DDTS10000224-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ADSP_Chat/listing3.html%3Fid%3DDTS10000224-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>