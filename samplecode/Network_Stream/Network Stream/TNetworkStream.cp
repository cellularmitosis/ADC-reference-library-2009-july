//	TNetworkStream.cp - Macintosh OpenTransport Network Stream IO class object// // Apple Macintosh Developer Technical Support// Written by:  Vinne Moscaritolo////  Copyright (work in progress)  Apple Computer, Inc All rights reserved.//// You may incorporate this sample code into your applications without// restriction, though the sample code has been provided "AS IS" and the// responsibility for its operation is 100% yours.  However, what you are// not permitted to do is to redistribute the source as "DSC Sample Code"// after having made changes. If you're going to re-distribute the source,// we require that you make it clear in the source that the code was// descended from Apple Sample Code, but that you've made changes.// #include "TNetworkStream.h"#include <iomanip.h>#define DEFAULT_CHUNKSIZE 512// ---------------------------------------------------------------------------// --------------------------- Network Output Stream -------------------------// ---------------------------------------------------------------------------// ---------------------------------------------------------------------------//	 ~TNetworkIOStream()// ---------------------------------------------------------------------------//	DestructorTNetworkIOStream::~TNetworkIOStream(){}// ---------------------------------------------------------------------------// --------------------------- Network Stream Buffer -------------------------// ---------------------------------------------------------------------------// ---------------------------------------------------------------------------//	 ~TNetworkBuf// ---------------------------------------------------------------------------//	DestructorTNetworkBuf::~TNetworkBuf(){	close();};// ---------------------------------------------------------------------------//	 attach(ep)// ---------------------------------------------------------------------------//	attach Network stream to endpointvoid TNetworkBuf::attach(EndpointRef ep, TEndpointInfo* info){// insure that it isn't open already	if (is_open()) return;// OK to set up	fEndPoint = ep;	fInfo = 	info;	// calculate optimal chunk size	fChunkSize = (fInfo->tsdu < 1) ? DEFAULT_CHUNKSIZE :fInfo->tsdu;}// ---------------------------------------------------------------------------//	 close()// ---------------------------------------------------------------------------//	close network streamvoid  TNetworkBuf::close(){	if (is_open())  {// blow ya load		if(fBuffer)	sync();// clean up after		fEndPoint = kOTInvalidRef;		fBuffer = nil;		setp(0, 0);// initiate teardown here???	}}// ---------------------------------------------------------------------------//	 sync()// ---------------------------------------------------------------------------//	sync bufferint TNetworkBuf::sync(){// can only output when open.	if (! is_open()) return EOF;// flush buffers	flush_output();		return 0;}// ---------------------------------------------------------------------------//	 overflow(c)// ---------------------------------------------------------------------------//	process chars in bufffer area int TNetworkBuf::overflow(int c){// allocate buffer space if needed	if(pbase() == 0 && !doallocate())  return EOF;	// if flush requested force output	if(c == EOF) return flush_output();// check if we are at end of buffer	if ((pptr() >= epptr()) && flush_output(T_MORE) && !doallocate()) return EOF;// store char	*pptr() = c; pbump(1);		return c;}// ---------------------------------------------------------------------------//	 doallocate()// ---------------------------------------------------------------------------//	return true if alocationBoolean TNetworkBuf::doallocate(){	if(!pbase() && (fBuffer = (char*) ::OTAllocMem(fChunkSize) )) {		setp(fBuffer, fBuffer + fChunkSize );		return true;		}	return  false;}// ---------------------------------------------------------------------------//	 xputn(char*, len)// ---------------------------------------------------------------------------//	stuff chars into output bufferint TNetworkBuf::xsputn( const char *s, int len){	const unsigned char *p = (const unsigned char*) s;		if(len <= 0) return 0;		for(int i = 0; i<len; i++, p++)		if( sputc(*p) == EOF ) return i;			return len;}// ---------------------------------------------------------------------------//	 flush_output()// ---------------------------------------------------------------------------//	flush output bufferint TNetworkBuf::flush_output(OTFlags flags){	int len = fBuffer ? pptr() - pbase(): 0;// can only output when open.	if (! is_open()) return EOF;// out any data	if (len || (fInfo->flags & T_SENDZERO) ) {		::OTSnd(fEndPoint, fBuffer, len , flags);		fBuffer = nil;		setp(0,0);		}		return len;}// ---------------------------------------------------------------------------//	 underflow()// ---------------------------------------------------------------------------//	flush output bufferint TNetworkBuf::underflow(){	return EOF;}// ---------------------------------------------------------------------------//	 uflow()// ---------------------------------------------------------------------------//	 int TNetworkBuf::uflow(){	return EOF;}// ---------------------------------------------------------------------------//	 Release(buf);// ---------------------------------------------------------------------------//	Release buffer chainvoid TNetworkBuf::Release(void* buf){	::OTFreeMem( buf );}// ---------------------------------------------------------------------------//	 buf = ReserveBuffer(req, resp );// ---------------------------------------------------------------------------//	////// WRITE MEchar* TNetworkBuf::ReserveBuffer(size_t  reqCount, size_t  *actCount ){	*actCount  =  (reqCount > BUFFSIZE) ? BUFFSIZE : reqCount ; 	return ( (char*) Buffer );}// ---------------------------------------------------------------------------//	 EnqueueBuffer(buf, size );// ---------------------------------------------------------------------------//	////// WRITE MEvoid  TNetworkBuf::EnqueueBuffer(char* buf, size_t count ){		if(buf) if( count);}