<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Bluetooth Device Access Guide: Developing Bluetooth Applications</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Developing Bluetooth Applications"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000997-CH216" title="Developing Bluetooth Applications"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/Bluetooth-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30000490" target="_top">Bluetooth</a> &gt; <a href="../BT_Intro/BT_Intro.html#//apple_ref/doc/uid/TP30000997-CH213-BAJDAJDJ">Bluetooth Device Access Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../BT_Bluetooth_On_MOSX/BT_Bluetooth_On_MOSX.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../BT_RevHistory/BT_RevHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000997-CH216-TP9" title="Developing Bluetooth Applications"></a><h1>Developing Bluetooth Applications</h1><p>This chapter describes how to develop Bluetooth applications for Mac OS X. In this context, <em>Bluetooth applications</em> encompasses the full range of applications that access Bluetooth-enabled devices, directly or indirectly. Whether you’re interested in vending a Bluetooth service or in making sure your application handles a Bluetooth device just like any other, this chapter will help get you started.</p><p>This chapter first presents an overview of different types of Bluetooth applications. Then it discusses general design principles to consider while developing a Bluetooth application for Mac OS X. Finally, it describes some specific tasks an application might need to perform.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-TPXREF111">Overview of Bluetooth Application Types</a>
				
			<br/>
			
        
			
			
				<a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-TPXREF116">General Design Considerations</a>
				
			<br/>
			
        
			
			
				<a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACJGDDH">A Collection of Specific Tasks</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF111" title="Overview of Bluetooth Application Types"></a><h2>Overview of Bluetooth Application Types</h2><p>Bluetooth applications run the gamut from games that can utilize a Bluetooth input device to applications that vend Bluetooth services or support new profiles. Different applications need different levels of “Bluetooth awareness” to successfully perform their functions. Some applications may be able to use a high-level manager that Mac OS X provides without ever having to use the Bluetooth API. Others will use the Bluetooth API extensively to provide Bluetooth-specific services. The integration of Bluetooth support on Mac OS X supports applications throughout this range. </p><p>To help you decide at what level your application needs to communicate with a Bluetooth device, this section surveys some typical actions a Bluetooth application might take. After you read this section, you’ll have a better idea of what parts of the Mac OS X Bluetooth API (if any) you need to use. </p><a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF112" title="Accessing a HID-Class Device"></a><h3>Accessing a HID-Class Device</h3><p>If you’re writing a game or other application that accepts input from a HID-class device, you may be wondering if you need to do something special to support Bluetooth-enabled devices. Alternatively, if you provide a Bluetooth-enabled HID-class device, you might wonder how to implement special features in your driver. Fortunately, Apple has done most of the work for you. In Mac OS X version 10.2.5 and later, Apple provides a fully compliant HID-class driver that supports Bluetooth. This means that Bluetooth-enabled, HID-class devices work transparently on Mac OS X version 10.2.5 and later: Your game or other application that accepts input from a HID-class device need not be concerned with the device’s transport. Equally as important, it also means that you do not have to use Apple’s Bluetooth API to access such devices.</p><p>When you configure a HID-class device, the Apple-provided HID-class driver loads and takes care of all the protocols and profiles that talk to the Bluetooth module on the device. You do not need to write a kernel-resident driver to gain access to the device. Instead, your application can access and even customize a HID-class device using Apple’s HID Manager client API. The Mac OS X HID Manager client API provides access to a HID-class device through a device interface exported to user space by the HID family. For example, using the HID Manager client API you can:</p><ul class="spaceabove"><li class="li"><p>Open or close a device</p></li><li class="li"><p>Get the most recent value of an element</p></li><li class="li"><p>Set an element value</p></li></ul><p>For more information on using the HID Manager client API to access a HID-class device, see <em><a href="../../HID/index.html#//apple_ref/doc/uid/TP40000970" target="_top">HID Class Device Interface Guide</a></em>. For sample code illustrating how to use the HID Manager client API, see <span class="content_text"><a href="../../../../../samplecode/Games/idxHumanInterfaceDeviceForceFeedback-date.html#//apple_ref/doc/uid/TP30000925-TP30000467-TP30000855" target="_top">Games Human Interface Device &amp; Force Feedback Sample Code</a></span>.</p><p>Although you don’t need to use the Bluetooth API to access a HID-class device, you may choose to use functions or methods from the Bluetooth framework to enhance the user’s experience. For example, your application can provide Bluetooth-specific information that lets the user know if a device doesn’t support a particular service. You can read about some of these tasks in <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACJGDDH">“A Collection of Specific Tasks.”</a></span></p><a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF113" title="Accessing Serial Ports"></a><h3>Accessing Serial Ports</h3><p>The Bluetooth serial port profile forms the basis of a number of other profiles, such as dial-up networking, generic object exchange, and object push. In addition, the serial port profile provides a serial port emulation layer that supports applications that require direct serial port access. With the Bluetooth serial port profile, these applications can treat a Bluetooth link as a serial cable link using standard POSIX ttys.</p><p>In general, applications that depend on direct serial port access are legacy applications or, perhaps, the debugging components of other applications. Even though it may seem easier for legacy applications to use the serial port emulation layer exclusively when communicating with Bluetooth devices, there are drawbacks:</p><ul class="spaceabove"><li class="li"><p>All Bluetooth-specific errors are reported as a failure to open the serial port.</p><p>Whether, for example, the Bluetooth device could not be found or it does not support the desired service, the user is informed that the serial port could not be opened. This is frustrating for the user because it does not accurately describe the problem and provides no guidance on how to fix it.</p></li><li class="li"><p>The user must set up the serial port.</p><p>A legacy serial port application requires the user to set up the serial port. This is not a trivial task and can be confusing for novice users. </p></li></ul><p>As an alternative to using the serial port profile, Apple strongly recommends that legacy applications expecting direct serial port access be updated to use the Bluetooth RFCOMM API. Using the RFCOMM API, you get the best of both worlds:</p><ul class="spaceabove"><li class="li"><p>Unfettered access to the serial ports</p></li><li class="li"><p>Complete control over the creation, behavior, and destruction of RFCOMM channels</p></li><li class="li"><p>Fine-grained error reporting, including the reporting of Bluetooth-specific errors and status messages</p></li><li class="li"><p>A clean and comprehensive user interface featuring integrated Bluetooth UI panels for device selection</p></li></ul><a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF114" title="Vending a Bluetooth Service"></a><h3>Vending a Bluetooth Service</h3><p>Bluetooth support on Mac OS X version 10.2 and later allows you to create new services in software and make them available to remote clients. Using the APIs in the Bluetooth frameworks, you define a service, ensure that it is visible to others, and serve it to remote clients.</p><p>Of course, which Bluetooth APIs you use depends on the nature of the service you plan to offer. One task that is common to all such applications, however, is the addition of the service to the local SDP database. A service must be present in the SDP database so remote clients can find it during an SDP inquiry. Apple has streamlined this task by defining:</p><ul class="spaceabove"><li class="li"><p>The scope of the service</p></li><li class="li"><p>The format of the service’s attributes</p></li></ul><p>A service’s scope can be either transient or persistent. A transient service exists only while the application that registered it is running. When that application closes, the service is automatically removed and the Mac OS X Bluetooth system performs any necessary clean up. As its name suggests, a persistent service persists beyond the running of the application that registered it; it even persists across reboots. A persistent service can initiate the launch of a client application when a remote connection requests the service.</p><p>As described in <span class="content_text"><a href="../BT_Bluetooth_On_MOSX/BT_Bluetooth_On_MOSX.html#//apple_ref/doc/uid/TP30000997-CH215-CIAJHEAC">“Objects in Bluetooth Connections,”</a></span> the Bluetooth system uses a dictionary format to define a Bluetooth service. In a service’s dictionary, each entry corresponds to a service attribute. This scheme makes a new service easy to define because you can describe it in a property list. It also makes it easy to add the dictionary to the SDP database. Using the Bluetooth framework API you can create an SDP service record from your dictionary, add it to the SDP database, and remove it from the database.</p><p>For specific examples detailing how to work with service-attribute dictionaries, see <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACIGAHC">“Providing a New Service.”</a></span></p><p>Another task specific to creating a new service to vend is getting a UUID to identify it. The Bluetooth specification defines UUIDs for various profiles and services. In addition, the SDP describes a method of generating UUIDs that guarantees an extremely small chance of duplication. For more information on the basis of this method, see <span class="content_text"><a href="http://www.opengroup.org/publications/catalog/c706.htm" target="_blank">http://www.opengroup.org/publications/catalog/c706.htm</a></span>. Apple uses Core Foundation functions to generate UUIDs. For more information on how to do this, see <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACIHJGF">“Generating a UUID.”</a></span></p><a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF116" title="General Design Considerations"></a><h2>General Design Considerations</h2><p>This section discusses general design considerations you should keep in mind as you develop a Bluetooth application for Mac OS X. Presented in no particular order, these considerations will help you produce an application that is easy to use and takes full advantage of Bluetooth technology.</p><a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF117" title="Inquiring and Paging"></a><h3>Inquiring and Paging</h3><p>The Bluetooth specification describes an inquiry process designed to find all Bluetooth devices in the immediate area. The process consists of sending out frequent inquiries and waiting for acknowledgements from in-range devices. The Bluetooth specification also defines a paging process in which a device or application sends out frequent pages to a particular device. If the target device is in range (and willing to connect) it will send a positive response to the page. </p><p>Although the Bluetooth specification supports the inquiry and paging processes, the practical implementation of these processes can lead to some undesirable effects, such as:</p><ul class="spaceabove"><li class="li"><p>An application that is constantly performing inquiries is disrupting 802.11b traffic in the vicinity.</p><p>This can severely degrade a system’s or device’s ability to send and receive other Bluetooth communication. In addition, it needlessly pollutes the wireless environment, adversely affecting other 802.11b devices.</p></li><li class="li"><p>Performing frequent pages does not result in a positive user experience.</p><p>One of the main reasons an application would want to perform device paging is to simulate a device-proximity detector: When the desired device comes into range, it responds to the application’s page and triggers some specific task in the application. The paging process is a lengthy one, however, and like the inquiry process, results in degraded Bluetooth communication for its duration. In the worst case (when the desired device is not present), the timeout for the page could be as much as 15 seconds.</p></li><li class="li"><p>For a device to be visible to an inquiry, it must be in discoverable mode.</p><p>The vast majority of devices are not in discoverable mode by default. The user must actively choose to make a device discoverable. In addition, a device that is always in discoverable mode is using more power. Since most Bluetooth-enabled devices are wireless, this means a greater drain on the battery. Finally, a perpetually discoverable device is more vulnerable to unwanted connections.</p></li></ul><p>The alternative to the discoverable mode is the connectable mode. When a device is connectable, it doesn’t respond to inquiries but it does respond to specific connection requests. Apple’s Bluetooth UI framework provides device and service discovery methods and functions that find known devices and avoid the problems listed above.</p><p>In Mac OS X version 10.4, Apple introduced the IOBluetoothDeviceInquiry class. Using the IOBluetoothDeviceInquiry object instantiated from this class, your application can perform non-GUI device inquiries.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000997-CH216-DontLinkElementID_4" title="Note"></a><p><strong>Note:</strong>&nbsp;You are strongly encouraged to use the device-discovery methods provided in the Bluetooth UI framework. Only if your application absolutely cannot use them should you consider using the IOBluetoothDeviceInquiry methods instead. If you do use the IOBluetoothDeviceInquiry API, be sure you heed the warnings described in <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACFJHEB">“Performing Device Inquiries.”</a></span></p></div><a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF118" title="Bandwidth Constraints"></a><h3>Bandwidth Constraints</h3><p>Bluetooth was developed as a low-bandwidth, wireless connectivity solution. It’s important to keep the bandwidth constraint in mind when designing your application. The total per-link budget for throughput and bandwidth is 720 kbps. This means that there are 720 kbps available to be shared among <em>all</em> connections on a link. When an application assumes that all 720 kbps are available to a single connection, there are two negative consequences:</p><ul class="spaceabove"><li class="li"><p>The performance on other connections is degraded</p></li><li class="li"><p>The application is likely to experience a much lower level of throughput, especially if the user has selected to use a Bluetooth mouse or keyboard. Quality-of-service constraints require Mac OS X to devote bandwidth to these devices, as well.</p></li></ul><p>It’s important to scrutinize your application’s bandwidth and throughput needs. If you do require a full 720 kbps of bandwidth, Bluetooth is probably the wrong choice for your wireless connectivity.</p><a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF119" title="SCO"></a><h3>SCO</h3><p>As described in <span class="content_text"><a href="../BT_Bluetooth_Basics/BT_Bluetooth_Basics.html#//apple_ref/doc/uid/TP30000997-CH214-CHDJGCEG">“The Bluetooth Protocol Stack,”</a></span> SCO stands for synchronous, connection-oriented links. These links are used primarily for voice communication. With Bluetooth 1.5 (which runs in Mac OS X version 10.3.2 and later), Apple introduced support for the headset profile, which is based on a SCO link. Using a computer equipped with an internal Apple Bluetooth module (or a D-Link DBT-120 rev. B or later) running the latest firmware, you can use a Bluetooth-enabled headset to communicate using iChat AV 2.1 public beta or later.</p><p>It’s important to realize that, in its current implementation, SCO is not adequate for speech recognition in Mac OS X. Although the operating system could support it, most SCO-based headsets would not be able to deliver the 22 kHz, 16-bit resolution required for speech recognition.</p><a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF120" title="Device Interfaces"></a><h3>Device Interfaces</h3><p>If you’re familiar with the I/O Kit, Apple’s object-oriented framework for developing device drivers, you may also be familiar with the concept of a device interface. A device interface is an I/O Kit construct that allows you to access hardware from applications. Using a device interface, you can develop an application-based device driver that enjoys the same level of control available to in-kernel drivers.</p><p>You do <em>not</em> need to use a device interface to access a Bluetooth device from an application. The Bluetooth framework APIs available in Mac OS X version 10.2 and later provide everything you need to access both Bluetooth devices and objects in the Bluetooth protocol stack. Using the Bluetooth framework APIs, you can:</p><ul class="spaceabove"><li class="li"><p>Create and destroy connections</p></li><li class="li"><p>Receive notifications of device appearance and disappearance</p></li><li class="li"><p>Transfer data to and from a device</p></li></ul><a name="//apple_ref/doc/uid/TP30000997-CH216-BACJGDDH" title="A Collection of Specific Tasks"></a><h2>A Collection of Specific Tasks</h2><p>Every Bluetooth application is unique, but there are a number of tasks that are common to many applications. This section presents several of these tasks and describes how to perform them using the Bluetooth and Bluetooth UI API.</p><p>Much of the code illustrating these tasks is drawn from the sample applications available in <code>/Developer/Examples/Bluetooth</code> on Mac OS X version 10.2 and later. The samples are also included in the SDK, available at <span class="content_text"><a href="http://developer.apple.com/hardware/bluetooth/" target="_top">http://developer.apple.com/hardware/bluetooth/</a></span>. Examine these sample applications to see how the individual tasks in this section fit into a complete application.</p><a name="//apple_ref/doc/uid/TP30000997-CH216-BACIGAHC" title="Providing a New Service"></a><h3>Providing a New Service</h3><p>If you’re providing a new Bluetooth service, you must make that service available through the local SDP database. This ensures that your service is visible to potential clients performing SDP service searches. Then, you wait for a client to request your service.</p><p>There are five steps in providing a service:</p><ol class="ol"><li class="li"><p>Define the service.</p></li><li class="li"><p>Generate a UUID for the service (or, if you’re providing a predefined service, use the UUID defined in the profile).</p></li><li class="li"><p>Add the service definition to the SDP database.</p></li><li class="li"><p>Register for notification of the opening of the incoming channel assigned to the service.</p></li><li class="li"><p>When finished providing the service, remove the service definition from the SDP database.</p></li></ol><p>The following sections describe these five steps in detail. API reference for the functions in this section is available at <span class="content_text"><!--a target="_top" -->Device Drivers Bluetooth Documentation<!--/a--></span> or on disk from <code>/Developer/Documentation/DeviceDriversIOKit/DeviceDriversIOKit.html</code>.</p><a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF121" title="Defining a Service"></a><h4>Defining a Service</h4><p>As described in <span class="content_text"><a href="../BT_Bluetooth_On_MOSX/BT_Bluetooth_On_MOSX.html#//apple_ref/doc/uid/TP30000997-CH215-CIAJHEAC">“Objects in Bluetooth Connections,”</a></span> you define a service by creating a dictionary in which each key-value pair, or property, corresponds to a service attribute. Apple makes it easy to add new services to the system by supporting the importation of a <code>plist</code> file that contains the dictionary. Thus, instead of building up a potentially complex dictionary in code, you can use the Property List Editor application to create it. Then, you use the Bluetooth API to load the dictionary into your application. <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACIEJCA">Figure 3-1</a></span> shows a portion of the dictionary that describes the RFCOMM Chat Server service.</p><br/><div><a name="//apple_ref/doc/uid/TP30000997-CH216-BACIEJCA" title="Figure 3-1Partial listing of RFCOMM Chat Server service dictionary"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>Partial listing of RFCOMM Chat Server service dictionary</p><img src = "../art/bt_plist.gif" alt = "Partial listing of RFCOMM Chat Server service dictionary" width="529" height="387"></div><br/><p>Each property in the dictionary corresponds to one of the many service attributes defined by the Bluetooth specification (or to one of the attributes defined in the service’s profile). The property’s key is the attribute ID, and the value is the attribute’s data value. For example, the first property in the dictionary in <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACIEJCA">Figure 3-1</a></span> describes the service record handle, a 32-bit number that uniquely identifies the service within the server. The third key-value pair describes the Bluetooth protocols the service needs.</p><p>Each attribute key is a string that must begin with a hexadecimal number representing the attribute’s ID. These IDs are defined in the file <code>BluetoothAssignedNumbers.h</code>, available in the Bluetooth framework. If you choose, you can add other characters to the key string, but only after a space following the hexadecimal ID number. For example, each key in the dictionary above displays the name of the attribute after the ID number and a space.</p><p>Each attribute value contains the information that describes the attribute. The Bluetooth specification defines several data types that identify the different types of data the attribute values can contain. For example, an unsigned integer is type 1, and a sequence of data elements is type 6. Apple has mapped these data types onto Foundation classes such as NSNumber and NSArray. In turn, these classes correspond to native property list types, such as <code>integer</code> and <code>array</code>. This chain of correspondence makes it easy to translate a dictionary in a <code>plist</code> file into a service record object that represents your service.</p><p>As you can see in <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACIEJCA">Figure 3-1</a></span>, however, the attribute values differ significantly from one another. This is because different attribute-value types can be described in different ways. Formally, an attribute value is described by a combination of three components:</p><ul class="spaceabove"><li class="li"><p>The size of the data</p></li><li class="li"><p>A description of the data type</p></li><li class="li"><p>The data itself</p></li></ul><p>This set of information is neatly captured in a three-property dictionary in which each property key names a component and each corresponding value holds the information. An example of such a dictionary is inside the value of the protocol descriptor list key shown in <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACIEJCA">Figure 3-1</a></span>:</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>DataElementSize&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>1&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>DataElementType&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>1&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>DataElementValue&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>3&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr></table></div><p>However, to make it easier to create an attribute dictionary in a <code>plist</code> file, Apple provides some shortcuts for common data types:</p><ul class="spaceabove"><li class="li"><p>If the attribute’s value is of type <code>string</code>, <code>data</code>, or <code>array</code>, you do not need to provide a data-element size property. This is because the Mac OS X Bluetooth system will infer the data type from the dictionary type and calculate the size from the data itself.</p></li><li class="li"><p>If the attribute’s value is a string or an unsigned, 32-bit integer, no three-property dictionary is required to describe it. The value of the service record handle key in <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACIEJCA">Figure 3-1</a></span> is an example of an unsigned, 32-bit integer value.</p></li><li class="li"><p>If the value is of the <code>nil</code> type (type 0), neither the data-element size property nor the data-element value property is required.</p></li><li class="li"><p>If the data type is either unsigned integer or signed two’s complement integer, you can use the <code>data</code> property list type to hold the value. In this case, the numeric data is read into the service record in network-byte order (most significant byte first). No data-element size property is needed for these data types when you use the <code>data</code> property list type.</p></li><li class="li"><p>If the attribute’s value is a UUID, you can use the <code>data</code> property list type to hold it. The Mac OS X Bluetooth system will infer the data type and calculate the size from the value.</p></li><li class="li"><p>If the attribute’s value is a list, such as the protocol-descriptor list attribute in <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACIEJCA">Figure 3-1</a></span>, you use the<code> array</code> property list type to represent it. Each array member describes a member of the list. Because each array member is itself a data element, it must conform to the guidelines for attribute values.</p></li></ul><p>At this time, there are two service-attribute properties you do not have to place in your service dictionary:</p><ul class="spaceabove"><li class="li"><p>Service record handle</p></li><li class="li"><p>RFCOMM channel ID</p></li></ul><p>Because there is a single name space for service record handles and channel IDs, the Bluetooth system assigns these when your application imports the dictionary. If you do include these properties in your service-attribute dictionary, the Bluetooth system attempts to use them. If the values you specify are already in use, the Bluetooth system assigns others instead.</p><p>The service attributes discussed so far are defined by the Bluetooth specification. They are made available through the service-discovery process so potential clients can make informed choices. In addition to these attributes, Apple defines optional local attributes that control the local behavior of the service. These attributes are not visible to remote clients. At this time, Apple defines two local attributes:</p><ul class="spaceabove"><li class="li"><p>Persistent</p></li><li class="li"><p>Target application</p></li></ul><p>You specify these attributes in a special property with the key <code>LocalAttributes</code>, placed at the root level of your service’s attribute dictionary. The value of the <code>LocalAttributes</code> key must be a dictionary whose members are individual local attributes.</p><p>The persistent attribute (identified by the key <code>Persistent</code>) accepts a Boolean type. A value of TRUE indicates that the service should persist beyond the application that initiated it and across system reboots. When you use this attribute to designate a service as persistent, the service-record handle is automatically saved. It is used to restore the service whenever the associated Bluetooth hardware is present. It’s essential that your application save its own copy of a persistent service’s record handle, too. This is because the only way to programmatically remove a persistent service is to pass the record handle to the <code><!--a-->IOBluetoothRemoveServiceWithRecordHandle<!--/a--></code> function. (For information on how to force the removal of a service whose handle you don’t know, see <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACBDEIH">“Removing a Service Without a Handle.”</a></span>)</p><p>By default, the absence of the <code>Persistent</code> attribute causes the service to be transient. (Note that the absence of the local attributes property as a whole also means the service is considered transient.) This means that the service is automatically removed when the client application terminates. If you choose, you can remove a transient service before the client application exits by calling <code><!--a-->IOBluetoothRemoveServiceWithRecordHandle<!--/a--></code>.</p><p>The second local attribute specifies an application that should be launched when a remote device attempts to connect to the service. This happens when a remote device tries to open an L2CAP or RFCOMM channel of the type specified in the service’s service record. The key of this local attribute is <code>TargetApplication</code>, and the value must be a string containing the absolute path to the target application’s executable file. If no <code>TargetApplication</code> attribute is present (or if the local attributes dictionary is absent), no special action is taken when a remote device connects to the service. In this case, it’s the application’s responsibility to watch for the connection and take the appropriate steps.</p><a name="//apple_ref/doc/uid/TP30000997-CH216-BACIHJGF" title="Generating a UUID"></a><h4>Generating a UUID</h4><p>To generate a UUID for your service, you can use the command-line utility <code>uuidgen</code>. Simply type <code>uuidgen</code> on the command line to receive a unique 128-bit value in the form of a hyphen-punctuated ASCII string, as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>% uuidgen<span></span></pre></td></tr><tr><td scope="row"><pre>4302FA6D-089B-11D8-96C4-0030656F08FE<span></span></pre></td></tr></table></div><p>You then use this UUID to identify your service. In the unlikely event you need a new UUID each time your code executes, you can use a Core Foundation function to generate it. Listing <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACJHFDG">Listing 3-1</a></span> shows how to do this.</p><a name="//apple_ref/doc/uid/TP30000997-CH216-BACJHFDG" title="Listing 3-1Generating a new UUID in code"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>Generating a new UUID in code</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;CoreFoundation/CoreFoundation.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CFUUIDRef   uuid;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFStringRef string;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    uuid = CFUUIDCreate( NULL );<span></span></pre></td></tr><tr><td scope="row"><pre>    string = CFUUIDCreateString( NULL, uuid );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFShow( string );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF122" title="Adding a Service Definition to the SDP Database"></a><h4>Adding a Service Definition to the SDP Database</h4><p>After you’ve described your service’s attributes in a <code>plist</code> file, you’re ready to use it in your application. The following is an outline of the steps you take to make your service available:</p><ol class="ol"><li class="li"><p>Create a dictionary and initialize it with the contents of your <code>plist</code> file.</p></li><li class="li"><p>Create an SDP service record that contains the attributes in your dictionary.</p></li><li class="li"><p>Preserve the newly created service-record handle. This is required if your service is persistent or if you plan to terminate a transient service before your application closes.</p></li><li class="li"><p>If necessary, preserve the RFCOMM or L2CAP channel the system assigns to your service.</p></li></ol><p>The code in <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACCCCJF">Listing 3-2</a></span> shows how to implement these steps. It assumes that you already defined an attribute dictionary in a <code>plist</code> file and know the file’s path. For brevity’s sake, only limited error handling is shown.</p><a name="//apple_ref/doc/uid/TP30000997-CH216-BACCCCJF" title="Listing 3-2Making a new service available"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>Making a new service available</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)publishService<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString            *dictionaryPath = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString            *serviceName = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableDictionary *sdpEntries = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a string with the new service name.<span></span></pre></td></tr><tr><td scope="row"><pre>    serviceName = [NSString stringWithFormat:@"%@ My New Service", [self<span></span></pre></td></tr><tr><td scope="row"><pre>                            localDeviceName]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the path for the dictionary we wish to publish.<span></span></pre></td></tr><tr><td scope="row"><pre>    dictionaryPath = [[NSBundle mainBundle]<span></span></pre></td></tr><tr><td scope="row"><pre>                pathForResource:@"MyServiceDictionary" ofType:@"plist"];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( ( dictionaryPath != nil ) &amp;&amp; ( serviceName != nil ) )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Initialize sdpEntries with the dictionary from the path.<span></span></pre></td></tr><tr><td scope="row"><pre>        sdpEntries = [NSMutableDictionary<span></span></pre></td></tr><tr><td scope="row"><pre>                    dictionaryWithContentsOfFile:dictionaryPath];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if ( sdpEntries != nil )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            IOBluetoothSDPServiceRecordRef  serviceRecordRef;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            [sdpEntries setObject:serviceName forKey:@"0100 - ServiceName*"];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Create a new IOBluetoothSDPServiceRecord that includes both<span></span></pre></td></tr><tr><td scope="row"><pre>        // the attributes in the dictionary and the attributes the<span></span></pre></td></tr><tr><td scope="row"><pre>        // system assigns. Add this service record to the SDP database.<span></span></pre></td></tr><tr><td scope="row"><pre>            if (IOBluetoothAddServiceDict( (CFDictionaryRef) sdpEntries,<span></span></pre></td></tr><tr><td scope="row"><pre>                        &amp;serviceRecordRef ) == kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                IOBluetoothSDPServiceRecord *serviceRecord;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                serviceRecord = [IOBluetoothSDPServiceRecord<span></span></pre></td></tr><tr><td scope="row"><pre>                            withSDPServiceRecordRef:serviceRecordRef];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                // Preserve the RFCOMM channel assigned to this service.<span></span></pre></td></tr><tr><td scope="row"><pre>                // A header file contains the following declaration:<span></span></pre></td></tr><tr><td scope="row"><pre>                // IOBluetoothRFCOMMChannelID mServerChannelID;<span></span></pre></td></tr><tr><td scope="row"><pre>                [serviceRecord getRFCOMMChannelID:&amp;mServerChannelID];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                // Preserve the service-record handle assigned to this<span></span></pre></td></tr><tr><td scope="row"><pre>                // service.<span></span></pre></td></tr><tr><td scope="row"><pre>                // A header file contains the following declaration:<span></span></pre></td></tr><tr><td scope="row"><pre>                // IOBluetoothSDPServiceRecordHandle mServerHandle;<span></span></pre></td></tr><tr><td scope="row"><pre>                [serviceRecord getServiceRecordHandle:&amp;mServerHandle];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                // Now that we have an IOBluetoothSDPServiceRecord object,<span></span></pre></td></tr><tr><td scope="row"><pre>                // we no longer need the IOBluetoothSDPServiceRecordRef.<span></span></pre></td></tr><tr><td scope="row"><pre>                IOBluetoothObjectRelease( serviceRecordRef );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF123" title="Getting Channel-Open Notifications"></a><h4>Getting Channel-Open Notifications</h4><p>The system assigns a particular RFCOMM channel to your service, and your application needs to know when a client is opening that channel. To do this, you register for a channel-open notification. <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACIDEJG">Listing 3-3</a></span> shows how to do this, using the RFCOMM channel ID you saved when you added your service dictionary (as shown in <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACCCCJF">Listing 3-2</a></span>).</p><a name="//apple_ref/doc/uid/TP30000997-CH216-BACIDEJG" title="Listing 3-3Registering for a channel-open notification"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>Registering for a channel-open notification</p><div class="codesample"><table><tr><td scope="row"><pre>// Register for a notification so we get notified when a client opens<span></span></pre></td></tr><tr><td scope="row"><pre>// the channel assigned to our new service.<span></span></pre></td></tr><tr><td scope="row"><pre>// A header file contains the following declaration:<span></span></pre></td></tr><tr><td scope="row"><pre>// IOBluetoothUserNotification *mIncomingChannelNotification;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>mIncomingChannelNotification = [IOBluetoothRFCOMMChannel<span></span></pre></td></tr><tr><td scope="row"><pre>        registerForChannelOpenNotifications:self<span></span></pre></td></tr><tr><td scope="row"><pre>        selector:@selector(newRFCOMMChannelOpened:channel:)<span></span></pre></td></tr><tr><td scope="row"><pre>        withChannelID:mServerChannelID<span></span></pre></td></tr><tr><td scope="row"><pre>        direction:kIOBluetoothUserNotificationChannelDirectionIncoming];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000997-CH216-TPXREF124" title="Withdrawing a Service"></a><h4>Withdrawing a Service</h4><p>When your application is ready to stop providing your service, you must remove it from the SDP database so it is no longer available to potential clients. To do this, you use the service record handle you saved when you first added your service dictionary to the database. In addition, you should unregister for the channel open notifications for which you registered earlier. <span class="content_text"><a href="BT_Develop_BT_Apps.html#//apple_ref/doc/uid/TP30000997-CH216-BACHBBGD">Listing 3-4</a></span> shows how to perform these tasks.</p><a name="//apple_ref/doc/uid/TP30000997-CH216-BACHBBGD" title="Listing 3-4Preparing to stop providing a service"></a><p class="codesample"><strong>Listing 3-4&nbsp;&nbsp;</strong>Preparing to stop providing a service</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)stopProvidingService<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( mServerHandle != 0 )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Remove the service.<span></span></pre></td></tr><tr><td scope="row"><pre>        IOBluetoothRemoveServiceWithRecordHandle( mServerHandle );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Unregister the notification.<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( mIncomingChannelNotification != nil )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [mIncomingChannelNotification unregister];<span></span></pre></td></tr><tr><td scope="row"><pre>        mIncomingChannelNotification = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    mServerChannelID = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000997-CH216-BACBDEIH" title="Removing a Service Without a Handle"></a><h4>Removing a Service Without a Handle</h4><p>If you’ve created a persistent service and your application crashes before you’re able to save the service-record handle, you can remove it manually, as the following steps show. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000997-CH216-DontLinkElementID_5" title="Note"></a><p><strong>Note:</strong>&nbsp;Following these steps results in the loss of all cached Bluetooth information on your system, such as device names and paired-device information. This should only be done as a last resort and <em>never</em> by an end user.</p></div><ol class="ol"><li class="li"><p>Enable the root user.</p><p>To do this, open Directory Utility (located in <code>/Applications/Utilities</code>), click the lock to make changes, and choose Edit > Enable Root User. (Note that you should disable the root user when you are not using it, to ensure the security and stability of your system.)</p></li><li class="li"><p>Open the Terminal application and log in as root.</p></li><li class="li"><p>Change directory to <code>/var/root/Library/Preferences</code>.</p></li><li class="li"><p>Remove the <code>blued.plist</code> file.</p></li></ol><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000997-CH216-DontLinkElementID_6" title="Important:"></a><p><strong>Important:</strong>&nbsp;The <code>blued.plist</code> file is an internal implementation detail. You should not write code that depends on its location or existence.</p><p></p></div><a name="//apple_ref/doc/uid/TP30000997-CH216-BACHDHDG" title="Using Delegates to Receive Asynchronous Messages"></a><h3>Using Delegates to Receive Asynchronous Messages</h3><p>Beginning in Mac OS X version 10.2.5, you can use delegates in your Objective-C application to receive asynchronous messages sent by L2CAP and RFCOMM channels. These messages include notifications of incoming data and channel status changes. When an L2CAP or RFCOMM channel is opened, the client of the channel uses the <code>setDelegate:</code> method to designate a delegate. It’s often convenient for the client to make itself the delegate, as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>[newRFCOMMChannel setDelegate:self]<span></span></pre></td></tr></table></div><p>If you choose to employ a delegate to receive asynchronous messages, you must implement at least the incoming data delegate method. Other delegate methods, such as those that receive channel status messages, are optional. The header files <code>IOBluetoothL2CAPChannel.h</code> and <code>IOBluetoothRFCOMMChannel.h</code> (both located in the Bluetooth framework) define informal protocols that describe the available delegate methods. For example, as a client of an RFCOMM channel, in addition to the <code>rfcommChannelData:data:length:</code> method, you can implement any of the following delegate methods:</p><ul class="spaceabove"><li class="li"><p><code>rfcommChannelOpenComplete:status:</code></p></li><li class="li"><p><code>rfcommChannelClose:</code></p></li><li class="li"><p><code>rfcommChannelControlSignalChanged:</code></p></li><li class="li"><p><code>rfcommChannelFlowControlChanged:</code></p></li><li class="li"><p><code>rfcommChannelWriteComplete:refcon:status:</code></p></li><li class="li"><p><code>rfcommChannelQueueSpaceAvailable:</code></p></li></ul><a name="//apple_ref/doc/uid/TP30000997-CH216-BACFJHEB" title="Performing Device Inquiries"></a><h3>Performing Device Inquiries</h3><p>The IOBluetoothDeviceInquiry class is designed to allow Bluetooth-supported inquiries while avoiding the worst of the negative consequences associated with the device inquiry process. The class does this by limiting the amount of time spent on inquiries within a certain time period.</p><p>Your application, too, must bear some of the responsibility for the smooth operation of the device inquiry process. In particular:</p><ul class="spaceabove"><li class="li"><p>You should not try to circumvent the restriction of inquiries by calling <code>start</code> on the IOBluetoothDeviceInquiry object multiple times in quick succession. After you call <code>start</code>, the inquiry may take several seconds to begin and calling <code>start</code> many times in a row does not change this. Therefore, you should call <code>start</code> only once to begin an inquiry process, recognizing that the inquiry may not begin as soon as you expect it to. If you implement the <code>deviceInquiryStarted</code> delegate method, you will be able to tell when the inquiry process has begun to search for devices.</p></li><li class="li"><p>You can shorten the length of time the IOBluetoothDeviceInquiry object spends on the inquiry process, but you should still not initiate multiple inquiries within that length of time.</p></li><li class="li"><p>You must not initiate your own remote device-name requests while this object is performing a device inquiry or from the delegate methods you implement. If you do this, you could deadlock your process. </p><p>If you need to perform your own name requests on remote devices, do so <em>only</em> after you have stopped the IOBluetoothDeviceInquiry object. </p></li></ul><p>You can tell the IOBluetoothDeviceInquiry object to perform name requests on the remote devices it finds by calling the <code>setUpdateNewDeviceNames</code> method. You can then retrieve the information after your <code>deviceInquiryDeviceFound</code> delegate method is invoked.</p><p>By default, the IOBluetoothDeviceInquiry object performs the broadest possible inquiry, searching for devices of any major and minor device class that report any major service class. If you choose, you can use the <code>setSearchCriteria</code> method to restrict the inquiry process to consider only devices that report a specific service class or that belong to a specific major or minor device class. The <code>BluetoothAssignedNumbers.h</code> header file (located in the Bluetooth framework) lists the device and service class values you can use. It is not recommended that you do this, however, because not all devices identify themselves or their services in a standard manner. If you perform a restricted device inquiry, you can miss devices you might be interested in.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../BT_Bluetooth_On_MOSX/BT_Bluetooth_On_MOSX.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../BT_RevHistory/BT_RevHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-12-11<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/Bluetooth/BT_Develop_BT_Apps/BT_Develop_BT_Apps.html%3Fid%3DTP30000997-4.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/Bluetooth/BT_Develop_BT_Apps/BT_Develop_BT_Apps.html%3Fid%3DTP30000997-4.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/Bluetooth/BT_Develop_BT_Apps/BT_Develop_BT_Apps.html%3Fid%3DTP30000997-4.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>