<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Creating and Displaying a Control(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING309></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-308.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-310.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-297.html"><B>Chapter 5 - Control Manager</B></A> / <A HREF="Toolbox-308.html"><B>Using the Control Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING309-0></A>
<H2><A NAME=MARKER-9-119></A>Creating and Displaying a Control</H2>
 <A NAME=MARKER-2-102></A><A NAME=MARKER-2-299></A>To create a control in one of your application's windows, use the <CODE>GetNewControl</CODE> or <CODE>NewControl</CODE> function. You should usually use <CODE>GetNewControl</CODE>, which takes information about the control from a control resource (that is, a '<CODE>CNTL'</CODE> resource) in a resource file. Like window resources, control resources isolate descriptive information from your application code for ease of modification--especially for translation to other languages. The rest of this section describes how to use <CODE>GetNewControl</CODE>. Although it's generally not recommended, you can also use the <CODE>NewControl</CODE> function and pass it the necessary descriptive information in individual parameters instead of using a control resource. The <CODE>NewControl<DFN> function is described on <A HREF=Toolbox-324.html#MARKER-9-382>page 5-82</A></DFN></CODE>.<P>
 When you use <CODE>GetNewControl</CODE>, you pass it the resource ID of the control resource, and you pass it a pointer to a window.<CODE> </CODE>The function then creates a data structure (called a <B>control record</B>) of type <CODE>ControlRecord</CODE> from the information in the control resource, adds the control record to the control list for your window, and returns as its function result a handle to the control. (You use a control's handle when referring to the control in most other Control Manager routines; when you create scroll bars or pop-up menus for a window, you should store their handles in one of your application's own data structures for later reference.)<P>
 When you specify<DFN> in the control resource</DFN> that a control is initially visible<DFN> and you use the <CODE>GetNewControl</CODE></DFN> functio<DFN>n, the Control Manager uses the control's control definition function to draw the control inside its window. </DFN>The Control Manager draws the control immediately, without using your window's standard updating mechanism. If you specify that a control is invisible, you can use the <CODE>ShowControl</CODE> procedure when you want to draw the control. Again, the Control Manager draws the control without using your window's standard updating mechanism. (Of course, even when the Control Manager draws the control, it might be completely or partially obscured from the user by overlapping windows or other objects.)<P>
 When your application receives an update event for a window that contains controls, you use the <CODE>UpdateControls</CODE> procedure in your application's standard window- updating code to redraw all the controls in the update region of the window. <P>
<DL>
<DT><B>Note</B>
<DD>When you use the Dialog Manager to implement buttons, radio buttons, checkboxes, or pop-up menus in alert boxes and dialog boxes, Dialog Manager routines automatically use Control Manager routines to create and update these controls for you. If you implement any controls other than buttons, radio buttons, checkboxes, and pop-up menus in alert or dialog boxes--and whenever you implement <I>any</I> controls (scroll bars, for example) in your application's windows--you must explicitly use either the <CODE>GetNewControl</CODE> or the <CODE>NewControl</CODE> function to create the controls. You must always use the <CODE>UpdateControls</CODE> procedure to update controls you put in your own windows.<A NAME=MARKER-9-552></A><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 When you use the Window Manager procedure <CODE>DisposeWindow</CODE> or <CODE>CloseWindow</CODE> to remove a window, either procedure automatically removes all controls associated with the window and releases the memory they occupy.<P>
 When you no longer need a control in a window that you want to keep, you can use the <CODE>DisposeControl</CODE> procedure, described on <A HREF=Toolbox-357.html#MARKER-9-543>page 5-108</A>, to remove it from the screen, delete it from its window's control list, and release the control record and all other associated data structures from memory. You can use the <CODE>KillControls</CODE> procedure, described on <A HREF=Toolbox-358.html#MARKER-9-547>page 5-108</A>, to dispose of all of a window's controls at once.<P>
 The next section, <A HREF=#MARKER-9-125>"Creating a Button, Checkbox, or Radio Button,"</A> provides a general discussion of the control resource as well as a more detailed description of the use of the control resource to specify buttons, checkboxes, and radio buttons in your application's windows. The two following sections, <A HREF=#MARKER-9-152>"Creating Scroll Bars"</A> (beginning on <A HREF=#MARKER-9-152>page 5-19</A>) and <A HREF=#MARKER-9-164>"Creating a Pop-Up Menu"</A> (beginning on <A HREF=#MARKER-9-164>page 5-22</A>), describe those elements of the control resource that differ from the control resources for buttons, checkboxes, and radio buttons. <A HREF=#MARKER-9-188>"Updating a Control" beginning on page 5-25</A> then offers an example of how you can use the <CODE>UpdateControls</CODE> procedure within your window-updating code.<P>
<DL>
<DT><B>Note</B>
<DD>For the Control Manager to draw a control properly inside a window, the window must have its upper-left corner at local coordinates (0,0). If you use the QuickDraw procedure <CODE>SetOrigin</CODE> to change a window's local coordinate system, be sure to change it back--so that the upper-left corner is again at (0,0)--before drawing any of its controls. Because many Control Manager routines can (at least potentially) redraw a control, the safest policy after changing a window's local coordinate system is to change the coordinate system back before calling any Control Manager routine.<EM></EM><A NAME=MARKER-2-124></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING309-10></A>
<H3><A NAME=MARKER-9-125></A>Creating a Button, Checkbox, or Radio Button</H3>
 <A NAME=MARKER-2-455></A><A HREF=#MARKER-9-127>Figure 5-10</A> shows a simple example of a button placed in a window of type <CODE>noGrowDocProc</CODE>--which you normally use to create a modeless dialog box. <BR>Although you usually use the Dialog Manager to create dialog boxes and their <BR>buttons, sometimes you might use the Window Manager and the Control Manager instead. The chapter "Dialog Manager" in this book explains why the use of the <BR>Window and Control Managers is sometimes preferable for this purpose.<P>
<B>Figure 5-10  <A NAME=MARKER-9-127></A>A button in a simple window</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-S-03.jpg"><P>
 <A HREF=#MARKER-9-128>Listing 5-1</A> shows an application-defined routine, <CODE>MyCreatePlaySoundsWindow</CODE>, that uses the <CODE>GetNewControl</CODE> function to create the button shown in <A HREF=#MARKER-9-127>Figure 5-10</A>.<P>
<B>Listing 5-1  <A NAME=MARKER-9-128></A>Creating a button for a window</B><P>
<PRE>
FUNCTION MyCreatePlaySoundsWindow: OSErr;
VAR
   myWindow: WindowPtr;
BEGIN
   MyCreatePlaySoundsWindow := noErr;
   myWindow := GetNewWindow(rPlaySoundsModelessWindow, NIL, POINTER(-1));
   IF myWindow &lt;&gt; NIL THEN
   BEGIN
      {use the window's refCon to identify this window}
      SetWRefCon(myWindow, LongInt(kMyPlaySoundsWindow));
      SetPort(myWindow);
      gMyPlayButtonCtlHandle := GetNewControl(rPlayButton, myWindow);
      IF (gMyPlayButtonCtlHandle = NIL) THEN
         MyCreatePlaySoundsWindow := kControlErr;
   END
   ELSE
      MyCreatePlaySoundsWindow := kNoSoundWindow;
END;
</PRE>
 The <CODE>MyCreatePlaySoundsWindow</CODE> routine begins by using the Window Manager function <CODE>GetNewWindow</CODE> to create a window; a pointer to that window is passed to <CODE>GetNewControl</CODE>. Note that, as explained in the chapter "Dialog Manager" in this book, you could create a modeless dialog box more easily by using the Dialog Manager function <CODE>GetNewDialog</CODE> and specifying its controls in an item list (<CODE>'DITL'</CODE>) resource.<P>
 <A NAME=MARKER-2-549></A>For the resource ID of a control resource, the <CODE>MyCreatePlaySoundsWindow</CODE> routine defines an <CODE>rPlayButton</CODE> constant, which it passes to the <CODE>GetNewControl</CODE> function. <A HREF=#MARKER-9-132>Listing 5-2</A> shows how this control resource appears in Rez input format.<A NAME=MARKER-2-447></A><P>
<B>Listing 5-2  Rez input for a control resource<A NAME=MARKER-9-132></A></B><P>
<PRE>
resource 'CNTL' (rPlayButton, preload, purgeable) {
   {87, 187, 107, 247},    /*rectangle*/
   0,                      /*initial setting*/
   visible,                /*make control visible*/
   1,                      /*maximum setting*/
   0,                      /*minimum setting*/
   pushButProc,            /*control definition ID*/
   0,                      /*reference value*/
   &quot;Play&quot;                  /*title*/
};
</PRE>
 <A NAME=MARKER-2-446></A>You supply the following information in the control resource for a button, checkbox, radio button, or scroll bar:<P>
<UL>
<LI>a rectangle, specified by coordinates local to the window, that determines the control's size and location<A NAME=MARKER-2-466></A>
<LI>the initial setting for the control
<LI>a constant (either <CODE>visible</CODE> or <CODE>invisible</CODE>) that specifies whether the control should be drawn on the screen immediately<A NAME=MARKER-2-465></A>
<LI>the maximum setting for the control
<LI>the minimum setting for the control
<LI>the control definition ID<A NAME=MARKER-2-472></A>
<LI>a reference value, which your application may use for any purpose<A NAME=MARKER-2-474></A>
<LI>the title of the control; or, for scroll bars, an empty string<P>
</UL>
 As explained in <A HREF=#MARKER-9-164>"Creating a Pop-Up Menu" beginning on page 5-22</A>, the values you supply in a control resource for a pop-up menu differ from those you specify for other buttons, checkboxes, radio buttons, and scroll bars.<P>
 Buttons are drawn to fit the rectangle exactly. To allow for the tallest characters in <BR>the system font, there should be at least a 20-point difference between the top and bottom coordinates of the rectangle. <A HREF=#MARKER-9-132>Listing 5-2</A> uses a rectangle with coordinates (87,187,107,247) to describe the size and location of the control within the window. Remember that the Control Manager will not draw controls properly unless the upper-left corner of the window coincides with the coordinates (0,0).<A NAME=MARKER-2-139></A><P>
 In <A HREF=#MARKER-9-132>Listing 5-2</A>, the initial and minimum settings for the button are 0 and the maximum setting is 1. In control resources for buttons, checkboxes, and radio buttons, supply these values as the initial settings:<P>
<UL>
<LI>For buttons, which don't retain a setting, specify a value of 0 for the initial and minimum settings and 1 for the maximum setting.
<LI>For checkboxes and radio buttons, which retain an on-or-off setting, specify a value of 0 when you want to the control to be initially off. To turn a checkbox or radio button on, assign it an initial setting of 1. In response, the Control Manager places an X in a checkbox or a black dot in a radio button.<P>
</UL>
 Because the <CODE>visible</CODE> identifier is specified in this example, the control is drawn immediately in its window. If you use the <CODE>invisible</CODE> identifier, your control is not drawn until your application uses the <CODE>ShowControl</CODE> procedure. When you want to make a visible control invisible, you can use the <CODE>HideControl</CODE> procedure.<A NAME=MARKER-2-118></A><P>
 In <A HREF=#MARKER-9-132>Listing 5-2</A>, the maximum setting for the button is 1, which you, too, should specify in your control resources as the maximum setting for buttons, checkboxes, and radio buttons. In <A HREF=#MARKER-9-132>Listing 5-2</A>, the minimum setting for the button is 0, which you, too, should specify in your control resources as the minimum setting for buttons, checkboxes, and radio buttons.<P>
 In <A HREF=#MARKER-9-132>Listing 5-2</A>, the <CODE>pushButProc</CODE> constant is used to specify the control definition ID. Use the <CODE>checkBoxProc</CODE> constant to specify a checkbox and the <CODE>radioButProc</CODE> constant to specify a radio button.<A NAME=MARKER-2-473></A><P>
 <A HREF=#MARKER-9-132>Listing 5-2</A> specifies a reference value of 0. Your application can use this value for any purpose (except when you add the <CODE>popupUseAddResMenu</CODE> variation code to the <CODE>popupMenuProc</CODE> control definition function, as described in <A HREF=#MARKER-9-164>"Creating a Pop-Up Menu" beginning on page 5-22</A>). <P>
 Finally, the string <CODE>&quot;Play&quot;</CODE> is specified as the title of the control. Buttons, checkboxes, <BR>and radio buttons require a title that communicates their purpose to the user.<DFN> (The chapter "Dialog Manager" in this book offers extensive guidelines on appropriate titles for buttons.)</DFN><P>
 <A NAME=MARKER-2-469></A><A NAME=MARKER-2-145></A>When specifying a title, make sure it fits in the control's rectangle; otherwise, the <BR>Control Manager truncates the title. For example, it truncates the titles of checkboxes <BR>and radio buttons on the right in Roman scripts, and it centers and truncates both ends of button titles.<P>
 If you localize your application for use with worldwide versions of system software, the titles may become longer or shorter. Translated text is often 50 percent longer than U.S. English text. You may need to resize your controls to accommodate the translated text.<P>
 By default, the Control Manager displays control titles in the system font. To make it easier to localize your application for use with worldwide versions of system software, you should not change the font. Do not use a smaller font, such as 9-point Geneva; some script systems, such as KanjiTalk, require 12-point fonts. You can spare yourself future localization effort by leaving all control titles in the system font.<A NAME=MARKER-2-146></A><P>
 Follow book-title style when you capitalize control titles. In general, capitalize one-word titles and capitalize nouns, adjectives, verbs, and prepositions of four or more letters in multiple-word titles. You usually don't capitalize words such <I></I>as <I>in, an,</I> or <I>and.</I> For capitalization rules, see the <I>Apple Publications Style Guide,</I> available from APDA.<P>
 The Control Manager allows button, checkbox, and radio button titles of multiple lines. When specifying a multiple-line title, end each line with the ASCII character code $0D (carriage return). If the control is a button, each line is horizontally centered, and the <BR>font leading is inserted between lines. (The height of each line is equal to the distance from the ascent line to the descent line plus the leading of the font used. Be sure to make the total height of the rectangle greater than the number of lines times this height.) If <BR>the control is a checkbox or a radio button, the text is justified as appropriate for the user's current script system, and the checkbox or button is vertically centered within <BR>its rectangle.<A NAME=MARKER-2-147></A><A NAME=MARKER-2-470></A><P>
 <A NAME=MARKER-2-457></A><A HREF=#MARKER-9-150>Figure 5-11</A> shows the Play Sounds window with four additional controls: radio buttons titled Droplet, Quack, Simple Beep, and Wild Eep. <P>
<B>Figure 5-11  <A NAME=MARKER-9-150></A>Radio buttons in a simple window</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-S-04.jpg"><P>
 Only one of these radio buttons can be on at a time. <A HREF=#MARKER-9-151>Listing 5-3</A> initially sets the Droplet radio button to 1, turning it on by default. This listing also shows the control resources for the other buttons, all initially set to 0 to turn them off.<P>
 For a checkbox or a radio button, always allow at least a 16-point difference between the top and bottom coordinates of its rectangle to accommodate the tallest characters in the system font.<P>
<B>Listing 5-3  <A NAME=MARKER-9-151></A>Rez input for the control resources of radio buttons</B><P>
<PRE>
resource 'CNTL' (cDroplet, preload, purgeable) {
   {13, 23, 31, 142},/*rectangle of control*/
   1,                /*initial setting*/
   visible,          /*make control visible*/ 
   1,                /*maximum setting*/
   0,                /*minimum setting*/
   radioButProc,     /*control definition ID*/ 
   0,                /*reference value*/
   &quot;Droplet&quot;         /*control title*/
};
resource 'CNTL' (cQuack, preload, purgeable) {
   {31, 23, 49, 142},/*rectangle of control*/
   0,                /*initial setting*/
   visible, 1, 0, radioButProc, 0, &quot;Quack&quot;};

resource 'CNTL' (cSimpleBeep, preload, purgeable) {
   {49, 23, 67, 142},/*rectangle of control*/
   0,                /*initial setting*/
   visible, 1, 0, radioButProc, 0, &quot;Simple Beep&quot;};
   
resource 'CNTL' (cWildEep, preload, purgeable) {
   {67, 23, 85, 142},/*rectangle of control*/
   0,                /*initial setting*/
   visible, 1, 0, radioButProc, 0, &quot;Wild Eep&quot;}; 
</PRE>
<A NAME=HEADING309-52></A>
<H3><A NAME=MARKER-9-152></A>Creating Scroll Bars</H3>
 <A NAME=MARKER-2-422></A><A NAME=MARKER-2-643></A>When you define the control resource for a scroll bar, specify the <CODE>scrollBarProc</CODE> constant for the control definition ID. Typically, you make the scroll bar invisible and specify an initial value of 0, a minimum value of 0, and a maximum value of 0, and you supply an empty string for the title. <P>
 After you create a window, use the <CODE>GetNewControl</CODE> function to create the scroll bar you've defined in the control resource and to attach that scroll bar to the window. Use the <CODE>MoveControl</CODE>, <CODE>SizeControl</CODE>, <CODE>SetControlMaximum</CODE>, and <CODE>SetControlValue</CODE> procedures to adjust the location, size, and settings of the scroll bars, and then use the <CODE>ShowControl</CODE> procedure to display the scroll bars.<P>
 In your window-handling code, make the maximum setting the maximum area you want to allow the user to scroll. Most applications allow the user to drag the size box and click the zoom box to change the size of windows, and they allow the user to add information to and remove it from documents. To allow users to perform these actions, your application needs to calculate a changing maximum setting based upon the document's current size and its window's current size. For new documents that have no content to scroll to, assign an initial value of 0 as the maximum setting in the control resource; the control definition function automatically makes a scroll bar inactive when its minimum and maximum settings are identical. Thereafter, your window-handling routines should set and maintain the maximum setting, as described in <A HREF=Toolbox-311.html#MARKER-9-227>"Determining and Changing Control Settings" beginning on page 5-34</A>.<P>
 By convention, a scroll bar is 16 pixels wide, so there should be a 16-point difference between the left and right coordinates of a vertical scroll bar's rectangle and between the top and bottom coordinates of a horizontal scroll bar's rectangle. (If you don't provide a 16-pixel width, the Control Manager scales the scroll bar to fit the width you specify.) A standard scroll bar should be at least 48 pixels long, to allow room for the scroll arrows and scroll box.<A NAME=MARKER-2-492></A><P>
 The Control Manager draws lines that are 1 pixel wide for the rectangle enclosing the scroll bar. As shown in <A HREF=#MARKER-9-156>Figure 5-12</A>, the outside lines of a scroll bar should overlap the lines that the Window Manager draws for the window frame. <P>
<B>Figure 5-12  <A NAME=MARKER-9-156></A>How a scroll bar should overlap the window frame</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-L-16.jpg"><P>
 To determine the rectangle for a <I>vertical</I> scroll bar, perform the following calculations and use their results in your control resource. (Do not include the area of the title bar in your calculations.)<P>
<UL>
<LI>top coordinate = combined height of any items above the scroll bar - 1
<LI>left coordinate = width of window - 15
<LI>bottom coordinate = height of window - 14
<LI>right coordinate = width of window + 1<P>
</UL>
 To determine the rectangle for a <I>horizontal</I> scroll bar, perform the following calculations and use their results in your control resource.<P>
<UL>
<LI>top coordinate = height of window - 15
<LI>left coordinate = combined width of any items to the left of the scroll bar - 1
<LI>bottom coordinate = height of window + 1
<LI>right coordinate = width of window - 14<P>
</UL>
 The top coordinate of a vertical scroll bar is -1, and the left coordinate of a horizontal scroll bar is -1, unless your application uses part of the window's typical scroll bar areas (in particular, those areas opposite the size box) for displaying information or specifying additional controls. For example, your application may choose to display the current page number of a document in the lower-left corner of the window--that is, in a small area to the left of its window's horizontal scroll bar. See <I>Macintosh Human Interface Guidelines</I> for a discussion of appropriate uses of a window's scroll bar areas for additional items and controls.<A NAME=MARKER-2-157></A><A NAME=MARKER-2-426></A><P>
 Just as the maximum settings of a window's scroll bars change when the user resizes the document's window, so too do the scroll bars' coordinate locations change when the user resizes the window. Although you must specify an initial maximum setting and location in the control resource for a scroll bar, your application must be able to change them dynamically--typically, by storing handles to each scroll bar in a document record when you create a window, and then by using Control Manager routines to change control settings (as described in <A HREF=Toolbox-311.html#MARKER-9-227>"Determining and Changing Control Settings" beginning on page 5-34</A>) and sizes and locations of controls (as described in <A HREF=Toolbox-313.html#MARKER-9-301>"Moving and Resizing Scroll Bars" beginning on page 5-60</A>).<P>
 <A HREF=#MARKER-9-159>Listing 5-4</A> shows a window resource (described in the chapter "Window Manager" in this book) for creating a window, and two control resources for creating the window's vertical and horizontal scroll bars. The rectangle for the initial size and shape of the window is specified in global coordinates, of course, and the rectangles for the two scroll bars are specified in coordinates local to the window.<P>
<B>Listing 5-4  <A NAME=MARKER-9-159></A>Rez input for resources for a window and its scroll bars</B><P>
<PRE>
                           /*initial window*/
resource 'WIND' (rDocWindow, preload, purgeable) {
   {64, 60, 314, 460},     /*initial rectangle for window*/
   zoomDocProc, invisible, goAway, 0x0, &quot;untitled&quot;
};
                           /*initial vertical scroll bar*/
resource 'CNTL' (rVScroll, preload, purgeable) {
   {-1, 385, 236, 401},    /*initial rectangle for control*/
      /*initial setting, visibility, max, min, ID, refcon, title*/
   0, invisible, 0, 0, scrollBarProc, 0, &quot;&quot;
};
                           /*initial horizontal scroll bar*/
resource 'CNTL' (rHScroll, preload, purgeable) {
   {235, -1, 251, 386},    /*initial rectangle for control*/
      /*initial setting, visibility, max, min, ID, refcon, title*/
   0, invisible, 0, 0, scrollBarProc, 0, &quot;&quot;
};
</PRE>
 <A NAME=MARKER-21-450></A><A HREF=#MARKER-9-161>Listing 5-5</A> shows an application-defined procedure called <CODE>DoNew</CODE> that uses the <CODE>GetNewWindow</CODE> and <CODE>GetNewControl</CODE> functions to create a window and its scroll bars from the resources in <A HREF=#MARKER-9-159>Listing 5-4</A>.<P>
<B>Listing 5-5  <A NAME=MARKER-9-161></A>Creating a document window with scroll bars</B><P>
<PRE>
PROCEDURE DoNew (newDocument: Boolean; VAR window: WindowPtr);
VAR
   good:                Boolean;
   windStorage:         Ptr;
   myData:              MyDocRecHnd;
BEGIN
   {use GetNewWindow or GetNewCWindow to create the window here}
   myData := MyDocRecHnd(NewHandle(SIZEOF(MyDocRec))); {create document rec}
   {test for errors along the way; if there are none, create the scroll }
   { bars and save their handles in myData}
   IF good THEN
   BEGIN    {create the vertical scroll bar and save its handle}
      myData^^.vScrollBar := GetNewControl(rVScroll, window);
      {create the horizontal scroll bar and save its handle}
      myData^^.hScrollBar := GetNewControl(rHScroll, window);
      good := (vScrollBar &lt;&gt; NIL) AND (hScrollBar &lt;&gt; NIL);
   END;
   IF good THEN
   BEGIN    {adjust size, location, settings, and visibility of scroll bars}
      MyAdjustScrollBars(window, FALSE);
      {perform other initialization here}
      IF NOT newDocument THEN
         ShowWindow(window);
   END;
   {clean up here}
END; {DoNew}
</PRE>
 The <CODE>DoNew</CODE> routine uses Window Manager routines to create a window; its window resource specifies that the window is invisible. The window resource specifies an initial size and location for the window, but because the window is invisible, this window is not drawn.<P>
 Then <CODE>DoNew</CODE> creates a document record and stores a handle to it in the <CODE>myData</CODE> variable. The SurfWriter sample application uses this document record to store the data that the user creates in this window--as well as handles to the scroll bars that it creates. The SurfWriter sample application later uses these control handles to handle scrolling through the document and to move and resize the scroll bars when the user resizes the window. (See the chapter "Window Manager" in this book for more information about creating such a document record.)<P>
 To create scroll bars, <CODE>DoNew</CODE> uses <CODE>GetNewControl</CODE> twice--once for the vertical scroll bar and once for the horizontal scroll bar. The <CODE>GetNewControl</CODE> function returns a control handle; <CODE>DoNew</CODE> stores these handles in the <CODE>vScrollBar</CODE> and <CODE>hScrollBar</CODE> fields of its document record for later reference.<A NAME=MARKER-2-451></A><P>
 Because the window and the scroll bars are invisible, nothing is drawn onscreen <BR>yet for the user. Before drawing the window and its scroll bars, <CODE>DoNew</CODE> calls <BR>another application-defined procedure, <CODE>MyAdjustScrollBars</CODE>. In turn, <CODE>MyAdjustScrollBars</CODE> calls other application-defined routines that move and <BR>resize the scroll bars to fit the window and then calculate the maximum settings of <BR>these controls. (<A HREF=Toolbox-311.html#MARKER-9-235>Listing 5-14</A> on <A HREF=Toolbox-311.html#MARKER-9-235>page 5-36</A> shows the <CODE>MyAdjustScrollBars</CODE> procedure.)<P>
 After creating the window and its scroll bars, and then sizing and positioning them appropriately, <CODE>DoNew</CODE> uses the Window Manager procedure <CODE>ShowWindow</CODE> to display the window with its scroll bars.<A NAME=MARKER-2-459></A><P>
<A NAME=HEADING309-83></A>
<H3><A NAME=MARKER-9-164></A>Creating a Pop-Up Menu</H3>
 <A NAME=MARKER-2-453></A><A NAME=MARKER-9-336></A><A NAME=MARKER-2-460></A>The values you specify in a control resource for a pop-up menu differ from those you specify for other controls. The control resource for a pop-up menu contains the <BR>following information:<P>
<UL>
<LI>a rectangle, specified by coordinates local to the window, that determines the size and location of the pop-up title and pop-up box<A NAME=MARKER-2-378></A>
<LI><A NAME=MARKER-2-10></A>the alignment of the pop-up title with the pop-up box
<LI>a constant (either <CODE>visible</CODE> or <CODE>invisible</CODE>) that specifies whether the control should be drawn on the screen immediately<A NAME=MARKER-2-170></A>
<LI>the width of the pop-up title
<LI>the resource ID of the <CODE>'MENU'</CODE> resource describing the pop-up menu items
<LI>the control definition ID<A NAME=MARKER-2-444></A>
<LI>a reference value, which your application may use for any purpose<A NAME=MARKER-2-448></A>
<LI>the title of the control<A NAME=MARKER-9-640></A><P>
</UL>
 <A HREF=#MARKER-9-174>Figure 5-13</A> on the next page shows a pop-up menu; <A HREF=#MARKER-9-175>Listing 5-6</A> shows the control resource that creates this pop-up menu. (The chapter "Menu Manager" in this book recommends typical uses of pop-up menus and describes the relation between pop-up menus and menus you display in the menu bar.)<P>
<B>Figure 5-13  <A NAME=MARKER-9-174></A>A pop-up menu</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-SL-01.jpg"><P>
<B>Listing 5-6  <A NAME=MARKER-9-175></A>Rez input for the control resource of a pop-up menu</B><P>
<PRE>
resource 'CNTL' (kPopUpCNTL, preload, purgeable) {
   {90, 18, 109, 198},  /*rectangle of control*/
   popupTitleLeftJust,  /*title position*/
   visible,             /*make control visible*/ 
   50,                  /*pixel width of title*/
   kPopUpMenu,          /*'MENU' resource ID*/
   popupMenuCDEFProc,   /*control definition ID*/ 
   0,                   /*reference value*/
   &quot;Speed:&quot;             /*control title*/
};
</PRE>
 <A HREF=#MARKER-9-175>Listing 5-6</A> specifies a rectangle with the coordinates (90,18,109,198). <A HREF=#MARKER-9-178>Figure 5-14</A> illustrates the rectangle for this pop-up menu.<A NAME=MARKER-2-228></A><A NAME=MARKER-2-177></A><P>
<B>Figure 5-14  <A NAME=MARKER-9-178></A>Dimensions of a sample pop-up menu</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-SL-02.jpg"><P>
 <A HREF=#MARKER-9-175>Listing 5-6</A> uses the <CODE>popupTitleLeftJust</CODE> constant to specify the position of the control title. Specify any combination of the following constants (or their values) to inform the Control Manager where and how to draw the pop-up menu's title:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Setting<TH>Constant<TH>Description<TR>
<TD>$0000<TD><CODE>popupTitleLeftJust</CODE><TD><A NAME=MARKER-9-570></A>Place title left of the pop-up box<TR>
<TD>$0001<TD><CODE>popupTitleCenterJust</CODE><TD><A NAME=MARKER-2-7></A>Center title over the pop-up box<TR>
<TD>$00FF<TD><CODE>popupTitleRightJust</CODE><TD><A NAME=MARKER-2-8></A>Place title right of the pop-up box<TR>
<TD>$0100<TD><CODE>popupTitleBold</CODE><TD><A NAME=MARKER-2-283></A>Use boldface font style<TR>
<TD>$0200<TD><CODE>popupTitleItalic</CODE><TD><A NAME=MARKER-2-120></A>Use italic font style</TABLE>
 
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Setting<TH>Constant<TH>Description<TR>
<TD>$0400<TD><CODE>popupTitleUnderline</CODE><TD><A NAME=MARKER-2-124></A>Use underline font style<TR>
<TD>$0800<TD><CODE>popupTitleOutline</CODE><TD><A NAME=MARKER-2-406></A>Use outline font style<TR>
<TD>$1000<TD><CODE>popupTitleShadow</CODE><TD><A NAME=MARKER-2-286></A>Use shadow font style<TR>
<TD>$2000<TD><CODE>popupTitleCondense</CODE><TD><A NAME=MARKER-2-30></A>Use condensed characters<TR>
<TD>$4000<TD><CODE>popupTitleExtend</CODE><TD><A NAME=MARKER-9-102></A>Use extended characters<TR>
<TD>$8000<TD><CODE>popupTitleNoStyle</CODE><TD><A NAME=MARKER-2-33></A>Use monostyle font</TABLE>
<P>
 If <CODE>GetNewControl</CODE> completes successfully, it sets the value of the <CODE>contrlValue</CODE> field <BR>of the control record by assigning to that field the item number of the first menu item. When the user chooses a different menu item, the Control Manager changes the <CODE>contrlValue</CODE> field to that item number.<P>
 When you create pop-up menus, your application should store the handles for them; for example, in a record pointed to by the <CODE>refCon</CODE> field of a window record or a dialog record. (See the chapters "Window Manager" and "Dialog Manager" in this book for more information about the window record and the dialog record.) Storing these handles, as shown in the following code fragment, allows your application to respond later to users' choices in pop-up menus:<P>
<PRE>
myData: MyDocRecHnd;
window: WindowPtr;

myData^^.popUpControlHandle := GetNewControl(kPopUpCNTL, window);
</PRE>
 <A HREF=#MARKER-9-175>Listing 5-6</A> specifies 50 pixels (in place of a maximum setting) as the width of the control title. After it creates the control, the Control Manager sets the maximum value in the pop-up menu's control record to the number of items in the pop-up menu. <A HREF=#MARKER-9-178>Figure 5-14</A> illustrates this title width for the pop-up menu.<P>
 <A HREF=#MARKER-9-175>Listing 5-6</A> uses a <CODE>kPopUpMenu</CODE> constant to specify the resource ID of a <CODE>'MENU'</CODE> resource (in place of a minimum setting for the control). (See the chapter "Menu Manager" in this book for a description of the <CODE>'MENU'</CODE> resource type.) After it creates the control, the Control Manager assigns 1 as the minimum setting in the pop-up menu's control record. <P>
<DL>
<DT><B>IMPORTANT</B>
<DD>When using the ResEdit application, version 2.1.1, you must use the same resource ID when specifying the menu resource and the control resource that together define a pop-up menu.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-31></A>You can also specify a different control definition ID by adding any or all of the following constants (or the variation codes they represent) to the <CODE>popupMenuProc</CODE> constant:<P>
<PRE>
CONST popupFixedWidth      = $0001; {use fixed-width control}
      popupUseAddResMenu   = $0004; {use resource for menu items}
      popupUseWFont        = $0008; {use window font}
</PRE>
 The reference value that you specify in the control resource (and stored by the Control Manager in the <CODE>contrlRfCon</CODE> field of the control record) is available for your application's use. However, if you specify <CODE>popupUseAddResMenu</CODE> as a variation code, the Control Manager coerces the value in the <CODE>contrlRfCon</CODE> field of the control record <BR>to the type <CODE>ResType</CODE> and then uses <CODE>AppendResMenu</CODE> to add items of that type to the pop-up menu. For example, if you specify a reference value of <CODE>LongInt('FONT')</CODE> as the reference value, the control definition function appends a list of the fonts installed <BR>in the system to the menu associated with the pop-up menu. After the control has been created, your application can use the control record's <CODE>contrlRfCon</CODE> field for whatever use it requires. You can determine which menu item is currently chosen by calling <CODE>GetControlValue</CODE>.<A NAME=MARKER-2-560></A><A NAME=MARKER-2-181></A><P>
 Whenever the pop-up menu is redrawn, its control definition function calls the Menu Manager procedure <CODE>CalcMenuSize</CODE>. This procedure recalculates the size of the <BR>menu associated with the control (to allow for the addition or deletion of items in the menu). The pop-up control definition function may also update the width of the pop-<BR>up menu to the sum of the width of the pop-up title, the width of the longest item in the menu, the width of the downward-pointing arrow, and a small amount of white space. As previously described, your application can override this behavior by adding the variation code <CODE>popupFixedWidth</CODE> to the pop-up control definition ID.<A NAME=MARKER-9-309></A><P>
 You should not use the Menu Manager function <CODE>GetMenuHandle</CODE> to obtain a handle to <BR>a menu associated with a pop-up control. If necessary, you can obtain the menu handle (and the menu ID) of a pop-up menu by dereferencing the <CODE>contrlData</CODE> field of the pop-up menu's control record. The <CODE>contrlData</CODE> field of a control record is a handle to a block of private information. For pop-up menu controls, this field is a handle to a pop-up private data record, which is described on <A HREF=Toolbox-319.html#MARKER-9-353>page 5-77</A>.<A NAME=MARKER-2-183></A><A NAME=MARKER-2-461></A><A NAME=MARKER-2-454></A><A NAME=MARKER-2-346></A><A NAME=MARKER-2-445></A><P>
<A NAME=HEADING309-113></A>
<H3><A NAME=MARKER-9-188></A>Updating a Control</H3>
 <A NAME=MARKER-2-189></A>Your program should use the <CODE>UpdateControls</CODE> procedure upon receiving an update event for a window that contains controls such as scroll bars. (Window Manager routines such as <CODE>SelectWindow</CODE>, <CODE>ShowWindow</CODE>, and <CODE>BringToFront</CODE> do not automatically <BR>call <CODE>UpdateControls</CODE> to display the window's controls. Instead, they merely add <BR>the appropriate regions to the window's update region. This in turn generates an <BR>update event.)<P>
<DL>
<DT><B>Note</B>
<DD>The Dialog Manager automatically updates the controls you use in alert boxes and dialog boxes.<A NAME=MARKER-2-341></A><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 When your application receives an update event for a window that contains controls, use the <CODE>UpdateControls</CODE> procedure in your window-updating code to redraw all the controls in the update region of the window. Call <CODE>UpdateControls</CODE> after using the Window Manager procedure <CODE>BeginUpdate</CODE> and before using the Window Manager procedure <CODE>EndUpdate</CODE>. <P>
 When you call <CODE>UpdateControls</CODE>, you pass it parameters specifying the window to <BR>be updated and the window area that needs updating. Use the<DFN> visible</DFN> region of <BR>the <DFN>window's graphics port</DFN>, as referenced in the port's <CODE>visRgn</CODE> field, to specify the window's update region.<P>
 <A HREF=#MARKER-9-191>Listing 5-7</A> shows an application-defined routine, <CODE>DoUpdate</CODE>, that responds to an update event. The <CODE>DoUpdate</CODE> routine calls the Window Manager procedure <CODE>BeginUpdate</CODE>. To redraw this portion of the window, <CODE>DoUpdate</CODE> then calls another of its own procedures, <CODE>MyDrawWindow</CODE>. <P>
<B>Listing 5-7  <A NAME=MARKER-9-191></A>Responding to an update event for a window</B><P>
<PRE>
PROCEDURE DoUpdate (window: WindowPtr);
VAR
   windowType: Integer;
BEGIN
   windowType := MyGetWindowType(window);
   CASE windowType OF
   kMyDocWindow:
      BEGIN
         BeginUpdate(window);
         MyDrawWindow(window);
         EndUpdate(window);
      END;  {of updating document windows}
   {handle other window types----modeless dialogs, etc.----here}
   END;  {of windowType CASE}
END;  {of DoUpdate}
</PRE>
 <A NAME=MARKER-2-192></A><A HREF=#MARKER-9-193>Listing 5-8</A> illustrates how the SurfWriter sample application updates window controls and other window contents by using its own application-defined routine, <CODE>MyDrawWindow</CODE>. To draw only those controls in the window's update region, <CODE>MyDrawWindow</CODE> calls <CODE>UpdateControls</CODE>. To draw the size box in the lower-right corner of the window, <CODE>MyDrawWindow</CODE> calls the Window Manager procedure <CODE>DrawGrowIcon</CODE>. Finally, <CODE>MyDrawWindow</CODE> redraws the appropriate information contained in the user's document. Because the SurfWriter application uses TextEdit for all text editing in the window contents, <A HREF=#MARKER-9-193>Listing 5-8</A> calls the TextEdit procedure <CODE>TEUpdate</CODE>. (TextEdit is described in detail in <I>Inside Macintosh: Text.</I>)<P>
<B>Listing 5-8  <A NAME=MARKER-9-193></A>Redrawing the controls in the update region</B><P>
<PRE>
PROCEDURE MyDrawWindow (window: WindowPtr);
VAR
   myData: MyDocRecHnd;
BEGIN                {draw the contents of the window}
   SetPort(window);
   myData := MyDocRecHnd(GetWRefCon(window));
   HLock(Handle(myData));
   WITH window^ DO
   BEGIN
      EraseRect(portRect);
      UpdateControls(window, visRgn);
      DrawGrowIcon(window);
      TEUpdate(portRect, myData^^.editRec);  {redraw text}
   END;
   HUnLock(Handle(myData));
END;  {MyDrawWindow}
</PRE>
 For more information about updating window contents, see the chapter "Window Manager" in this book.<A NAME=MARKER-2-194></A><A NAME=MARKER-2-93></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-308.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-310.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
