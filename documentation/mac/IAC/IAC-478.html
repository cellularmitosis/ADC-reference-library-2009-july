<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Writing a Status Routine for High-Level Functions(IM:IC)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING478></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="IAC-477.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-479.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="IAC-2.html"><B>Interapplication Communication</B></A> / <BR><DD><A HREF="IAC-469.html"><B>Chapter 12 - Data Access Manager</B></A> / <A HREF="IAC-474.html"><B>Using the Data Access Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING478-0></A>
<H2><A NAME=MARKER-9-129></A><A NAME=MARKER-21-130></A>Writing a Status Routine for High-Level Functions</H2>
 <A NAME=MARKER-2-131></A><A NAME=MARKER-2-132></A><A NAME=MARKER-2-133></A><A NAME=MARKER-2-134></A><A NAME=MARKER-2-135></A>Both of the two main high-level functions, <CODE>DBStartQuery</CODE> and <CODE>DBGetQueryResults</CODE>, call low-level functions repeatedly. After each time they call a low-level function, these high-level functions call a routine that you provide, called a <I>status routine.</I> Your status routine can check the result code returned by the low-level function and can cancel execution of the high-level function before it calls the next low-level function. Your status routine can also update your application's windows after the <CODE>DBStartQuery</CODE> function has displayed a dialog box.<P>
 You provide a pointer to your status routine in the <CODE>statusProc</CODE> parameter to the <CODE>DBStartQuery</CODE> and <CODE>DBGetQueryResults</CODE> functions. <P>
 Here is a function declaration for a status routine:<A NAME=MARKER-2-136></A><P>
<PRE>
FUNCTION MyStatusFunc (message: Integer; result: OSErr; 
                       dataLen: Integer; dataPlaces: Integer; 
                       dataFlags: Integer; dataType: DBType; 
                       dataPtr: Ptr): Boolean;
</PRE>
 Your status routine should return a value of <CODE>TRUE</CODE> if you want to continue execution of the <CODE>DBStartQuery</CODE> or <CODE>DBGetQueryResults</CODE> function, or a value of <CODE>FALSE</CODE> if you want to cancel execution of the function. In the latter case, the high-level function returns the <CODE>userCanceledErr</CODE> result code.<P>
<DL>
<DT><B>Note</B>
<DD>If you call the <CODE>DBStartQuery</CODE> or <CODE>DBGetQueryResults</CODE> function asynchronously, you cannot depend on the A5 register containing a pointer to your application's global variables when the Data Access Manager calls your status routine.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A NAME=MARKER-2-137></A><A NAME=MARKER-2-138></A>The <CODE>message</CODE> parameter tells your status routine the current status of the high-level function that called it. The possible values for the <CODE>message</CODE> parameter depend on which function called your routine. <P>
 The value of the <CODE>result</CODE> parameter depends on the value of the <CODE>message</CODE> parameter, as summarized in the following list: 
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Message<TH>Result<TR>
<TD>kDBUpdateWind<TD>0<TR>
<TD>kDBAboutToInit<TD>0<TR>
<TD>kDBInitComplete<TD>Result of <CODE>DBInit</CODE><TR>
<TD>kDBSendComplete<TD>Result of <CODE>DBSend</CODE><TR>
<TD>kDBExecComplete<TD>Result of <CODE>DBExec</CODE><TR>
<TD>kDBStartQueryComplete<TD>Result of <CODE>DBStartQuery</CODE><TR>
<TD>kDBGetItemComplete<TD>Result of <CODE>DBGetItem</CODE><TR>
<TD>kDBGetQueryResultsComplete<TD>Result of <CODE>DBGetQueryResults</CODE></TABLE>
<P>
 The <CODE>dataLen</CODE>, <CODE>dataPlaces</CODE>, <CODE>dataFlags</CODE>, <CODE>dataType</CODE>, and <CODE>dataPtr</CODE> parameters are returned only by the <CODE>DBGetQueryResults</CODE> function, and only when the <CODE>message</CODE> parameter equals <CODE>kDBGetItemComplete</CODE>. When the <CODE>DBGetQueryResults</CODE> function calls your status routine with this message, the <CODE>dataLen</CODE>, <CODE>dataPlaces</CODE>, and <CODE>dataType</CODE> parameters contain the length, decimal places, and type of the data item retrieved, respectively, and the <CODE>dataPtr</CODE> parameter contains a pointer to the data item. <P>
 The least significant bit of the <CODE>dataFlags</CODE> parameter is set to <CODE>1</CODE> if the data item is in the last column of the row. The third bit of the <CODE>dataFlags</CODE> parameter is set to <CODE>1</CODE> if the data item is <CODE>NULL</CODE>. You can use this information, for example, to check whether the data meets some criteria of interest to the user, or to display each data item as the <CODE>DBGetItem</CODE> function receives it. You can use the constants <CODE>kDBLastColFlag</CODE> and <CODE>kDBNullFlag</CODE> to test for these flag bits.<P>
 The <CODE>DBGetQueryResults</CODE> function returns a results record, which contains a handle to the retrieved data. The address in the <CODE>dataPtr</CODE> parameter points inside the array specified by this handle. Because the <CODE>dataPtr</CODE> parameter is not a pointer to a block of memory allocated by the Memory Manager, but just a pointer to a location inside such a block, you cannot use this pointer in any Memory Manager routines (such as the <CODE>GetPtrSize</CODE> function). Note also that you cannot rely on this pointer remaining valid after you return control to the <CODE>DBGetQueryResults</CODE> function. <P>
 The <CODE>DBStartQuery</CODE> function can send to your status routine the following constants in the <CODE>message</CODE> parameter:<P>
<PRE>
CONST {DBStartQuery status messages}
      kDBUpdateWind           = 0;     {update windows}
      kDBAboutToInit          = 1;     {about to call DBInit}
      kDBInitComplete         = 2;     {DBInit has completed}
      kDBSendComplete         = 3;     {DBSend has completed}
      kDBExecComplete         = 4;     {DBExec has completed}
      kDBStartQueryComplete   = 5;     {DBStartQuery is about to }
                                       { complete} 
</PRE>
 The <CODE>DBGetQueryResults</CODE> function can send to your status routine the following constants in the <CODE>message</CODE> parameter:<P>
<PRE>
CONST {DBGetQueryResults status messages}
      kDBGetItemComplete         = 6;  {DBGetItem has completed}
      kDBGetQueryResultsComplete = 7;  {DBGetQueryResults has }
                                       { completed} 
</PRE>
 <A HREF=IAC-511.html#MARKER-9-359>Listing 12-3</A> shows a status routine for the <CODE>DBStartQuery</CODE> function. This routine updates the application's windows in response to the <CODE>kDBUpdateWind</CODE> message, displays a dialog box giving the user the option of canceling before the data access is initiated, and checks the results of calls to the <CODE>DBInit</CODE>, <CODE>DBSend</CODE>, and <CODE>DBExec</CODE> functions. If one of these functions returns an error, the status routine displays a dialog box describing the error.<P>
<B>Listing 12-3  <A NAME=MARKER-9-359></A><A NAME=MARKER-21-140></A>A sample status routine</B><P>
<PRE>
FUNCTION MyStartStatus(message: Integer; result: OSErr;
                        dataLen: Integer; dataPlaces: Integer;
                        dataFlags: Integer; dataType: DBType; 
                        dataPtr: Ptr): Boolean;
VAR
   myString:   Str255;
   continue:   Boolean;
BEGIN
   continue := TRUE; {assume user wants to continue with query}
   CASE message OF
   kDBUpdateWind:    {a qdef function has just been called; }
      BEGIN          { handle activate and update events}
         MyDoActivate;  {find and handle activate events}
         MyDoUpdate;    {find and handle update events}
      END;  {kDBUpdateWind}
   kDBAboutToInit:   {about to initiate a session}
      BEGIN {MyDisplayDialog displays a dialog box. The value }
            { returned in the continue variable indicates }
            { whether DBStartQuery should continue.}
         myString := 'The Data Access Manager is about to open a 
                     session.  This could take a while.  Do you
                     want to continue?';
         MyDisplayDialog(@myString, continue);
      END;  {kDBAboutToInit}
   kDBInitComplete:  {the DBInit function has completed execution}
      BEGIN
         IF result &lt;&gt; noErr THEN {if there's an error, }
         BEGIN                   { let the user know what it is}
            CASE result OF
            rcDBError:
            BEGIN
               myString := 'The Data Access Manager was unable to
                           open the session.  Please check your
                           connections and try again later.';
               MyDisplayString(@myString);
            END;  {rcDBError}
            rcDBBadDDev:
            BEGIN
               myString := 'The Data Access Manager cannot find
                           the database extension file it needs to
                           open a session.  Check with your system
                           administrator for a copy of the file.';
               MyDisplayString(@myString);
            END;  {rcDBBadDDev}
            OTHERWISE
            BEGIN
               myString := 'The Data Access Manager was unable to
                           open the session.  The error code 
                           returned was';
               MyDisplayError(@myString, result);
            END; {of otherwise}
         END;  {of CASE result}
         END; {of result &lt;&gt; noErr}
      END; {kDBInitComplete}
   kDBSendComplete:  {the DBSend function has completed execution} 
      BEGIN
         {if there's an error, let the user know what it is}
         IF result &lt;&gt; noErr THEN
         BEGIN
            IF result = rcDBError THEN
            BEGIN
               myString := 'An error occurred while the Data 
                           Access Manager was trying to send the 
                           query. Please try again later.';
               MyDisplayString(@myString);
            END
            ELSE
            BEGIN
               myString := 'An error occurred while the Data 
                           Access Manager was trying to send the 
                           query. The error code returned was';
               MyDisplayError(@myString, result);
            END;
         END;  {of result &lt;&gt; noErr}
      END;  {kDBSendComplete}
   kDBExecComplete:  {the DBExec function has completed execution}
      BEGIN
         IF result &lt;&gt; noErr THEN {if there's an error, }
         BEGIN                   { let the user know what it is}
            IF result = rcDBError THEN
            BEGIN
               myString := 'The Data Access Manager was unable to
                        execute the query. There may be a problem
                        with the query document or the database.
                        Check with your system administrator.';
               MyDisplayString(@myString);
            END
            ELSE
            BEGIN
               myString := 'An error occurred while the Data
                        Access Manager was trying to execute the
                        query.  The error code returned was';
               MyDisplayError(@myString, result);
            END;
         END;  {of result &lt;&gt; noErr}
      END;  {kDBExecComplete}
   kDBStartQueryComplete:{the DBStartQuery function is about }
      BEGIN             { to return control to your application}
         {clean up memory and any dialog boxes left on the screen}
         MyCleanUpWindows;
      END;  {kDBStartQueryComplete}
   END; {CASE message}
   MyStartStatus := continue;
END;
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="IAC-477.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-479.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="IAC-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
