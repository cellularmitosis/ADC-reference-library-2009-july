<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Secure Coding Guide: Avoiding Race Conditions and Insecure File Operations</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Avoiding Race Conditions and Insecure File Operations"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002585" title="Avoiding Race Conditions and Insecure File Operations"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000434" target="_top">Security</a> &gt; <a href="../index.html" target="_top">Secure Coding Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ValidatingInput.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="AccessControl.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40002585-SW1" title="Avoiding Race Conditions and Insecure File Operations"></a><hr /><H1>Avoiding Race Conditions and Insecure File Operations</H1><p>This article describes the various sorts of <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_143"></a>race conditions and insecure file operations and discusses how to avoid them. Code samples illustrate safe practices.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW8">Race Conditions Explained</a>
				
			<br/>
			
        
			
			
				<a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW7">Interprocess Communication</a>
				
			<br/>
			
        
			
			
				<a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW9">Insecure File Operations</a>
				
			<br/>
			
        
			
			
				<a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW10">Secure File Operations</a>
				
			<br/>
			
        
			
			
				<a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW2">Time Of Check–Time Of Use</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002585-SW8" title="Race Conditions Explained"></a><h2>Race Conditions Explained</h2><p>Suppose you wrote a program designed to automatically count the number of people entering a sports stadium for a game. The turnstiles are wired and send a signal to the computer each time someone walks through. You have a separate process running to monitor the signal from each turnstile. Each time a process receives a signal, it reads the global variable <code>Gate</code>, increments it by one, and writes it back. Thus, multiple processes are keeping a single running total. Now suppose two people enter different gates at exactly the same time. The sequence of events might then be as follows: </p><ol class="ol"><li class="li"><p>Process A receives a signal from gate A.</p></li><li class="li"><p>Process B receives a signal from gate B.</p></li><li class="li"><p>Process A reads <code>Gate == 1000</code>.</p></li><li class="li"><p>Process B reads <code>Gate == 1000</code>.</p></li><li class="li"><p>Process A increments <code>Gate</code> by 1 so that <code>Gate == 1001</code>.</p></li><li class="li"><p>Process B increments <code>Gate</code> by 1 so that <code>Gate == 1001</code>.</p></li><li class="li"><p>Process A writes <code>Gate = 1001</code>.</p></li><li class="li"><p>Process B writes <code>Gate = 1001</code>.</p></li></ol><p>Because process B read <code>Gate</code> before process A had time to increment it and write it back, both process A and process B have read the same value for <code>Gate</code>. After process A increments <code>Gate</code> and writes it back, process B overwrites the value of <code>Gate</code> with the same value written by process A. Because of the race condition, one of the two people entering the stadium was not counted. Since there might be long lines at each turnstile, this condition might occur many times before a big game, and a dishonest ticket clerk who knew about this undercount could pocket some of the receipts with no fear of being caught.</p><p>From a software security point of view, there are a couple of ways to exploit race conditions. If a program is writing temporary files, or temporarily relaxing permissions on files or folders in order to perform a privileged operation, an attacker might be able to create a race condition by careful timing of his attack. If the program checks the status of a file before writing to it, for example, the attacker might be able to take advantage of the time gap between when the program checks the file and when it writes to it to mount an attack. This is referred to as a time of check–time of use problem.</p><p>Other race conditions that can be exploited, like the example above, involve the use of shared data or other interprocess communication methods. If an attacker can interfere with the data after it is written and before it is read, he can disrupt the operation of the program, alter data, or do other mischief. The use of non-thread-safe calls in multithreaded programs can result in data corruption. If an attacker can manipulate the program to cause two such threads to interfere with each other, it may be possible to mount a denial-of-service attack. In some cases, by using such a race condition to overwrite a buffer in the heap with data from a routine that uses more data than the routine that allocated the buffer, an attacker can create a buffer overflow. As discussed in <span class="content_text"><a href="BufferOverflows.html#//apple_ref/doc/uid/TP40002577-SW1">“Avoiding Buffer Overflows,”</a></span> buffer overflows can be exploited to cause execution of malicious code. Darwin-level code (that is, scripts and code written with direct calls to BSD) that includes signal handlers is especially vulnerable to this sort of attack.</p><a name="//apple_ref/doc/uid/TP40002585-SW7" title="Interprocess Communication"></a><h2>Interprocess Communication</h2><p>Any time the sequence in which two operations are completed affects the result, there is the potential for a race condition. For example, if two processes (in a single program or different programs) share the same global variable, then there is the potential for one process to interfere with the other or for an attacker to alter the variable after one process sets it but before the other reads it. See <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_144"></a><span class="content_text"><a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW8">“Race Conditions Explained”</a></span> at the beginning of this article for an example of a race condition of this type. The solution to race conditions of this type is to use some locking mechanism to prevent one process from changing a variable until another is finished with it. There are problems and hazards associated with such mechanisms, however, and they must be implemented carefully. For a full discussion, see Wheeler, <em>Secure Programming for Linux and Unix HOWTO</em>, at <span class="content_text"><a href="http://www.dwheeler.com/secure-programs/" target="_blank">http://www.dwheeler.com/secure-programs/</a></span>.</p><p><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_145"></a>Signal handlers are another common source of race conditions. Signals from the operating system to a process or between two processes are used for such purposes as terminating a process or causing it to reinitialize. If you include signal handlers in your program, they should not make any system calls and should terminate as quickly as possible. Although there are certain system calls that are safe from within signal handlers, writing a safe signal handler that does so is tricky. The best thing to do is to set a flag that your program checks periodically, and do no other work within the signal handler. This is because the signal handler can be interrupted by a new signal before it finishes processing the first signal, leaving the system in an unpredictable state or, worse, providing a vulnerability for an attacker to exploit. For example, if the signal handler writes user-supplied data to a system log, an attacker can use a signal handler race condition to put the attacker's own code into the heap.</p><p>In a vulnerability reported in 1997 for a number of implementations of the FTP protocol, a user could cause a race condition by closing an FTP connection. Closing the connection resulted in the near-simultaneous transmission of two signals to the FTP server: one to abort the current operation, and one to log out the user. The race condition occurred when the logout signal arrived just before the abort signal. When a user logged onto an FTP server as an anonymous user, the server would temporarily downgrade its privileges from root to nobody so that the logged-in user had no privileges to write files. In order to log out the user, however, the server reassumed root privileges. If the abort signal arrived at just the right time, it would abort the logout procedure after the server had assumed root privileges but before it had logged out the user. The user would then be logged in with root privileges, and could proceed to write files at will. An attacker could exploit this vulnerability with a graphical FTP client simply by repeatedly clicking the “Cancel” button. [CVE-1999-0035] </p><p>For a brief introduction to signal handlers, see the Little Unix Programmers Group site at <span class="content_text"><a href="http://users.actcom.co.il/~choo/lupg/tutorials/signals/signals-programming.html" target="_blank">http://users.actcom.co.il/~choo/lupg/tutorials/signals/signals-programming.html</a></span>. For a discourse on how signal handler race conditions can be exploited, see the article by Michal Zalewski at <span class="content_text"><a href="http://www.bindview.com/Services/razor/Papers/2001/signals.cfm" target="_blank">http://www.bindview.com/Services/razor/Papers/2001/signals.cfm</a></span>.</p><a name="//apple_ref/doc/uid/TP40002585-SW9" title="Insecure File Operations"></a><h2>Insecure File Operations</h2><p>Insecure <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_146"></a><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_147"></a>file operations are a major source of security vulnerabilities. In some cases, opening or writing to a file in an insecure fashion can give attackers the opportunity to create a race condition (see <span class="content_text"><a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW2">“Time Of Check–Time Of Use”</a></span>). Often, however, insecure file operations give an attacker the chance to read confidential information, an opportunity to gain control of an application or even of the system, or an opening for a denial of service attack. This section discusses insecure file operations. The following section, <span class="content_text"><a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW10">“Secure File Operations,”</a></span> describes some techniques you can use to make sure your file operations are secure.</p><ul class="ul"><li class="li"><p>The <code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_148"></a>chflags</code> utility sets flags on a file, including a flag that prevents the file from being modified. Once this flag has been set, attempts to modify the file—such as to change permissions with the <code>chmod</code> utility or to change the UID or GID with the <code>chown</code> utility—will fail, even if these utilities are run as root. Therefore, you must always check result codes of file operations and be prepared to handle the situation if the operation fails. </p></li><li class="li"><p>Although the <code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_149"></a>rm</code> command clears user flags on a file if it sees that they're there, it can still fail. For example, you can't remove a directory that has anything inside it. If a directory is in a location where other users have access to it, any attempt to remove the directory might fail. The safest thing is to use a private directory that no one else has access to. If that’s not possible, check to make sure the <code>rm</code> command succeeded and be prepared to handle the case that it does not.</p></li><li class="li"><p>A <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_150"></a>hard link is a second name for a file—the file appears to be in two different locations with two different names. If a file has two (or more) hard links and you check the file to make sure that the ownership, permissions, and so forth are all correct, but fail to check the number of links to the file, an attacker can write to or read from the file through their own link in their own directory. Therefore, among other checks before you use a file, you should check the number of links. Do not, however, simply fail if there's a second link to a file, because there are some circumstances where a link is all right or even expected. You need to anticipate such conditions and allow for them. Even if the link is unexpected, you need to handle the situation gracefully. Otherwise, an attacker can cause denial of service just by creating a link to the file. Instead, you should notify the user of the situation, giving them as much information as possible so they can try to track down the source of the problem. </p></li><li class="li"><p>Symbolic links are more common than hard links. A <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_151"></a>symbolic link is a special type of file that contains a path name. Functions that follow symbolic links automatically open, read, or write to the file whose path name is in the symbolic link file rather than the symbolic link file itself. Your application receives no notification that a symbolic link was followed; to your application, it appears as if the file addressed is the one that was used. An attacker can use a symbolic link, for example, to cause your application to write the contents intended for a temporary file to a critical system file instead, thus corrupting the system. Alternatively, the attacker can capture data you are writing or can substitute the attacker's data for your own when you read the temporary file. Avoid functions, such as <code>chown</code> and <code>stat</code>, that follow symbolic links (see <span class="content_text"><a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW3">Table 1</a></span> for alternatives). As with hard links, your program should evaluate whether a symbolic link is all right, and if not, should handle the situation gracefully.</p></li><li class="li"><p>Any time you work on files in a location to which others have read/write access, there’s the potential for the file to be compromised or corrupted. </p></li><li class="li"><p>Before you attempt a file operation, make sure the operation can be done on that file. For example, before attempting to read a file, make sure it's not a FIFO.    </p></li><li class="li"><p>Just because you can write to a file, that doesn’t mean you <em>should</em> write to it. For example, the fact that a directory exists doesn’t mean you created it, and the fact that you can append to a file doesn’t mean you own the file or no one else can write to it. </p></li><li class="li"><p>Mac OS X can perform file operations on files in several different file systems. Some operations can be done only on certain systems. For example, certain file systems honor setuid files when executed from them and some don't. Be sure you know what file system you’re working with and what operations can be carried out on that system.</p></li><li class="li"><p>Local pathnames can point to remote files.  For example, the path <code>/volumes/foo</code> might actually be someone's FTP server rather than a locally-mounted volume. Just because you're accessing something by a pathname, that does not guarantee that it's local or that it should be accessed.</p></li><li class="li"><p>A user can mount a <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_152"></a>file system anywhere they have write access and own the directory. In other words, almost anywhere a user can create a directory, they can mount a file system on top of it. Because this can be done remotely, an attacker running as root on a remote system could mount a file system into your home directory. Files in that file system would appear to be files in your home directory owned by root. For example, <code>/tmp/foo</code> might be a local directory, or it might be the root mount point of a <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_153"></a>remotely mounted file system. Similarly, <code>/tmp/foo/bar</code> might be a local file, or it might have been created on another machine and be owned by root over there. Therefore, you can't trust files based only on ownership, and you can't assume that setting the UID to 0 was done by someone you trust.  To tell whether the file is mounted locally, use the <code>lstat</code> or <code>fstat</code> call to check the <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_154"></a>device ID. If the device ID is different from that of files you know to be local, then you’ve crossed a device boundary. </p></li><li class="li"><p>Just because a program's executable doesn't mean that users won't be able to read the content of the file. </p></li><li class="li"><p>When you fork a new process, the child process inherits all the <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_155"></a>file descriptors from the parent unless you set the <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_156"></a>close-on-exec flag. If you fork and execute a child process and drop the child process’ privileges so its real and effective IDs are those of some other user (to avoid running that process with elevated privileges), then that user can use a debugger to attach the child process. They can then run arbitrary code from that running process. Because the child process inherited all the file descriptors from the parent, the user now has access to every file opened by the parent process. See <span class="content_text"><a href="AccessControl.html#//apple_ref/doc/uid/TP40002589-SW10">“Inheriting File Descriptors”</a></span> for more information on this type of vulnerability.</p></li></ul><a name="//apple_ref/doc/uid/TP40002585-SW10" title="Secure File Operations"></a><h2>Secure File Operations</h2><p>There are several principles you can follow to help ensure that you do not have file-based security vulnerabilities in your program:<a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_157"></a></p><ul class="ul"><li class="li"><p>The first principle is to always check the result codes of all the routines you call. Most of the file-based security vulnerabilities that have been caught by Apple's security team could have been avoided if the developers of the programs had checked result codes. For example, if someone has called the <code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_158"></a>chflags</code> utility to set the immutable flag on a file and you call the <code>chmod</code> utility to change file modes or access control lists on that file, then your <code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_159"></a>chmod</code> call will fail, even if you are running as root. Another example of a call that might fail unexpectedly is the <code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_160"></a>rm</code> call to delete a directory. If you think a directory is empty and call <code>rm</code> to delete the directory, but someone else has put a file or subdirectory in there, your <code>rm</code> call will fail. </p></li><li class="li"><p>When working in a directory to which your process does not have exclusive access, you must check to make sure a file does not exist before you create it. You must also verify that the file you intend to read from or write to is the same file you created.</p></li><li class="li"><p>Toward this end, use routines that operate on <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_161"></a>file descriptors rather than pathnames wherever possible, so you can be sure you're always dealing with the same file.</p></li><li class="li"><p>Intentionally create files as a separate step from opening them so that you can verify that you are opening a file you created rather than one that already existed. </p></li><li class="li"><p>When checking for the existence or status of a file, you must know whether the function or shell routine you are calling follows symbolic links. For example, whereas the C function <code>lstat</code> gives you the status of a file regardless of whether it's a normal file or a symbolic link, the <code>stat</code> function follows symbolic links and, if the specified file was a symbolic link,  returns the status of the linked-to file. Therefore, if you use the <code>stat</code> function, you could be fooled into thinking you are writing to or reading from a certain file in a known directory, when you are really accessing another file entirely. </p></li><li class="li"><p>Before you read a file, make sure it has the owner and permissions you expect. Be prepared to fail gracefully (rather than hanging) if it does not.</p></li><li class="li"><p>Set your process' file code creation mask (<a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_162"></a>umask) to restrict access to files created by your process. The umask is a bitmask that alters the default <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_163"></a>permissions of a new file. If you set the umask to <code>0x022</code>, for example, any new file created by your process has <code>rw-r--r--</code> permissions. When a process calls another process, the new process inherits the parent process' umask. Then if your process calls another process, the new process creates a file, and the new process does not reset the umask, you have a good chance of having a file that is not accessible to all users on the system. For more information on the umask, see the manual page for <code>umask(2)</code> and Viega and McGraw, <em>Building Secure Software</em>, Addison Wesley, 2002. For a particularly lucid explanation of the use of a umask, see <span class="content_text"><a href="http://www.sun.com/bigadmin/content/submitted/umask_permissions.html" target="_blank">http://www.sun.com/bigadmin/content/submitted/umask_permissions.html</a></span>.</p></li></ul><p>The following sections give some hints on how to follow these principles when you are using generic C code, Carbon, and Cocoa.</p><a name="//apple_ref/doc/uid/TP40002585-SW4" title="Generic C"></a><h3>Generic C</h3><p>For <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_164"></a>generic C programming, if you are opening a <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_165"></a>temporary file in a public directory, you can use the <code>open</code> function with the <code>O_CREAT</code> and <code>O_EXCL</code> flags set to create the file and obtain a <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_166"></a>file descriptor. The <code>O_EXCL</code> flag causes this function to return an error if the file already exists. Be sure to check for errors before proceeding. As a shortcut, you can use the <code>mkstemp</code> function to open the temporary file. The <code>mkstemp</code> function guarantees a unique filename and returns a file descriptor, thus allowing you skip the step of checking the <code>open</code> function result for an error, which might require you to change the filename and call <code>open</code> again. </p><p>After you've opened the file and obtained a file descriptor, you can safely use functions that take file descriptors, such as the standard C functions <code>write</code> and <code>read</code>, for as long as you keep the file open. See the manual pages for <code>open(2)</code>, <code>mkstemp(3)</code>, <code>write(2)</code>, and <code>read(2)</code> for more on these functions, and see Wheeler, <em>Secure Programming for Linux and Unix HOWTO</em> for advantages and shortcomings to using these functions. </p><p>If you need to open a preexisting file to modify it or read from it, you need to check the file's ownership, type, and permissions, and the number of links to the file before using it. </p><p>To safely opening a file for reading, for example, you can use the following procedure:</p><ol class="ol"><li class="li"><p>Call the <code>lstat</code> function to get information about the file. (Do not use the <code>stat</code> function, as that function follows symbolic links.) Save the <code>stat</code> structure returned by the <code>lstat</code> function.</p></li><li class="li"><p>Check the file's status information to make sure the file is not a symbolic link.</p></li><li class="li"><p>Check the user ID (UID) and group ID (GID) of the file to make sure they are correct.</p></li><li class="li"><p>Check the filetype to make sure it's correct.</p></li><li class="li"><p>Check the read, write, and execute permissions for the file to make sure they are what you expect.</p></li><li class="li"><p>Check that there is only one hard link to the file.</p></li><li class="li"><p>Call the <code>open</code> function and save the file descriptor.</p></li><li class="li"><p>Using the file descriptor, call the <code>fstat</code> function to obtain the <code>stat</code> structure for the file you opened.</p></li><li class="li"><p>Compare the device and inode numbers in the stat structure obtained before you opened the file with those in the stat structure obtained after you opened the file to verify that they are the same file. </p></li><li class="li"><p>Check all the information in the <code>stat</code> structure returned by the <code>fstat</code> function to make sure it is what you expect. </p></li></ol><p>Although this might seem like a lot of extra work, it eliminates the race condition that can occur between calling the <code>stat</code> and <code>open</code> functions. Note that you can avoid all the status checking by using a secure directory instead of a public one to hold your program's files.</p><p><span class="content_text">Table 1</span> shows some functions to avoid—and the safer equivalent functions to use—in order to avoid race conditions when you are creating files in a public directory.</p><a name="//apple_ref/doc/uid/TP40002585-SW3" title="Table 1C file functions to avoid and to use"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1&nbsp;&nbsp;</strong>C file functions to avoid and to use</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Functions to avoid</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Functions to use instead</p></th></tr><tr><td  scope="row"><p><code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_167"></a>fopen</code> returns a file pointer; automatically creates the file if it does not exist but returns no error if the file does exist</p></td><td ><p><code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_168"></a>open</code> returns a file descriptor; creates a file and returns an error if the file already exists when the <code>O_CREAT</code> and <code>O_EXCL</code> options are used</p></td></tr><tr><td  scope="row"><p><code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_169"></a>chmod</code> takes a file path</p></td><td ><p><code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_170"></a>fchmod</code> takes a file descriptor</p></td></tr><tr><td  scope="row"><p><code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_171"></a>chown</code> takes a file path and follows symbolic links</p></td><td ><p><code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_172"></a>fchown</code> takes a file descriptor and does not follow symbolic links</p></td></tr><tr><td  scope="row"><p><code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_173"></a>stat</code> takes a file path and follows symbolic links</p></td><td ><p><code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_174"></a>lstat</code> takes a file path but does not follow symbolic links; </p><p><code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_175"></a>fstat</code> takes a file descriptor and returns information about an open file</p></td></tr><tr><td  scope="row"><p><code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_176"></a>mktemp</code> creates a temporary file with a unique name and returns a file path; you need to open the file in another call</p></td><td ><p><code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_177"></a>mkstemp</code> creates a temporary file with a unique name, opens it for reading and writing, and returns a file descriptor</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002585-SW5" title="Carbon"></a><h3>Carbon</h3><p>If you are using the Carbon File Manager to create and open files, you should be aware of how the File Manager accesses files. <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_178"></a></p><ul class="spaceabove"><li class="li"><p>The file specifier <code>FSSpec</code> structure uses a path to locate files, not a file descriptor. Functions that use an <code>FSSpec</code> file specifier are deprecated and should not be used in any case.</p></li><li class="li"><p>The file reference <code>FSRef</code> structure uses a path to locate files and should be used only if your files are in a safe directory, not in a publicly accessible directory. These functions include <code>FSGetCatalogInfo</code>, <code>FSSetCatalogInfo</code>, <code>FSCreateFork</code>, and others.</p></li><li class="li"><p>The File Manager creates and opens files in separate operations.  The create operation fails if the file already exists. However, none of the file-creation functions return a file descriptor.</p></li></ul><p>To find the default location to store <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_179"></a>temporary files, you can call the <code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_180"></a>FSFindFolder</code> function and specify a directory type of <code>kTemporaryFolderType</code>. This function checks to see whether the UID calling the function owns the directory and, if not, returns the user home directory in <code>~/library</code>.  Therefore, this function returns a relatively safe place to store temporary files. This location is not as secure as a directory that you created and that is accessible only by your program. The <code>FSFindFolder</code> function is documented in <em><a href="../../../../Carbon/Reference/Folder_Manager/index.html#//apple_ref/doc/uid/TP30000238" target="_top">Folder Manager Reference</a></em>. </p><p>If you've obtained the file reference of a directory (from the <code>FSFindFolder</code> function, for example), you can use the <code>FSRefMakePath</code> function to obtain the directory's path name. However, be sure to check the function result, because if the <code>FSFindFolder</code> function fails, it returns a <code>null</code> string. If you don't check the function result, you might end up trying to create a temporary file with a pathname formed by appending a filename to a <code>null</code> string.</p><a name="//apple_ref/doc/uid/TP40002585-SW11" title="Cocoa"></a><h3>Cocoa</h3><p>There are no Cocoa methods that create a file and return a file descriptor. However, you can call the standard C <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_181"></a><code>open</code> function from an Objective-C program to obtain a file descriptor (see <span class="content_text"><a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW4">“Generic C”</a></span>). Or you can call the <code>mkstemp</code> function to create a temporary file and obtain a file descriptor. Then you can use the <code>NSFileHandle</code> method <code>InitWithFileDescriptor:</code> to initialize a file handle, and other <code>NSFileHandle</code> methods to safely write to or read from the file.  Documentation for the <code>NSFileHandle</code> class is in <em><a href="../../../../Cocoa/Reference/Foundation/ObjC_classic/index.html#//apple_ref/doc/uid/20001091" target="_top">Foundation Framework Reference</a></em>.</p><p>To obtain the path to the default location to store <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_182"></a>temporary files (stored in the <code>$TMPDIR</code> environmental variable), you can use the <code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_183"></a>NSTemporaryDirectory</code> function, which calls the<code>FSFindFolder</code> and <code>FSRefMakePath</code> functions for you (see <span class="content_text"><a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW5">“Carbon”</a></span>). Note that <code>NSTemporaryDirectory</code> can return <code>/tmp</code> under certain circumstances such as if you link on a pre-Mac OS X v10.3 development target. Therefore, if you're using <code>NSTemporaryDirectory</code>, you either have to be sure that using <code>/tmp</code> is suitable for your operation or, if not, you should consider that an error case and create a more secure temporary directory if that happens.</p><p>The <code>changeFileAttributes:atPath:</code> method in the <code>NSFileManager</code> class is similar to <code>chmod</code> or <code>chown</code>, in that it takes a file path rather than a file descriptor. You shouldn't use this method if you're working in a public directory or a user's home directory. Instead, call the <code>fchown</code> or <code>fchmod</code> function (see <span class="content_text"><a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW3">Table 1</a></span>). You can call the <code>NSFileHandle</code> class's <code>fileDescriptor</code> method to get the file descriptor of a file in use by <code>NSFileHandle</code>. </p><p>The <code>NSString</code> and <code>NSData</code> classes have <code>writeToFile:atomically</code> methods designed to minimize the risk of data loss when writing to a file. These methods write first to a temporary file, and then, when they're sure the write is successful, they replace the written-to file with the temporary file. This is not always an appropriate thing to do when working in a public directory or a user's home directory, because there are a number of path-based file operations involved. Instead, initialize an <code>NSFileHandle</code> object with an existing file descriptor and use <code>NSFileHandle</code> methods to write to the file, as mentioned above. The following code, for example, uses the <code>mkstemp</code> function to create a temporary file and obtain a file descriptor, which it then uses to initialize <code>NSFileHandle</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>fd = mkstemp(tmpfile); // check return for -1, which indicates an error<span></span></pre></td></tr><tr><td scope="row"><pre>NSFileHandle *myhandle = [[NSFileHandle alloc] initWithFileDescriptor:fd];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002585-SW6" title="Shell Scripts"></a><h3>Shell Scripts</h3><p><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_184"></a><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_185"></a>Scripts must follow the same general rules as other programs to avoid race conditions. There are a few tips you should know to help make your scripts more secure.</p><p>First, when writing a script, set the temporary directory (<code>$TMPDIR</code>) environmental variable to a safe directory. Even if your script doesn't directly create any <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_186"></a>temporary files, one or more of the routines you call might create one, which can be a security vulnerability if it's created in an insecure directory. See the manual pages for <code>setenv(1)</code> and <code>setenv(3)</code> for information on changing the temporary directory environmental variable. For the same reason, set your process' file code creation mask (umask) to restrict access to any files that might be created by routines run by your script (see <span class="content_text"><a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW10">“Secure File Operations”</a></span> for more information on the umask).</p><p>It's also a good idea to use the <code>ktrace</code> function on a shell script so you can watch every command that gets executed to make sure that during the life of your script no temporary file is created in an insecure location. See the manual page for <code>ktrace(2)</code> for more information.</p><p>Do not redirect output using the operators <code>></code> or <code>>></code> to a publicly writable location. These operators do not check to see whether the file already exists, and they follow symbolic links.</p><p>Do not use the <code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_187"></a>test</code> command (or its <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_188"></a>left bracket (<code>[</code>) equivalent) to check for the existence of a file or other status information for the file before writing to it. Doing so always results in a race condition; that is, it is possible for an attacker to create, write to, alter, or replace the file before you start writing. Instead, use the <code>mkdtemp</code> command to create a subdirectory to which only you have access. It's important to check the result to make sure the command succeeded. if you do all your file operations in this directory, you can be fairly confident that no one with less than root access can interfere with your script. For more information, see the manual pages for <code>test(1)</code> and <code>mkdtemp(3)</code>.</p><a name="//apple_ref/doc/uid/TP40002585-SW2" title="Time Of Check&acirc;&#128;&#147;Time Of Use"></a><h2>Time Of Check–Time Of Use</h2><p>A <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_189"></a>race condition that can be caused by insecure file operations is the <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_190"></a>time of check–time of use problem. Many programs write temporary files to publicly accessible directories. You can set the file permissions of the temporary file to prevent another user from altering the file. However, if the file already exists before you write to it, you could be overwriting data needed by another program or you could be using a file prepared by an attacker, in which case it might be a symbolic link, redirecting your output to a file needed by the system or to a file controlled by the attacker. To prevent this, programs often check to make sure a temporary file with a specific name does not already exist in the target directory, and then they open the file to write to it.</p><p>An attacker can create a race condition by repeatedly creating and removing files with the name used by your program for the temporary file. If they create the file at just the right moment, it will be after your program has checked to make sure the file doesn't exist, but before the program writes to it. Then, when your program does write to the temporary file, it will be writing to the attacker's file rather than creating a new file.</p><p>In a vulnerability in a directory server, a server script was executing commands to write private and public keys to temporary files, then reading those keys and putting them in a database. Because the temporary files were in a publicly writable directory, an attacker could have created a race condition by substituting the attacker's own files (or symbolic links to the attacker's files) before the keys were read, thus causing the script to read the attacker's private and public keys. After that, anything encrypted or authenticated using those keys would be under the attacker's control. Or the attacker could have read the private keys, which can be used to decrypt encrypted data. Private keys must be kept secret to be useful. [CVE-2005-2519]</p><p>Often, rather than substituting an ordinary file for your temporary file, an attacker creates a hard or symbolic link.</p><p>Here are some guidelines to help you avoid time of check–time of use vulnerabilities.  For more detailed discussions, especially for C code, see Viega and McGraw, <em>Building Secure Software</em>, Addison Wesley, 2002, and Wheeler, <em>Secure Programming for Linux and Unix HOWTO</em>, available at <span class="content_text"><a href="http://www.dwheeler.com/secure-programs/" target="_blank">http://www.dwheeler.com/secure-programs/</a></span>.</p><ul class="ul"><li class="li"><p>If at all possible, avoid creating <a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_191"></a>temporary files in a shared directory, such as <code>/tmp</code>, or in directories owned by the user. If anyone else has access to your temporary file, they can modify its content, change its ownership or mode, or replace it with a hard or symbolic link. It's much safer to either not use a temporary file at all (use some other form of interprocess communication) or keep temporary files in a directory you create and to which only your process (acting as your user) has access.</p></li><li class="li"><p>If your file must be in a shared directory, give it a unique (and randomly generated) filename (you can use the C function <code><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_192"></a>mkstemp</code> to do this) and never close and reopen the file. If you close such a file, an attacker can potentially find it and change it before you reopen it. Here are some public directories that you can use:</p><ul class="nested"><li class="nested li"><p><code>~/Library/Caches/TemporaryItems</code></p><p>When you use this subdirectory, you are writing to the user's own home directory, not some other user's directory or a system directory. If the user's home directory has the default permissions, it can be written to only by that user and root. Therefore, this directory is not as susceptible to attack from outside, nonprivileged users as some other directories might be.</p></li><li class="nested li"><p><code>/var/run</code></p><p>This directory is used for process ID (pid) files and other system files needed just once per startup session. This directory is cleared out each time the system starts up.</p></li><li class="nested li"><p><code>/var/db</code></p><p>This directory is used for databases accessible to system processes.<a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_193"></a><a name="//apple_ref/doc/uid/TP40002585-DontLinkElementID_194"></a></p></li></ul></li></ul>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ValidatingInput.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="AccessControl.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-05-23<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Security/Conceptual/SecureCodingGuide/Articles/RaceConditions.html%3Fid%3DTP40002415-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Security/Conceptual/SecureCodingGuide/Articles/RaceConditions.html%3Fid%3DTP40002415-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Security/Conceptual/SecureCodingGuide/Articles/RaceConditions.html%3Fid%3DTP40002415-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
