<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Porting Drivers to Mac OS X: Driver Porting Basics</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Driver Porting Basics"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001169-CH205" title="Driver Porting Basics"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../Darwin/index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../intro/intro.html#//apple_ref/doc/uid/TP30001169-CH204-TPXREF101">Porting Drivers to Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../intro/intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../other-iokit/other-iokit.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001169-CH205-TPXREF101" title="Driver Porting Basics"></a><h1>Driver Porting Basics</h1><p>This chapter describes some of the fundamental differences between traditional UNIX-style drivers (including BSD and Linux) and Mac OS X’s I/O Kit drivers. As with any subject as broad as driver porting, there are many details that are specific to the technology area in question. This chapter does not attempt to cover such issues. Instead, it focuses on the more general issues, leaving the implementation details as an exercise for the reader.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="unix-model.html#//apple_ref/doc/uid/TP30001169-CH205-BAJIIDDH">Does Your Driver Belong in the Kernel?</a>
				
			<br/>
			
        
			
			
				<a href="unix-model.html#//apple_ref/doc/uid/TP30001169-CH205-TPXREF112">What’s My Class?</a>
				
			<br/>
			
        
			
			
				<a href="unix-model.html#//apple_ref/doc/uid/TP30001169-CH205-TPXREF105">Workloops vs. Interrupt Handlers</a>
				
			<br/>
			
        
			
			
				<a href="unix-model.html#//apple_ref/doc/uid/TP30001169-CH205-TPXREF106">IOMemoryDescriptor vs.  kvtophys</a>
				
			<br/>
			
        
			
			
				<a href="unix-model.html#//apple_ref/doc/uid/TP30001169-CH205-TPXREF107">C++ Driver Model</a>
				
			<br/>
			
        
			
			
				<a href="unix-model.html#//apple_ref/doc/uid/TP30001169-CH205-TPXREF108">Data Types</a>
				
			<br/>
			
        
			
			
				<a href="unix-model.html#//apple_ref/doc/uid/TP30001169-CH205-TPXREF109">ioctl Handling</a>
				
			<br/>
			
        
			
			
				<a href="unix-model.html#//apple_ref/doc/uid/TP30001169-CH205-TPXREF110">sysctl and  syscall Handling</a>
				
			<br/>
			
        
			
			
				<a href="unix-model.html#//apple_ref/doc/uid/TP30001169-CH205-TPXREF111">Interrupt Priority Levels ( IPL/SPL) vs. IOLock Locks</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001169-CH205-BAJIIDDH" title="Does Your Driver Belong in the Kernel?"></a><h2>Does Your Driver Belong in the Kernel?</h2><p>This document primarily applies to in-kernel device drivers. Not all device drivers in Mac OS X are in the kernel. For example, most human interface devices (keyboards, mice, and so on) and graphics and imaging devices (printers, scanners, and similar) are controlled by user-space drivers.</p><p>In general, your driver should be in the kernel if it is used concurrently across multiple applications or if its primary client is in the kernel. Examples include video drivers, disk or disk controller drivers, and so on.</p><p>There are a few cases where a driver has to reside in the kernel even though similar devices can reside in user space. In particular, any device on a PCI or AGP bus must be in the kernel because those busses do not export interfaces to user space for security reasons.</p><p>For the most part, PCI devices are things that need to be in the kernel anyway. There are a few exceptions, however, such as MIDI device drivers. While MIDI device drivers live in user space, PCI device drivers must reside in the kernel. Thus PCI cards with MIDI interfaces require two drivers: the actual I/O Kit driver for the device (subclassed from the PCI driver family) and a CFPlugIn in user space to provide a driver to CoreMIDI. Interfacing drivers across user-kernel boundaries is beyond the scope of this book. For help creating drivers that span user-kernel boundaries, you should contact Apple Developer Technical Support.</p><a name="//apple_ref/doc/uid/TP30001169-CH205-TPXREF112" title="What&acirc;&#128;&#153;s My Class?"></a><h2>What’s My Class?</h2><p>Before you actually start porting code, you should create a stub driver using the correct base class for your type of device. The <em><a href="../../../../Darwin/Reference/KernelIOKitFramework/index.html#//apple_ref/doc/uid/TP30000816" target="_top">Kernel Framework Reference</a></em> provides documentation for each of these base classes.</p><p>In general, you will need to use two classes in your drivers: a base class (whose name typically ends with “driver”) and a nub class (whose name typically ends with “device”).</p><p>The base class instance will represent the driver itself. It must then instantiate an instance of the nub class for each device that it is controlling. This nub abstraction provides a mechanism for other parts of the system to actually use your driver to communicate with the device. The mechanism for instantiating this nub varies from class to class.</p><p>For detailed information on this process, you should read <em><a href="../../../../DeviceDrivers/Conceptual/IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em> and follow the <span class="content_text"><a href="../../../../Darwin/Conceptual/KEXTConcept/KEXTConceptIOKit/hello_iokit.html#//apple_ref/doc/uid/20002366" target="_top">Hello I/O Kit tutorial</a></span>.</p><a name="//apple_ref/doc/uid/TP30001169-CH205-TPXREF105" title="Workloops vs. Interrupt Handlers"></a><h2>Workloops vs. Interrupt Handlers</h2><p>Drivers in Mac OS X are designed around the concept of a workloop. (Many drivers on other UNIX-based platforms are written in a similar fashion, but not as part of the primary driver model.)</p><p>The idea of a workloop is simple. It is basically just a helper thread. When an interrupt occurs, instead of a handler routine being executed immediately, the kernel sets that thread to “ready to execute”. Thus, the interrupt handling occurs at a kernel thread priority instead of at an interrupt priority. This ensures that interrupts don’t get lost while handling routines have interrupts turned off. It also means that routines running in an interrupt service thread context do not have to obey the same rules as an actual interrupt handler; they can block, call IOLog, and so on.</p><p>Creating a workloop is relatively simple. The following code is an example of registering to receive two interrupts using a workloop:</p><div class="codesample"><table><tr><td scope="row"><pre>/* class variables */<span></span></pre></td></tr><tr><td scope="row"><pre>IOWorkLoop *myWorkLoop;<span></span></pre></td></tr><tr><td scope="row"><pre>IOInterruptEventSource *interruptSource;<span></span></pre></td></tr><tr><td scope="row"><pre>IOInterruptEventSource *DMAInterruptSource;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* code in start() */<span></span></pre></td></tr><tr><td scope="row"><pre>myWorkLoop = IOWorkLoop::workLoop();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if( myWorkLoop == NULL) {    IOLog( "org_mklinux_iokit_swim3_driver::start: Couldn't allocate "<span></span></pre></td></tr><tr><td scope="row"><pre>        "workLoop event source\n" );<span></span></pre></td></tr><tr><td scope="row"><pre>    return false;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>interruptSource = IOInterruptEventSource::interruptEventSource(<span></span></pre></td></tr><tr><td scope="row"><pre>    (OSObject*)this,<span></span></pre></td></tr><tr><td scope="row"><pre>    (IOInterruptEventAction)&amp;org_mklinux_iokit_swim3_driver::handleInterrupt,<span></span></pre></td></tr><tr><td scope="row"><pre>    (Filter)&amp;org_mklinux_iokit_swim3_driver::interruptPending,<span></span></pre></td></tr><tr><td scope="row"><pre>    (IOService*)provider,<span></span></pre></td></tr><tr><td scope="row"><pre>    (int)0 );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ( interruptSource == NULL ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog( "org_mklinux_iokit_swim3_driver::start: Couldn't allocate "<span></span></pre></td></tr><tr><td scope="row"><pre>        "Interrupt event source\n" );<span></span></pre></td></tr><tr><td scope="row"><pre>    return false;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ( myWorkLoop->addEventSource( interruptSource ) != kIOReturnSuccess ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog( "org_mklinux_iokit_swim3_driver::start - Couldn't add Interrupt"<span></span></pre></td></tr><tr><td scope="row"><pre>        “event source\n" );    return false;}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>DMAInterruptSource = IOInterruptEventSource::interruptEventSource(<span></span></pre></td></tr><tr><td scope="row"><pre>    (OSObject*)this,<span></span></pre></td></tr><tr><td scope="row"><pre>    (IOInterruptEventAction)&amp;org_mklinux_iokit_swim3_driver::<span></span></pre></td></tr><tr><td scope="row"><pre>        handleDMAInterrupt,    (IOService*)provider,    (int)1 );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ( DMAInterruptSource == NULL ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog( "org_mklinux_iokit_swim3_driver::start: Couldn't allocate "<span></span></pre></td></tr><tr><td scope="row"><pre>        "Interrupt event source\n" );<span></span></pre></td></tr><tr><td scope="row"><pre>    return false;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ( myWorkLoop->addEventSource( DMAInterruptSource ) != kIOReturnSuccess )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog( "org_mklinux_iokit_swim3_driver::start - Couldn't add "<span></span></pre></td></tr><tr><td scope="row"><pre>        "Interrupt event source\n" );<span></span></pre></td></tr><tr><td scope="row"><pre>    return false;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>myWorkLoop->enableAllInterrupts();<span></span></pre></td></tr></table></div><p>The methods <code>handleInterrupt</code> and <code>handleDMAInterrupt</code> will now called for the first and second device interrupts (offsets 0 and 1), respectively.</p><p>For the most part, this interrupt handler will behave much like any interrupt handler would in any other OS (except that you can call <code><!--a-->printf<!--/a--></code> and <code><!--a-->IOLog<!--/a--></code> safely). However, there are some exceptions, particularly in the area of interrupt priority.</p><p>You should note that this source example uses <code>IOFilterInterruptEventSource</code> instead of <code>IOInterruptEventSource</code>. This is strongly recommended for two reasons. First, if you are writing a driver for a multifunction PCI card), this will avoid having the OS call all of the drivers for all of the devices on that card. Second, if your card is installed into an environment where an interrupt line gets shared, this will significantly improve performance.</p><p>Unlike <code>IOInterruptEventSource</code>, when you create an <code>IOFilterInterruptEventSource</code> object, you pass in a filter function in addition to the handler.</p><p>In the filter function (<code><!--a-->org_mklinux_iokit_swim3_driver::interruptPending<!--/a--></code> in this example), you should test to see whether your device generated the interrupt, and return <code><!--a  -->true<!--/a--></code> if your driver should handle the interrupt or <code><!--a  -->false<!--/a--></code> if it belongs to another device on the card. This generally involves polling a register in your device to see which interrupt flags are set, then storing the value for later use. Note that because the filter function runs in the primary hardware interrupt context, you must treat it like any other direct hardware interrupt—don’t block, don’t call <code><!--a-->IOLog<!--/a--></code>, don’t copy data around or allocate memory, and so on.</p><p>For more information, read <em><a href="../../../../DeviceDrivers/Conceptual/IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em> and <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP30001169-CH205-TPXREF106" title="IOMemoryDescriptor vs.  kvtophys"></a><h2>IOMemoryDescriptor vs.  kvtophys</h2><p>For any given location in a computer’s memory, computer architectures define (at least) three distinct addresses: the physical address (the actual address line values as seen by the processor), the logical/virtual address (the address as seen by software), and the bus address (the address as seen by an arbitrary I/O device).</p><p>On most 32-bit hardware, the physical address is the same as the bus address. Thus, most people ignore the distinction. In Mac OS X, you must treat them as two different things, particularly on 64-bit hardware. For this reason, using physical addresses obtained with kvtophys is unsafe, and the function kvtophys has actually been removed from availability to KEXTs to prevent its improper use.</p><p>Instead, you should use an <code>IOMemoryDescriptor</code> for your memory allocation so that you can obtain the bus address associated with the block of memory and hand that information to the peripheral.</p><p>To do this, you use the method <code>IOMemoryDescriptor::getPhysicalSegment</code>. The first argument is an offset from the beginning of the descriptor. The second is the address where the segment length should be stored. If the segment length returned is less than the total descriptor length (which you can obtain using the method <code>IOMemoryDescriptor::getLength</code>), then you must get the physical address of the next segment, and so on, until you have dealt with the entire descriptor.</p><div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/TP30001169-CH205-DontLinkElementID_3" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;You <em>must</em> call <code>IOMemoryDescriptor::Prepare</code> on the descriptor before using <code>getPhysicalSegment</code> to ensure that appropriate physical to bus address mappings are configured prior to initiating a bus transaction. Don’t forget to call <code>IOMemoryDescriptor::Complete</code> after the transaction is completed. Failure to do so can cause data corruption and random crashes.</p><p></p><div class="clear"></div></div><p>For more information about the <code>IOMemoryDescriptor</code> class, see the I/O Kit reference documentation, available from Apple’s developer documentation website.</p><a name="//apple_ref/doc/uid/TP30001169-CH205-TPXREF107" title="C++ Driver Model"></a><h2>C++ Driver Model</h2><p>I/O Kit drivers are written in C++. Most device drivers in other operating systems are written in C. This often poses interesting issues, primarily related to the way driver-specific data is stored. It also can lead to a number of other surprises. These are described further in <span class="content_text"><a href="../other-language/other-language.html#//apple_ref/doc/uid/TP30001169-CH207-TPXREF106">“C++ Language Considerations.”</a></span></p><a name="//apple_ref/doc/uid/TP30001169-CH205-TPXREF108" title="Data Types"></a><h2>Data Types</h2><p>Data types tend to be of different sizes in various driver models. to avoid any nasty surprises, you should always check the bit width of the various data types in the original OS, then explicitly use data types of the same width. For example, if type <code>int</code> on Linux is 32 bits, for maximum longevity, you should use the type <code>uint32_t</code> in Mac OS X.</p><p>Suggested types are:</p><ul class="simple"><li><p><code>uint8_t</code>—unsigned 8-bit integer</p></li><li><p><code>uint16_t</code>—unsigned 16-bit integer</p></li><li><p><code>uint32_t</code>—unsigned 32-bit integer</p></li><li><p><code>uint64_t</code>—unsigned 64-bit integer</p></li><li><p><code>int8_t</code>—signed 8-bit integer</p></li><li><p><code>int16_t</code>—signed 16-bit integer</p></li><li><p><code>int32_t</code>—signed 32-bit integer</p></li><li><p><code>int64_t</code>—signed 64-bit integer</p></li></ul><p>The definition for these types can be included in both user-space and kernel-space code with the following:</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;stdint.h><span></span></pre></td></tr></table></div><p>You can also use the equivalent Mac-specific types, such as <code>UInt32</code>, which can be included with the following:</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;libkern/OSTypes.h><span></span></pre></td></tr></table></div><p>A note of caution: boolean variables can be problematic as there is no standard rule about their size. Rather than use built-in boolean types, you should generally stick with an explicit integer of your choice of sizes to avoid inadvertent alignment differences between your C and C++ code.</p><a name="//apple_ref/doc/uid/TP30001169-CH205-TPXREF109" title="ioctl Handling"></a><h2>ioctl Handling</h2><p>Mac OS X does not use <code><!--a-->ioctl<!--/a--></code> support at the driver level. Instead, higher level driver families handle <code><!--a-->ioctl<!--/a--></code> calls and turn them into explicit function calls. The details of these calls are dependent on the type of driver in question.</p><p>If the driver family you are using does not provide an <code><!--a-->ioctl<!--/a--></code> that you need, you can either file a bug requesting that the <code><!--a-->ioctl<!--/a--></code> be added or you can provide a similar solution through the use of a user client/device interface pair. These are described in more detail in the document <em><a href="../../../../DeviceDrivers/Conceptual/WritingDeviceDriver/index.html#//apple_ref/doc/uid/TP30000694" target="_top">I/O Kit Device Driver Design Guidelines</a></em>, available from the Apple Technical Publications website.</p><p>If none of these options is acceptable, you can also sometimes subclass the BSD user client for a particular class of devices (such as <code>IOMediaBSDClient</code>) and add additional <code><!--a-->ioctl<!--/a--></code> support. For example, to add an ioctl for a particular type of media, you would need to override the following methods:</p><ul class="ul"><li class="li"><p><code>start</code>—determine if the media is of the desired type</p></li><li class="li"><p><code>ioctl</code>—handle the ioctl</p></li></ul><p>A brief code snipped follows:</p><div class="codesample"><table><tr><td scope="row"><pre>bool FloppyMediaBSDClient::start(IOService *provider)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOMedia * media = (IOMedia *) provider;<span></span></pre></td></tr><tr><td scope="row"><pre>    u_int64_t size;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOStorage *storage;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Make sure our provider’s start routine succeeds */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (super::start(provider) == false)<span></span></pre></td></tr><tr><td scope="row"><pre>        return false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Make sure our provider is a block storage device */<span></span></pre></td></tr><tr><td scope="row"><pre>    media = getProvider();<span></span></pre></td></tr><tr><td scope="row"><pre>    storage = media->getProvider();<span></span></pre></td></tr><tr><td scope="row"><pre>    this->driver = OSDynamicCast(IOBlockStorageDriver, storage);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!this->driver)<span></span></pre></td></tr><tr><td scope="row"><pre>        return false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*<span></span></pre></td></tr><tr><td scope="row"><pre>     * Determine if this is really the type of media we’re looking for,<span></span></pre></td></tr><tr><td scope="row"><pre>     * in this case by its size. This could also be done using a more<span></span></pre></td></tr><tr><td scope="row"><pre>     * specific OSDynamicCast if we are looking for a particular driver<span></span></pre></td></tr><tr><td scope="row"><pre>     * to be upstream.<span></span></pre></td></tr><tr><td scope="row"><pre>     */<span></span></pre></td></tr><tr><td scope="row"><pre>    size = media->getSize() / (u_int64_t) 512;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch (size) {<span></span></pre></td></tr><tr><td scope="row"><pre>    case 0: // unformatted<span></span></pre></td></tr><tr><td scope="row"><pre>    case 720: // 360k<span></span></pre></td></tr><tr><td scope="row"><pre>    case 800: // 400k<span></span></pre></td></tr><tr><td scope="row"><pre>    case 1440: // 720k<span></span></pre></td></tr><tr><td scope="row"><pre>    case 1600: // 800k<span></span></pre></td></tr><tr><td scope="row"><pre>    case 2880: // 1440k<span></span></pre></td></tr><tr><td scope="row"><pre>    case 2881: // 1440k also<span></span></pre></td></tr><tr><td scope="row"><pre>    case 3360: // 1680k<span></span></pre></td></tr><tr><td scope="row"><pre>    case 5760: // 2880k<span></span></pre></td></tr><tr><td scope="row"><pre>        dIOLog("Floppy Disk Media Detected.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr><tr><td scope="row"><pre>    default:<span></span></pre></td></tr><tr><td scope="row"><pre>        dIOLog("Non-floppy disk media detected: %ld\n", (unsigned long)size);<span></span></pre></td></tr><tr><td scope="row"><pre>        return false;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return true;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int FloppyMediaBSDClient::ioctl (<span></span></pre></td></tr><tr><td scope="row"><pre>    dev_t           dev,<span></span></pre></td></tr><tr><td scope="row"><pre>    u_long          cmd,<span></span></pre></td></tr><tr><td scope="row"><pre>    caddr_t         data,<span></span></pre></td></tr><tr><td scope="row"><pre>    int             flags,<span></span></pre></td></tr><tr><td scope="row"><pre>    struct proc *   proc )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre>    // Process a Floppy-specific ioctl.<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    int *buffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    int error  = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn status = kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>    int formatflags;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch(cmd) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case FD_VERIFY:<span></span></pre></td></tr><tr><td scope="row"><pre>            buffer = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case FD_FORMAT:<span></span></pre></td></tr><tr><td scope="row"><pre>            buffer = (int *)data;<span></span></pre></td></tr><tr><td scope="row"><pre>            if (!buffer) {<span></span></pre></td></tr><tr><td scope="row"><pre>                dIOLog("ioctl (floppy): null buffer!\n");<span></span></pre></td></tr><tr><td scope="row"><pre>                error=EINVAL;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    switch (cmd)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case FD_VERIFY:<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            IOLog("Got FD_VERIFY -- not supported yet.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>            error = ENOTTY;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        case FD_FORMAT:<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            formatflags = *buffer;<span></span></pre></td></tr><tr><td scope="row"><pre>            IOLog("Got FD_FORMAT -- not supported yet (flags = 0x%x).\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                formatflags);<span></span></pre></td></tr><tr><td scope="row"><pre>            error = ENOTTY;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    default:<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            //<span></span></pre></td></tr><tr><td scope="row"><pre>            // A foreign ioctl was received.  Ask our superclass' opinion.<span></span></pre></td></tr><tr><td scope="row"><pre>            //<span></span></pre></td></tr><tr><td scope="row"><pre>            IOLog("fd: unknown ioctl, calling parent.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>            error = super::ioctl(dev, cmd, data, flags, proc);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>return error; // (return error status)<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p></p><a name="//apple_ref/doc/uid/TP30001169-CH205-TPXREF110" title="sysctl and  syscall Handling"></a><h2>sysctl and  syscall Handling</h2><p>Much like <code><!--a-->ioctl<!--/a--></code> support, Mac OS X drivers do not generally use <code><!--a-->sysctl<!--/a--></code> or <code><!--a-->syscall<!--/a--></code> interfaces except those provided by their respective families. Instead, user client/device interface pairs are used. These are described in more detail in the document <em><a href="../../../../DeviceDrivers/Conceptual/WritingDeviceDriver/index.html#//apple_ref/doc/uid/TP30000694" target="_top">I/O Kit Device Driver Design Guidelines</a></em>, available from the Apple Technical Publications website.</p><p>However, Mac OS X does provide ways of adding additional <code><!--a-->sysctl<!--/a--></code> and <code><!--a-->syscall<!--/a--></code> support. This is described in detail in the document <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP30001169-CH205-TPXREF111" title="Interrupt Priority Levels ( IPL/SPL) vs. IOLock Locks"></a><h2>Interrupt Priority Levels ( IPL/SPL) vs. IOLock Locks</h2><p>Many UNIX-based driver models use interrupt priority levels as a means of protecting critical sections in drivers using functions like things like <code><!--a-->splhigh<!--/a--></code>, <code><!--a-->splbio<!--/a--></code>, and <code><!--a-->splx<!--/a--></code>. Using interrupt priority to protect critical sections doesn’t work particularly well on SMP systems, and thus most operating systems are moving away from this design. However, these functions are still in common use.</p><p>Mac OS X does not support the use of interrupt priority levels for disabling interrupts for critical section protection. Instead, you should use locks, semaphores, or other synchronization mechanisms. If you compile your code using these functions, the code may compile, but will either not work properly (because the function in question is a no-op) or will result in a kernel panic, depending on the functions used.</p><p>Instead of using these functions, you should generally use <code>IOLock</code> mutex lock. These are described in the <em><a href="../../../../Darwin/Reference/KernelIOKitFramework/index.html#//apple_ref/doc/uid/TP30000816" target="_top">Kernel Framework Reference</a></em>, and are briefly summarized below:</p><div class="codesample"><table><tr><td scope="row"><pre>/*  Allocate an I/O Lock */<span></span></pre></td></tr><tr><td scope="row"><pre>IOLock *IOLockAlloc( void );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Free an I/O Lock */<span></span></pre></td></tr><tr><td scope="row"><pre>void IOLockFree( IOLock * lock);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Lock an I/O Lock */<span></span></pre></td></tr><tr><td scope="row"><pre>static __inline__ void IOLockLock( IOLock * lock);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Lock an I/O Lock if it doing so would not block. Returns true if<span></span></pre></td></tr><tr><td scope="row"><pre>    lock was obtained. */<span></span></pre></td></tr><tr><td scope="row"><pre>static __inline__boolean_t IOLockTryLock( IOLock * lock);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Unlock an I/O Lock */<span></span></pre></td></tr><tr><td scope="row"><pre>void IOLockUnlock( IOLock * lock);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Wait on condition specified by event (where event is usually<span></span></pre></td></tr><tr><td scope="row"><pre>    generated by taking the address of a variable, much like<span></span></pre></td></tr><tr><td scope="row"><pre>    timeout/untimeout in BSD */<span></span></pre></td></tr><tr><td scope="row"><pre>static __inline__ int IOLockSleep(<span></span></pre></td></tr><tr><td scope="row"><pre>        IOLock * lock,<span></span></pre></td></tr><tr><td scope="row"><pre>        void *event,<span></span></pre></td></tr><tr><td scope="row"><pre>        UInt32 interType);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Similar to IOLockSleep, only with a timeout specified */<span></span></pre></td></tr><tr><td scope="row"><pre>static __inline__ int IOLockSleepDeadline(<span></span></pre></td></tr><tr><td scope="row"><pre>        IOLock * lock,<span></span></pre></td></tr><tr><td scope="row"><pre>        void *event,<span></span></pre></td></tr><tr><td scope="row"><pre>        AbsoluteTime deadline,<span></span></pre></td></tr><tr><td scope="row"><pre>        UInt32 interType);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*  Wake up an event waiting on the condition specified by event<span></span></pre></td></tr><tr><td scope="row"><pre>    The boolean oneThread specifies whether to signal on the condition<span></span></pre></td></tr><tr><td scope="row"><pre>    (wake the first waiting thread) or broadcast (wake all threads<span></span></pre></td></tr><tr><td scope="row"><pre>    that are waiting).<span></span></pre></td></tr><tr><td scope="row"><pre> */<span></span></pre></td></tr><tr><td scope="row"><pre>static __inline__ void IOLockWakeup(IOLock * lock,<span></span></pre></td></tr><tr><td scope="row"><pre>        void *event,<span></span></pre></td></tr><tr><td scope="row"><pre>        bool oneThread);<span></span></pre></td></tr></table></div><p>If you find that you can’t live without a semaphore implementation, you can either implement one using an <code>IOLock</code> or use the Mach semaphores described in <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em>. The former is strongly recommended, as binary compatibility is not guaranteed for KEXTs that use Mach directly.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../intro/intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../other-iokit/other-iokit.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Porting/Conceptual/PortingDrivers/unix-model/unix-model.html%3Fid%3DTP30001169-2.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Porting/Conceptual/PortingDrivers/unix-model/unix-model.html%3Fid%3DTP30001169-2.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Porting/Conceptual/PortingDrivers/unix-model/unix-model.html%3Fid%3DTP30001169-2.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>