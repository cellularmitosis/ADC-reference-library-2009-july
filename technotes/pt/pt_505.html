<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note PT505: A/ROSE &amp; MCP Card Q&amp;As</title>                                       <meta name="categories" content="Platforms and Tools"><meta name="week-posted" content="Oct 1, 1990 - Oct 5, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002694" title="A/ROSE & MCP Card Q&As"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note PT505</div>
<div id="pageheadsub">A/ROSE &amp; MCP Card Q&amp;As</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note contains a collection of archived Q&amp;As relating to a specifictopic--questions sent the Developer Support Center (DSC) along withanswers from the DSC engineers. Current Q&amp;A's can be found on the <A HREF = "../../qa/index.html">Macintosh Technical Q&amp;A's web site</a>.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><h2>A/ROSE memory requirements</h2><p>How much memory is required in addition to normal application requirements foruploading A/ROSE to an MCP card? My faceless background task was unsuccessfulat booting the Apple TokenRing card until the background application partitionwas increased.</p>___<P>With the release of A/ROSE 1.1.8, the download code is stored as a resource,instead of being linked statically with an application. This change in downloadarchitecture allows A/ROSE to be more flexible in terms of compatibility withA/UX and future operating system architectures. As a result, additional heapspace is required for the download code resource to be brought into memory. The<code>'dwnl'</code> resource is about 9K. The memory required is about 9K + <code>sizeof</code>(largestsegment of the task). There are probably a few other small factors that may addan additional couple of K.</p><p>If you encounter problems in this area, you might segment your code. The A/ROSEstuff, after being segmented, has a maximum segment size of about 14 or 15K.So, if your code is small, you may still need about 25K to download. If yoursegments are greater than 15K, that will determine how much memory you need.</p><h2>A/ROSE product description</h2><P>Date Written:  1/4/93</p><P>Last reviewed:  6/14/93</p><p>What's A/ROSE? The extension is on my Duo, and I'm not sure what it is, orwhether I need it or not.</p>___<P>A/ROSE is a system extension which allows communication between the Macintoshmotherboard and Macintosh Coprocessor Platform (MCP)-based NuBus cards whichrun the Apple Real-Time Operating System. Translated to English, this meansthat specific Macintosh NuBus cards, such as the Apple TokenRing cards and thelatest Apple Ethernet NB card, have their own 68000 chip on board. A/ROSE isthe driver which allows the Macintosh Operating System to communicate with thesmart card, plus A/ROSE contains the operating system used to get the smartcard up and running, along with any task information associated with the card.The only reason for having this INIT installed is to support an MCP-based card.On the Duo, it could be that the DuoDock has an Ethernet NB card installed.When not docked, A/ROSE still loads, but isn't used by the Duo. Other cardsthat require A/ROSE include the two Apple TokenRing, the Serial NB, and theApple Coax/TwinAx NB cards. Note that SNA*ps is a software product that mayrequire A/ROSE in specific configurations.</p><p>If the DuoDock doesn't have one of the listed cards installed, or yourMacintosh Duo is not used for SNA*ps, then you can remove the A/ROSE startupdocument.</p><p>For more details, read "Inside the Macintosh Coprocessor Platform and A/ROSE"in issue #4 of <i>develop</i> (October 1990).</p><h2>A/ROSE &amp; MCP development questions</h2><P>Date Written:  12/11/90</p><P>Last reviewed:  6/14/93</p><p>What restrictions (power, speed, and so on) does the Macintosh CoprocessorPlatform (MCP) impose on the hardware added to the platform? Can we use A/ROSEon a board that we design ourselves from scratch? If so, we have the followingquestions concerning the hardware requirements for a board running A/ROSE: Mustthe CPU running A/ROSE be a 68000 or could it be a 68020 or 68030? Can A/ROSEhandle master transfers under NuBus control between the card and main boardmemory? Is the source code for A/ROSE (and specifically the InterCardCommunication Manager) available if we needed to tailor that code to oursystem?</p>___<P>To the knowledge of the A/ROSE engineer, A/ROSE requires modification in orderto permit master transfers under NuBus control between the card and main boardmemory. The engineer succeeded in designing a routine to perform the writeoperation from A/ROSE; however, the read operation proved to be a challenge. Asolution to your problem would be to release the source code. However, at thistime this isn't possible. There has been consideration on this subject but nofinal decision.</p><p>In response to your other questions, MCP doesn't impose any restrictions on thehardware. There are some card dependencies imposed by A/ROSE, described in thedocument, "A/ROSE Card Dependency," available on AppleLink.</p><p>I'm familiar with a couple of cards based on the MCP board. On one card inparticular, the processor was swapped with a 68020 using A/ROSE.</p><h2>gCommon addresses and downloading card-dependent routines</h2><P>Date Written:  8/14/91</p><P>Last reviewed:  6/14/93</p><p>After upgrading to A/ROSE 1.1.2, when I download to my board, it doesn't callmy board-specific routines in the resource <code>'hlta'</code> that I installed into A/ROSEPrep.</p>___<P>Check the gCommon area on the card at locations <code>gCardInit0</code>, <code>gCardInit1</code>, and<code>gCardInit2</code>. These are the addresses where the Download subroutine would haveplaced the card-dependent routines when placing the routines on the card. Youcan find these addresses in the :A/ROSE:includes:arose.a header file.</p><p>If these addresses are zero, that means either the Download subroutine failedto find the card-dependent routines when doing the downloading, or the Downloadsubroutine is the wrong version and doesn't know about card-dependent routines,or the application doing the downloading was not linked with a recent enoughversion of Download-Lib.o and contains the old Download subroutine code. Theactual code for doing downloading has been moved from the application to theA/ROSE Prep file and glue code is now in the Download-Lib.o file, which is whatthe application really calls. This glue code knows how to load the actualdownloading code.</p><p>If these addresses are nonzero, A/ROSE, during its initialization, should callthese routines. If A/ROSE is not calling them, check to see where the A/ROSEkernel is coming from. Was the A/ROSE kernel linked in with the code? In thiscase, you need to relink your code with a more recent version of the A/ROSEkernel.</p><h2>A/ROSE NetCopy process description</h2><P>Date Written:  8/30/91</p><P>Last reviewed:  6/14/93</p><p>How does the NetCopy <code>cVirtualToReal</code> routine work in the oscglue.a file of thePortable A/ROSE code? I'm trying to emulate the <code>NetCopy</code> command in my A/ROSEcode. I want the copy routine to work without requiring the user to use the<code>LockRealArea</code> command on the Macintosh Operating System side, but this meansthat I have to worry about the addressing being passed in as being virtual. Isthe A/ROSE kernel on the board providing the virtual-to-real mapping or does itjust send a message back to A/ROSE Prep to do it and then use the results?</p>___<P>What <code>cVirtualToReal()</code> does is take as input, a transaction ID (TID), a virtualaddress and a size. It returns a NuBus address and a size. If the returned sizeis zero, <code>cVirtualToReal()</code> could not find a corresponding NuBus address for thevirtual address. If the returned size is non-zero, this size is the size of thecontiguous address range for the virtual address starting at the NuBusaddress.</p><p>This is how <code>cVirtualToReal()</code> works: <code>cVirtualToReal()</code> examines the TID to findout the slot (call it slot s) associated with the TID. <code>cVirtualToReal()</code> looksat the iccm communications area of slot s looking at <code>MapCnt</code>, <code>MapPtr</code>, and<code>MapChk</code>. (Please refer to iccmDefs.h or iccmDefs.a in the iccm communicationsarea record ca_Rec.)</P><P>If <code>MapCnt</code> is zero, the virtual address is assumed to be the same as the NuBusaddress. In this case, <code>cVirtualToReal()</code> sets the returned NuBus address valueto be that of the virtual address and returns the size the same as the size oninput.</p><p>If <code>MapCnt</code> is nonzero, the slot either has an address scheme where the virtualaddress that the TID on slot s uses cannot be the same as the NuBus address(say the processor was a 68020 with no PMMU and required that local cardaddresses have zero for the high address byte) or the slot has something likeVM (which is what happens on the main logic board). <code>cVirtualToReal()</code> will usethe address map pointed to by MapPtr on slot s to try to resolve the virtualaddress to a NuBus address. MapPtr is a pointer to a linked list of structAddrMap (defined in os.h or os.a). If <code>cVirtualToReal()</code> can resolve the virtualaddress by looking at the <code>AddrMap</code> entries, it will do so. If <code>cVirtualToReal()</code>cannot, it will return zero for the size. The <code>MapChk</code> and <code>MapCnt</code> variables in<code>ca_Rec</code> are used for concurrency. <code>cVirtualToReal()</code> will fetch a pointer from the<code>MapPtr</code> structure and then check to see if <code>MapChk</code> has changed. <code>cVirtualToReal()</code>knows that the pointers in <code>MapPtr</code> and the AddrMap entry have not changed ifMapChk has not changed. <code>cVirtualToReal()</code> starts its search over at thebeginning of the <code>MapPtr</code> list should <code>MapChk</code> change. <code>cVirtualToReal()</code> knows thatit can start searching the <code>MapPtr</code> list only when MapCnt equals <code>MapChk</code>.</p><p>What <code>cLockRealArea()</code> does is take as input a virtual address and size andreturns on output the NuBus address/length pairs associated with that virtualaddress and size. <code>cLockRealArea()</code> also returns a success/failure statusindicating if <code>cLockRealArea()</code> successfully "locked" the pages in memoryassociated with the virtual address and size.</p><p>Please note: There is a <code>cLockRealArea()</code> on the main logic board used to lockmemory on the main logic board. There is also a <code>cLockRealArea()</code> in the A/ROSEkernel on the NuBus card which WOULD lock memory on the NuBus card. The<code>cLockRealArea()</code> on the NuBus card acts as a no-op at this moment and is presentfor compatibility reasons.</p><p>Here's a description of how <code>cLockRealArea()</code> works: <code>cLockRealArea()</code> on a NuBuscard acts as a no-op. <code>cLockRealArea()</code> on a NuBus card returns a NuBusaddress/length pair as one would expect but otherwise does nothing.</p><p><code>cLockRealArea()</code> on the main logic board is much more interesting.<code>cLockRealArea()</code> on the main logic board tries to lock down the pages associatedwith the virtual address/size (assuming a PMMU is present and the appropriatea_line traps are present) calling either <code>_LockMemory</code> or <code>_LockMemoryContiguous</code>.Next, if <code>_LockMemory</code> or <code>_LockMemoryContiguous</code> works, <code>cLockRealArea()</code> tries tocreate an AddrMap entry to store the NuBus addresses associated with thevirtual address. <code>cLockRealArea()</code> needs to call <code>_LockMemoryContiguous</code> on thisAddrMap entry to lock it down as well. Finally, if <code>cLockRealArea()</code> has made itthis far, <code>cLockRealArea()</code> will try to insert the AddrMap entry into the linkedlist pointed to by <code>MapPtr</code> in the iccm communications area ca_Rec.<code>cLockRealArea()</code> will change <code>MapChk</code>, insert the AddrMap entry, and then changeMapCnt to be the same value as <code>MapChk</code>.</p><p>What <code>cNetCopy()</code> does is take as input a source TID/source address, destinationTID/destination address, and size. <code>cNetCopy()</code> calls <code>cVirtualToReal()</code> to convertthe source TID/source address and the destination TID/destination address intoNuBus addresses. If <code>cVirtualToReal()</code> can convert the addresses, <code>cNetCopy()</code> willperform a blockmove() operation moving the data itself. If <code>cVirtualToReal()</code>cannot convert the addresses, <code>cNetCopy()</code> will send an A/ROSE IPC message to theNuBus slot (please note that the main logic board is NuBus slot zero) askingthe iccm (please note that iccm is built into the A/ROSE driver on the mainlogic board) to perform the copy. Iccm will perform the copy and send a replyback to <code>cNetCopy()</code> when the copy is complete.</p><p>At this moment, the only slot that can have virtual addresses that<code>cVirtualToReal()</code> cannot convert to NuBus addresses are main logic boardaddresses. <code>cVirtualToReal()</code> can always resolve virtual addresses that exist onNuBus cards.</p><p>If the user on the Macintosh Operating System side does not use <code>LockRealArea()</code>and PMMU is believed to be active, an A/ROSE IPC message is sent from the NuBuscard to the iccm portion of the A/ROSE driver on the main logic board toperform the copy. The iccm portion of the A/ROSE driver will send back a replywhen it has performed the copy.</p><p>One unasked question is could the card request that memory on the main logicboard be locked down from the card. The answer to this question is NO. The<code>LockRealArea()</code> routine on the main logic board that does the locking down ofmemory on the main logic board associates the memory that it is locking downwith the TID of the main logic board process that is calling <code>LockRealArea()</code>.</p><h2>NuBus '90 and MCP card timing</h2><P>Date Written:  8/28/91</p><P>Last reviewed:  6/14/93</p><p>The Macintosh Coprocessor (MCP) card uses the NuBus 10 MHz clock for the systemclock and the NuBus'90 clock is 20 MHz, so how can the cards continue to work?The 68000 isn't rated for 20 MHz. Is there a new pinout for NuBus'90 thatprovides both clocks?</p>___<P>The NuBus'90 CLK signal (pin C32) is 10 MHz (didn't change); the 20 MHz clocksignal is the CLK2X signal, which is pin B24 (previously -5.2 Volts).</p><h2>Dynamically downloaded A/ROSE task specifications</h2><P>Date Written:  2/25/92</p><P>Last reviewed:  6/14/93</p><p>How does a dynamically downloaded A/ROSE task specify its stack size, heapsize, execution priority?</p>___<P>You'll note from the description of the <code>DynamicDownload</code> function as describedin the <i>Macintosh Coprocessor Platform Developer's Guide,</i> page 8-8, thata pointer to an <code>RSM_StartTask</code> parameter area is required. The caller mustinitialize the following fields:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  st_parmblock-&gt;stack  st_parmblock-&gt;heap  st_parmblock-&gt;priority</pre>	</TD></TR></TABLE></CENTER><p>The dynamic download process uses these fields of the RSM (Remote StartManager) parameter block when initializing an A/ROSE task.</p><h2>Dynamically downloaded A/ROSE task startup</h2><P>Date Written:  2/25/92</p><P>Last reviewed:  6/14/93</p><p>When an A/ROSE task is downloaded dynamically, how and when is it started up?</p>___<P>The quick answer is that such a task is started before the download routinereturns. A more complete answer can be made by perusing the Portable A/ROSEcode available on the Developer CD. When a dynamic download call is processed,some preflighting work is performed by the download routine in the A/ROSE Prepfile. A/ROSE first checks that a card capable of running A/ROSE exists in thedesignated slot.</p><p>A/ROSE then checks via the Remote System Manager (RSM) to determine if there issufficient memory on the target board to process the download. The memory isallocated via RSM for the new task, and a copy of the <code>ST_PB</code> is made into theuser area, for processing the download. The register blocks are theninitialized. A message is sent to RSM to perform the <code>RSM_StartTask</code> procedure.When RSM processes the message, a call is made to NetCopy to copy the ST_PBrecord onto the card. There's some more preflighting of the <code>ST_PB</code>, whichresults in a call to the <code>StartTask</code> Instruction Trap. <code>StartTask</code>, as shown in thefile ostrap.a from Portable A/ROSE, ensures that the call did not originatefrom an interrupt. The task table is searched for an available entry. When oneis found, memory is allocated for the process, heap, and stack if specified.Some additional processing is performed to set up the task. Finally, the taskis linked into a priority table and the task becomes "live."</p><p>As documented, the download process returns the TID of the task, if successful.It should be noted that while the task has been started, the task still needstime to perform initialization and any Name Manager registration before a<code>LookupTask</code> call is made.</p><p>The code available on the Portable A/ROSE disk is a good source for learningthe details on this function.</p><h2>FreeMem and FreeMsg don't set pointers to zero</h2><P>Date Written:  2/25/92</p><P>Last reviewed:  6/14/93</p><p>Do the A/ROSE functions <code>FreeMem</code> and <code>FreeMsg</code> set the pointers to zero or does anA/ROSE task calling these functions have to do so explicitly?</p>___<P><code>FreeMem</code> and <code>FreeMsg</code> do not set the pointers to zero upon return. Your processmust do so explicitly if you plan to check whether a message block is valid.</p><h2>Net_Register_Task same as Register_Task(..., World_Visible)</h2><P>Date Written:  2/25/92</p><P>Last reviewed: 6/14/93</p><p>What's the difference between the A/ROSE Net_Register_Task andRegister_Task(..., World_Visible)?</p>___<P>There's no difference between the two calls. When A/ROSE was first beingdeveloped, a design specification under investigation was to have <code>NetCopy</code>perform as its name suggests - to copy data across the network. This featureproved difficult to implement. The functions became limited to copying databetween the motherboard and installed NuBus cards. To transmit A/ROSE messagesacross the network, refer to Chapter 11 in the <i>Macintosh CoprocessorPlatform Programmer's Guide</i> for a description of the Forwarder mechanismand a sample program demonstrating this capability.</p><h2>A/ROSE mCode value isn't incremented for unknown messages</h2><P>Date Written:  2/25/92</p><P>Last reviewed:  6/14/93</p><p>With an unknown A/ROSE message, is mCode incremented by 1 before sending itback to the sender (assuming, of course, the current task is not the sender)?</p>___<P>For unknown messages, the <code>mCode</code> value is not incremented. The message code issimply OR'd with 0x8000.</p><p>Reference:</p><P><i>Macintosh Coprocessor Platform Programmer's Guide,</i> page 3-15</p><h2>Setting A/ROSE mCode or mStatus on receiving a message</h2><P>Date Written:  2/25/92</p><P>Last reviewed:  6/14/93</p><p>Should an A/ROSE server-like task (a task that loops waiting for messages, butdoesn't originate messages) switch on <code>mCode</code> or <code>mStatus</code> when a message arrives?In other words, which should be checked first when getting a message--<code>mCode</code> or<code>mStatus</code>? In addition, if <code>mCode</code> is a known code, but the status is nonzero,should the message be discarded (ignored)?</p>___<P>Your program could certainly do either; however, it would seem more normal toswitch on mCode first, then take a look at the status. This style correspondsto the layout of the Programmer's Guide and would make the code easier tofollow by someone else.</p><p>As for discarding the message, the question posed is not clear. If <code>mStatus</code> isnonzero, some error has occurred and needs to be dealt with. However, otherprocessing could be performed with the same message block allocated. Forexample, you might have a loop that queries the existence of the ICCM on eachcard. If an error is returned, the task would know that there is no MacintoshCoprocessor Platform card in the designated slot, or that A/ROSE has not beeninitialized on the installed card. The task would increment the slot countervariable and continue to query the next card. When the loop is finished, aFreeMsg call would be made.</p><h2>NetCopy &amp; mDataPtr buffer address if A/ROSE IsLocal TRUE</h2><P>Date Written:  2/25/92</p><P>Last reviewed:  6/14/93</p><p>If IsLocal returns TRUE, can a task avoid calling <code>NetCopy</code> and access themDataPtr buffer address directly and at will? </p>___<P>How about a yes/no answer. If IsLocal returns TRUE, then your process canbypass the <code>NetCopy</code> procedure; however, you cannot access the <code>mDataPtr</code> bufferaddress directly without first checking that you are dealing with a physicaladdress on the main logic unit. For example, your process may be running on aMacintosh IIci or IIsi, which have "interesting" memory maps where the virtualaddresses do not correspond to the physical ones. In such cases, refer to theTechnote "Coping with VM and Memory Mappings."</p><h2>A/ROSE LockRealArea call</h2><P>Date Written:  2/25/92</p><P>Last reviewed:  6/14/93</p><p>When does the A/ROSE LockRealArea call really need to be used? Is it compatiblewith virtual memory and System 7.0?</p>___<P>LockRealArea is provided as a Prep routine and is used by routines on themotherboard to prevent System 7 virtual memory from paging an important bufferout from under a process like <code>NetCopy</code>. <code>LockRealArea</code> was designed forcompatibility with virtual memory and System 7.0.</p><p><code>LockRealArea</code> performs two functions. First, it makes it possible for a <code>NetCopy</code>call made by any NuBus card task to access the main logic board memory.Secondly, it calls either the Macintosh Operating System virtual memorydispatch trap <code>_LockMemory</code> if <code>LockRealArea</code> was called with a physicaladdress/length pair count greater than one, or <code>_LockMemoryContiguous</code> ifLockRealArea was called with a physical address/length pair count equal toone.</p><p><code>_LockMemory</code> and <code>_LockMemoryContiguous</code> in turn perform two functions. Bothrequests ensure that the virtual memory being locked is placed in physicalmemory and is not pageable. Secondly, both requests make the physical pages ofthe physical memory noncacheable. This second attribute takes care of the"stale" data cache problem that can occur with 68030 and 68040 CPUs.</p><h2>Unregistering A/ROSE task names</h2><P>Date Written:  2/25/92</p><P>Last reviewed:  6/14/93</p><p>When an A/ROSE task quits, is it more efficient to unregister that task's nameswith the Name Manager, or just let the Name Manager take care of itautomatically?</p>___<P>For tasks running on cards, A/ROSE will automatically unregister all namesassociated with a given task when either StopTask is explicitly called or yourtasks main() [as specified in the StartTask call] is returned from.</p><p>For tasks running on the motherboard, A/ROSE will <i>not </i>automaticallyunregister the names. This is because the task is an application, driver, VBL,etc., first, and an A/ROSE task second. In all cases it isn't clear when thetask is finished. It's the task's responsibility to unregister names associatedwith tasks running on the motherboard.</p><p>In regard to efficiency, the answer is that it is more efficient for the taskto allow the Name Manager to unregister the names for it. The Unregisterfunction will be called in all cases at termination (even if you explicitlyunregister), so a duplicate function call can be avoided. Again, this<i>only</i> applies to tasks on the card! On the motherboard you must<i>explicitly</i> call <code>Unregister</code>.</p><h2>A/ROSE task interrupts</h2><P>Date Written:  2/25/92</p><P>Last reviewed:  6/14/93</p><p>What can or cannot be done at interrupt time in an A/ROSE task or an A/ROSEprocess running on the motherboard?</p>___<P>On the motherboard, you must refrain from doing anything that results in memorymovement or allocation. In addition, you should not call <code>KillReceive</code> from aninterrupt routine. A race condition could result --the <code>KillReceive</code> may not getdone or done at the wrong time.</p><p>On the card, you should not call <code>StartTask</code>, <code>StopTask</code>, or <code>Receive</code> from aninterrupt routine. Please note that <code>RegisterTask</code>, <code>LookupTask</code>, and <code>printf</code> call<code>Receive</code> in their code, and as such, cannot be done from an interrupt routine.</p><p>Here are some additional caveats that you should be aware of with regard toISRs (Interrupt Service Routines):</p><p>On the card, you probably do not want to call <code>GetTID</code>. If you call <code>GetTID</code> duringinterrupt time, you'll get the <code>TID</code> of the currently executing A/ROSE task,which is probably <i>not</i> the <code>TID</code> of the A/ROSE task which installed yourinterrupt routine. It is best for your task which installs your interruptroutine to save the TID in a memory location for your interrupt routine.</p><p>On the card, you should note that if you do a <code>GetMsg</code> request, the <code>mFrom</code> fieldin the A/ROSE message will not be what you expect. You might expect the <code>mFrom</code>field to be your task which installed the interrupt routine. The <code>mFrom</code> fieldwill be set to what <code>GetTID()</code> would return.</p><p>One final caveat and this one is hard to explain. This caveat concernsperformance. To achieve a fast level of real-time latency, the card'sprimitives, like <code>Send</code> and <code>GetMsg</code> and <code>FreeMsg</code>, try to disable interrupts for asshort a time as possible. However, if an interrupt routine calls <code>Send</code>, <code>Send</code><i>cannot</i> lower the interrupt level below whatever called it. For example,suppose an interrupt routine at interrupt level 2 calls <code>Send</code>; <code>Send</code><i>cannot</i>  lower its interrupt level below 2 to zero; an interrupt at level1 or another interrupt at level 2 might be pending, causing confusion for theinterrupt routine. It's best for the interrupt routine to lower its interruptlevel when safe before calling <code>Send</code>.</p><p>Should the interrupt routine need an A/ROSE message buffer, it's best for thetask that installed the interrupt routine to preallocate message buffers bycalling <code>GetMsg</code>, refill the supply as needed, and place pointers to thesemessage buffers in an area for the interrupt routine to use. Normally, theinterrupt routine will want to send an A/ROSE IPC message to the task to wakeit up.</p><p>DTS recommends the following logic for such a wakeup scenario:</p><ol type="1" start="1">	<li>Have the task do a <code>GetMsg</code>, set up this message so the mTo field is that of this task and this message has a task-defined <code>mCode</code>, and save the address of the message buffer in a variable called <code>messagePointer</code>. This effectively creates an A/ROSE IPC message that you will recognize as the wakeup message from the interrupt routine.</li>	<li>Have the task install the interrupt routine.</li>	<li>When the interrupt routine is invoked, have it do whatever is necessary at its interrupt level. Then, have the interrupt routine get the value from <code>messagePointer</code> into a register (like D1) and zero <code>messagePointer</code>. Have the interrupt routine lower its interrupt level to the previous interrupt level found on the stack. If D1 is zero, you're done. Exit the interrupt routine by doing <code>JMP PostRTE</code>. If D1 is nonzero, D1 contains the address of the wakeup message; call <code>Send</code> to send the A/ROSE IPC message to wake up the task.</li>	<li>When the task receives the wakeup message, which it recognizes by the <code>mCode</code>, the task can store the address of the wakeup message in <code>messagePointer</code>. Then, the task can look for information left by the interrupt routine on what the task should do. The task must be prepared to find multiple things to do or nothing to do.</li></ol>         <a name=Downloads></A>                  <P><A HREF="#top">Back to top</A></p><h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (53K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/pt_505.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/pt/pt_505.html%3Fid%3DDTS10002694-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/pt/pt_505.html%3Fid%3DDTS10002694-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/pt/pt_505.html%3Fid%3DDTS10002694-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>