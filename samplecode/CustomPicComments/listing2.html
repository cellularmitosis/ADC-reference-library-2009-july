<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>CustomPicComments - /CustomPC:B.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">CustomPicComments</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">CustomPicComments</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/CustomPC:B.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CarbonPrefix.h</option>
<option value="listing2.html">/CustomPC:B.c</option></select>
				</p>
				</form>
				<p><strong><a href="CustomPicComments.zip">Download Sample</a></strong> (&#147;CustomPicComments.zip&#148;, 21.8K)<BR>
<strong><a href="CustomPicComments.dmg">Download Sample</a></strong> (&#147;CustomPicComments.dmg&#148;, 83.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    CustomPC/B.c  Contains:  Sample showing how to implement custom PicComments and QuickDraw bottlenecks.         See the ReadMe for code details.  Written by:     Copyright:  Copyright &copy; 1991-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        08/2000      JM    Carbonized, non-Carbon code is commented out                    for demonstration purposes.        7/9/1999    KG    Updated for Metrowerks Codewarror Pro 2.1        03/97  v. 2.0  ik    Rewritten as 'Custom PicComments/Bottlenecks'        10/91  v. 1.0  dh    Shipped as 'DTS Groupies' sample.        */#include &quot;CarbonPrefix.h&quot;#include &lt;Dialogs.h&gt;#include &lt;Fonts.h&gt;#include &lt;Menus.h&gt;#include &lt;Devices.h&gt;#include &lt;Resources.h&gt;/*------ constants --------------------------------------------------------------------------*/#define kCreatorType  'EGAD'    /* Our creator type.        */#define rMenuBar    128      /* The menubar resource ID.      */#define mApple      128      /* Apple menu ID.          */#define iAbout      1      /* &quot;About&quot; menu item index.    */#define mFile      129      /* File menu ID.          */#define iQuit      1      /* Quit menu item index.      */#define kMaxPICTs    50      /* Max. no. of pictures we handle.  */#define kCustomComment  100      /* Custom PicComment indicator.    */#define kSubPICTComment  200      /* Our (sub-picture) sub-PicComment.                     This comment indicates that we've                     stored a picture inside of a                     picture.  We use it to extract                     the individual PICTs.      *//*------ types --------------------------------------------------------------------------*/typedef struct TPICTRec {  int      numPICTs;      /* The number of sub-pictures,     */  PicHandle  picture[kMaxPICTs];  /* and their PicHandles,      */  Rect    curPos[kMaxPICTs];  /* and their last drawn positions.  */} TPICTRec;/*------ globals --------------------------------------------------------------------------*/static TPICTRec    gPICTRec;    /* Our global picture record.    */static Rect      gPictsBounds;  /* The bounds used by our pictures.  */static Boolean    gQuitting;    /* &quot;Quitting?&quot; flag.        */static WindowPtr  gTheWindow;    /* Our window's pointer.      *//*------ prototypes ------------------------------------------------------------------------*//*extern void      CompositePictures(void);//extern pascal void  CustomPicProc(int kind, int dataSize, Handle dataHandle);extern pascal void  CustomPicProc(short kind, short dataSize, Handle dataHandle)extern void      DisassemblePictures(void);extern void      DoMenuCommand(long menuResult);extern void      EventLoop(void);extern void      MoveThePicts(Rect *wBounds);extern void      MakeThePicts(void);extern void      ShowThePicts(void);*/void      CompositePictures(void);pascal void     CustomPicProc(short kind, short dataSize, Handle dataHandle);void      DisassemblePictures(void);void      DoMenuCommand(long menuResult);void      EventLoop(void);void      MoveThePicts(Rect *wBounds);void      MakeThePicts(void);void      ShowThePicts(void);/*------ CompositePictures ----------------------------------------------------------------*///  CompositePictures groups all of the pictures in the global picture record//  into one &quot;composite&quot; picture.  It removes all of the old pictures and//  stores the new one./*----------------------------------------------------------------------------------------*/void CompositePictures(){  PicHandle  aPICT, groupPICT;  RgnHandle  oldClip;  int      idx;  long    dataSize;  long    ownerApp;  short    localPicComment;/*  Save the old clipping region, and set a valid one so our grouped  picture develops ok.                        */  oldClip = NewRgn();  GetClip(oldClip);  ClipRect(&amp;gPictsBounds);  groupPICT = OpenPicture(&amp;gPictsBounds);/*  Create a picture to contain all the other ones, then draw those into  it, separated by our PicComments.  Kill the individual pictures as  we go.  Finally, close the composite picture.            */  ownerApp = kCreatorType;  localPicComment = kSubPICTComment;  for(idx = 0; idx &lt; gPICTRec.numPICTs; idx++)  {    aPICT = gPICTRec.picture[idx];/*  We don't just use a single custom PicComment since another app may  use the same comment and conflicts could result.  (Not in this app,  but in the real world.)  We add six bytes to the handle and store the  creator type of the app that made the picture followed by 2 bytes  for a local PicComment kind within the app.  If we used more than  one PicComment in this app, this extra information would be  necessary.                              */    dataSize = GetHandleSize((Handle) aPICT) +6;    SetHandleSize((Handle) aPICT, dataSize);    BlockMove((Ptr) *aPICT, (Ptr) *aPICT +6, dataSize -6);    BlockMove(&amp;ownerApp, (Ptr) *aPICT, 4);    BlockMove(&amp;localPicComment, (Ptr) *aPICT +4, 2);    PicComment(kCustomComment, dataSize, (Handle) aPICT);/*  Fix the original PicHandle so that we can draw our picture for apps  that don't know about our custom comments.              */    BlockMove((Ptr) *aPICT +6, (Ptr) *aPICT, dataSize -6);    SetHandleSize((Handle) aPICT, dataSize -6);    DrawPicture(aPICT, &amp;(*aPICT)-&gt;picFrame);    KillPicture(aPICT);    gPICTRec.picture[idx] = NULL;  }  ClosePicture();/*  Restore the original clipping region and update our global picture  record so that we have one consolidated picture, in the first slot.  We set it's current position to (0, 0, 0, 0) so that we don't waste  time erasing anything on the first draw.              */  SetClip(oldClip);  DisposeRgn(oldClip);  gPICTRec.numPICTs = 1;  gPICTRec.picture[0] = groupPICT;  SetRect(&amp;gPICTRec.curPos[0], 0, 0, 0, 0);}/*------ CustomPicProc ----------------------------------------------------------------*///    CustomPicProc is our replacement for the port's StdCommentProc.//     in the global picture record/*----------------------------------------------------------------------------------------*///pascal void CustomPicProc(int kind, int dataSize, Handle dataHandle)pascal void CustomPicProc(short kind, short dataSize, Handle dataHandle){  int      nextNum;  long    ownerApp;  short    localPicComment;  Handle    theHandle;/*  If this is a custom PicComment, see if it's ours.  In this app,  we know it always will be, but when you import other pictures  you can't be so sure.                        */  if (kind == kCustomComment &amp;&amp; (gPICTRec.numPICTs &lt; kMaxPICTs))  {    if (dataSize &lt; 6) return;            /* Not ours?  */        BlockMove((Ptr) *dataHandle, &amp;ownerApp, 4);    BlockMove((Ptr) *dataHandle +4, &amp;localPicComment, 2);    if ((ownerApp != kCreatorType) ||        /* Not ours?  */        (localPicComment != kSubPICTComment)) return;/*  This is indeed our picture comment.  Create a handle for the data we  found, store it in our global picture record and bump the number of  pictures we have.  The reason that we clear the picture's curPos  rect is so that we won't waste time erasing anything the first time  we enter MoveTheGroupies.                      */    nextNum = gPICTRec.numPICTs;    gPICTRec.picture[nextNum] = (PicHandle) dataHandle;    SetRect(&amp;gPICTRec.curPos[nextNum], 0, 0, 0, 0);/*  After we create the handle for the data, we have to remember that  we have 6 bytes of identifying &quot;garbage&quot; in front of the picture  data.  To remove that, BlockMove all the picture data to the  beginning of the handle and reset the handle's size.  This is kind  of a hassle, but it's really best to store your custom PicComments  this way.  Otherwise, you may misinterpret someone elses comments  or cause them to misinterpret yours.                */    if (HandToHand((Handle *) &amp;gPICTRec.picture[nextNum]) == noErr)    {      ++gPICTRec.numPICTs;      theHandle = (Handle) gPICTRec.picture[nextNum];      BlockMove((Ptr) *theHandle +6, (Ptr) *theHandle, dataSize -6);      SetHandleSize(theHandle, dataSize -6);    }  }}/*------ DisassemblePictures ----------------------------------------------------------------*///  DisassemblePictures ungroups the first picture in the global picture//  record.  It replaces that picture with new pictures of every picture//  it contained.  All drawing is done within another &quot;dummy&quot; picture//  so that nothing draws on the screen. The reason we can't use an empty//  clipping region to do this is that PicComments will be clipped out along//  with everything else, and we'd be hosed.  (We need the PicComments!)  //  This code is written so that it installs the GrafProcs correctly for//  both GrafPorts and CGrafPorts./*----------------------------------------------------------------------------------------*/void DisassemblePictures(){  GrafPtr    curPort;  //QDProcs    theQDProcs;    /* If we're using a GrafPort\xC9      */  CQDProcs  theCQDProcs;  /* If we're using a CGrafPort\xC9      */  PicHandle  dummyPICT;/*  Reset the number of pictures in our global picture record to zero.  There's actually one picture there at this point (the composite  one), but we must set this to zero so that our PicComment handler  stores extracted pictures in the right place.            */  gPICTRec.numPICTs = 0;/*  Get the current port and the standard QDProcs or CQDProcs,  depending on whether we have a GrafPort or CGrafPort.        */  GetPort(&amp;curPort);  //if (curPort-&gt;portBits.rowBytes &lt; 0)        /* CGrafPort\xC9    */  if (GetPortBitMapForCopyBits(curPort)-&gt;rowBytes &lt; 0)  {    SetStdCProcs(&amp;theCQDProcs);    theCQDProcs.commentProc = NewQDCommentProc(CustomPicProc);    //curPort-&gt;grafProcs = (QDProcsPtr) &amp;theCQDProcs;    SetPortGrafProcs(curPort, &amp;theCQDProcs);  }  else                      /* GrafPort\xC9    */  {    /*SetStdProcs(&amp;theQDProcs);    theQDProcs.commentProc = NewQDCommentProc(CustomPicProc);    //curPort-&gt;grafProcs = (QDProcsPtr) &amp;theQDProcs;    SetPortGrafProcs(curPort, &amp;theQDProcs);*/      }/*  Open our dummy picture and draw into it so that our PicComment  handler is called to parse the picture.  When finished, close the  picture, kill it and remove our grafProcs.              */  dummyPICT = OpenPicture(&amp;(*gPICTRec.picture[0])-&gt;picFrame);  DrawPicture(gPICTRec.picture[0], &amp;(*gPICTRec.picture[0])-&gt;picFrame);  ClosePicture();  KillPicture(dummyPICT);  //curPort-&gt;grafProcs = NULL;  SetPortGrafProcs(curPort, NULL);}/*------ DoMenuCommand ----------------------------------------------------------------*///    DoMenuCommand handles our menu items./*----------------------------------------------------------------------------------------*/void DoMenuCommand(long menuResult){  int      menuID, menuItem;  //Str255    daName;  /*MenuHandle  theMenu;*/  //GrafPtr    savePort;/*  Get the menu ID and item ID.      */  menuID = (menuResult &gt;&gt;16) &amp; 0xFFFF;  menuItem = menuResult &amp; 0xFFFF;/*  Do what we're supposed to.        */  switch (menuID)  {    case mApple:            /*  Apple Menu          */      switch (menuItem)      {        case iAbout:        /*  -&gt; Handle &quot;About&quot;      */          break;        default:          /*  -&gt; The rest are DAs.    */          /*GetPort(&amp;savePort);          GetMenuItemText(GetMenuHandle(mApple), menuItem, daName);          OpenDeskAcc((ConstStr255Param)daName);          SetPort(savePort);*/          break;      };    case mFile:              /*  File Menu          */      switch (menuItem)      {        case iQuit:          gQuitting = true;    /*  -&gt; Quit            */          break;      }  }  HiliteMenu(0);}/*------ EventLoop ----------------------------------------------------------------*///    EventLoop is a main event loop.  It calls WaitNextEvent and//    other nice stuff.  It also makes our pictures assemble, disassemble, //    and move about./*----------------------------------------------------------------------------------------*/void EventLoop(){  EventRecord    theEvent;  WindowPtr    whichWindow;  short      partCode;  Rect      dragRect;  RgnHandle    grayRgn;  char      key, time;  unsigned long  finalTicks;  Rect      tempRect1;/*  Set up the rectangle for where we can drag windows.  Initialize  our &quot;time-through-the-loop&quot; counter to -1 so that it gets bumped  to zero on the first pass.  This will enable us assemble the  grouped picture as we go through the first time.            */  grayRgn = GetGrayRgn();  //dragRect = (*grayRgn)-&gt;rgnBBox;  GetRegionBounds(GetGrayRgn(), &amp;dragRect);  time = -1;/*  We have a counter which goes from 0-26 and is incremented each time  we go through this code. At time = 0, We assemble the grouped image.  At time = 12, we break all the PICTs out of it.  At time = 27, we  cycle back to time = 0.  In between these life altering times,  (at least for groupies), we draw all of our current pictures in  random places.  This clearly shows whether the PICTs are currently  grouped or not.  We go through this loop until the user quits.      */  do  {    //SetPort(gTheWindow);    SetPortWindowPort(gTheWindow);    time = ++time % 27;       if (time == 0)    {      CompositePictures();      /*  Group the pictures.        */      //EraseRect(&amp;(gTheWindow)-&gt;portRect);      EraseRect(GetPortBounds(GetWindowPort(gTheWindow), &amp;tempRect1));    }     if (time == 12)    {      DisassemblePictures();    /*  Ungroup the pictures.      */      //EraseRect(&amp;(gTheWindow)-&gt;portRect);      EraseRect(GetPortBounds(GetWindowPort(gTheWindow), &amp;tempRect1));    }/*  Move all pictures so we can see their current state.          */    //MoveThePicts(&amp;(gTheWindow)-&gt;portRect);    MoveThePicts(GetPortBounds(GetWindowPort(gTheWindow), &amp;tempRect1));/*  Delay so our graphics don't flash.                    */    Delay((time &lt; 12)? 40:10, &amp;finalTicks);  /*  Handle any pending events.                        */    if (WaitNextEvent(everyEvent, &amp;theEvent, 0, NULL))      switch (theEvent.what)      {        case mouseDown:          /*  Handle mouse clicks.  */                  partCode = FindWindow(theEvent.where, &amp;whichWindow);          switch (partCode)          {            case inContent:              if (whichWindow != FrontWindow())                SelectWindow(whichWindow);              break;              case inDrag:              DragWindow(whichWindow, theEvent.where, &amp;dragRect);              break;              case inMenuBar:              DoMenuCommand(MenuSelect(theEvent.where));              case inSysWindow:              //SystemClick(&amp;theEvent, whichWindow);              break;          }          break;          case updateEvt:          /*  Handle update events.  */            BeginUpdate((WindowPtr) theEvent.message);            EndUpdate((WindowPtr) theEvent.message);          break;        case keyDown:          /*  Handle key presses.    */        case autoKey:           key = (char) (theEvent.message &amp; charCodeMask);          if (((theEvent.modifiers &amp; cmdKey) != 0) &amp;&amp; (theEvent.what == keyDown))            DoMenuCommand(MenuKey(key));          break;      }  }  while (!gQuitting);}/*------ MoveThePicts ----------------------------------------------------------------*///  MoveThePicts moves the current pictures\xC9 somewhere randomly.  It//  first erases all the pictures in descending order.  Then it redraws//  them in new locations in ascending order. This way we don't wipe out//  any of the new pictures when the old ones are erased./*----------------------------------------------------------------------------------------*/void MoveThePicts(Rect *wBounds){  int    newLeft, newTop, width, height, idx;  float  maxX, maxY;  Rect  picFrame, curPos;/*  First erase all pictures in reverse order.  Also, calculate their  new locations and store those in their curPos fields.        */  for (idx = gPICTRec.numPICTs -1; idx &gt;= 0; idx--)  {    curPos = gPICTRec.curPos[idx];    EraseRect(&amp;curPos);    picFrame = (*gPICTRec.picture[idx])-&gt;picFrame;    width = picFrame.right -picFrame.left;    height = picFrame.bottom -picFrame.top;/*  To calculate new positions, we find the maximum position we can  have for the picture's top left corner.  Then, we find a random  point that's bounded by (0, 0) and that maximum.  Finally, we  set this picture's current position so that it has this point for  its top left corner.                        */    maxX = (wBounds-&gt;right - wBounds-&gt;left) -width;    maxY = (wBounds-&gt;bottom - wBounds-&gt;top) -height;        newTop = (((float) Random() +32767)/65534.0) * maxX;    newLeft = (((float) Random() +32767)/65534.0) * maxY;      curPos.top = newTop;    curPos.left = newLeft;    curPos.bottom = newTop +height;    curPos.right = newLeft +width;    gPICTRec.curPos[idx] = curPos;  }/*  Now draw all the pictures in their new positions.          */  for (idx = 0; idx &lt; gPICTRec.numPICTs; idx++)    DrawPicture(gPICTRec.picture[idx], &amp;gPICTRec.curPos[idx]);}/*------ MakeThePicts ----------------------------------------------------------------*///  MakeThePicts creates the pictures that will be grouped.  These can be//  any QuickDraw pictures.  For this example, I use four pictures; one//  containing a square, one with a circle, one with a triangle and one//  with some text.  These are all stored in the global picture record.  //  This routine is only called once, to put some pictures into the works to//  start with./*----------------------------------------------------------------------------------------*/void MakeThePicts(){  RgnHandle  oldClip;  PolyHandle  trianglePoly;  int      fNum, vPos;/*  Save the current clipping region so that we can restore it later.  Set our own clipping region, so that we know we have a valid one.  Also initialize the number of pictures in our global picture  structure to zero.                          */  oldClip = NewRgn();  GetClip(oldClip);  SetRect(&amp;gPictsBounds, 0, 0, 150, 150);  ClipRect(&amp;gPictsBounds);    gPICTRec.numPICTs = 0;/*  Create a picture with a blue square in it.  We set the curPos  rectangle for all of these pictures to (0, 0, 0, 0) so that  we don't do any unnecessary erasing the first time they enter  MoveTheGroupies.                          */  gPICTRec.picture[0] = OpenPicture(&amp;gPictsBounds);  ForeColor(blueColor);  PaintRect(&amp;gPictsBounds);  ClosePicture();  SetRect(&amp;gPICTRec.curPos[0], 0, 0, 0, 0);  ++gPICTRec.numPICTs;/*  Create a picture with a red circle in it.              */  gPICTRec.picture[1] = OpenPicture(&amp;gPictsBounds);  ForeColor(redColor);  PaintOval(&amp;gPictsBounds);  ClosePicture();  SetRect(&amp;gPICTRec.curPos[1], 0, 0, 0, 0);  ++gPICTRec.numPICTs;/*  Create a picture with a green triangle in it.  */  gPICTRec.picture[2] = OpenPicture(&amp;gPictsBounds);  ForeColor(greenColor);  trianglePoly = OpenPoly();  MoveTo(gPictsBounds.left, gPictsBounds.bottom);  LineTo((gPictsBounds.right - gPictsBounds.left)/2, gPictsBounds.top);  LineTo(gPictsBounds.right, gPictsBounds.bottom);  LineTo(gPictsBounds.left, gPictsBounds.bottom);  ClosePoly();  PaintPoly(trianglePoly);  KillPoly(trianglePoly);  ClosePicture();  SetRect(&amp;gPICTRec.curPos[2], 0, 0, 0, 0);  ++gPICTRec.numPICTs;/*  Create a picture with some text in it.  */  gPICTRec.picture[3] = OpenPicture(&amp;gPictsBounds);  ForeColor(blackColor);  GetFNum((ConstStr255Param) &quot;\pTimes&quot;, (short*)&amp;fNum);  TextFont(fNum);  TextSize(12);  TextFont(bold);  vPos = gPictsBounds.top +(gPictsBounds.bottom - gPictsBounds.top)/2;  MoveTo(gPictsBounds.left +10, vPos +10);  DrawString((ConstStr255Param) &quot;\pCustom PicComments&quot;);  ClosePicture();  SetRect(&amp;gPICTRec.curPos[3], 0, 0, 0, 0);  ++gPICTRec.numPICTs;/*  Restore the original clipping region.                */  SetClip(oldClip);  DisposeRgn(oldClip);}/*------ ShowThePicts ----------------------------------------------------------------*///  ShowThePicts starts the show.//  First, we find the deepest display because the groupies are a colorful//  bunch.  Then we create a window and some pictures.  Finally, we jump into//  our main event loop./*----------------------------------------------------------------------------------------*/void ShowThePicts(){  Rect    maxRect, deepRect, wBounds;  GDHandle  deepGDH;/*  Find the bounds of the deepest device.  We'll use this to determine  where to put our window.  Passing the maximum enclosing rectangle  to GetMaxDevice assures that we find the deepest device available.  */  SetRect(&amp;maxRect, -32767, -32767, 32767, 32767);  deepGDH = GetMaxDevice(&amp;maxRect);  deepRect = (*deepGDH)-&gt;gdRect;/*  Create a window for our drawing, offset onto the deepest device.  */    SetRect(&amp;wBounds, 40, 40, 360, 340);  OffsetRect(&amp;wBounds, wBounds.left +deepRect.left, wBounds.top +deepRect.top);  gTheWindow = NewWindow(nil, &amp;wBounds, (ConstStr255Param) &quot;\pCustomPC/B&quot;, true, noGrowDocProc, (WindowPtr) -1, false, 1234);  //SetPort(gTheWindow);  SetPortWindowPort(gTheWindow);/*  Create our pictures to group, then go into the work loop.  This  loop continually groups the pictures, draws the grouped picture  in different locations, ungroups the picture, draws the ungrouped  pictures in different locations and repeats until the user quits.  */    MakeThePicts();  EventLoop();}/*------ CompositePictures ----------------------------------------------------------------*///  CompositePictures groups all of the pictures in the global picture record//  into one &quot;composite&quot; picture.  It removes all the old pictures and//  stores the new one./*----------------------------------------------------------------------------------------*//*  -------------------------------------  main.  -------------------------------------  */void main(void){      unsigned long randSeed;  Handle    menuBar;/*  Initialize the toolbox routines.                  */  //InitGraf(&amp;qd.thePort);  //InitFonts();  //InitWindows();  //InitMenus();  //InitDialogs(nil);  InitCursor();/*  Set up our menubar.                          */  menuBar = GetNewMBar(rMenuBar);    /*  Read menus into menu bar  */  SetMenuBar(menuBar);        /*  and install them.      */  DisposeHandle(menuBar);    //AppendResMenu(GetMenuHandle(mApple), 'DRVR');  DrawMenuBar();/*  Initialize the random number seed for our hopping groupies and set  our quitting flag to false.  Call the routine that runs everything,  then, quit.                              */    GetDateTime(&amp;randSeed);    gQuitting = false;    ShowThePicts();}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/CustomPicComments/listing2.html%3Fid%3DDTS10000080-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/CustomPicComments/listing2.html%3Fid%3DDTS10000080-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/CustomPicComments/listing2.html%3Fid%3DDTS10000080-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>