<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ClutWind - /CLUTSample.a</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">ClutWind</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ClutWind</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/CLUTSample.a</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CLUTSample.a</option>
<option value="listing2.html">/CLUTSample.h</option>
<option value="listing3.html">/CLUTSample.inc1.a</option>
<option value="listing4.html">/CLUTSample.r</option>
<option value="listing5.html">/CLUTSampleMisc.a</option></select>
				</p>
				</form>
				<p><strong><a href="ClutWind.zip">Download Sample</a></strong> (&#147;ClutWind.zip&#148;, 25.6K)<BR>
<strong><a href="ClutWind.dmg">Download Sample</a></strong> (&#147;ClutWind.dmg&#148;, 81.9K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">**  Apple Macintosh Developer Technical Support***  CLUTSample***     Loosely based in the sample SAMPLE this program shows*     how to create a window and display on it the colors of the CLUT*  associated with the device the window sits on top of.**  Left to the curious reader are some improvements such as, remembering the*  positions of each open window, so if you use this program to monitor your*  color tables it will position the windows in the last place you opened them.*  The treatment of direct devices is kind of 'casual' a better color display may *  be appropriate. Last, it may be desireable to change the size of the color*  rectangles depending on the depth of the color table.*  Check Sample sources for more detailed documentation.* ================================================* -------------- INCLUDES SECTION ----------------* ================================================    PRINT  PUSH,OFF      ; don't print any of this stuff  INCLUDE  'ToolEqu.a'  INCLUDE  'Traps.a'  INCLUDE  'PackMacs.a'  INCLUDE  'QuickEqu.a'  INCLUDE  'SysEqu.a'  INCLUDE  'CLUTSample.inc1.a'    ; all our macros and data templates  PRINT  POP        ; restore the PRINT options  * ================================================* ---------  DATA STORAGE ALLOCATION  ------------* ================================================* Global data storage.  All global memory is allocated here.  The* Linker will load all global data offset from A5, and the Asm knows this.* Therefore, no reference to (A5) is required in the code. Hooray!* Here we declare two data structures using our templates defined previously.* They must be EXPORTed here for other files that need to IMPORT them.    EXPORT  (QD,G):DATAQD    DS  MyQDGlobals    ; QuickDraw's globalsG    DS  AppGlobals    ; application's globals* ================================================* ---------  INITIALIZATION PROC  ------------* ================================================    SEG   'Initialize'    ; case sensitiveInitialize  PROC        ; Initialize everythingCountReg  EQU  D4      ; temporary registor to count loopsStackFrame  RECORD  {A6Link},DECR    ; build a stack frame recordParamBegin  EQU  *      ; start parameters after this pointParamSize  EQU  ParamBegin-*    ; size of all the passed parametersRetAddr   DS.L  1      ; place holder for return addressA6Link    DS.L  1      ; place holder for A6 linkCurMBar    DS.L  1      ; local handle to our menubarTheEvent   DS  EventRecord     ; local copy of the event recordLocalSize  EQU   *      ; size of all the local variables    ENDR        IMPORT  GoGetRect,AlertUser,SysEnvirons,  \      OpenClutWind, \      TrapAvailable    ; linked in with Interface.o    WITH  StackFrame    ; cover our local stack frame    LINK  A6,#LocalSize    ; allocate our local stack frame        MOVEM.L  CountReg,-(SP)     ; save the current registor values    MOVE.W  #False,G.InBackground  ; we start out in the foreground    MOVE.W  #True,G.Stopped    ; we'll start with the red light on* ------------- INITIALIZE MANAGERS -------------@1    PEA   QD.thePort     ; initialize all of the Managers    _InitGraf      ; please don't flush my events    _InitFonts    _InitWindows    _InitMenus    _TEInit    CLR.L  -(SP)      _InitDialogs    _InitCursor    * Call MPPOpen and ATPLoad at this point to initialize AppleTalk, if you are using it.* NOTE -- It is no longer necessary, and actually unhealthy, to check PortBUse and* SPConfig before opening AppleTalk. The drivers are capable of checking for port* availability themselves.  This next bit of code is necessary to allow the default* button of our alert be outlined.   * ------------- WASTE THREE EVENTS -------------    MOVE.W  #2,CountReg    ; set register value to loop 3 timesLoop    CLR.W  -(SP)      ; space for result    MOVE.W  #EveryEvent,-(SP)  ; the events we want    PEA  TheEvent(A6)    ; pass a pointer to our event    _EventAvail    MOVE.W  (SP)+,D0    ; result code    DBF  CountReg,Loop    ; decrement count, if count &lt; 0 then continue* ------------- GET THE ENVIRONMENT -------------    CLR.W  -(SP)      ; create space for result    MOVE.W  #EnvironsVersion,-(SP)  ; version of SysEnvirons we want    PEA  G.Mac      ; the global environment record    JSR  SysEnvirons    ; we can ignore any errors here,    MOVE.W  (SP)+,D0    ; SysEnvirons will fill in regardless    MOVE.W  G.Mac.MachineType,D0   ; negitive value means old ROMs    BPL.S  @2      ; 128k ROMs or better, continue on    JMP  AlertUser    ; we don't want to run on 64k ROMs* ------------- TEST FOR WAITNEXTEVENT -------------* 1.02 - Move TrapAvailable call to after SysEnvirons so that* we can tell in TrapAvailable if a tool trap value is out of range.@2    CLR.W  -(SP)      ; space for result of trap test    MOVE.W  #WaitNextEvent,-(SP)  ; pass the trap number of WaitNextEvent trap    BSR  TrapAvailable    ; test for this trap    MOVE.W  (SP)+,G.HasWNEvent  ; put the result in our global flag           MOVE.L  applLimit,D1    ; get pointer to ApplLimit    MOVE.L  applZone,D0    ; get pointer to ApplicZone    SUB.L  D0,D1      ; subtract the ApplicZone from ApplLimit    CMPI.L  #MinHeap,D1    ; do we have enough memory?    BPL.S  @3      ; yes we do, continue on    JMP  AlertUser    ; no, report the error    @3    _PurgeSpace      ; results will be in A0 and D0    CMPI.L  #MinSpace,D0    ; do we have enough purgeable space?    BPL.S  @4    JMP  AlertUser    ; no, report the error* ------------- SET UP THE MENUS -------------  @4    CLR.L  -(SP)      ; space for MenuBar handle    MOVE.W  #rMenuBar,-(SP)    ; our MenuBar resource    _GetNewMBar      ; the modern way, get a MenuBar    MOVE.L  (SP),CurMBar(A6)    _SetMenuBar    MOVEA.L  CurMBar(A6),A0    ; we're done with that handle    _DisposHandle      ; there is a result in D0    CLR.L  -(SP)    MOVE.W  #AppleMenu,-(SP)    _GetMHandle      ; put Apple menu handle on stack    MOVE.L  #'DRVR',-(SP)    ; get all the DAs    _AddResMenu    _DrawMenuBarExit    MOVEM.L  (SP)+,CountReg    ; restore the registors    UNLK  A6      ; destroy the link    MOVEA.L  (SP)+,A0    ; pull off the return address    ADDA.L  #ParamSize,SP    ; strip all of the caller's parameters    JMP  (A0)      ; return to the caller    DbgInfo  Initialz    ; this name will appear in the debugger    ENDP* ================================================* PROCEDURE OpenClutWind();* ================================================    SEG  'Main'      ; case sensitiveOpenClutWind  PROCStackFrame  RECORD  {A6Link},DECR    ; build a stack frame recordParamBegin  EQU  *      ; passed parameter of the window pointerParamSize  EQU  ParamBegin-*    ; size of all the passed parametersRetAddr   DS.L  1      ; place holder for return addressA6Link    DS.L  1      ; place holder for A6 linkLocalSize  EQU   *      ; size of all the local variables    ENDR        IMPORT  DrawClut,NulMouse,OpenWindow    WITH  StackFrame,ClutWData  ; cover our local stack frame    LINK  A6,#LocalSize    ; allocate our local stack frame    Clr.l  -(SP)    Move.W  #rWindow,-(SP)    Move.L  #ClutWDataSize,-(SP)    PEA  DrawClut    PEA  NulMouse    JSR  OpenWindow    MOVE.L  (SP)+,A0Exit    UNLK  A6      ; destroy the link    MOVEA.L  (SP)+,A0    ; pull off the return address    ADDA.L  #ParamSize,SP    ; strip all of the caller's parameters    JMP  (A0)      ; return to the caller    DbgInfo  OpenClutWind    ENDP* ================================================* PROCEDURE DoUpdate(window: WindowPtr);* ================================================* This is called when an update event is received for a window.* It calls DrawWindow to draw the contents of an application window.* As an efficiency measure that does not have to be followed, it* calls the drawing routine only if the visRgn is non-empty. This* will handle situations where calculations for drawing or drawing* itself is very time-consuming.    SEG  'Main'      ; case sensitiveDoUpdate  PROCStackFrame  RECORD  {A6Link},DECR    ; build a stack frame recordParamBegin  EQU  *      ; start parameters after this pointWindowPtr  DS.L  1      ; passed parameter of the window pointerParamSize  EQU  ParamBegin-*    ; size of all the passed parametersRetAddr   DS.L  1      ; place holder for return addressA6Link    DS.L  1      ; place holder for A6 linkLocalSize  EQU   *      ; size of all the local variables    ENDR        IMPORT  IsAppWindow,DrawWindow    WITH  StackFrame    ; cover our local stack frame    LINK  A6,#LocalSize    ; allocate our local stack frame    CLR.W  -(SP)      ; space for result of IsAppWindow    MOVE.L  WindowPtr(A6),-(SP)  ; pass the window pointer    BSR  IsAppWindow    ; test if this window was ours    MOVE.W  (SP)+,D0        CMPI.W  #True,D0    ; it must be our window    BNE.S  Exit      ; it wasn't our window        MOVE.L  WindowPtr(A6),-(SP)  ; update only the visible region    _BeginUpDate      ; region of the window    CLR.W  -(SP)      ; space for result    MOVEA.L  WindowPtr(A6),A0  ; the window pointer    MOVE.L  visRgn(A0),-(SP)  ; the window's visRgn handle    _EmptyRgn    MOVE.W  (SP)+,D0    ; result of EmptyRgn    CMPI.W  #True,D0    ; was the visRgn empty?    BEQ.S  @1      ; yes, then no update is needed        Clr.l  -(SP)    MOVE.L  WindowPtr(A6),-(SP)    _GetWRefCon    Move.l  (SP)+,A2  ; Retrieve handle    Move.l  (A2),A0    ; Deref Handle    Move.l  (A0),A0    ; Get ProcPtr    MOVE.L  WindowPtr(A6),-(SP)    JSR  (A0)    ; draw the window    @1    MOVE.L  WindowPtr(A6),-(SP)  ; get pointer to window    _EndUpdateExit    UNLK  A6      ; destroy the link    MOVEA.L  (SP)+,A0    ; pull off the return address    ADDA.L  #ParamSize,SP    ; strip all of the caller's parameters    JMP  (A0)      ; return to the caller    DbgInfo  DoUpdate    ; this name will appear in the debugger    ENDP* ================================================* PROCEDURE DoActivate(window: WindowPtr; becomingActive: BOOLEAN);* ================================================* In this sample there is no other processing necessary other than what* the Window Manager has already done for us.  This would be the place to* perform an activate on TextEdit records, controls, lists, update GrowIcon, etc.    SEG  'Main'      ; case sensitiveDoActivate  PROCStackFrame  RECORD  {A6Link},DECR    ; build a stack frame recordParamBegin  EQU  *      ; start parameters after this pointWindowPtr  DS.L  1      ; passed parameter of the window pointerActive    DS.W  1      ; modifiers from the event recordParamSize  EQU  ParamBegin-*    ; size of all the passed parametersRetAddr   DS.L  1      ; place holder for return addressA6Link    DS.L  1      ; place holder for A6 linkLocalSize  EQU   *      ; size of all the local variables    ENDR        IMPORT  IsAppWindow    WITH  StackFrame    ; cover our local stack frame    LINK  A6,#LocalSize    ; allocate our local stack frame    CLR.W  -(SP)      ; space for result of IsAppWindow    MOVE.L  WindowPtr(A6),-(SP)  ; pass the window pointer    BSR  IsAppWindow    ; test if this window was ours    MOVE.W  (SP)+,D0    ; get the result    CMPI.W  #True,D0    ; it must be our window    BNE.S  Exit      ; it wasn't our window    CMPI.W  #True,Active(A6)  ; was it an Activate?    BNE.S  DeActivate    ; no, perform a Deactivate    * do the activate event processing here, then &quot;BRA.S   Exit&quot;    DeActivate          ; do the deactivate event* do the deactivate event processing here, then fall through to Exit    Exit    UNLK  A6      ; destroy the link    MOVEA.L  (SP)+,A0    ; pull off the return address    ADDA.L  #ParamSize,SP    ; strip all of the caller's parameters    JMP  (A0)      ; return to the caller    DbgInfo  Activate    ; this name will appear in the debugger    ENDP          * ================================================* PROCEDURE DoMenuCommand(menuResult: LONGINT);* ================================================* This is called when an item is chosen from the menu bar (after calling* MenuSelect or MenuKey). It performs the right operation for each command.* It is good to have both the result of MenuSelect and MenuKey go to* one routine like this to keep everything organized.    SEG  'Main'      ; case sensitiveDoMenuCommand  PROCStackFrame  RECORD  {A6Link},DECR    ; build a stack frame recordParamBegin  EQU  *      ; start parameters after this pointMenuItem  DS.W  1      ; result from _MenuKey or _MenuSelectMenuID    DS.W  1      ; caller passed a long word, ID + ItemParamSize  EQU  ParamBegin-*    ; size of all the passed parametersRetAddr   DS.L  1      ; place holder for return addressA6Link    DS.L  1      ; place holder for A6 linkDeskname  DS.B  256      ; local storage for Desk Accs nameTempPort  DS.L  1      ; local storage for the current portLocalSize  EQU   *      ; size of all the local variables    ENDR        IMPORT  SetLight,DoCloseWindow,Terminate    WITH  StackFrame    ; cover our local stack frame    LINK  A6,#LocalSize    ; allocate our local stack frame    MOVE.W  MenuID(A6),D0    ; a nifty Pascal case-like macro    CASE#.W  (D0,IF),      \      (AppleMenu,  DoAppleMenu),  \      (FileMenu,  DoFileMenu)            ; add additional Menus would go here    BRA.W  Exit      ; otherwise we will exit this procedure* ------------- THE APPLE MENU ROUTINES -------------DoAppleMenu    CMPI.W  #AboutItem,MenuItem(A6)  ; was it the about item?    BNE.S  @1      ; no, must be a Desk Acc    CLR.W  -(SP)      ; show the About dialog    MOVE.W  #rAboutAlert,-(SP)  ; resource for alert dialog    CLR.L  -(SP)      ; no filter procedure used here    _Alert        ; read the resource and display it    MOVE.W  (SP)+,D0    ; I don't care which item is was    BRA.W  Exit      ; all done with with Apple menu@1    PEA  TempPort(A6)    ; open a desk accessory    _GetPort      ; save the current port    CLR.L  -(SP)      ; space for result of GetMHandle    MOVE.W  #AppleMenu,-(SP)    _GetMHandle      ; put Apple menu on stack    MOVE.W  MenuItem(A6),-(SP)  ; and here's the MenuItem    PEA  DeskName(A6)    ; now tell me the DA's name    _GetItem    CLR.W  -(SP)      ; space for OpenDeskAcc result    PEA  DeskName(A6)    _OpenDeskAcc      ; open that puppy    MOVE.W  (SP)+,D0    ; result    MOVE.L  TempPort(A6),-(SP)  ; restore the port    _SetPort    BRA.S  Exit    * ------------- THE FILE MENU ROUTINES -------------DoFileMenu      MOVE.W  MenuItem(A6),D0   ; test the MenuItem    Case#.W  (D0,IF),      \      (NewItem,  FileNew),  \      (CloseItem,  FileClose),  \      (QuitItem,  FileQuit)    BRA.S  Exit      ; add additional menus hereFileNew:    BSR   OpenClutWind    BRA.S  ExitFileClose    CLR.L  -(SP)      ; bug fix, didn't clear space for result -JDR 2/27/89    _FrontWindow    BSR  DoCloseWindow    ; close the window     BRA.S  ExitFileQuit  BSR  Terminate    ; let's get out of here    Exit    CLR.W  -(SP)      _HiLiteMenu      ; unhilite all Menus    UNLK  A6      ; destroy the link    MOVEA.L  (SP)+,A0    ; pull off the return address    ADDA.L  #ParamSize,SP    ; strip all of the caller's parameters    JMP  (A0)      ; return to the caller    DbgInfo  DoMenuCm    ; this name will appear in the debugger    ENDP    * ================================================* PROCEDURE OpenWindow(WINDid:Integer,WDataSize:Long,UpdateRtn:ProcPtr,MouseRtn:ProcPtr):WindowPtr* ================================================    SEG  'Main'      ; case sensitiveOpenWindow  PROC  EXPORT    StackFrame  RECORD  {A6Link},DECR    ; build a stack frame recordResult1    DS.L  1ParamBegin  EQU  *      ; start parameters after this pointrWindow    DS.W  1      ; Id of WIND resource to useWDataSize  DS.L  1      ; Size of window data record to allocateProcPtr    DS.L  1      ; Pointer to update routine for this windowMouseRtn  DS.L  1ParamSize  EQU  ParamBegin-*    ; size of all the passed parametersRetAddr   DS.L  1      ; place holder for return addressA6Link    DS.L  1      ; place holder for A6 link* insert locals hereTempWord  DS.W  1TempLong  DS.L  1LocalSize  EQU   *      ; size of all the local variables    ENDR    IMPORT  AlertUser    WITH  StackFrame    ; cover our local stack frame    LINK  A6,#LocalSize    ; allocate our local stack frame        MOVE.L  #windowSize,D0    _NewPtr ,Clear      ; create a pointer in A0 and clear memory    CMPA.L  #NIL,A0      ; check for NIL pointer (result in D0)    BNE.S  @1      ; must have been a valid pointer    Move.w  #25,-(SP)    ; Error #    Pea  #'OpenWindow1'    ; Routine Name    Pea  #'No Memory for Window Record'  ; Message    JMP  AlertUser    ; couldn't get memory, report error@1    CLR.L  -(SP)      ; create space for result    MOVE.W  rWindow(A6),-(SP)  ; out window resource definition    MOVE.L  A0,-(SP)    ; our window record storage    MOVE.L  #-1,-(SP)    ; make it on top    _GetNewCWindow      ; create the window    Move.l  (SP)+,Result1(A6)        MOVE.L  WDataSize(A6),D0    _NewHandle ,Clear    ; create a pointer in A0 and clear memory    CMPA.L  #NIL,A0      ; check for NIL pointer (result in D0)    BNE.S  @2      ; must have been a valid pointer    Move.w  #25,-(SP)  ; Error #    Pea  #'OpenWindow2'  ; Routine Name    Pea  #'No Memory for Window Record'  ; Message    JMP  AlertUser    ; couldn't get memory, report error@2    Move.l  A0,-(SP)    ; Save address    Move.l  Result1(A6),-(SP)    Move.l  A0,-(SP)    _SetWRefCon    Move.l  (SP)+,A0    ; restore address    Move.l  (A0),A0  WITH  ClutWData    Move.l  ProcPtr(A6),UpdateRtn(A0)  ; Update routine    Move.l  MouseRtn(A6),MouseDnRtn(A0)  ; Mouse down routine  ENDWITHExit    UNLK  A6      ; destroy the link    MOVEA.L  (SP)+,A0    ; pull off the return address    ADDA.L  #ParamSize,SP    ; strip all of the caller's parameters    JMP  (A0)      ; return to the caller    DbgInfo  OpenWindow    ENDP          * ================================================* PROCEDURE DoMouseDown(Event: EventRecord);* ================================================* Handle all of the MouseDown events.    SEG  'Main'      ; case sensitiveDoMouseDown  PROCStackFrame  RECORD  {A6Link},DECR    ; build a stack frame recordParamBegin  EQU  *      ; start parameters after this pointEventPtr   DS.L  1       ; pointer to current eventParamSize  EQU  ParamBegin-*    ; size of all the passed parametersRetAddr   DS.L  1      ; place holder for return addressA6Link    DS.L  1      ; place holder for A6 linkWindowPtr  DS.L  1      ; local Window pointer variableWhere    DS.L  1      ; local variable where the click wasNewGrowRect  DS  Rect      ; local rect variable for SizeWindowLocalSize  EQU   *      ; size of all the local variables    ENDR    IMPORT  AdjustMenus,DoContentClick    WITH  StackFrame    ; cover our local stack frame    LINK  A6,#LocalSize    ; allocate our local stack frame        MOVEA.L  EventPtr(A6),A0    ; event record only needed by SystemClick    MOVE.L  evtMouse(A0),Where(A6)  ; make a local copy of the mouse location    CLR.W  -(SP)      ; space for FindWindow result    MOVE.L  Where(A6),-(SP)    ; the mouse point    PEA  WindowPtr(A6)    ; a local variable    _FindWindow      ; put the result in a register    MOVE.W  (SP)+,D0    ; a nifty Pascal case-like macro    Case#.W  (D0,IF),      \      (InMenuBar,  MenuEvent),  \      (InSysWindow,  SystemEvent),  \      (InContent,  Content),  \      (InDrag,  Drag)            ; add additional routines here    BRA.S  Exit      ; otherwise we will exit this procedure* ------------- THE DESK ACCS EVENT -------------MenuEvent      BSR.W  AdjustMenus    CLR.L  -(SP)      ; space for MenuSelect    MOVE.L  Where(A6),-(SP)    ; Mouse coordinates    _MenuSelect      ; pass MenuSelect's result    BSR  DoMenuCommand    ; go do the menu and return    BRA.S  Exit* ------------- THE DESK ACCS EVENT -------------SystemEvent      MOVE.L  EventPtr(A6),-(SP)  ; get EventRecord and WindowPtr    MOVE.L  WindowPtr(A6),-(SP)  ; pass the window pointer and...    _SystemClick      ; let the system handle it    BRA.S  Exit* ------------- THE CONTENT EVENT -------------Content        CLR.L  -(SP)      ; was our window in front?    _FrontWindow      ; get front window's pointer    MOVE.L  (SP)+,D0    CMP.L  WindowPtr(A6),D0  ; was it in the front window?    BNE.S  @1      ; no, then just select window        Clr.l  -(SP)    MOVE.L  WindowPtr(A6),-(SP)    _GetWRefCon    Move.l  (SP)+,A2    ; Retrieve handle    Move.l  (A2),A0      ; Deref Handle  WITH  ClutWData    Move.l  MouseDnRtn(A0),A0  ; Get ProcPtr  ENDWITH    MOVE.L  WindowPtr(A6),-(SP)  ; pass the window pointer    MOVE.L  EventPtr(A6),-(SP)  ; pass a pointer to the event    JSR  (A0)    BRA.S  Exit    @1    MOVE.L  WindowPtr(A6),-(SP)  ; only select this window    _SelectWindow      ; and take no further action    BRA.S  Exit* ------------- THE DRAG A WINDOW EVENT -------------Drag        MOVE.L  WindowPtr(A6),-(SP)  ; pass Window Pointer    MOVE.L  Where(A6),-(SP)    ; Mouse coordinates and boundary    PEA  QD.Screenbits.bounds      _DragWindow      ; drag it the screen's boundaryExit        UNLK  A6      ; destroy the link    MOVEA.L  (SP)+,A0    ; pull off the return address    ADDA.L  #ParamSize,SP    ; strip all of the caller's parameters    JMP  (A0)      ; return to the caller    DbgInfo  MouseDwn    ; this name will appear in the debugger    ENDP        * ================================================* PROCEDURE DoEvent(event: EventRecord);* ================================================* Do the right thing for an event. Determine what kind of event it is,* and call the appropriate routines.    SEG  'Main'      ; case sensitiveDoEvent    PROCModifyReg  EQU  D4      ; we'll use this register locallyStackFrame  RECORD  {A6Link},DECR    ; build a stack frame recordParamBegin  EQU  *      ; start listing parameters hereEventPtr   DS.L  1       ; pointer to current eventParamSize  EQU  ParamBegin-*    ; size of all the passed parametersRetAddr   DS.L  1      ; place holder for return addressA6Link    DS.L  1      ; place holder for A6 linkTheEvent   DS  EventRecord     ; local copy of the event recordLocalSize  EQU   *      ; size of all the local variables    ENDR    IMPORT  DoMouseDown,DrawWindow,  \      AdjustMenus,IsAppWindow,\      DoUpdate,DoActivate        WITH  StackFrame,TheEvent  ; cover our local stack frame    LINK  A6,#LocalSize    ; allocate our local stack frame    MOVEM.L  ModifyReg,-(SP)    ; save this register before using it    MOVEA.L  EventPtr(A6),A0    ; pointer of event passed by caller    LEA  TheEvent(A6),A1    ; pointer to local variable TheEvent    MOVE.L  #evtBlkSize,D0    ; size of an event record    _BlockMove      ; we now have a local copy of the event    MOVE.W  Modify(A6),ModifyReg  ; a nifty Pascal case-like macro    MOVE.W  What(A6),D0    ; get the event number    Case#  (D0,Exit),  \  ; if not an event we support, then exit      ,    \  ;  0 Null (not used)      MouseDown,  \  ;  1 Mouse down      ,    \  ;  2 Mouse up (not used)      KeyDown,  \  ;  3 Key down      ,    \  ;  4 Key up (not used)      KeyDown,  \  ;  5 Auto key      Update,   \  ;  6 Update      Disk,    \  ;  7 Disk inserted      Activate,  \  ;  8 Activate/Deactivate      ,    \  ;  9 (not used)      ,    \  ; 10 Network (not used)      ,    \  ; 11 I/O Driver (not used)      ,    \  ; 12 App1 (not used)      ,    \  ; 13 App2 (not used)      ,    \  ; 14 App3 (not used)      OSEvent,    ; 15 OS Event or Suspend/Resume* ------------- THE MOUSEDOWN EVENT -------------MouseDown      PEA  TheEvent(A6)    ; pass Event pointer in case of SystemClick    BSR  DoMouseDown    BRA  Exit* ------------- THE KEYDOWN EVENT -------------KeyDown        BTST  #CmdKey,ModifyReg  ; command key?    BEQ  Exit      ; no, then we're done    BSR.W  AdjustMenus    ; first, adjust the menus    CLR.L  -(SP)      ; space for MenuKey    MOVE.W  2+Message(A6),-(SP)  ; get the character    _MenuKey      ; is it a command?    BSR  DoMenuCommand    ; handle the command and return    BRA.S  Exit* ------------- THE UPDATE EVENT -------------Update      MOVE.L  Message(A6),-(SP)  ; pass the window pointer    BSR  DoUpdate    ; do the update    BRA.S  Exit* ------------- THE DISK EVENT -------------Disk      TST.W  Message(A6)    ; check for error    BEQ.S  @1      ; if none, skip    CLR.W  -(SP)    MOVE.L  #DITopLeft,-(SP)    MOVE.L  Message(A6),-(SP)    MOVE.W  #diBadMount,-(SP)    _Pack2        ; go through disk init package    ADDQ  #2,SP      ; throw away result@1    BRA.S  Exit* ------------- THE ACTIVATE/DEACTIVATE EVENT -------------Activate      BTST  #ActiveFlag,ModifyReg  ; was it an Activate?    BEQ.S  @1      ; no, perform a Deactivate    MOVE.L  Message(A6),-(SP)  ; pass the current window pointer    MOVE.W  #True,-(SP)    ; set up for an Activate event    BSR  DoActivate    ; do the activate routine    BRA.S  Exit      ; we're done@1    MOVE.L  Message(A6),-(SP)  ; pass current window pointer    MOVE.W  #False,-(SP)    ; set up for an Deactivate event    BSR  DoActivate    ; go do the activate routine    BRA.S  Exit      ; we're done* ------------- THE SUSPEND/RESUME EVENT -------------* OSEvent is the event number of the suspend/resume and mouse-moved events sent* by MultiFinder. Once we determine that an event is an osEvent, we look at the* high byte of the message sent to determine which kind it is. To differentiate* suspend and resume events we check the resumeMask bit.OSEvent    MOVE.B  Message(A6),D1    ; get high byte of Message in reg    CMPI.B  #SuspendResume,D1  ; test for message event type    BNE.S  Exit      ; not a suspend/resume event    BTST  #0,3+Message(A6)  ; test bit zero in low byte of Message    BNE.S  @1      ; this is a resume event        MOVE.W  #True,G.InBackground  ; a suspend event    CLR.L  -(SP)      ; bug fix, was passing Message to DoActivate -JDR 2/27/89     _FrontWindow      ; pass the front window to DoActivate -JDR 2/27/89    MOVE.W  #False,-(SP)    ; pass false to cause deactivate    BSR  DoActivate    ; go do the activate routine    BRA.S  Exit@1    MOVE.W  #False,G.InBackground  ; a resume event    CLR.L  -(SP)      ; bug fix, was passing Message to DoActivate -JDR 2/27/89     _FrontWindow      ; pass the front window to DoActivate -JDR 2/27/89    MOVE.W  #True,-(SP)    ; pass false to cause activate    BSR  DoActivate    ; go do the activate routine    Exit        MOVEM.L  (SP)+,ModifyReg    ; restore this register after use    UNLK  A6    MOVEA.L  (SP)+,A0    ; save the caller's address    ADDA.L  #ParamSize,SP    ; strip the caller's parameters    JMP  (A0)    DbgInfo  DoEvent      ; this name will appear in the debugger    ENDP    * ================================================* PROCEDURE EventLoop;* ================================================* Get the events by calling WaitNextEvent, if it's available, otherwise* by calling GetNextEvent. Also call AdjustCursor before doing the event.* After returning from handling the event, we have to make sure the cursor* is still adjusted proper ONLY because this application can &quot;sleep&quot; forever.* An event record is allocated on the stack.  A pointer to this event is* passed to &quot;DoEvent&quot;.  We loop until the user has selects &quot;Quit&quot; in the* file menu.  This program will exit through the DoMenuCommand routine.* 1.02 made adjustments to the event loop logic.  There was a bug in calling* AdjustCursor at the wrong time. (it crashed under _GetNextEvent too!)* If you are using modeless dialogs that have editText items,* you will want to call IsDialogEvent to give the caret a chance* to blink, even if WNE/GNE returned FALSE. However, check FrontWindow* for a non-NIL value before calling IsDialogEvent.    SEG  'Main'      ; case sensitiveEventLoop  PROC        ; any source file can use this routineStackFrame  RECORD  {A6Link},DECR    ; build a stack frame recordParamBegin  EQU  *      ; start listing parameters hereParamSize  EQU  ParamBegin-*    ; size of all the passed parametersRetAddr   DS.L  1      ; place holder for return addressA6Link    DS.L  1      ; place holder for A6 linkTheEvent   DS  EventRecord     ; local copy of the event recordMouseMvdRgn  DS.L  1      ; local region for MouseMoved eventsMousePos  DS.L  1      ; local point for mouse positionLocalSize  EQU   *      ; size of all the local variables    ENDR        IMPORT  AdjustCursor,GetGlobalMouse    WITH  StackFrame    ; cover our local stack frame    LINK  A6,#LocalSize    ; allocate our local stack frame        CLR.L  -(SP)    _NewRgn        ; create region for AdjustCursor    MOVE.L  (SP)+,MouseMvdRgn(A6)  ; save the handle to this region* ------------- GET NEXT EVENT LOOP -------------NextEvent      CMPI.W  #True,G.HasWNEvent   ; see if we can call WaitNextEvent    BNE.S  @1      ; nope, old time events        PEA  MousePos(A6)    ; here's the mouse    BSR  GetGlobalMouse    ; get global coordinate    MOVE.L  MousePos(A6),-(SP)  ; here's the mouse    MOVE.L  MouseMvdRgn(A6),-(SP)  ; the region to change    BSR  AdjustCursor    ; adjust the cursor and region    CLR.W  -(SP)      ; space for result    MOVE.W  #EveryEvent,-(SP)  ; the events we want    PEA  TheEvent(A6)    ; pointer to the event record    MOVE.L  #SleepValue,-(SP)  ; the sleeping time value    MOVE.L  MouseMvdRgn(A6),-(SP)  ; the current MouseRgn    _WaitNextEvent    BRA.S  @2      ; got an event to handle?              ; no WaitNextEvent trap available@1    _SystemTask      ; call SystemTask for drivers and DAs    CLR.W  -(SP)      ; space for result    MOVE.W  #EveryEvent,-(SP)  ; the events we want    PEA  TheEvent(A6)    ; pass a pointer to our event    _GetNextEvent@2    MOVE.W  (SP)+,D0    ; result code    BEQ.S  NextEvent    ; no event, get another one    GotEvent  MOVE.L  TheEvent.where(A6),-(SP); the mouse location    MOVE.L  MouseMvdRgn(A6),-(SP)  ; the region to change    BSR  AdjustCursor    ; adjust cursor BEFORE doing event    PEA  TheEvent(A6)    ; pass the pointer to our event    BSR  DoEvent      ; do the event and return    BRA.S  NextEvent    ; done with that event, get the nextExit    UNLK  A6      ; destroy the link    MOVEA.L  (SP)+,A0    ; pull off the return address    ADDA.L  #ParamSize,SP    ; strip all of the caller's parameters    JMP  (A0)      ; return to the caller    DbgInfo  EvntLoop    ; this name will appear in the debugger    ENDP* ================================================* --------------- MAIN ENTRY POINT ---------------* ================================================* This is the entry point of the program.  We start with data initializing* and then to get the System environment (SysEnvirons).  We unload the* initialization code segment and finally get started with the EventLoop.    SEG  'Main'      ; case sensitiveStartUp          MAIN        ; entry point of the program        IMPORT  _DataInit,Initialize,  \      ForceEnvirons,EventLoop    JSR  _DataInit    ; initialize those constants      PEA  _DataInit    ; get rid of that segment    _UnloadSeg* If you have stack requirements that differ from the default, then you could* use SetApplLimit to increase StackSpace at this point, before calling MaxApplZone.    _MaxApplZone      ; result in D0    JSR  Initialize    ; get things the program set up    PEA  Initialize    _UnloadSeg      ; we're done this that segment too* ------------- SET UP THE CLUT WINDOW -------------    BSR  OpenClutWind        LEA  EventLoop,A0    ; on your mark, get set,...    JMP  (A0)      ; go into the event loop    ENDP    END        ; end of this source file</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ClutWind/listing1.html%3Fid%3DDTS10000141-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ClutWind/listing1.html%3Fid%3DDTS10000141-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ClutWind/listing1.html%3Fid%3DDTS10000141-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>