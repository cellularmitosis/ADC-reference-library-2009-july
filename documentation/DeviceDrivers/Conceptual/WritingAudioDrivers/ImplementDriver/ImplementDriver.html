<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Audio Device Driver Programming Guide: Implementing an Audio Driver</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Implementing an Audio Driver"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000732" title="Implementing an Audio Driver"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/MusicAudio-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30000452" target="_top">Audio</a> &gt; <a href="../About/About.html#//apple_ref/doc/uid/TP30000729-CH204-DontLinkElementID_4">Audio Device Driver Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AudioFamilyDesign/AudioFamilyDesign.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CustomControls/CustomControls.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000732-DontLinkElementID_14" title="Implementing an Audio Driver"></a><h1><a name="//apple_ref/doc/uid/TP30000732-BAJDFDIH" title="Implementing an Audio Driver"></a>Implementing an Audio Driver</h1><p>As discussed in the chapter <span class="content_text"><a href="../AudioFamilyDesign/AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-CJBBAGJF">“Audio Family Design,”</a></span> writing an audio driver using the Audio family requires, in object-oriented terms, that you do some certain things in your code:</p>
<ul class="ul"><li class="li"><p>Create a subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> which, among other things, initializes the hardware and registers for sleep/wake notifications.</p></li>
<li class="li"><p>Create a subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> which, among other things, initializes the I/O engine and stops and starts it.</p></li>
<li class="li"><p>Create, configure, and attach to the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object the number of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> and <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects appropriate to your driver.</p></li>
<li class="li"><p>Respond to value changes in the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects.</p></li>
<li class="li"><p>In a separate code module (but as part of the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass implementation), implement the driver’s clipping and converting routines.</p></li></ul>
<p>This chapter will guide you through these implementation steps. It uses as a code source the SamplePCIAudioDriver example project (located in <code>/Developer/Examples/Kernel/IOKit/Audio/Templates</code> when you install the Developer package). In the interest of brevity, this chapter does not use all the code found in that project and strips the comments from the code. Refer to the SamplePCIAudioDriver project for the full range of code and comments on it.</p>


<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-TPXREF101">Setting Up the Project</a>
				
			<br/>
			
        
			
			
				<a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-TPXREF102">Implementing an IOAudioDevice Subclass</a>
				
			<br/>
			
        
			
			
				<a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-TPXREF105">Implementing an IOAudioEngine Subclass</a>
				
			<br/>
			
        
			
			
				<a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJCBIAF">Clipping and Converting Samples</a>
				
			<br/>
			
        
			
			
				<a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-TPXREF110">Debugging and Testing the Driver</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000732-TPXREF101" title="Setting Up the Project"></a><h2>Setting Up the Project</h2>
<p>Even before you create a project for your audio driver, you should consider some elemental facets of design. Examine the audio hardware and decide which Audio-family objects are required to support it. Of course, your driver must have one <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object (instantiated from a custom subclass), but how many <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>, <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code>, and <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects should you create?</p>
<p><span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-CJBDBEDA">Table 3-1</a></span> provides a decision matrix for determining how many Audio-family objects of each kind that you need.</p><a name="//apple_ref/doc/uid/TP30000732-CJBDBEDA" title="Table 3-1Deciding which Audio family objects to create (and other design decisions)"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 3-1&nbsp;&nbsp;</strong>Deciding which Audio family objects to create (and other design decisions)</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Question</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>What to create</p></th>
</tr>


<tr>
<td  scope="row"><p>Are there sample buffers of different sizes?</p></td>
<td ><p>Create a custom <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object for each sample buffer.</p></td>
</tr>
<tr>
<td  scope="row"><p>How many I/O or DMA engines are there on the device?</p></td>
<td ><p>Create a custom <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object for each I/O or DMA engine.</p></td>
</tr>
<tr>
<td  scope="row"><p>How many separate or interleaved sample buffers are there?</p></td>
<td ><p>Create an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object for each buffer (both input and output).</p></td>
</tr>
<tr>
<td  scope="row"><p>How many controllable attributes are there (volume, gain, mute, and so on)?</p></td>
<td ><p>Create an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> object for each attribute.</p></td>
</tr>

</table></div>
<p>The SamplePCIAudioDriver project requires one custom <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass object, two <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> objects (input and output), and six <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects (left and right output volume, left and right input gain, and input and output mute).</p>
<p>You also should decide what properties your driver must have to match against your provider’s nub and specify those properties in your driver’s <code>IOKitPersonalities</code> dictionary. In the SamplePCIAudioDriver personality (see <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-CJBEHGED">Figure 3-1</a></span>), the provider is the PCI family and the nub class is <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOPCIDevice_h/Classes/IOPCIDevice/index.html#//apple_ref/cpp/cl/IOPCIDevice" target="_top">IOPCIDevice</a></code>. In addition, a PCI audio driver would usually specify the vendor and device ID registers (primary or subsystem) as the value of the <code>IOPCIMatch</code> key. (Note that in the SamplePCIAudioDriver example, the vendor and device ID registers are specified as zeros; for your driver, you would substitute the appropriate values.) Finally, for your <code>IOClass</code> property, append the name of your <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> subclass to the standard reverse-DNS construction <code>com_</code><em>company</em><code>_driver</code><code>_</code>; in the case of the SamplePCIAudioDriver project, the <code>IOClass</code> value is <code>com_MyCompany_driver_SamplePCIAudioDevice</code>.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000732-CJBEHGED" title="Figure 3-1Bundle settings of the sample PCI audio driver"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>Bundle settings of the sample PCI audio driver</p><img src = "../Art/pcidriverplist.gif" alt = "Bundle settings of the sample PCI audio driver" width="557" height="298"></div><br/>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000732-DontLinkElementID_15" title="Note"></a><p><strong>Note:</strong>&nbsp;For more on PCI device matching, see the document <span class="content_text"><!--a target="_top" -->Writing PCI Drivers<!--/a--></span>.</p></div>
<p>Of course, if your driver’s provider is different (say, USB or FireWire), the matching properties that you would specify in an <code>IOKitPersonalities</code> dictionary would be different.</p>
<p>As <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-CJBEHGED">Figure 3-1</a></span> suggests, also make sure that you specify other necessary properties in your driver’s <code>Info.plist</code> file, including the versioning and dependency information in the <code>OSBundleLibraries</code> dictionary.</p>
<div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/TP30000732-DontLinkElementID_16" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;

Use of floating point is generally discouraged in the kernel to avoid a performance penalty during function calls. Threads running in the kernel only keep floating point registers in their stack if floating point has already been used in that thread.</p><p>
For threads called from user space (including the threads that call <code><!--a target="_top" -->clipOutputSamples<!--/a--></code> and <code><!--a target="_top" -->convertInputSamples<!--/a--></code>), however, floating point has already been used, and thus no additional penalty is incurred by using hardware floating point.</p><p>
However, there is a catch. By default, most I/O Kit code is compiled with floating-point emulation (the <code>-msoft-float</code> compiler flag). You must be very careful to ensure that code that needs to interact with actual floating-point samples does <em>not</em> get compiled with this compiler flag. This is described in more detail in the relevant sections.</p><p></p><div class="clear"></div></div>
<a name="//apple_ref/doc/uid/TP30000732-TPXREF102" title="Implementing an IOAudioDevice Subclass"></a><h2>Implementing an IOAudioDevice Subclass</h2>
<p>Every I/O Kit audio driver must implement a subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code>. One instance of this class is created when the driver is loaded. An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object is the central, coordinating object of the driver; it represents the audio hardware in an overall sense.</p>
<p>Despite its central role, an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> subclass generally does not do as much as an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass. It merely initializes the hardware at startup and creates the custom <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> objects required by the driver. It may also create the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects used by the driver and respond to requests to change the values of these controls, but the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass could do these tasks instead. In the example used for this chapter (SamplePCIAudioDriver), the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> subclass creates and manages the device’s controls.</p>
<p>Begin by adding a header file and an implementation file for the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> superclass you are going to implement. In the header file, specify <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> as the superclass and provide the necessary declarations.</p>
<p><span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJIFGEC">Listing 3-1</a></span> shows the beginning of <code>SamplePCIAudioDevice.h</code>.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJIFGEC" title="Listing 3-1Partial class declaration of the IOAudioDevice subclass"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>Partial class declaration of the IOAudioDevice subclass</p>
<div class="codesample"><table><tr><td scope="row"><pre>#include &lt;IOKit/audio/IOAudioDevice.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct SamplePCIAudioDeviceRegisters {<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 reg1;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 reg2;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 reg3;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 reg4;<span></span></pre></td></tr><tr><td scope="row"><pre>} SamplePCIAudioDeviceRegisters;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>class IOPCIDevice;<span></span></pre></td></tr><tr><td scope="row"><pre>class IOMemoryMap;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define SamplePCIAudioDevice com_MyCompany_driver_SamplePCIAudioDevice<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>class SamplePCIAudioDevice : public IOAudioDevice<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    friend class SampleAudioEngine;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSDeclareDefaultStructors(SamplePCIAudioDevice)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOPCIDevice     *pciDevice;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOMemoryMap     *deviceMap;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SamplePCIAudioDeviceRegisters *deviceRegisters;<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP30000732-TPXREF103" title="Hardware Initialization"></a><h3>Hardware Initialization</h3>
<p>I/O Kit audio drivers do not need to override the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top">IOService</a></code><code>::</code><code>start</code> method. Instead, the default <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> implementation of <code>start</code> first invokes the superclass implementation and then calls the <code><!--a target="_top" -->initHardware<!--/a--></code> method of the subclass. Your <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> subclass must override the <code><!--a target="_top" -->initHardware<!--/a--></code> method.</p>
<p>Your implementation of <code><!--a target="_top" -->initHardware<!--/a--></code> must do two general things:</p>
<ul class="spaceabove"><li class="li"><p>It must perform any necessary hardware-specific initializations (on both the provider and the audio sides), such as mapping resources and setting the hardware to a known state. It also involves creating and initializing the necessary Audio family objects.</p></li>
<li class="li"><p>It must set the names by which the driver is to be known to the Audio HAL and its clients.</p></li></ul>
<p>If the <code><!--a target="_top" -->initHardware<!--/a--></code> call succeeds, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> superclass (in the <code>start</code> method) sets up power management if the family is supposed to manage power and then calls <code><!--a target="_top" -->registerService<!--/a--></code> to make the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object visible in the I/O Registry.</p>
<p><span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJJFGBJ">Listing 3-2</a></span> shows how the SamplePCIAudioDevice class implements the <code><!--a target="_top" -->initHardware<!--/a--></code> method.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJJFGBJ" title="Listing 3-2Implementing the initHardware method"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>Implementing the initHardware method</p>
<div class="codesample"><table><tr><td scope="row"><pre>bool SamplePCIAudioDevice::initHardware(IOService *provider)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    bool result = false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("SamplePCIAudioDevice[%p]::initHardware(%p)\n",  this, provider);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!super::initHardware(provider)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    pciDevice = OSDynamicCast(IOPCIDevice, provider);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!pciDevice) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    deviceMap = pciDevice->mapDeviceMemoryWithRegister(kIOPCIConfigBaseAddress0);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!deviceMap) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    deviceRegisters = (SamplePCIAudioDeviceRegisters  *)deviceMap->getVirtualAddress();<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!deviceRegisters) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    pciDevice->setMemoryEnable(true);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    setDeviceName("Sample PCI Audio Device");<span></span></pre></td></tr><tr><td scope="row"><pre>    setDeviceShortName("PCIAudio");<span></span></pre></td></tr><tr><td scope="row"><pre>    setManufacturerName("My Company");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#error Put your own hardware initialization code here...and in other  routines!!<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!createAudioEngine()) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    result = true;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Done:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!result) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (deviceMap) {<span></span></pre></td></tr><tr><td scope="row"><pre>            deviceMap->release();<span></span></pre></td></tr><tr><td scope="row"><pre>            deviceMap = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return result;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>The first part of this method does some provider-specific initializations. The implementation gets the provider, an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOPCIDevice_h/Classes/IOPCIDevice/index.html#//apple_ref/cpp/cl/IOPCIDevice" target="_top">IOPCIDevice</a></code> object, and with it, configures a map for the PCI configuration space base registers. With this map, it gets the virtual address for the registers. Then it enables PCI memory access by calling <code><!--a target="_top" -->setMemoryEnable<!--/a--></code>.</p>
<p>Next, the SamplePCIAudioDevice implementation sets the full and short name of the device as well as the manufacturer’s name, making this information available to the Audio HAL.</p>
<p>The last significant call in this implementation is a call to <code>createAudioEngine</code>. This method creates the driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> and <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects (and, indirectly, the driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> objects).</p>
<a name="//apple_ref/doc/uid/TP30000732-TPXREF104" title="Creating the IOAudioEngine Objects"></a><h4>Creating the IOAudioEngine Objects</h4>
<p>In the <code><!--a target="_top" -->initHardware<!--/a--></code> method, create an instance of your driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass for each I/O engine on the device. After it’s created and initialized, call <code>activateAudioEngine</code> to signal to the Audio HAL that the engine is ready to begin vending audio services.</p>
<p>The SamplePCIAudioDevice subclass creates its sole <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object in a subroutine of <code><!--a target="_top" -->initHardware<!--/a--></code> named <code>createAudioEngine</code> (see <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJDGIGE">Listing 3-3</a></span>).</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJDGIGE" title="Listing 3-3Creating an IOAudioEngine object"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>Creating an IOAudioEngine object</p>
<div class="codesample"><table><tr><td scope="row"><pre>bool SamplePCIAudioDevice::createAudioEngine()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    bool result = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    SamplePCIAudioEngine *audioEngine = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOAudioControl *control;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    audioEngine = new SamplePCIAudioEngine;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!audioEngine) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!audioEngine->init(deviceRegisters)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>     // example code skipped...<span></span></pre></td></tr><tr><td scope="row"><pre>     // Here create the driver’s IOAudioControl objects<span></span></pre></td></tr><tr><td scope="row"><pre>     // (see next section)...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    activateAudioEngine(audioEngine);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    audioEngine->release();<span></span></pre></td></tr><tr><td scope="row"><pre>    result = true;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Done:<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!result &amp;&amp; (audioEngine != NULL)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        audioEngine->release();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return result;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP30000732-DontLinkElementID_17" title="Note"></a><p><strong>Note:</strong>&nbsp;In the interest of concision, this listing excludes the code that creates the driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects; see <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJIBBCD">“Creating and Adding the IOAudioControl Objects”</a></span> for this step.</p></div>
<p>In this example, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> subclass creates a raw instance of the driver’s subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> (SamplePCIAudioEngine) and then initializes it, passing in the device registers so the object can access those registers. You can define your <code>init</code> method to take any number of parameters. </p>
<p>Next, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> implementation activates the audio engine (<code>activateAudioEngine</code>); this causes the newly created <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object’s <code>start</code> and <code><!--a target="_top" -->initHardware<!--/a--></code> methods to be invoked. When <code>activateAudioEngine</code> returns, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> is ready to begin vending audio services to the system. Because the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> superclass retains the driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> objects, be sure to release each <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object so that it is freed when the driver is terminated.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJIBBCD" title="Creating and Adding the IOAudioControl Objects"></a><h4>Creating and Adding the IOAudioControl Objects</h4>
<p>A typical I/O Kit audio driver must instantiate several <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects to help it manage the controllable attributes of the audio hardware. These attributes include such things as volume, mute, and input/output selection. You can create and manage these control objects in your <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass or in your <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> subclass; it doesn’t matter which.</p>
<p>As summarized in <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJGJEEB">Table 3-2</a></span>, the Audio family provides three subclasses of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> that implement behavior specific to three functional types of control. Instantiate a control from the subclass that is appropriate to a controllable attribute of the device.</p><a name="//apple_ref/doc/uid/TP30000732-BAJGJEEB" title="Table 3-2Subclasses of IOAudioControl"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 3-2&nbsp;&nbsp;</strong>Subclasses of IOAudioControl</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Subclass</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Purpose</p></th>
</tr>


<tr>
<td  scope="row"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioLevelControl_h/Classes/IOAudioLevelControl/index.html#//apple_ref/cpp/cl/IOAudioLevelControl" target="_top">IOAudioLevelControl</a></code></p></td>
<td ><p>For controls such as volume, where a range of measurable values (such as decibels) is associated with an integer range.</p></td>
</tr>
<tr>
<td  scope="row"><p><code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioToggleControl_h/Classes/IOAudioToggleControl/index.html#//apple_ref/cpp/cl/IOAudioToggleControl" target="_top">IOAudioToggleControl</a></code></p></td>
<td ><p>For controls such as mute, where the state is either off or on.</p></td>
</tr>
<tr>
<td  scope="row"><p><code><!--a target="_top" -->IOAudioSelectorControl<!--/a--></code></p></td>
<td ><p>For controls that select a discrete attribute, such as input gain.</p></td>
</tr>

</table></div>
<p>Each subclass (or control type) has a <code>create</code> method and a convenience method specific to a subtype of control. The <code>IOAudioTypes.h</code> header file, which defines constants for control type and subtype, also defines other constants intended to be supplied as parameters in the control-creation methods. <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJJDDCA">Table 3-3</a></span> summarizes the categories that these constants fall into.</p><a name="//apple_ref/doc/uid/TP30000732-BAJJDDCA" title="Table 3-3Categories of audio-control constants in IOAudioTypes.h"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 3-3&nbsp;&nbsp;</strong>Categories of audio-control constants in IOAudioTypes.h</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Category</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Purpose</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Examples and comments</p></th>
</tr>


<tr>
<td  scope="row"><p>Type</p></td>
<td ><p>General function of control</p></td>
<td ><p>Level, toggle, or selector (each corresponding to an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> subclass).</p></td>
</tr>
<tr>
<td  scope="row"><p>Subtype</p></td>
<td ><p>Purpose of the control</p></td>
<td ><p>Volume, mute, or input/output; subclass convenience methods assume a subtype.</p></td>
</tr>
<tr>
<td  scope="row"><p>Channel ID</p></td>
<td ><p>Common defaults for channels</p></td>
<td ><p>Default right channel, default center channel, default sub woofer, all channels.</p></td>
</tr>
<tr>
<td  scope="row"><p>Usage</p></td>
<td ><p>How the control is to be used</p></td>
<td ><p>Output, input, or pass-through.</p></td>
</tr>

</table></div>
<p>See <code>IOAudioTypes.h</code> for the complete set of audio-control constants.</p>
<p>After you create an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> object you must take two further steps:</p>
<ul class="spaceabove"><li class="li"><p>Set the value-change handler for the control. </p><p>The value-change handler is a callback routine that is invoked when a client of the Audio HAL requests a change in a controllable attribute. See <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJFDCDA">“Implementing Control Value-Change Handlers”</a></span> for more on these routines.</p></li>
<li class="li"><p>Add the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> to the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object they are associated with.</p></li></ul>
<p>In the SamplePCIAudioDriver example, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> subclass creates and initializes the driver’s <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> objects. This happens in the <code>createAudioEngine</code> method; <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJGGDCG">Listing 3-4</a></span> shows the creation and initialization of one control.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJGGDCG" title="Listing 3-4Creating an IOAudioControl object and adding it to the IOAudioEngine object"></a><p class="codesample"><strong>Listing 3-4&nbsp;&nbsp;</strong>Creating an IOAudioControl object and adding it to the IOAudioEngine object</p>
<div class="codesample"><table><tr><td scope="row"><pre>    // ... from createAudioEngine()<span></span></pre></td></tr><tr><td scope="row"><pre>    control = IOAudioLevelControl::createVolumeControl(<span></span></pre></td></tr><tr><td scope="row"><pre>          65535,     // initial value<span></span></pre></td></tr><tr><td scope="row"><pre>          0,     // min value<span></span></pre></td></tr><tr><td scope="row"><pre>          65535,     // max value<span></span></pre></td></tr><tr><td scope="row"><pre>          (-22 &lt;&lt; 16) + (32768),     // -22.5 in IOFixed (16.16)<span></span></pre></td></tr><tr><td scope="row"><pre>          0,     // max 0.0 in IOFixed<span></span></pre></td></tr><tr><td scope="row"><pre>          kIOAudioControlChannelIDDefaultLeft,<span></span></pre></td></tr><tr><td scope="row"><pre>          kIOAudioControlChannelNameLeft,<span></span></pre></td></tr><tr><td scope="row"><pre>          0,     // control ID - driver-defined<span></span></pre></td></tr><tr><td scope="row"><pre>          kIOAudioControlUsageOutput);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!control) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    control->setValueChangeHandler((IOAudioControl::IntValueChangeHandler)<span></span></pre></td></tr><tr><td scope="row"><pre>                                    volumeChangeHandler, this );<span></span></pre></td></tr><tr><td scope="row"><pre>    audioEngine->addDefaultAudioControl(control);<span></span></pre></td></tr><tr><td scope="row"><pre>    control->release();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Here create more IOAudioControl objects for right output channel,<span></span></pre></td></tr><tr><td scope="row"><pre>** output mute,left and right input gain, and input mute. For each,  set<span></span></pre></td></tr><tr><td scope="row"><pre>** value change handler and add to the IOAudioEngine<span></span></pre></td></tr><tr><td scope="row"><pre>*/<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP30000732-DontLinkElementID_18" title="Note"></a><p><strong>Note:</strong>&nbsp;This code fragment shows the creation of only one <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> object. What must be done for the other controls—right output volume, output mute, left and right input gain, and input mute—is similar.</p></div>
<p>In this example, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> subclass creates a left output volume control with an integer range from 0 to 65535 and a corresponding decibel range from –22.5 to 0.0. A channel must always be associated with an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> object. You do this when you create the object by specifying constants (defined in <code>IOAudioDefines.h</code>) for both channel ID and channel name. You must also specify a “usage” constant that indicates how the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> will be used (input, output, or pass-through).</p>
<p>Once you have added an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> to its <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>, you should release it so that it is properly freed when the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object is done with it. </p>
<a name="//apple_ref/doc/uid/TP30000732-CJBJDJCB" title="Handling Sleep/Wake Notifications"></a><h4>Handling Sleep/Wake Notifications</h4>
<p>As the power controller for your device, it is necessary to register for sleep/wake notifications. At a minimum, your handlers should stop and restart any audio engines under their control. Depending on the device, this may not be sufficient, however.</p>
<p>In general—and particularly for PCI devices—device power will be cycled during sleep, but the device will not disappear from the device tree. This means that your driver will not be torn down and reinitialized. Thus, for these devices, it is crucial that you register for sleep/wake notifications and reinitialize your device registers to a known state on wake. Otherwise, unexpected behavior may result.</p>
<p>For information about how to register for sleep/wake notifications, see the <span class="content_text"><!--a target="_top" -->Power Management<!--/a--></span> chapter of <em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJFDCDA" title="Implementing Control Value-Change Handlers"></a><h3>Implementing Control Value-Change Handlers</h3>
<p>For each <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> object that your driver creates, it must implement what is known as a value-change handler for it. (This doesn’t imply that you need you need to create a separate handler for each control; one handler could be used to manage multiple controls of similar type.) The value-change handler is a callback routine that is invoked when the controllable device attribute associated with an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> object needs to be changed.</p>
<p>The header file <code>IOAudioControl.h</code> defines three prototypes for control value-change handlers:</p>
<div class="codesample"><table><tr><td scope="row"><pre>    typedef IOReturn (*IntValueChangeHandler)(OSObject *target,<span></span></pre></td></tr><tr><td scope="row"><pre>        IOAudioControl *audioControl, SInt32 oldValue, SInt32 newValue);<span></span></pre></td></tr><tr><td scope="row"><pre>    typedef IOReturn (*DataValueChangeHandler)(OSObject *target,<span></span></pre></td></tr><tr><td scope="row"><pre>        IOAudioControl *audioControl, const void *oldData, UInt32<span></span></pre></td></tr><tr><td scope="row"><pre>        oldDataSize, const void *newData, UInt32 newDataSize);<span></span></pre></td></tr><tr><td scope="row"><pre>    typedef IOReturn (*ObjectValueChangeHandler)(OSObject *target,<span></span></pre></td></tr><tr><td scope="row"><pre>        IOAudioControl *audioControl, OSObject *oldValue,<span></span></pre></td></tr><tr><td scope="row"><pre>        OSObject *newValue);<span></span></pre></td></tr></table></div>
<p>Each prototype is intended for a different kind of control value: integer, pointer to raw data (<code>void *</code>), and (<code><!--a target="_top" -->libkern<!--/a--></code>) object. For most cases, the integer handler should be sufficient. All of the existing <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/cl/IOAudioControl" target="_top">IOAudioControl</a></code> subclasses pass integer values to the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioControl_h/Classes/IOAudioControl/index.html#//apple_ref/cpp/tdef/IOAudioControl/IntValueChangeHandler" target="_top">IntValueChangeHandler</a></code> object.</p>
<p>The essential task of the value-change handler is to update the proper attribute of the audio hardware to the new control value. <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJJEFFI">Listing 3-5</a></span> shows how one might implement a value-change handler (excluding the actual attribute-setting code).</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJJEFFI" title="Listing 3-5Implementing a control value-change handler"></a><p class="codesample"><strong>Listing 3-5&nbsp;&nbsp;</strong>Implementing a control value-change handler</p>
<div class="codesample"><table><tr><td scope="row"><pre>IOReturn SamplePCIAudioDevice::volumeChangeHandler(IOService *target,<span></span></pre></td></tr><tr><td scope="row"><pre>        IOAudioControl *volumeControl, SInt32 oldValue, SInt32 newValue)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn result = kIOReturnBadArgument;<span></span></pre></td></tr><tr><td scope="row"><pre>    SamplePCIAudioDevice *audioDevice;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    audioDevice = (SamplePCIAudioDevice *)target;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (audioDevice) {<span></span></pre></td></tr><tr><td scope="row"><pre>        result = audioDevice->volumeChanged(volumeControl, oldValue,<span></span></pre></td></tr><tr><td scope="row"><pre>                    newValue);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return result;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn SamplePCIAudioDevice::volumeChanged(IOAudioControl *volumeControl,<span></span></pre></td></tr><tr><td scope="row"><pre>                            SInt32 oldValue, SInt32 newValue)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("SamplePCIAudioDevice[%p]::volumeChanged(%p, %ld,  %ld)\n", this,<span></span></pre></td></tr><tr><td scope="row"><pre>            volumeControl, oldValue, newValue);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (volumeControl) {<span></span></pre></td></tr><tr><td scope="row"><pre>        IOLog("\t-> Channel %ld\n", volumeControl->getChannelID());<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Add hardware volume code change<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>The reason for the nested implementation in this example is that the value-change callback itself must be a straight C-language function (in this case, it’s a static member function). The static function simply forwards the message to the actual target for processing.</p>
<a name="//apple_ref/doc/uid/TP30000732-TPXREF105" title="Implementing an IOAudioEngine Subclass"></a><h2>Implementing an IOAudioEngine Subclass</h2>
<p>In addition to implementing a subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code>, writers of audio drivers must also implement a subclass of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>. This subclass should define the attributes and behavior of the driver that are specific to the hardware’s I/O engine. These include specifying the size and characteristics of the sample and mix buffers, getting the current sample frame on demand, handling interrupts to take a timestamp, handling format changes, and starting and stopping the I/O engine upon request.</p>
<p>Start by defining the interface of your <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass in a header file. <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJCABJJ">Listing 3-6</a></span> shows the main contents of the <code>SamplePCIAudioEngine.h</code> file.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJCABJJ" title="Listing 3-6Interface definition of the SamplePCIAudioEngine class"></a><p class="codesample"><strong>Listing 3-6&nbsp;&nbsp;</strong>Interface definition of the SamplePCIAudioEngine class</p>
<div class="codesample"><table><tr><td scope="row"><pre>class SamplePCIAudioEngine : public IOAudioEngine<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSDeclareDefaultStructors(SamplePCIAudioEngine)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SamplePCIAudioDeviceRegisters   *deviceRegisters;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SInt16                          *outputBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt16                          *inputBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOFilterInterruptEventSource     *interruptEventSource;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>public:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual bool init(SamplePCIAudioDeviceRegisters *regs);<span></span></pre></td></tr><tr><td scope="row"><pre>    virtual void free();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual bool initHardware(IOService *provider);<span></span></pre></td></tr><tr><td scope="row"><pre>    virtual void stop(IOService *provider);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual IOAudioStream *createNewAudioStream(IOAudioStreamDirection<span></span></pre></td></tr><tr><td scope="row"><pre>            direction, void *sampleBuffer, UInt32 sampleBufferSize);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual IOReturn performAudioEngineStart();<span></span></pre></td></tr><tr><td scope="row"><pre>    virtual IOReturn performAudioEngineStop();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual UInt32 getCurrentSampleFrame();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual IOReturn performFormatChange(IOAudioStream *audioStream,<span></span></pre></td></tr><tr><td scope="row"><pre>            const IOAudioStreamFormat *newFormat, const IOAudioSampleRate<span></span></pre></td></tr><tr><td scope="row"><pre>            *newSampleRate);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual IOReturn clipOutputSamples(const void *mixBuf, void  *sampleBuf,<span></span></pre></td></tr><tr><td scope="row"><pre>            UInt32 firstSampleFrame, UInt32 numSampleFrames, const<span></span></pre></td></tr><tr><td scope="row"><pre>            IOAudioStreamFormat *streamFormat, IOAudioStream *audioStream);<span></span></pre></td></tr><tr><td scope="row"><pre>    virtual IOReturn convertInputSamples(const void *sampleBuf,  void *destBuf,<span></span></pre></td></tr><tr><td scope="row"><pre>            UInt32 firstSampleFrame, UInt32 numSampleFrames, const<span></span></pre></td></tr><tr><td scope="row"><pre>            IOAudioStreamFormat *streamFormat, IOAudioStream *audioStream);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    static void interruptHandler(OSObject *owner, IOInterruptEventSource<span></span></pre></td></tr><tr><td scope="row"><pre>            *source, int count);<span></span></pre></td></tr><tr><td scope="row"><pre>    static bool interruptFilter(OSObject *owner, IOFilterInterruptEventSource<span></span></pre></td></tr><tr><td scope="row"><pre>            *source);<span></span></pre></td></tr><tr><td scope="row"><pre>    virtual void filterInterrupt(int index);<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div>
<p>Most of the methods and types declared here are explained in the following sections—including (for example) why there is a cluster of interrupt-related methods.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000732-DontLinkElementID_19" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code><!--a target="_top" -->clipOutputSamples<!--/a--></code> and <code><!--a target="_top" -->convertInputSamples<!--/a--></code> methods, although they are declared in the class interface-definition file (in this case, <code>SamplePCIAudioEngine.h</code>), are implemented in a separate source module. The reason for that, and the procedures for implementing these methods, are found in <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJCBIAF">“Clipping and Converting Samples.”</a></span></p></div>
<a name="//apple_ref/doc/uid/TP30000732-BAJFJGGC" title="Hardware Initialization"></a><h3>Hardware Initialization</h3>
<p>As you did in your <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> subclass, you must implement the <code><!--a target="_top" -->initHardware<!--/a--></code> method in your <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass to perform certain hardware initializations. The <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> <code><!--a target="_top" -->initHardware<!--/a--></code> method is invoked indirectly when the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioDevice_h/Classes/IOAudioDevice/index.html#//apple_ref/cpp/cl/IOAudioDevice" target="_top">IOAudioDevice</a></code> object calls <code>activateAudioEngine</code> on an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object.</p>
<p>In your implementation of <code><!--a target="_top" -->initHardware<!--/a--></code>, you should accomplish two general tasks: configure the I/O engine and create the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> objects used by the engine. As part of initialization, you should also implement the <code>init</code> method if anything special should happen prior to the invocation of <code><!--a target="_top" -->initHardware<!--/a--></code>; in the case of the SamplePCIAudioEngine class, the <code>init</code> method calls the superclass implementation and then assigns the passed-in device registers to an instance variable. </p>
<a name="//apple_ref/doc/uid/TP30000732-TPXREF106" title="Configuring the I/O Engine"></a><h4>Configuring the I/O Engine</h4>
<p>Configuring the audio hardware’s I/O engine involves the completion of many recommended tasks:</p>
<ul class="spaceabove"><li class="li"><p>Determine the current sample rate and set the initial sample rate using <code><!--a target="_top" -->setSampleRate<!--/a--></code>.</p></li>
<li class="li"><p>Call <code><!--a target="_top" -->setNumSampleFramesPerBuffer<!--/a--></code> to specify the number of sample frames in each buffer serviced by this I/O engine.</p></li>
<li class="li"><p>Call <code><!--a target="_top" -->setDescription<!--/a--></code> to make the name of the I/O engine available to Audio HAL clients.</p></li>
<li class="li"><p>Call <code>setOutputSampleLatency</code> or <code><!--a target="_top" -->setInputSampleLatency<!--/a--></code> (or both methods, if appropriate) to indicate how much latency exists on the input and output streams. The Audio family makes this information available to the Audio HAL so it can pass it along to its clients for synchronization purposes.</p></li>
<li class="li"><p>Call <code><!--a target="_top" -->setSampleOffset<!--/a--></code> to make sure that the Audio HAL stays at least the specified number of samples away from the I/O engine’s head. This setting is useful for block-transfer devices.</p></li>
<li class="li"><p>Create the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> objects to be used by the I/O engine and add them to the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code>. See <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJBBABA">“Creating IOAudioStream Objects”</a></span> for details.</p></li>
<li class="li"><p>Add a handler to your command gate for the interrupt fired by the I/O engine when it wraps to the beginning of the sample buffer. (This assumes a “traditional” interrupt.)</p></li>
<li class="li"><p>Perform any necessary engine-specific initializations.</p></li></ul>
<p><span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJCHEJF">Listing 3-7</a></span> illustrates how the SamplePCIAudioEngine class does some of these steps. Note that some initial values, such as <code>INITIAL_SAMPLE_RATE</code>, have been defined earlier using <code>#define</code> preprocessor commands. </p>
<a name="//apple_ref/doc/uid/TP30000732-BAJCHEJF" title="Listing 3-7Configuring the I/O engine"></a><p class="codesample"><strong>Listing 3-7&nbsp;&nbsp;</strong>Configuring the I/O engine</p>
<div class="codesample"><table><tr><td scope="row"><pre>bool SamplePCIAudioEngine::initHardware(IOService *provider)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    bool result = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOAudioSampleRate initialSampleRate;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOAudioStream *audioStream;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOWorkLoop *workLoop;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!super::initHardware(provider)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    initialSampleRate.whole = INITIAL_SAMPLE_RATE;<span></span></pre></td></tr><tr><td scope="row"><pre>    initialSampleRate.fraction = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    setSampleRate(&amp;initialSampleRate);<span></span></pre></td></tr><tr><td scope="row"><pre>    setDescription("Sample PCI Audio Engine");<span></span></pre></td></tr><tr><td scope="row"><pre>    setNumSampleFramesPerBuffer(NUM_SAMPLE_FRAMES);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    workLoop = getWorkLoop();<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!workLoop) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    interruptEventSource =  IOFilterInterruptEventSource::filterInterruptEventSource(this,<span></span></pre></td></tr><tr><td scope="row"><pre>            OSMemberFunctionCast(IOInterruptEventAction, this,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;SamplePCIAudioEngine::interruptHandler),<span></span></pre></td></tr><tr><td scope="row"><pre>            OSMemberFunctionCast(Filter, this,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;SamplePCIAudioEngine::interruptFilter),<span></span></pre></td></tr><tr><td scope="row"><pre>            audioDevice->getProvider());<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!interruptEventSource) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    workLoop->addEventSource(interruptEventSource);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    outputBuffer = (SInt16 *)IOMalloc(BUFFER_SIZE);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!outputBuffer) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    inputBuffer = (SInt16 *)IOMalloc(BUFFER_SIZE);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!inputBuffer) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    audioStream = createNewAudioStream(kIOAudioStreamDirectionOutput,<span></span></pre></td></tr><tr><td scope="row"><pre>                outputBuffer, BUFFER_SIZE);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!audioStream) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    addAudioStream(audioStream);<span></span></pre></td></tr><tr><td scope="row"><pre>    audioStream->release();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    audioStream = createNewAudioStream(kIOAudioStreamDirectionInput,<span></span></pre></td></tr><tr><td scope="row"><pre>                inputBuffer, BUFFER_SIZE);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!audioStream) {<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    addAudioStream(audioStream);<span></span></pre></td></tr><tr><td scope="row"><pre>    audioStream->release();<span></span></pre></td></tr><tr><td scope="row"><pre>    result = true;<span></span></pre></td></tr><tr><td scope="row"><pre>Done:<span></span></pre></td></tr><tr><td scope="row"><pre>    return result;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>The following section, <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJBBABA">“Creating IOAudioStream Objects,”</a></span> describes the implementation of <code>createNewAudioStream</code>, which this method calls. A couple of other things in this method merit a bit more discussion.</p>
<p>First, in the middle of the method are a few lines of code that create a filter interrupt event source and add it to the work loop. Through this event source, an event handler specified by the driver will receive interrupts fired by the I/O engine. In the case of SamplePCIAudioEngine, the driver wants the interrupt at primary interrupt time instead of secondary interrupt time because of the better periodic accuracy. To do this, it creates an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOFilterInterruptEventSource_h/Classes/IOFilterInterruptEventSource/index.html#//apple_ref/cpp/cl/IOFilterInterruptEventSource" target="_top">IOFilterInterruptEventSource</a></code> object that makes a filtering call to the primary interrupt handler (<code>interruptFilter</code>); the usual purpose of this callback is to determine which secondary interrupt handler should be called, if any. The SamplePCIAudioEngine in the <code>interruptFilter</code> routine (as you’ll see in <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJEEGDG">“Taking a Timestamp”</a></span>) calls the method that actually takes the timestamp and always returns <code>false</code> to indicate that the secondary handler should not be called. For the driver to receive interrupts, the event source must be enabled. This is typically done when the I/O engine is started. </p>
<p>Second, this method allocates input and output sample buffers in preparation for the creation of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> objects in the two calls to <code>createNewAudioStream</code>. The method of allocation in this example is rather rudimentary and would be more robust in a real driver. Also note that <code>BUFFER_SIZE</code> is defined earlier as:</p>
<div class="codesample"><table><tr><td scope="row"><pre>NUM_SAMPLE_FRAMES * NUM_CHANNELS * BIT_DEPTH / 8<span></span></pre></td></tr></table></div>
<p>In other words, compute the byte size of your sample buffers by multiplying the number of sample frames in the buffer by the number of the channels in the audio stream; then multiply that amount by the bit depth and divide the resulting amount by 8 (bit size of one byte).</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJBBABA" title="Creating IOAudioStream Objects"></a><h4>Creating IOAudioStream Objects</h4>
<p>Your <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass should also create its <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> objects when it initializes the I/O engine (<code><!--a target="_top" -->initHardware<!--/a--></code>). You should have one <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> instance for each sample buffer serviced by the I/O engine. In the process of creating an object, make sure that you do the following things:</p>
<ul class="spaceabove"><li class="li"><p>Initialize it with the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> object that uses it (in this case, your <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass instance).</p></li>
<li class="li"><p>Initialize the fields of a <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioTypes_h/index.html#//apple_ref/c/tdef/IOAudioStreamFormat" target="_top">IOAudioStreamFormat</a></code> structure with the values specific to a particular format.</p></li>
<li class="li"><p>Call <code><!--a target="_top" -->setSampleBuffer<!--/a--></code> to pass the actual hardware sample buffer to the stream. If the sample buffer resides in main memory, it should be allocated before you make this call.</p><p>The <code>SamplePCIAudioEngine</code> subclass allocates the sample buffers (input and output) in <code><!--a target="_top" -->initHardware<!--/a--></code> before it calls <code>createNewAudioStream</code>.</p></li>
<li class="li"><p>Call <code><!--a target="_top" -->addAvailableFormat<!--/a--></code> for each format to which the stream can be set. As part of the <code><!--a target="_top" -->addAvailableFormat<!--/a--></code> call, specify the minimum and maximum sample rates for that format.</p></li>
<li class="li"><p>Once you have added all supported formats to an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code>, call <code><!--a target="_top" -->setFormat<!--/a--></code> to specify the initial format for the hardware. Currently, <code><!--a target="_top" -->performFormatChange<!--/a--></code> is invoked as a result of the <code><!--a target="_top" -->setFormat<!--/a--></code> call.</p></li></ul>
<p><span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJEDHBG">Listing 3-8</a></span> shows how the SamplePCIAudioEngine subclass creates and initializes an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJEDHBG" title="Listing 3-8Creating and initializing an IOAudioStream object"></a><p class="codesample"><strong>Listing 3-8&nbsp;&nbsp;</strong>Creating and initializing an IOAudioStream object</p>
<div class="codesample"><table><tr><td scope="row"><pre>IOAudioStream *SamplePCIAudioEngine::createNewAudioStream(IOAudioStreamDirection<span></span></pre></td></tr><tr><td scope="row"><pre>                direction, void *sampleBuffer, UInt32 sampleBufferSize)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOAudioStream *audioStream;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    audioStream = new IOAudioStream;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (audioStream) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!audioStream->initWithAudioEngine(this, direction,  1)) {<span></span></pre></td></tr><tr><td scope="row"><pre>            audioStream->release();<span></span></pre></td></tr><tr><td scope="row"><pre>        } else {<span></span></pre></td></tr><tr><td scope="row"><pre>            IOAudioSampleRate rate;<span></span></pre></td></tr><tr><td scope="row"><pre>            IOAudioStreamFormat format = {<span></span></pre></td></tr><tr><td scope="row"><pre>                2,      // number of channels<span></span></pre></td></tr><tr><td scope="row"><pre>                kIOAudioStreamSampleFormatLinearPCM, // sample format<span></span></pre></td></tr><tr><td scope="row"><pre>                kIOAudioStreamNumericRepresentationSignedInt,<span></span></pre></td></tr><tr><td scope="row"><pre>                BIT_DEPTH,      // bit depth<span></span></pre></td></tr><tr><td scope="row"><pre>                BIT_DEPTH,      // bit width<span></span></pre></td></tr><tr><td scope="row"><pre>                kIOAudioStreamAlignmentHighByte,  // high byte aligned<span></span></pre></td></tr><tr><td scope="row"><pre>                kIOAudioStreamByteOrderBigEndian, // big endian<span></span></pre></td></tr><tr><td scope="row"><pre>                true,      // format is mixable<span></span></pre></td></tr><tr><td scope="row"><pre>                0      // driver-defined tag - unused by this driver<span></span></pre></td></tr><tr><td scope="row"><pre>            };<span></span></pre></td></tr><tr><td scope="row"><pre>            audioStream->setSampleBuffer(sampleBuffer, sampleBufferSize);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            rate.fraction = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>            rate.whole = 44100;<span></span></pre></td></tr><tr><td scope="row"><pre>            audioStream->addAvailableFormat(&amp;format, &amp;rate,  &amp;rate);<span></span></pre></td></tr><tr><td scope="row"><pre>            rate.whole = 48000;<span></span></pre></td></tr><tr><td scope="row"><pre>            audioStream->addAvailableFormat(&amp;format, &amp;rate,  &amp;rate);<span></span></pre></td></tr><tr><td scope="row"><pre>            audioStream->setFormat(&amp;format);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return audioStream;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP30000732-TPXREF107" title="Starting and Stopping the I/O Engine"></a><h3>Starting and Stopping the I/O Engine</h3>
<p>Your <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass must implement <code><!--a target="_top" -->performAudioEngineStart<!--/a--></code> and <code><!--a target="_top" -->performAudioEngineStop<!--/a--></code> to start and stop the I/O engine. When you start the engine, make sure it starts at the beginning of the sample buffer. Before starting the I/O engine, your implementation should do two things: </p>
<ul class="spaceabove"><li class="li"><p>Enable the interrupt event source to allow the I/O engine to fire interrupts as it wraps from the end to the beginning of the sample buffer; in its interrupt handler, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> instance can continually take timestamps.</p></li>
<li class="li"><p>Take an initial timestamp to mark the moment the audio engine started, but do so without incrementing the loop count.</p></li></ul>
<p>By default, the method <code><!--a target="_top" -->takeTimeStamp<!--/a--></code> automatically increments the current loop count as it takes the current timestamp. But because you are starting a new run of the I/O engine and are not looping, you don't want the loop count to be incremented. To indicate that, pass <code>false</code> into <code><!--a target="_top" -->takeTimeStamp<!--/a--></code>.</p>
<p><span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJCABJG">Listing 3-9</a></span> shows how the SamplePCIAudioEngine class implements the <code><!--a target="_top" -->performAudioEngineStart<!--/a--></code> method; the actual hardware-related code that starts the engine is not supplied.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJCABJG" title="Listing 3-9Starting the I/O engine"></a><p class="codesample"><strong>Listing 3-9&nbsp;&nbsp;</strong>Starting the I/O engine</p>
<div class="codesample"><table><tr><td scope="row"><pre>IOReturn SamplePCIAudioEngine::performAudioEngineStart()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("SamplePCIAudioEngine[%p]::performAudioEngineStart()\n",  this);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    assert(interruptEventSource);<span></span></pre></td></tr><tr><td scope="row"><pre>    interruptEventSource->enable();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    takeTimeStamp(false);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Add audio - I/O start code here<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#error performAudioEngineStart() - add engine-start code here; driver  will<span></span></pre></td></tr><tr><td scope="row"><pre>                                not work without it<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>In <code><!--a target="_top" -->performAudioEngineStop<!--/a--></code>, be sure to disable the interrupt event source before you stop the I/O engine.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJEEGDG" title="Taking a Timestamp"></a><h3>Taking a Timestamp</h3>
<p>A major responsibility of your <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass is to take a timestamp each time the I/O engine loops from the end of the sample buffer to the beginning of the sample buffer. Typically, you program the hardware to throw the interrupt when this looping occurs. You must also set up an interrupt handler to receive and process the interrupt. In the interrupt handler, simply call <code><!--a target="_top" -->takeTimeStamp<!--/a--></code> with no parameters; this method does the following:</p>
<ul class="spaceabove"><li class="li"><p>It gets the current (machine) time and sets it as the loop timestamp in the <code><a href="../../../../Darwin/Reference/IOKit/IOAudioTypes_h/index.html#//apple_ref/c/tdef/IOAudioEngineStatus" target="_top">IOAudioEngineStatus</a></code>-defined area of memory shared with Audio clients.</p></li>
<li class="li"><p>It increments the loop count in the same <code><a href="../../../../Darwin/Reference/IOKit/IOAudioTypes_h/index.html#//apple_ref/c/tdef/IOAudioEngineStatus" target="_top">IOAudioEngineStatus</a></code>-defined area of shared memory.</p></li></ul>
<p>The Audio HAL requires both pieces of updated information so that it can track where the I/O engine currently is and predict where it will be in the immediate future.</p>
<p>The SamplePCIAudioEngine subclass uses an <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOFilterInterruptEventSource_h/Classes/IOFilterInterruptEventSource/index.html#//apple_ref/cpp/cl/IOFilterInterruptEventSource" target="_top">IOFilterInterruptEventSource</a></code> object in its interrupt-handling mechanism. As <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJFJGGC">“Hardware Initialization”</a></span> describes, when the subclass creates this object, it specifies both an interrupt-filter routine and an interrupt-handler routine. The interrupt-handler routine, however, is never called; instead, the interrupt-filter routine calls another routine directly (<code>filterInterrupt</code>), which calls <code><!--a target="_top" -->takeTimeStamp<!--/a--></code>. <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJECIDE">Listing 3-10</a></span> shows this code.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJECIDE" title="Listing 3-10The SamplePCIAudioEngine interrupt filter and handler"></a><p class="codesample"><strong>Listing 3-10&nbsp;&nbsp;</strong>The SamplePCIAudioEngine interrupt filter and handler</p>
<div class="codesample"><table><tr><td scope="row"><pre>bool SamplePCIAudioEngine::interruptFilter(OSObject *owner,<span></span></pre></td></tr><tr><td scope="row"><pre>                            IOFilterInterruptEventSource *source)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    SamplePCIAudioEngine *audioEngine = OSDynamicCast(SamplePCIAudioEngine,<span></span></pre></td></tr><tr><td scope="row"><pre>            owner);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (audioEngine) {<span></span></pre></td></tr><tr><td scope="row"><pre>        audioEngine->filterInterrupt(source->getIntIndex());<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return false;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void SamplePCIAudioEngine::filterInterrupt(int index)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    takeTimeStamp();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>Note that you can specify your own timestamp in place of the system’s by calling <code><!--a target="_top" -->takeTimeStamp<!--/a--></code> with an <code><a href="../../../../Darwin/Conceptual/KernelProgramming/services/services.html#//apple_ref/doc/uid/TP30000905-CH219-CHDJBFEF" target="_top">AbsoluteTime</a></code> parameter (see <span class="content_text"><a href="http://developer.apple.com/qa/qa2004/qa1398.html" target="_top">Technical Q&amp;A QA1398</a></span> and the “<span class="content_text"><a href="../../../../Darwin/Conceptual/KernelProgramming/services/services.html#//apple_ref/doc/uid/TP30000905-CH219-CHDJBFEF" target="_top">Using Kernel Time Abstractions</a></span>” section of <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em> for information on <code><a href="../../../../Darwin/Conceptual/KernelProgramming/services/services.html#//apple_ref/doc/uid/TP30000905-CH219-CHDJBFEF" target="_top">AbsoluteTime</a></code>). This alternative typically isn’t necessary but may be used in cases where the looping isn’t detectable until some time after the actual loop time. In that case, the delay can be subtracted from the current time to indicate when the loop occurred in the past.</p>
<div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/TP30000732-DontLinkElementID_20" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;
It is crucial to provide a reasonable timestamp, particularly with USB devices. The CoreAudio HAL does additional filtering of timestamps to compensate for deficiencies in USB. If your timestamps are not reasonably close to the expected timestamp (and in particular, if your timestamps are too far in the future), they will be ignored. This can result in various audio glitches and artifacts.</p><p>
If you are experiencing pops and other glitches, try setting your transport type to something other than <code><!--a  -->kIOAudioDeviceTransportTypeUSB<!--/a--></code>. If this significantly improves the situation, you likely have something wrong with your timestamps. (Note, however, that lack of improvement does not necessarily vindicate your timestamps.)</p><p>
If you are experiencing unexplained glitches in audio playback, the timestamps are the most likely cause. You should use the HALLab tool (available in the CoreAudio SDK, or preinstalled as part of Xcode) to help you determine what is causing the failure.</p><p></p><div class="clear"></div></div>
<a name="//apple_ref/doc/uid/TP30000732-TPXREF108" title="Providing a Playback Frame Position"></a><h3>Providing a Playback Frame Position</h3>
<p>An <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass must implement the <code><!--a target="_top" -->getCurrentSampleFrame<!--/a--></code> to return the playback hardware’s current frame to the caller. This value (as you can see in <span class="content_text"><a href="../AudioFamilyDesign/AudioFamilyDesign.html#//apple_ref/doc/uid/TP30000731-TPXREF116">Figure 2-5</a></span>) tells the caller where playback is occurring relative to the start of the buffer.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000732-DontLinkElementID_21" title="Note"></a><p><strong>Note:</strong>&nbsp;A common mistake is to report the number of frames played since the start of <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> processing. The value the <code><!--a target="_top" -->getCurrentSampleFrame<!--/a--></code> method returns should be equal to that value modulo the number of frames per buffer.</p></div>
<p>The erase-head process uses this value; it erases (zeroes out) frames in the sample and mix buffers up to, but not including, the sample frame returned by this method. Thus, although the sample counter value returned doesn’t have to be exact, it should never be larger than the actual sample counter. If it is larger, audio data may be erased by the erase head before the hardware has a chance to play it.</p>
<a name="//apple_ref/doc/uid/TP30000732-TPXREF109" title="Implementing Format and Rate Changes"></a><h3>Implementing Format and Rate Changes</h3>
<p>If an audio driver supports multiple audio formats or sample rates, it must implement the <code><!--a target="_top" -->performFormatChange<!--/a--></code> method to make these changes in the hardware when clients request them. The method has parameters for a new format and for a new sample rate; if either of these parameters is <code>NULL</code>, the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> subclass should change only the item that isn’t <code>NULL</code>.</p>
<p>Although the SamplePCIAudioDriver driver deals with only one audio format, it is capable of two sample rates, 44.1 kilohertz and 48 kilohertz. <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJJCDBB">Listing 3-11</a></span> illustrates how <code><!--a target="_top" -->performFormatChange<!--/a--></code> is implemented to change a sample rate upon request.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJJCDBB" title="Listing 3-11Changing the sample rate"></a><p class="codesample"><strong>Listing 3-11&nbsp;&nbsp;</strong>Changing the sample rate</p>
<div class="codesample"><table><tr><td scope="row"><pre>IOReturn SamplePCIAudioEngine::performFormatChange(IOAudioStream<span></span></pre></td></tr><tr><td scope="row"><pre>        *audioStream, const IOAudioStreamFormat *newFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>        const IOAudioSampleRate *newSampleRate)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("SamplePCIAudioEngine[%p]::peformFormatChange(%p,  %p, %p)\n", this,<span></span></pre></td></tr><tr><td scope="row"><pre>        audioStream, newFormat, newSampleRate);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (newSampleRate) {<span></span></pre></td></tr><tr><td scope="row"><pre>        switch (newSampleRate->whole) {<span></span></pre></td></tr><tr><td scope="row"><pre>            case 44100:<span></span></pre></td></tr><tr><td scope="row"><pre>                IOLog("/t-> 44.1kHz selected\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                // Add code to switch hardware to 44.1khz<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            case 48000:<span></span></pre></td></tr><tr><td scope="row"><pre>                IOLog("/t-> 48kHz selected\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                // Add code to switch hardware to 48kHz<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            default:<span></span></pre></td></tr><tr><td scope="row"><pre>                IOLog("/t Internal Error - unknown sample rate  selected.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p></p>
<a name="//apple_ref/doc/uid/TP30000732-BAJCBIAF" title="Clipping and Converting Samples"></a><h2>Clipping and Converting Samples</h2>
<p>Arguably, the most important work that an audio device driver does is converting audio samples between the format expected by the hardware and the format expected by the clients of the hardware. In Mac OS X, the default format of audio data in the kernel as well as in the Audio HAL and all of its clients is 32-bit floating point. However, audio hardware typically requires audio data to be in an integer format.</p>
<p>To perform these conversions, your audio driver must implement at least one of two methods, depending on the directions of the audio streams supported:</p>
<ul class="ul"><li class="li"><p>Implement <code><!--a target="_top" -->clipOutputSamples<!--/a--></code> if your driver has an output <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object.</p></li>
<li class="li"><p>Implement <code><!--a target="_top" -->convertInputSamples<!--/a--></code> if your driver has an input <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object.</p></li></ul>
<p>In addition to performing clipping and conversion, these methods are also a good place to add device-specific input and output filtering code. For example, a particular model of USB speakers might sound better with a slight high frequency roll-off. (Note that if this is the only reason for writing a driver, you should generally use an <code>AppleUSBAudio</code> plug-in instead, as described in the <em><a href="../../../../../samplecode/SampleUSBAudioPlugin/index.html#//apple_ref/doc/uid/DTS10003471" target="_top">SampleUSBAudioPlugin</a></em> example code.)</p>
<p>Because these methods execute floating-point code, you cannot include them in the same source file as the other <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioEngine_h/Classes/IOAudioEngine/index.html#//apple_ref/cpp/cl/IOAudioEngine" target="_top">IOAudioEngine</a></code> methods you implement. The compiler, by default, enables floating-point emulation to prevent floating-point instructions from being generated. To get around this, create a separate library that contains the floating-point code and compile and link this library into the resulting kernel module. The separate library for the SamplePCIAudioDriver project is <code>libAudioFloatLib</code>.</p>
<p>A common mistake that people make when developing an audio driver is either failing to write these methods or failing to include this additional library when linking the KEXT. When this occurs, you will execute the <code><!--a target="_top" -->clipOutputSamples<!--/a--></code> and <code><!--a target="_top" -->convertInputSamples<!--/a--></code> methods that are built into the base class. These methods are just stubs that return <code><!--a  -->kIOReturnUnsupported<!--/a--></code> (<code>0xe00002c7</code>, or <code>-536870201</code>). If you see this error returned by one of these methods, you should make sure you are linking your KEXT together correctly.</p>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP30000732-DontLinkElementID_22" title="Important:"></a><p><strong>Important:</strong>&nbsp;
See the project configuration for SamplePCIAudioDriver (or any other example audio-driver project) to find out how to generate this separate static library and include it in your project. Pay particular attention to the required compiler options.</p><p></p></div>
<p>The <code><!--a target="_top" -->clipOutputSamples<!--/a--></code> method is passed six parameters:</p>
<ul class="ul"><li class="li"><p>A pointer to the start of the source (mix) buffer</p></li>
<li class="li"><p>A pointer to the start of the destination (sample) buffer</p></li>
<li class="li"><p>The index of the first sample frame in the buffers to clip and convert</p></li>
<li class="li"><p>The number of sample frames to clip and convert</p></li>
<li class="li"><p>A pointer to the current format (structure <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioTypes_h/index.html#//apple_ref/c/tdef/IOAudioStreamFormat" target="_top">IOAudioStreamFormat</a></code>) of the audio stream</p></li>
<li class="li"><p>A pointer to the <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOAudioStream_h/Classes/IOAudioStream/index.html#//apple_ref/cpp/cl/IOAudioStream" target="_top">IOAudioStream</a></code> object this method is working on</p></li></ul>
<p>Your implementation must first clip any floating-point samples in the mix buffer that fall outside the range –1.0 to 1.0 and then convert the floating-point value to the comparable value in the format expected by the hardware. Then copy that value to the corresponding positions in the sample buffer. <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJGICGJ">Listing 3-12</a></span> illustrates how the SamplePCIAudioDriver implements the <code><!--a target="_top" -->clipOutputSamples<!--/a--></code> method.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJGICGJ" title="Listing 3-12Clipping and converting output samples"></a><p class="codesample"><strong>Listing 3-12&nbsp;&nbsp;</strong>Clipping and converting output samples</p>
<div class="codesample"><table><tr><td scope="row"><pre>IOReturn SamplePCIAudioEngine::clipOutputSamples(const void *mixBuf,<span></span></pre></td></tr><tr><td scope="row"><pre>        void *sampleBuf, UInt32 firstSampleFrame, UInt32 numSampleFrames,<span></span></pre></td></tr><tr><td scope="row"><pre>        const IOAudioStreamFormat *streamFormat, IOAudioStream *audioStream)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 sampleIndex, maxSampleIndex;<span></span></pre></td></tr><tr><td scope="row"><pre>    float *floatMixBuf;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt16 *outputBuf;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    floatMixBuf = (float *)mixBuf;<span></span></pre></td></tr><tr><td scope="row"><pre>    outputBuf = (SInt16 *)sampleBuf;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    maxSampleIndex = (firstSampleFrame + numSampleFrames) *<span></span></pre></td></tr><tr><td scope="row"><pre>                        streamFormat->fNumChannels;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    for (sampleIndex = (firstSampleFrame * streamFormat->fNumChannels);<span></span></pre></td></tr><tr><td scope="row"><pre>                        sampleIndex &lt; maxSampleIndex; sampleIndex++)  {<span></span></pre></td></tr><tr><td scope="row"><pre>        float inSample;<span></span></pre></td></tr><tr><td scope="row"><pre>        inSample = floatMixBuf[sampleIndex];<span></span></pre></td></tr><tr><td scope="row"><pre>        const static float divisor = ( 1.0 / 32768 );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Note: A softer clipping operation could be done here<span></span></pre></td></tr><tr><td scope="row"><pre>        if (inSample > (1.0 - divisor)) {<span></span></pre></td></tr><tr><td scope="row"><pre>            inSample = 1.0 - divisor;<span></span></pre></td></tr><tr><td scope="row"><pre>        } else if (inSample &lt; -1.0) {<span></span></pre></td></tr><tr><td scope="row"><pre>            inSample = -1.0;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        outputBuf[sampleIndex] = (SInt16) (inSample * 32768.0);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>Here are a few comments on this specific example:</p>
<ol class="ol"><li class="li"><p>It starts by casting the <code>void *</code> buffers to <code>float *</code> for the mix buffer and<code> SInt16
*</code> for the sample buffer; in this project, the hardware uses signed 16-bit integers for its samples while the mix buffer is always <code>float *</code>.</p></li>
<li class="li"><p>Next, it calculates the upper limit on the sample index for the upcoming clipping and converting loop.</p></li>
<li class="li"><p>The method loops through the mix and sample buffers and performs the clip and conversion operations on one sample at a time. </p><ol class="ol"><li class="ol ol"><p>It fetches the floating-point sample from the mix buffer and clips it (if necessary) to a range between -1.0 and 1.0.</p></li>
<li class="ol ol"><p>It scales and converts the floating-point value to the appropriate signed 16-bit integer sample and writes it to the corresponding location in the sample buffer.</p></li></ol></li></ol>
<p>The parameters passed into the <code><!--a target="_top" -->convertInputSamples<!--/a--></code> method are <em>almost</em> the same as those for the <code><!--a target="_top" -->clipOutputSamples<!--/a--></code> method. The only difference is that, instead of a pointer to the mix buffer, a pointer to a floating-point destination buffer is passed; this is the buffer that the Audio HAL uses. In your driver’s implementation of this method, do the opposite of the <code><!--a target="_top" -->clipOutputSamples<!--/a--></code>: convert from the hardware format to the system 32-bit floating point format. No clipping is necessary because your conversion process can control the bounds of the floating-point values.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000732-DontLinkElementID_23" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code><!--a target="_top" -->convertInputSamples<!--/a--></code> method should begin writing at the <em>beginning</em> of the destination buffer, unlike <code><!--a-->clipOuputSamples<!--/a--></code>, which writes at an offset based on the index passed in.</p></div>
<p><span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJDIEDI">Listing 3-13</a></span> shows how the SamplePCIAudioDriver project implements this method.</p>
<a name="//apple_ref/doc/uid/TP30000732-BAJDIEDI" title="Listing 3-13Converting input samples."></a><p class="codesample"><strong>Listing 3-13&nbsp;&nbsp;</strong>Converting input samples.</p>
<div class="codesample"><table><tr><td scope="row"><pre>IOReturn SamplePCIAudioEngine::convertInputSamples(const void *sampleBuf,<span></span></pre></td></tr><tr><td scope="row"><pre>        void *destBuf, UInt32 firstSampleFrame, UInt32 numSampleFrames,<span></span></pre></td></tr><tr><td scope="row"><pre>        const IOAudioStreamFormat *streamFormat, IOAudioStream<span></span></pre></td></tr><tr><td scope="row"><pre>        *audioStream)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 numSamplesLeft;<span></span></pre></td></tr><tr><td scope="row"><pre>    float *floatDestBuf;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt16 *inputBuf;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Note: Source is offset by firstSampleFrame<span></span></pre></td></tr><tr><td scope="row"><pre>    inputBuf = &amp;(((SInt16 *)sampleBuf)[firstSampleFrame *<span></span></pre></td></tr><tr><td scope="row"><pre>                            streamFormat->fNumChannels]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Note: Destination is not.<span></span></pre></td></tr><tr><td scope="row"><pre>    floatDestBuf = (float *)destBuf;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    numSamplesLeft = numSampleFrames * streamFormat->fNumChannels;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    const static float divisor = ( 1.0 / 32768 );<span></span></pre></td></tr><tr><td scope="row"><pre>    while (numSamplesLeft > 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        SInt16 inputSample;<span></span></pre></td></tr><tr><td scope="row"><pre>        inputSample = *inputBuf;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (inputSample >= 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>            *floatDestBuf = inputSample * divisor;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        ++inputBuf;<span></span></pre></td></tr><tr><td scope="row"><pre>        ++floatDestBuf;<span></span></pre></td></tr><tr><td scope="row"><pre>        --numSamplesLeft;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>The code in <span class="content_text">Listing 3-13</span> does the following things:</p>
<ol class="ol"><li class="li"><p>It starts by casting the destination buffer to a <code>float *</code>.</p></li>
<li class="li"><p>It casts the sample buffer to a signed 16-bit integer and determines the starting point within this input buffer for conversion.</p></li>
<li class="li"><p>It calculates the number of actual samples to convert.</p></li>
<li class="li"><p>It loops through the samples, scaling each to within a range of –1.0 to 1.0 (thus converting it to a float) and storing it in the destination buffer at the proper location.</p></li></ol>
<a name="//apple_ref/doc/uid/TP30000732-TPXREF110" title="Debugging and Testing the Driver"></a><h2>Debugging and Testing the Driver</h2>
<p>Many of the techniques you would use in debugging and testing an audio driver are the same ones you’d use with other types of device drivers. After all, any I/O Kit driver has a structure and a behavior that are similar to any other I/O Kit driver, regardless of family. </p>
<p>For example, it’s always a good idea when a driver is under development to make <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOLib_h/index.html#//apple_ref/c/func/IOLog" target="_top">IOLog</a></code> calls at critical points in your code, such as before and after an I/O transfer. The <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOLib_h/index.html#//apple_ref/c/func/IOLog" target="_top">IOLog</a></code> function writes a message to the console (accessible through the Console application) and to <code>/var/log/system.log</code>. You can format the message string with variable data in the style of <code><!--a-->printf<!--/a--></code>.</p>
<p>Similarly, you can examine the I/O Registry with the I/O Registry Explorer application or the <code>ioreg</code> command-line utility. The I/O Registry will show the position of your driver’s objects in the driver stack, the client-provider relationships among them, and the attributes of those driver objects. In <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-BAJCGDHH">Figure 3-2</a></span>, the I/O Registry Explorer shows part of the objects and their attributes in a USB audio device driver.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000732-BAJCGDHH" title="Figure 3-2The I/O Registry (via I/O Registry Explorer)"></a><p><strong>Figure 3-2&nbsp;&nbsp;</strong>The I/O Registry (via I/O Registry Explorer)</p><img src = "../Art/appleusbaudio_regexp.gif" alt = "The I/O Registry (via I/O Registry Explorer)" width="439" height="410"></div><br/>
<p>However, as <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-CJBCAIBF">“Custom Debugging Information in the I/O Registry”</a></span> explains, your driver can insert information in the I/O Registry to assist the testing and debugging of your driver.</p>
<a name="//apple_ref/doc/uid/TP30000732-TPXREF111" title="Tools for Testing Audio Drivers"></a><h3>Tools for Testing Audio Drivers</h3>
<p>The Mac OS X Developer package provides two applications that are helpful when you’re testing audio driver software. These items are not shipped as executables, but are instead included as example-code projects installed in <code>/Developer/Examples/CoreAudio/HAL</code>. The two projects that are of interest are HALLab and MillionMonkeys. To obtain the executables, copy the project folders to your home directory (or any file-system location where you have write access) and build the projects.</p>
<p>The HALLab application helps you verify the controls and other attributes of a loaded audio driver. With it, you can play back sound files to any channel of a device, check whether muting and volume changes work for every channel, test input operation, enable soft play through, view the device object hierarchy, and do various other tests.</p>
<p><span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-CJBBJAAD">Figure 3-3</a></span> and <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-CJBDFJJF">Figure 3-4</a></span> show you what two of the HALLab windows look like.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000732-CJBBJAAD" title="Figure 3-3The HALLab System window"></a><p><strong>Figure 3-3&nbsp;&nbsp;</strong>The HALLab System window</p>
<img src = "../Art/system_info.gif" alt = "The HALLab System window" width="368" height="415"></div><br/>
<br/><div><a name="//apple_ref/doc/uid/TP30000732-CJBDFJJF" title="Figure 3-4The HALLab IO Cycle Telemetry window"></a><p><strong>Figure 3-4&nbsp;&nbsp;</strong>The HALLab IO Cycle Telemetry window</p>
<img src = "../Art/io_cycle.gif" alt = "The HALLab IO Cycle Telemetry window" width="924" height="474"></div><br/>
<p>The MillionMonkeys application was designed for performance profiling of your driver. In particular, it allows you to determine latency at various steps of audio processing while the system is under load. This can aid in tracking down performance-related issues with audio drivers. <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-CJBDCICJ">Figure 3-5</a></span> and <span class="content_text"><a href="ImplementDriver.html#//apple_ref/doc/uid/TP30000732-CJBBJHGD">Figure 3-6</a></span> show the two panes of the MillionMonkeys application window.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000732-CJBDCICJ" title="Figure 3-5The MillionMonkeys Device &amp;amp; Workload pane"></a><p><strong>Figure 3-5&nbsp;&nbsp;</strong>The MillionMonkeys Device &amp; Workload pane</p><img src = "../Art/device_workload.gif" alt = "The MillionMonkeys Device &amp; Workload pane" width="886" height="697"></div><br/>
<br/><div><a name="//apple_ref/doc/uid/TP30000732-CJBBJHGD" title="Figure 3-6The MillionMonkeys Data Collection &amp;amp; Display pane"></a><p><strong>Figure 3-6&nbsp;&nbsp;</strong>The MillionMonkeys Data Collection &amp; Display pane</p><img src = "../Art/data_collection.gif" alt = "The MillionMonkeys Data Collection &amp; Display pane" width="884" height="700"></div><br/>
<a name="//apple_ref/doc/uid/TP30000732-CJBCAIBF" title="Custom Debugging Information in the I/O Registry"></a><h3>Custom Debugging Information in the I/O Registry</h3>
<p>Another way you can test and debug your audio device driver is to write custom properties to the I/O Registry. For example, you may want to track hardware register state or internal driver state (if the driver has any). Whenever your driver makes a change to the hardware state, it could read the hardware register values and call <code>setProperty</code> with the current value. Then, when testing the driver, run the I/O Registry Explorer application and note what the I/O Registry shows this value to be. This technique allows you to easily determine if the driver is putting the hardware in the correct state.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AudioFamilyDesign/AudioFamilyDesign.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CustomControls/CustomControls.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WritingAudioDrivers/ImplementDriver/ImplementDriver.html%3Fid%3DTP30000729-3.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WritingAudioDrivers/ImplementDriver/ImplementDriver.html%3Fid%3DTP30000729-3.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WritingAudioDrivers/ImplementDriver/ImplementDriver.html%3Fid%3DTP30000729-3.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>