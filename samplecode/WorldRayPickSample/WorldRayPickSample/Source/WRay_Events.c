/*  *	WRay_Events.c * *	QuickDraw 3D 1.6 Sample *	Robert Dierkes * *	 07/28/98	RDD		Created. *//*------------------*//*	Include Files	*//*------------------*/#include "QD3D.h"#if defined(OS_MACINTOSH) && OS_MACINTOSH#include <EPPC.h>#include <DiskInit.h>#include <ToolUtils.h>#endif#include "WRay_Error.h"#include "WRay_Document.h"#include "WRay_Events.h"#include "WRay_Main.h"#include "WRay_Menu.h"#include "WRay_Pick.h"#include "WRay_Scene.h"#include "WRay_System.h"/*------------------*//*	  Constants		*//*------------------*//*----------------------*//*	Extern Declarations	*//*----------------------*/extern	TDocument	gDocument;extern	TQ3Boolean	gTimeToQuit;/*----------------------*//*   Type Definitions	*//*----------------------*//*----------------------*//*   Local Prototypes   *//*----------------------*/staticvoid	Events_Activate (			EventRecord				*pEvent);staticvoid	Events_MouseDown (			EventRecord				*pEvent);staticvoid	Events_KeyPress (			EventRecord				*pEvent);staticvoid	Events_Disk (			EventRecord				*pEvent);staticvoid	Events_HandleApp4Event (			EventRecord				*pEvent);staticvoid	Events_ClickInContent(			EventRecord				*pEvent,			TDocumentPtr			pDocument);staticvoid	Events_GrowBox (			EventRecord				*pEvent,			WindowPtr				pWindow);staticvoid	Events_ZoomBox (			EventRecord				*pEvent,			WindowPtr				pWindow,			short					windowPart);/* *	Events_Initialize */Boolean Events_Initialize(			void){	FlushEvents(everyEvent, 0);	return true;}/* *	Events_Process */void Events_Process(	void){	EventRecord 	event;	Boolean			doEvent;	while (! gTimeToQuit) {		/* Is there an event in the queue? */		doEvent = WaitNextEvent(everyEvent, &event, 0, NULL);		switch (event.what) {			case nullEvent:				if (Pick_Animate(&gDocument) == kQ3Success) {					Document_Draw(&gDocument);					Scene_Rotate();				}				else {					if (Scene_Rotate() == kQ3Success) {						Document_Draw(&gDocument);					}				}				break;			case mouseDown:				Events_MouseDown(&event);				break;			case keyDown:			case autoKey:				Events_KeyPress(&event);				break;			case updateEvt:				(void) Events_Update (&event);				break;			case activateEvt:				Events_Activate (&event);				break;			case diskEvt:				Events_Disk (&event);				break;			case mouseUp:			case keyUp:			case osEvt:			case kHighLevelEvent:				break;		}	}}#pragma mark -/* *	Events_Update */Boolean Events_Update (			EventRecord *pEvent){	GrafPtr			savedPort;	WindowPtr		pUpdateWindow;	Boolean			wasUpdated;	pUpdateWindow = (WindowPtr) pEvent->message;	GetPort (&savedPort);	SetPort (pUpdateWindow);	if (pUpdateWindow == gDocument.fWindow) {		BeginUpdate (pUpdateWindow);		(void) Document_Draw(&gDocument);		EndUpdate (pUpdateWindow);		wasUpdated = true;	}	else {		/* Unknown window */		wasUpdated = false;	}	SetPort (savedPort);	return wasUpdated;}/* *	Events_Activate */staticvoid Events_Activate (			EventRecord	*pEvent){	WindowPtr		pActiveWindow;	pActiveWindow = (WindowPtr) pEvent->message;	/* Activate window */	if (pEvent->modifiers & activeFlag)	{		/* Enable/Disable items */		SetPort (pActiveWindow);	}	else	/* Deactivate window */	{		/* Enable/Disable items */	}}/* *	Events_MouseDown */staticvoid Events_MouseDown(			EventRecord *pEvent){	WindowPtr	pWindow;	short		windowPart;	windowPart = FindWindow(pEvent->where, &pWindow);	switch (windowPart) {		case inMenuBar: 			Menu_Command (MenuSelect (pEvent->where), &gDocument);			break;		case inSysWindow:			SystemClick (pEvent, pWindow);			break;		case inDrag:			{				Rect	bounds;				bounds = (**GetGrayRgn()).rgnBBox;				/* Must SetPort before dragging */				SetPort (pWindow);				DragWindow(pWindow, pEvent->where, &bounds);				bounds = pWindow->portRect;				LocalToGlobal((Point *) &bounds.top);				LocalToGlobal((Point *) &bounds.bottom);			}			break;		case inGrow:			Events_GrowBox (pEvent, pWindow);			break;		case inContent:			if (FrontWindow() != pWindow) {				SelectWindow(pWindow);			}			SetPort (pWindow);			if (pWindow == NULL) {				DEBUG_ASSERT(pWindow != NULL,pWindow)			}			else {				Events_ClickInContent(pEvent, &gDocument);			}		break;		case inGoAway:			if (TrackGoAway(pWindow, pEvent->where)) {				/* Main */				if (pWindow == gDocument.fWindow) {					gTimeToQuit = kQ3True;				}				else				{					/**/				}			}			break;	case inZoomIn:	case inZoomOut:		Events_ZoomBox (pEvent, pWindow, windowPart);		break;		default:			break;	}}/* *	Events_KeyPress */staticvoid Events_KeyPress(			EventRecord		*pEvent){	char	charCode;	charCode = pEvent->message & charCodeMask;	if (pEvent->modifiers & btnState)	{		/* Button is UP with a key */		if (pEvent->modifiers & cmdKey) {			Menu_Command (MenuKey (charCode), &gDocument);		}		else {		}	}	else {		/* Button is DOWN with a key */	}}/* *	Events_Disk */staticvoid Events_Disk(			EventRecord *pEvent){	Point	topLeft;	SetPt(&topLeft, 100, 100);	if (HiWord(pEvent->message) != noErr)		(void) DIBadMount(topLeft, pEvent->message);}#pragma mark -/* *	Events_ClickInContent */staticvoid Events_ClickInContent(			EventRecord		*pEvent,			TDocumentPtr	pDocument){	#pragma unused(pEvent)	#pragma unused(pDocument)}/* *	Events_GrowBox */staticvoid Events_GrowBox (			EventRecord		*pEvent,			WindowPtr		pWindow){	long		newSize;	Rect		newRect,				oldRect,				screenRect;	GrafPtr		savedPort;	screenRect = (**GetGrayRgn()).rgnBBox;	screenRect.left =	screenRect.top  = 64;	oldRect = newRect = pWindow->portRect;	GetPort (&savedPort);	SetPort (pWindow);	newSize = GrowWindow (pWindow, pEvent->where, &screenRect);	if (newSize != 0)	{		newRect.right	= newRect.left + (short) newSize;		newRect.bottom	= newRect.top  + (short) (newSize >> 16);		SizeWindow (pWindow,					newRect.right  - newRect.left,					newRect.bottom - newRect.top,					true);		InvalRect (&oldRect);		Document_UpdateCameraAspectRatio (&gDocument, &newRect);	}	SetPort (savedPort);}/* *	Events_ZoomBox */staticvoid Events_ZoomBox (			EventRecord		*pEvent,			WindowPtr		pWindow,			short			windowPart){	Rect	bounds;	GrafPtr	savedPort;	GetPort (&savedPort);	SetPort (pWindow);/**/	if (TrackBox (pWindow, pEvent->where, windowPart))	{		ZoomWindow (pWindow, windowPart, true);		bounds = pWindow->portRect;		InvalRect (&bounds);		Document_UpdateCameraAspectRatio (&gDocument, &bounds);	}	SetPort (savedPort);}