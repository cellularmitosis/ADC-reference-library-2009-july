<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>AEObject-Edition Sample - /Windows.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">AEObject-Edition Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">AEObject-Edition Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Windows.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AEObject-Edition Sample.r</option>
<option value="listing2.html">/AEObject.c</option>
<option value="listing3.html">/AEUtilities.c</option>
<option value="listing4.html">/AppleEventCore.c</option>
<option value="listing5.html">/BuildHeaders.c</option>
<option value="listing6.html">/Files.c</option>
<option value="listing7.html">/globals.c</option>
<option value="listing8.html">/Initialize.c</option>
<option value="listing9.html">/Macros.h</option>
<option value="listing10.html">/main.c</option>
<option value="listing11.html">/Menu.c</option>
<option value="listing12.html">/Print.c</option>
<option value="listing13.html">/prototypes.h</option>
<option value="listing14.html">/Publish.c</option>
<option value="listing15.html">/SampConstants.h</option>
<option value="listing16.html">/Sampdefines.h</option>
<option value="listing17.html">/Structs.h</option>
<option value="listing18.html">/Subscribe.c</option>
<option value="listing19.html">/TextSections.c</option>
<option value="listing20.html">/Utilities.c</option>
<option value="listing21.html">/Windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="AEObject-Edition_Sample.zip">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.zip&#148;, 895.6K)<BR>
<strong><a href="AEObject-Edition_Sample.dmg">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.dmg&#148;, 1.22M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*------------------------------------------------------------------------------**  Apple Developer Technical Support**  **  Program: AEObject-Edition Sample*  File:   Windows.c -C Source**  by: C.K. Haun &lt;TR&gt;**  Copyright &copy; 1990-1992 Apple Computer, Inc.*  All rights reserved.**------------------------------------------------------------------------------* This file contains some of our window handling routines.   * It also contains the clipboard handlers*----------------------------------------------------------------------------*/#define __MYWINDOWS__#include &quot;Sampdefines.h&quot;#pragma segment MyWindowsstatic void DragPictOrObject(Point *where, windowCHandle tempWC);/* AddNewWindow creates and initializes a new document window. *//* It returns false in this example if there are already 10 windows open. */WindowPtr AddNewWindow(Boolean showIt){    windowCHandle setControls;    WindowPtr tempWP;    Handle tempHand;    short cnt = 0;    Str31 wtitle;    tempWP = GetNewWindow(kDocWindow, 0, (WindowPtr)-1);        /* get a new window */    ((WindowPeek)tempWP)-&gt;windowKind = kDocumentWindow;     /* mark it as a document window */    tempHand = NewHandleClear(sizeof(windowControl));       /* add our control structure to it */    ((WindowPeek)tempWP)-&gt;refCon = tempHand;                /* and attach the controller to the window */    setControls = (windowCHandle)((WindowPeek)tempWP)-&gt;refCon;      /* and put it where we can use it */    HLock((Handle)setControls);                             /* lock it down while we fill it*/        /* add pointers to our procedures for drawing, saving, and closing */    /* This way, all I need is one dispatch point for drawing, closing */    /* or whatever, I don't have to case off the window kind to go to the  */    /* correct routine.  Kinda like object-oriented programming, but I won't */    /* admit that. */    (*setControls)-&gt;drawMe = (ProcPtr)DrawFull;    (*setControls)-&gt;saveMe = (ProcPtr)SaveMe;    (*setControls)-&gt;closeMe = (ProcPtr)CloseMyWindow;    (*setControls)-&gt;clickMe = (ProcPtr)DoDocumentClick;    (*setControls)-&gt;sizeMe = (ProcPtr)NilProc;    /* now initialize all our required handles */    (*setControls)-&gt;pubs = NewHandle(0);    (*setControls)-&gt;pubRects = NewHandle(0);    (*setControls)-&gt;numPubs = 0;    (*setControls)-&gt;subs = NewHandle(0);    (*setControls)-&gt;subRects = NewHandle(0);    (*setControls)-&gt;subDataHandle = NewHandle(0);    (*setControls)-&gt;numSubs = 0;    (*setControls)-&gt;pictHandle = NewHandle(0);    (*setControls)-&gt;pictRects = NewHandle(0);    (*setControls)-&gt;numPicts = 0;    /* init shapes */    (*setControls)-&gt;theShapes = nil;    (*setControls)-&gt;numShapes = 0;    /* initialize our control codes and counts */    (*setControls)-&gt;currentAction = 0;    (*setControls)-&gt;undoAction = 0;    (*setControls)-&gt;hasSelection = false;    (*setControls)-&gt;windowDirty = false;    /* I am using this window ID to identify the sections (publishers and subscribers) */    /* that are associated with this window */    (*setControls)-&gt;windowID = gMasterWindowID;    gMasterWindowID += 10000;                               /* update for next window */    /* clear the file spec for the file this document will be saved to */    /* since the handle is nil, I know this window hasn't been saved yet. */    (*setControls)-&gt;fileAliasHandle = (AliasHandle)NewHandle(0);    (*setControls)-&gt;boxHandle = nil;                        /* no textedit field */    (*setControls)-&gt;textSections = nil;    /* if there already is a window (or more) add a count to this title */    if (showIt) {        short docWCount = 0;        WindowPtr ourWindows = (WindowPtr)LMGetWindowList();                   /* grab the first window from the global WindowList */        Str32 numOfW;        GetWTitle(tempWP, wtitle);                          /* get our current title (untitled) */        while (ourWindows) {                                /* count 'em up */            if (((WindowPeek)ourWindows)-&gt;windowKind == kDocumentWindow)                docWCount++;                                /* only count doc windows o' course */            ourWindows = (WindowPtr)((WindowPeek)ourWindows)-&gt;nextWindow;        } /* end ourWindows while */        /* change the number to text, and append it */        NumToString((long)docWCount, numOfW);        AppendString(wtitle, numOfW);        SetWTitle(tempWP, wtitle);        ShowWindow(tempWP);                                 /* show it */    }    HUnlock((Handle)setControls);    SetPort(tempWP);    SetUndo(0, false);                                      /* since it is the current window, set all the actions to default */    SetCurAction(0);                                        /* initialize the environment for a new window in front */    SetMyCursor(0);    SwitchChecks(0);    SetWMenus(true);    if (showIt) {        /* add it's name to our window menu */        AddToWindowMenu(tempWP, nil);        ChangePlane(tempWP);    }    return(tempWP);}/* end AddNewWindow *//* CloseMyWindow closes the window and disposes of all the memory *   associated with it.  It also calls HandleSections (sic) to UnRegister* all the editions associated with this window */void CloseMyWindow(WindowPtr theClose){    windowCHandle theWind;    short alBack;    register qq;  OSErr myErr;    PicHandle *tempPicHandPtr;  NMRec myNotification;  Str255 nmWords;  myNotification.qType =nmType ;  myNotification.nmMark = nil;  myNotification.nmIcon = nil;  myNotification.nmSound = (Handle)-1;  myNotification.nmStr =&amp;nmWords ;  myNotification.nmResp =nil ;    theWind = (windowCHandle)GetWRefCon(theClose);  GetIndString(&amp;nmWords,kGeneralStrings,kBringForward);    HLock((Handle)theWind);    /* First see if we need to ask the user if they want to save this window or not */    if ((*theWind)-&gt;windowDirty) {     ModalFilterUPP upp;       Str255 windName;        GetWTitle(theClose, windName);        ParamText(windName, &quot;&quot;, &quot;&quot;, &quot;&quot;);    /* No before we can do this, we have to be the frontmost application.  It is */    /* not proper to put up a ModalDialog if you are not frontmost! */    /* But we cannot bully ourselves forward, we have got to  */    /* ask the AppleEvent Manager if we can come forward. */    /* **** YOU MUST ASK TO COME FORWARD!!!!! */    /*  NEVER force yourself forward.  Bad thing will happen if you do, you will */    /* be messing up scripting systems if you change layers  */    /* at will.  So, we do this.... */        myErr = AEInteractWithUser(kAEDefaultTimeout, &amp;myNotification, gCommonIdleFunctionUPP);    /* now we've got to check the error.  It is possible that there is NO way that */    /* we can come forward and bring up a dialog (imagine if this machine were running in another */    /* room, or late at night, and there was no-one to respond to the dialog) */    /* So we check like so.... */    if(myErr == errAENoUserInteraction){      return; /* we're blowing away the save because we can't talk about it */    }    InitCursor();    upp = NewModalFilterProc(standardAlertFilter);        alBack = Alert(kDirtyAlert, upp);                   /* Ask 'em */    DisposeRoutineDescriptor(upp);            if (alBack == ok)                                   /* they said yes, dispatch to the save handler */            (ProcPtr)(*(theWind))-&gt;saveMe(theWind, theClose);        if (alBack == cancel) {            /* if they said Cancel, this also tells us that the user does not want to */            /* quit the application if they were in the midst of shutdown ops.  So, */            /* reset the stopping flag.  Even if they weren't, this doesn't do any harm */            gStop = false;            return;        }    }    /* Save all our subscribers and publishers */    HandleSectionSave(theWind, false, true, nil);    /* get rid of all our memory associated with this window */    DisposeHandle((*theWind)-&gt;pubs);    DisposeHandle((*theWind)-&gt;pubRects);    DisposeHandle((*theWind)-&gt;subs);    DisposeHandle((*theWind)-&gt;subRects);    DisposeHandle((Handle)(*theWind)-&gt;fileAliasHandle);    /* Was there a TextEdit handle??? */    if ((*theWind)-&gt;boxHandle != nil)        TEDispose((*theWind)-&gt;boxHandle);    /* if there are any pictures, kill them too */    if ((*theWind)-&gt;numPicts) {        HLock((*theWind)-&gt;pictHandle);        tempPicHandPtr = (PicHandle *)*(*theWind)-&gt;pictHandle;        for (qq = 0; qq &lt; (*theWind)-&gt;numPicts; qq++) {     /* rectangles are handled in the HandleSectionSave */            KillPicture(*tempPicHandPtr);            tempPicHandPtr += 1;        }    }    DisposeHandle((*theWind)-&gt;pictHandle);    DisposeHandle((*theWind)-&gt;pictRects);    DisposeHandle((Handle)theWind);    DeleteFromWindowMenu(theClose);    /* and finally actually close the window */    CloseWindow(theClose);    if (FrontWindow()) {        gShowingSecHandle = nil;        gShowPub = false;        gShowSub = false;        if (((WindowPeek)FrontWindow())-&gt;windowKind == kDocumentWindow)            SetWMenus(true);    } else {        SetWMenus(false);        gShowingSecHandle = nil;        gShowPub = false;        gShowSub = false;    }    EnableItem(gFileMenuHandle, kOpenItem);    EnableItem(gFileMenuHandle, kNewItem);    } /* end CloseMyWindow *//* DrawFull draws the contents of our document windows */void DrawFull(windowCHandle theWind, WindowPtr theWindPtr){    register qq;    Rect scratchRect;    RgnHandle tempRgn;  RGBColor black = {0,0,0};    Rect grabRect;    ShapesHandle theShape;    /* Are there any shapes in this window? */    if ((*theWind)-&gt;numShapes) {        theShape = (*theWind)-&gt;theShapes;        /* walk through all the shapes */        do {            HLock((Handle)theShape);            switch ((*theShape)-&gt;type) {                /* Draw whatever type of shape this is */                case kLineShape:                 if(gHasColor)            RGBForeColor(&amp;(*theShape)-&gt;theColor);                          MoveTo((*theShape)-&gt;theRect.left, (*theShape)-&gt;theRect.top);                    LineTo((*theShape)-&gt;theRect.right, (*theShape)-&gt;theRect.bottom);                    break;                case kRectShape:                 if(gHasColor)            RGBForeColor(&amp;(*theShape)-&gt;theColor);                                FrameRect(&amp;(*theShape)-&gt;theRect);                    break;                case kOvalShape:          if(gHasColor)            RGBForeColor(&amp;(*theShape)-&gt;theColor);                                FrameOval(&amp;(*theShape)-&gt;theRect);                    break;            }            HUnlock((Handle)theShape);            theShape = (*theShape)-&gt;nextShape;        }while (theShape); /* end of shape list */    }if(gHasColor)  RGBForeColor(&amp;black);                    /* Is there a TextEdit field in this window? */    if ((*theWind)-&gt;boxHandle != nil) {        /* If there is a textedit field, there may also be bordered text sections, */        /* so check for them also */        Rect framer;        mySectionDataHandle tempTS = (*theWind)-&gt;textSections;        TEUpdate(&amp;(*theWind)-&gt;textBox, (*theWind)-&gt;boxHandle);        framer = (*theWind)-&gt;textBox;        InsetRect(&amp;framer, -3, -2);        FrameRect(&amp;framer);        /* step through any possible sections, and border them as needful */        while (tempTS) {            if ((*tempTS)-&gt;bordered)                BorderTextSection(tempTS);            tempTS = (*tempTS)-&gt;nextSection;        } /* end of text section list check */    }        if ((*theWind)-&gt;numSubs) {                              /* are we subscribed to anything? */        PicHandle *tempHand;        Handle *tempRHand;        Rect *tempRect;        HLock((*theWind)-&gt;subDataHandle);                   /* lock down and get the rectangles and */        HLock((*theWind)-&gt;subRects);                        /* current picture data for the subscribers this */        tempHand = (PicHandle *)*(*theWind)-&gt;subDataHandle;     /* window has */        tempRHand = (Handle *)*(*theWind)-&gt;subRects;        /* cast them into a handy form, and step through the list, drawing each */        for (qq = 0; qq &lt; (*theWind)-&gt;numSubs; qq++) {            PicHandle tempPic;            tempPic = *tempHand;            /* ****This following check is important!**** */            /* No matter what data type you are subscribing to, the data MAY NOT */            /* be in your application at the time you get an update.  */            /* Updates have a higher event priority than AppleEvents, and you usually */            /* will get an update event after you show the 'Subscribe' dialog box and the */            /* user has subscribed to something.  */            /* What that means is that you may not have yet gotten the first Section Read */            /* event for this subscription, you have no data to display. */            if (GetHandleSize((Handle)tempPic) != nil) {                HLock(*tempRHand);                tempRect = (Rect *)*(*tempRHand);                DrawPicture(tempPic, tempRect);                HUnlock(*tempRHand);            }            tempHand += 1;            tempRHand += 1;        }        HUnlock((*theWind)-&gt;subDataHandle);        HUnlock((*theWind)-&gt;subRects);    }    if ((*theWind)-&gt;numPicts) {        /* see if we have any pictures.  Pictures will be residual if the user */        /* used to have a subscriber, and canceled it.  We get rid of the subscription */        /* but keep the data */        Handle *tempPicPtr;        Handle *tempPicRect;        HLock((*theWind)-&gt;pictHandle);        HLock((*theWind)-&gt;pictRects);        tempPicPtr = (Handle *)*((*theWind)-&gt;pictHandle);        tempPicRect = (Handle *)*((*theWind)-&gt;pictRects);        for (qq = 0; qq &lt; (*theWind)-&gt;numPicts; qq++) {            HLock(*tempPicRect);            DrawPicture((PicHandle)*tempPicPtr, (Rect *)(*(*tempPicRect)));            tempPicPtr += 1;            tempPicRect += 1;        }    }    /* Show publisher in this window if it's been clicked on lately */    if (theWindPtr == FrontWindow()) {        if (gShowPub) {            PenPat(&amp;qd.gray);                                /* 50% gray for publishers */            PenSize(3, 3);            FrameRect(&amp;gShowPubRect);            PenPat(&amp;qd.black);            PenSize(1, 1);            grabRect = gShowPubRect;            grabRect.top = grabRect.bottom - 7;            grabRect.left = grabRect.right - 7;            PaintRect(&amp;grabRect);            /* **** NOTE:  I've taken the invert out of these areas because it got confusing for what */            /* I was publishing and subscribing.  Since we're dealing basically with bitmaps NOT */            /* with object-style graphiocs, the invert can be confusing.  */            /*   InsetRect(&amp;gShowPubRect, 4, 4); */            /* invert the selection */            /*InvertRect(&amp;gShowPubRect);*/            /*InsetRect(&amp;gShowPubRect, -4, -4); */        }        if (gShowSub) {            PenPat(&amp;qd.dkGray);                              /* 75% gray for subscriptions */            PenSize(3, 3);            InsetRect(&amp;gShowSubRect, -4, -4);            FrameRect(&amp;gShowSubRect);                        PenPat(&amp;qd.black);            PenSize(1, 1);            /* same as NOTE above */            /*InsetRect(&amp;gShowSubRect, 4, 4); */            /*InvertRect(&amp;gShowSubRect); */            /*InsetRect(&amp;gShowSubRect, -4, -4); */            /* add a resizing grabber */            if (gResizeSub) {                /* If they can resize subscriptions, draw the grab box. */                /* see the extra check box I added to the Subscriber Options dialog */                grabRect = gShowSubRect;                grabRect.top = grabRect.bottom - 7;                grabRect.left = grabRect.right - 7;                                PenPat(&amp;qd.black);                /* if this is not the front window, just outline the grabber */                /* if it is frontmost, draw it in solid black */                if (theWindPtr != FrontWindow()) {                    EraseRect(&amp;grabRect);                    FrameRect(&amp;grabRect);                } else {                    EraseRect(&amp;grabRect);                    PaintRect(&amp;grabRect);                }            }            InsetRect(&amp;gShowSubRect, 4, 4);        }        /* see if border showing is happening */        /* They optionally may have the 'Show All Borders' menu item checked, if so show */        /* the location of all the sections in this window */        if (gShowingAll) {            Rect borderRect;            /* show all pubs */            if ((*theWind)-&gt;numPubs) {                Rect *tempRectPtr;                HLock((*theWind)-&gt;pubRects);                tempRectPtr = (Rect *)*(*theWind)-&gt;pubRects;                PenPat(&amp;qd.gray);                            /* 50% gray for publishers */                PenSize(3, 3);                for (qq = 0; qq &lt; (*theWind)-&gt;numPubs; qq++) {                    borderRect = *tempRectPtr;                    FrameRect(&amp;borderRect);                    tempRectPtr += 1;                }                HUnlock((*theWind)-&gt;pubRects);            }                        /* show all subs */            if ((*theWind)-&gt;numSubs) {                                Handle *theRectsHandle;                                HLock((*theWind)-&gt;subRects);                /* lock down the rect handle */                /* cast it as a pointer to handles for reading ease */                theRectsHandle = (Handle *)*(*theWind)-&gt;subRects;                                PenPat(&amp;qd.dkGray);                          /* 75% gray for subscriptions */                PenSize(3, 3);                for (qq = 0; qq &lt; (*theWind)-&gt;numSubs; qq++) {                                        HLock(*theRectsHandle);                                        borderRect = *((Rect *)*(*theRectsHandle));                    InsetRect(&amp;borderRect, -4, -4);                    FrameRect(&amp;borderRect);                    HUnlock(*theRectsHandle);                    theRectsHandle += 1;                                    }                HUnlock((*theWind)-&gt;subRects);                            }            /* and show all text sections */            if ((*theWind)-&gt;textSections) {                mySectionDataHandle tempTS = (*theWind)-&gt;textSections;                do {                    BorderTextSection(tempTS);                    tempTS = (*tempTS)-&gt;nextSection;                }while (tempTS);                            }            PenSize(1, 1);            PenPat(&amp;qd.black);        }    }    /* and the grow box */    scratchRect = theWindPtr-&gt;portRect;    scratchRect.top = scratchRect.bottom - 15;    scratchRect.left = scratchRect.right - 15;    tempRgn = NewRgn();    GetClip(tempRgn);    ClipRect(&amp;scratchRect);    DrawGrowIcon(theWindPtr);    SetClip(tempRgn);    DisposeRgn(tempRgn);    }/* end DrawFull *//* DoDocumentClick handles clicking in the content region of our *//* document windows. */void DoDocumentClick(WindowPtr twindow){        /* if the window already was frontmost, take the right */    /* action for this window */    /* *** NOTE: Normally, this is also the place where you would */    /* update the modification date (mdDate)  of publishers */    /* If the user takes an action across a published area, you */    /* should update the modification time to flag yourself that this */    /* edition needs to be sent.  This date/time will also show up in the */    /* Options dialog for that publisher. But for the sake of clarity in this */    /* sample, I am only changing the mod date on edition write (in files.c) */    Point endPoint;    Point oldendPoint;    Rect startRect;    Boolean wasInTB;    windowCHandle shortname;    short tempAct;    Rect testRect;    shortname = (windowCHandle)GetWRefCon(twindow);    /* This handle is already locked on entry, from the dispatcher that got us here */        tempAct = (*shortname)-&gt;currentAction;                  /* what are they doing? */    SetPort(twindow);                                       /* make sure the port is good, I'm paranoid */    GlobalToLocal(&amp;gERecord.where);                         /* everything will be in local coordinate to this window */    /* I don't want users to draw objects across my text box, so see if this click is in that thang */    testRect.left = testRect.right = gERecord.where.h;    testRect.right++;    testRect.top = testRect.bottom = gERecord.where.v;    testRect.bottom++;    wasInTB = InTextBox(shortname, &amp;testRect);    if (!wasInTB || tempAct == kTextBox || tempAct == kNoAction) {        switch (tempAct) {                                  /* switch off the action code */            myLine tempLine;            case kNoAction:                /* no menu items checked.  See if they clicked in a */                /* publisher or subcriber */                /* border a publisher or subscriber if they clicked in one */                if (!SearchPubs(gERecord.where) &amp;&amp; !SearchSubs(gERecord.where)) {                    /* if they didn't click in one, then erase the current selection */                    /* Check to see if they're clicking in the TERecord.  This takes precidence over */                    /* any other click */                    /* You'll want to change this depending on your app */                    if (wasInTB) {                        /* treat this like a random click to de-border any PICT subscriptions that */                        /* may be selected */                        KillSelection(shortname);                        DeBorderSelection();                        /* check publisher stuff here */                                                TEClick(gERecord.where, gERecord.modifiers &amp; shiftKey, (*shortname)-&gt;boxHandle);                        if (!gShowingAll) {                            mySectionDataHandle tempTS = (*shortname)-&gt;textSections;                            Boolean anyOn = false;          /* for our invalidate check */                            /* step through text sections and turn off flags */                            //while (tempTS) {                            ///* also check here to see if anything was bordered.  If it was, invalidate */                            ///* the TE rectangle so the old borders will be erased.  If there */                            ///* were NOT any, don't invalidate, so we don't strobe the user to */                            ///* blindness */                            //anyOn = anyOn | (*tempTS)-&gt;bordered;                            //(*tempTS)-&gt;bordered = false;                            //tempTS = (*tempTS)-&gt;nextSection;                            //}                            //if (anyOn)                            //InvalRect(&amp;(*(*shortname)-&gt;boxHandle)-&gt;viewRect);                        }                                   /* see if the click was inside a subscriber */                        CheckSectionHit();                                            } else {                        /* if it was a random click, dehilite the text selection if there is one */                        if ((*shortname)-&gt;boxHandle != nil) {                            TESetSelect((*(*shortname)-&gt;boxHandle)-&gt;selStart, (*(*shortname)-&gt;boxHandle)-&gt;selStart,                                        (*shortname)-&gt;boxHandle);                            /* Also, check to see if any borders are on in the TE box.  If so, turn them off.  */                            /* That is, unless gSHowingAll is on.... */                            /* and it's easiest just to invlaidate the terect */                            InvalRect(&amp;(*(*shortname)-&gt;boxHandle)-&gt;viewRect);                            if (!gShowingAll) {                                mySectionDataHandle tempTS = (*shortname)-&gt;textSections;                                /* step through text sections and turn off flags */                                while (tempTS) {                                    (*tempTS)-&gt;bordered = false;                                    tempTS = (*tempTS)-&gt;nextSection;                                } /* tempTS while end */                            }                        }                        KillSelection(shortname);                        DeBorderSelection();                        /* and drag around a picture or an object if they want */                        DragPictOrObject(&amp;gERecord.where, shortname);                    }                    break;                    case kDrawLine:                        /* they want to draw a line in this window */                        /* start and end points of the line set to the same val */                        oldendPoint = endPoint = gERecord.where;                        PenMode(srcXor);                    /* Xor so we can rubberband the line */                        while (StillDown()) {               /* Keep doing this as long as the */                            /* user keeps the mouse down */                            GetMouse(&amp;endPoint);            /* Current mouse position in local */                            MakeRect(&amp;gERecord.where, &amp;endPoint, &amp;testRect);                            if (!InTextBox(shortname, &amp;testRect)) {                                /* coordinates */                                if (endPoint != oldendPoint) {      /* only do this if the mouse moved so the line doesn't flicker */                                    /* erase the old line (redraw in Xor mode ) */                                    MoveTo(gERecord.where.h, gERecord.where.v);                                    LineTo(oldendPoint.h, oldendPoint.v);                                    /* draw the new line */                                    MoveTo(gERecord.where.h, gERecord.where.v);                                    LineTo(endPoint.h, endPoint.v);                                    oldendPoint = endPoint;                                }                            } else {              endPoint = oldendPoint;              }                        }  /* StillDown while end */                        PenMode(srcCopy);                        /* They released the mouse.  Add the line they drew */                        /* to our record */                        tempLine.start = gERecord.where;                        tempLine.end = endPoint;                        /* see this function later in this file */                        AddLine((windowCHandle)((WindowPeek)twindow)-&gt;refCon, &amp;tempLine);                        /* changes the Undo menu item text */                        SetUndo(kDrawLine, false);                        break;                              /* end line case */                                                /* they want to draw a rectangle in this window */                    case kDrawRect:                        /* start and end of rectangle set to the same val */                        PullRect(shortname, &amp;startRect, false, false, true);                        /* Add it to our window */                        AddRect((windowCHandle)((WindowPeek)twindow)-&gt;refCon, &amp;startRect);                        SetUndo(kDrawRect, false);          /* Set undo menu item text to */                        /* Undo Rectangle */                        break;                              /* end rectangle case */                                            case kDrawOval:                        /* start and end of oval set to the same val */                        PullRect(shortname, &amp;startRect, true, false, true);                        /* Add the oval to our window struct */                        AddOval((windowCHandle)((WindowPeek)twindow)-&gt;refCon, &amp;startRect);                        /* Set undo menu item text to Undo Oval */                        SetUndo(kDrawOval, false);                        break;                    case kTextBox:                        /* start and end of rectangle set to the same val */                        PullRect(shortname, &amp;startRect, false, false, true);                        /* Add it to our window */                        AddTextBox((windowCHandle)((WindowPeek)twindow)-&gt;refCon, &amp;startRect);                        SetUndo(kCantUndo, false);          /* can't undo a text box */                        SwitchChecks(kTextBox);                        InitCursor();                        /* Undo Rectangle */                        break;                    case kSelectStuff:                        /* pretty much like drawrect, but */                        /* the resulting rect can be published */                        /* get rid of the old one */                        if ((*shortname)-&gt;hasSelection)                                KillSelection((windowCHandle)GetWRefCon(twindow));                        PullRect(shortname, &amp;startRect, false, false, true);                        PenPat(&amp;qd.gray);                        FrameRect(&amp;startRect);                        PenPat(&amp;qd.black);                        PenSize(1, 1);                        AddSelection((windowCHandle)((WindowPeek)twindow)-&gt;refCon, &amp;startRect);                        /* they can only select one rectangle, so clear the check */                        /* and change the cursor back to an arrow */                        SwitchChecks(kSelectStuff);                        InitCursor();                        (*shortname)-&gt;hasSelection = true;            SetUndo(kSelectItem - 1, false);        /* since the item on the menu is one more than our use, because of the divider */                        /* before the MenuSelect call above to see how it's used */                        break;                        break;                } else {                    unsigned long timeNow;                    /* they did click in one, see if it is/was a double click please */                    /* A double-click in a section should be treated the same */                    /* as if the user had selected Pub/Sub options for that section */                    KillSelection(shortname);                    if ((gShowingSecHandle == gLastSection) &amp;&amp; (gShowingSecHandle != nil)) {                        timeNow = TickCount();                        if ((timeNow - gLastSecClickTick) &lt; GetDblTime()) {                            /* it is a double click.  treat the same way as the menu selection for */                            /* Options UNLESS they had the option key down, then do a gotopublisher*/                            if (gERecord.modifiers &amp; optionKey)                                MyGoToPublisher(gLastSection);                            else                                DoOptions(gShowingSecHandle);       /* in Subscribe.c. */                                                    } else {                            /* not a double click.  Set up for the next pass */                            /* de-border the old one please */                            gLastSecClickTick = timeNow;                            gLastSection = gShowingSecHandle;                        }                    } else {                        gLastSecClickTick = timeNow;                        gLastSection = gShowingSecHandle;                    }                }        }    } else {  /* no matter which tool is selected, you can select in the TB */  TEClick(gERecord.where, gERecord.modifiers &amp; shiftKey, (*shortname)-&gt;boxHandle);  }}/* end DoDocumentClick *//* DragPictOrObject drags a shape or picture.  Stores last position in *//* window structure for Undo */void DragPictOrObject(Point *where, windowCHandle tempWC){    Handle *tempPicRect;    ShapesHandle theShapes;    register qq;    Rect origRect;    Boolean hadIt = false;    Point thePoint;    /* See if the hit was in a Pict, search all picts  */        if ((*tempWC)-&gt;numPicts) {        HLock((*tempWC)-&gt;pictRects);            tempPicRect = (Handle *)*((*tempWC)-&gt;pictRects);        /* run through all of them */    for (qq = 0; qq &lt; (*tempWC)-&gt;numPicts; qq++) {      /* Did we hit this one? */            if (PtInRect(*where, (Rect *)(*(*tempPicRect)))) {      /* Yes, drag it around */                      Rect dragger = *((Rect *)(*(*tempPicRect)));                thePoint = *where;                origRect = dragger;        hadIt = true;                PullRect(tempWC, &amp;dragger, false, true, false);                if(!EqualRect(&amp;origRect,&amp;dragger)){          /* if it really moved, update the dirty flag  &lt;ckh 1.0.2&gt;*/                    (*tempWC)-&gt;windowDirty = kMyTrue;          }        *((Rect *)(*(*tempPicRect)))=dragger;                InvalRect(&amp;dragger);                InvalRect(&amp;origRect);                                if ((*tempWC)-&gt;hasSelection)                        InvalRect(&amp;(*tempWC)-&gt;selectionRect);                (*tempWC)-&gt;hasSelection = true;                (*tempWC)-&gt;selectionRect = dragger;                /* make this one pixel bigger, so if the user wants to publish a Pict */        /* they get the whole thing */        InsetRect(&amp;(*tempWC)-&gt;selectionRect,-1,-1);        break;                                            }            tempPicRect += 1;        }        HUnlock((*tempWC)-&gt;pictRects);            }    if (!hadIt) {        /* check all my shapes */        if ((*tempWC)-&gt;numShapes) {            Boolean offsetIt = false;            theShapes = (*tempWC)-&gt;theShapes;            do {                Rect dragger;                HLock((Handle)theShapes);                dragger = (*theShapes)-&gt;theRect;                if ((*theShapes)-&gt;type == kLineShape) {                    short temp;                                        if (dragger.top &gt; dragger.bottom) {                        offsetIt = true;                        temp = dragger.top;                        dragger.top = dragger.bottom;                        dragger.bottom = temp;                    }                    if (dragger.left &gt; dragger.right) {                        offsetIt = true;                        temp = dragger.left;                        dragger.left = dragger.right;                        dragger.right = temp;                                            }                }                if (PtInRect(*where, &amp;dragger)) {                                        thePoint = *where;                                        /* have to see if this was a line, since that rect may be reversed */                                        origRect = dragger;                    InsetRect(&amp;dragger, -1, -1);                    hadIt = true;          PullRect(tempWC, &amp;dragger, false, true, false);                    InsetRect(&amp;dragger, 1, 1);          if(!EqualRect(&amp;origRect,&amp;dragger))(*tempWC)-&gt;windowDirty = kMyTrue;                    if (offsetIt) {                        OffsetRect(&amp;(*theShapes)-&gt;theRect, dragger.left - origRect.left, dragger.top - origRect.top);                    } else {                        (*theShapes)-&gt;theRect = dragger;                    }                    InvalRect(&amp;dragger);                    InvalRect(&amp;origRect);                                        (*tempWC)-&gt;hasSelection = true;                    if ((*tempWC)-&gt;hasSelection)                        InvalRect(&amp;(*tempWC)-&gt;selectionRect);          (*tempWC)-&gt;hasSelection = true;                    (*tempWC)-&gt;selectionRect = dragger;                              /* make this one pixel bigger, so if the user wants to publish an object */          /* they get the whole thing */          InsetRect(&amp;(*tempWC)-&gt;selectionRect,-1,-1);                    break;                                                                            }                        HUnlock((Handle)theShapes);                theShapes = (*theShapes)-&gt;nextShape;            }while (theShapes); /* end of shapes */                    }    }} /* end DragPictOrObject *//* KillSelection removes any selection from the current window */void KillSelection(windowCHandle tempWC){    Rect nulRect =  {        0, 0, 0, 0    };        InvalRect(&amp;(*tempWC)-&gt;selectionRect);    (*tempWC)-&gt;selectionRect = nulRect;    (*tempWC)-&gt;hasSelection = false;    } /* end KillSelection *//* UndoLast undoes the last drawing action that happened in the current * window.  Each window has it's own record of the last action, so * Undo is always valid for the current window, and will not act on a * window the user doesn't expect. */void UndoLast(void){    windowCHandle temp;    WindowPtr tempPort;    ShapesHandle tempSH, beforeLast;    GetPort(&amp;tempPort);                                     /* not really necessary, but I'm paranoid */    SetPort(FrontWindow());    temp = (windowCHandle)GetWRefCon(FrontWindow());    HLock((Handle)temp);                                    /* memory may move when handles are resized */    switch ((*temp)-&gt;undoAction) {                          /* last action that happened in this window */        /* For the graphic objects, we need to erase the last thing draw and update        * the window record's handles and counts */        case kDrawLine:        case kDrawRect:        case kDrawOval:            /* unlink and dispose of the last shape handle please */            /* find the last shape */            beforeLast = (*temp)-&gt;theShapes;            tempSH = (*temp)-&gt;theShapes;            if ((*temp)-&gt;numShapes == 1) {                (*temp)-&gt;numShapes = 0;                DisposeHandle((Handle)(*temp)-&gt;theShapes);                (*temp)-&gt;theShapes = nil;            } else {                register qq;                for (qq = 0; qq &lt; (*temp)-&gt;numShapes - 2; qq++) {                    tempSH = (*tempSH)-&gt;nextShape;                }                DisposeHandle((Handle)(*tempSH)-&gt;nextShape);                (*tempSH)-&gt;nextShape = nil;                (*temp)-&gt;numShapes--;                            }            break;        case kTextBox:            TEDispose((*temp)-&gt;boxHandle);            (*temp)-&gt;boxHandle = nil;            InsetRect(&amp;(*temp)-&gt;textBox, -3, -2);           /* just don't ask */            InvalRect(&amp;(*temp)-&gt;textBox);            break;        case kSelectStuff:            KillSelection(temp);            break;    case kMoveObject:            break;    }    HUnlock((Handle)temp);    /* now make sure things get refreshed */    InvalRect(&amp;(FrontWindow()-&gt;portRect));    EraseRect(&amp;(FrontWindow()-&gt;portRect));    SetUndo(0, false);    SetPort(tempPort);} /* end UndoLast *//* AddLine adds a line to our window data structure *//* nowHandle is the window data structure handle *//* inLine is the line to add */void AddLine(windowCHandle nowHandle, myLine *inline){Rect tempRect;  short temp;ShapesHandle newShape = NewShape(nowHandle);(*newShape)-&gt;type=kLineShape;(*newShape)-&gt;aeType = cGraphicLine;(*newShape)-&gt;theRect.top =  inline-&gt;start.v;(*newShape)-&gt;theRect.left = inline-&gt;start.h;(*newShape)-&gt;theRect.bottom = inline-&gt;end.v;(*newShape)-&gt;theRect.right = inline-&gt;end.h;tempRect = (*newShape)-&gt;theRect;if (tempRect.top &gt; tempRect.bottom) {temp = tempRect.top;tempRect.top = tempRect.bottom;tempRect.bottom = temp;}if (tempRect.left &gt; tempRect.right) {temp = tempRect.left;tempRect.left = tempRect.right;tempRect.right = temp;}InvalRect(&amp;tempRect);}/* end AddLine *//* AddRect adds a rectangle  to our window data structure *//* nowHandle is the window data structure handle *//* inRect is the rect to add */void AddRect(windowCHandle nowHandle, Rect *inrect){ShapesHandle tempShape = NewShape(nowHandle);(*tempShape)-&gt;type=kRectShape;(*tempShape)-&gt;aeType = cRectangle;(*tempShape)-&gt;theRect=*inrect;InvalRect(inrect);}/* end AddRect *//* AddTextBox adds a text editing box to our window data structure *//* nowHandle is the window data structure handle *//* inRect is the position to put the box in to add */void AddTextBox(windowCHandle nowHandle, Rect *inrect){    Rect framer;    HLock((Handle)nowHandle);        (*nowHandle)-&gt;textBox = *inrect;    (*nowHandle)-&gt;windowDirty = kMyTrue;    /* Create a TERecord to go here */    InsetRect(&amp;(*nowHandle)-&gt;textBox, -3, -3);    (*nowHandle)-&gt;boxHandle = TENew(inrect, &amp;(*nowHandle)-&gt;textBox);    TEActivate((*nowHandle)-&gt;boxHandle);    framer = (*nowHandle)-&gt;textBox;    InsetRect(&amp;framer, -3, -2);    InvalRect(&amp;framer);    HUnlock((Handle)nowHandle);}/* end AddTextBox *//* AddOval adds a oval  to our window data structure *//* nowHandle is the window data structure handle *//* inOval is the oval to add */void AddOval(windowCHandle nowHandle, Rect *inoval){ShapesHandle tempShape = NewShape(nowHandle);(*tempShape)-&gt;type=kOvalShape;(*tempShape)-&gt;aeType = cOval;(*tempShape)-&gt;theRect=*inoval;InvalRect(inoval);} /* end AddOval *//* AddSelection adds a selection rectangle  to our window data structure *//* nowHandle is the window data structure handle *//* inRect is the rect to add */void AddSelection(windowCHandle nowHandle, Rect *inrect){    HLock((Handle)nowHandle);    (*nowHandle)-&gt;selectionRect = *inrect;    (*nowHandle)-&gt;hasSelection = true;    HUnlock((Handle)nowHandle);} /* end AddSelection *//* NewShape adds a new shape to our window structure */ShapesHandle NewShape(windowCHandle theWindow){ShapesHandle newShape = (ShapesHandle)NewHandle(sizeof(Shapes));ShapesHandle tempShapes=(*theWindow)-&gt;theShapes;(*newShape)-&gt;theColor = gColorArray[gCurrentColor];if(tempShapes){ /* if there is already a shape defined *//* find the end and store this handle there */while((*tempShapes)-&gt;nextShape){tempShapes=(*tempShapes)-&gt;nextShape;}(*tempShapes)-&gt;nextShape=newShape;} else {/* first shape */(*theWindow)-&gt;theShapes=newShape;}/* increase our count of shapes */(*theWindow)-&gt;numShapes++;(*theWindow)-&gt;windowDirty = kMyTrue;(*newShape)-&gt;nextShape=nil;return(newShape);}/* end NewShape *//* ChangePlane does the housekeeping we need to do when a window comes to *//* the front, swapping menu checks, setting the cursor, and so on *//* And by the way, this routine has caused me more problems than any other, I will *//* be completely rewriting it in the next release, it is _not_ optimal. */void ChangePlane(WindowPtr twindow){    short temp;  Rect scratchRect;    WindowPtr oldWindow = FrontWindow();    windowCHandle shortname;    /* Before the swap kill any current borders */    DeBorderSelection();         /* deactivate the textedit record of the old window, if there is one */    if (oldWindow != nil &amp;&amp; oldWindow != twindow &amp;&amp; IsMyWindow(oldWindow)) {        windowCHandle tempCH = (windowCHandle)GetWRefCon(oldWindow);        if ((*tempCH)-&gt;boxHandle != nil)            TEDeactivate((*tempCH)-&gt;boxHandle);      SetPort(oldWindow);      scratchRect = twindow-&gt;portRect;    scratchRect.top = scratchRect.bottom - 15;    scratchRect.left = scratchRect.right - 15;  InvalRect(&amp;scratchRect);    }    /* if the window coming forward isn't a doc window, dim the tools menu */    if (((WindowPeek)twindow)-&gt;windowKind != kDocumentWindow) {        SetWMenus(false);    } else {        SetWMenus(true);    }    SetUndo(0, true);                                       /* tell SetUndo to pull the undo item value out of the current record */    shortname = (windowCHandle)GetWRefCon(twindow);         /* was oldwindow */    HLock((Handle)shortname);    temp = (*shortname)-&gt;currentAction;                     /* pull the last action the */    HUnlock((Handle)shortname);                             /* user was performing out of the */    SetCurAction(temp);                                     /* window record */    SetMyCursor(actsToIDs[temp]);                           /* set the right cursor */    SwitchChecks(actsToIDs[temp]);                          /* check the right menu item */    gShowPub = gShowSub = false;                            /* selections go away when windows */    gShowingSecHandle = nil;    if ((*shortname)-&gt;boxHandle != nil)        TEActivate((*shortname)-&gt;boxHandle);    SelectWindow(twindow);                                  /* select the window */  SetPort(twindow);  scratchRect = twindow-&gt;portRect;    scratchRect.top = scratchRect.bottom - 15;    scratchRect.left = scratchRect.right - 15;  InvalRect(&amp;scratchRect);    /* and re-do our window indexes */  /* **** NOTE:  I am not including the AEStatus window in this  */    /* window index or check!  The AEStatus window is a special diagnostic  /* only type window that is _not_ anything a 'real' application would have */  /*  It can change planes in  the middle of an AppleEvent if there is information */  /* to display, and if I included it in my real window list that */  /* would violate 'state freezing' for the space of an event, which  */  /* is A Bad Thing */  /* So I'm looking at everything but the AES window */  temp = 1;  oldWindow = FrontWindow();  while(oldWindow){  shortname = (windowCHandle)GetWRefCon(oldWindow);  if((((WindowPeek)oldWindow)-&gt;visible) &amp;&amp; (((WindowPeek)oldWindow)-&gt;windowKind != kAEStatusWindow &amp;&amp; IsMyWindow(oldWindow)))  {(*shortname)-&gt;windowIndex = temp;    temp++;}  oldWindow = (WindowPtr)((WindowPeek)oldWindow)-&gt;nextWindow;  }  /* now any invisible windows, since their index will be after the visible ones */  oldWindow = (WindowPtr)LMGetWindowList();  while(oldWindow){  shortname = (windowCHandle)GetWRefCon(oldWindow);  if((!((WindowPeek)oldWindow)-&gt;visible) &amp;&amp; (((WindowPeek)oldWindow)-&gt;windowKind != kAEStatusWindow) &amp;&amp; IsMyWindow(oldWindow))  {(*shortname)-&gt;windowIndex = temp;  temp++;}    oldWindow = (WindowPtr)((WindowPeek)oldWindow)-&gt;nextWindow;  }AdjustCursor(gERecord.where, mousergn);}/* end ChangePlane *//* may be a shape ,PICT, or a selection range *//* so if it's a shape, I cut the shape definition, pict, same thing.  *//* if it's  a selection range, I dunno what I'm gonna do. *//* no, actually I'll just cut all the components of the range */void CutGraphic(windowCHandle tempWC){Rect localSelection = (*tempWC)-&gt;selectionRect;}void CopyGraphic(windowCHandle tempWC){#pragma unused (tempWC)}void ClearGraphic(windowCHandle tempWC){#pragma unused (tempWC)}/* This sets window properties, it's passed one of our property tokens */OSErr SetWindowProperty(PropertyTHdl propertyBack, AEDesc *theData){    OSErr myErr = noErr;    AEDesc convertedDesc;    Size dataSize;    switch ((*propertyBack)-&gt;theProperty) {        case pName:            /* setting name.  Let's see if the data is typeChar */            if (theData-&gt;descriptorType != typeChar) {                /* problem.  See if it'll coerce */                myErr = AECoerceDesc(theData, typeChar, &amp;convertedDesc);                if (!myErr) {                    /* it converted.  swap descs (kinda) */                    myErr = AEDisposeDesc(theData);                    myErr = AEDuplicateDesc(&amp;convertedDesc, theData);                    myErr = AEDisposeDesc(&amp;convertedDesc);                }            }            if (!myErr) {                Str63 newName,oldName;                                /* the data in the handle is text.  Make it into a string for us */                dataSize = GetHandleSize(theData-&gt;dataHandle);                if (dataSize &gt; 63)                    dataSize = 63;                          /* Truncating the name because I want to */                HLock(theData-&gt;dataHandle);                BlockMove((Ptr)*(theData-&gt;dataHandle), (Ptr)&amp;newName[1], dataSize);                HUnlock(theData-&gt;dataHandle);                newName[0] = dataSize;                /* set the title.  We have the window pointer in the property token */        GetWTitle((*propertyBack)-&gt;token.window,&amp;oldName);                SetWTitle((*propertyBack)-&gt;token.window, &amp;newName);            /* v 1.0.1 revise old name in window menu please */        AddToWindowMenu((*propertyBack)-&gt;token.window,&amp;oldName);          /* all done! */            }            break;        case pBounds:            /* we have been passed a new rectangle, in global coords */            /* so pull the rectangle out */            /* again, make sure the data is in a rect type */            if (theData-&gt;descriptorType != typeQDRectangle) {                /* problem.  See if it'll coerce */                myErr = AECoerceDesc(theData, typeQDRectangle, &amp;convertedDesc);                if (!myErr) {                    /* it converted.  swap descs (kinda) */                    myErr = AEDisposeDesc(theData);                    myErr = AEDuplicateDesc(&amp;convertedDesc, theData);                    myErr = AEDisposeDesc(&amp;convertedDesc);                }            }            if (!myErr) {                Rect newRect;                /* OK, the data handle contains a rect.  I'll move it so it's easier to read */                newRect = *((Rect *)*(theData-&gt;dataHandle));                /* Move the window.  Pass a false as BringToFront since we don't want window shuffling */                /* check the rect for validity */        if( newRect.top &lt; newRect.bottom &amp;&amp; newRect.left &lt; newRect.right){        MoveWindow((*propertyBack)-&gt;token.window, newRect.left, newRect.top, false);                /* set the new dimensions.  And generate an update as needed */                SizeWindow((*propertyBack)-&gt;token.window, (newRect.right - newRect.left), (newRect.bottom - newRect.top), true);                /* Done! */        } else {        myErr = errAEEventNotHandled;        AddToReply(&quot;\pBad Window Size&quot;,kWeirdSizeErr);        }            }            break;        case pHasTitleBar:        case pIsModal:        case pIsModified:        case pIsResizable:        case pIsStationeryPad:        case pIsZoomed:    /* add new Winter '92 registry error code &lt;ckh 1.0.2&gt;*/            myErr = errAENotModifiable;                   /* I am not allowing these properties to be modified */      AddToReply(&quot;\p Attempted to modify a read-only parameter&quot;,errAENotModifiable);            break;        case pVisible:      /* value is true oder false */      if(**(theData-&gt;dataHandle)){        ShowWindow((*propertyBack)-&gt;token.window);        AddToWindowMenu((*propertyBack)-&gt;token.window,nil);        }      else {        DeleteFromWindowMenu((*propertyBack)-&gt;token.window);        HideWindow((*propertyBack)-&gt;token.window);        }      break;    }    return(myErr);} /* end SetWindowProperty */OSErr SetShapeProperty(PropertyTHdl propertyBack, AEDesc *theData){    OSErr myErr = noErr;    AEDesc convertedDesc;  WindowPtr tempWindow;  ShapesHandle theShape =(*propertyBack)-&gt;token.shapeHandle;    switch ((*propertyBack)-&gt;theProperty) {        case pBounds:        case pDefinitionRect:            /* we have been passed a new rectangle */            /* so pull the rectangle out */            /* again, make sure the data is in a rect type */            if (theData-&gt;descriptorType != typeQDRectangle) {                /* problem.  See if it'll coerce */                myErr = AECoerceDesc(theData, typeQDRectangle, &amp;convertedDesc);                if (!myErr) {                    /* it converted.  swap descs (kinda) */                    myErr = AEDisposeDesc(theData);                    myErr = AEDuplicateDesc(&amp;convertedDesc, theData);                    myErr = AEDisposeDesc(&amp;convertedDesc);                }            }            if (!myErr) {      /* we have a rect.  Set the shape to it */      HLock((Handle)theShape);      /* invalidate the old rect so the user sees the change */      /* * NOTE:  I'm getting current port and setting the one in the  */      /* token.  Remember, there is NO reason for an event to have to */      /* occur in the frontmost or current port */      GetPort(&amp;tempWindow);      SetPort((*propertyBack)-&gt;inWindow);      InvalRect(&amp;(*theShape)-&gt;theRect);      /* i dont want the rect set to zero, please */      if(!EmptyRect(((Rect *)*(theData-&gt;dataHandle)))){            (*theShape)-&gt;theRect = *((Rect *)*(theData-&gt;dataHandle));      InvalRect(&amp;(*theShape)-&gt;theRect);}      SetPort(tempWindow);      }            break;    case pPenColor:    /* pretty much the same for colors */       if (theData-&gt;descriptorType != typeRGBColor) {                /* problem.  See if it'll coerce */                myErr = AECoerceDesc(theData, typeRGBColor, &amp;convertedDesc);                if (!myErr) {                    /* it converted.  swap descs (kinda) */                    myErr = AEDisposeDesc(theData);                    myErr |= AEDuplicateDesc(&amp;convertedDesc, theData);                    myErr |= AEDisposeDesc(&amp;convertedDesc);                }            }            if (!myErr) {      /* we have a rect.  Set the shape to it */      HLock((Handle)theShape);      /* invalidate the old rect so the user sees the change */      /* * NOTE:  I'm getting current port and setting the one in the  */      /* token.  Remember, there is NO reason for an event to have to */      /* occur in the frontmost or current port */      GetPort(&amp;tempWindow);      SetPort((*propertyBack)-&gt;inWindow);      InvalRect(&amp;(*theShape)-&gt;theRect);      (*theShape)-&gt;theColor = *((RGBColor *)*(theData-&gt;dataHandle));      SetPort(tempWindow);      }            break;    /* I'm not handling any other properties right now, check again later */    default:    /* add new Winter '92 registry error code &lt;ckh 1.0.2&gt;*/            myErr = errAENotModifiable;                   /* I am not allowing these properties to be modified */      AddToReply(&quot;\p Attempted to modify a read-only parameter&quot;,errAENotModifiable);    break;    }    return(myErr);}/* Check to see if a window belongs to a desk accessory. *//* This is _almost_ unnecessary in System 7.  Since DAs have their own layer now, and *//* it's _almost_ impossible to force a DA into an applications space, this should *//* rarely be true *//* HOWEVER, there are INITs out there that will stick windows in your window list. *//* BallooonWriter does, for example */Boolean IsDAWindow(WindowPtr window){    if (window == nil)        return false;    else                                                    /* DA windows have negative windowKinds */        return((WindowPeek)window)-&gt;windowKind &lt; 0;}/* end IsDAWindow*//* DrawClip draws the current contents of the clipboard */void DrawClip(windowCHandle theWind, WindowPtr windowIn){#pragma unused(theWind)    RgnHandle tempRgn;    Rect theRect;    Str63 clipString;    UpdateScrap(false);                                     /* no neverending updateas */    MoveTo(10, 10);    /* Get the basic clipboard text */    GetIndString(clipString, kClipBoardStrings, 1);    DrawString(clipString);    /* get the string that says what type of thing is on the clipboard */    GetIndString(clipString, kClipBoardStrings, gClipHasContents);    DrawString(clipString);    MoveTo(0, 13);    /* underline those words */    LineTo(FindClipWindow()-&gt;portRect.right, 13);    HLock(gScrapData);    /* I make all my clipboard data into a picture, so we can use DrawPicture to display it */    if ((GetHandleSize(gScrapData) != 0) &amp;&amp; gScrapData) {        Rect picRect;        picRect = ((*(PicHandle)gScrapData))-&gt;picFrame;        OffsetRect(&amp;picRect, 0, 15);        DrawPicture((PicHandle)gScrapData, &amp;picRect);    }    HUnlock(gScrapData);    /* Add our grow box, clip out the rect so we don't get the */    /* spurious scroll area lines */    theRect = windowIn-&gt;portRect;    theRect.top = theRect.bottom - 15;    theRect.left = theRect.right - 15;    tempRgn = NewRgn();    GetClip(tempRgn);    ClipRect(&amp;theRect);    DrawGrowIcon(windowIn);    SetClip(tempRgn);    DisposeRgn(tempRgn);    } /* end DrawClip */void ClipClick(WindowPtr twindow){                                                           /* nothing happens on a clipboard click, it's in here for whenever I put scroll bars in */#pragma unused (twindow)} /* end ClipClick *//* Closes the clipboard window and takes it off the window menu *//* Remember, however, it isn't dead.  If there is a section on the  *//* clipboard it can still get updated */void CloseClip(WindowPtr inWind){#pragma unused (inWind)  WindowPtr clipWind = FindClipWindow();    Str63 menuText;    if (((WindowPeek)clipWind)-&gt;visible) {          HideWindow(clipWind);                DeleteFromWindowMenu(clipWind);        if (FrontWindow() != nil)            ChangePlane(FrontWindow());        /* change the menu string to read 'Show Clipboard' */        GetIndString(menuText, kGeneralStrings, kShowClipString);        SetMenuItemText(gEditMenuHandle, kClapNum, menuText);    }} /* end CloseClip */void SizeClip(WindowPtr windowIn){#pragma unused (windowIn)} /* end SizeClip *//* UpdateScrap reads in the current scrap, and makes a picture from it *//* It will also cause the clipboard window to redraw if it's visible */void UpdateScrap(Boolean refreshIt){    /* The 'refreshIt' variable is there to indicate if the window should be */    /* invalidated or not.  I added this so this routine can safely */    /* be called from the drawing procedure without fear of nverending updates */    Handle textData;    long myOffset;    long length;    textData = NewHandle(0);    if (gClipHasContents == kClipHasSub) {    } else {        /* show standard scrap types, prefering pictures */        length = GetScrap(gScrapData, 'PICT', &amp;myOffset);        if (length &lt; 0) {            if (length == noTypeErr) {                length = GetScrap(textData, kGenericTEXTWord, &amp;myOffset);                /* if it's text, I'm going to make it into a picture for my clipboard display, makes things */                /* easier in my draw proc */                if (length &gt; 0) {                    DisposeHandle(gScrapData);               /* kill the old one */                    gScrapData = (Handle)OpenPicture(&amp;FindClipWindow()-&gt;portRect);                    HLock(textData);                    TETextBox(*textData, length, &amp;(FindClipWindow())-&gt;portRect, teJustLeft);                    HUnlock(textData);                    ClosePicture();                    gClipHasContents = kClipHasText;                }            } else {                                        /* another type of error, like nothing available at all */                MySetHandleSize(gScrapData, 0);                gClipHasContents = kClipEmpty;            }        } else {            /* set the pict rect so it's in the upper left of our clipboard */            gClipHasContents = kClipHasPict;            OffsetRect(&amp;((*(PicHandle)gScrapData))-&gt;picFrame, (((*(PicHandle)gScrapData))-&gt;picFrame.left * -1),                       (((*(PicHandle)gScrapData))-&gt;picFrame.top * -1) + 11);        }    }    DisposeHandle(textData);    if (refreshIt &amp;&amp; ((WindowPeek)FindClipWindow())-&gt;visible) {        /* if we want it refreshed, force an update */        WindowPtr temp;        GetPort(&amp;temp);        SetPort(FindClipWindow());        InvalRect(&amp;(FindClipWindow())-&gt;portRect);        SetPort(temp);    }}/* end updatescrap *//* SpitClip spits our private subscription out to the general clipboard as a PICT type scrap *//* when we go in the background.  Does nothing if it's not a subscription, since it'll already *//* be right. */void SpitClip(void){    if (gClipHasContents == kClipHasSub) {        ZeroScrap();        HLock(gScrapData);        PutScrap(GetHandleSize(gScrapData), 'PICT', *gScrapData);            }} /* end spitclip *//* Handy little routine to find and return a pointer to the clipboard, visible or not */WindowPtr FindClipWindow(void){    WindowPtr twindow = (WindowPtr)LMGetWindowList();    while (twindow) {        if (((WindowPeek)twindow)-&gt;windowKind == kClipboardWindow)            return(twindow);        twindow = (WindowPtr)((WindowPeek)twindow)-&gt;nextWindow;    } /* end of windows while */    return(nil);                                            /* should never reach here */} /* end FindClipWindow *//* AppleEvent Status Window routines *//* Changes the visiblility state of the AEStatus window */void ToggleAEWindow(void){  WindowPtr oldFront = FrontWindow();    Str63 menuText;    short tempShort;  if(!IsModalFront()){    WindowPtr AEWind = FindAEWindow();                      /* find it */    if (((WindowPeek)AEWind)-&gt;visible) {                    /* if it's visiblem hide it */        HideWindow(AEWind);        DeleteFromWindowMenu(AEWind);                       /* and remive it from the menu */        tempShort = kShowAEString;    } else {        ShowWindow(AEWind);                                 /* show the thing */        AddToWindowMenu(AEWind, nil);                       /* add it's name to the window menu */        if(oldFront)ChangePlane(AEWind);                                /* bring it forward */        tempShort = kHideAEString;            }    /* get the correct text for the 'Show/Hide AEWindow' menu item */    GetIndString(menuText, kGeneralStrings, tempShort);    SetMenuItemText(gAppleEventMenuHandle, kShowAEWind, menuText);}} /* end ToggleAEWindow *//* Handy little routine for finding the AEStatus window, visible or not */WindowPtr FindAEWindow(void){    WindowPtr twindow = (WindowPtr)LMGetWindowList();    while (twindow) {        if (((WindowPeek)twindow)-&gt;windowKind == kAEStatusWindow)            return(twindow);        twindow = (WindowPtr)((WindowPeek)twindow)-&gt;nextWindow;    }    return(nil);                                            /* should never reach here */    } /* end FindAEWindow *//* Draws the AEStatus window */void DrawAES(windowCHandle theWind, WindowPtr windowIn){    Rect theRect;    RgnHandle tempRgn;    theRect = windowIn-&gt;portRect;    TEUpdate(&amp;theRect, (*theWind)-&gt;boxHandle);    theRect.top = theRect.bottom - 15;    theRect.left = theRect.right - 15;    tempRgn = NewRgn();    GetClip(tempRgn);    ClipRect(&amp;theRect);    DrawGrowIcon(windowIn);    SetClip(tempRgn);    DisposeRgn(tempRgn);    } /* end DrawAES *//* Handles a click in the AEStatus window,  by  doing a TEClick */void ClickAES(WindowPtr twindow){    windowCHandle tempWCH = (windowCHandle)GetWRefCon(twindow);    Rect theRect = twindow-&gt;portRect;    SetPort(twindow);    GlobalToLocal(&amp;gERecord.where);        TEClick(gERecord.where, gERecord.modifiers &amp; shiftKey, (*tempWCH)-&gt;boxHandle);    } /* end ClickAES *//* CloseAES doesn't close the window, just makes it invisible */void CloseAES(WindowPtr inWind){#pragma unused (inWind)WindowPtr aeWind = FindAEWindow();    Str32 menuText;    if (((WindowPeek)aeWind)-&gt;visible) {               HideWindow(aeWind);        DeleteFromWindowMenu(aeWind);        if (FrontWindow() != nil)            ChangePlane(FrontWindow());        /* and change the menu text */        GetIndString(menuText, kGeneralStrings, kShowAEString);        SetMenuItemText(gAppleEventMenuHandle, kShowAEWind, menuText);    }} /* end CloseAES */void AESKey(char theKey, windowCHandle tempWC){    TEKey(theKey, (*tempWC)-&gt;boxHandle);} /* end AESKey *//* Resize the AES window *//* When resizing TextEdit records, I always destroy and recreate them in *//* their new size, instead of mucking around with the rects.  Simpler and safer */void SizeAES(WindowPtr windowIn){    Handle theText;    Rect newRect;        short selStart, selEnd;    windowCHandle tempWCH = (windowCHandle)GetWRefCon(windowIn);    /* recalculate the TE rectangle */    newRect = windowIn-&gt;portRect;    newRect.right -= 16;    /* Get the old text */    theText = (Handle)TEGetText((*tempWCH)-&gt;boxHandle);    /* get the old selection range */    selStart = (*(*tempWCH)-&gt;boxHandle)-&gt;selStart;    selEnd = (*(*tempWCH)-&gt;boxHandle)-&gt;selEnd;    /* copy the old text */    HandToHand(&amp;theText);    /* kill the TERecord */    TEDeactivate((*tempWCH)-&gt;boxHandle);    TEDispose((*tempWCH)-&gt;boxHandle);    /* recreate it in it's new size */    (*tempWCH)-&gt;boxHandle = TENew(&amp;newRect, &amp;newRect);    /* and do all the housekeeping associated with a new TERecord */    TEAutoView(true, (*tempWCH)-&gt;boxHandle);    HLock((Handle)theText);    TESetText((Ptr)*theText, GetHandleSize((Handle)theText), (*tempWCH)-&gt;boxHandle);    TECalText((*tempWCH)-&gt;boxHandle);    DisposeHandle((Handle)theText);    TEActivate((*tempWCH)-&gt;boxHandle);    TESetSelect(selStart, selEnd, (*tempWCH)-&gt;boxHandle);    TEUpdate(&amp;newRect, (*tempWCH)-&gt;boxHandle);} /* end SizeAES *//* The next few routines add text to the AEStatus window, in various ways */void AddToAEWindow(Ptr text, long count){    WindowPtr tempW = FindAEWindow();    WindowPtr temp;    windowCHandle tempWCH = (windowCHandle)GetWRefCon(tempW);    GetPort(&amp;temp);    /* No matter what, if we're adding text we want the window to be visible, even if  */    /* it's not frontmost */    if (!((WindowPeek)tempW)-&gt;visible) {    ToggleAEWindow();      }    /* if it's your preference to see the window any time something happens, it comes forward here */    if (gPreferences.bringAEUp &amp;&amp; FrontWindow() != tempW &amp;&amp; !IsModalFront())        ChangePlane(tempW);                                 /* bring it forward if you want */    SetPort(tempW);    /* move to the end of the record */    TESetSelect(32000, 32000, (*tempWCH)-&gt;boxHandle);    /* add the text */    TEInsert(text, count, (*tempWCH)-&gt;boxHandle);    SetPort(temp);} /* end AddToAEWindow *//* routine to add a number easily */void AddAENum(long theNum){    Str31 theString;    NumToString(theNum, theString);    AddToAEWindow(&amp;theString[1], theString[0]);    } /* end AddAENum *//* routine to add a PString easily */void AddAEText(ConstStr255Param theText){    AddToAEWindow(&amp;theText[1], theText[0]);    } /* end AddAEText *//* This routine is called when the user selects a window from the Windows menu *//* it gets the item text, then finds the window that matches it and *//* makes it frontmost */void WindowToFront(short which,Str63 name){    Str63 tempTitle;  Str63 otherName;    WindowPtr frontW = FrontWindow();    if (!frontW)        return;    if(name == nil){name = &amp;otherName;    GetMenuItemText(gWindowMenuHandle, which, name);    }    do {        GetWTitle(frontW, tempTitle);        if (EqualString(name, tempTitle, false, false)) {            break;        } else {            frontW = (WindowPtr)((WindowPeek)frontW)-&gt;nextWindow;        }    }            while (frontW);    if (frontW)        ChangePlane(frontW);    } /* end WindowToFront *//* Adds the input window title to the window list.  If it was there  *//* in an old incarnation, it replaces the old text with the new name *//* (like when a user saves the file, or does a 'save as' */void AddToWindowMenu(WindowPtr theWindow, const Str255 oldName){        short count = CountMItems(gWindowMenuHandle);    Str255 wTitle;    Str255 theItem;    short iCount = 0;    GetWTitle(theWindow, wTitle);    /* if the window already existed, change an existing menu item */    if (oldName) {        do {            iCount++;            GetMenuItemText(gWindowMenuHandle, iCount, theItem);            if (EqualString(theItem, oldName, false, false))                break;                    }                while (true);        SetMenuItemText(gWindowMenuHandle, iCount, wTitle);    } else {        count++;        InsertMenuItem(gWindowMenuHandle, wTitle, count);    }} /* end AddToWindowMenu *//* take this window off the window menu, for whatever reason */void DeleteFromWindowMenu(WindowPtr theWindow){    register qq;    Str63 item, name;    short count = CountMItems(gWindowMenuHandle);    GetWTitle(theWindow, name);    for (qq = 1; qq &lt; count + 1; qq++) {        GetMenuItemText(gWindowMenuHandle, qq, &amp;item);        if (EqualString(item, name, false, false)) {            DeleteMenuItem(gWindowMenuHandle, qq);        }    }} /* end DeleteFromWindowMenu *//* CheckExisting is called from our file opener to see if this file *//* is already open */Boolean CheckExisting(FSSpecPtr newSpec){  Boolean openNow = false;  /* check against all the open windows */  WindowPtr tempWindow = FrontWindow();  FSSpec tempSpec;  Boolean wasCh;  windowCHandle tempWC;  while(tempWindow){    if(((WindowPeek)tempWindow)-&gt;windowKind == kDocumentWindow){      tempWC = (windowCHandle)GetWRefCon(tempWindow);      if(GetHandleSize((Handle)(*tempWC)-&gt;fileAliasHandle)){        ResolveAlias(nil,(*tempWC)-&gt;fileAliasHandle,&amp;tempSpec,&amp;wasCh);        openNow = CompareFSSpecs(&amp;tempSpec,newSpec);        if(openNow)break;      }        }    tempWindow = (WindowPtr)((WindowPeek)tempWindow)-&gt;nextWindow;  }    return(openNow);} /* end CheckExisting */#undef __MYWINDOWS__</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/AEObject-Edition_Sample/listing21.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/AEObject-Edition_Sample/listing21.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/AEObject-Edition_Sample/listing21.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>