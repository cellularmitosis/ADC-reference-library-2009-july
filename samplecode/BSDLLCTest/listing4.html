<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>BSDLLCTest - /EthernetSocketStuff.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Networking/index.html">Networking</a> &gt; <a href="../../samplecode/Networking/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">BSDLLCTest</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">BSDLLCTest</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/EthernetSocketStuff.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BSDLLCTest.c</option>
<option value="listing2.html">/BSDLLCTest.h</option>
<option value="listing3.html">/BSDLLCTestCommon.h</option>
<option value="listing4.html">/EthernetSocketStuff.c</option>
<option value="listing5.html">/EthernetSocketStuff.h</option>
<option value="listing6.html">/EthernetSocketTool.c</option>
<option value="listing7.html">/GetEthernetAddrSample.c</option>
<option value="listing8.html">/GetEthernetAddrSample.h</option>
<option value="listing9.html">/MoreAuthSample/MoreCFQ/MoreCFQ.c</option>
<option value="listing10.html">/MoreAuthSample/MoreCFQ/MoreCFQ.h</option>
<option value="listing11.html">/MoreAuthSample/MoreSecurity/MoreSecurity.c</option>
<option value="listing12.html">/MoreAuthSample/MoreSecurity/MoreSecurity.h</option>
<option value="listing13.html">/MoreAuthSample/MoreSecurity/MoreSecurityTest/MoreSecurityTest.c</option>
<option value="listing14.html">/MoreAuthSample/MoreSecurity/MoreSecurityTest/MoreSecurityTestCommon.h</option>
<option value="listing15.html">/MoreAuthSample/MoreSecurity/MoreSecurityTest/MoreSecurityTestTool.c</option>
<option value="listing16.html">/MoreAuthSample/MoreSecurity/ReadMeAboutMoreAuthSample.html</option>
<option value="listing17.html">/MoreAuthSample/MoreSetup.h</option>
<option value="listing18.html">/MoreAuthSample/MoreUNIX/MoreUNIX.c</option>
<option value="listing19.html">/MoreAuthSample/MoreUNIX/MoreUNIX.h</option>
<option value="listing20.html">/ReadMe-BSDLLCTest.html</option></select>
				</p>
				</form>
				<p><strong><a href="BSDLLCTest.zip">Download Sample</a></strong> (&#147;BSDLLCTest.zip&#148;, 442.6K)<BR>
<strong><a href="BSDLLCTest.dmg">Download Sample</a></strong> (&#147;BSDLLCTest.dmg&#148;, 760.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
 *  EthernetSocketStuff.c
 *  BSDLLCTest
 *

 Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
 (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
 use, installation, modification or redistribution of this Apple software
 constitutes acceptance of these terms.  If you do not agree with these terms,
 please do not use, install, modify or redistribute this Apple software.

 In consideration of your agreement to abide by the following terms, and subject
 to these terms, Apple grants you a personal, non-exclusive license, under Apple's
 copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
 reproduce, modify and redistribute the Apple Software, with or without
 modifications, in source and/or binary forms; provided that if you redistribute
 the Apple Software in its entirety and without modifications, you must retain
 this notice and the following text and disclaimers in all such redistributions of
 the Apple Software.  Neither the name, trademarks, service marks or logos of
 Apple Computer, Inc. may be used to endorse or promote products derived from the
 Apple Software without specific prior written permission from Apple.  Except as
 expressly stated in this notice, no other rights or licenses, express or implied,
 are granted by Apple herein, including but not limited to any patent rights that
 may be infringed by your derivative works or by other works in which the Apple
 Software may be incorporated.

 The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
 WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
 WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
 COMBINATION WITH YOUR PRODUCTS.

 IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
                        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
 OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
 (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
 ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include &quot;BSDLLCTestCommon.h&quot;
#include &quot;MoreUNIX.h&quot;
#include &quot;MoreSecurity.h&quot;
#include &quot;MoreCFQ.h&quot;
#include &quot;EthernetSocketStuff.h&quot;
#include &lt;sys/un.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;fcntl.h&gt;

static PacketBuffer    gPacket;
static Boolean      gDone;
static UInt32      gCounter;

int DoAddProtocolMatch(int fd, int ptype, u_int32_t prot_family, 
                        u_char ssap, u_char dsap, u_char cntrl_code, u_char *snapAddr);
int DoAddDelMulticast(int fd, unsigned char *mcAddr, Boolean addFlag);
OSStatus DoBSDLLCWriteTest(EnetTestData *enetdata);
OSStatus DoCancelBSDLLCReadTest(EnetTestData *enetdata);
OSStatus DoBSDLLCReadTest(EnetTestData *enetdata);
int  DoSendPacket(EnetTestData *enetdata, const void *vptr, size_t n);

/*******************************************************************************
** DoAddProtocolMatch - uses the setsocketopt call to specify the protocols
**  to be for the raw socket to watch for.  
    input parameters
    fd is the socket file descriptor
    ptype is the protocol type - NDRV_DEMUXTYPE_ETHERTYPE, NDRV_DEMUXTYPE_SAP or
                                NDRV_DEMUXTYPE_SNAP
    if ptype is NDRV_DEMUXTYPE_ETHERTYPE, then ntype is the native protocol type - e.g. 0x806
    if ptype is NDRV_DEMUXTYPE_SAP then 
    ssap and dsap are the source and destination SAP values to watch for
    and cntrl_code is the control code value - typically 3
    if ptype is NDRV_DEMUXTYPE_SNAP, then 
    *snapAddr is a 5 byte array with the SNAP addr info with the assumption that the 
    source and destination SAP are 0xAA and the control code is 0x03
********************************************************************************/

int DoAddProtocolMatch(int fd, int ptype, u_int32_t prot_family, 
                        u_char ssap, u_char dsap, u_char cntrl_code, u_char *snapAddr)
{
    struct ndrv_protocol_desc  desc;
    struct ndrv_demux_desc  demux_desc[1];
    int        result;
  int       i;
    
    bzero(&amp;desc, sizeof(desc));        // zero out the strucuture
    bzero(&amp;demux_desc, sizeof(demux_desc));    // zero out the strucuture

    desc.version = NDRV_PROTOCOL_DESC_VERS;
    desc.protocol_family = prot_family;
    desc.demux_count = (u_int32_t)1;
    desc.demux_list = (struct ndrv_demux_desc*)&amp;demux_desc;
    
    switch (demux_desc[0].type = ptype)
    {
        case NDRV_DEMUXTYPE_ETHERTYPE:
      fprintf(stderr, &quot;adding ethertype protocol 0x%X\n&quot;, demux_desc[0].data.ether_type);
            demux_desc[0].length = sizeof(demux_desc[0].data.ether_type);
            demux_desc[0].data.ether_type = sizeof(demux_desc[0].data.ether_type);
            break;
        
        case NDRV_DEMUXTYPE_SAP:
      fprintf(stderr, &quot;adding SAP protocol 0x%X\n&quot;, dsap);
            demux_desc[0].length = sizeof(demux_desc[0].data.sap);
            demux_desc[0].data.sap[0] = dsap;
            demux_desc[0].data.sap[1] = ssap;
            demux_desc[0].data.sap[2] = cntrl_code;
            break;
        
        case NDRV_DEMUXTYPE_SNAP:
      fprintf(stderr, &quot;adding SNAP protocol &quot;);
      for (i = 0; i &lt; 5; i++)
      {
        fprintf(stderr, &quot;%X &quot;, snapAddr[i]);
      }
      fprintf(stderr, &quot;\n&quot;);
            demux_desc[0].length = sizeof(demux_desc[0].data.snap);
            demux_desc[0].data.snap[0] = (u_int8_t)snapAddr[0];
            demux_desc[0].data.snap[1] = (u_int8_t)snapAddr[1];
            demux_desc[0].data.snap[2] = (u_int8_t)snapAddr[2];
            demux_desc[0].data.snap[3] = (u_int8_t)snapAddr[3];
            demux_desc[0].data.snap[4] = (u_int8_t)snapAddr[4];
            break;
        
        default:
            return -1;  // return -1 as an error if an unknown protocol type was passed in
            break;
    }
    
    result = setsockopt(fd, SOL_NDRVPROTO, NDRV_SETDMXSPEC, (caddr_t)&amp;desc, sizeof(desc));
  if (result)
  fprintf(stderr, &quot;error on setsockopt %d\n&quot;, result);
    return result;
}

/*******************************************************************************
** DoAddDelMulticast - used to add or delete a multicast address when receiving
** packets.
********************************************************************************/

int DoAddDelMulticast(int fd, unsigned char *mcAddr, Boolean addFlag)
{
    struct sockaddr_dl  dl;
    int      result;

    bzero(&amp;dl, sizeof(dl));
    dl.sdl_len = sizeof(dl);
    dl.sdl_family = AF_LINK;
    dl.sdl_type = IFT_ETHER;
    dl.sdl_nlen = 0;
    dl.sdl_alen = sizeof(struct ether_addr);
    bcopy(mcAddr, dl.sdl_data, sizeof(struct ether_addr));

    // enable multicast reception
    if (addFlag)
    {
        result = setsockopt(fd, SOL_NDRVPROTO, NDRV_ADDMULTICAST, &amp;dl, sizeof(dl));
        if (result &lt; 0) 
        {
            fprintf(stderr, &quot;setsockopt(NDRV_ADDMULTICAST) failed: %s\n&quot;, strerror(errno));
        }
    }
    else
    {
        result = setsockopt(fd, SOL_NDRVPROTO, NDRV_DELMULTICAST, &amp;dl, sizeof(dl));
        if (result &lt; 0) 
        {
            fprintf(stderr, &quot;setsockopt(NDRV_DELMULTICAST) failed: %s\n&quot;, strerror(errno));
        }
    }
    

    return result;
}

OSStatus DoBSDLLCWriteTest(EnetTestData *enetdata)
{
    OSStatus  err = noErr;
    int      result;
    UInt32    i, datasize;
    
  enetdata-&gt;numPacketsSent = 0;
    memset(&amp;gPacket, 0, sizeof(gPacket));    // zero out the global packet buffer structure
        // since we are writing, we don't have to add a protocol to listen for

  gPacket.rawModeOffset = 17;
    // check is we are doing SNAP
  if (enetdata-&gt;sap == 0xAA)
    gPacket.rawModeOffset += 5;


        // set up the first 18 bytes past the control byte for non SNAP LLC endpoint or
        // past the SNAP header for a SNAP endpoint, so that we can recognize it 
    strcpy((char*)&amp;gPacket.data[gPacket.rawModeOffset], &quot;begin data section\0&quot;);

        // set up some specific bytes in the data buffer that begins at the same point
        // relative to the LLC or SNAP header
    gPacket.data[DATAOFFSET     + gPacket.rawModeOffset] = 0;
    gPacket.data[DATAOFFSET + 1 + gPacket.rawModeOffset] = 0;
    strcpy((char*)&amp;gPacket.data[DATAOFFSET+2 + gPacket.rawModeOffset], &quot;end of data section\0&quot;);
    
  // set up for a rawmode send data call.  Fill in the enet header
  // set the destination address
  for (i = 0; i &lt; sizeof(MACAddress); i++)
    gPacket.data[i] = enetdata-&gt;destaddr[i];
    
  // set the source address
  for (i = 0; i &lt; sizeof(MACAddress); i++)
    gPacket.data[i+6] = enetdata-&gt;srcaddr[i];

  // set the packet len field
  // due to a bug in Mac OS X 10.1.x, if you set the data size field of the Ethernet header to 1500,
  // the packet will not be received. Detect if Mac OS 10.1.x is present and limit the data size to 1499
  datasize = DATASIZE;
  if (datasize &gt;= 1500)
   {
     if (enetdata-&gt;verMacOS &lt;= 0x1015)
     {
       datasize = 1499;
     }
     else
       datasize = 1500;
   }
    gPacket.data[12] = datasize &gt;&gt; 8;
    gPacket.data[13] = datasize &amp; 0xFF;

  // set the dsap, ssap, and control byte fields.
    gPacket.data[14] = enetdata-&gt;sap;  // set DSAP
    gPacket.data[15] = enetdata-&gt;sap;  // set SSAP
    gPacket.data[16] = 0x03;      // set control byte
    
    if (enetdata-&gt;sap == 0xAA)
    {
        // set up the SNAP Addr
        for (i = 0; i &lt; 5; i++)
            gPacket.data[i+17] = enetdata-&gt;snap[i];
    }

    enetdata-&gt;tbegin = clock ();
    
    gDone = false;
    gPacket.i = 0;
        
    while (!gDone)
    {
    // send the packet and make sure to include the length of the ethernet header
        if ((result = DoSendPacket(enetdata, &amp;gPacket.data, datasize + ETHER_HDR_LEN)) == (datasize + ETHER_HDR_LEN))
        {
            err = noErr;
      enetdata-&gt;numPacketsSent++;
        }
        else
        {
            fprintf(stderr, &quot;\n error occurred sending data, only %d bytes sent&quot;, result);
        }
                                
    }  // end while loop sending data

    enetdata-&gt;tend = clock();
  return err;
}

int DoSendPacket(EnetTestData *enetdata, const void *vptr, size_t n)
{
    int    nleft = 0;
    int    nwritten = 0;
    const char  *ptr;
            
    if (gDone == false)
    {
        ptr = vptr;
        nleft = n;
        while (nleft &gt; 0)
        {
 //           nwritten = write(fd, ptr, nleft);
            nwritten = sendto(enetdata-&gt;fd, ptr, nleft, 0, &amp;(enetdata-&gt;saddr), sizeof(enetdata-&gt;saddr));
            if (nwritten &lt;= 0)
            {
                if (errno == EINTR)
                    nwritten = 0;  // try calling write once more
                else
                {
                    fprintf (stderr, &quot;\n error writing data, errno - %d&quot;, errno);
                    enetdata-&gt;sendErrors++;
                    if (enetdata-&gt;sendErrors &gt; 10)
                        gDone = true;
                    return nwritten;
                }
            }
            nleft -= nwritten;
            ptr += nwritten;
            
        }
    }
    
    gPacket.i++;
                                    
    if (gPacket.i &gt;= enetdata-&gt;numPacketsToSend)
            gDone = true;
    else
    {
                    // increment the counter in the packet
            gPacket.data[DATAOFFSET+0+gPacket.rawModeOffset] = gPacket.i &gt;&gt; 8;
            gPacket.data[DATAOFFSET+1+gPacket.rawModeOffset] = gPacket.i;
                    
    }        
    return n;
}

static void* CallBSDRead (void *data)
{
    EnetTestData *enetdata = (EnetTestData*)data;
    int    offset, lcounter;
    int    addrlen;
    int    nread;
    char  buff[1530];
    OSStatus   err = noErr;
    
    while ((enetdata-&gt;flag &amp; kQuitThread) == 0)
    {
        addrlen = sizeof(enetdata-&gt;saddr);
    // issue a blocking read call
        nread = recvfrom(enetdata-&gt;fd, buff, sizeof(buff), 0, &amp;(enetdata-&gt;saddr), &amp;addrlen);
//        nread = recvfrom(enetdata-&gt;fd, buff, sizeof(buff), 0, NULL, NULL);
        if (nread &lt; 0)
        {
             fprintf (stderr, &quot;error on recvfrom - %d\n&quot;, nread);
             enetdata-&gt;readErrors++;
        }
        else
        {
            enetdata-&gt;packetsRead++;
                // if rawmode is on then we want to account for
                // the additional 17 bytes which will be at the
                // beginning of the packet.
            offset = 17;
            if (enetdata-&gt;sap == 0xAA)
            {
                offset += 5;    // account for the SNAP header
            }
                                    
            lcounter = buff[DATAOFFSET + offset + 0] &lt;&lt; 8;
            lcounter |= buff[DATAOFFSET + offset + 1];
        // the lastPacketNum value (zero based) is displayed in the statistics 
        // so add 1 to the value so
        // that it appears the same as the packetsRead value which is 1 based
      enetdata-&gt;lastPacketNum = lcounter + 1;
      
      if (lcounter == 0)  // check if we are receiving a new sequence of test packets
                // the following assumes that we always receive the first packet of a series
                // which is not necessarily the way things are going to be.
      {
        enetdata-&gt;packetsInOrder = 0;
        enetdata-&gt;packetsOutOfOrder = 0;
      }
      else if (lcounter == gCounter)
        enetdata-&gt;packetsInOrder++;
      else
        enetdata-&gt;packetsOutOfOrder++;
      
      gCounter = lcounter + 1;  // prepare gCounter for next incoming packet to compare
        }
    }
    
    return (void*)err;
}

OSStatus DoCancelBSDLLCReadTest(EnetTestData *enetdata)
{
  OSStatus  err = noErr;

  // set the flag so that the MPTask will quit
  if (enetdata-&gt;flag &amp; kThreadActive)
  {
    enetdata-&gt;flag |= kQuitThread;
    // if the task is still active then call terminateTask
    err = pthread_cancel(enetdata-&gt;pthread);
    if (err != noErr)
    {
      fprintf(stderr, &quot;pthread_cancel returned error %ld\n&quot;, err);
    }
    
    close(enetdata-&gt;fd);
    enetdata-&gt;fd = 0;

  }

  return err;
}
        
OSStatus DoBSDLLCReadTest(EnetTestData *enetdata)
{
    int    result = noErr;
    
    gCounter = 0;
    gDone = false;

    result = pthread_create(&amp;(enetdata-&gt;pthread), NULL, CallBSDRead, enetdata);

    if (result == kOTNoError)
    {
        fprintf (stderr, &quot;pthread_create worked\n&quot;);
        enetdata-&gt;flag |= kThreadActive;
    }
    else
    {
        fprintf (stderr, &quot;error on pthread_create - %d\n&quot;, result);
        enetdata-&gt;flag &amp;= (-1 ^ kThreadActive);
    }
    
  return result;
}

/*
  GetPFNDRVSocket: entry function for obtaining a PF_NDRV socket.
  Parameters:
    socket - pointer to an int where the PF_NDRV socket is to be returned. 
  Result: noErr if the socket was opened by the PFNDRVTool, otherwise an error
  is returned and socket is set to -1;
  
  Uses the MoreAuthSample code to call the tooll, which is included in this sample
  For the complete sample, go to
  &lt;http://developer.apple.com/samplecode/Sample_Code/Security/MoreAuthSample.htm&gt;
  
*/
OSStatus GetPFNDRVSocket(int *socket)
{
    CFURLRef       tool;
    OSStatus      err;
    AuthorizationRef  auth;
    CFDictionaryRef   request;
    CFDictionaryRef   response;
    CFStringRef     key;
    CFStringRef     value;

  *socket = -1;
    tool     = NULL;
    request  = NULL;
    response = NULL;
    auth    = NULL;
    // Create an Authorization Services environment.  Normally your
    // application would do this as it begins so that it can pre-authorize.
    // However, I don't pre-authorized because a) the pre-authorize flag
    // does nothing in current versions of Mac OS X [2907852], and b) doing
    // the pre-authorize triggers two authentication dialogs the first time
    // you run the application, which is never what you want.

    err = AuthorizationCreate(NULL, kAuthorizationEmptyEnvironment, kAuthorizationFlagDefaults, &amp;auth);
            // Find our helper tool, possibly restoring it from the template.
    if (err == noErr)
    {
        err = MoreSecCopyHelperToolURLAndCheckBundled(CFBundleGetMainBundle(), CFSTR(&quot;GetPFNDRVSocketToolTemplate&quot;), kApplicationSupportFolderType, CFSTR(&quot;BSDLLCTest&quot;), CFSTR(&quot;GetPFNDRVSocketTool&quot;), &amp;tool);
    }


    // Create the request dictionary.
    if (err == noErr)
    {
    // pass in the command name
        key   = kBSDLLCTestCommandNameKey;
        value = kBSDLLCTestGetPFNDRVSocket;
        request = CFDictionaryCreate(NULL, (const void **) &amp;key, (const void **) &amp;value, 1, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
        err = CFQError(request);
    }
    
    // Go go gadget helper tool!
    // open the ethernet socket
    // to do this we call our tool which will run with the SUID bit set so that we
    // can open a PF_NDRV socket. On success, the socket is returned for us to use.
    if (err == noErr)
    {
        err = MoreSecExecuteRequestInHelperTool(tool, auth, request, &amp;response);
    }

  // Extract information from the response.

    if (err == noErr)
    {
//    CFShow(response);

        err = MoreSecGetErrorFromResponse(response);
        if (err == noErr)
        {
      // things worked - get the PFNDRV socket

      CFArrayRef   descArray;
      CFIndex    descIndex;
      CFIndex    descCount;

      // we are looking for a returned file descriptor, so specify the
      // kMoreSecFileDescriptorsKey which is set in the tool and 
      // is handled in a special manner by
      // the MoreAuthSample framework.
      descArray = (CFArrayRef) CFDictionaryGetValue(response, kMoreSecFileDescriptorsKey);
      assert(descArray != NULL);
      assert( CFGetTypeID(descArray) == CFArrayGetTypeID() );
      
      descCount = CFArrayGetCount(descArray);
      assert (descCount == 1);   // expect only a single response
      for (descIndex = 0; descIndex &lt; descCount; descIndex++)
      {
        CFNumberRef thisDescNum;
        
        thisDescNum = (CFNumberRef) CFArrayGetValueAtIndex(descArray, descIndex);
        assert( (thisDescNum != NULL) &amp;&amp; (CFGetTypeID(thisDescNum) == CFNumberGetTypeID()) );

        // Normally it's bad to include function calls that have side effects 
        // within an &quot;assert&quot;, but in this case the assert is guaranteed 
        // to be in effect because we're inside a MORE_DEBUG block.
        
        assert( CFNumberGetValue(thisDescNum, kCFNumberIntType, socket) );
        assert(*socket &gt;= 0);
        fprintf(stderr, &quot;returned socket is %d\n&quot;, *socket);
      }

        }
    }

    return err;
}

OSStatus DoEnetTest(EnetTestData *enetdata)
{
  OSStatus      err;

    
  // check if we are trying to cancel an active receive test
  if (enetdata-&gt;sendRcvState != kCancelTest)
  {
        // need to get a privileged socket
        err = GetPFNDRVSocket(&amp;(enetdata-&gt;fd));

        if (err)
        {
            fprintf(stderr, &quot;Error trying to open PF_NDRV socket %d\n&quot;, (int)err);
        }

        if (err == noErr)
        {            
            enetdata-&gt;saddr.sa_len = sizeof(struct sockaddr);
            enetdata-&gt;saddr.sa_family = AF_NDRV;
            err = bind(enetdata-&gt;fd, &amp;(enetdata-&gt;saddr), sizeof(enetdata-&gt;saddr));
            if (err != noErr)
            {
                fprintf(stderr, &quot;\n\nError binding raw Ethernet socket!&quot;);
                fprintf(stderr, &quot;\nerrno is %d\n&quot;, errno);
            }
        }

        if (err == noErr)
        {
            // set up a protocol match - this is needed for listening to incoming packets
            // however for enet connections which are not presently active, adding the protocol
            // will get the stack active on the connection.
            if (enetdata-&gt;sap != 0xAA)
            {
                memset(&amp;(enetdata-&gt;snap), 0, sizeof(enetdata-&gt;snap));
                err = DoAddProtocolMatch(enetdata-&gt;fd, DLIL_DESC_SAP, NDRV_DEMUXTYPE_SAP, enetdata-&gt;sap, enetdata-&gt;sap, CONTROLCODE, (u_char*)&amp;(enetdata-&gt;snap));
            }
            else
            {
                err = DoAddProtocolMatch(enetdata-&gt;fd, DLIL_DESC_SNAP, NDRV_DEMUXTYPE_SNAP, enetdata-&gt;sap, enetdata-&gt;sap, CONTROLCODE, (u_char *)&amp;(enetdata-&gt;snap));
            }

            if (err != noErr)
                fprintf(stderr, &quot;DoAddProtocolMatch failed with error %ld\n&quot;, err);
        }
    
    if (err == noErr)
    {
      if (enetdata-&gt;sendRcvState == kSendTest)
      {
#if 0
        /* For Mac OS X 10.1.x, a problem can occur if trying to open a connection
          to an Ethernet NIC which is currently inactive. Some NIC's do not
          respond to being opened immediately - while the PFNDRV socket gets
          opened, nothing is sent across the wire.
          if this is the first time we are using a non-built in connection
          then sleep for 3 seconds.
        */
        if (enetdata-&gt;isFirstTime == TRUE)
        {
          fprintf(stderr, &quot;sleeping 5 secs\n&quot;);
          sleep(5);
        }
#endif
        DoBSDLLCWriteTest(enetdata);
        close(enetdata-&gt;fd);
        enetdata-&gt;fd = 0;
      }
      else
      {
        // this is a listening test.  check if the designated receive address has
        // been specified as a multicast address. Actually we could programmatically
        // figure this out
                if (enetdata-&gt;destAddrIsMCast)
                {
                    err = DoAddDelMulticast(enetdata-&gt;fd, (unsigned char*) enetdata-&gt;destaddr, true);
                    if (err)
                        fprintf(stderr, &quot;DoAddDelMulticast failed with error %ld\n&quot;, err);
                    else
                        fprintf(stderr, &quot;DoAddDelMulticast workedn&quot;);
                }
      
        
        if (err == noErr)
        {
          DoBSDLLCReadTest(enetdata);
          // when this routine finishes, we have started a receive test which
          // is currently active.
        }
        
        if (err)
        {
          close(enetdata-&gt;fd);
          enetdata-&gt;fd = 0;
        }
      }
    }
  }
  else
  {
    // we need to cancel an active receive test
    err = DoCancelBSDLLCReadTest(enetdata);
    if (err)
      fprintf(stderr, &quot;Error occurred canceling the read test %ld\n&quot;, err);
    else
      fprintf(stderr, &quot;cancelled the read test OK.\n&quot;);
  }
  return err;
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/BSDLLCTest/listing4.html%3Fid%3DDTS10000692-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/BSDLLCTest/listing4.html%3Fid%3DDTS10000692-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/BSDLLCTest/listing4.html%3Fid%3DDTS10000692-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>