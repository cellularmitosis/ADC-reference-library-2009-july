<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"            "http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN2007: The CGDirectDisplay API</title><meta name="keywords" content="CGDirectDisplay, bit depth, resolution switch, gamma, palette, full screen, cursor control, vertical blank, DrawSprocket."><meta name="Description" content="Technical Note TN2007: This Technote provides a referencefor the CGDirectDisplay API on Mac OS X."><meta name="categories" content="Core Graphics, Overview, Operating System and QuickDraw"><meta name="week-posted" content="Nov 6, 2000 - Nov 10, 2000"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003046" title="The CGDirectDisplay API"></a><A NAME="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/GraphicsImaging/idxCarbon-date.html" target="_blank">Graphics & Imaging > Carbon</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN2007</div>
<div id="pageheadsub">The CGDirectDisplay API</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">         <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext">                  <A HREF="#Section1">Definitions</A><BR>                  <BR>                  <A HREF="#Section12">Typical Usage</A><BR>                  <BR>                  <A HREF="#Section2">Finding Display IDs</A><BR>                  <BR>                  <A HREF="#Section3">Selecting Display Modes</A><BR>                  <BR>                  <A HREF="#Section4">Retrieving Display Mode Information</A><BR>                  <BR>                  <A HREF="#Section5">Using CGDirectDisplayIDs with OpenGL</A><BR>                  <BR>                  <A HREF="#Section6">Capturing and Releasing Displays</A><BR>                  <BR>                  <A HREF="#Section7">Switching the Display Mode</A><BR>                  <BR>                  <A HREF="#Section8">Adjusting the Display Gamma and Palette</A><BR>                  <BR>                  <A HREF="#Section9">Accessing the CoreGraphics Shielding Window</A><BR>                  <BR>                  <A HREF="#Section10">Controlling the Mouse Cursor</A><BR>                  <BR>                  <A HREF="#Section11">Waiting for the Vertical Blank</A><BR>                  <BR>                  <A HREF="#Summary">Summary</A><BR>                   <BR>                   <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                 <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left>            <!-- begin_intro_text --><p id="introtext">                This                  Technote provides a reference for the CGDirectDisplay API on Mac OS X.            </p>            <p id="introtext">                The CGDirectDisplay API is designed to provide direct access                    to display modes, cursor position, gamma tables, and other low-level                    functionality.  It is intended to replace and extend DrawSprocket, the Display Manager,                    and other similar APIs with one single, coherent, integrated API.            </p>            <p id="introtext">                This Technote describes the important data types, two typical                    usage patterns, and all of the function calls in the API.  A separate Technote                    will cover the API provided by CGDirectPalette.            </p><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Nov 07 2000]</h3><!-- end_date -->        </td>    </tr></table> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR>          <!-- begin_content --><P><A NAME="Section1"></A></P>                  <H2>Definitions</H2>                     <H3>Types used by the CGDirectDisplay API:</H3>            <CENTER><TABLE BORDER=1 CELLPADDING=10 WIDTH=550>               <TR>                  <td valign=top align=left>                  <P><B>Data Type</B></P>                  </TD>                  <td valign=top align=left>                  <P><B>Description</B></P>                  </TD>               </TR>               <TR>                  <td valign=top align=left>                  <P><CODE>CGDirectDisplayID</CODE></P>                  </TD>                  <td valign=top align=left>                  <P>An opaque reference to a display  (<CODE>kCGDirectMainDisplay</CODE>                        refers to the main display as a convenience)</P>                  </TD>               </TR>               <TR>                  <td valign=top align=left>                  <P><CODE>CGDirectPaletteRef</CODE></P>                  </TD>                  <td valign=top align=left>                  <P>An opaque reference to a palette</P>                  </TD>               </TR>               <TR>                  <td valign=top align=left>                  <P><CODE>CGDisplayCount</CODE></P>                  </TD>                  <td valign=top align=left>                  <P>An unsigned 32 bit value</P>                  </TD>               </TR>               <TR>                  <td valign=top align=left>                  <P><CODE>CGTableCount</CODE></P>                  </TD>                  <td valign=top align=left>                  <P>An unsigned 32 bit value</P>                  </TD>               </TR>               <TR>                  <td valign=top align=left>                  <P><CODE>CGDisplayCoord</CODE></P>                  </TD>                  <td valign=top align=left>                  <P>A signed 32 bit value representing a coordinate on a display                        (The display origin is in the upper left corner)</P>                  </TD>               </TR>               <TR>                  <td valign=top align=left>                  <P><CODE>CGByteValue</CODE></P>                  </TD>                  <td valign=top align=left>                  <P>An unsigned 8 bit value used by the gamma/palette functions</P>                  </TD>               </TR>               <TR>                  <td valign=top align=left>                  <P><CODE>CGOpenGLDisplayMask</CODE></P>                  </TD>                  <td valign=top align=left>                  <P>An unsigned 32 bit value holding OpenGL display mask bits                        (Each bit represents a different display)</P>                  </TD>               </TR>               <TR>                  <td valign=top align=left>                  <P><CODE>CGBeamPosition</CODE></P>                  </TD>                  <td valign=top align=left>                  <P>An unsigned 32 bit value representing the position of the refresh beam on the display (0 is at the top)</P>                  </TD>               </TR>               <TR>                  <td valign=top align=left>                  <P><CODE>CGMouseDelta</CODE></P>                  </TD>                  <td valign=top align=left>                  <P>A signed 32 bit value representing the change in the mouse position</P>                  </TD>               </TR>               <TR>                  <td valign=top align=left>                  <P><CODE>CGDisplayErr</CODE></P>                  </TD>                  <td valign=top align=left>                  <P>A signed 32 bit error value</P>                  </TD>               </TR>            </TABLE></CENTER><BR>                  <P><A HREF="#top">Back to top</A></P>                                    <P><A NAME="Section12"></A></P>                  <H2>Typical Usage</H2>                <H3>Simple:</H3>                <P>In the simple case, you want to take over the main display and set it to the                mode that most closely matches your required bit depth and resolution.  You can                then do any drawing you need to directly to the base address of the display.                Once you are done, restore the display mode and release the display.  </P>                <CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550> <TR> <td bgcolor="#e6e6e6" align=left>                <pre>CFDictionaryRef mode;CFDictionaryRef originalMode;size_t desiredBitDepth = 16;size_t desiredWidth = 1024;size_t desiredHeight = 768;boolean_t exactMatch;originalMode = CGDisplayCurrentMode( kCGDirectMainDisplay );mode = CGDisplayBestModeForParameters(    kCGDirectMainDisplay,    desiredBitDepth, desiredWidth,    desiredHeight, &amp;exactMatch );if ( NULL != mode ) {        /* If it is important to have an        exact match, check exactMatch here */    CGDisplayCapture( kCGDirectMainDisplay );    CGDisplaySwitchToMode( kCGDirectMainDisplay, mode );    CGDisplayHideCursor( kCGDirectMainDisplay );        /* Do your drawing/game loop here Use        CGDisplayBaseAddress() to get the base        address of the display */    CGDisplayShowCursor( kCGDirectMainDisplay );    CGDisplaySwitchToMode( kCGDirectMainDisplay, originalMode );    CGDisplayRelease( kCGDirectMainDisplay );}</pre></TD></TR></TABLE></CENTER><BR><BR><P><B>Listing 1</B>.  Code listing for the simple case.</p>                                               <H3>Complex:</H3>                 <P>In the complex case, you need more control over which display you use or                want to determine for yourself what "best mode" means.  In this case, you                get an array of active displays, iterate over that list examining the modes                that each display supports, and choose the most appropriate display/mode                combination for your application. </P>                                <CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550> <TR> <td bgcolor="#e6e6e6" align=left>                <pre>CFDictionaryRef originalMode;CGDirectDisplayID displays[kMaxDisplays];CGDisplayCount numDisplays;CGDisplayCount i;CGDisplayErr err;CFDictionaryRef bestMode = NULL;CGDirectDisplayID bestDisplay = kCGDirectMainDisplay;err = CGGetActiveDisplayList(    kMaxDisplays,    displays,    &numDisplays);if ( err != kCGDisplayNoErr ){    printf("Cannot get displays (%d)\n", err);    exit( 1 );}for ( i = 0; i &lt; numDisplays; i++ ){    CFDictionaryRef mode;    CFIndex i, cnt;    CGDirectDisplayID dspy;    CFArrayRef modeList;    dspy = displays[i];    modeList = CGDisplayAvailableModes(dspy);    if ( NULL != modeList )    {        //  Examine each mode        cnt = CFArrayGetCount( modeList );        for ( i = 0; i &lt; cnt; i++ )        {            //  Pull the mode dictionary out of the CFArray            mode = CFArrayGetValueAtIndex( modeList, i );            /* Examine the mode here thisModeIsTheBest( mode )            is a user supplied function that evaluates each            mode and picks the best one (returning true) */            if ( thisModeIsTheBest( mode ) )            {                bestMode = mode;                bestDisplay = dspy;            }        }    }}//  At this point, you have identified the best mode//      and its corresponding display IDif ( NULL != bestMode ){    originalMode = CGDisplayCurrentMode( bestDisplay );    CGDisplayCapture( bestDisplay );    CGDisplaySwitchToMode( bestDisplay, bestMode );    CGDisplayHideCursor( bestDisplay );    //  Do your drawing/game loop here    //  Use CGDisplayBaseAddress() to get the base address of the display    CGDisplayShowCursor( bestDisplay );    CGDisplaySwitchToMode( bestDisplay, originalMode );    CGDisplayRelease( bestDisplay );    }                </pre></TD></TR></TABLE></CENTER><BR><BR><P><B>Listing 2</B>.  Code listing for the complex case.</p>                         <P><A HREF="#top">Back to top</A></P>                                    <P><A NAME="Section2"></A></P>                  <H2>Finding Display IDs</H2>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGGetActiveDisplayList(    CGDisplayCount maxDisplays,    CGDirectDisplayID * activeDspys,    CGDisplayCount * dspyCnt);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Lists all active displays.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGGetDisplaysWithPoint(    CGPoint point,    CGDisplayCount maxDisplays,    CGDirectDisplayID * dspys,    CGDisplayCount * dspyCnt);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>         <LI>Lists all displays containing <CODE>point</CODE>.</LI>         <LI>Returns 0 in <CODE>dspyCnt</CODE> if no displays contain <CODE>point</CODE>.</LI>         <LI>Note that displays can overlap (via mirroring, for example) so the <CODE>dspys</CODE> array                may contain more than one display ID.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGGetDisplaysWithRect(    CGRect rect,    CGDisplayCount maxDisplays,    CGDirectDisplayID * dspys,    CGDisplayCount * dspyCnt);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Lists all displays containing at least part of <CODE>rect</CODE>.</LI>         <LI>Returns 0 in <CODE>dspyCnt</CODE> if no displays contain <CODE>point</CODE>.</LI>         <LI>Note that displays can overlap (via mirroring, for example) so the <CODE>dspys</CODE>                array may contain more than one display ID.</LI>         </UL>                           <P><A HREF="#top">Back to top</A></P>                                    <P><A NAME="Section3"></A></P>                  <H2>Selecting Display Modes</H2>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CFDictionaryRef CGDisplayCurrentMode(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Returns a CFDictionaryRef describing the current display mode.</LI>         <LI>Returns NULL for an invalid display ID.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CFArrayRef CGDisplayAvailableModes(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>         <LI>Returns a CFArray of CFDictionaries describing all available modes.</LI>         <LI>Returns NULL for an invalid display ID.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CFDictionaryRef CGDisplayBestModeForParameters(    CGDirectDisplayID display,    size_t bitsPerPixel,    size_t width,    size_t height,    boolean_t *exactMatch);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Finds a display mode of the specified depth with dimensions                equal to or greater than those specified.</LI>         <LI>If no exact depth match is found, checks for the next larger                depth with dimensions equal to or greater than those specified.</LI>         <LI>If no mode satisfies the criteria, returns the current mode.</LI>         <LI>Sets <CODE>exactMatch</CODE> (if not <CODE>NULL</CODE>) to                <CODE>true</CODE> if an exact match is found and <CODE>false</CODE>                if no exact match is available.</LI>         <LI>Returns NULL for an invalid display ID.</LI>         </UL>                  <P><A HREF="#top">Back to top</A></P>                  <P ALIGN=center>&nbsp;</P>                  <P><A NAME="Section4"></A></P>                  <H2>Retrieving Display Mode Information</H2>                    <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGRect CGDisplayBounds(CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Returns the screen size and origin in global coordinates.</LI>         <LI>Returns an empty rect for an invalid display ID.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>size_t CGDisplayPixelsWide(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>         <LI>Returns the display width in pixels.</LI>         <LI>Returns 0 for an invalid display ID.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>size_t CGDisplayPixelsHigh(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>         <LI>Returns the display height in pixels.</LI>         <LI>Returns 0 for an invalid display ID.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>size_t CGDisplayBitsPerPixel(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Returns the current bit depth of the specified display.</LI>         <LI>Returns 0 for an invalid display ID.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>size_t CGDisplayBitsPerSample(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Returns the number of bits per color sample for the specified display.</LI>         <LI>Returns 0 for an invalid display ID.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>size_t CGDisplaySamplesPerPixel(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Returns the number of color samples per pixel for the specified display.</LI>         <LI>Returns 0 for an invalid display ID.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>size_t CGDisplayBytesPerRow(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Returns the number of bytes per row for the specified display.</LI>         <LI>Returns 0 for an invalid display ID.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>void * CGDisplayBaseAddress(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Returns the base address of the specified display.</LI>         <LI>Returns NULL for an invalid display ID.</LI>         <LI>Note that if the display has not been captured, the returned address                 may refer to read-only memory.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>void * CGDisplayAddressForPosition(    CGDirectDisplayID display,    CGDisplayCoord x,    CGDisplayCoord y);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Returns the address for location (X,Y) in screen coordinates.</LI>         <LI>(0,0) represents the upper-left corner of the display.</LI>         <LI>Returns NULL if the display ID is invalid or the X and Y coordinates are out of bounds.</LI>         <LI>Note, if the display has not been captured, the returned address                 may refer to read-only memory.</LI>         </UL>                         <P><A HREF="#top">Back to top</A></P>                                    <P><A NAME="Section5"></A></P>                  <H2>Using CGDirectDisplayIDs with OpenGL</H2>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGGetDisplaysWithOpenGLDisplayMask(    CGOpenGLDisplayMask mask,    CGDisplayCount maxDisplays,    CGDirectDisplayID * dspys,    CGDisplayCount * dspyCnt);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>         <LI>Finds a list of displays whose mask bits are specified in <CODE>mask</CODE>.</LI>         <LI>Note that more than one display can be specified in the mask so the <CODE>dspys</CODE>                array may contain more than one display ID.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGOpenGLDisplayMask CGDisplayIDToOpenGLDisplayMask(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Finds the OpenGL display mask corresponding to a given display ID.</LI>         <LI>Returns 0 for an invalid display ID.</LI>         </UL>                  <P><A HREF="#top">Back to top</A></P>                                             <P><A NAME="Section6"></A></P>                  <H2>Capturing and Releasing Displays</H2>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGDisplayCapture(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Captures the specified display to put up the shield window and                allow for synchronous mode changes.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGDisplayRelease(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>         <LI>Releases the specified display and removes the shield window.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>boolean_t CGDisplayIsCaptured(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Returns <CODE>true</CODE> if the specified display is captured.</LI>         </UL>                           <P><A HREF="#top">Back to top</A></P>                                    <P><A NAME="Section7"></A></P>                  <H2>Switching the Display Mode</H2>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGDisplaySwitchToMode(    CGDirectDisplayID display,    CFDictionaryRef mode);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Switches the specified display into the mode described by the <CODE>mode</CODE> dictionary.</LI>         <LI>Note that switching modes may change display parameters and addresses.</LI>         <LI>The selected display mode persists for the life of the program and, when the program                terminates, the display mode automatically reverts to                the mode set in the Monitors panel in the System Preferences.</LI>         <LI>Note that display mode switching is only synchronous when applied to a captured display.                If the display has not been captured, mode switching is asynchronous and may not be complete                when <CODE>CGDisplaySwitchToMode</CODE> returns.</LI>         </UL>                           <P><A HREF="#top">Back to top</A></P>                                    <P><A NAME="Section8"></A></P>                  <H2>Adjusting the Display Gamma and Palette</H2>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGSetDisplayTransferByFormula(    CGDirectDisplayID display,    CGGammaValue redMin,    CGGammaValue redMax,    CGGammaValue redGamma,    CGGammaValue greenMin,    CGGammaValue greenMax,    CGGammaValue greenGamma,    CGGammaValue blueMin,    CGGammaValue blueMax,    CGGammaValue blueGamma);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Sets the display gamma/transfer function from a formula specifying                    min and max values and a gamma for each channel.</LI>         <LI>Gamma values must be greater than 0.0.</LI>         <LI>Specify a value of (1.0 / 1.6) to get an antigamma of 1.6.</LI>         <LI>Min values must be greater than or equal to 0.0 and less than 1.0.</LI>         <LI>Max values must be greater than 0.0 and less than or equal to 1.0.</LI>         <LI>Returns kCGSRangeCheck error if the values are out of range or max is greater than or equal to min.</LI>         <LI>Values are computed by sampling a function for a range of indices from 0 through 1:<BR>                value = Min + ((Max - Min) * pow(index, Gamma))</LI>         <LI>The resulting values are converted to a machine specific format and loaded into the hardware.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGGetDisplayTransferByFormula(    CGDirectDisplayID display,    CGGammaValue *redMin,    CGGammaValue *redMax,    CGGammaValue *redGamma,    CGGammaValue *greenMin,    CGGammaValue *greenMax,    CGGammaValue *greenGamma,    CGGammaValue *blueMin,    CGGammaValue *blueMax,    CGGammaValue *blueGamma);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>         <LI>Gets the display gamma/transfer function from a formula specifying                    min and max values and a gamma for each channel.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGSetDisplayTransferByTable(    CGDirectDisplayID display,    CGTableCount tableSize,    const CGGammaValue  *redTable,    const CGGammaValue  *greenTable,    const CGGammaValue  *blueTable);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Sets the display gamma/transfer function using tables of data for each channel.</LI>         <LI>Values within each table should have values in the range of 0.0 through 1.0.</LI>         <LI>The same table may be passed in for red, green, and blue channels.</LI>         <LI><CODE>tableSize</CODE> indicates the number of entries in each table.</LI>         <LI>The tables are interpolated as needed to generate the number of samples needed by hardware.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGGetDisplayTransferByTable(    CGDirectDisplayID display,    CGTableCount capacity,    CGGammaValue  *redTable,    CGGammaValue  *greenTable,    CGGammaValue  *blueTable,    CGTableCount *sampleCount);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Gets the display transfer tables.</LI>         <LI><CODE>capacity</CODE> indicates the number of samples each array can hold.</LI>         <LI><CODE>sampleCount</CODE> is filled in with the number of samples actually copied in.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGSetDisplayTransferByByteTable(    CGDirectDisplayID display,    CGTableCount tableSize,    const CGByteValue  *redTable,    const CGByteValue  *greenTable,    const CGByteValue  *blueTable);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Sets the display gamma/transfer function using tables of byte values for each channel.</LI>         <LI>Values within each table should have values in the range of 0 through 255.</LI>         <LI>The same table may be passed in for red, green, and blue channels.</LI>         <LI><CODE>tableSize</CODE> indicates the number of entries in each table.</LI>         <LI>The tables are interpolated as needed to generate the number of samples needed by hardware.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>boolean_t CGDisplayCanSetPalette(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Returns <CODE>true</CODE> if the specified display supports palettes.</LI>         <LI>8-bit pseudo-color only.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGDisplaySetPalette(    CGDirectDisplayID display,    const CGDirectPaletteRef palette);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Sets the palette for the specified display ID.</LI>         <LI>Note that the current gamma function is applied to the palette elements before they are                loaded into the hardware.</LI>         </UL>                           <P><A HREF="#top">Back to top</A></P>                                    <P><A NAME="Section9"></A></P>                  <H2>Accessing the CoreGraphics Shielding Window</H2>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>void * CGShieldingWindowID(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Returns the CoreGraphics raw shield window ID for use with the drawing surface APIs.</LI>         <LI>Returns NULL if the display ID is invalid or the display is not shielded.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>int32_t CGShieldingWindowLevel(void);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>         <LI>Returns the window level used for the shielding window.</LI>         <LI>This value may be used to position Cocoa windows at the                same window level as the shielding window.</LI>         </UL>                 <P><A HREF="#top">Back to top</A></P>                                    <P><A NAME="Section10"></A></P>                  <H2>Controlling the Mouse Cursor</H2>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGDisplayHideCursor(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Increments the hide cursor count, hiding the mouse cursor if necessary.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGDisplayShowCursor(    CGDirectDisplayID display);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>         <LI>Decrements the hide cursor count, showing the mouse cursor if necessary.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGDisplayMoveCursorToPoint(    CGDirectDisplayID display, CGPoint point);</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Moves the mouse cursor to the specified point relative to the display                origin (the upper left corner of the display).</LI>         <LI>Returns <CODE>kCGDisplayNoErr</CODE> if successful.</LI>         <LI>Note that no events are generated as a result of this move.</LI>         <LI>Points that would lie outside the desktop are clipped to the desktop.</LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>void CGGetLastMouseDelta(    CGMouseDelta * deltaX,    CGMouseDelta * deltaY );</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>         <LI>Returns the mouse position change associated with the last mouse move                event received by this application.</LI>         </UL>                 <P><A HREF="#top">Back to top</A></P>                                    <P><A NAME="Section11"></A></P>                  <H2>Waiting for the Vertical Blank</H2>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGDisplayErr CGDisplayWaitForBeamPositionOutsideLines(    CGDirectDisplayID display,    CGBeamPosition upperScanLine,    CGBeamPosition lowerScanLine );</pre></TD></TR></TABLE></CENTER><BR><BR>         <UL>         <LI>Waits until the beam position is outside the range specified by                <CODE>upperScanLine</CODE> and <CODE>lowerScanLine</CODE>.</LI>         <LI>Returns <CODE>kCGDisplayNoErr</CODE> on success and an error if <CODE>display</CODE>,                <CODE>upperScanLine</CODE>, or <CODE>lowerScanLine</CODE> are invalid.</LI>         <LI>Note that if <CODE>upperScanLine</CODE> and <CODE>lowerScanLine</CODE> encompass                the entire display height, the function returns an error.</LI>         <LI><CODE>lowerScanLine</CODE> must be greater than or equal to <CODE>upperScanLine</CODE>.</LI>         <LI>Some display systems may not use conventional video vertical and                horizontal sweeps in refreshing the display.  These displays report a                <CODE>kCGDisplayRefreshRate</CODE> of 0 in the CFDictionaryRef returned by                <CODE>CGDisplayCurrentMode</CODE> and on such displays                <CODE>CGDisplayWaitForBeamPositionOutsideLines</CODE> returns at once.</LI>         <LI><CODE>upperScanLine</CODE> and <CODE>lowerScanLine</CODE> should be set                to allow enough lead time for the drawing operation to complete.                A common strategy is to wait for the beam to pass the bottom of the                drawing area, allowing almost a full vertical sweep period to perform                drawing.  To do this, set <CODE>upperScanLine</CODE> to 0, and set                <CODE>lowerScanLine</CODE> to the bottom of the bounding box:<BR>                <CODE>lowerScanLine = (CGBeamPosition)(cgrect.origin.y + cgrect.size.height);</CODE></LI>         </UL>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>CGBeamPosition CGDisplayBeamPosition(    CGDirectDisplayID display );</pre></TD></TR></TABLE></CENTER><BR><BR>                  <UL>         <LI>Returns the current beam position on the display.</LI>         <LI>Returns 0 if <CODE>display</CODE> is invalid or the display doesn't                implement a conventional vertical sweep for painting.</LI>         </UL>                           <P><A HREF="#top">Back to top</A></P>                                    <P><A NAME="Summary"></A></P>                  <H2>Summary</H2>                  <P>This Technote covers the basic information you need to start using            the CGDirectDisplay API, including the important type definitions, function            calls, and typical usage patterns.  Information on using the CGDirectPalette            API will follow in an upcoming Technote.</P>                  <P ><A HREF="#top">Back to top</A></P>                  <P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (140K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn2007.pdf">Download</A></P>               </TD>            </TR>                    </table>         <BR>                  <P ><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn2007.html%3Fid%3DDTS10003046-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn2007.html%3Fid%3DDTS10003046-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn2007.html%3Fid%3DDTS10003046-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>