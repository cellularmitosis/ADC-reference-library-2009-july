<html><head><title>Mac OS X
 Manual Page For expect(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/expect" title="Mac OS X
 Manual Page for expect(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/expect"; name=expect(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
EXPECT(1)                                                                                          EXPECT(1)



<b>NAME</b>
       expect - programmed dialogue with interactive programs, Version 5

<b>SYNOPSIS</b>
       <b>expect</b> [ <b>-dDinN</b> ] [ <b>-c</b> <u>cmds</u> ] [ [ <b>-</b>[<b>f</b>|<b>b</b>] ] <u>cmdfile</u> ] [ <u>args</u> ]

<b>INTRODUCTION</b>
       <b>Expect</b>  is a program that "talks" to other interactive programs according to a script.  Following the
       script, <b>Expect</b> knows what can be expected from a program and what the correct response should be.  An
       interpreted language provides branching and high-level control structures to direct the dialogue.  In
       addition, the user can take control and interact directly when desired, afterward  returning  control
       to the script.

       <b>Expectk</b>  is  a mixture of <b>Expect</b> and <b>Tk</b>.  It behaves just like <b>Expect</b> and <b>Tk</b>'s <b>wish</b>.  <b>Expect</b> can also
       be used directly in C or C++ (that is, without Tcl).  See <!-- a -->libexpect(3)<!-- /a -->.

       The name "Expect" comes from the idea of <u>send/expect</u> sequences popularized by uucp, kermit and  other
       modem  control programs.  However unlike uucp, <b>Expect</b> is generalized so that it can be run as a user-<font color="#ffffff" class="whiteout">level&nbsp;userlevel</font>
       level command with any program and task in mind.  <b>Expect</b> can actually talk to several programs at the
       same time.

       For example, here are some things <b>Expect</b> can do:

                 Cause your computer to dial you back, so that you can login without paying for the call.

                 Start  a  game  (e.g.,  rogue) and if the optimal configuration doesn't appear, restart it
                  (again and again) until it does, then hand over control to you.

                 Run fsck, and in response to its questions, answer "yes", "no" or  give  control  back  to
                  you, based on predetermined criteria.

                 Connect  to another network or BBS (e.g., MCI Mail, CompuServe) and automatically retrieve
                  your mail so that it appears as if it was originally sent to your local system.

                 Carry environment variables, current directory, or any kind of information across  rlogin,
                  telnet, tip, su, chgrp, etc.

       There are a variety of reasons why the shell cannot perform these tasks.  (Try, you'll see.)  All are
       possible with <b>Expect</b>.

       In general, <b>Expect</b> is useful for running any program which requires interaction between  the  program
       and  the  user.  All that is necessary is that the interaction can be characterized programmatically.
       <b>Expect</b> can also give the user back control (without halting the program being controlled) if desired.
       Similarly, the user can return control to the script at any time.

<b>USAGE</b>
       <b>Expect</b>  reads  <u>cmdfile</u>  for  a list of commands to execute.  <b>Expect</b> may also be invoked implicitly on
       systems which support the #! notation by marking the script executable, and making the first line  in
       your script:

           #!/usr/local/bin/expect -f

       Of  course, the path must accurately describe where <b>Expect</b> lives.  /usr/local/bin is just an example.

       The <b>-c</b> flag prefaces a command to be executed before any in the script.  The command should be quoted
       to  prevent being broken up by the shell.  This option may be used multiple times.  Multiple commands
       may be executed with a single <b>-c</b> by separating them with semicolons.  Commands are  executed  in  the
       order they appear.  (When using Expectk, this option is specified as <b>-command</b>.)

       The  <b>-d</b>  flag  enables  some diagnostic output, which primarily reports internal activity of commands
       such as <b>expect</b> and <b>interact</b>.  This flag has the same effect as "exp_internal 1" at the  beginning  of
       an  Expect  script, plus the version of <b>Expect</b> is printed.  (The <b>strace</b> command is useful for tracing
       statements, and the <b>trace</b> command is useful for tracing variable assignments.)  (When using  Expectk,
       this option is specified as <b>-diag</b>.)

       The <b>-D</b> flag enables an interactive debugger.  An integer value should follow.  The debugger will take
       control before the next Tcl procedure if the value is non-zero or if a ^C is pressed (or a breakpoint
       is  hit,  or  other  appropriate debugger command appears in the script).  See the README file or SEE
       ALSO (below) for more information on the debugger.  (When using Expectk, this option is specified  as
       <b>-Debug</b>.)

       The  <b>-f</b>  flag prefaces a file from which to read commands from.  The flag itself is optional as it is
       only useful when using the #! notation (see above), so that other arguments may be  supplied  on  the
       command line.  (When using Expectk, this option is specified as <b>-file</b>.)

       By  default,  the  command file is read into memory and executed in its entirety.  It is occasionally
       desirable to read files one line at a time.  For example, stdin is read this way.  In order to  force
       arbitrary  files to be handled this way, use the <b>-b</b> flag.  (When using Expectk, this option is speci-<font color="#ffffff" class="whiteout">fied&nbsp;specified</font>
       fied  as  <b>-buffer</b>.)<b>Note</b>that<b>stdio-buffering</b>may<b>still</b>take<b>place</b>however<b>this</b>shouldn't<b>cause</b>problems<b>when</b>read-<font color="#ffffff" class="whiteout">ingfromafifoorstdin.&nbsp;-buffer.)Notethatstdio-bufferingmaystilltakeplacehoweverthisshouldn'tcauseproblemswhenreadingfromafifoorstdin.</font>
       ing<b>from</b>a<b>fifo</b>or<b>stdin.</b>

       If the string "-" is supplied as a filename, standard input is read instead.  (Use "./-" to read from
       a file actually named "-".)

       The <b>-i</b> flag causes <b>Expect</b> to interactively prompt for commands instead of reading them from  a  file.
       Prompting  is terminated via the <b>exit</b> command or upon EOF.  See <b>interpreter</b> (below) for more informa-<font color="#ffffff" class="whiteout">tion.&nbsp;information.</font>
       tion.  <b>-i</b> is assumed if neither a command file nor <b>-c</b> is used.  (When using Expectk, this  option  is
       specified as <b>-interactive</b>.)

       <b>--</b>  may be used to delimit the end of the options.  This is useful if you want to pass an option-like
       argument to your script without it being interpreted by <b>Expect</b>.  This can usefully be placed  in  the
       #! line to prevent any flag-like interpretation by Expect.  For example, the following will leave the
       original arguments (including the script name) in the variable <u>argv</u>.

           #!/usr/local/bin/expect --<font color="#ffffff" class="whiteout">Note&nbsp;-Note</font>

       Note that the usual <a href="../man3/getopt.3.html#//apple_ref/doc/man/3/getopt">getopt(3)</a> and <a href="../man2/execve.2.html#//apple_ref/doc/man/2/execve">execve(2)</a> conventions must be observed when adding arguments to the
       #! line.

       The  file  $exp_library/expect.rc  is  sourced  automatically if present, unless the <b>-N</b> flag is used.
       (When using Expectk,  this  option  is  specified  as  <b>-NORC</b>.)   Immediately  after  this,  the  file
       ~/.expect.rc  is sourced automatically, unless the <b>-n</b> flag is used.  If the environment variable DOT-<font color="#ffffff" class="whiteout">DIR&nbsp;DOTDIR</font>
       DIR is defined, it is treated as a directory and .expect.rc is read from there.  (When using Expectk,
       this option is specified as <b>-norc</b>.)  This sourcing occurs only after executing any <b>-c</b> flags.

       <b>-v</b>  causes  Expect  to  print its version number and exit.  (The corresponding flag in Expectk, which
       uses long flag names, is -version.)

       Optional <u>args</u> are constructed into a list and stored in the variable named <u>argv</u>.  <u>argc</u> is initialized
       to the length of argv.

       <u>argv0</u>  is  defined  to  be the name of the script (or binary if no script is used).  For example, the
       following prints out the name of the script and the first three arguments:

           send_user "$argv0 [lrange $argv 0 2]\n"


<b>COMMANDS</b>
       <b>Expect</b> uses <u>Tcl</u> (Tool Command Language).  Tcl provides control flow (e.g., if, for,  break),  expres-<font color="#ffffff" class="whiteout">sion&nbsp;expression</font>
       sion  evaluation  and  several other features such as recursion, procedure definition, etc.  Commands
       used here but not defined (e.g., <b>set</b>, <b>if</b>, <b>exec</b>) are Tcl commands (see <!-- a -->tcl(3)<!-- /a -->).  <b>Expect</b> supports addi-<font color="#ffffff" class="whiteout">tional&nbsp;additional</font>
       tional commands, described below.  Unless otherwise specified, commands return the empty string.

       Commands  are listed alphabetically so that they can be quickly located.  However, new users may find
       it easier to start by reading the descriptions of <b>spawn</b>, <b>send</b>, <b>expect</b>, and <b>interact</b>, in that order.

       Note that the best introduction to the language (both  Expect  and  Tcl)  is  provided  in  the  book
       "Exploring  Expect"  (see  SEE ALSO below).  Examples are included in this man page but they are very
       limited since this man page is meant primarily as reference material.

       Note that in the text of this man page, "Expect" with an uppercase "E" refers to the  <b>Expect</b>  program
       while "expect" with a lower-case "e" refers to the <b>expect</b> command within the <b>Expect</b> program.)

       <b>close</b> <u>[-slave]</u> <u>[-onexec</u> <u>0|1]</u> <u>[-i</u> <u>spawn</u><b>_</b><u>id]</u>
             closes  the  connection  to  the current process.  Most interactive programs will detect EOF on
             their stdin and exit; thus <b>close</b> usually suffices to kill the process as  well.   The  <b>-i</b>  flag
             declares the process to close corresponding to the named spawn_id.

             Both  <b>expect</b> and <b>interact</b> will detect when the current process exits and implicitly do a <b>close</b>.
             But if you kill the process by, say, "exec kill $pid", you will need to explicitly call  <b>close</b>.

             The <b>-onexec</b> flag determines whether the spawn id will be closed in any new spawned processes or
             if the process is overlayed.  To leave a spawn id open, use the value 0.   A  non-zero  integer
             value will force the spawn closed (the default) in any new processes.

             The  <b>-slave</b>  flag closes the slave associated with the spawn id.  (See "spawn -pty".)  When the
             connection is closed, the slave is automatically closed as well if still open.

             No matter whether the connection is closed implicitly or explicitly, you should  call  <b>wait</b>  to
             clear  up  the  corresponding  kernel process slot.  <b>close</b> does not call <b>wait</b> since there is no
             guarantee that closing a process connection will cause it to exit.  See  <b>wait</b>  below  for  more
             info.

       <b>debug</b> <u>[[-now]</u> <u>0|1]</u>
             controls a Tcl debugger allowing you to step through statements, set breakpoints, etc.

             With no arguments, a 1 is returned if the debugger is not running, otherwise a 0 is returned.

             With  a 1 argument, the debugger is started.  With a 0 argument, the debugger is stopped.  If a
             1 argument is preceded by the <b>-now</b> flag, the debugger is started immediately (i.e., in the mid-<font color="#ffffff" class="whiteout">dle&nbsp;middle</font>
             dle  of the <b>debug</b> command itself).  Otherwise, the debugger is started with the next Tcl state-<font color="#ffffff" class="whiteout">ment.&nbsp;statement.</font>
             ment.

             The <b>debug</b> command does not change any traps.  Compare this to starting Expect with the <b>-D</b>  flag
             (see above).

             See the README file or SEE ALSO (below) for more information on the debugger.

       <b>disconnect</b>
             disconnects  a  forked process from the terminal.  It continues running in the background.  The
             process is given its own process group (if possible).  Standard I/O is redirected to /dev/null.

             The following fragment uses <b>disconnect</b> to continue running the script in the background.

                 if {[fork]!=0} exit
                 disconnect
                 . . .

             The  following script reads a password, and then runs a program every hour that demands a pass-<font color="#ffffff" class="whiteout">word&nbsp;password</font>
             word each time it is run.  The script supplies the password so that you only have  to  type  it
             once.  (See the <b>stty</b> command which demonstrates how to turn off password echoing.)

                 send_user "password?\ "
                 expect_user -re "(.*)\n"
                 for {} 1 {} {
                     if {[fork]!=0} {sleep 3600;continue}
                     disconnect
                     spawn priv_prog
                     expect Password:
                     send "$expect_out(1,string)\r"
                     . . .
                     exit
                 }

             An advantage to using <b>disconnect</b> over the shell asynchronous process feature (&amp;) is that <b>Expect</b>
             can save the terminal parameters prior to disconnection, and then later apply them to new ptys.
             With  &amp;,  <b>Expect</b> does not have a chance to read the terminal's parameters since the terminal is
             already disconnected by the time <b>Expect</b> receives control.

       <b>exit</b> <u>[-opts]</u> <u>[status]</u>
             causes <b>Expect</b> to exit or otherwise prepare to do so.

             The <b>-onexit</b> flag causes the next argument to be used as an exit handler.  Without an  argument,
             the current exit handler is returned.

             The  <b>-noexit</b> flag causes <b>Expect</b> to prepare to exit but stop short of actually returning control
             to the operating system.  The user-defined exit handler is run as well as Expect's own internal
             handlers.   No  further  Expect commands should be executed.  This is useful if you are running
             Expect with other Tcl extensions.  The current interpreter (and main window if in the Tk  envi-<font color="#ffffff" class="whiteout">ronment)&nbsp;environment)</font>
             ronment)  remain  so  that other Tcl extensions can clean up.  If Expect's <b>exit</b> is called again
             (however this might occur), the handlers are not rerun.

             Upon exiting, all connections to spawned processes are closed.  Closure will be detected as  an
             EOF  by  spawned processes.  <b>exit</b> takes no other actions beyond what the normal <a href="../man2/_exit.2.html#//apple_ref/doc/man/2/_exit">_exit(2)</a> proce-<font color="#ffffff" class="whiteout">dure&nbsp;procedure</font>
             dure does.  Thus, spawned processes that do not check for EOF may continue to run.  (A  variety
             of conditions are important to determining, for example, what signals a spawned process will be
             sent, but these are system-dependent, typically documented under <a href="../man3/exit.3.html#//apple_ref/doc/man/3/exit">exit(3)</a>.)   Spawned  processes
             that continue to run will be inherited by init.

             <u>status</u>  (or  0  if not specified) is returned as the exit status of <b>Expect</b>.  <b>exit</b> is implicitly
             executed if the end of the script is reached.

       <b>exp_continue</b> [-continue_timer]
             The command <b>exp_continue</b> allows <b>expect</b> itself to continue executing rather than returning as it
             normally would. By default <b>exp_continue</b> resets the timeout timer. The <u>-continue</u><b>_</b><u>timer</u> flag pre-<font color="#ffffff" class="whiteout">vents&nbsp;prevents</font>
             vents timer from being restarted. (See <b>expect</b> for more information.)

       <b>exp_internal</b> <u>[-f</u> <u>file]</u> <u>value</u>
             causes further commands to send diagnostic information internal to <b>Expect</b> to stderr if <u>value</u> is
             non-zero.   This  output  is disabled if <u>value</u> is 0.  The diagnostic information includes every
             character received, and every attempt made to match the current output against the patterns.

             If the optional <u>file</u> is supplied, all normal and debugging  output  is  written  to  that  file
             (regardless of the value of <u>value</u>).  Any previous diagnostic output file is closed.

             The  <b>-info</b>  flag  causes exp_internal to return a description of the most recent non-info argu-<font color="#ffffff" class="whiteout">ments&nbsp;arguments</font>
             ments given.

       <b>exp_open</b> <u>[args]</u> <u>[-i</u> <u>spawn</u><b>_</b><u>id]</u>
             returns a Tcl file identifier that corresponds to the original spawn id.  The  file  identifier
             can then be used as if it were opened by Tcl's <b>open</b> command.  (The spawn id should no longer be
             used.  A <b>wait</b> should not be executed.

             The <b>-leaveopen</b> flag leaves the spawn id open for access through Expect commands.  A  <b>wait</b>  must
             be executed on the spawn id.

       <b>exp_pid</b> <u>[-i</u> <u>spawn</u><b>_</b><u>id]</u>
             returns the process id corresponding to the currently spawned process.  If the <b>-i</b> flag is used,
             the pid returned corresponds to that of the given spawn id.

       <b>exp_send</b>
             is an alias for <b>send</b>.

       <b>exp_send_error</b>
             is an alias for <b>send_error</b>.

       <b>exp_send_log</b>
             is an alias for <b>send_log</b>.

       <b>exp_send_tty</b>
             is an alias for <b>send_tty</b>.

       <b>exp_send_user</b>
             is an alias for <b>send_user</b>.

       <b>exp_version</b> <u>[[-exit]</u> <u>version]</u>
             is useful for assuring that the script is compatible with the current version of Expect.

             With no arguments, the current version of <b>Expect</b> is returned.  This version may then be encoded
             in  your  script.  If you actually know that you are not using features of recent versions, you
             can specify an earlier version.

             Versions consist of three numbers separated by dots.  First is the major number.  Scripts writ-<font color="#ffffff" class="whiteout">ten&nbsp;written</font>
             ten  for  versions  of  <b>Expect</b>  with  a  different major number will almost certainly not work.
             <b>exp_version</b> returns an error if the major numbers do not match.

             Second is the minor number.  Scripts written for a version with a greater minor number than the
             current  version  may  depend  upon some new feature and might not run.  <b>exp_version</b> returns an
             error if the major numbers match, but the script minor number is greater than that of the  run-<font color="#ffffff" class="whiteout">ning&nbsp;running</font>
             ning <b>Expect</b>.

             Third  is  a  number  that plays no part in the version comparison.  However, it is incremented
             when the <b>Expect</b> software distribution is changed in any way, such as by  additional  documenta-<font color="#ffffff" class="whiteout">tion&nbsp;documentation</font>
             tion or optimization.  It is reset to 0 upon each new minor version.

             With the <b>-exit</b> flag, <b>Expect</b> prints an error and exits if the version is out of date.

       <b>expect</b> <u>[[-opts]</u> <u>pat1</u> <u>body1]</u> <u>...</u> <u>[-opts]</u> <u>patn</u> <u>[bodyn]</u>
             waits  until  one  of  the  patterns  matches the output of a spawned process, a specified time
             period has passed, or an end-of-file is seen.  If the final body is empty, it may be omitted.

             Patterns from the most recent <b>expect_before</b> command are implicitly used before any  other  pat-<font color="#ffffff" class="whiteout">terns.&nbsp;patterns.</font>
             terns.   Patterns from the most recent <b>expect_after</b> command are implicitly used after any other
             patterns.

             If the arguments to the entire <b>expect</b> statement require more than one line, all  the  arguments
             may  be  "braced"  into one so as to avoid terminating each line with a backslash.  In this one
             case, the usual Tcl substitutions will occur despite the braces.

             If a pattern is the keyword <b>eof</b>, the corresponding body is executed  upon  end-of-file.   If  a
             pattern is the keyword <b>timeout</b>, the corresponding body is executed upon timeout.  If no timeout
             keyword is used, an implicit null action is executed upon timeout.  The default timeout  period
             is  10 seconds but may be set, for example to 30, by the command "set timeout 30".  An infinite
             timeout may be designated by the value -1.  If a pattern is the  keyword  <b>default</b>,  the  corre-<font color="#ffffff" class="whiteout">sponding&nbsp;corresponding</font>
             sponding body is executed upon either timeout or end-of-file.

             If  a  pattern  matches, then the corresponding body is executed.  <b>expect</b> returns the result of
             the body (or the empty string if no pattern matched).  In  the  event  that  multiple  patterns
             match, the one appearing first is used to select a body.

             Each  time  new  output  arrives,  it is compared to each pattern in the order they are listed.
             Thus, you may test for absence of a match by making the last pattern  something  guaranteed  to
             appear,  such  as a prompt.  In situations where there is no prompt, you must use <b>timeout</b> (just
             like you would if you were interacting manually).

             Patterns are specified in three ways.  By default, patterns are specified as with Tcl's  <b>string</b>
             <b>match</b> command.  (Such patterns are also similar to C-shell regular expressions usually referred
             to as "glob" patterns).  The <b>-gl</b> flag may may be used to protect patterns that might  otherwise
             match  <b>expect</b>  flags  from doing so.  Any pattern beginning with a "-" should be protected this
             way.  (All strings starting with "-" are reserved for future options.)


             For example, the following fragment looks for a successful login.  (Note that <b>abort</b> is presumed
             to be a procedure defined elsewhere in the script.)

                 expect {
                     busy               {puts busy\n ; exp_continue}
                     failed             abort
                     "invalid password" abort
                     timeout            abort
                     connected
                 }

             Quotes  are  necessary  on  the fourth pattern since it contains a space, which would otherwise
             separate the pattern from the action.  Patterns with the same action (such as the 3rd and  4th)
             require  listing  the  actions  again.   This  can be avoid by using regexp-style patterns (see
             below).  More information on forming glob-style patterns can be found in the Tcl manual.

             Regexp-style patterns follow the syntax defined by Tcl's <b>regexp</b>  (short  for  "regular  expres-<font color="#ffffff" class="whiteout">sion")&nbsp;expression")</font>
             sion") command.  regexp patterns are introduced with the flag <b>-re</b>.  The previous example can be
             rewritten using a regexp as:

                 expect {
                     busy       {puts busy\n ; exp_continue}
                     -re "failed|invalid password" abort
                     timeout    abort
                     connected
                 }

             Both types of patterns are "unanchored".  This means that patterns do not  have  to  match  the
             entire  string,  but  can begin and end the match anywhere in the string (as long as everything
             else matches).  Use ^ to match the beginning of a string, and $ to match the end.  Note that if
             you  do not wait for the end of a string, your responses can easily end up in the middle of the
             string as they are echoed from the spawned process.  While still producing correct results, the
             output  can look unnatural.  Thus, use of $ is encouraged if you can exactly describe the char-<font color="#ffffff" class="whiteout">acters&nbsp;characters</font>
             acters at the end of a string.

             Note that in many editors, the ^ and $ match the beginning and end of lines respectively.  How-<font color="#ffffff" class="whiteout">ever,&nbsp;However,</font>
             ever,  because expect is not line oriented, these characters match the beginning and end of the
             data (as opposed to lines) currently in the expect matching buffer.  (Also, see the note  below
             on "system indigestion.")

             The <b>-ex</b> flag causes the pattern to be matched as an "exact" string.  No interpretation of *, ^,
             etc is made (although the usual Tcl conventions must still be observed).   Exact  patterns  are
             always unanchored.


             The <b>-nocase</b> flag causes uppercase characters of the output to compare as if they were lowercase
             characters.  The pattern is not affected.

             While reading output, more than 2000 bytes can force earlier bytes to be "forgotten".  This may
             be  changed with the function <b>match_max</b>.  (Note that excessively large values can slow down the
             pattern matcher.)  If <u>patlist</u> is <b>full_buffer</b>, the corresponding body is executed  if  <u>match</u><b>_</b><u>max</u>
             bytes  have  been  received and no other patterns have matched.  Whether or not the <b>full_buffer</b>
             keyword is used, the forgotten characters are written to expect_out(buffer).

             If <u>patlist</u> is the keyword <b>null</b>, and nulls are allowed (via the <b>remove_nulls</b> command), the  cor-<font color="#ffffff" class="whiteout">responding&nbsp;corresponding</font>
             responding  body  is  executed  if  a single ASCII 0 is matched.  It is not possible to match 0
             bytes via glob or regexp patterns.

             Upon matching a pattern (or eof or full_buffer), any matching and previously  unmatched  output
             is saved in the variable <u>expect</u><b>_</b><u>out(buffer)</u>.  Up to 9 regexp substring matches are saved in the
             variables <u>expect</u><b>_</b><u>out(1,string)</u> through <u>expect</u><b>_</b><u>out(9,string)</u>.  If  the  <b>-indices</b>  flag  is  used
             before  a  pattern,  the  starting and ending indices (in a form suitable for <b>lrange</b>) of the 10
             strings are stored in the variables <u>expect</u><b>_</b><u>out(X,start)</u> and  <u>expect</u><b>_</b><u>out(X,end)</u>  where  X  is  a
             digit,  corresponds to the substring position in the buffer.  0 refers to strings which matched
             the entire pattern and is generated for glob patterns as well as regexp patterns.  For example,
             if a process has produced output of "abcdefgh\n", the result of:

                 expect "cd"

             is as if the following statements had executed:

                 set expect_out(0,string) cd
                 set expect_out(buffer) abcd

             and  "efgh\n" is left in the output buffer.  If a process produced the output "abbbcabkkkka\n",
             the result of:

                 expect -indices -re "b(b*).*(k+)"

             is as if the following statements had executed:

                 set expect_out(0,start) 1
                 set expect_out(0,end) 10
                 set expect_out(0,string) bbbcabkkkk
                 set expect_out(1,start) 2
                 set expect_out(1,end) 3
                 set expect_out(1,string) bb
                 set expect_out(2,start) 10
                 set expect_out(2,end) 10
                 set expect_out(2,string) k
                 set expect_out(buffer) abbbcabkkkk

             and "a\n" is left in the output buffer.  The pattern "*" (and -re ".*") will flush  the  output
             buffer without reading any more output from the process.

             Normally,  the  matched  output  is discarded from Expect's internal buffers.  This may be pre-<font color="#ffffff" class="whiteout">vented&nbsp;prevented</font>
             vented by prefixing a pattern with the <b>-notransfer</b> flag.  This flag  is  especially  useful  in
             experimenting (and can be abbreviated to "-not" for convenience while experimenting).

             The  spawn  id  associated  with  the  matching  output  (or  eof  or full_buffer) is stored in
             <u>expect</u><b>_</b><u>out(spawn</u><b>_</b><u>id)</u>.

             The <b>-timeout</b> flag causes the current expect command to use the following  value  as  a  timeout
             instead of using the value of the timeout variable.

             By  default,  patterns are matched against output from the current process, however the <b>-i</b> flag
             declares the output from the named spawn_id list be matched against any following patterns  (up
             to  the  next <b>-i</b>).  The spawn_id list should either be a whitespace separated list of spawn_ids
             or a variable referring to such a list of spawn_ids.

             For example, the following example waits for "connected" from the current process,  or  "busy",
             "failed" or "invalid password" from the spawn_id named by $proc2.

                 expect {
                     -i $proc2 busy {puts busy\n ; exp_continue}
                     -re "failed|invalid password" abort
                     timeout abort
                     connected
                 }

             The  value  of  the global variable <u>any</u><b>_</b><u>spawn</u><b>_</b><u>id</u> may be used to match patterns to any spawn_ids
             that are named with all other <b>-i</b> flags in the current <b>expect</b> command.  The spawn_id from  a  <b>-i</b>
             flag with no associated pattern (i.e., followed immediately by another <b>-i</b>) is made available to
             any other patterns in the same <b>expect</b> command associated with <u>any</u><b>_</b><u>spawn</u><b>_</b><u>id.</u>

             The <b>-i</b> flag may also name a global variable in which case the variable is read for  a  list  of
             spawn  ids.   The  variable is reread whenever it changes.  This provides a way of changing the
             I/O source while the command is in execution.  Spawn ids provided this way  are  called  "indi-<font color="#ffffff" class="whiteout">rect"&nbsp;"indirect"</font>
             rect" spawn ids.

             Actions  such as <b>break</b> and <b>continue</b> cause control structures (i.e., <b>for</b>, <b>proc</b>) to behave in the
             usual way.  The command <b>exp_continue</b> allows <b>expect</b> itself to  continue  executing  rather  than
             returning as it normally would.

             This  is useful for avoiding explicit loops or repeated expect statements.  The following exam-<font color="#ffffff" class="whiteout">ple&nbsp;example</font>
             ple is part of a fragment to automate rlogin.  The <b>exp_continue</b> avoids having to write a second
             <b>expect</b> statement (to look for the prompt again) if the rlogin prompts for a password.

                 expect {
                     Password: {
                         stty -echo
                         send_user "password (for $user) on $host: "
                         expect_user -re "(.*)\n"
                         send_user "\n"
                         send "$expect_out(1,string)\r"
                         stty echo
                         exp_continue
                     } incorrect {
                         send_user "invalid password or account\n"
                         exit
                     } timeout {
                         send_user "connection to $host timed out\n"
                         exit
                     } eof {
                         send_user \
                             "connection to host failed: $expect_out(buffer)"
                         exit
                     } -re $prompt
                 }

             For  example,  the  following  fragment  might help a user guide an interaction that is already
             totally automated.  In this case, the terminal is put into raw mode.  If the user presses  "+",
             a variable is incremented.  If "p" is pressed, several returns are sent to the process, perhaps
             to poke it in some way, and "i" lets the user interact with the process,  effectively  stealing
             away control from the script.  In each case, the <b>exp_continue</b> allows the current <b>expect</b> to con-<font color="#ffffff" class="whiteout">tinue&nbsp;continue</font>
             tinue pattern matching after executing the current action.

                 stty raw -echo
                 expect_after {
                     -i $user_spawn_id
                     "p" {send "\r\r\r"; exp_continue}
                     "+" {incr foo; exp_continue}
                     "i" {interact; exp_continue}
                     "quit" exit
                 }


             By default, <b>exp_continue</b> resets the timeout timer.  The timer is not restarted, if <b>exp_continue</b>
             is called with the <b>-continue_timer</b> flag.

       <b>expect_after</b> <u>[expect</u><b>_</b><u>args]</u>
             works  identically  to  the  <b>expect_before</b>  except  that  if  patterns  from  both  <b>expect</b>  and
             <b>expect_after</b> can match, the <b>expect</b> pattern is used.  See the  <b>expect_before</b>  command  for  more
             information.

       <b>expect_background</b> <u>[expect</u><b>_</b><u>args]</u>
             takes  the same arguments as <b>expect</b>, however it returns immediately.  Patterns are tested when-<font color="#ffffff" class="whiteout">ever&nbsp;whenever</font>
             ever new input arrives.  The pattern <b>timeout</b> and <b>default</b> are meaningless  to  <b>expect_background</b>
             and  are  silently  discarded.  Otherwise, the <b>expect_background</b> command uses <b>expect_before</b> and
             <b>expect_after</b> patterns just like <b>expect</b> does.

             When <b>expect_background</b> actions are being evaluated, background processing for the same spawn id
             is  blocked.   Background  processing is unblocked when the action completes.  While background
             processing is blocked, it is possible to do a (foreground) <b>expect</b> on the same spawn id.

             It is not possible to execute an <b>expect</b> while an <b>expect_background</b> is unblocked.   <b>expect_back</b>-<font color="#ffffff" class="whiteout">ground&nbsp;expect_background</font>
             <b>ground</b>  for a particular spawn id is deleted by declaring a new expect_background with the same
             spawn id.  Declaring <b>expect_background</b> with no pattern removes the  given  spawn  id  from  the
             ability to match patterns in the background.

       <b>expect_before</b> <u>[expect</u><b>_</b><u>args]</u>
             takes  the same arguments as <b>expect</b>, however it returns immediately.  Pattern-action pairs from
             the most recent <b>expect_before</b> with the same spawn id are  implicitly  added  to  any  following
             <b>expect</b> commands.  If a pattern matches, it is treated as if it had been specified in the <b>expect</b>
             command itself, and the associated body is executed in the context of the <b>expect</b>  command.   If
             patterns from both <b>expect_before</b> and <b>expect</b> can match, the <b>expect_before</b> pattern is used.

             If no pattern is specified, the spawn id is not checked for any patterns.

             Unless  overridden  by  a <b>-i</b> flag, <b>expect_before</b> patterns match against the spawn id defined at
             the time that the <b>expect_before</b> command was executed (not when its pattern is matched).

             The -info flag causes <b>expect_before</b> to return the current specifications of  what  patterns  it
             will  match.   By default, it reports on the current spawn id.  An optional spawn id specifica-<font color="#ffffff" class="whiteout">tion&nbsp;specification</font>
             tion may be given for information on that spawn id.  For example

                 expect_before -info -i $proc

             At most one spawn id specification may be given.  The flag -indirect  suppresses  direct  spawn
             ids that come only from indirect specifications.

             Instead  of a spawn id specification, the flag "-all" will cause "-info" to report on all spawn
             ids.

             The output of the -info flag can be reused as the argument to expect_before.

       <b>expect_tty</b> <u>[expect</u><b>_</b><u>args]</u>
             is like <b>expect</b> but it reads characters from /dev/tty  (i.e.  keystrokes  from  the  user).   By
             default,  reading is performed in cooked mode.  Thus, lines must end with a return in order for
             <b>expect</b> to see them.  This may be changed via <b>stty</b> (see the <b>stty</b> command below).

       <b>expect_user</b> <u>[expect</u><b>_</b><u>args]</u>
             is like <b>expect</b> but it reads characters from stdin (i.e. keystrokes from the user).  By default,
             reading is performed in cooked mode.  Thus, lines must end with a return in order for <b>expect</b> to
             see them.  This may be changed via <b>stty</b> (see the <b>stty</b> command below).

       <b>fork</b>  creates a new process.  The new process is an exact copy of the  current  <b>Expect</b>  process.   On
             success,  <b>fork</b>  returns  0  to  the new (child) process and returns the process ID of the child
             process to the parent process.  On failure (invariably due to lack  of  resources,  e.g.,  swap
             space, memory), <b>fork</b> returns -1 to the parent process, and no child process is created.

             Forked  processes  exit via the <b>exit</b> command, just like the original process.  Forked processes
             are allowed to write to the log files.  If you do not disable debugging or logging in  most  of
             the processes, the result can be confusing.

             Some  pty  implementations  may  be confused by multiple readers and writers, even momentarily.
             Thus, it is safest to <b>fork</b> before spawning processes.

       <b>interact</b> <u>[string1</u> <u>body1]</u> <u>...</u> <u>[stringn</u> <u>[bodyn]]</u>
             gives control of the current process to the user, so that keystrokes are sent  to  the  current
             process, and the stdout and stderr of the current process are returned.

             String-body  pairs  may  be specified as arguments, in which case the body is executed when the
             corresponding string is entered.  (By default, the string is not sent to the current  process.)
             The <b>interpreter</b> command is assumed, if the final body is missing.

             If the arguments to the entire <b>interact</b> statement require more than one line, all the arguments
             may be "braced" into one so as to avoid terminating each line with a backslash.   In  this  one
             case, the usual Tcl substitutions will occur despite the braces.

             For  example, the following command runs interact with the following string-body pairs defined:
             When ^Z is pressed, <b>Expect</b> is suspended.  (The <b>-reset</b> flag restores the terminal modes.)   When
             ^A  is  pressed, the user sees "you typed a control-A" and the process is sent a ^A.  When $ is
             pressed, the user sees the date.  When ^C is pressed, <b>Expect</b> exits.  If "foo" is  entered,  the
             user sees "bar".  When ~~ is pressed, the <b>Expect</b> interpreter runs interactively.

                 set CTRLZ \032
                 interact {
                     -reset $CTRLZ {exec kill -STOP [pid]}
                     \001   {send_user "you typed a control-A\n";
                             send "\001"
                            }
                     $      {send_user "The date is [exec date]."}
                     \003   exit
                     foo    {send_user "bar"}
                     ~~
                 }


             In  string-body  pairs, strings are matched in the order they are listed as arguments.  Strings
             that partially match are not sent to the current process in anticipation of the remainder  com-<font color="#ffffff" class="whiteout">ing.&nbsp;coming.</font>
             ing.   If  characters  are then entered such that there can no longer possibly be a match, only
             the part of the string will be sent to the process that cannot possibly  begin  another  match.
             Thus,  strings  that are substrings of partial matches can match later, if the original strings
             that was attempting to be match ultimately fails.

             By default, string matching is exact with no wild cards.  (In contrast, the <b>expect</b> command uses
             glob-style  patterns by default.)  The <b>-ex</b> flag may be used to protect patterns that might oth-<font color="#ffffff" class="whiteout">erwise&nbsp;otherwise</font>
             erwise match <b>interact</b> flags from doing so.  Any pattern beginning with a  "-"  should  be  pro-<font color="#ffffff" class="whiteout">tected&nbsp;protected</font>
             tected this way.    (All strings starting with "-" are reserved for future options.)

             The  <b>-re</b>  flag  forces  the  string to be interpreted as a regexp-style pattern.  In this case,
             matching substrings are stored in the variable <u>interact</u><b>_</b><u>out</u> similarly to the way <b>expect</b>  stores
             its output in the variable <b>expect_out</b>.  The <b>-indices</b> flag is similarly supported.

             The pattern <b>eof</b> introduces an action that is executed upon end-of-file.  A separate <b>eof</b> pattern
             may also follow the <b>-output</b> flag in which case it is matched if an eof is detected while  writ-<font color="#ffffff" class="whiteout">ing&nbsp;writing</font>
             ing  output.  The default <b>eof</b> action is "return", so that <b>interact</b> simply returns upon any EOF.

             The pattern <b>timeout</b> introduces a timeout (in seconds) and action  that  is  executed  after  no
             characters  have  been read for a given time.  The <b>timeout</b> pattern applies to the most recently
             specified process.  There is no default timeout.  The special variable "timeout" (used  by  the
             <b>expect</b> command) has no affect on this timeout.

             For  example, the following statement could be used to autologout users who have not typed any-<font color="#ffffff" class="whiteout">thing&nbsp;anything</font>
             thing for an hour but who still get frequent system messages:

                 interact -input $user_spawn_id timeout 3600 return -output \
                     $spawn_id


             If the pattern is the keyword <b>null</b>, and nulls are allowed (via the <b>remove_nulls</b>  command),  the
             corresponding  body  is executed if a single ASCII 0 is matched.  It is not possible to match 0
             bytes via glob or regexp patterns.

             Prefacing a pattern with the flag <b>-iwrite</b> causes the variable <u>interact</u><b>_</b><u>out(spawn</u><b>_</b><u>id)</u> to be  set
             to the spawn_id which matched the pattern (or eof).

             Actions  such as <b>break</b> and <b>continue</b> cause control structures (i.e., <b>for</b>, <b>proc</b>) to behave in the
             usual way.  However <b>return</b> causes interact to return to its caller, while  <b>inter_return</b>  causes
             <b>interact</b>  to  cause  a  return in its caller.  For example, if "proc foo" called <b>interact</b> which
             then executed the action <b>inter_return</b>, <b>proc</b> <b>foo</b> would return.  (This  means  that  if  <b>interact</b>
             calls  <b>interpreter</b>  interactively  typing  <b>return</b>  will  cause  the interact to continue, while
             <b>inter_return</b> will cause the interact to return to its caller.)

             During <b>interact</b>, raw mode is used so that all characters may be passed to the current  process.
             If  the  current process does not catch job control signals, it will stop if sent a stop signal
             (by default ^Z).  To restart it, send a continue signal (such as by "kill  -CONT  &lt;pid&gt;").   If
             you  really  want  to send a SIGSTOP to such a process (by ^Z), consider spawning csh first and
             then running your program.  On the other hand, if you want to send a SIGSTOP to <b>Expect</b>  itself,
             first call interpreter (perhaps by using an escape character), and then press ^Z.

             String-body  pairs  can be used as a shorthand for avoiding having to enter the interpreter and
             execute commands interactively.  The previous terminal mode is used while the body of a string-<font color="#ffffff" class="whiteout">body&nbsp;stringbody</font>
             body pair is being executed.

             For  speed, actions execute in raw mode by default.  The <b>-reset</b> flag resets the terminal to the
             mode it had before <b>interact</b> was executed  (invariably,  cooked  mode).   Note  that  characters
             entered  when  the  mode  is being switched may be lost (an unfortunate feature of the terminal
             driver on some systems).  The only reason to use <b>-reset</b> is if your action depends on running in
             cooked mode.

             The  <b>-echo</b> flag sends characters that match the following pattern back to the process that gen-<font color="#ffffff" class="whiteout">erated&nbsp;generated</font>
             erated them as each character is read.  This may be useful when the user needs to see  feedback
             from partially typed patterns.

             If  a  pattern  is  being  echoed but eventually fails to match, the characters are sent to the
             spawned process.  If the spawned process then echoes them, the user  will  see  the  characters
             twice.  <b>-echo</b> is probably only appropriate in situations where the user is unlikely to not com-<font color="#ffffff" class="whiteout">plete&nbsp;complete</font>
             plete the pattern.  For example, the following excerpt is from rftp, the recursive-ftp  script,
             where  the  user is prompted to enter ~g, ~p, or ~l, to get, put, or list the current directory
             recursively.  These are so far away from the normal ftp commands, that the user is unlikely  to
             type  ~  followed  by  anything  else,  except mistakenly, in which case, they'll probably just
             ignore the result anyway.

                 interact {
                     -echo ~g {getcurdirectory 1}
                     -echo ~l {getcurdirectory 0}
                     -echo ~p {putcurdirectory}
                 }

             The <b>-nobuffer</b> flag sends characters that match the following pattern on to the  output  process
             as characters are read.

             This  is useful when you wish to let a program echo back the pattern.  For example, the follow-<font color="#ffffff" class="whiteout">ing&nbsp;following</font>
             ing might be used to monitor where a person is dialing (a Hayes-style modem).  Each time  "atd"
             is seen the script logs the rest of the line.

                 proc lognumber {} {
                     interact -nobuffer -re "(.*)\r" return
                     puts $log "[exec date]: dialed $interact_out(1,string)"
                 }

                 interact -nobuffer "atd" lognumber


             During  <b>interact</b>,  previous use of <b>log_user</b> is ignored.  In particular, <b>interact</b> will force its
             output to be logged (sent to the standard output) since it is presumed the user doesn't wish to
             interact blindly.

             The  <b>-o</b>  flag  causes  any  following key-body pairs to be applied to the output of the current
             process.  This can be useful, for example, when dealing with hosts that send  unwanted  charac-<font color="#ffffff" class="whiteout">ters&nbsp;characters</font>
             ters during a telnet session.

             By  default,  <b>interact</b>  expects  the  user to be writing stdin and reading stdout of the <b>Expect</b>
             process itself.  The <b>-u</b> flag (for "user") makes <b>interact</b> look for the user as the process named
             by its argument (which must be a spawned id).

             This  allows  two unrelated processes to be joined together without using an explicit loop.  To
             aid in debugging, Expect diagnostics always go to stderr (or stdout  for  certain  logging  and
             debugging  information).   For the same reason, the <b>interpreter</b> command will read interactively
             from stdin.

             For example, the following fragment creates a login process.   Then  it  dials  the  user  (not
             shown),  and  finally connects the two together.  Of course, any process may be substituted for
             login.  A shell, for example, would allow the user to work without  supplying  an  account  and
             password.

                 spawn login
                 set login $spawn_id
                 spawn tip modem
                 # dial back out to user
                 # connect user to login
                 interact -u $login

             To  send  output  to  multiple  processes,  list each spawn id list prefaced by a <b>-output</b> flag.
             Input for a group of output spawn ids may be determined by a spawn id list prefaced by a <b>-input</b>
             flag.   (Both  <b>-input</b>  and <b>-output</b> may take lists in the same form as the <b>-i</b> flag in the <b>expect</b>
             command, except that any_spawn_id is not meaningful in  <b>interact</b>.)   All  following  flags  and
             strings  (or  patterns)  apply  to  this input until another -input flag appears.  If no <b>-input</b>
             appears, <b>-output</b> implies "-input $user_spawn_id -output".  (Similarly, with  patterns  that  do
             not have <b>-input</b>.)  If one <b>-input</b> is specified, it overrides $user_spawn_id.  If a second <b>-input</b>
             is specified, it overrides $spawn_id.  Additional <b>-input</b> flags may be specified.

             The two implied input processes default to having their  outputs  specified  as  $spawn_id  and
             $user_spawn_id  (in  reverse).   If a <b>-input</b> flag appears with no <b>-output</b> flag, characters from
             that process are discarded.

             The <b>-i</b> flag introduces a replacement for the current spawn_id when no other <b>-input</b>  or  <b>-output</b>
             flags are used.  A -i flag implies a -o flag.

             It  is  possible to change the processes that are being interacted with by using indirect spawn
             ids.  (Indirect spawn ids are described in the section on the expect command.)  Indirect  spawn
             ids may be specified with the -i, -u, -input, or -output flags.

       <b>interpreter</b>  <b>[args]</b>
             causes  the  user to be interactively prompted for <b>Expect</b> and Tcl commands.  The result of each
             command is printed.

             Actions such as <b>break</b> and <b>continue</b> cause control structures (i.e., <b>for</b>, <b>proc</b>) to behave in  the
             usual  way.   However  <b>return</b>  causes  interpreter  to return to its caller, while <b>inter_return</b>
             causes <b>interpreter</b> to cause a return in its caller.  For example, if "proc foo"  called  <b>inter</b>-<font color="#ffffff" class="whiteout">preter&nbsp;interpreter</font>
             <b>preter</b>  which  then executed the action <b>inter_return</b>, <b>proc</b> <b>foo</b> would return.  Any other command
             causes <b>interpreter</b> to continue prompting for new commands.

             By default, the prompt contains two integers.  The first integer describes  the  depth  of  the
             evaluation  stack  (i.e.,  how many times Tcl_Eval has been called).  The second integer is the
             Tcl history identifier.  The prompt can be set by defining a procedure called  "prompt1"  whose
             return  value  becomes  the  next  prompt.   If a statement has open quotes, parens, braces, or
             brackets, a secondary prompt (by default "+&gt; ") is issued upon newline.  The  secondary  prompt
             may be set by defining a procedure called "prompt2".

             During <b>interpreter</b>, cooked mode is used, even if the its caller was using raw mode.

             If  stdin  is  closed,  <b>interpreter</b> will return unless the <b>-eof</b> flag is used, in which case the
             subsequent argument is invoked.

       <b>log_file</b> <u>[args]</u> <u>[[-a]</u> <u>file]</u>
             If a filename is provided, <b>log_file</b> will record a transcript of the session (beginning at  that
             point)  in  the  file.  <b>log_file</b> will stop recording if no argument is given.  Any previous log
             file is closed.

             Instead of a filename, a Tcl file identifier may be provided by using the <b>-open</b>  or  <b>-leaveopen</b>
             flags.  This is similar to the <b>spawn</b> command.  (See <b>spawn</b> for more info.)

             The <b>-a</b> flag forces output to be logged that was suppressed by the <b>log_user</b> command.

             By default, the <b>log_file</b> command <u>appends</u> to old files rather than truncating them, for the con-<font color="#ffffff" class="whiteout">venience&nbsp;convenience</font>
             venience of being able to turn logging off and on multiple times in one session.   To  truncate
             files, use the <b>-noappend</b> flag.

             The  <b>-info</b>  flag  causes log_file to return a description of the most recent non-info arguments
             given.

       <b>log_user</b> <u>-info|0|1</u>
             By default, the send/expect dialogue is logged to stdout (and a logfile if open).  The  logging
             to  stdout  is  disabled by the command "log_user 0" and reenabled by "log_user 1".  Logging to
             the logfile is unchanged.

             The <b>-info</b> flag causes log_user to return a description of the most  recent  non-info  arguments
             given.

       <b>match_max</b> <u>[-d]</u> <u>[-i</u> <u>spawn</u><b>_</b><u>id]</u> <u>[size]</u>
             defines  the  size  of the buffer (in bytes) used internally by <b>expect</b>.  With no <u>size</u> argument,
             the current size is returned.

             With the <b>-d</b> flag, the default size is set.  (The initial default is 2000.)  With the  <b>-i</b>  flag,
             the size is set for the named spawn id, otherwise it is set for the current process.

       <b>overlay</b> <u>[-#</u> <u>spawn</u><b>_</b><u>id]</u> <u>[-#</u> <u>spawn</u><b>_</b><u>id]</u> <u>[...]</u> <u>program</u> <u>[args]</u>
             executes  <u>program</u> <u>args</u> in place of the current <b>Expect</b> program, which terminates.  A bare hyphen
             argument forces a hyphen in front of the command  name  as  if  it  was  a  login  shell.   All
             spawn_ids are closed except for those named as arguments.  These are mapped onto the named file
             identifiers.

             Spawn_ids are mapped to file identifiers for the new program to inherit.  For example, the fol-<font color="#ffffff" class="whiteout">lowing&nbsp;following</font>
             lowing  line  runs  chess  and allows it to be controlled by the current process - say, a chess
             master.

                 overlay -0 $spawn_id -1 $spawn_id -2 $spawn_id chess

             This is more efficient than "interact -u", however, it sacrifices the ability to do  programmed
             interaction since the <b>Expect</b> process is no longer in control.

             Note  that  no  controlling  terminal  is  provided.  Thus, if you disconnect or remap standard
             input, programs that do job control (shells, login, etc) will not function properly.

       <b>parity</b> <u>[-d]</u> <u>[-i</u> <u>spawn</u><b>_</b><u>id]</u> <u>[value]</u>
             defines whether parity should be retained or stripped from the output of spawned processes.  If
             <u>value</u>  is  zero, parity is stripped, otherwise it is not stripped.  With no <u>value</u> argument, the
             current value is returned.

             With the <b>-d</b> flag, the default parity value is set.  (The initial default is 1, i.e., parity  is
             not  stripped.)  With the <b>-i</b> flag, the parity value is set for the named spawn id, otherwise it
             is set for the current process.

       <b>remove_nulls</b> <u>[-d]</u> <u>[-i</u> <u>spawn</u><b>_</b><u>id]</u> <u>[value]</u>
             defines whether nulls are retained or removed from the output of spawned processes before  pat-<font color="#ffffff" class="whiteout">tern&nbsp;pattern</font>
             tern  matching or storing in the variable <u>expect</u><b>_</b><u>out</u> or <u>interact</u><b>_</b><u>out</u>.  If <u>value</u> is 1, nulls are
             removed.  If <u>value</u> is 0, nulls are not removed.  With no <u>value</u> argument, the current  value  is
             returned.

             With  the  <b>-d</b>  flag,  the  default  value  is  set.  (The initial default is 1, i.e., nulls are
             removed.)  With the <b>-i</b> flag, the value is set for the named spawn id, otherwise it is  set  for
             the current process.

             Whether or not nulls are removed, <b>Expect</b> will record null bytes to the log and stdout.

       <b>send</b> <u>[-flags]</u> <u>string</u>
             Sends <u>string</u> to the current process.  For example, the command

                 send "hello world\r"

             sends  the  characters,  h  e  l  l  o &lt;blank&gt; w o r l d &lt;return&gt; to the current process.  (Tcl
             includes a printf-like command (called <b>format</b>) which can build arbitrarily complex strings.)

             Characters are sent immediately although programs with line-buffered input will  not  read  the
             characters until a return character is sent.  A return character is denoted "\r".

             The  <b>--</b>  flag  forces  the next argument to be interpreted as a string rather than a flag.  Any
             string can be preceded by "--" whether or not it actually looks like a flag.  This  provides  a
             reliable  mechanism to specify variable strings without being tripped up by those that acciden-<font color="#ffffff" class="whiteout">tally&nbsp;accidentally</font>
             tally look like flags.  (All strings starting with "-" are reserved for future options.)

             The <b>-i</b> flag declares that the string be sent  to  the  named  spawn_id.   If  the  spawn_id  is
             <u>user</u><b>_</b><u>spawn</u><b>_</b><u>id</u>,  and  the  terminal  is  in  raw  mode, newlines in the string are translated to
             return-newline sequences so that they appear as if the terminal was in cooked mode.   The  <b>-raw</b>
             flag disables this translation.

             The  <b>-null</b> flag sends null characters (0 bytes).  By default, one null is sent.  An integer may
             follow the <b>-null</b> to indicate how many nulls to send.

             The <b>-break</b> flag generates a break condition.  This only makes sense if the spawn id refers to a
             tty device opened via "spawn -open".  If you have spawned a process such as tip, you should use
             tip's convention for generating a break.

             The <b>-s</b> flag forces output to be sent "slowly", thus avoid the common situation where a computer
             outtypes an input buffer that was designed for a human who would never outtype the same buffer.
             This output is controlled by the value of the variable "send_slow" which takes  a  two  element
             list.   The  first element is an integer that describes the number of bytes to send atomically.
             The second element is a real number that describes the number of seconds by  which  the  atomic
             sends  must be separated.  For example, "set send_slow {10 .001}" would force "send -s" to send
             strings with 1 millisecond in between each 10 characters sent.

             The <b>-h</b> flag forces output to be sent (somewhat)  like  a  human  actually  typing.   Human-like
             delays  appear  between  the  characters.  (The algorithm is based upon a Weibull distribution,
             with modifications to suit this particular application.)  This  output  is  controlled  by  the
             value of the variable "send_human" which takes a five element list.  The first two elements are
             average interarrival time of characters in seconds.  The first is used by default.  The  second
             is  used at word endings, to simulate the subtle pauses that occasionally occur at such transi-<font color="#ffffff" class="whiteout">tions.&nbsp;transitions.</font>
             tions.  The third parameter is a measure of variability where .1 is quite variable, 1  is  rea-<font color="#ffffff" class="whiteout">sonably&nbsp;reasonably</font>
             sonably  variable,  and  10 is quite invariable.  The extremes are 0 to infinity.  The last two
             parameters are, respectively, a minimum and maximum interarrival time.  The minimum and maximum
             are  used last and "clip" the final time.  The ultimate average can be quite different from the
             given average if the minimum and maximum clip enough values.

             As an example, the following command emulates a fast and consistent typist:

                 set send_human {.1 .3 1 .05 2}
                 send -h "I'm hungry.  Let's do lunch."

             while the following might be more suitable after a hangover:

                 set send_human {.4 .4 .2 .5 100}
                 send -h "Goodd party lash night!"

             Note that errors are not simulated, although you can set up error correction  situations  your-<font color="#ffffff" class="whiteout">self&nbsp;yourself</font>
             self by embedding mistakes and corrections in a send argument.

             The  flags  for  sending  null  characters, for sending breaks, for forcing slow output and for
             human-style output are mutually exclusive. Only the one specified last will be  used.  Further-<font color="#ffffff" class="whiteout">more,&nbsp;Furthermore,</font>
             more, no <u>string</u> argument can be specified with the flags for sending null characters or breaks.

             It is a good idea to precede the first <b>send</b> to a process by an <b>expect</b>.  <b>expect</b>  will  wait  for
             the process to start, while <b>send</b> cannot.  In particular, if the first <b>send</b> completes before the
             process starts running, you run the risk of having your  data  ignored.   In  situations  where
             interactive programs offer no initial prompt, you can precede <b>send</b> by a delay as in:

                 # To avoid giving hackers hints on how to break in,
                 # this system does not prompt for an external password.
                 # Wait for 5 seconds for exec to complete
                 spawn telnet very.secure.gov
                 sleep 5
                 send password\r

             <b>exp_send</b> is an alias for <b>send</b><u>.</u>  If you are using Expectk or some other variant of Expect in the
             Tk environment, <b>send</b> is defined by Tk for an entirely different purpose.  <b>exp_send</b> is  provided
             for  compatibility between environments.  Similar aliases are provided for other Expect's other
             send commands.

       <b>send_error</b> <u>[-flags]</u> <u>string</u>
             is like <b>send</b>, except that the output is sent to stderr rather than the current process.

       <b>send_log</b> <u>[--]</u> <u>string</u>
             is like <b>send</b>, except that the string is only sent to the log file (see  <b>log_file</b>.)   The  argu-<font color="#ffffff" class="whiteout">ments&nbsp;arguments</font>
             ments are ignored if no log file is open.

       <b>send_tty</b> <u>[-flags]</u> <u>string</u>
             is like <b>send</b>, except that the output is sent to /dev/tty rather than the current process.

       <b>send_user</b> <u>[-flags]</u> <u>string</u>
             is like <b>send</b>, except that the output is sent to stdout rather than the current process.

       <b>sleep</b> <u>seconds</u>
             causes  the  script to sleep for the given number of seconds.  Seconds may be a decimal number.
             Interrupts (and Tk events if you are using Expectk) are processed while Expect sleeps.

       <b>spawn</b> <u>[args]</u> <u>program</u> <u>[args]</u>
             creates a new process running <u>program</u> <u>args</u>.  Its stdin, stdout  and  stderr  are  connected  to
             Expect,  so that they may be read and written by other <b>Expect</b> commands.  The connection is bro-<font color="#ffffff" class="whiteout">ken&nbsp;broken</font>
             ken by <b>close</b> or if the process itself closes any of the file identifiers.

             When a process is started by <b>spawn</b>, the variable <u>spawn</u><b>_</b><u>id</u> is set to a descriptor  referring  to
             that  process.   The process described by <u>spawn</u><b>_</b><u>id</u> is considered the <u>current</u> <u>process</u>.  <u>spawn</u><b>_</b><u>id</u>
             may be read or written, in effect providing job control.

             <u>user</u><b>_</b><u>spawn</u><b>_</b><u>id</u> is a global variable containing a descriptor which refers to the user.  For exam-<font color="#ffffff" class="whiteout">ple,&nbsp;example,</font>
             ple, when <u>spawn</u><b>_</b><u>id</u> is set to this value, <b>expect</b> behaves like <b>expect_user</b>.

             <u>error</u><b>_</b><u>spawn</u><b>_</b><u>id</u> is a global variable containing a descriptor which refers to the standard error.
             For example, when <u>spawn</u><b>_</b><u>id</u> is set to this value, <b>send</b> behaves like <b>send_error</b>.

             <u>tty</u><b>_</b><u>spawn</u><b>_</b><u>id</u> is a global variable  containing  a  descriptor  which  refers  to  /dev/tty.   If
             /dev/tty  does  not  exist  (such  as in a cron, at, or batch script), then <u>tty</u><b>_</b><u>spawn</u><b>_</b><u>id</u> is not
             defined.  This may be tested as:

                 if {[info vars tty_spawn_id]} {
                     # /dev/tty exists
                 } else {
                     # /dev/tty doesn't exist
                     # probably in cron, batch, or at script
                 }


             <b>spawn</b> returns the UNIX process id.  If no process is spawned,  0  is  returned.   The  variable
             <u>spawn</u><b>_</b><u>out(slave,name)</u> is set to the name of the pty slave device.

             By  default,  <b>spawn</b>  echoes  the command name and arguments.  The <b>-noecho</b> flag stops <b>spawn</b> from
             doing this.

             The <b>-console</b> flag causes console output to be redirected to the spawned process.  This  is  not
             supported on all systems.

             Internally, <b>spawn</b> uses a pty, initialized the same way as the user's tty.  This is further ini-<font color="#ffffff" class="whiteout">tialized&nbsp;initialized</font>
             tialized so that all settings are "sane" (according to <a href="stty.1.html#//apple_ref/doc/man/1/stty">stty(1)</a>).  If the variable <u>stty</u><b>_</b><u>init</u>  is
             defined,  it is interpreted in the style of stty arguments as further configuration.  For exam-<font color="#ffffff" class="whiteout">ple,&nbsp;example,</font>
             ple, "set stty_init raw" will cause further spawned processes's terminals to start in raw mode.
             <b>-nottycopy</b>  skips the initialization based on the user's tty.  <b>-nottyinit</b> skips the "sane" ini-<font color="#ffffff" class="whiteout">tialization.&nbsp;initialization.</font>
             tialization.

             Normally, <b>spawn</b> takes little time to execute.  If you notice spawn taking a significant  amount
             of  time,  it is probably encountering ptys that are wedged.  A number of tests are run on ptys
             to avoid entanglements with errant processes.  (These take 10 seconds per wedged pty.)  Running
             Expect  with the <b>-d</b> option will show if <b>Expect</b> is encountering many ptys in odd states.  If you
             cannot kill the processes to which these ptys are  attached,  your  only  recourse  may  be  to
             reboot.

             If  <u>program</u>  cannot  be  spawned  successfully because <!-- a -->exec(2)<!-- /a --> fails (e.g. when <u>program</u> doesn't
             exist), an error message will be returned by the next <b>interact</b> or <b>expect</b> command as if  <u>program</u>
             had  run  and  produced the error message as output.  This behavior is a natural consequence of
             the implementation of <b>spawn</b>.  Internally, spawn forks, after which the spawned process  has  no
             way to communicate with the original <b>Expect</b> process except by communication via the spawn_id.

             The  <b>-open</b>  flag  causes  the  next  argument to be interpreted as a Tcl file identifier (i.e.,
             returned by <b>open</b>.)  The spawn id can then be used as if it were a spawned process.   (The  file
             identifier should no longer be used.)  This lets you treat raw devices, files, and pipelines as
             spawned processes without using a pty.  0 is  returned  to  indicate  there  is  no  associated
             process.   When the connection to the spawned process is closed, so is the Tcl file identifier.
             The <b>-leaveopen</b> flag is similar to <b>-open</b> except that <b>-leaveopen</b> causes the file identifier to be
             left open even after the spawn id is closed.

             The  <b>-pty</b>  flag  causes  a  pty to be opened but no process spawned.  0 is returned to indicate
             there is no associated process.  Spawn_id is set as usual.

             The variable <u>spawn</u><b>_</b><u>out(slave,fd)</u> is set to a file identifier corresponding to  the  pty  slave.
             It can be closed using "close -slave".

             The  <b>-ignore</b>  flag names a signal to be ignored in the spawned process.  Otherwise, signals get
             the default behavior.  Signals are named as in  the  <b>trap</b>  command,  except  that  each  signal
             requires a separate flag.

       <b>strace</b> <u>level</u>
             causes  following  statements to be printed before being executed.  (Tcl's trace command traces
             variables.)  <u>level</u> indicates how far down in the call stack to trace.  For example, the follow-<font color="#ffffff" class="whiteout">ing&nbsp;following</font>
             ing command runs <b>Expect</b> while tracing the first 4 levels of calls, but none below that.

                 expect -c "strace 4" script.exp


             The  <b>-info</b>  flag  causes  strace  to return a description of the most recent non-info arguments
             given.

       <b>stty</b> <u>args</u>
             changes terminal modes similarly to the external stty command.

             By default, the controlling terminal is accessed.  Other terminals can be accessed by appending
             "&lt;  /dev/tty..."  to the command.  (Note that the arguments should not be grouped into a single
             argument.)

             Requests for status return it as the result of the command.  If no status is requested and  the
             controlling  terminal  is  accessed,  the  previous  status  of the raw and echo attributes are
             returned in a form which can later be used by the command.

             For example, the arguments <b>raw</b> or <b>-cooked</b> put the terminal into raw mode.  The  arguments  <b>-raw</b>
             or  <b>cooked</b>  put  the  terminal into cooked mode.  The arguments <b>echo</b> and <b>-echo</b> put the terminal
             into echo and noecho mode respectively.

             The following example illustrates how to temporarily disable echoing.  This could  be  used  in
             otherwise-automatic scripts to avoid embedding passwords in them.  (See more discussion on this
             under EXPECT HINTS below.)

                 stty -echo
                 send_user "Password: "
                 expect_user -re "(.*)\n"
                 set password $expect_out(1,string)
                 stty echo


       <b>system</b> <u>args</u>
             gives <u>args</u> to <a href="sh.1.html#//apple_ref/doc/man/1/sh">sh(1)</a> as input, just as if it had been  typed  as  a  command  from  a  terminal.
             <b>Expect</b>  waits  until  the  shell terminates.  The return status from sh is handled the same way
             that <b>exec</b> handles its return status.

             In contrast to <b>exec</b> which redirects stdin and stdout to the script, <b>system</b>  performs  no  redi-
             rection (other than that indicated by the string itself).  Thus, it is possible to use programs
             which must talk directly to /dev/tty.  For the same reason,  the  results  of  <b>system</b>  are  not
             recorded in the log.

       <b>timestamp</b> <u>[args]</u>
             returns a timestamp.  With no arguments, the number of seconds since the epoch is returned.

             The <b>-format</b> flag introduces a string which is returned but with substitutions made according to
             the POSIX rules for strftime.  For example %a is replaced by an abbreviated weekday name (i.e.,
             Sat).  Others are:
                 %a      abbreviated weekday name
                 %A      full weekday name
                 %b      abbreviated month name
                 %B      full month name
                 %c      date-time as in: Wed Oct  6 11:45:56 1993
                 %d      day of the month (01-31)
                 %H      hour (00-23)
                 %I      hour (01-12)
                 %j      day (001-366)
                 %m      month (01-12)
                 %M      minute (00-59)
                 %p      am or pm
                 %S      second (00-61)
                 %u      day (1-7, Monday is first day of week)
                 %U      week (00-53, first Sunday is first day of week one)
                 %V      week (01-53, ISO 8601 style)
                 %w      day (0-6)
                 %W      week (00-53, first Monday is first day of week one)
                 %x      date-time as in: Wed Oct  6 1993
                 %X      time as in: 23:59:59
                 %y      year (00-99)
                 %Y      year as in: 1993
                 %Z      timezone (or nothing if not determinable)
                 %%      a bare percent sign

             Other % specifications are undefined.  Other characters will be passed through untouched.  Only
             the C locale is supported.

             The <b>-seconds</b> flag introduces a number of seconds since the epoch to be used as  a  source  from
             which to format.  Otherwise, the current time is used.

             The  <b>-gmt</b>  flag forces timestamp output to use the GMT timezone.  With no flag, the local time-<font color="#ffffff" class="whiteout">zone&nbsp;timezone</font>
             zone is used.

       <b>trap</b> <u>[[command]</u> <u>signals]</u>
             causes the given <u>command</u> to be executed upon future receipt of any of the given  signals.   The
             command  is executed in the global scope.  If <u>command</u> is absent, the signal action is returned.
             If <u>command</u> is the string SIG_IGN, the signals are ignored.  If <u>command</u> is the  string  SIG_DFL,
             the  signals  are result to the system default.  <u>signals</u> is either a single signal or a list of
             signals.  Signals may be specified numerically or symbolically as  per  <a href="../man3/signal.3.html#//apple_ref/doc/man/3/signal">signal(3)</a>.   The  "SIG"
             prefix may be omitted.

             With no arguments (or the argument -number), <b>trap</b> returns the signal number of the trap command
             currently being executed.

             The <b>-code</b> flag uses the return code of the command in place of whatever code Tcl was  about  to
             return when the command originally started running.

             The  <b>-interp</b>  flag  causes the command to be evaluated using the interpreter active at the time
             the command started running rather than when the trap was declared.

             The <b>-name</b> flag causes the <b>trap</b> command to return the signal name of the trap command  currently
             being executed.

             The <b>-max</b> flag causes the <b>trap</b> command to return the largest signal number that can be set.

             For  example,  the  command "trap {send_user "Ouch!"} SIGINT" will print "Ouch!"  each time the
             user presses ^C.

             By default, SIGINT (which can usually be generated by pressing ^C) and SIGTERM cause Expect  to
             exit.  This is due to the following trap, created by default when Expect starts.

                 trap exit {SIGINT SIGTERM}

             If  you  use  the  -D  flag to start the debugger, SIGINT is redefined to start the interactive
             debugger.  This is due to the following trap:

                 trap {exp_debug 1} SIGINT

             The debugger trap can be changed by setting the environment variable EXPECT_DEBUG_INIT to a new
             trap command.

             You  can,  of  course,  override both of these just by adding trap commands to your script.  In
             particular, if you have your own "trap exit SIGINT", this  will  override  the  debugger  trap.
             This is useful if you want to prevent users from getting to the debugger at all.

             If  you  want  to define your own trap on SIGINT but still trap to the debugger when it is run-<font color="#ffffff" class="whiteout">ning,&nbsp;running,</font>
             ning, use:

                 if {![exp_debug]} {trap mystuff SIGINT}

             Alternatively, you can trap to the debugger using some other signal.

             <b>trap</b> will not let you override the action for SIGALRM as this is  used  internally  to  <b>Expect</b>.
             The  disconnect command sets SIGALRM to SIG_IGN (ignore).  You can reenable this as long as you
             disable it during subsequent spawn commands.

             See <a href="../man3/signal.3.html#//apple_ref/doc/man/3/signal">signal(3)</a> for more info.

       <b>wait</b> <u>[args]</u>
             delays until a spawned process (or the current process if none is named) terminates.

             <b>wait</b> normally returns a list of four integers.  The first integer is the  pid  of  the  process
             that  was waited upon.  The second integer is the corresponding spawn id.  The third integer is
             -1 if an operating system error occurred, or 0 otherwise.  If the  third  integer  was  0,  the
             fourth integer is the status returned by the spawned process.  If the third integer was -1, the
             fourth integer is the value of errno set by the operating system.  The global  variable  error-<font color="#ffffff" class="whiteout">Code&nbsp;errorCode</font>
             Code is also set.

             Additional  elements  may  appear  at the end of the return value from <b>wait</b>.  An optional fifth
             element identifies a class of information.  Currently, the only possible value for this element
             is  CHILDKILLED  in which case the next two values are the C-style signal name and a short tex-<font color="#ffffff" class="whiteout">tual&nbsp;textual</font>
             tual description.

             The <b>-i</b> flag declares the process to wait corresponding to the named spawn_id (NOT  the  process
             id).   Inside  a  SIGCHLD  handler, it is possible to wait for any spawned process by using the
             spawn id -1.

             The <b>-nowait</b> flag causes the wait to return immediately with  the  indication  of  a  successful
             wait.   When the process exits (later), it will automatically disappear without the need for an
             explicit wait.

             The <b>wait</b> command may also be used wait for a  forked  process  using  the  arguments  "-i  -1".
             Unlike  its  use with spawned processes, this command can be executed at any time.  There is no
             control over which process is reaped.  However, the return value can be checked for the process
             id.


<b>LIBRARIES</b>
       Expect automatically knows about two built-in libraries for Expect scripts.  These are defined by the
       directories named in the variables exp_library and exp_exec_library.  Both are meant to contain util-<font color="#ffffff" class="whiteout">ity&nbsp;utility</font>
       ity files that can be used by other scripts.

       exp_library  contains  architecture-independent files.  exp_exec_library contains architecture-depen-<font color="#ffffff" class="whiteout">dent&nbsp;architecture-dependent</font>
       dent files.  Depending on your system, both directories may be totally empty.  The existence  of  the
       file $exp_exec_library/cat-buffers describes whether your /bin/cat buffers by default.

<b>PRETTY-PRINTING</b>
       A  vgrind definition is available for pretty-printing <b>Expect</b> scripts.  Assuming the vgrind definition
       supplied with the <b>Expect</b> distribution is correctly installed, you can use it as:

           vgrind -lexpect file


<b>EXAMPLES</b>
       It many not be apparent how to put everything together that the man page describes.  I encourage  you
       to  read  and try out the examples in the example directory of the <b>Expect</b> distribution.  Some of them
       are real programs.  Others are simply illustrative of certain techniques, and of course, a couple are
       just quick hacks.  The INSTALL file has a quick overview of these programs.

       The <b>Expect</b> papers (see SEE ALSO) are also useful.  While some papers use syntax corresponding to ear-<font color="#ffffff" class="whiteout">lier&nbsp;earlier</font>
       lier versions of Expect, the accompanying rationales are still valid and go into a  lot  more  detail
       than this man page.

<b>CAVEATS</b>
       Extensions  may  collide  with  Expect's  command  names.   For example, <b>send</b> is defined by Tk for an
       entirely different purpose.  For this reason, most of the  <b>Expect</b>  commands  are  also  available  as
       "exp_XXXX".  Commands and variables beginning with "exp", "inter", "spawn", and "timeout" do not have
       aliases.  Use the extended command names if you need this compatibility between environments.

       <b>Expect</b> takes a rather liberal view of scoping.  In particular, variables read by commands specific to
       the  <b>Expect</b> program will be sought first from the local scope, and if not found, in the global scope.
       For example, this obviates the need to place "global timeout" in every procedure you write that  uses
       <b>expect</b>.   On  the other hand, variables written are always in the local scope (unless a "global" com-<font color="#ffffff" class="whiteout">mand&nbsp;command</font>
       mand has been issued).  The most common problem this causes is when spawn is executed in a procedure.
       Outside the procedure, <u>spawn</u><b>_</b><u>id</u> no longer exists, so the spawned process is no longer accessible sim-<font color="#ffffff" class="whiteout">ply&nbsp;simply</font>
       ply because of scoping.  Add a "global spawn_id" to such a procedure.

       If you cannot enable the multispawning capability (i.e., your system  supports  neither  select  (BSD
       *.*),  poll  (SVR&gt;2), nor something equivalent), <b>Expect</b> will only be able to control a single process
       at a time.  In this case, do not attempt to set <u>spawn</u><b>_</b><u>id</u>, nor should you execute processes  via  exec
       while  a  spawned process is running.  Furthermore, you will not be able to <b>expect</b> from multiple pro-<font color="#ffffff" class="whiteout">cesses&nbsp;processes</font>
       cesses (including the user as one) at the same time.

       Terminal parameters can have a big effect on scripts.  For example, if a script is  written  to  look
       for  echoing, it will misbehave if echoing is turned off.  For this reason, Expect forces sane termi-<font color="#ffffff" class="whiteout">nal&nbsp;terminal</font>
       nal parameters by default.  Unfortunately, this can make things unpleasant for other programs.  As an
       example,  the  emacs  shell  wants  to  change  the "usual" mappings: newlines get mapped to newlines
       instead of carriage-return newlines, and echoing is disabled.  This allows one to use emacs  to  edit
       the input line.  Unfortunately, Expect cannot possibly guess this.

       You  can  request  that  Expect not override its default setting of terminal parameters, but you must
       then be very careful when writing scripts for such environments.  In the case of emacs, avoid depend-<font color="#ffffff" class="whiteout">ing&nbsp;depending</font>
       ing upon things like echoing and end-of-line mappings.

       The commands that accepted arguments braced into a single list (the <b>expect</b> variants and <b>interact</b>) use
       a heuristic to decide if the list is actually one argument or many.  The heuristic can fail  only  in
       the  case  when  the  list actually does represent a single argument which has multiple embedded \n's
       with non-whitespace characters between them.  This seems sufficiently improbable, however  the  argu-<font color="#ffffff" class="whiteout">ment&nbsp;argument</font>
       ment  "-nobrace"  can  be  used  to force a single argument to be handled as a single argument.  This
       could conceivably be used with machine-generated Expect code.   Similarly,  -brace  forces  a  single
       argument to be handle as multiple patterns/actions.


<b>BUGS</b>
       It was really tempting to name the program "sex" (for either "Smart EXec" or "Send-EXpect"), but good
       sense (or perhaps just Puritanism) prevailed.

       On some systems, when a shell is spawned, it complains about not being able to  access  the  tty  but
       runs  anyway.   This  means  your  system has a mechanism for gaining the controlling tty that <b>Expect</b>
       doesn't know about.  Please find out what it is, and send this information back to me.

       Ultrix 4.1 (at least the latest versions around here) considers  timeouts  of  above  1000000  to  be
       equivalent to 0.

       Digital UNIX 4.0A (and probably other versions) refuses to allocate ptys if you define a SIGCHLD han-<font color="#ffffff" class="whiteout">dler.&nbsp;handler.</font>
       dler.  See grantpt page for more info.

       IRIX 6.0 does not handle pty permissions correctly so that if Expect attempts to allocate a pty  pre-<font color="#ffffff" class="whiteout">viously&nbsp;previously</font>
       viously used by someone else, it fails.  Upgrade to IRIX 6.1.

       Telnet  (verified only under SunOS 4.1.2) hangs if TERM is not set.  This is a problem under cron, at
       and in cgi scripts, which do not define TERM.  Thus, you must set it explicitly -  to  what  type  is
       usually  irrelevant.   It  just has to be set to something!  The following probably suffices for most
       cases.

           set env(TERM) vt100


       Tip (verified only under BSDI BSD/OS 3.1 i386) hangs if SHELL and HOME are not set.  This is a  prob-<font color="#ffffff" class="whiteout">lem&nbsp;problem</font>
       lem  under  cron,  at and in cgi scripts, which do not define these environment variables.  Thus, you
       must set them explicitly - to what type is usually irrelevant.  It just has to be set  to  something!
       The following probably suffices for most cases.

           set env(SHELL) /bin/sh
           set env(HOME) /usr/local/bin



       Some  implementations  of ptys are designed so that the kernel throws away any unread output after 10
       to 15 seconds (actual number is implementation-dependent) after  the  process  has  closed  the  file
       descriptor.  Thus <b>Expect</b> programs such as

           spawn date
           sleep 20
           expect

       will  fail.   To avoid this, invoke non-interactive programs with <b>exec</b> rather than <b>spawn</b>.  While such
       situations are conceivable, in practice I have never encountered a situation in which the final  out-<font color="#ffffff" class="whiteout">put&nbsp;output</font>
       put of a truly interactive program would be lost due to this behavior.

       On  the  other  hand, Cray UNICOS ptys throw away any unread output immediately after the process has
       closed the file descriptor.  I have reported this to Cray and they are working on a fix.

       Sometimes a delay is required between a prompt and a response, such as when a tty interface is chang-<font color="#ffffff" class="whiteout">ing&nbsp;changing</font>
       ing  UART  settings  or  matching  baud  rates  by looking for start/stop bits.  Usually, all this is
       require is to sleep for a second or two.  A more robust technique is to retry until the  hardware  is
       ready to receive input.  The following example uses both strategies:

           send "speed 9600\r";
           sleep 1
           expect {
               timeout {send "\r"; exp_continue}
               $prompt
           }


       trap  -code will not work with any command that sits in Tcl's event loop, such as sleep.  The problem
       is that in the event loop, Tcl discards the return codes from async event handlers.  A workaround  is
       to set a flag in the trap code.  Then check the flag immediately after the command (i.e., sleep).


<b>EXPECT</b> <b>HINTS</b>
       There  are  a  couple  of  things  about  <b>Expect</b> that may be non-intuitive.  This section attempts to
       address some of these things with a couple of suggestions.

       A common expect problem is how to recognize shell prompts.  Since these are customized differently by
       differently  people and different shells, portably automating rlogin can be difficult without knowing
       the prompt.  A reasonable convention is to have users store a  regular  expression  describing  their
       prompt  (in particular, the end of it) in the environment variable EXPECT_PROMPT.  Code like the fol-<font color="#ffffff" class="whiteout">lowing&nbsp;following</font>
       lowing can be used.  If EXPECT_PROMPT doesn't exist, the code still has a good chance of  functioning
       correctly.

           set prompt "(%|#|\\$) $"          ;# default prompt
           catch {set prompt $env(EXPECT_PROMPT)}

           expect -re $prompt

       I  encourage  you  to write <b>expect</b> patterns that include the end of whatever you expect to see.  This
       avoids the possibility of answering a question before seeing the entire thing.   In  addition,  while
       you  may  well  be  able  to answer questions before seeing them entirely, if you answer early,  your
       answer may appear echoed back in the middle of the question.  In other words, the resulting  dialogue
       will be correct but look scrambled.

       Most  prompts  include  a  space character at the end.  For example, the prompt from ftp is 'f', 't',
       'p', '&gt;' and &lt;blank&gt;.  To match this prompt, you must account for each of these characters.  It is  a
       common mistake not to include the blank.  Put the blank in explicitly.

       If  you  use  a pattern of the form X*, the * will match all the output received from the end of X to
       the last thing received.  This sounds intuitive but can be  somewhat  confusing  because  the  phrase
       "last  thing  received"  can  vary depending upon the speed of the computer and the processing of I/O
       both by the kernel and the device driver.

       In particular, humans tend to see program output arriving in huge chunks (atomically) when in reality
       most  programs produce output one line at a time.  Assuming this is the case, the * in the pattern of
       the previous paragraph may only match the end of the current line even though there seems to be more,
       because at the time of the match that was all the output that had been received.

       <b>expect</b>  has no way of knowing that further output is coming unless your pattern specifically accounts
       for it.

       Even depending on line-oriented buffering is unwise.  Not only do programs rarely make promises about
       the  type  of buffering they do, but system indigestion can break output lines up so that lines break
       at seemingly random places.  Thus, if you can express the last few characters of a prompt when  writ-<font color="#ffffff" class="whiteout">ing&nbsp;writing</font>
       ing patterns, it is wise to do so.

       If you are waiting for a pattern in the last output of a program and the program emits something else
       instead, you will not be able to detect that with the <b>timeout</b> keyword.  The  reason  is  that  <b>expect</b>
       will  not timeout - instead it will get an <b>eof</b> indication.  Use that instead.  Even better, use both.
       That way if that line is ever moved around, you won't have to edit the line itself.

       Newlines are usually converted to carriage return, linefeed sequences when  output  by  the  terminal
       driver.    Thus,  if  you  want  a  pattern  that  explicitly  matches  the  two  lines,  from,  say,
       printf("foo\nbar"), you should use the pattern "foo\r\nbar".

       A similar translation occurs when reading from the user, via <b>expect_user</b>.  In  this  case,  when  you
       press return, it will be translated to a newline.  If <b>Expect</b> then passes that to a program which sets
       its terminal to raw mode (like telnet), there is going to be a problem, as the program expects a true
       return.   (Some programs are actually forgiving in that they will automatically translate newlines to
       returns, but most don't.)  Unfortunately, there is no way to find out that a program put its terminal
       into raw mode.

       Rather  than manually replacing newlines with returns, the solution is to use the command "stty raw",
       which will stop the translation.  Note, however, that this means that you  will  no  longer  get  the
       cooked line-editing features.

       <b>interact</b> implicitly sets your terminal to raw mode so this problem will not arise then.

       It  is often useful to store passwords (or other private information) in <b>Expect</b> scripts.  This is not
       recommended since anything that is stored on a computer is susceptible to being accessed  by  anyone.
       Thus,  interactively prompting for passwords from a script is a smarter idea than embedding them lit-<font color="#ffffff" class="whiteout">erally.&nbsp;literally.</font>
       erally.  Nonetheless, sometimes such embedding is the only possibility.

       Unfortunately, the UNIX file system has no direct way of creating scripts which  are  executable  but
       unreadable.  Systems which support setgid shell scripts may indirectly simulate this as follows:

       Create  the  <b>Expect</b>  script  (that  contains  the secret data) as usual.  Make its permissions be 750
       (-rwxr-x---) and owned by a trusted group, i.e., a group which is allowed to read it.  If  necessary,
       create  a  new  group  for  this  purpose.   Next,  create  a  /bin/sh  script  with permissions 2751
       (-rwxr-s--x) owned by the same group as before.

       The result is a script which may be executed (and read) by anyone.  When invoked, it runs the  <b>Expect</b>
       script.

<b>SEE</b> <b>ALSO</b>
       <!-- a --><b>Tcl</b>(3)<!-- /a -->, <!-- a --><b>libexpect</b>(3)<!-- /a -->
       <u>"Exploring</u>  <u>Expect:</u>  <u>A</u>  <u>Tcl-Based</u> <u>Toolkit</u> <u>for</u> <u>Automating</u> <u>Interactive</u> <u>Programs"</u> by Don Libes, pp. 602,
       ISBN 1-56592-090-2, O'Reilly and Associates, 1995.
       <u>"expect:</u> <u>Curing</u> <u>Those</u> <u>Uncontrollable</u> <u>Fits</u> <u>of</u> <u>Interactivity"</u> by Don Libes, Proceedings of  the  Summer
       1990 USENIX Conference, Anaheim, California, June 11-15, 1990.
       <u>"Using</u>  <b>expect</b>  to Automate System Administration Tasks" by Don Libes, Proceedings of the 1990 USENIX
       Large Installation Systems Administration Conference,  Colorado  Springs,  Colorado,  October  17-19,
       1990.
       <u>"Tcl:</u>  <u>An</u> <u>Embeddable</u> <u>Command</u> <u>Language"</u> by John Ousterhout, Proceedings of the Winter 1990 USENIX Con-<font color="#ffffff" class="whiteout">ference,&nbsp;Conference,</font>
       ference, Washington, D.C., January 22-26, 1990.
       <u>"expect:</u> <u>Scripts</u> <u>for</u> <u>Controlling</u> <u>Interactive</u> <u>Programs"</u> by Don Libes, Computing Systems, Vol.  4,  No.
       2, University of California Press Journals, November 1991.
       <u>"Regression</u>  <u>Testing</u>  <u>and</u> <u>Conformance</u> <u>Testing</u> <u>Interactive</u> <u>Programs",</u> by Don Libes, Proceedings of the
       Summer 1992 USENIX Conference, pp. 135-144, San Antonio, TX, June 12-15, 1992.
       <u>"Kibitz</u> <u>-</u> <u>Connecting</u> <u>Multiple</u> <u>Interactive</u> <u>Programs</u> <u>Together",</u> by Don Libes,  Software  -  Practice  &amp;
       Experience, John Wiley &amp; Sons, West Sussex, England, Vol. 23, No. 5, May, 1993.
       <u>"A</u>  <u>Debugger</u>  <u>for</u> <u>Tcl</u> <u>Applications",</u> by Don Libes, Proceedings of the 1993 Tcl/Tk Workshop, Berkeley,
       CA, June 10-11, 1993.

<b>AUTHOR</b>
       Don Libes, National Institute of Standards and Technology

<b>ACKNOWLEDGMENTS</b>
       Thanks to John Ousterhout for Tcl, and Scott Paisley for  inspiration.   Thanks  to  Rob  Savoye  for
       Expect's autoconfiguration code.

       The  HISTORY  file documents much of the evolution of <b>expect</b>.  It makes interesting reading and might
       give you further insight to this software.  Thanks to the people mentioned in  it  who  sent  me  bug
       fixes and gave other assistance.

       Design  and  implementation of <b>Expect</b> was paid for in part by the U.S. government and is therefore in
       the public domain.  However the author and NIST would like credit if this program  and  documentation
       or portions of them are used.



                                              29 December 1994                                     EXPECT(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/expect.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/expect.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/expect.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
