<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Drawing Guide: Graphics Contexts</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Graphics Contexts"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40003290-CH203" title="Graphics Contexts"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290-CH201-SW1">Cocoa Drawing Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../DrawingEnviron/DrawingEnviron.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Transforms/Transforms.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40003290-CH203-BCIJFBJJ" title="Graphics Contexts"></a><h1>Graphics Contexts</h1><p>Graphics contexts are a fundamental part of the drawing infrastructure in Cocoa applications. As the name suggests, a graphics context provides the context for subsequent drawing operations. It identifies the current drawing destination (screen, printer, file, and so on), the coordinate system and boundaries for the underlying canvas, and any graphics attributes associated with the destination. </p>
<p>For most of the drawing you do in Cocoa, you never need to create a graphics context yourself. The normal drawing cycle in Cocoa automatically creates and configures a graphics context for you to use. For some advanced drawing, however, you may need to create your own graphics context prior to drawing.</p>
<p>In a Cocoa application, graphics contexts for nearly all types of canvas are represented by the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_268"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSGraphicsContext" target="_top">NSGraphicsContext</a></code> class. You use graphics context objects to manipulate graphics attributes and to get information about the current drawing environment. </p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH203-SW3" title="Note"></a><p><strong>Note:</strong>&nbsp;For <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_269"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_270"></a>OpenGL drawing, you use the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_271"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSOpenGLContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSOpenGLContext" target="_top">NSOpenGLContext</a></code> class instead of <code>NSGraphicsContext</code> for the graphics context object. OpenGL drawing, and use of the <code>NSOpenGLContext</code> class, are covered in <span class="content_text"><a href="../QuartzOpenGL/QuartzOpenGL.html#//apple_ref/doc/uid/TP40003290-CH211-BAAECJDJ">“Using OpenGL in Your Application.”</a></span> </p></div>
<p>This chapter provides an overview of Cocoa graphics contexts and how you use them in your application. It includes information on how to create custom graphics contexts and when it might be appropriate to do so. </p>


<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-SW4">Graphics Context Basics</a>
				
			<br/>
			
        
			
			
				<a href="GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-SW9">Modifying the Current Graphics State</a>
				
			<br/>
			
        
			
			
				<a href="GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-BCIGDIAA">Creating Graphics Contexts</a>
				
			<br/>
			
        
			
			
				<a href="GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-SW11">Threading and Graphics Contexts</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40003290-CH203-SW4" title="Graphics Context Basics"></a><h2>Graphics Context Basics</h2>
<p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_272"></a>The primary job of any <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_273"></a>graphics context object is to maintain information about the current state of the drawing environment. In Quartz, the graphics context object is associated with a window, bitmap, PDF file, or other output device and maintains information for that device. The same is true for a Cocoa graphics context, but because Cocoa drawing is view-based, some additional changes are made to the drawing environment before your view’s <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/drawRect:" target="_top">drawRect:</a></code> method is called. </p>
<p>By the time your view’s <code>drawRect:</code> method is called, Cocoa has made sure that any drawing calls you make stay within the confines of your view. It saves the graphics state to simplify the process of undoing its changes later. It adds an appropriate transform to the current transformation matrix to place the drawing origin at the origin of your view. It also sets the clipping region to your view's visible boundaries, preventing any rendered content from straying into other views. Your view is effectively the star of the show, at least until another view’s <code>drawRect:</code> method is called. </p>
<p>While the current context is focused on your view, you can draw paths, images, text, or any other content you want. You can also change the attributes of the current drawing environment to achieve the appearance you want for your content. Eventually, the content you draw is sent to the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_274"></a>Quartz Compositor, where it is combined with the content from other views in the window and flushed to the screen or output device. </p>
<p>After your <code>drawRect:</code> method returns, Cocoa goes through the process of resetting the drawing environment for the next view. It reverts any changes you made to the drawing environment and sets up the coordinate transform and clipping region for the next view, giving it its own pristine environment in which to work. This process then repeats itself during each update cycle in your application.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH203-BCIGCBBJ" title="The Current Context"></a><h3>The Current Context</h3>
<p>Each thread in a Cocoa application has its own <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_275"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_276"></a>graphics context object for a given window. You can access this object from your code using the  <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_277"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/clm/NSGraphicsContext/currentContext" target="_top">currentContext</a></code> method of <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSGraphicsContext" target="_top">NSGraphicsContext</a></code>, as shown in the following example:</p>
<div class="codesample"><table><tr><td scope="row"><pre>NSGraphicsContext* aContext = [NSGraphicsContext currentContext];<span></span></pre></td></tr></table></div><p>The <code>currentContext</code> method always returns the Cocoa graphics context object that is appropriate for the current drawing environment. This object keeps track of the current graphics state, lets you save and restore graphics state information, and lets you modify many graphics state attributes. The changes you make to the graphics state affect all subsequent drawing calls. If you change an attribute more than once, only the most recent setting is used. </p>
<p>To save the current <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_278"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_279"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_280"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_281"></a>graphics state, you use the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_282"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSGraphicsContext/saveGraphicsState" target="_top">saveGraphicsState</a></code> method of <code>NSGraphicsContext</code>. This method essentially pushes a copy of the current state onto a stack, leaving you free to make changes to the current state. When you want to revert back to the previous state, you simply call the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_283"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSGraphicsContext/restoreGraphicsState" target="_top">restoreGraphicsState</a></code> method to pop the current graphics state (including all changes since the last save) off of the stack and restore the previous state. </p>
<p>If you plan to change the current graphics state significantly, it is a good idea to save the current state before making your changes. Modifying one or two attributes usually may not merit saving the graphics state, since you can reset or change those individual attributes easily. However, if you are changing more than one or two attributes, it is usually easier to save and restore the entire graphics state. You can call the <code>saveGraphicsState</code> method as often as needed in your code to save snapshots of the current graphics state, but you must be sure to balance each call with a matching call to <code>restoreGraphicsState</code>. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH203-SW5" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>saveGraphicsState</code> and <code>restoreGraphicsState</code> methods are available both as class methods and as instance methods. The class method versions simply save and restore the graphics state of the current context. The instance methods let you save the state of a specific context object, although in most cases this should be the current context.</p></div>
<p>The following example shows a simple <code>drawRect:</code> method that iterates over an array of developer-defined objects, each of which is drawn with a different set of attributes. The graphics state is saved and restored during each loop iteration, ensuring that each object starts from the same graphics state. </p>
<div class="codesample"><table><tr><td scope="row"><pre>- (void)drawRect:(NSRect)rect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSGraphicsContext* theContext = [NSGraphicsContext currentContext];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    int i;<span></span></pre></td></tr><tr><td scope="row"><pre>    int numObjects = [myObjectArray count];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Iterate over an array of objects<span></span></pre></td></tr><tr><td scope="row"><pre>    // Set the attributes for each before drawing<span></span></pre></td></tr><tr><td scope="row"><pre>    for (i = 0; i &lt; numObjects; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [theContext saveGraphicsState];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Set the drawing attributes<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Draw the object<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        [theContext restoreGraphicsState];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_5" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;

When saving and restoring the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_284"></a>graphics state, you must balance all calls to <code>saveGraphicsState</code> with a corresponding call to <code>restoreGraphicsState</code>. Failure to do so can result in unexpected changes to the appearance of any windows that use that view. </p><p></p><div class="clear"></div></div>
<a name="//apple_ref/doc/uid/TP40003290-CH203-BCIHGDAH" title="Graphics State Information"></a><h3>Graphics State Information</h3>
<p>Each Cocoa graphics context object maintains information about the current state of the drawing environment. This information ranges from the global rendering settings to the attributes used to render the current path and is the same state information saved by Quartz. Whenever you save the current graphics state, you save a copy of the settings listed in <span class="content_text">Table 2-1</span>. </p><a name="//apple_ref/doc/uid/TP40003290-CH203-BCIJDJBB" title="Table 2-1Graphics state information"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>Graphics state information</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Attribute</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th>
</tr>


<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_285"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_286"></a>Current transformation matrix (<a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_287"></a>CTM)</p></td>
<td ><p>Maps points in the view’s coordinate system to points in the destination device's coordinate system. Cocoa modifies the CTM before calling your view’s <code>drawRect:</code> method. You can use an <code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAffineTransform" target="_top">NSAffineTransform</a></code> object to modify the CTM further to change the drawing origin, scale the canvas, or rotate the coordinate system. For more information, see <span class="content_text"><a href="../Transforms/Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCIDJJBI">“Coordinate Systems and Transforms.”</a></span> </p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_288"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_289"></a>Clipping area</p></td>
<td ><p>Specifies the area of the canvas that can be painted by drawing calls. Cocoa modifies the clipping region to the visible area of your view before calling its <code>drawRect:</code> method. You can use an <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> object to further clip the visible area. For more information, see <span class="content_text"><a href="GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-BCIIADBC">“Setting the Clipping Region.”</a></span></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_290"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_291"></a>Line width</p></td>
<td ><p>Specifies the width of paths. The default line width is <code>1.0</code> but you can modify this value using an <code>NSBezierPath</code> object. For more information, see <span class="content_text"><a href="../Paths/Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCECBJC">“Line Width.”</a></span></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_292"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_293"></a>Line join style</p></td>
<td ><p>Specifies how two connected lines are joined together. The default join style is <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/c/econst/NSMiterLineJoinStyle" target="_top">NSMiterLineJoinStyle</a></code> but you can modify this value using an <code>NSBezierPath</code> object. For more information, see <span class="content_text"><a href="../Paths/Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCFDEIE">“Line Join Styles.”</a></span></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_294"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_295"></a>Line cap style</p></td>
<td ><p>Specifies the appearance of an open end point on a path. The default line cap style is <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/c/econst/NSButtLineCapStyle" target="_top">NSButtLineCapStyle</a></code> but you can modify this value using an <code>NSBezierPath</code> object. For more information, see <span class="content_text"><a href="../Paths/Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCEIDJI">“Line Cap Styles.”</a></span></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_296"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_297"></a>Line dash style</p></td>
<td ><p>Defines a broken pattern for lines, including the initial phase for the style. There is no default dash style, resulting in solid lines. You modify dash styles for a path using an <code>NSBezierPath</code> object. For more information, see <span class="content_text"><a href="GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-BCIEBIIB">“Setting Path Attributes.”</a></span></p></td>
</tr>
<tr>
<td  scope="row"><p>Line <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_298"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_299"></a>miter limit</p></td>
<td ><p>Determines when lines should be joined with a bevel instead of a miter. Applies only when the line join style is set to <code>NSMiterLineJoinStyle</code>. The length of the miter is divided by the line width. If the resulting value is greater than the miter limit, a bevel is used. The default value is <code>10.0</code> but you can modify this value using an <code>NSBezierPath</code> object. For more information, see <span class="content_text"><a href="../Paths/Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCFHEIF">“Miter Limits.”</a></span></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_300"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_301"></a>Flatness value</p></td>
<td ><p>Specifies the accuracy with which curves are rendered. (It is also the maximum error tolerance, measured in pixels.) Smaller numbers result in smoother curves at the expense of more calculations. The interpretation of this value may vary slightly on different rendering devices. The default value is <code>0.6</code> but you can modify this value using an <code>NSBezierPath</code> object. For more information, see <span class="content_text"><a href="../Paths/Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCBBHIG">“Line Flatness.”</a></span></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_302"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_303"></a>Stroke color</p></td>
<td ><p>Specifies the color used for rendering paths. This color applies only to the path line itself, not the area the path encompasses. You can specify colors using any of the system-supported color spaces. This value includes alpha information. Color information is managed by the <code><a href="../../../Reference/ApplicationKit/Classes/NSColor_Class/Reference/Reference.html#//apple_ref/occ/cl/NSColor" target="_top">NSColor</a></code> class. For more information, see <span class="content_text"><a href="GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-BCIDFCGD">“Setting Colors and Patterns.”</a></span></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_304"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_305"></a>Fill color</p></td>
<td ><p>Specifies the color used to fill the area enclosed by a path. You can specify colors using any of the system-supported color spaces. This value includes alpha information. Color information is managed by the <code>NSColor</code> class. For more information, see <span class="content_text"><a href="GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-BCIDFCGD">“Setting Colors and Patterns.”</a></span></p></td>
</tr><tr><td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_306"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_307"></a>Shadow</p></td><td ><p>Specifies the shadow attributes to apply to rendered content. You set shadows using the <code><a href="../../../Reference/ApplicationKit/Classes/NSShadow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSShadow" target="_top">NSShadow</a></code> class. For more information, see <span class="content_text"><a href="../AdvancedDrawing/AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-SW1">“Adding Shadows to Drawn Paths.”</a></span> </p></td></tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_308"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_309"></a>Rendering intent</p></td>
<td ><p>Specifies the technique used to map in-gamut colors to the gamut of the current color space. Cocoa does not support setting this attribute directly. Instead, you must use Quartz. For more information, see <span class="content_text"><a href="../Color/Color.html#//apple_ref/doc/uid/TP40003290-CH205-BAJEBCFF">“Mapping Physical Colors to a Color Space.”</a></span> </p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_310"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_311"></a>Font name</p></td>
<td ><p>Specifies the font to use when drawing text. You modify font information using the <code><a href="../../../Reference/ApplicationKit/Classes/NSFont_Class/Reference/Reference.html#//apple_ref/occ/cl/NSFont" target="_top">NSFont</a></code> class. For more information on drawing text, see <span class="content_text"><a href="../Text/Text.html#//apple_ref/doc/uid/TP40003290-CH209-BCIHBCAG">“Text Attributes.”</a></span> </p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_312"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_313"></a>Font size</p></td>
<td ><p>Specifies the font size to use when drawing text. You modify font information using the <code>NSFont</code> class. For more information on drawing text, see <span class="content_text"><a href="../Text/Text.html#//apple_ref/doc/uid/TP40003290-CH209-BCIHBCAG">“Text Attributes.”</a></span> </p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_314"></a>Font <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_315"></a>character spacing</p></td>
<td ><p>Specifies the character spacing to use when drawing text. (This attribute is supported only indirectly by Cocoa.) For more information on drawing text, see <span class="content_text"><a href="../Text/Text.html#//apple_ref/doc/uid/TP40003290-CH209-BCIHBCAG">“Text Attributes.”</a></span></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_316"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_317"></a>Text drawing mode</p></td>
<td ><p>Specifies how to render the text. (This attribute is supported only indirectly by Cocoa.) For more information on drawing text, see <span class="content_text"><a href="../Text/Text.html#//apple_ref/doc/uid/TP40003290-CH209-BCIHBCAG">“Text Attributes.”</a></span></p></td>
</tr><tr><td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_318"></a>Image <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_319"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_320"></a>interpolation quality</p></td><td ><p>Specifies the process used to interpolate images during rendering. You use the <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSGraphicsContext" target="_top">NSGraphicsContext</a></code> class to change this setting. For more information, see <span class="content_text"><a href="../Images/Images.html#//apple_ref/doc/uid/TP40003290-CH208-SW2">“Image Size and Resolution”</a></span> </p></td></tr><tr><td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_321"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_322"></a>Compositing operation</p></td><td ><p>Specifies the process used to composite source and destination material together. (The compositing operations supported by Cocoa are related to the Quartz blend modes but differ in their usage and behavior.) You use the <code>NSGraphicsContext</code> class to set the default value for this setting. Some rendering methods and functions may let you specify a different option. For more information, see <span class="content_text"><a href="GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-BCIDBEEB">“Setting Compositing Options.”</a></span></p></td></tr>
<tr>
<td  scope="row"><p>Global <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_323"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_324"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_325"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_326"></a>alpha</p></td>
<td ><p>Specifies a global alpha (transparency) value to apply in addition to the alpha value for a given color. Cocoa does not support this attribute directly. If you want to set it, you must use the <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextSetAlpha" target="_top">CGContextSetAlpha</a></code> function in Quartz.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_327"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_328"></a>Anti-aliasing setting</p></td>
<td ><p>Specifies whether paths use aliasing to smooth lines as they cross pixel boundaries. You use the <code>NSGraphicsContext</code> class to change this setting. For more information, see <span class="content_text"><a href="GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-BCIJJCBB">“Setting the Anti-aliasing Options.”</a></span> </p></td>
</tr>

</table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH203-SW6" title="Note"></a><p><strong>Note:</strong>&nbsp;The <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_329"></a>winding rule used to fill paths is not stored as part of the current graphics state. You can set a default winding rule for <code>NSBezierPath</code> objects but doing so affects content rendered using those objects. For more information, see <span class="content_text"><a href="../Paths/Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BAJIJJGD">“Winding Rules.”</a></span> </p></div>
<a name="//apple_ref/doc/uid/TP40003290-CH203-SW7" title="Screen Canvases and Print Canvases"></a><h3>Screen Canvases and Print Canvases</h3>
<p>In a broad sense, Cocoa graphics context objects serve two types of <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_330"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_331"></a>canvases: <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_332"></a>screen-based canvases and <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_333"></a>print-based canvases. A screen-based graphics context renders content to a window, view, or image with the results usually appearing on a screen. A print-based graphics context is used to render content to a printer spool file, PDF file, PostScript file, EPS file, or other medium usually associated with the printing system.</p>
<p>For nearly all screen-based and print-based drawing, Cocoa provides an appropriate graphics context object automatically. Cocoa provides a graphics context object during all view updates and in response to the user printing a document. There are situations, however, where you must create a <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_334"></a>graphics context object manually, including the following:</p>
<ul class="spaceabove"><li class="li"><p>Using <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_335"></a>OpenGL commands to render your view content</p></li>
<li class="li"><p>Drawing to an offscreen bitmap</p></li>
<li class="li"><p>Creating PDF or EPS data</p></li>
<li class="li"><p>Initiating a print job programmatically</p></li></ul>
<p>Using the class methods of <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSGraphicsContext" target="_top">NSGraphicsContext</a></code>, you can create graphics context objects for drawing to screen-based canvases. You cannot use these methods for print-based canvas, however. Cocoa routes all printing operations through the Cocoa printing system, which handles the task of setting up the graphics context object for you. This means that if you want to generate PDF data, EPS data, or print to a printer, you must use the methods of the <code><a href="../../../Reference/ApplicationKit/Classes/NSPrintOperation_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPrintOperation" target="_top">NSPrintOperation</a></code> class to create a print job for your target. It also means that your views should provide some minimal printing support if you want to produce well-formatted output for print-based canvases. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH203-SW8" title="Note"></a><p><strong>Note:</strong>&nbsp;Although Cocoa does provide some support for creating OpenGL graphics contexts automatically, the default pixel format options are usually limited. In most cases, you will want to create a custom OpenGL graphics context with the pixel format options you need for drawing. For more information, see <span class="content_text"><a href="../QuartzOpenGL/QuartzOpenGL.html#//apple_ref/doc/uid/TP40003290-CH211-BAAIFCFA">“Creating an OpenGL Graphics Context.”</a></span>  </p></div><p>You can determine the type of <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_336"></a>canvas being managed by the current graphics context using the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_337"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSGraphicsContext/isDrawingToScreen" target="_top">isDrawingToScreen</a></code> instance method or <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/clm/NSGraphicsContext/currentContextDrawingToScreen" target="_top">currentContextDrawingToScreen</a></code> class method of <code>NSGraphicsContext</code>. For print-based canvases, you can use the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_338"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSGraphicsContext/attributes" target="_top">attributes</a></code> method to get additional information about the canvas, such as whether it is being used to generate a PDF or EPS file. </p>
<p>For more information about obtaining contexts for both screen-based and print-based canvases, see <span class="content_text"><a href="GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-BCIGDIAA">“Creating Graphics Contexts.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40003290-CH203-BCIEABFI" title="Graphics Contexts and Quartz"></a><h3>Graphics Contexts and Quartz</h3>
<p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_339"></a>The <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSGraphicsContext" target="_top">NSGraphicsContext</a></code> class in Cocoa is a wrapper for a <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_340"></a>Quartz graphics context (<a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_341"></a><code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/tdef/CGContextRef" target="_top">CGContextRef</a></code> data type). Both types manage the same basic information, and in fact, many methods of <code>NSGraphicsContext</code> simply call their Quartz equivalents. This relationship makes it easy to perform any Quartz-related drawing in your application. It also means that any time you have a Cocoa graphics context (an instance of the <code>NSGraphicsContext</code> class), you have a Quartz graphics context as well. </p><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_342"></a>For information on how to use Cocoa graphics contexts to call Quartz functions, see <span class="content_text"><a href="../QuartzOpenGL/QuartzOpenGL.html#//apple_ref/doc/uid/TP40003290-CH211-BAAJDFGJ">“Using Quartz in Your Application.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40003290-CH203-SW9" title="Modifying the Current Graphics State"></a><h2>Modifying the Current Graphics State</h2>
<p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_343"></a>In your view’s <code>drawRect:</code> method, one of the first things you may want to do is <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_344"></a>modify the current drawing environment. For example, you might want to configure the current drawing colors, modifying the clipping region, transform the coordinate system, and so on. Many attributes can be set directly using the methods of <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSGraphicsContext" target="_top">NSGraphicsContext</a></code> but some require the use of other objects. The following sections list the available drawing attributes and how you modify them.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_6" title="Important:"></a><p><strong>Important:</strong>&nbsp;Saving and restoring the current graphics state is a relatively expensive operation <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_345"></a> that should done as little as possible. In general, you should try to save and restore the graphics state only to undo several changes at once or when there is no alternative, such as to reset the clipping path. For individual changes, setting a new value directly is often more efficient than saving and restoring the entire graphics state. </p><p></p></div>
<a name="//apple_ref/doc/uid/TP40003290-CH203-BCIDFCGD" title="Setting Colors and Patterns"></a><h3>Setting Colors and Patterns</h3>
<p>Cocoa provides support for <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_346"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_347"></a>colors in a variety of different color spaces. The <code><a href="../../../Reference/ApplicationKit/Classes/NSColor_Class/Reference/Reference.html#//apple_ref/occ/cl/NSColor" target="_top">NSColor</a></code> class supports <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_348"></a>RGB, <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_349"></a>CMYK, and <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_350"></a>grayscale color spaces by default but can also support custom color spaces defined by <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_351"></a>ICC and ColorSync profiles. The colors you specify include the color channels appropriate for the color space and an optional alpha component to define the transparency of the color. </p><p>To set the current <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_352"></a>stroke or fill attributes, create an <code>NSColor</code> object and send it a <code>set</code>, <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_353"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSColor_Class/Reference/Reference.html#//apple_ref/occ/instm/NSColor/setStroke" target="_top">setStroke</a></code>, or <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_354"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSColor_Class/Reference/Reference.html#//apple_ref/occ/instm/NSColor/setFill" target="_top">setFill</a></code> message. The stroke and fill attributes define the color or pattern for paths and the areas they enclose.  The current stroke and fill colors affect all drawn content except text, which requires the application of text attributes; see <span class="content_text"><a href="../Color/Color.html#//apple_ref/doc/uid/TP40003290-CH205-BAJIBFGC">“Applying Color to Text.”</a></span></p>
<p>For more information about colors and how to create them, see <span class="content_text"><a href="../Color/Color.html#//apple_ref/doc/uid/TP40003290-CH205-BAJDFIFE">“Color and Transparency.”</a></span>  </p>
<a name="//apple_ref/doc/uid/TP40003290-CH203-BCIEBIIB" title="Setting Path Attributes"></a><h3>Setting Path Attributes</h3><p>To modify the value of path attributes, you use the <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> class. Using the methods of this class, you can set the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_355"></a>line width, <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_356"></a>line join style, <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_357"></a>line dash style, line <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_358"></a>cap style, <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_359"></a>miter limit, <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_360"></a>flatness, and <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_361"></a>winding rule attributes. All of these attributes affect the way paths are rendered by Cocoa. </p>
<p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_362"></a>Path <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_363"></a>attributes come in two flavors: global and path-specific. When you use the class methods in <code>NSBezierPath</code> to set the "default" value for an attribute, you are setting the global attribute. Global attributes are global to path objects (as opposed to the graphics state), so setting a global attribute affects all paths you render using the <code>NSBezierPath</code> class, but does not affect Quartz-based paths. To override a global attribute for an individual path object, you should set a path-specific value. For example, to set the global line width, you use the <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/setDefaultLineWidth:" target="_top">setDefaultLineWidth:</a></code> class method of <code>NSBezierPath</code>. To set the line width for a specific <code>NSBezierPath</code> object, you use its <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/setLineWidth:" target="_top">setLineWidth:</a></code> instance method. </p>
<p>For information on how to set both default and path-specific attributes, and to see the resulting appearance of rendered content, see <span class="content_text"><a href="../Paths/Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCDEJGD">“Path Attributes.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40003290-CH203-SW10" title="Setting Text Attributes"></a><h3>Setting Text Attributes</h3><p>For most string-based drawing in Cocoa, you apply <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_364"></a>text attributes directly to the strings, rather than relying on the global font settings. The Cocoa string objects and the Cocoa text system both support the use of attributes for modifying the appearance of string. For <code><a href="../../../Reference/Foundation/Classes/NSAttributedString_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAttributedString" target="_top">NSAttributedString</a></code> objects, you apply the attributes directly to character ranges in the string. For regular <code><a href="../../../Reference/Foundation/Classes/NSString_Class/Reference/NSString.html#//apple_ref/occ/cl/NSString" target="_top">NSString</a></code> objects, you apply the attributes to the entire string when you draw it.</p><p>If you want to set the global font settings stored in the graphics state, perhaps for drawing strings using Quartz, you can use the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_365"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSFont_Class/Reference/Reference.html#//apple_ref/occ/cl/NSFont" target="_top">NSFont</a></code> object to set the font family and size. After creating a font object, you use its set method to apply the font information to the current graphics state. </p>
<p>For more information about drawing options for text, see <span class="content_text"><a href="../Text/Text.html#//apple_ref/doc/uid/TP40003290-CH209-BCIEEIGC">“Text.”</a></span> For more information about the Cocoa text system, see <em><a href="../../TextArchitecture/index.html#//apple_ref/doc/uid/10000086i" target="_top">Text System Overview</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH203-BCIDBEEB" title="Setting Compositing Options"></a><h3>Setting Compositing Options</h3>
<p>When you render each visual element, you need to decide how that element interacts with any surrounding content. You might want the element to be layered on top of or behind the current content or be merged with it in interesting ways. You specify this behavior using different compositing options. </p><p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_366"></a>Compositing options specify how the colors in source content are blended with the existing content in the drawing destination. With fully opaque colors, most compositing options simply mask or overlay different parts of the source and destination content. With partially transparent colors, however, you can achieve interesting blending effects. </p>
<p>The Cocoa compositing options differ from the blend modes used in Quartz, although the two perform basically the same task. The Cocoa options are inherited from the NextStep environment, whereas the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_367"></a>Quartz <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_368"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_369"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_370"></a>blend modes are part of the newer PDF-based rendering model. Despite their historical legacy, the Cocoa options are still a very powerful way to composite content, and may even be a little easier to understand than their Quartz counterparts. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_7" title="Important:"></a><p><strong>Important:</strong>&nbsp;Despite their similarities, there is no direct mapping between the Cocoa compositing options and the Quartz blend modes. In addition, when drawing to a print-based canvas, you should use only the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeCopy" target="_top">NSCompositeCopy</a></code> or the  <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeSourceOver" target="_top">NSCompositeSourceOver</a></code> operators. (For PDF content, you should use only the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeSourceOver" target="_top">NSCompositeSourceOver</a></code> operator or the Quartz blend modes.) If you need to use any other compositing operators, you should render your content to an image and then draw the image to the printing context using one of the supported operators. If your application relies heavily on PDF blend modes, you may want to use Quartz for your drawing instead.</p><p></p></div>
<p><span class="content_text">Figure 2-1</span> shows the Cocoa <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_371"></a>compositing options and how they affect rendered content. At the top of the figure are the source and destination content being rendered. The veins of the leaf are completely transparent while the rest of the leaf is opaque. In the destination image, the color is rendered at partial opacity. Below that are the results for each of the supported <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_372"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_373"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_374"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_375"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_376"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_377"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_378"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_379"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_380"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_381"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_382"></a>compositing <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_383"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_384"></a>operations.</p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH203-BCIDHAGH" title="Figure 2-1Compositing operations in Cocoa"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>Compositing operations in Cocoa</p>
<img src = "../art/composite_modes.gif" alt = "Compositing operations in Cocoa" width="554" height="606"></div><br/><p><span class="content_text">Table 2-2</span> lists the mathematical equations used to compute pixel colors during compositing operations. In each equation, <code>R</code> is the resulting (premultiplied) color, <code>S</code> is the source color, <code>D</code> is the destination color, <code>Sa</code> is the alpha value of the source color, and <code>Da</code> is the alpha value of the destination color. All color component values and alpha values are in the range 0 to 1 for these computations.  </p><a name="//apple_ref/doc/uid/TP40003290-CH203-SW2" title="Table 2-2Mathematical equations for compositing colors"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-2&nbsp;&nbsp;</strong>Mathematical equations for compositing colors</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Para</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Para</p></th></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeClear" target="_top">NSCompositeClear</a></code></p></td><td ><p><code>R = 0</code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeCopy" target="_top">NSCompositeCopy</a></code></p></td><td ><p><code>R = S</code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeSourceOver" target="_top">NSCompositeSourceOver</a></code></p></td><td ><p><code>R = S + D*(1 - Sa)</code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeSourceIn" target="_top">NSCompositeSourceIn</a></code></p></td><td ><p><code>R = S*Da</code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeSourceOut" target="_top">NSCompositeSourceOut</a></code></p></td><td ><p><code>R = S*(1 - Da)</code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeSourceAtop" target="_top">NSCompositeSourceAtop</a></code></p></td><td ><p><code>R = S*Da + D*(1 - Sa)</code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeDestinationOver" target="_top">NSCompositeDestinationOver</a></code></p></td><td ><p><code>R = S*(1 - Da) + D</code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeDestinationIn" target="_top">NSCompositeDestinationIn</a></code></p></td><td ><p><code>R = D*Sa</code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeDestinationOut" target="_top">NSCompositeDestinationOut</a></code></p></td><td ><p><code>R = D*(1 - Sa)</code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeDestinationAtop" target="_top">NSCompositeDestinationAtop</a></code></p></td><td ><p><code>R = S*(1 - Da) + D*Sa</code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeXOR" target="_top">NSCompositeXOR</a></code></p></td><td ><p><code>R = S*(1 - Da) + D*(1 - Sa)</code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositePlusDarker" target="_top">NSCompositePlusDarker</a></code></p></td><td ><p><code>R = MAX(0, (1 - D) + (1 - S))</code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositePlusLighter" target="_top">NSCompositePlusLighter</a></code></p></td><td ><p><code>R = MIN(1, S + D)</code></p></td></tr></table></div><p>To set the current compositing operation, you use the <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSGraphicsContext/setCompositingOperation:" target="_top">setCompositingOperation:</a></code> method of <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSGraphicsContext" target="_top">NSGraphicsContext</a></code>. This sets the global compositing option to use if no other operator is specified. The default compositing option is <code>NSCompositeSourceOver</code>.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH203-BCIIADBC" title="Setting the Clipping Region"></a><h3>Setting the Clipping Region</h3><p>The clipping region is a useful way to limit drawing to a specific portion of your view. Instead of creating complex graphics offscreen and then compositing them precisely in your view, you can use a clipping region to mask out the portions of your view you do not want modified. For example, you might use a clipping region to prevent drawing commands from drawing over some already rendered content. Similarly, you might use a clipping region to cut out specific portions of an image you want to render.</p>
<p>Before invoking your view’s <code>drawRect:</code> method, Cocoa configures the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_385"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_386"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_387"></a>clipping region of the current graphics context to match the visible area of your view. This prevents your view's drawing code from rendering content outside of your view's boundaries, possibly on top of other views. </p><p>You can restrict the drawable region of your view even further by adding shapes to the current clipping region. Whenever you add a new shape to the current clipping region, Cocoa determines the intersection of the shape with the current clipping region and uses the result as the new clipping region. This behavior means that you should generally add only one shape to the clip region before doing your drawing. The shape you add can be a single rectangle, multiple rectangles, or a combination of multiple complex subpaths in a single <code>NSBezierPath</code> object.  </p>
<p>For simple rectangular shapes, the easiest way to clip is using the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_388"></a><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSRectClip" target="_top">NSRectClip</a></code> function. To specify multiple rectangular regions, use the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_389"></a><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSRectClipList" target="_top">NSRectClipList</a></code> function instead. To clip your view to a nonrectangular region, you must use an <code>NSBezierPath</code> object. The path you create can be arbitrarily complex and include multiple rectangular and nonrectangular regions. Once you have the path you want, use the object’s <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_390"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/addClip" target="_top">addClip</a></code> method to add the resulting shape to the current clipping region. (For information on how to create paths, see <span class="content_text"><a href="../Paths/Paths.html#//apple_ref/doc/uid/TP40003290-CH206-SW4">“Drawing Fundamental Shapes.”</a></span>) </p>
<p><span class="content_text">Figure 2-2</span> shows the effects of applying a clipping path to an image. The top images show the image to be clipped and the path to use for the clip shape, which in this case consists of two shapes inside a single <code>NSBezierPath</code> object. Although the clip shape is the same in both cases, the resulting clip region is different. This is because clipping takes into account the current winding rule when calculating the clipping region. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH203-BCIJHHBI" title="Figure 2-2Clipping paths and winding rules"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>Clipping paths and winding rules</p>
<img src = "../art/winding_rules_clipping.jpg" alt = "Clipping paths and winding rules" ></div><br/>
<p>The following example shows you how to create the clip region shown in <span class="content_text">Figure 2-2</span>. The clip region is composed of an overlapping square and circle, so you simply add a rectangle and oval with the appropriate sizes to a Bezier path object and call the <code>addClip</code> method. </p>
<div class="codesample"><table><tr><td scope="row"><pre>// If you plan to do more drawing later, it's a good idea<span></span></pre></td></tr><tr><td scope="row"><pre>// to save the graphics state before clipping.<span></span></pre></td></tr><tr><td scope="row"><pre>[NSGraphicsContext saveGraphicsState];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Create the path and add the shapes<span></span></pre></td></tr><tr><td scope="row"><pre>NSBezierPath* clipPath = [NSBezierPath bezierPath];<span></span></pre></td></tr><tr><td scope="row"><pre>[clipPath appendBezierPathWithRect:NSMakeRect(0.0, 0.0, 100.0, 100.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[clipPath appendBezierPathWithOvalInRect:NSMakeRect(50.0, 50.0, 100.0,  100.0)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Add the path to the clip shape.<span></span></pre></td></tr><tr><td scope="row"><pre>[clipPath addClip];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Draw the image.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[NSGraphicsContext restoreGraphicsState];<span></span></pre></td></tr></table></div>
<div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_8" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;
Although you can also use the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_391"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/setClip" target="_top">setClip</a></code> method of <code>NSBezierPath</code> to modify the clipping region, doing so is not recommended. The <code>setClip</code> method replaces the entire clipping region with the area you specify. If the new clipping region extends beyond the bounds of your view, this could lead to portions of your content spilling over into neighboring views. </p><p></p><div class="clear"></div></div>
<a name="//apple_ref/doc/uid/TP40003290-CH203-BCIJJCBB" title="Setting the Anti-aliasing Options"></a><h3>Setting the Anti-aliasing Options</h3>
<p>Cocoa <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_392"></a>graphics contexts support <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_393"></a>anti-aliasing in the same way that their Quartz counterparts do. <strong><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_394"></a>Anti-aliasing</strong> is the process of artificially correcting the jagged (or aliased) edges surrounding text or shapes in bitmap images. These jagged edges occur primarily in lower-resolution bitmaps where it is easier to see individual pixels. To remove the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_395"></a>jagged edges, Cocoa uses different colors for the pixels that surround a shape’s outline. The colors it uses are a blend of the original pixel color and the color of the shape’s outline. By blending colors in this way, the edges of the shape appear much smoother. <span class="content_text">Figure 2-3</span> shows the same image aliased and anti-aliased. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH203-BCICEJGF" title="Figure 2-3A comparison of aliased and anti-aliased content"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>A comparison of aliased and anti-aliased content</p><img src = "../art/antialias.gif" alt = "A comparison of aliased and anti-aliased content" width="378" height="426"></div><br/>
<p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_396"></a>To enable or disable anti-aliasing, use the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_397"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSGraphicsContext/setShouldAntialias:" target="_top">setShouldAntialias:</a></code> method of <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSGraphicsContext" target="_top">NSGraphicsContext</a></code>. Even with anti-aliasing disabled, it may still appears as if Cocoa is drawing content using aliasing. When drawing content on <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_398"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_399"></a>nonpixel boundaries, Cocoa may opt to split the line over multiple pixels, which can give the impression of aliasing. For more information about how to avoid this situation, see <span class="content_text"><a href="../Transforms/Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCICIJAJ">“Doing Pixel-Exact Drawing.”</a></span>  </p>
<a name="//apple_ref/doc/uid/TP40003290-CH203-BCIGDIAA" title="Creating Graphics Contexts"></a><h2>Creating Graphics Contexts</h2>
<p><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_400"></a>The type of drawing you do in your application will determine whether you need to create any graphics context objects explicitly or simply use the one Cocoa provides you. If all you do is draw in your views, you can probably just use the Cocoa-provided context. This is true both for screen-based and print-based drawing. If your application performs any other type of drawing, however, you may need to create a graphics context yourself.</p><p>The following sections provide information on how and when to create Cocoa graphics contexts for your content. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH203-SW1" title="Creating a Screen-Based Context"></a><h3>Creating a Screen-Based Context</h3>
<p>If you want to do any drawing outside of the normal update cycle of your view, you must create a graphics context object explicitly.  You might use this technique to draw in an offscreen window or bitmap and then copy the resulting bits elsewhere. You could also use it to draw to a window from a secondary thread. The <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/cl/NSGraphicsContext" target="_top">NSGraphicsContext</a></code> class includes methods for creating new graphics context objects specifically for windows and bitmap images. </p>
<p>To draw to a <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_401"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_402"></a>window, you can use the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_403"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/clm/NSGraphicsContext/graphicsContextWithWindow:" target="_top">graphicsContextWithWindow:</a></code> method of <code>NSGraphicsContext</code>. The context you get back is initialized to the window itself, and not to a specific view. In fact, you may not want to use this technique if the window contains many subviews. In order to draw the views properly, you would need to walk the list of subviews manually and configure the drawing environment for each one, which is not recommended. Instead, you would use this technique for drawing to an offscreen buffer. </p>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_9" title="Important:"></a><p><strong>Important:</strong>&nbsp;
Because most Mac OS X windows are already <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_404"></a>double-buffered, do not use offscreen windows or bitmaps simply to update the contents of a window. Doing so wastes memory (by adding a third buffer) and requires an extra copy operation to transfer the bits from the offscreen window to the window buffer. </p><p></p></div>
<p>To draw to a <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_405"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_406"></a>bitmap, you have two options. If your code runs in Mac OS X v10.4 and later, you can use the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_407"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/clm/NSGraphicsContext/graphicsContextWithBitmapImageRep:" target="_top">graphicsContextWithBitmapImageRep:</a></code> method to create a context object focused on an <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBitmapImageRep" target="_top">NSBitmapImageRep</a></code> object. The drawing you do is then rendered directly to the bitmap. If your code must run on earlier versions of Mac OS X, you must either lock focus on a view or use an offscreen window and then capture the contents of the view or window. For information and examples on how to create bitmaps, see <span class="content_text"><a href="../Images/Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCICHFGA">“Creating a Bitmap”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40003290-CH203-BCIDHFFD" title="Creating a PDF or PostScript Context"></a><h3>Creating a PDF or PostScript Context</h3>
<p>Unlike screen-based contexts, if you want to create a graphics context for a <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_408"></a>PDF, <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_409"></a>EPS, or print-based canvas, you do not do so directly. All print-based operations must go through the Cocoa printing system, which handles the work required for setting up the printed pages and running the print job. </p><p>The simplest way to create a <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_410"></a>PDF or <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_411"></a>EPS file is to use the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/dataWithPDFInsideRect:" target="_top">dataWithPDFInsideRect:</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/dataWithEPSInsideRect:" target="_top">dataWithEPSInsideRect:</a></code> methods of <code>NSView</code>. These methods configure a print job automatically and use your view's existing drawing code to generate the PDF or EPS data. For more information and an example of how to use these methods, see <span class="content_text"><a href="../Images/Images.html#//apple_ref/doc/uid/TP40003290-CH208-SW1">“Creating a PDF or EPS Image Representation.”</a></span> </p>
<p>To create a print job manually, you use the <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_412"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSPrintOperation_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPrintOperation" target="_top">NSPrintOperation</a></code> class. This class offers several class methods for creating print jobs for a particular view and outputting the job to a printer, PDF file, or EPS file. Once you have an instance of the <code>NSPrintOperation</code> class, you can set the print information and use the <code><a href="../../../Reference/ApplicationKit/Classes/NSPrintOperation_Class/Reference/Reference.html#//apple_ref/occ/instm/NSPrintOperation/runOperation" target="_top">runOperation</a></code> method to start the print job, at which point Cocoa takes over. </p>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_10" title="Important:"></a><p><strong>Important:</strong>&nbsp;
You cannot create a viable graphics context for PDF or PostScript canvases using the <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/clm/NSGraphicsContext/graphicsContextWithAttributes:" target="_top">graphicsContextWithAttributes:</a></code> method. You must go through the Cocoa Printing system instead.  </p><p></p></div>
<p>During the execution of a print job, Cocoa calls several methods of your view to handle page layout and drawing. These methods are called for all printing paths, so implementing them for printing will also support PDF and EPS. For information on how to implement these methods, <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_413"></a>see <em><a href="../../Printing/index.html#//apple_ref/doc/uid/10000083i" target="_top">Printing Programming Topics for Cocoa</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH203-SW11" title="Threading and Graphics Contexts"></a><h2>Threading and Graphics Contexts</h2>
<p>The Application Kit maintains a unique <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_414"></a><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_415"></a>graphics context for each window and thread combination. Because each thread has its own graphics context object for a given window, it is possible to use secondary threads to draw to that window. There are some caveats, however.</p>
<p>During the normal update cycle for windows, all drawing requests are sent to your application’s main thread for processing. The normal update cycle happens when a user event triggers a change in your user interface. In this situation, you would call the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/setNeedsDisplay:" target="_top">setNeedsDisplay:</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/setNeedsDisplayInRect:" target="_top">setNeedsDisplayInRect:</a></code> method (or the <code>display</code> family of methods) from your application’s main thread to invalidate the portions of your view that require redrawing. You should not call these methods from any secondary threads. </p>
<p>If you want to update a window or view from a secondary thread<a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_416"></a>, you must manually lock focus on the window or view and initiate drawing yourself. <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_417"></a>Locking <a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_418"></a>focus configures the drawing environment for that window's graphics context. Once locked, you can configure the drawing environment, issue your drawing commands as usual, and then flush the contents of the graphics context to the window buffer.  </p>
<p>In order to draw regularly on a secondary thread, you must notify the thread yourself. The simplest way to send regular notifications is using an <code><a href="../../../Reference/Foundation/Classes/NSTimer_Class/Reference/NSTimer.html#//apple_ref/occ/cl/NSTimer" target="_top">NSTimer</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSAnimation_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAnimation" target="_top">NSAnimation</a></code> object. For more information on how to animate content, see <span class="content_text"><a href="../AdvancedDrawing/AdvancedDrawing.html#//apple_ref/doc/uid/TP40003290-CH207-CJBFEEJA">“Advanced Drawing Techniques.”</a></span></p><p>Creating bitmaps on secondary threads is one way to thread your drawing code. Because bitmaps are self-contained entities, they can be created safely on secondary threads. From your thread, you would need to create the graphics context object explicitly (as described in <span class="content_text"><a href="GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-SW1">“Creating a Screen-Based Context”</a></span>) and then issue drawing calls to draw into the bitmap buffer. For more information on how to create bitmaps, including sample code, see <span class="content_text"><a href="../Images/Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCICHFGA">“Creating a Bitmap.”</a></span>  </p>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH203-DontLinkElementID_11" title="Important:"></a><p><strong>Important:</strong>&nbsp;
Although drawing on secondary threads is allowed, you should always handle events and other user-requested actions from your application’s main thread only. Using multiple threads to handle events can lead to processing those events out of sequence, which can cause inconsistencies in your application’s behavior.</p><p></p></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../DrawingEnviron/DrawingEnviron.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Transforms/Transforms.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-01-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/GraphicsContexts/GraphicsContexts.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/GraphicsContexts/GraphicsContexts.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/GraphicsContexts/GraphicsContexts.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>