<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Interface Builder Plug-In Programming Guide: Inspector Objects</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Inspector Objects"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40004323-CH6" title="Inspector Objects"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../InterfaceBuilder-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000525" target="_top">Interface Builder</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40004323-CH1-DontLinkElementID_48">Interface Builder Plug-In Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ThePlug-inObject/ThePlug-inObject.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AdvancedTechniques/AdvancedTechniques.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40004323-CH6-SW1" title="Inspector Objects"></a><h1>Inspector Objects</h1><p>The inspector window in Interface Builder provides the user with access to the attributes of the currently selected objects. The inspector window is divided into several different panes, which are selected using controls at the top of the window (<span class="content_text">Figure 5-1</span>). The attributes pane is the only pane plug-in developers can customize. </p><br/><div><a name="//apple_ref/doc/uid/TP40004323-CH6-SW2" title="Figure 5-1The inspector window for Cocoa controls"></a><p><strong>Figure 5-1&nbsp;&nbsp;</strong>The inspector window for Cocoa controls</p><img src = "../Art/insp_attributes_pane.jpg" alt = "The inspector window for Cocoa controls" ></div><br/><p>The attributes pane displays the design-time attributes of the currently selected objects. The attributes themselves are divided up and displayed in “sections”, which are collapsible regions consisting of a title bar and content area. The content area of each section contains the attributes associated with a given class in the selected object’s lineage. For example, an instance of the <code>NSButton</code> class contains sections displaying the <code>NSView</code> attributes, <code>NSControl</code> attributes, and <code>NSButton</code> attributes. </p><p>The advantage of sections is that they promote greater editability when multiple objects are selected. When multiple objects are selected, Interface Builder displays all of the inspectors that are common among the selected objects. Thus, if an <code>NSButton</code> and <code>NSTextField</code> object are selected, the user sees the Control, View, and Object inspectors. This lets the user modify any of the attributes that are common to the objects in the selection. </p><p>Each section in the attributes pane is managed by an inspector object. An inspector object ensures that the controls in the section’s content view remain synchronized with the attributes of the currently selected objects. When one of your custom objects is selected, Interface Builder queries it for the names of the inspector classes needed to display its attributes. Interface Builder provides inspector classes for all of the standard Cocoa classes so you need to provide inspectors only for those classes you use to implement your custom objects. In addition, an inspector class is needed only if your custom view or object classes have attributes that are configurable at design time. If they do not, you do not need to create an inspector class.</p><p>The steps for creating an inspector object are as follows:</p><ol class="ol"><li class="li"><p>Define a custom subclass of <code>IBInspector</code>.</p></li><li class="li"><p>Create a nib file with the user interface of your inspector section.</p></li><li class="li"><p>Configure the bindings or write the code needed to synchronize your inspector interface with the currently selected objects.</p></li><li class="li"><p>Register your inspector class with Interface Builder.</p></li></ol>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CreatingInspectors.html#//apple_ref/doc/uid/TP40004323-CH6-DontLinkElementID_10">Creating Your Inspector Class</a>
				
			<br/>
			
        
			
			
				<a href="CreatingInspectors.html#//apple_ref/doc/uid/TP40004323-CH6-SW9">Creating Your Inspector’s User Interface</a>
				
			<br/>
			
        
			
			
				<a href="CreatingInspectors.html#//apple_ref/doc/uid/TP40004323-CH6-SW5">Synchronizing Your Inspector’s Interface</a>
				
			<br/>
			
        
			
			
				<a href="CreatingInspectors.html#//apple_ref/doc/uid/TP40004323-CH6-DontLinkElementID_13">Registering Your Inspector Objects</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40004323-CH6-DontLinkElementID_10" title="Creating Your Inspector Class"></a><h2>Creating Your Inspector Class</h2><p>The <code>IBInspector</code> class provides the default controller interface for implementing your custom inspector objects. Custom inspectors are needed only for classes that have custom design-time attributes that you want to be configurable in Interface Builder. If your classes do not expose any public attributes, you do not need to create an inspector class. </p><p>Every inspector class has the following responsibilities:</p><ul class="ul"><li class="li"><p>Provide an interface for viewing and setting attributes. </p></li><li class="li"><p>Synchronize the controls in its view with the attributes of the current selection.</p></li></ul><p>The <code>viewNibName</code> method of <code>IBInspector</code> is the preferred way to provide the interface for your inspector class. This method returns the name of the nib file containing your inspector’s interface. You can also create your user interface programmatically if you prefer. The steps for creating your user interface are discussed in <span class="content_text"><a href="CreatingInspectors.html#//apple_ref/doc/uid/TP40004323-CH6-SW9">“Creating Your Inspector’s User Interface.”</a></span> </p><p>For information on how to synchronize your inspector’s interface with the current selection, see <span class="content_text"><a href="CreatingInspectors.html#//apple_ref/doc/uid/TP40004323-CH6-SW5">“Synchronizing Your Inspector’s Interface.”</a></span> </p><a name="//apple_ref/doc/uid/TP40004323-CH6-SW9" title="Creating Your Inspector&acirc;&#128;&#153;s User Interface"></a><h2>Creating Your Inspector’s User Interface</h2><p>There are two ways to create your inspector’s user interface: programatically or using a nib file. Using a nib file is by far the simplest way to create your inspector’s interface. In fact, if you use Cocoa bindings, it is possible to create your inspector with little or no code at all. Whereas, creating your inspector interface programatically is complicated and requires much more effort and testing to ensure the correct positioning and layout of any controls.</p><p>All new plug-in projects in Xcode come with an inspector nib file for you to customize. To create additional inspector nib files, you use Interface Builder. Interface Builder’s new document dialog includes an IB Kit tab that contains plug-in related template nib files. From this tab, selecting the Inspector template creates a nib file with the default content view shown in <span class="content_text">Figure 5-2</span>. This view includes several guides to help you line up your custom controls with the controls found in other inspectors. The view also includes some default controls that you can use for your inspector (or delete if they are not needed). Although you should not change the width of your inspector view, you can (and should) change its height to match the space used by your controls. </p><br/><div><a name="//apple_ref/doc/uid/TP40004323-CH6-SW7" title="Figure 5-2Default inspector view template"></a><p><strong>Figure 5-2&nbsp;&nbsp;</strong>Default inspector view template</p><img src = "../Art/inspector_view.jpg" alt = "Default inspector view template" ></div><br/><p>To configure the nib file containing your inspector’s user interface, do the following:</p><ol class="ol"><li class="li"><p>Open your plug-in project in Xcode. (This ensures that your class header files are accessible in Interface Builder.) </p></li><li class="li"><p>Open your project’s existing inspector nib file (or create a new one).</p></li><li class="li"><p>Add or remove any needed controls in your inspector view.</p><p>Typically, you would provide a single control for each design-time attribute of your object you want to expose. The type of the control would be determined by the type of data represented by the underlying attribute.</p><ul class="ul"><li class="li"><p>String values are typically represented by text fields.</p></li><li class="li"><p>Numerical values may be displayed in a text field but might also have an optional stepper control to increment or decrement the value. </p></li><li class="li"><p>Boolean values are typically represented using check boxes. </p></li><li class="li"><p>Enumerated type lists may be represented by radio buttons or pop-up menus. </p></li></ul></li><li class="li"><p>Select the Files Owner proxy object and open the identity pane of the inspector window. </p></li><li class="li"><p>Set the class name of File’s Owner to your <code>IBInspector</code> subclass. (You set this information in the identity pane of the inspector window.)</p></li><li class="li"><p>If it is not already connected, connect the <code>inspectorView</code> outlet of Files Owner to your inspector view. (This outlet is provided for you by the <code>IBInspector</code> class and should be connected already.) </p></li><li class="li"><p>Create any other connections or bindings required by your code. (For example, you might want to connect any outlets or actions to their targets.) </p></li><li class="li"><p>Save your nib file and add it to your Xcode project (if it has not yet been added).</p></li></ol><p>Nearly all inspector nib files require some additional connections beyond the <code>inspectorView</code> outlet of File’s Owner. You use these connections to make it possible to synchronize changes as the user changes the current selection and modifies controls in your inspector. Cocoa bindings provide the simplest type of connection by automatically synchronizing the current selection with your inspector’s controls. You can also use outlets and actions if you prefer, however. For more information on using both of these techniques, see <span class="content_text"><a href="CreatingInspectors.html#//apple_ref/doc/uid/TP40004323-CH6-SW5">“Synchronizing Your Inspector’s Interface.”</a></span></p><p>If you want to create your inspector view programmatically, you can do so by implementing a custom <code>view</code> method in your <code>IBInspector</code> subclass. In your implementation of this method, you would create the view object you want your inspector to display and configure it as required by your custom object. In addition to overriding this method, you must override the <code>viewNibName</code> method and have it return <code>nil</code> to prevent Interface Builder from automatically looking for a nib file. </p><a name="//apple_ref/doc/uid/TP40004323-CH6-SW5" title="Synchronizing Your Inspector&acirc;&#128;&#153;s Interface"></a><h2>Synchronizing Your Inspector’s Interface</h2><p>Interface Builder relies on your inspector object to coordinate the synchronization of the currently selected objects to your inspector’s user interface. Cocoa bindings are the preferred (and simplest) way to synchronize data but you can also use outlets and actions if you prefer. Which technique you choose may also depend on the complexity of your objects and how much logic is required to synchronize them with the inspector controls. Synchronization is required in the following situations:</p><ul class="ul"><li class="li"><p>The user changes the current selection.</p></li><li class="li"><p>The user changes the value of one of your inspector’s controls. </p></li></ul><p>When multiple objects are selected, the inspector window displays only those inspector sections that are common to all of the selected objects. Your inspector objects must be prepared to handle this situation gracefully by displaying appropriate values in the controls of their user interfaces. Although there are options for situations where handling multiple selected objects is difficult or impossible, you are highly encouraged to design your inspector interface in a way that allows it to display at least some information when multiple objects are selected.</p><p>The following sections guide you through the steps to implement the synchronization code for your inspectors. Remember that you can choose to use bindings, outlets and actions, or a combination of both. </p><a name="//apple_ref/doc/uid/TP40004323-CH6-SW6" title="Synchronizing Your Interface Using Bindings"></a><h3>Synchronizing Your Interface Using Bindings</h3><p>Bindings provide a sophisticated and elegant way to synchronize your inspector interface with the currently selected objects. Bindings are especially easy to use with inspectors since the whole point of an inspector is to reflect the values in the current selection—a task for which bindings are well suited.  </p><p>To establish a binding, select one of the controls in your inspector view and open the inspector window. In the bindings pane, configure your binding to the File’s Owner object and use the <code>inspectedObjectsController.selection</code> string as the initial part of the model key path. The <code>inspectedObjectsController</code> property of the <code>IBInspector</code> class is a key-value observable property that returns an <code>NSArrayController</code> object with the current selection. Binding through this object provides you with access to the currently selected objects.  If your synchronization logic is more complex, you can also include additional controller objects in your nib file and bind to them as needed to implement your logic.</p><p>To bind a checkbox to a Boolean value in your custom object, you would do the following: </p><ol class="ol"><li class="li"><p>Select the checkbox and open the inspector window.</p></li><li class="li"><p>In the bindings pane, expand the Value binding so that you can configure it.</p><ol class="ol"><li class="ol ol"><p>Set the Bind to property to the File’s Owner object.</p></li><li class="ol ol"><p>Set the Model Key Path field to a value similar to the following:</p><p><code>inspectedObjectsController.selection.</code><em>MyObjectProperty</em></p><p>where <em>MyObjectProperty</em> is the name of a KVO-compliant attribute in the target object.</p></li></ol></li><li class="li"><p>Configure any other bindings as desired. </p></li></ol><p>For more information about establishing bindings between objects, see <em><a href="../../../../Cocoa/Conceptual/CocoaBindings/index.html#//apple_ref/doc/uid/10000167i" target="_top">Cocoa Bindings Programming Topics</a></em>. </p><a name="//apple_ref/doc/uid/TP40004323-CH6-DontLinkElementID_11" title="Synchronizing Your Interface Manually"></a><h3>Synchronizing Your Interface Manually</h3><p>If you prefer use actions and outlets to synchronize your interface, you must do the following to implement your synchronization code:</p><ul class="spaceabove"><li class="li"><p>Define action methods in your inspector object that synchronize changes in your inspector’s controls with the objects in the current selection.</p></li><li class="li"><p>Implement the <code>refresh</code> method of your inspector object to respond to changes in the current selection. </p></li></ul><p>Implementing action methods for your inspector’s controls is a relatively straightforward task. When invoked, your action method should get the value from the control that initiated the action and write that value to each of the selected objects. To get the currently selected objects, use the <code>inspectedObjects</code> method of <code>IBInspector</code>. </p><p>Compared to bindings, implementing your <code>refresh</code> method involves a little more work, especially to support multiple selected objects. Interface Builder calls your <code>refresh</code> method any time the application state changes in a way that might require you to refresh your inspector. These state changes typically involve the user changing the selection but they might also be triggered by the active undo manager or other circumstances. </p><p>One of the first things your <code>refresh</code> method should do is see how many objects are in the current selection. If only one object is selected, you can simply extract the attribute values from that object and use them to set the state of your inspector’s interface. If multiple objects are selected, you need to determine what to display. If all of the values are the same, you should display the common value. If the values are different, you need to convey a multi-selection state in the appropriate controls. </p><p><span class="content_text">Listing 5-1</span> shows a <code>refresh</code> method for an inspector whose interface contains a single text field, which is assigned to the <code>titleField</code> outlet of the inspector object. When a single object is selected, the refresh method simply sets the value of the text field to the value of the object in the array. If multiple objects are selected and all their titles match, this method displays the common title string in the text field. If there is a mismatch in any of the titles, a placeholder string is displayed instead.</p><a name="//apple_ref/doc/uid/TP40004323-CH6-SW8" title="Listing 5-1Handling multiple objects in the refresh method"></a><p class="codesample"><strong>Listing 5-1&nbsp;&nbsp;</strong>Handling multiple objects in the refresh method</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)refresh<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSArray*        objects = [self inspectedObjects];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString*       newTitle;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSInteger       numObjects = [objects count];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (numObjects == 1)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        newTitle = [[objects objectAtIndex:0] title];<span></span></pre></td></tr><tr><td scope="row"><pre>        [titleField setStringValue:newTitle];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else if (numObjects > 1)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSString*    tempString;<span></span></pre></td></tr><tr><td scope="row"><pre>        NSInteger    i;<span></span></pre></td></tr><tr><td scope="row"><pre>        BOOL        allMatch = YES;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // See if the titles are all the same.<span></span></pre></td></tr><tr><td scope="row"><pre>        newTitle = [[objects objectAtIndex:0] title];<span></span></pre></td></tr><tr><td scope="row"><pre>        for (i = 1; i &lt; numObjects; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            tempString = [[objects objectAtIndex:i] title];<span></span></pre></td></tr><tr><td scope="row"><pre>            if (![newTitle isEqualToString:tempString])<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                allMatch = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Set the value of the text field.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (allMatch)<span></span></pre></td></tr><tr><td scope="row"><pre>            [titleField setStringValue:newTitle];<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            [titleField setStringValue:@""];<span></span></pre></td></tr><tr><td scope="row"><pre>            [(NSTextFieldCell*)[titleField cell] setPlaceholderString:@"&lt;multiple>"];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [super refresh];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When implementing a custom <code>refresh</code> method, you must invoke <code>super</code> at some point in your implementation. Interface Builder uses the <code>refresh</code> message to update some of its own internal objects, such as the inspected objects controller. Invoking <code>super</code> ensures these objects are updated properly. </p><a name="//apple_ref/doc/uid/TP40004323-CH6-SW4" title="Tips for Displaying Attributes for Multiple Selected Objects"></a><h3>Tips for Displaying Attributes for Multiple Selected Objects</h3><p>When multiple objects are selected, Interface Builder displays only those inspectors that are common among all of the selected objects. Although the types are the same, the attributes of each object may not be the same, however. If the current selection contains multiple objects, your inspector needs to check the values in the objects and determine an appropriate way to convey that information. There are two basic scenarios that can occur:</p><ul class="spaceabove"><li class="li"><p>All of the objects contain the same value for a given attribute.</p></li><li class="li"><p>At least one object has a different value for an attribute.</p></li></ul><p>If all of the objects contain the same value, you should display the common value. If the values differ in any way, you need to convey this status to the user somehow. Some controls support the ability to display a mixed state indicator, but others may require that you simply show no value. The following list shows some of the standard controls used in inspectors and how you might use them to display mixed state information: </p><ul class="spaceabove"><li class="li"><p>Check boxes - display the mixed state setting for the checkbox.</p></li><li class="li"><p>Text fields - display a placeholder string with the value “<em>Mixed</em>“ or “<em>&lt;multiple></em>“. </p></li><li class="li"><p>Pop-up buttons and combo boxes - display a blank menu item—that is, a menu item with no text.</p></li><li class="li"><p>Segmented controls - deselect all segments. </p></li><li class="li"><p>Radio buttons - deselect all buttons in the group.</p></li><li class="li"><p>Color wells - display a default color</p></li></ul><a name="//apple_ref/doc/uid/TP40004323-CH6-DontLinkElementID_12" title="Disabling Your Inspector During Multiple Selection"></a><h3>Disabling Your Inspector During Multiple Selection</h3><p>If your inspector object cannot inspect a selection with multiple objects, you can tell Interface Builder not to display your inspector when multiple objects are selected. To do this, override the <code>supportsMultipleObjectInspection</code> method in your <code>IBInspector</code> subclass and return <code>NO</code>. </p><p>Returning <code>NO</code> from the <code>supportsMultipleObjectInspection</code> method should be avoided if at all possible. You might use this option, however, when no reasonable alternative exists for reflecting the data of multiple objects. For example, if your inspector displays tabular data or some other complex data that cannot be represented easily for more than one object at a time, you could use this option. Doing so should still be avoided whenever possible, however. Instead, you might consider disabling your table or temporarily replacing it with a text field and the words “Multiple selection”.  </p><p>If it is easy to reflect a multi-object selection for some attributes but not others, it is preferable to disable the one or two problematic controls when multiple objects are selected than disable your entire inspector interface. Disabling the problematic controls lets the user continue to modify other attributes of the object, even when multiple objects are selected. </p><a name="//apple_ref/doc/uid/TP40004323-CH6-DontLinkElementID_13" title="Registering Your Inspector Objects"></a><h2>Registering Your Inspector Objects</h2><p>Before it can display your inspector interface, Interface Builder needs to know which objects use it. You provide this information by implementing the <code>ibPopulateAttributeInspectorClasses:</code> method on your custom object. In your implementation of this method, you add the list of inspector classes that can be used to edit your object to the provided array. Interface Builder then creates inspector objects based on the set of classes you return. </p><p>When implementing your <code>ibPopulateAttributeInspectorClasses:</code> method, be sure to call <code>super</code> before adding any custom classes to the <code>classes</code> array. The order in which you add classes to the array defines the resulting order of the inspector sections in the inspector window. The first class in the array appears at the bottom of the inspector window, while the last class appears at the top. This means that you should generally add any inherited inspectors first and add your custom inspectors after that. </p><p><span class="content_text">Listing 5-2</span> shows a sample implementation of the  <code>ibPopulateAttributeInspectorClasses:</code> method for a custom view. This view has a single custom inspector, called <code>MyInspector</code>, that it adds to the inherited inspector list.</p><a name="//apple_ref/doc/uid/TP40004323-CH6-SW3" title="Listing 5-2Returning the inspectors for an object"></a><p class="codesample"><strong>Listing 5-2&nbsp;&nbsp;</strong>Returning the inspectors for an object</p><div class="codesample"><table><tr><td scope="row"><pre>@implementation MyCustomView (InspectorIntegration)<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)ibPopulateAttributeInspectorClasses:(NSMutableArray *)classes<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [super ibPopulateAttributeInspectorClasses:classes];<span></span></pre></td></tr><tr><td scope="row"><pre>    [classes addObject:[MyInspector class]];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>For more information about the <code><!--a target="_top" -->ibPopulateAttributeInspectorClasses<!--/a--></code> method, see <em><a href="../../../Reference/NSObjectIBAdditions_Reference/index.html#//apple_ref/doc/uid/TP40004459" target="_top">NSObject Interface Builder Kit Additions Reference</a></em>. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ThePlug-inObject/ThePlug-inObject.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AdvancedTechniques/AdvancedTechniques.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-07-18<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/IBPlugInGuide/CreatingInspectors/CreatingInspectors.html%3Fid%3DTP40004323-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/IBPlugInGuide/CreatingInspectors/CreatingInspectors.html%3Fid%3DTP40004323-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/IBPlugInGuide/CreatingInspectors/CreatingInspectors.html%3Fid%3DTP40004323-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>