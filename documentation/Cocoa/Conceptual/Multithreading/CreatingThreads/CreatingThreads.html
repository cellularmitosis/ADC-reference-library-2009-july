<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Threading Programming Guide: Creating and Managing Threads</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Creating and Managing Threads"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/10000057i-CH15" title="Creating and Managing Threads"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ProcessManagement-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000456" target="_top">Process Management</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1">Threading Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../OperationObjects/OperationObjects.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ThreadSafety/ThreadSafety.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/10000057i-CH15-SW2" title="Creating and Managing Threads"></a><h1>Creating and Managing Threads</h1><p>In Mac OS X, each process (application) is made up of one or more threads. Each thread represents a single stream of execution for the application's code. Every application starts with a single thread, which runs the application's <code>main</code> function. Applications can spawn additional threads, each of which executes the code of a specific function.</p><p>When an application spawns a new thread, that thread becomes an independent entity inside of the application's process space. Each thread has its own execution stack and is scheduled for runtime separately by the kernel. A thread can communicate with other threads and other processes, perform I/O operations, and do anything else you might need it to do. Because they are inside the same process space, however, all threads in a single application share the same virtual memory space and have the same access rights as the process itself. </p><p>This chapter provides an overview of the thread technologies available in Mac OS X and examples of how to use those technologies in your applications.</p><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH15-SW18" title="Note"></a><p><strong>Note:</strong>&nbsp;For a historical look at the threading architecture of Mac OS, and for additional background information on threads, see Technical Note TN2028, “Threading Architectures”.</p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW16">About Mac OS X Threads</a>
				
			<br/>
			
        
			
			
				<a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW19">Creating a Thread</a>
				
			<br/>
			
        
			
			
				<a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-125024-BAJGFJED">Creating POSIX Threads in a Cocoa Application</a>
				
			<br/>
			
        
			
			
				<a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW8">Configuring Threads</a>
				
			<br/>
			
        
			
			
				<a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW10">Terminating a Thread</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/10000057i-CH15-SW16" title="About Mac OS X Threads"></a><h2>About Mac OS X Threads</h2><p>In Mac OS X, threads are a low-level way to facilitate multiple streams of execution in a single application. Although not as sophisticated as operation objects, threads are a common paradigm on most operating systems and so are familiar to most developers. The following sections describe the thread technologies available in Mac OS X and platform-specific information about those technologies.  </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW17" title="Threading Technologies"></a><h3>Threading Technologies</h3><p>Although the underlying implementation mechanism for threads in Mac OS X is Mach threads, you rarely (if ever) work with threads at the Mach level. Instead, you usually use the more convenient POSIX API or one of its derivatives. The Mach implementation does provide the basic features of all threads, however, including a preemptive execution model and the ability to schedule threads so they are independent of each other. </p><p><span class="content_text">Table 3-1</span> lists the threading technologies you can use in your applications. This list does not cover thread-related technologies, such as <code>NSOperation</code>, which use threads internally to implement program concurrency. Those technologies are covered in other chapters of this document.  </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW1" title="Table 3-1Mac OS X thread technologies"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-1&nbsp;&nbsp;</strong>Mac OS X thread technologies</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Technology</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Cocoa threads </p></td><td ><p>Cocoa implements threads using the <code>NSThread</code> class. Cocoa also provides methods on <code>NSObject</code> for spawning new threads and executing code on already-running threads. For more information, see <span class="content_text"><a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW11">“Using NSThread”</a></span> and <span class="content_text"><a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW13">“Using NSObject to Spawn a Thread.”</a></span></p></td></tr><tr><td  scope="row"><p>POSIX threads</p></td><td ><p>POSIX threads provide a C-based interface for creating threads. If you are not writing a Cocoa application, this is the best choice for creating threads. The POSIX interface is relatively simple to use and offers ample flexibility for configuring your threads. For more information, see <span class="content_text"><a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW12">“Using POSIX Threads”</a></span> </p></td></tr><tr><td  scope="row"><p>Multiprocessing Services</p></td><td ><p>Multiprocessing Services is a legacy C-based interface used by applications transitioning from older versions of Mac OS. You should avoid using this technology for any new development. Instead, you should use the <code>NSThread</code> class or POSIX threads. For more information about this technology, see <em><a href="../../../../Carbon/Conceptual/Multitasking_MultiproServ/index.html#//apple_ref/doc/uid/TP40000853" target="_top">Multiprocessing Services Programming Guide</a></em>. </p></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH15-SW27" title="Note"></a><p><strong>Note:</strong>&nbsp;Another threading technology found in some versions of Mac OS X is the Carbon Thread Manager. It is a legacy technology, however, that should not be used for any active development.</p></div><p>Mac OS X supports all of the standard features found in the POSIX threads implementation, including the following:</p><ul class="spaceabove"><li class="li"><p>Thread customization; see <span class="content_text"><a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW8">“Configuring Threads”</a></span></p></li><li class="li"><p>Support for creating threads as joinable or detached; see <span class="content_text"><a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW3">“Setting the Detached State of a Thread”</a></span> </p></li><li class="li"><p>Per-thread storage; see <span class="content_text"><a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW4">“Configuring Thread-Local Storage”</a></span></p></li><li class="li"><p>Support for thread cancellation semantics; see <span class="content_text"><a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW10">“Terminating a Thread”</a></span></p></li></ul><a name="//apple_ref/doc/uid/10000057i-CH15-SW7" title="Thread Costs"></a><h3>Thread Costs</h3><p>Threading has a real cost to your program (and the system) in terms of memory use and performance. Each thread in Mac OS X requires the allocation of memory in both the kernel memory space and your program’s memory space. The core structures needed to manage your thread and coordinate its scheduling are stored in the kernel using wired memory. Your thread’s stack space and per-thread data is stored in your program’s memory space. Most of these structures are created and initialized when you first create the thread—a process that can be relatively expensive because of the required interactions with the kernel.  </p><p><span class="content_text">Table 3-2</span> quantifies the approximate costs associated with creating a new user-level thread in your application. Some of these costs are configurable, such as the amount of stack space allocated for secondary threads. The time-based costs in particular are rough approximations and should be used only for relative comparisons with each other. Things like thread and lock creation times can vary greatly depending on processor load, the speed of the computer, and the amount of available system and program memory.</p><a name="//apple_ref/doc/uid/10000057i-CH15-SW5" title="Table 3-2Thread creation costs"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-2&nbsp;&nbsp;</strong>Thread creation costs</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Item</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Approximate cost</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Notes</p></th></tr><tr><td  scope="row"><p>Kernel data structures</p></td><td ><p>Approximately 1 KB</p></td><td ><p>This memory is used to store the thread data structures and attributes, much of which is allocated as wired memory and therefore cannot be paged to disk.<a name="//apple_ref/doc/uid/10000057i-CH15-DontLinkElementID_11"></a></p></td></tr><tr><td  scope="row"><p>Stack space</p></td><td ><p>512 KB (secondary threads)</p><p>8 MB (main thread</p></td><td ><p>The minimum allowed stack size for secondary threads is 16 KB and the stack size must be a multiple of 4 KB. The space for this memory is set aside in your process space at thread creation time, but the actual pages associated with that memory are not created until they are needed. <a name="//apple_ref/doc/uid/10000057i-CH15-DontLinkElementID_12"></a><a name="//apple_ref/doc/uid/10000057i-CH15-DontLinkElementID_13"></a></p></td></tr><tr><td  scope="row"><p>Creation time</p></td><td ><p>Approximately 90 microseconds</p></td><td ><p>This value reflects the time between the initial call to create the thread and the time at which the thread’s entry point routine began executing. The figures were determined by analyzing the mean and median values generated during thread creation on an Intel-based iMac with a 2 GHz Core Duo processor and 1 GB of RAM.</p></td></tr><tr><td  scope="row"><p>Mutex acquisition time</p></td><td ><p>Approximately 0.2 microseconds</p></td><td ><p>This is the lock acquisition time in an uncontested case. If the lock is held by another thread, the acquisition time can be much greater. The figures were determined by analyzing the mean and median values generated during mutex acquisition on an Intel-based iMac with a 2 GHz Core Duo processor and 1 GB of RAM.</p></td></tr><tr><td  scope="row"><p>Atomic compare-and-swap</p></td><td ><p>Approximately 0.05 microseconds</p></td><td ><p>This is the compare-and-swap time in an uncontested case. The figures were determined by analyzing the mean and median values for the operation and were generated on an Intel-based iMac with a 2 GHz Core Duo processor and 1 GB of RAM.</p></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH15-SW28" title="Note"></a><p><strong>Note:</strong>&nbsp;Because of their underlying kernel support, operation objects can often create threads more quickly. Rather than creating threads from scratch every time, they use pools of threads already residing in the kernel to save on allocation time. For more information about using operation objects, see <span class="content_text"><a href="../OperationObjects/OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW1">“Creating and Managing Operation Objects.”</a></span>  </p></div><p>Another cost to consider when writing threaded code is the production costs. Designing a threaded application can sometimes require fundamental changes to the way you organize your application’s data structures. Making those changes might be necessary to avoid the use of synchronization, which can itself impose a tremendous performance penalty on poorly designed applications. Designing those data structures, and debugging problems in threaded code, can increase the time it takes to develop a threaded application. Avoiding those costs can create bigger problems at runtime, however, if your threads spend too much time waiting on locks or doing nothing.</p><a name="//apple_ref/doc/uid/10000057i-CH15-SW19" title="Creating a Thread"></a><h2>Creating a Thread</h2><p>Creating low-level threads is relatively simple. In all cases, you must have a function or method to act as your thread’s main entry point and you must use one of the available thread routines to start your thread. The following sections show the basic creation process for the more commonly used thread technologies. Threads created using these techniques inherit a default set of attributes, determined by the technology you use. For information on how to configure your threads, see <span class="content_text"><a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW8">“Configuring Threads.”</a></span>  </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW11" title="Using NSThread"></a><h3>Using NSThread</h3><p>There are two ways to create a thread using the <code>NSThread</code> class:</p><ul class="spaceabove"><li class="li"><p>Use the <code>detachNewThreadSelector:toTarget:withObject:</code> class method to spawn the new thread.</p></li><li class="li"><p>Create a new <code>NSThread</code> object and call its <code>start</code> method. (Supported only in Mac OS X v10.5 and later.)</p></li></ul><p>Both techniques create a detached thread in your application. A detached thread means that the thread’s resources are automatically reclaimed by the system when the thread exits. It also means that your code does not have to join explicitly with the thread later. </p><p>Because the <code>detachNewThreadSelector:toTarget:withObject:</code> method is supported in all versions of Mac OS X, it is more frequently used than the other technique. To detach a new thread, you simply provide the name of the method (specified as a selector) that you want to use as the thread entry point along with the object that defines that method and any data you want to pass to the thread. The following example shows a basic invocation of this method that spawns a thread using a custom method of the current object.  </p><div class="codesample"><table><tr><td scope="row"><pre>[NSThread detachNewThreadSelector:@selector(myThreadMainMethod:) toTarget:self withObject:nil];<span></span></pre></td></tr></table></div><p>Prior to Mac OS X v10.5, you used the <code>NSThread</code> class primarily to spawn threads. Although you could get an <code>NSThread</code> object and access some thread attributes, you could only do so from the thread itself after it was running. In Mac OS X v10.5, support was added for creating <code>NSThread</code> objects without a running thread. This support made it possible to get and set various thread attributes prior to starting the thread. It also made it possible to use that thread object later to refer to the running thread.  </p><p>The simple way to initialize an <code>NSThread</code> object is to use the <code>initWithTarget:selector:object:</code> method. This method takes the exact same information as the <code>detachNewThreadSelector:toTarget:withObject:</code> method and uses it to initialize a new <code>NSThread</code> instance. It does not start the thread, however. To start the thread, you call the thread object’s <code>start</code> method explicitly, as shown in the following example: </p><div class="codesample"><table><tr><td scope="row"><pre>NSThread* myThread = [[NSThread alloc] initWithTarget:self<span></span></pre></td></tr><tr><td scope="row"><pre>                                        selector:@selector(myThreadMainMethod:)<span></span></pre></td></tr><tr><td scope="row"><pre>                                        object:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>[myThread start];<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH15-SW29" title="Note"></a><p><strong>Note:</strong>&nbsp;An alternative to using the <code>initWithTarget:selector:object:</code> method is to subclass <code>NSThread</code> and override its <code>main</code> method. You would use the overridden version of this method to implement your thread’s main entry point. For more information, see the subclassing notes in <em><a href="../../../Reference/Foundation/Classes/NSThread_Class/index.html#//apple_ref/doc/uid/TP40003746" target="_top">NSThread Class Reference</a></em>. </p></div><p>If you have an <code>NSThread</code> object whose thread is currently running, one way you can send messages to that thread is to use the <code>performSelector:onThread:withObject:waitUntilDone:</code> method of almost any object in your application. Support for performing selectors on threads (other than the main thread) was introduced in Mac OS X v10.5 and is a convenient way to communicate between threads. The messages you send using this technique are executed directly by the other thread as part of its normal run-loop processing. (Of course, this does mean that the target thread has to be running in its run loop, but that is a relatively straightforward matter; see <span class="content_text"><a href="../RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">“Run Loop Management.”</a></span>) You may still need some form of synchronization when you communicate this way, but it is still simpler than setting up communications ports between the threads. </p><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH15-SW30" title="Note"></a><p><strong>Note:</strong>&nbsp;Although good for occasional communication between threads, you should not use the  <code>performSelector:onThread:withObject:waitUntilDone:</code> method for time critical or frequent communication between threads. </p></div><p>For a list of other thread communication options, see <span class="content_text"><a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW3">“Setting the Detached State of a Thread.”</a></span> </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW12" title="Using POSIX Threads"></a><h3>Using POSIX Threads</h3><p>Mac OS X provides C-based support for creating threads using the POSIX thread API. This technology can actually be used in any type of Mac OS X application (including Cocoa applications) and might be more convenient if you are writing your software for multiple platforms. The POSIX routine you use to create threads is called, appropriately enough, <code>pthread_create</code>. </p><p><span class="content_text">Listing 3-1</span> shows two custom functions for creating a thread using POSIX calls. The <code>LaunchThread</code> function creates a new thread whose main routine is implemented in the <code>PosixThreadMainRoutine</code> function. The new thread is created as a detached thread in the following example. The default attribute set for POSIX results in the creation of joinable threads. Marking the thread as detached gives the system a chance to reclaim the resources for that thread immediately when it exits.  </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW6" title="Listing 3-1Creating a thread in C"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>Creating a thread in C</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;assert.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;pthread.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// The thread entry point routine.<span></span></pre></td></tr><tr><td scope="row"><pre>void* PosixThreadMainRoutine(void* data)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Do some work here.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void LaunchThread()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the thread using POSIX routines.<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_attr_t  attr;<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_t       posixThreadID;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    assert(!pthread_attr_init(&amp;attr));<span></span></pre></td></tr><tr><td scope="row"><pre>    assert(!pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    int     threadError = pthread_create(&amp;posixThreadID, &amp;attr, &amp;PosixThreadMainRoutine, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    assert(!pthread_attr_destroy(&amp;attr));<span></span></pre></td></tr><tr><td scope="row"><pre>    if (threadError != 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>         // Report an error.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If you add the code from the preceding listing to one of your source files and call the <code>LaunchThread</code> function, it would create a new detached thread in your application. Of course, new threads created using this code would not do anything useful. The threads would launch and almost immediately exit. To make things more interesting, you would need to add code to the <code>PosixThreadMainRoutine</code> function to do some actual work. To ensure that a thread knows what work to do, you can pass it a pointer to some data at creation time. You pass this pointer as the last parameter of the <code>pthread_create</code> function. </p><p>To communicate information from your newly created thread back to your application’s main thread, you need to establish a communications path between the target threads. For C-based applications, there are several ways to communicate between threads, including the use of ports, conditions, or shared memory. For long-lived threads, you should almost always set up some sort of interthread communications mechanism to give your application’s main thread a way to check the status of the thread or shut it down cleanly when the application exits. </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW13" title="Using NSObject to Spawn a Thread"></a><h3>Using NSObject to Spawn a Thread</h3><p>In Mac OS X v10.5 and later, all objects have the ability to spawn a new thread and use it to execute one of their methods. The <code>performSelectorInBackground:withObject:</code> method creates a new detached thread and uses the specified method as the entry point for the new thread. For example, if you have some object (represented by the variable <code>myObj</code>) and that object has a method called <code>doSomething</code> that you want to run in a background thread, you could could use the following code to do that: </p><div class="codesample"><table><tr><td scope="row"><pre>[myObj performSelectorInBackground:@selector(doSomething) withObject:nil];<span></span></pre></td></tr></table></div><p>The effect of calling this method is the same as if you called the <code>detachNewThreadSelector:toTarget:withObject:</code> method of <code>NSThread</code> with the current object, selector, and parameter object as parameters. The new thread is spawned immediately using the default configuration and begins running. Inside the selector, you must configure the thread just as you would any thread. For example, you would need to set up an autorelease pool (if you were not using garbage collection) and configure the thread’s run loop if you planned to use it. For information on how to configure new threads, see <span class="content_text"><a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW8">“Configuring Threads.”</a></span> </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW20" title="Using Other Threading Technologies"></a><h3>Using Other Threading Technologies</h3><p>Although the POSIX routines and <code>NSThread</code> class are the recommended technologies to use for creating low-level threads, Mac OS X does include other C-based technologies. Of these, the only other one you might consider using is Multiprocessing Services, which is itself implemented on top of POSIX threads. Multiprocessing Services was developed originally for earlier versions of Mac OS and was later made available for Carbon applications in Mac OS X. If you have existing code that uses this technology, you can continue to use it, although you should also consider porting your thread-related code to POSIX. </p><p>For information on how to use Multiprocessing Services, see <em><a href="../../../../Carbon/Conceptual/Multitasking_MultiproServ/index.html#//apple_ref/doc/uid/TP40000853" target="_top">Multiprocessing Services Programming Guide</a></em>. </p><a name="//apple_ref/doc/uid/20000738-125024" title="Creating POSIX Threads in a Cocoa Application"></a><a name="//apple_ref/doc/uid/10000057i-CH15-125024-BAJGFJED" title="Creating POSIX Threads in a Cocoa Application"></a><h2>Creating POSIX Threads in a Cocoa Application</h2><p>Although the <code>NSThread</code> class is the main interface for creating threads in Cocoa applications, you are free to use POSIX threads instead if doing so is more convenient for you. For example, you might use POSIX threads if you already have code that uses them and you do not want to rewrite it. If you do plan to use the POSIX threads in a Cocoa application, you should still be aware of the interactions between Cocoa and threads and obey the guidelines in the following sections.  </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW21" title="Protecting the Cocoa Frameworks"></a><h3>Protecting the Cocoa Frameworks</h3><p>For multithreaded applications, Cocoa frameworks use locks and other forms of internal synchronization to ensure they behave correctly. To prevent these locks from degrading performance in the single-threaded case, however, Cocoa does not create them until the application spawns its first new thread using the <code>NSThread</code> class. If you spawn threads using only POSIX thread routines, Cocoa does not receive the notifications it needs to know that your application is now multithreaded. When that happens, operations involving the Cocoa frameworks may destabilize or crash your application. </p><p>To let Cocoa know that you intend to use multiple threads, all you have to do is spawn a single thread using the <code>NSThread</code> class and let that thread immediately exit. Your thread entry point need not do anything. Just the act of spawning a thread using <code>NSThread</code> is enough to ensure that the locks needed by the Cocoa frameworks are put in place. </p><p>If you are not sure if Cocoa thinks your application is multithreaded or not, you can use the <code><a href="../../../Reference/Foundation/Classes/NSThread_Class/Reference/Reference.html#//apple_ref/occ/clm/NSThread/isMultiThreaded" target="_top">isMultiThreaded</a></code> method of <code>NSThread</code> to check. </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW22" title="Supporting Autoreleased Objects"></a><h3>Supporting Autoreleased Objects</h3><p>If your code does not require garbage collection, and you plan to create Cocoa objects, each thread you create must have an autorelease pool. Creating an autorelease pool at the beginning of your thread’s main entry routine is a standard procedure regardless of which technology you use to create the thread. For more information, see <span class="content_text"><a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW14">“Memory Management in Threads.”</a></span>  </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW23" title="Mixing POSIX and Cocoa Locks"></a><h3>Mixing POSIX and Cocoa Locks</h3><p>It is safe to use a mixture of POSIX and Cocoa locks inside the same application. Cocoa lock and condition objects are essentially just wrappers for POSIX mutexes and conditions. For a given lock, however, you must always use the same interface to create and manipulate that lock. In other words, you cannot use a Cocoa <code>NSLock</code> object to manipulate a mutex you created using the <code>pthread_mutex_init</code> function, and vice versa.</p><a name="//apple_ref/doc/uid/10000057i-CH15-SW8" title="Configuring Threads"></a><h2>Configuring Threads</h2><p>After you create a thread, and sometimes before, you may want to configure different portions of the thread environment. The following sections describe some of the changes you can make and when you might make them. </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW24" title="Configuring the Stack Size of a Thread"></a><h3>Configuring the Stack Size of a Thread</h3><p>For each new thread you create, Mac OS X allocates a specific amount of memory in your process space to act as the stack for that thread. The stack manages the stack frames and is also where any local variables for the thread are declared. The amount of memory allocated for threads is listed in <span class="content_text"><a href="CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW7">“Thread Costs.”</a></span> </p><p>If you want to change the stack size of a given thread, you must do so before you create the thread. All of the threading technologies provide some way of setting the stack size, although setting the stack size using <code>NSThread</code> is available only in Mac OS X v10.5 and later. <span class="content_text">Table 3-3</span> lists the different options for each technology. </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW9" title="Table 3-3Setting the stack size of a thread"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-3&nbsp;&nbsp;</strong>Setting the stack size of a thread</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Technology</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Option</p></th></tr><tr><td  scope="row"><p>Cocoa</p></td><td ><p>In Mac OS X v10.5 and later, allocate and initialize an <code>NSThread</code> object (do not use the <code>detachNewThreadSelector:toTarget:withObject:</code> method). Before calling the <code>start</code> method of the thread object, use the <code>setStackSize:</code> method to specify the new stack size. </p></td></tr><tr><td  scope="row"><p>POSIX</p></td><td ><p>Create a new <code>pthread_attr_t</code> structure and use the <code>pthread_attr_setstacksize</code> function to change the default stack size. Pass the attributes to the <code>pthread_create</code> function when creating your thread. </p></td></tr><tr><td  scope="row"><p>Multiprocessing Services</p></td><td ><p>Pass the appropriate stack size value to the <code>MPCreateTask</code> function when you create your thread. </p></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH15-SW14" title="Memory Management in Threads"></a><h3>Memory Management in Threads</h3><p>Because threads share the memory space of your process, memory management is usually the same for threads as it is for the rest of your program. In other words, you can continue to use malloc package or the Cocoa memory management techniques you would use in a single-threaded application. </p><p>If you are writing a Cocoa application, however, there is one additional aspect to threaded programming that you must handle. If your code uses the traditional reference counting model to retain and release objects, as opposed to using garbage collection, you must create an autorelease pool for each of your custom threads that uses Cocoa. You must always create an autorelease pool before performing any operation where the <code>autorelease</code> method of an object might be called. This usually means creating the <code>NSAutoreleasePool</code> object as the first step in your thread’s main entry routine and deleting it as the last step, as shown in the following example: </p><div class="codesample"><table><tr><td scope="row"><pre>- (void)myThreadMainRoutine<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Do thread work here.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [pool release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If your project requires the use of garbage collection, an autorelease pool is not necessary for secondary threads. If garbage collection is optional or not used, however, you must create one. The presence of an autorelease pool in a garbage-collected application is not harmful, and for the most part is simply ignored.</p><p>For more information on memory management and autorelease pools in Cocoa applications, see <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em>. </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW4" title="Configuring Thread-Local Storage"></a><h3>Configuring Thread-Local Storage</h3><p>Each thread maintains a dictionary of key-value pairs that can be accessed from anywhere in the thread. You can use this dictionary to store information that you want to persist throughout the execution of your thread. For example, you could use it to store state information that you want to persist through multiple iterations of your thread’s run loop. </p><p>Cocoa and POSIX store the thread dictionary in different ways, so you cannot mix and match calls to the two technologies. As long as you stick with one technology inside your thread code, however, the end results should be similar. In Cocoa, you use the <code>threadDictionary</code> method of an <code>NSThread</code> object to retrieve an <code>NSMutableDictionary</code> object, to which you can add any keys required by your thread. In POSIX, you use the <code>pthread_setspecific</code> and <code>pthread_getspecific</code> functions to set and get the keys and values of your thread. </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW25" title="Setting Up a Run Loop"></a><h3>Setting Up a Run Loop</h3><p>When writing code you want to run on a separate thread, you have two options. The first option is to write the code for a thread as one long task to be performed with little or no interruption, and have the thread exit when it finishes. The second option is put your thread into a loop and have it process requests dynamically as they arrive. The first option requires no special setup for your code; you just start doing the work you want to do. The second option, however, involves setting up your thread’s run loop. </p><p>Mac OS X provides built-in support for implementing run loops in every thread. Cocoa and Carbon start the run loop of your application’s main thread automatically, but if you create any secondary threads, you must configure the run loop and start it manually. </p><p>For information on using and configuring run loops, see <span class="content_text"><a href="../RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">“Run Loop Management.”</a></span> </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW3" title="Setting the Detached State of a Thread"></a><h3>Setting the Detached State of a Thread</h3><p>Most Mac OS X high-level thread technologies create detached threads by default. In most cases, detached threads are preferred because they allow the system to free up the thread’s data structures immediately upon completion of the thread. Detached threads also do not require explicit interactions with your program. The means of retrieving results from the thread is left to your discretion. By comparison, the system does not reclaim the resources for joinable threads until another thread explicitly joins with that thread, a process which may block the thread that performs the join. </p><p>You can think of joinable threads as akin to child threads. Although they still run as independent threads, a joinable thread must be joined by another thread before its resources can be reclaimed by the system. Joinable threads also provide an explicit way to pass data from an exiting thread to another thread. Just before it exits, a joinable thread can pass a data pointer or other return value to the <code>pthread_exit</code> function. Another thread can then claim this data by calling the <code>pthread_join</code> function. </p><div class="importantbox"><a name="//apple_ref/doc/uid/10000057i-CH15-DontLinkElementID_6" title="Important:"></a><p><strong>Important:</strong>&nbsp;At application exit time, detached threads can be terminated immediately but joinable threads cannot. Each joinable thread must be joined before the process is allowed to exit. Joinable threads may therefore be preferable in cases where the thread is doing critical work that should not be interrupted, such as saving data to disk. </p><p></p></div><p>If you do want to create joinable threads, the only way to do so is using POSIX threads. POSIX creates threads as joinable by default. To mark a thread as detached or joinable, modify the thread attributes using the <code>pthread_attr_setdetachstate</code> function prior to creating the thread. After the thread begins, you can change a joinable thread to a detached thread by calling the <code>pthread_detach</code> function. For more information about these POSIX thread functions, see the <code><a href="../../../../Darwin/Reference/ManPages/man3/pthread.3.html#//apple_ref/doc/man/3/pthread" target="_top">pthread</a></code> man page. For information on how to join with a thread, see the <code><a href="../../../../Darwin/Reference/ManPages/man3/pthread_join.3.html#//apple_ref/doc/man/3/pthread_join" target="_top">pthread_join</a></code> man page.</p><a name="//apple_ref/doc/uid/10000057i-CH15-SW26" title="Setting the Thread Priority"></a><h3>Setting the Thread Priority</h3><p>Any new thread you create has a default priority associated with it. The kernel’s scheduling algorithm takes thread priorities into account when determining which threads to run, with higher priority threads being more likely to run than threads with lower priorities. Higher priorities do not guarantee a specific amount of execution time for your thread, just that it is more likely to be chosen by the scheduler when compared to lower-priority threads. </p><div class="importantbox"><a name="//apple_ref/doc/uid/10000057i-CH15-DontLinkElementID_7" title="Important:"></a><p><strong>Important:</strong>&nbsp;It is generally a good idea to leave the priorities of your threads at their default values. Increasing the priorities of some threads also increases the likelihood of starvation among lower-priority threads. If your application contains high-priority and low-priority threads that must interact with each other, the starvation of lower-priority threads may block other threads and create performance bottlenecks.</p><p></p></div><p>If you do want to modify thread priorities, both Cocoa and POSIX provide a way to do so. For Cocoa threads, you can use the <code>setThreadPriority:</code> class method of <code>NSThread</code> to set the priority of the currently running thread. For POSIX threads, you use the <code>pthread_setschedparam</code> function. For more information, see <em><a href="../../../Reference/Foundation/Classes/NSThread_Class/index.html#//apple_ref/doc/uid/TP40003746" target="_top">NSThread Class Reference</a></em> or <code><a href="../../../../Darwin/Reference/ManPages/man3/pthread_setschedparam.3.html#//apple_ref/doc/man/3/pthread_setschedparam" target="_top">pthread_setschedparam</a></code> man page.</p><a name="//apple_ref/doc/uid/10000057i-CH15-SW10" title="Terminating a Thread"></a><h2>Terminating a Thread</h2><p>The recommended way to exit a thread is to let it exit its entry point routine normally. Although Cocoa, POSIX, and Multiprocessing Services offer routines for killing threads directly, the use of such routines is strongly discouraged. Killing a thread prevents that thread from cleaning up after itself. Memory allocated by the thread could potentially be leaked and any other resources currently in use by the thread might not be cleaned up properly, creating potential problems later. </p><p>If you anticipate the need to terminate a thread in the middle of an operation, you should design your threads from the outset to respond to a cancel or exit message. For long-running operations, this might mean stopping work periodically and checking to see if such a message arrived. If a message does come in asking the thread to exit, the thread would then have the opportunity to perform any needed cleanup and exit gracefully; otherwise, it could simply go back to work and process the next chunk of data.</p><p>One way to respond to cancel messages is to use a run loop input source to receive such messages. <span class="content_text">Listing 3-2</span> shows the structure of how this code might look in your thread’s main entry routine. (The example shows the main loop portion only and does not include the steps for setting up an autorelease pool or configuring the actual work to do.) The example installs a custom input source on the run loop that presumably can be messaged from another one of your threads; for information on setting up input sources, see <span class="content_text"><a href="../RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW7">“Configuring Run Loop Sources.”</a></span> After performing a portion of the total amount of work, the thread runs the run loop briefly to see if a message arrived on the input source. If not, the run loop exits immediately and the loop continues with the next chunk of work. Because the handler does not have direct access to the <code>exitNow</code> local variable, the exit condition is communicated through a key-value pair in the thread dictionary. </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW15" title="Listing 3-2Checking for an exit condition during a long job"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>Checking for an exit condition during a long job</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)threadMainRoutine<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL moreWorkToDo = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL exitNow = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRunLoop* runLoop = [NSRunLoop currentRunLoop];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Add the exitNow BOOL to the thread dictionary.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableDictionary* threadDict = [[NSThread currentThread] threadDictionary];<span></span></pre></td></tr><tr><td scope="row"><pre>    [threadDict setValue:[NSNumber numberWithBool:exitNow] forKey:@"ThreadShouldExitNow"];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Install an input source.<span></span></pre></td></tr><tr><td scope="row"><pre>    [self myInstallCustomInputSource];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while (moreWorkToDo &amp;&amp; !exitNow)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Do one chunk of a larger body of work here.<span></span></pre></td></tr><tr><td scope="row"><pre>        // Change the value of the moreWorkToDo Boolean when done.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Run the run loop but timeout immediately if the input source isn't waiting to fire.<span></span></pre></td></tr><tr><td scope="row"><pre>        [runLoop runUntilDate:[NSDate date]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Check to see if an input source handler changed the exitNow value.<span></span></pre></td></tr><tr><td scope="row"><pre>        exitNow = [[threadDict valueForKey:@"ThreadShouldExitNow"] boolValue];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../OperationObjects/OperationObjects.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ThreadSafety/ThreadSafety.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>