<HTML><HEAD>	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">	<META NAME="Generator" CONTENT="Microsoft Word 73.1">	<TITLE>Should You Program in the Kernel?</TITLE></HEAD><body bgcolor="white"><a name="//apple_ref/doc/uid/TP30001137"></a><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header -->		<br><!-- start of path --> <font face="Geneva,Helvetica,Arial" size="1"><b><br>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Documentation</a> &gt; <a href="../index.html#//apple_ref/doc/uid/TP30000422" target="_top">Darwin &amp; Core OS</a> <b>&gt;</b> Should You Program in the Kernel?</font> <!-- end of path --> <br><br><hr alt=""><H1>Should You Program in the Kernel?</H1><P>If you are thinking of writing code for the kernel environment, think carefully. Programming in the kernel can be a difficult and dangerous task. And often there is a way to accomplish what you want to do without touching the kernel.</P><P>Software that resides in the kernel tends to be expensive. Kernel code is "wired" into physical memory and thus cannot be paged out by the virtual memory system. As more code is put into the kernel, less physical memory is available to user-space processes. Consequently, paging activity will probably intensify, thereby degrading system performance. </P><P>Kernel code is also inherently destabilizing, much more so than application code.  The kernel environment is a single process, and this means that there is no memory protection between your extension or driver and anything else in the kernel. Access memory in the wrong place and&#150;boom&#150; the entire system can grind to a halt, a victim of a kernel panic. Moreover, because  kernel code usually provides services to numerous user-space clients, any inefficiencies in the code can be propagated to those clients,  thereby affecting the system globally.</P><P>Finally, kernel software is a real pain to write. There are subtleties to grapple with unknown in the realm of application development. And because the tools for kernel development are in an early stage of maturity, bugs in kernel code are harder to find than in user-space software.</P><P>With all this in mind, the message is clear. It is in everyone's best interest to put as little code as possible into the kernel. And any code that ends up in the kernel should be honed and rigorously tested.</P><P>&nbsp;</P><H2>When Code Should Reside In the Kernel</H2><P>A handful of situations warrant loading a driver or extension into the kernel environment:</P><UL><LI>The software is used by the operating system itself.<LI>Multiple user-space programs will frequently use the software.<LI>The software needs to respond directly to primary interrupts (those delivered by the CPU's interrupt controller).</UL><P>If the software you are writing does not match any of these criteria, it probably doesn't belong in the kernel. If your software is a driver for a disk, a network controller, or a keyboard, it should reside in the kernel. If it is an extension to the file system, it should live in the kernel. If, on the other hand, it is used only now and then by a single user-space program, it should be loaded by the program and reside within it. Drivers for printers and scanners fall into this latter category.</P><P>&nbsp;</P><H2>Alternatives to Kernel-Resident Code</H2><P>Apple provides a number of technologies that might let you accomplish what you want to do <I>and</I> stay out of the kernel. First are the higher-level APIs that give you some hardware-level access. For example, the CFNetwork and POSIX networking APIs are a powerful resource for many networking capabilities and Core Graphics (Quartz) enables you to do some fairly low-level things with the graphics subsystem.</P><P>Second, and just as important, is the "device interface" technology of the I/O Kit framework. Using a plug-in architecture, this technology makes it possible for your application to interact with the kernel to access most hardware. In addition, you can&#150;with a little help from the I/O Kit&#150;use POSIX APIs to access serial, storage, or network devices.</P><!--<P>&nbsp;</P><H2>Check the Roadmap</H2><P>To help you decide in what direction you should go to write your software, we have provided a <a href="../SiteInfo/Roadmap.html">Roadmap to Information</a>. This short document describes the structure of developer documentation for the Mac OS X kernel environment, suggests the prerequisite reading, and identifies the documents special to each particular type of driver or extension.</P>--><P>&nbsp;</P><P>&nbsp;</P></FONT><p><font face="Geneva,Helvetica,Arial" size="1">&#169; 2001 Apple Computer, Inc.</font></p></BODY></HTML>
