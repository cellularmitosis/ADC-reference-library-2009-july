<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>TE Over Background - /TESample.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">TE Over Background</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxGraphicsImaging-date.html" target="_blank">Carbon > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">TE Over Background</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/TESample.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/TESample.c</option>
<option value="listing2.html">/TESample.h</option>
<option value="listing3.html">/TESample.r</option>
<option value="listing4.html">/TESampleGlue.a</option>
<option value="listing5.html">/TESamplePPC.r</option></select>
				</p>
				</form>
				<p><strong><a href="TE_Over_Background.zip">Download Sample</a></strong> (&#147;TE_Over_Background.zip&#148;, 40.0K)<BR>
<strong><a href="TE_Over_Background.dmg">Download Sample</a></strong> (&#147;TE_Over_Background.dmg&#148;, 101.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*------------------------------------------------------------------------------##  Apple Macintosh Developer Technical Support##  MultiFinder-Aware Simple TextEdit Sample Application##  TESample##  This file: TESample.c  -  C Source##  Copyright &copy; 1989 Apple Computer, Inc.#  All rights reserved.##  Versions:  #        1.00        08/88#        1.01        11/88#        1.02        04/89#        1.03        06/89##  Components:#        TESample.p      June 1, 1989#        TESample.c      June 1, 1989#        TESampleGlue.a    June 1, 1989  -MPW only-#        TESample.r      June 1, 1989#        TESample.h      June 1, 1989#        PTESample.make    June 1, 1989  -MPW only-#        CTESample.make    June 1, 1989  -MPW only-#        TESampleGlue.s    June 1, 1989  -A/UX only-#        TESampleAUX.r    June 1, 1989  -A/UX only-#        Makefile      June 1, 1989  -A/UX only-##  TESample is an example application that demonstrates how #  to initialize the commonly used toolbox managers, operate #  successfully under MultiFinder, handle desk accessories and #  create, grow, and zoom windows. The fundamental TextEdit #  toolbox calls and TextEdit autoscroll are demonstrated. It #  also shows how to create and maintain scrollbar controls.##  It does not by any means demonstrate all the techniques you #  need for a large application. In particular, Sample does not #  cover exception handling, multiple windows/documents, #  sophisticated memory management, printing, or undo. All of #  these are vital parts of a normal full-sized application.##  This application is an example of the form of a Macintosh #  application; it is NOT a template. It is NOT intended to be #  used as a foundation for the next world-class, best-selling, #  600K application. A stick figure drawing of the human body may #  be a good example of the form for a painting, but that does not #  mean it should be used as the basis for the next Mona Lisa.##  We recommend that you review this program or Sample before #  beginning a new application. Sample is a simple app. which doesn't #  use TextEdit or the Control Manager.#------------------------------------------------------------------------------*//* Segmentation strategy:   This program consists of three segments. Main contains most of the code,   including the MPW libraries, and the main program. Initialize contains   code that is only used once, during startup, and can be unloaded after the   program starts. %A5Init is automatically created by the Linker to initialize   globals for the MPW libraries and is unloaded right away. *//* SetPort strategy:   Toolbox routines do not change the current port. In spite of this, in this   program we use a strategy of calling SetPort whenever we want to draw or   make calls which depend on the current port. This makes us less vulnerable   to bugs in other software which might alter the current port (such as the   bug (feature?) in many desk accessories which change the port on OpenDeskAcc).   Hopefully, this also makes the routines from this program more self-contained,   since they don't depend on the current port setting. *//* Clipboard strategy:   This program does not maintain a private scrap. Whenever a cut, copy, or paste   occurs, we import/export from the public scrap to TextEdit's scrap right away,   using the TEToScrap and TEFromScrap routines. If we did use a private scrap,   the import/export would be in the activate/deactivate event and suspend/resume   event routines. */#include &lt;Types.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;QDOffscreen.h&gt;#include &lt;Fonts.h&gt;#include &lt;Events.h&gt;#include &lt;Controls.h&gt;#include &lt;Windows.h&gt;#include &lt;Menus.h&gt;#include &lt;TextEdit.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Desk.h&gt;#include &lt;Scrap.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;Memory.h&gt;#include &lt;SegLoad.h&gt;#include &lt;Files.h&gt;#include &lt;OSUtils.h&gt;#include &lt;OSEvents.h&gt;#include &lt;Packages.h&gt;#include &lt;Traps.h&gt;#include &lt;Printing.h&gt;#include &lt;DiskInit.h&gt;#include &lt;Errors.h&gt;#include &lt;GestaltEqu.h&gt;#include &lt;AppleEvents.h&gt;#include &quot;TESample.h&quot;    /* bring in all the #defines for TESample *//* A DocumentRecord contains the WindowRecord for one of our document windows,   as well as the TEHandle for the text we are editing. Other document fields   can be added to this record as needed. For a similar example, see how the   Window Manager and Dialog Manager add fields after the GrafPort. */typedef struct {  WindowRecord  docWindow;  TEHandle    docTE;  ControlHandle  docVScroll;  ControlHandle  docHScroll;  TEClickLoopUPP  docClick;  GWorldPtr       docImage;} DocumentRecord, *DocumentPeek;/* The &quot;g&quot; prefix is used to emphasize that a variable is global. *//* GMac is used to hold the result of a SysEnvirons call. This makes   it convenient for any routine to check the environment. It is   global information, anyway. */SysEnvRec  gMac;        /* set up by Initialize *//* GHasWaitNextEvent is set at startup, and tells whether the WaitNextEvent   trap is available. If it is false, we know that we must call GetNextEvent. */Boolean    gHasWaitNextEvent;  /* set up by Initialize *//* GInBackground is maintained by our OSEvent handling routines. Any part of   the program can check it to find out if it is currently in the background. */Boolean    gInBackground;    /* maintained by Initialize and DoEvent *//* GNumDocuments is used to keep track of how many open documents there are   at any time. It is maintained by the routines that open and close documents. */short    gNumDocuments;    /* maintained by Initialize, DoNew, and DoCloseWindow */#if powercTEClickLoopUPP gClickLoopUPP;#endifControlActionUPP gHActionUPP;ControlActionUPP gVActionUPP;QDRectUPP        gQDRectUPP;QDRgnUPP         gQDRgnUPP;/* Here are declarations for all of the C routines. In MPW 3.0 we can use   actual prototypes for parameter type checking. A/UX C does not grok   prototypes, so eliminate them under A/UX */  void AlertUser( short error );  void EventLoop( void );  void DoEvent( EventRecord *event );  void AdjustCursor( Point mouse, RgnHandle region );  void GetGlobalMouse( Point *mouse );  void DoGrowWindow( WindowPtr window, EventRecord *event );  void DoZoomWindow( WindowPtr window, short part );  void ResizeWindow( WindowPtr window );  void GetLocalUpdateRgn( WindowPtr window, RgnHandle localRgn );  void DoUpdate( WindowPtr window );  void PaintImage( void );  void DoDeactivate( WindowPtr window );  void DoActivate( WindowPtr window, Boolean becomingActive );  void DoContentClick( WindowPtr window, EventRecord *event );  void DoKeyDown( EventRecord *event );  unsigned long GetSleep( void );  void CommonAction( ControlHandle control, short *amount );  pascal void VActionProc( ControlHandle control, short part );  pascal void HActionProc( ControlHandle control, short part );  void DoIdle( void );  void DrawWindow( WindowPtr window );  void AdjustMenus( void );  void DoMenuCommand( long menuResult );pascal void CustomRect(  GrafVerb verb,  Rect     *destRect);pascal void CustomRgn(  GrafVerb  verb,  RgnHandle destRgn);  void DoNew( void );  Boolean DoCloseWindow( WindowPtr window );  void Terminate( void );  void Initialize( void );  void BigBadError( short error );  void GetTERect( WindowPtr window, Rect *teRect );  void AdjustViewRect( TEHandle docTE );  void AdjustTE( WindowPtr window );  void AdjustHV( Boolean isVert, ControlHandle control, TEHandle docTE,          Boolean canRedraw );  void AdjustScrollValues( WindowPtr window, Boolean canRedraw );  void AdjustScrollSizes( WindowPtr window );  void AdjustScrollbars( WindowPtr window, Boolean needsResize );    #if powerc    pascal Boolean ClickLoopProc(TEPtr pTE);    #else    extern pascal void AsmClickLoopProc(void);    #endif    pascal void ClickLoopAddOn(void);    pascal TEClickLoopUPP GetOldClickLoop(void);  Boolean IsAppWindow( WindowPtr window );  Boolean IsDAWindow( WindowPtr window );  Boolean TrapAvailable( short tNumber);/* Define HiWrd and LoWrd macros for efficiency. */#define HiWrd(aLong)  (((aLong) &gt;&gt; 16) &amp; 0xFFFF)#define LoWrd(aLong)  ((aLong) &amp; 0xFFFF)/* Define TopLeft and BotRight macros for convenience. Notice the implicit   dependency on the ordering of fields within a Rect */#define TopLeft(aRect)  (* (Point *) &amp;(aRect).top)#define BotRight(aRect)  (* (Point *) &amp;(aRect).bottom)/* This routine is part of the MPW runtime library. This external   reference to it is done so that we can unload its segment, %A5Init. */#ifndef THINK_C  extern void _DataInit();#endif/* A reference to our assembly language routine that gets attached to the clikLoopfield of our TE record. */extern pascal void AsmClikLoop();#ifdef powerc   QDGlobals  qd;#endif#pragma segment Mainmain(){#ifndef THINK_C  UnloadSeg((Ptr) _DataInit);    /* note that _DataInit must not be in Main! */#endif    /* 1.01 - call to ForceEnvirons removed */    /*  If you have stack requirements that differ from the default,    then you could use SetApplLimit to increase StackSpace at     this point, before calling MaxApplZone. */  MaxApplZone();          /* expand the heap so code segments load at the top */  Initialize();          /* initialize the program */#ifndef THINK_C  UnloadSeg((Ptr) Initialize);  /* note that Initialize must not be in Main! */#endif  EventLoop();          /* call the main event loop */}/* Get events forever, and handle them by calling DoEvent.   Also call AdjustCursor each time through the loop. */#pragma segment Mainvoid EventLoop(){  RgnHandle  cursorRgn;  Boolean    gotEvent;  EventRecord  event;  Point    mouse;  cursorRgn = NewRgn();      /* we'll pass WNE an empty region the 1st time thru */  do {    /* use WNE if it is available */    if ( gHasWaitNextEvent ) {      GetGlobalMouse(&amp;mouse);      AdjustCursor(mouse, cursorRgn);      gotEvent = WaitNextEvent(everyEvent, &amp;event, GetSleep(), cursorRgn);    }    else {      SystemTask();      gotEvent = GetNextEvent(everyEvent, &amp;event);    }    if ( gotEvent ) {      /* make sure we have the right cursor before handling the event */      AdjustCursor(event.where, cursorRgn);      DoEvent(&amp;event);    }    else      DoIdle();        /* perform idle tasks when it's not our event */    /*  If you are using modeless dialogs that have editText items,      you will want to call IsDialogEvent to give the caret a chance      to blink, even if WNE/GNE returned FALSE. However, check FrontWindow      for a non-NIL value before calling IsDialogEvent. */  } while ( true );  /* loop forever; we quit via ExitToShell */} /*EventLoop*//* Do the right thing for an event. Determine what kind of event it is, and call the appropriate routines. */#pragma segment Mainvoid DoEvent(event)  EventRecord  *event;{  short    part, err;  WindowPtr  window;  char    key;  Point    aPoint;  switch ( event-&gt;what ) {    case nullEvent:      /* we idle for null/mouse moved events ands for events which aren't        ours (see EventLoop) */      DoIdle();      break;    case mouseDown:      part = FindWindow(event-&gt;where, &amp;window);      switch ( part ) {        case inMenuBar:             /* process a mouse menu command (if any) */          AdjustMenus();  /* bring 'em up-to-date */          DoMenuCommand(MenuSelect(event-&gt;where));          break;        case inSysWindow:           /* let the system handle the mouseDown */          SystemClick(event, window);          break;        case inContent:          if ( window != FrontWindow() ) {            SelectWindow(window);            /*DoEvent(event);*/  /* use this line for &quot;do first click&quot; */          } else            DoContentClick(window, event);          break;        case inDrag:                /* pass screenBits.bounds to get all gDevices */          DragWindow(window, event-&gt;where, &amp;qd.screenBits.bounds);          break;        case inGoAway:          if ( TrackGoAway(window, event-&gt;where) )            DoCloseWindow(window); /* we don't care if the user cancelled */          break;        case inGrow:          DoGrowWindow(window, event);          break;        case inZoomIn:        case inZoomOut:        if ( TrackBox(window, event-&gt;where, part) )            DoZoomWindow(window, part);          break;      }      break;    case keyDown:    case autoKey:                       /* check for menukey equivalents */      key = event-&gt;message &amp; charCodeMask;      if ( event-&gt;modifiers &amp; cmdKey ) {  /* Command key down */        if ( event-&gt;what == keyDown ) {          AdjustMenus();      /* enable/disable/check menu items properly */          DoMenuCommand(MenuKey(key));        }      } else        DoKeyDown(event);      break;    case activateEvt:      DoActivate((WindowPtr) event-&gt;message, (event-&gt;modifiers &amp; activeFlag) != 0);      break;    case updateEvt:      DoUpdate((WindowPtr) event-&gt;message);      break;    /*  1.01 - It is not a bad idea to at least call DIBadMount in response      to a diskEvt, so that the user can format a floppy. */    case diskEvt:      if ( HiWord(event-&gt;message) != noErr ) {        SetPt(&amp;aPoint, kDILeft, kDITop);        err = DIBadMount(aPoint, event-&gt;message);      }      break;    case kOSEvent:    /*  1.02 - must BitAND with 0x0FF to get only low byte */      switch ((event-&gt;message &gt;&gt; 24) &amp; 0x0FF) {    /* high byte of message */        case kMouseMovedMessage:          DoIdle();          /* mouse-moved is also an idle event */          break;        case kSuspendResumeMessage:    /* suspend/resume is also an activate/deactivate */          gInBackground = (event-&gt;message &amp; kResumeMask) == 0;          DoActivate(FrontWindow(), !gInBackground);          break;      }      break;  }} /*DoEvent*//*  Change the cursor's shape, depending on its position. This also calculates the region  where the current cursor resides (for WaitNextEvent). When the mouse moves outside of  this region, an event is generated. If there is more to the event than just  &quot;the mouse moved&quot;, we get called before the event is processed to make sure  the cursor is the right one. In any (ahem) event, this is called again before we  fall back into WNE. */#pragma segment Mainvoid AdjustCursor(mouse,region)  Point    mouse;  RgnHandle  region;{  WindowPtr  window;  RgnHandle  arrowRgn;  RgnHandle  iBeamRgn;  Rect    iBeamRect;  window = FrontWindow();  /* we only adjust the cursor when we are in front */  if ( (! gInBackground) &amp;&amp; (! IsDAWindow(window)) ) {    /* calculate regions for different cursor shapes */    arrowRgn = NewRgn();    iBeamRgn = NewRgn();    /* start arrowRgn wide open */    SetRectRgn(arrowRgn, kExtremeNeg, kExtremeNeg, kExtremePos, kExtremePos);    /* calculate iBeamRgn */    if ( IsAppWindow(window) ) {      iBeamRect = (*((DocumentPeek) window)-&gt;docTE)-&gt;viewRect;      SetPort(window);  /* make a global version of the viewRect */      LocalToGlobal(&amp;TopLeft(iBeamRect));      LocalToGlobal(&amp;BotRight(iBeamRect));      RectRgn(iBeamRgn, &amp;iBeamRect);      /* we temporarily change the port's origin to &quot;globalfy&quot; the visRgn */      SetOrigin(-window-&gt;portBits.bounds.left, -window-&gt;portBits.bounds.top);      SectRgn(iBeamRgn, window-&gt;visRgn, iBeamRgn);      SetOrigin(0, 0);    }    /* subtract other regions from arrowRgn */    DiffRgn(arrowRgn, iBeamRgn, arrowRgn);    /* change the cursor and the region parameter */    if ( PtInRgn(mouse, iBeamRgn) ) {      SetCursor(*GetCursor(iBeamCursor));      CopyRgn(iBeamRgn, region);    } else {      SetCursor(&amp;qd.arrow);      CopyRgn(arrowRgn, region);    }    DisposeRgn(arrowRgn);    DisposeRgn(iBeamRgn);  }} /*AdjustCursor*//*  Get the global coordinates of the mouse. When you call OSEventAvail  it will return either a pending event or a null event. In either case,  the where field of the event record will contain the current position  of the mouse in global coordinates and the modifiers field will reflect  the current state of the modifiers. Another way to get the global  coordinates is to call GetMouse and LocalToGlobal, but that requires  being sure that thePort is set to a valid port. */#pragma segment Mainvoid GetGlobalMouse(mouse)  Point  *mouse;{  EventRecord  event;    OSEventAvail(kNoEvents, &amp;event);  /* we aren't interested in any events */  *mouse = event.where;        /* just the mouse position */} /*GetGlobalMouse*//*  Called when a mouseDown occurs in the grow box of an active window. In  order to eliminate any 'flicker', we want to invalidate only what is  necessary. Since ResizeWindow invalidates the whole portRect, we save  the old TE viewRect, intersect it with the new TE viewRect, and  remove the result from the update region. However, we must make sure  that any old update region that might have been around gets put back. */#pragma segment Mainvoid DoGrowWindow(window,event)  WindowPtr  window;  EventRecord  *event;{  long    growResult;  Rect    tempRect;  RgnHandle  tempRgn;  DocumentPeek doc;    tempRect = qd.screenBits.bounds;          /* set up limiting values */  tempRect.left = kMinDocDim;  tempRect.top = kMinDocDim;  growResult = GrowWindow(window, event-&gt;where, &amp;tempRect);  /* see if it really changed size */  if ( growResult != 0 ) {    doc = (DocumentPeek) window;    tempRect = (*doc-&gt;docTE)-&gt;viewRect;        /* save old text box */    tempRgn = NewRgn();    GetLocalUpdateRgn(window, tempRgn);        /* get localized update region */    SizeWindow(window, LoWrd(growResult), HiWrd(growResult), true);    ResizeWindow(window);    /* calculate &amp; validate the region that hasn't changed so it won't get redrawn */    SectRect(&amp;tempRect, &amp;(*doc-&gt;docTE)-&gt;viewRect, &amp;tempRect);    ValidRect(&amp;tempRect);              /* take it out of update */    InvalRgn(tempRgn);                /* put back any prior update */    DisposeRgn(tempRgn);  }} /* DoGrowWindow *//*   Called when a mouseClick occurs in the zoom box of an active window.  Everything has to get re-drawn here, so we don't mind that  ResizeWindow invalidates the whole portRect. */#pragma segment Mainvoid DoZoomWindow(window,part)  WindowPtr  window;  short    part;{  EraseRect(&amp;window-&gt;portRect);  ZoomWindow(window, part, window == FrontWindow());  ResizeWindow(window);} /*  DoZoomWindow *//* Called when the window has been resized to fix up the controls and content. */#pragma segment Mainvoid ResizeWindow(window)  WindowPtr  window;{  CGrafPtr savedPort;   /* Saves the current port for later restoring */  GDHandle savedDevice; /* Saves the current GDevice for later restoring */  AdjustScrollbars(window, true);  AdjustTE(window);  InvalRect(&amp;window-&gt;portRect);  /* Resize the background image to the new size of the window */  GetGWorld( /*&lt;*/&amp;savedPort, /*&lt;*/&amp;savedDevice );  UpdateGWorld( &amp;((DocumentPeek)window)-&gt;docImage, 0, &amp;window-&gt;portRect, nil, nil, 0 );  SetGWorld( ((DocumentPeek)window)-&gt;docImage, nil );  PaintImage();  SetGWorld( savedPort, savedDevice );} /* ResizeWindow *//* Returns the update region in local coordinates */#pragma segment Mainvoid GetLocalUpdateRgn(window,localRgn)  WindowPtr  window;  RgnHandle  localRgn;{  CopyRgn(((WindowPeek) window)-&gt;updateRgn, localRgn);  /* save old update region */  OffsetRgn(localRgn, window-&gt;portBits.bounds.left, window-&gt;portBits.bounds.top);} /* GetLocalUpdateRgn *//*  This is called when an update event is received for a window.  It calls DrawWindow to draw the contents of an application window.  As an efficiency measure that does not have to be followed, it  calls the drawing routine only if the visRgn is non-empty. This  will handle situations where calculations for drawing or drawing  itself is very time-consuming. */#pragma segment Mainvoid DoUpdate(window)  WindowPtr  window;{  if ( IsAppWindow(window) ) {    BeginUpdate(window);        /* this sets up the visRgn */    if ( ! EmptyRgn(window-&gt;visRgn) )  /* draw if updating needs to be done */      DrawWindow(window);    EndUpdate(window);  }} /*DoUpdate*/static void PaintImage(){  CGrafPtr  savedPort;    /* Pointer to saved CGrafPort for later restoring */  GDHandle  savedGDevice; /* Handle to saved GDevice for later restoring */  RGBColor  rampColor;    /* Color to use when drawing a step of the ramp */  short     maxRampCount; /* Number of pixels in a ramp */  short     rampWidth;    /* Width of each ramp in pixels */  short     rampFactor;   /* Value to set a color component to in a ramp */  short     pinFactor;    /* Value to pin a color component to in a ramp */  short     x;            /* Horizontal coordinate to draw ramp step */  short     y;            /* Vertical coordinate to draw ramp step */  GetGWorld( /*&lt;*/&amp;savedPort, /*&lt;*/&amp;savedGDevice );  /* Pin component values at $0000 first, then at $FFFF */  maxRampCount = savedPort-&gt;portRect.bottom - savedPort-&gt;portRect.top;  rampWidth = (savedPort-&gt;portRect.right - savedPort-&gt;portRect.left) / 16;  for (pinFactor = 0; pinFactor &gt;= -1; pinFactor--)  {    /* Loop on y coordinate over entire GrafPort */    for (y = 0; y &lt; maxRampCount; y++)    {      /* Calculate value of components that are dynamic in a ramp */      rampFactor = y * 65535 / maxRampCount;      if (pinFactor == -1)      {        /* If pinning at $FFFF, then use one's comp of rampFactor */        rampFactor ^= 0xFFFF;        x = rampWidth;      }      else        x = 0;      rampColor.red = rampFactor;      rampColor.green = rampFactor;      rampColor.blue = rampFactor;      RGBForeColor( &amp;rampColor );      MoveTo( x, y );      Line( rampWidth, 0 );      x += rampWidth * 2;      rampColor.blue = pinFactor;      RGBForeColor( &amp;rampColor );      MoveTo( x, y );      Line( rampWidth, 0 );      x += rampWidth * 2;      rampColor.green = pinFactor;      RGBForeColor( &amp;rampColor );      MoveTo( x, y );      Line( rampWidth, 0 );      x += rampWidth * 2;      rampColor.blue = rampFactor;      RGBForeColor( &amp;rampColor );      MoveTo( x, y );      Line( rampWidth, 0 );      x += rampWidth * 2;      rampColor.red = pinFactor;      RGBForeColor( &amp;rampColor );      MoveTo( x, y );      Line( rampWidth, 0 );      x += rampWidth * 2;      rampColor.green = rampFactor;      RGBForeColor( &amp;rampColor );      MoveTo( x, y );      Line( rampWidth, 0 );      x += rampWidth * 2;      rampColor.blue = pinFactor;      RGBForeColor( &amp;rampColor );      MoveTo( x, y );      Line( rampWidth, 0 );      x += rampWidth * 2;      rampColor.green = pinFactor;      RGBForeColor( &amp;rampColor );      MoveTo( x, y );      Line( rampWidth, 0 );    }  }}/*  This is called when a window is activated or deactivated.  It calls TextEdit to deal with the selection. */#pragma segment Mainvoid DoActivate(window, becomingActive)  WindowPtr  window;  Boolean    becomingActive;{  RgnHandle  tempRgn, clipRgn;  Rect    growRect;  DocumentPeek doc;    if ( IsAppWindow(window) ) {    doc = (DocumentPeek) window;    if ( becomingActive ) {      /*  since we don't want TEActivate to draw a selection in an area where        we're going to erase and redraw, we'll clip out the update region        before calling it. */      tempRgn = NewRgn();      clipRgn = NewRgn();      GetLocalUpdateRgn(window, tempRgn);      /* get localized update region */      GetClip(clipRgn);      DiffRgn(clipRgn, tempRgn, tempRgn);      /* subtract updateRgn from clipRgn */      SetClip(tempRgn);      TEActivate(doc-&gt;docTE);      SetClip(clipRgn);              /* restore the full-blown clipRgn */      DisposeRgn(tempRgn);      DisposeRgn(clipRgn);            /* the controls must be redrawn on activation: */      (*doc-&gt;docVScroll)-&gt;contrlVis = kControlVisible;      (*doc-&gt;docHScroll)-&gt;contrlVis = kControlVisible;      InvalRect(&amp;(*doc-&gt;docVScroll)-&gt;contrlRect);      InvalRect(&amp;(*doc-&gt;docHScroll)-&gt;contrlRect);      /* the growbox needs to be redrawn on activation: */      growRect = window-&gt;portRect;      /* adjust for the scrollbars */      growRect.top = growRect.bottom - kScrollbarAdjust;      growRect.left = growRect.right - kScrollbarAdjust;      InvalRect(&amp;growRect);    }    else {          TEDeactivate(doc-&gt;docTE);      /* the controls must be hidden on deactivation: */      HideControl(doc-&gt;docVScroll);      HideControl(doc-&gt;docHScroll);      /* the growbox should be changed immediately on deactivation: */      DrawGrowIcon(window);    }  }} /*DoActivate*//*  This is called when a mouseDown occurs in the content of a window. */#pragma segment Mainvoid DoContentClick(window,event)  WindowPtr  window;  EventRecord  *event;{  Point    mouse;  ControlHandle control;  short    part, value;  Boolean    shiftDown;  DocumentPeek doc;  Rect    teRect;  if ( IsAppWindow(window) ) {    SetPort(window);    mouse = event-&gt;where;              /* get the click position */    GlobalToLocal(&amp;mouse);    doc = (DocumentPeek) window;    /* see if we are in the viewRect. if so, we won't check the controls */    GetTERect(window, &amp;teRect);    if ( PtInRect(mouse, &amp;teRect) ) {      /* see if we need to extend the selection */      shiftDown = (event-&gt;modifiers &amp; shiftKey) != 0;  /* extend if Shift is down */      TEClick(mouse, shiftDown, doc-&gt;docTE);    } else {      part = FindControl(mouse, window, &amp;control);      switch ( part ) {        case 0:              /* do nothing for viewRect case */          break;        case inThumb:          value = GetCtlValue(control);          part = TrackControl(control, mouse, nil);          if ( part != 0 ) {            value -= GetCtlValue(control);            /* value now has CHANGE in value; if value changed, scroll */            if ( value != 0 )              if ( control == doc-&gt;docVScroll )                TEScroll(0, value * (*doc-&gt;docTE)-&gt;lineHeight, doc-&gt;docTE);              else                TEScroll(value, 0, doc-&gt;docTE);          }          break;        default:            /* they clicked in an arrow, so track &amp; scroll */          if ( control == doc-&gt;docVScroll )            value = TrackControl(control, mouse, gVActionUPP);          else            value = TrackControl(control, mouse, gHActionUPP);          break;      }    }  }} /*DoContentClick*//* This is called for any keyDown or autoKey events, except when the Command key is held down. It looks at the frontmost window to decide what to do with the key typed. */#pragma segment Mainvoid DoKeyDown(event)  EventRecord  *event;{  WindowPtr  window;  char    key;  TEHandle  te;  window = FrontWindow();  if ( IsAppWindow(window) ) {    te = ((DocumentPeek) window)-&gt;docTE;    key = event-&gt;message &amp; charCodeMask;    /* we have a char. for our window; see if we are still below TextEdit's      limit for the number of characters (but deletes are always rad) */    if ( key == kDelChar ||        (*te)-&gt;teLength - ((*te)-&gt;selEnd - (*te)-&gt;selStart) + 1 &lt;        kMaxTELength ) {      TEKey(key, te);      AdjustScrollbars(window, false);      AdjustTE(window);    } else      AlertUser(eExceedChar);  }} /*DoKeyDown*//*  Calculate a sleep value for WaitNextEvent. This takes into account the things  that DoIdle does with idle time. */#pragma segment Mainunsigned long GetSleep(){  long    sleep;  WindowPtr  window;  TEHandle  te;  sleep = 60;            /* default value for sleep */  if ( !gInBackground ) {    window = FrontWindow();      /* and the front window is ours... */    if ( IsAppWindow(window) ) {      te = ((DocumentPeek) (window))-&gt;docTE;  /* and the selection is an insertion point... */      if ( (*te)-&gt;selStart == (*te)-&gt;selEnd )        sleep = GetCaretTime();    /* blink time for the insertion point */    }  }  return sleep;} /*GetSleep*//*  Common algorithm for pinning the value of a control. It returns the actual amount  the value of the control changed. Note the pinning is done for the sake of returning  the amount the control value changed. */#pragma segment Mainvoid CommonAction(control,amount)  ControlHandle control;  short    *amount;{  short    value, max;    value = GetCtlValue(control);  /* get current value */  max = GetCtlMax(control);    /* and maximum value */  *amount = value - *amount;  if ( *amount &lt; 0 )    *amount = 0;  else if ( *amount &gt; max )    *amount = max;  SetCtlValue(control, *amount);  *amount = value - *amount;    /* calculate the real change */} /* CommonAction *//* Determines how much to change the value of the vertical scrollbar by and how  much to scroll the TE record. */#pragma segment Mainpascal void VActionProc(control,part)  ControlHandle control;  short    part;{  short    amount;  WindowPtr  window;  TEPtr    te;    if ( part != 0 ) {        /* if it was actually in the control */    window = (*control)-&gt;contrlOwner;    te = *((DocumentPeek) window)-&gt;docTE;    switch ( part ) {      case inUpButton:      case inDownButton:    /* one line */        amount = 1;        break;      case inPageUp:      /* one page */      case inPageDown:        amount = (te-&gt;viewRect.bottom - te-&gt;viewRect.top) / te-&gt;lineHeight;        break;    }    if ( (part == inDownButton) || (part == inPageDown) )      amount = -amount;    /* reverse direction for a downer */    CommonAction(control, &amp;amount);    if ( amount != 0 )      TEScroll(0, amount * te-&gt;lineHeight, ((DocumentPeek) window)-&gt;docTE);  }} /* VActionProc *//* Determines how much to change the value of the horizontal scrollbar by and howmuch to scroll the TE record. */#pragma segment Mainpascal void HActionProc(control,part)  ControlHandle control;  short    part;{  short    amount;  WindowPtr  window;  TEPtr    te;    if ( part != 0 ) {    window = (*control)-&gt;contrlOwner;    te = *((DocumentPeek) window)-&gt;docTE;    switch ( part ) {      case inUpButton:      case inDownButton:    /* a few pixels */        amount = kButtonScroll;        break;      case inPageUp:      /* a page */      case inPageDown:        amount = te-&gt;viewRect.right - te-&gt;viewRect.left;        break;    }    if ( (part == inDownButton) || (part == inPageDown) )      amount = -amount;    /* reverse direction */    CommonAction(control, &amp;amount);    if ( amount != 0 )      TEScroll(amount, 0, ((DocumentPeek) window)-&gt;docTE);  }} /* VActionProc *//* This is called whenever we get a null event et al. It takes care of necessary periodic actions. For this program, it calls TEIdle. */#pragma segment Mainvoid DoIdle(){  WindowPtr  window;  window = FrontWindow();  if ( IsAppWindow(window) )    TEIdle(((DocumentPeek) window)-&gt;docTE);} /*DoIdle*//* Draw the contents of an application window. */#pragma segment Mainvoid DrawWindow(window)  WindowPtr  window;{  SetPort(window);  EraseRect( &amp;window-&gt;portRect );  DrawControls(window);  DrawGrowIcon(window);  TEUpdate(&amp;window-&gt;portRect, ((DocumentPeek) window)-&gt;docTE);} /*DrawWindow*//*  Enable and disable menus based on the current state.  The user can only select enabled menu items. We set up all the menu items  before calling MenuSelect or MenuKey, since these are the only times that  a menu item can be selected. Note that MenuSelect is also the only time  the user will see menu items. This approach to deciding what enable/  disable state a menu item has the advantage of concentrating all  the decision-making in one routine, as opposed to being spread throughout  the application. Other application designs may take a different approach  that may or may not be as valid. */#pragma segment Mainvoid AdjustMenus(){  WindowPtr  window;  MenuHandle  menu;  long    offset;  Boolean    undo;  Boolean    cutCopyClear;  Boolean    paste;  TEHandle  te;  window = FrontWindow();  menu = GetMHandle(mFile);  if ( gNumDocuments &lt; kMaxOpenDocuments )    EnableItem(menu, iNew);    /* New is enabled when we can open more documents */  else    DisableItem(menu, iNew);  if ( window != nil )      /* Close is enabled when there is a window to close */    EnableItem(menu, iClose);  else    DisableItem(menu, iClose);  menu = GetMHandle(mEdit);  undo = false;  cutCopyClear = false;  paste = false;  if ( IsDAWindow(window) ) {    undo = true;        /* all editing is enabled for DA windows */    cutCopyClear = true;    paste = true;  } else if ( IsAppWindow(window) ) {    te = ((DocumentPeek) window)-&gt;docTE;    if ( (*te)-&gt;selStart &lt; (*te)-&gt;selEnd )      cutCopyClear = true;      /* Cut, Copy, and Clear is enabled for app. windows with selections */    if ( GetScrap(nil, 'TEXT', &amp;offset)  &gt; 0)      paste = true;      /* if there's any text in the clipboard, paste is enabled */  }  if ( undo )    EnableItem(menu, iUndo);  else    DisableItem(menu, iUndo);  if ( cutCopyClear ) {    EnableItem(menu, iCut);    EnableItem(menu, iCopy);    EnableItem(menu, iClear);  } else {    DisableItem(menu, iCut);    DisableItem(menu, iCopy);    DisableItem(menu, iClear);  }  if ( paste )    EnableItem(menu, iPaste);  else    DisableItem(menu, iPaste);} /*AdjustMenus*//*  This is called when an item is chosen from the menu bar (after calling  MenuSelect or MenuKey). It does the right thing for each command. */#pragma segment Mainvoid DoMenuCommand(menuResult)  long    menuResult;{  short    menuID, menuItem;  short    itemHit, daRefNum;  Str255    daName;  OSErr    saveErr;  TEHandle  te;  WindowPtr  window;  Handle    aHandle;  long    oldSize, newSize;  long    total, contig;  window = FrontWindow();  menuID = HiWord(menuResult);  /* use macros for efficiency to... */  menuItem = LoWord(menuResult);  /* get menu item number and menu number */  switch ( menuID ) {    case mApple:      switch ( menuItem ) {        case iAbout:    /* bring up alert for About */          itemHit = Alert(rAboutAlert, nil);          break;        default:      /* all non-About items in this menu are DAs et al */          /* type Str255 is an array in MPW 3 */          GetItem(GetMHandle(mApple), menuItem, daName);          daRefNum = OpenDeskAcc(daName);          break;      }      break;    case mFile:      switch ( menuItem ) {        case iNew:          DoNew();          break;        case iClose:          DoCloseWindow(FrontWindow());      /* ignore the result */          break;        case iQuit:          Terminate();          break;      }      break;    case mEdit:          /* call SystemEdit for DA editing &amp; MultiFinder */      if ( !SystemEdit(menuItem-1) ) {        te = ((DocumentPeek) FrontWindow())-&gt;docTE;        switch ( menuItem ) {          case iCut:            if ( ZeroScrap() == noErr ) {              PurgeSpace(&amp;total, &amp;contig);              if ((*te)-&gt;selEnd - (*te)-&gt;selStart + kTESlop &gt; contig)                AlertUser(eNoSpaceCut);              else                   {                TECut(te);                if ( TEToScrap() != noErr ) {                  AlertUser(eNoCut);                  ZeroScrap();                }              }            }            break;          case iCopy:            if ( ZeroScrap() == noErr ) {              TECopy(te);  /* after copying, export the TE scrap */              if ( TEToScrap() != noErr ) {                AlertUser(eNoCopy);                ZeroScrap();              }            }            break;          case iPaste:  /* import the TE scrap before pasting */            if ( TEFromScrap() == noErr ) {              if ( TEGetScrapLen() + ((*te)-&gt;teLength -                ((*te)-&gt;selEnd - (*te)-&gt;selStart)) &gt; kMaxTELength )                AlertUser(eExceedPaste);              else {                aHandle = (Handle) TEGetText(te);                oldSize = GetHandleSize(aHandle);                newSize = oldSize + TEGetScrapLen() + kTESlop;                SetHandleSize(aHandle, newSize);                saveErr = MemError();                SetHandleSize(aHandle, oldSize);                if (saveErr != noErr)                  AlertUser(eNoSpacePaste);                else                  TEPaste(te);              }            }            else              AlertUser(eNoPaste);            break;          case iClear:            TEDelete(te);            break;        }      AdjustScrollbars(window, false);      AdjustTE(window);      }      break;  }  HiliteMenu(0);          /* unhighlight what MenuSelect (or MenuKey) hilited */} /*DoMenuCommand*/pascal void CustomRect(  GrafVerb verb,      /* Operation to perform */  Rect     *destRect) /* Rectangle to be drawn */{  GrafPtr   currPort;          /* Port that this bottleneck is attached to */  GWorldPtr backImage;         /* The window's background image */  TEHandle  docText;           /* Document's TextEdit record */  RgnHandle clippedDestRgn;    /* Region that covers clippedDestRect area */  RgnHandle destRectRgn;       /* Region that covers destRect */  Rect      textRect;          /* Copy of the TextEdit record's viewRect */  Rect      clippedDestRect;   /* Rectangle to copy GWorld into */  Rect      clippedSourceRect; /* Rectangle to copy GWorld image from */  short     horzOffset;        /* Horizontal offset of destRect from viewRect */  short     vertOffset;        /* Vertical offset of destRect from viewRect */  if (verb == erase)  {    /* Get the document's background image and TextEdit record */    GetPort( /*&lt;*/&amp;currPort );    backImage = ((DocumentPeek)currPort)-&gt;docImage;    docText = ((DocumentPeek)currPort)-&gt;docTE;    textRect = (**docText).viewRect;    /* Get the amount that the TextEdit record is scrolled */    horzOffset = textRect.left - (**docText).destRect.left;    vertOffset = textRect.top - (**docText).destRect.top;    /* Source rect is dest rect scrolled, clipped to viewRect and off-screen port */    clippedSourceRect = *destRect;    SectRect( &amp;clippedSourceRect, &amp;textRect, /*&lt;*/&amp;clippedSourceRect );    OffsetRect( /*\xD7*/&amp;clippedSourceRect, horzOffset, vertOffset );    SectRect( &amp;clippedSourceRect, &amp;backImage-&gt;portRect, /*&lt;*/&amp;clippedSourceRect );    /* Dest rect is clipped to viewRect and same size and source rect */    clippedDestRect = *destRect;    SectRect( &amp;clippedDestRect, &amp;textRect, /*&lt;*/&amp;clippedDestRect );    clippedDestRect.right = clippedDestRect.left + (clippedSourceRect.right -        clippedSourceRect.left);    clippedDestRect.bottom = clippedDestRect.top + (clippedSourceRect.bottom -        clippedSourceRect.top);    /* Draw the background instead of erasing */    CopyBits( &amp;((GrafPtr)backImage)-&gt;portBits, &amp;currPort-&gt;portBits,        &amp;clippedSourceRect, &amp;clippedDestRect,        srcCopy, nil );    /* Erase the area outside of the area of the background */    clippedDestRgn = NewRgn();    destRectRgn = NewRgn();    RectRgn( clippedDestRgn, &amp;clippedDestRect );    RectRgn( destRectRgn, destRect );    DiffRgn( destRectRgn, clippedDestRgn, clippedDestRgn );    StdRgn( erase, clippedDestRgn );    DisposeRgn( clippedDestRgn );    DisposeRgn( destRectRgn );  }  else if (verb == invert)  {    /* Turn off colored hilighting so that we can see something */    *((char *)0x0938) |= 0x80;    StdRect( verb, destRect );  }  else    /* Nothing special; just call original bottleneck */    StdRect( verb, destRect );}pascal void CustomRgn(  GrafVerb  verb,    /* Operation to perform */  RgnHandle destRgn) /* Region to be drawn */{  GrafPtr   currPort;          /* Port that this bottleneck is attached to */  GWorldPtr backImage;         /* The window's background image */  TEHandle  docText;           /* Document's TextEdit record */  Rect      textRect;          /* Copy of the TextEdit record's viewRect */  Rect      clippedDestRect;   /* Rectangle to copy GWorld into */  Rect      clippedSourceRect; /* Rectangle to copy GWorld image from */  Rect      destRect;          /* Rectangle that circumscribes destRgn */  short     horzOffset;        /* Horizontal offset of destRect from viewRect */  short     vertOffset;        /* Vertical offset of destRect from viewRect */  if (verb == erase)  {    /* Get the document's background image and TextEdit record */    GetPort( /*&lt;*/&amp;currPort );    backImage = ((DocumentPeek)currPort)-&gt;docImage;    docText = ((DocumentPeek)currPort)-&gt;docTE;    textRect = (**docText).viewRect;    destRect = (**destRgn).rgnBBox;    /* Get the amount that the TextEdit record is scrolled */    horzOffset = textRect.left - (**docText).destRect.left;    vertOffset = textRect.top - (**docText).destRect.top;    /* Source rect is dest rect scrolled, clipped to viewRect and off-screen port */    clippedSourceRect = destRect;    SectRect( &amp;clippedSourceRect, &amp;textRect, /*&lt;*/&amp;clippedSourceRect );    OffsetRect( /*\xD7*/&amp;clippedSourceRect, horzOffset, vertOffset );    SectRect( &amp;clippedSourceRect, &amp;backImage-&gt;portRect, /*&lt;*/&amp;clippedSourceRect );    /* Dest rect is clipped to viewRect and same size and source rect */    clippedDestRect = destRect;    SectRect( &amp;clippedDestRect, &amp;textRect, /*&lt;*/&amp;clippedDestRect );    clippedDestRect.right = clippedDestRect.left + (clippedSourceRect.right -        clippedSourceRect.left);    clippedDestRect.bottom = clippedDestRect.top + (clippedSourceRect.bottom -        clippedSourceRect.top);    /* Draw the background instead of erasing */    CopyBits( &amp;((GrafPtr)backImage)-&gt;portBits, &amp;currPort-&gt;portBits,        &amp;clippedSourceRect, &amp;clippedDestRect,        srcCopy, destRgn );  }  else    StdRgn( verb, destRgn );}/* Create a new document and window. */#pragma segment Mainvoid DoNew(){  Boolean    good;  Ptr      storage;  WindowPtr  window;  Rect    destRect, viewRect;  DocumentPeek doc;  CGrafPtr    savedPort;  GDHandle    savedDevice;  QDErr       error;  QDProcsPtr  customProcs;  storage = NewPtr(sizeof(DocumentRecord));  if ( storage != nil ) {    window = GetNewWindow(rDocWindow, storage, (WindowPtr) -1);    if ( window != nil ) {      gNumDocuments += 1;      /* this will be decremented when we call DoCloseWindow */      good = false;      SetPort(window);      doc =  (DocumentPeek) window;      GetTERect(window, &amp;viewRect);      destRect = viewRect;      destRect.right = destRect.left + kMaxDocWidth;      doc-&gt;docTE = TENew(&amp;destRect, &amp;viewRect);      good = doc-&gt;docTE != nil;  /* if TENew succeeded, we have a good document */      if ( good ) {        /* 1.02 - good document? \xD1 proceed */        AdjustViewRect(doc-&gt;docTE);        TEAutoView(true, doc-&gt;docTE);        doc-&gt;docClick = (ProcPtr) (*doc-&gt;docTE)-&gt;clickLoop;        #if powerc        TESetClickLoop(gClickLoopUPP, doc-&gt;docTE);                #else        (*doc-&gt;docTE)-&gt;clickLoop = (TEClickLoopUPP) AsmClickLoopProc;                #endif      }      /* Create the GWorld to use as the background image */      GetGWorld( &amp;savedPort, &amp;savedDevice );      error = NewGWorld( &amp;doc-&gt;docImage, 0, &amp;window-&gt;portRect, nil, nil, 0 );      good = error == noErr;      if (good)      {        /* Draw the image of ramps into the GWorld */        SetGWorld( doc-&gt;docImage, nil );        PaintImage();        SetGWorld( savedPort, savedDevice );        /* Allocate and initialize bottleneck routines */        customProcs = (QDProcsPtr)NewPtr( sizeof (QDProcs) );        SetStdProcs(customProcs );        customProcs-&gt;rectProc = gQDRectUPP;        customProcs-&gt;rgnProc = gQDRgnUPP;                /* Install our bottlenecks into the window */        window-&gt;grafProcs = customProcs;      }      if ( good ) {        /* good document? \xD1 get scrollbars */        doc-&gt;docVScroll = GetNewControl(rVScroll, window);        good = (doc-&gt;docVScroll != nil);      }      if ( good) {        doc-&gt;docHScroll = GetNewControl(rHScroll, window);        good = (doc-&gt;docHScroll != nil);      }            if ( good ) {        /* good? \xD1 adjust &amp; draw the controls, draw the window */        /* false to AdjustScrollValues means musn't redraw; technically, of course,        the window is hidden so it wouldn't matter whether we called ShowControl or not. */        AdjustScrollValues(window, false);        ShowWindow(window);      } else {        DoCloseWindow(window);  /* otherwise regret we ever created it... */        AlertUser(eNoWindow);      /* and tell user */      }    } else      DisposPtr(storage);      /* get rid of the storage if it is never used */  }} /*DoNew*//* Close a window. This handles desk accessory and application windows. *//*  1.01 - At this point, if there was a document associated with a  window, you could do any document saving processing if it is 'dirty'.  DoCloseWindow would return true if the window actually closed, i.e.,  the user didn't cancel from a save dialog. This result is handy when  the user quits an application, but then cancels the save of a document  associated with a window. */#pragma segment MainBoolean DoCloseWindow(window)  WindowPtr  window;{  TEHandle  te;  if ( IsDAWindow(window) )    CloseDeskAcc(((WindowPeek) window)-&gt;windowKind);  else if ( IsAppWindow(window) ) {    te = ((DocumentPeek) window)-&gt;docTE;    if ( te != nil )      TEDispose(te);      /* dispose the TEHandle if we got far enough to make one */    /*  1.01 - We used to call DisposeWindow, but that was technically      incorrect, even though we allocated storage for the window on      the heap. We should instead call CloseWindow to have the structures      taken care of and then dispose of the storage ourselves. */    CloseWindow(window);    DisposPtr((Ptr) window);    gNumDocuments -= 1;  }  return true;} /*DoCloseWindow*//***************************************************************************************** 1.01 DoCloseBehind(window) was removed ***  1.01 - DoCloseBehind was a good idea for closing windows when quitting  and not having to worry about updating the windows, but it suffered  from a fatal flaw. If a desk accessory owned two windows, it would  close both those windows when CloseDeskAcc was called. When DoCloseBehind  got around to calling DoCloseWindow for that other window that was already  closed, things would go very poorly. Another option would be to have a  procedure, GetRearWindow, that would go through the window list and return  the last window. Instead, we decided to present the standard approach  of getting and closing FrontWindow until FrontWindow returns NIL. This  has a potential benefit in that the window whose document needs to be saved  may be visible since it is the front window, therefore decreasing the  chance of user confusion. For aesthetic reasons, the windows in the  application should be checked for updates periodically and have the  updates serviced.**************************************************************************************//* Clean up the application and exit. We close all of the windows so that they can update their documents, if any. */ /*  1.01 - If we find out that a cancel has occurred, we won't exit to the  shell, but will return instead. */#pragma segment Mainvoid Terminate(){  WindowPtr  aWindow;  Boolean    closed;    closed = true;  do {    aWindow = FrontWindow();        /* get the current front window */    if (aWindow != nil)      closed = DoCloseWindow(aWindow);  /* close this window */    }  while (closed &amp;&amp; (aWindow != nil));  if (closed)    ExitToShell();              /* exit if no cancellation */} /*Terminate*//*  Set up the whole world, including global variables, Toolbox managers,  menus, and a single blank document. *//*  1.01 - The code that used to be part of ForceEnvirons has been moved into  this module. If an error is detected, instead of merely doing an ExitToShell,  which leaves the user without much to go on, we call AlertUser, which puts  up a simple alert that just says an error occurred and then calls ExitToShell.  Since there is no other cleanup needed at this point if an error is detected,  this form of error- handling is acceptable. If more sophisticated error recovery  is needed, an exception mechanism, such as is provided by Signals, can be used. */  #pragma segment Initializevoid Initialize(){  Handle  menuBar;  long  total, contig;  EventRecord event;  short  count;  gInBackground = false;  InitGraf((Ptr) &amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(nil);  InitCursor();  /*  Call MPPOpen and ATPLoad at this point to initialize AppleTalk,     if you are using it. */  /*  NOTE -- It is no longer necessary, and actually unhealthy, to check    PortBUse and SPConfig before opening AppleTalk. The drivers are capable    of checking for port availability themselves. */    /*  This next bit of code is necessary to allow the default button of our    alert be outlined.    1.02 - Changed to call EventAvail so that we don't lose some important    events. */     for (count = 1; count &lt;= 3; count++)    EventAvail(everyEvent, &amp;event);    /*  Ignore the error returned from SysEnvirons; even if an error occurred,    the SysEnvirons glue will fill in the SysEnvRec. You can save a redundant    call to SysEnvirons by calling it after initializing AppleTalk. */     SysEnvirons(kSysEnvironsVersion, &amp;gMac);    /* Make sure that the machine has at least 128K ROMs. If it doesn't, exit. */    if (gMac.machineType &lt; 0) BigBadError(eWrongMachine);    /*  1.02 - Move TrapAvailable call to after SysEnvirons so that we can tell    in TrapAvailable if a tool trap value is out of range. */      gHasWaitNextEvent = TrapAvailable(_WaitNextEvent);  /*  1.01 - We used to make a check for memory at this point by examining ApplLimit,    ApplicZone, and StackSpace and comparing that to the minimum size we told    MultiFinder we needed. This did not work well because it assumed too much about    the relationship between what we asked MultiFinder for and what we would actually    get back, as well as how to measure it. Instead, we will use an alternate    method comprised of two steps. */     /*  It is better to first check the size of the application heap against a value    that you have determined is the smallest heap the application can reasonably    work in. This number should be derived by examining the size of the heap that    is actually provided by MultiFinder when the minimum size requested is used.    The derivation of the minimum size requested from MultiFinder is described    in Sample.h. The check should be made because the preferred size can end up    being set smaller than the minimum size by the user. This extra check acts to    insure that your application is starting from a solid memory foundation. */     if ((long) GetApplLimit() - (long) ApplicZone() &lt; kMinHeap) BigBadError(eSmallSize);    /*  Next, make sure that enough memory is free for your application to run. It    is possible for a situation to arise where the heap may have been of required    size, but a large scrap was loaded which left too little memory. To check for    this, call PurgeSpace and compare the result with a value that you have determined    is the minimum amount of free memory your application needs at initialization.    This number can be derived several different ways. One way that is fairly    straightforward is to run the application in the minimum size configuration    as described previously. Call PurgeSpace at initialization and examine the value    returned. However, you should make sure that this result is not being modified    by the scrap's presence. You can do that by calling ZeroScrap before calling    PurgeSpace. Make sure to remove that call before shipping, though. */    /* ZeroScrap(); */  PurgeSpace(&amp;total, &amp;contig);  if (total &lt; kMinSpace)    if (UnloadScrap() != noErr)      BigBadError(eNoMemory);    else {      PurgeSpace(&amp;total, &amp;contig);      if (total &lt; kMinSpace)        BigBadError(eNoMemory);    }  /*  The extra benefit to waiting until after the Toolbox Managers have been initialized    to check memory is that we can now give the user an alert to tell him/her what    happened. Although it is possible that the memory situation could be worsened by    displaying an alert, MultiFinder would gracefully exit the application with    an informative alert if memory became critical. Here we are acting more    in a preventative manner to avoid future disaster from low-memory problems. */  menuBar = GetNewMBar(rMenuBar);      /* read menus into menu bar */  if ( menuBar == nil )        BigBadError(eNoMemory);  SetMenuBar(menuBar);          /* install menus */  DisposHandle(menuBar);  AddResMenu(GetMHandle(mApple), 'DRVR');  /* add DA names to Apple menu */  DrawMenuBar();  gNumDocuments = 0;    /* set up the UPP for our ClikLoop if we are compiling for PowerPC */  #if powerc  gClickLoopUPP = NewTEClickLoopProc(ClickLoopProc);    #endif    /* set up the UPPs for our scroll bar tracking */  gHActionUPP = NewControlActionProc(HActionProc);  gVActionUPP = NewControlActionProc(VActionProc);    /* finally the UPPs for the QD routines */  gQDRectUPP   =  NewQDRectProc(CustomRect);  gQDRgnUPP    =  NewQDRgnProc(CustomRgn);  /* do other initialization here */  DoNew();                /* create a single empty document */} /*Initialize*//* Used whenever a, like, fully fatal error happens */#pragma segment Initializevoid BigBadError(error)  short error;{  AlertUser(error);  ExitToShell();}/* Return a rectangle that is inset from the portRect by the size of  the scrollbars and a little extra margin. */#pragma segment Mainvoid GetTERect(window,teRect)  WindowPtr  window;  Rect    *teRect;{  *teRect = window-&gt;portRect;  InsetRect(teRect, kTextMargin, kTextMargin);  /* adjust for margin */  teRect-&gt;bottom = teRect-&gt;bottom - 15;    /* and for the scrollbars */  teRect-&gt;right = teRect-&gt;right - 15;} /*GetTERect*//* Update the TERec's view rect so that it is the greatest multiple of  the lineHeight that still fits in the old viewRect. */#pragma segment Mainvoid AdjustViewRect(docTE)  TEHandle  docTE;{  TEPtr    te;    te = *docTE;  /* te-&gt;viewRect.bottom = (((te-&gt;viewRect.bottom - te-&gt;viewRect.top) / te-&gt;lineHeight)              * te-&gt;lineHeight) + te-&gt;viewRect.top; */} /*AdjustViewRect*//* Scroll the TERec around to match up to the potentially updated scrollbar  values. This is really useful when the window has been resized such that the  scrollbars became inactive but the TERec was already scrolled. */#pragma segment Mainvoid AdjustTE(window)  WindowPtr  window;{  TEPtr    te;    te = *((DocumentPeek)window)-&gt;docTE;  TEScroll((te-&gt;viewRect.left - te-&gt;destRect.left) -      GetCtlValue(((DocumentPeek)window)-&gt;docHScroll),      (te-&gt;viewRect.top - te-&gt;destRect.top) -        (GetCtlValue(((DocumentPeek)window)-&gt;docVScroll) *        te-&gt;lineHeight),      ((DocumentPeek)window)-&gt;docTE);} /*AdjustTE*//* Calculate the new control maximum value and current value, whether it is the horizontal or  vertical scrollbar. The vertical max is calculated by comparing the number of lines to the  vertical size of the viewRect. The horizontal max is calculated by comparing the maximum document  width to the width of the viewRect. The current values are set by comparing the offset between  the view and destination rects. If necessary and we canRedraw, have the control be re-drawn by  calling ShowControl. */#pragma segment Mainvoid AdjustHV(isVert,control,docTE,canRedraw)  Boolean    isVert;  ControlHandle control;  TEHandle  docTE;  Boolean    canRedraw;{  short    value, lines, max;  short    oldValue, oldMax;  TEPtr    te;    oldValue = GetCtlValue(control);  oldMax = GetCtlMax(control);  te = *docTE;              /* point to TERec for convenience */  if ( isVert ) {    lines = te-&gt;nLines;    /* since nLines isn't right if the last character is a return, check for that case */    if ( *(*te-&gt;hText + te-&gt;teLength - 1) == kCrChar )      lines += 1;    max = lines - ((te-&gt;viewRect.bottom - te-&gt;viewRect.top) /        te-&gt;lineHeight);  } else    max = kMaxDocWidth - (te-&gt;viewRect.right - te-&gt;viewRect.left);    if ( max &lt; 0 ) max = 0;  SetCtlMax(control, max);    /* Must deref. after SetCtlMax since, technically, it could draw and therefore move    memory. This is why we don't just do it once at the beginning. */  te = *docTE;  if ( isVert )    value = (te-&gt;viewRect.top - te-&gt;destRect.top) / te-&gt;lineHeight;  else    value = te-&gt;viewRect.left - te-&gt;destRect.left;    if ( value &lt; 0 ) value = 0;  else if ( value &gt;  max ) value = max;    SetCtlValue(control, value);  /* now redraw the control if it needs to be and can be */  if ( canRedraw || (max != oldMax) || (value != oldValue) )    ShowControl(control);} /*AdjustHV*//* Simply call the common adjust routine for the vertical and horizontal scrollbars. */#pragma segment Mainvoid AdjustScrollValues(window,canRedraw)  WindowPtr  window;  Boolean    canRedraw;{  DocumentPeek doc;    doc = (DocumentPeek)window;  AdjustHV(true, doc-&gt;docVScroll, doc-&gt;docTE, canRedraw);  AdjustHV(false, doc-&gt;docHScroll, doc-&gt;docTE, canRedraw);} /*AdjustScrollValues*//*  Re-calculate the position and size of the viewRect and the scrollbars.  kScrollTweek compensates for off-by-one requirements of the scrollbars  to have borders coincide with the growbox. */#pragma segment Mainvoid AdjustScrollSizes(window)  WindowPtr  window;{  Rect    teRect;  DocumentPeek doc;    doc = (DocumentPeek) window;  GetTERect(window, &amp;teRect);              /* start with TERect */  (*doc-&gt;docTE)-&gt;viewRect = teRect;  AdjustViewRect(doc-&gt;docTE);              /* snap to nearest line */  MoveControl(doc-&gt;docVScroll, window-&gt;portRect.right - kScrollbarAdjust, -1);  SizeControl(doc-&gt;docVScroll, kScrollbarWidth, (window-&gt;portRect.bottom -         window-&gt;portRect.top) - (kScrollbarAdjust - kScrollTweek));  MoveControl(doc-&gt;docHScroll, -1, window-&gt;portRect.bottom - kScrollbarAdjust);  SizeControl(doc-&gt;docHScroll, (window-&gt;portRect.right -         window-&gt;portRect.left) - (kScrollbarAdjust - kScrollTweek),        kScrollbarWidth);} /*AdjustScrollSizes*//* Turn off the controls by jamming a zero into their contrlVis fields (HideControl erases them  and we don't want that). If the controls are to be resized as well, call the procedure to do that,  then call the procedure to adjust the maximum and current values. Finally re-enable the controls  by jamming a $FF in their contrlVis fields. */#pragma segment Mainvoid AdjustScrollbars(window,needsResize)  WindowPtr  window;  Boolean    needsResize;{  DocumentPeek doc;    doc = (DocumentPeek) window;  /* First, turn visibility of scrollbars off so we won't get unwanted redrawing */  (*doc-&gt;docVScroll)-&gt;contrlVis = kControlInvisible;  /* turn them off */  (*doc-&gt;docHScroll)-&gt;contrlVis = kControlInvisible;  if ( needsResize )                  /* move &amp; size as needed */    AdjustScrollSizes(window);  AdjustScrollValues(window, needsResize);      /* fool with max and current value */  /* Now, restore visibility in case we never had to ShowControl during adjustment */  (*doc-&gt;docVScroll)-&gt;contrlVis = kControlVisible;  /* turn them on */  (*doc-&gt;docHScroll)-&gt;contrlVis = kControlVisible;} /* AdjustScrollbars */// When the user selects text by dragging, TextEdit repeatedly calls a click loop routine which// it gets from the TERecord's clikLoop field. TextEdit's default routine does some useful things,// such as scrolling the text being selected, but it doesn't know about our scroll bars.// Therefore, we replace the routine with one that calls both the old routine and an add-on routine// which handles the scroll bars. Unfortunately, the way this works is very different for 68K and// PowerPC. On 68K, we have to be aware that the original click loop routine has a register-based// interface, so our replacement is easier to write in assembly. For PowerPC, we can let routine// descriptors handle the argument conversions, and do everything in the C routine ClickLoopProc.#if powercpascal Boolean ClickLoopProc(TEPtr pTE){  CallTEClickLoopProc(GetOldClickLoop(), pTE);  ClickLoopAddOn();  return true;}#endif// The ClickLoopAddOn routine handles the scroll bars during drag-scrolling.pascal void ClickLoopAddOn(void){  WindowPtr  window;  RgnHandle  region;    window = FrontWindow();  region = NewRgn();  GetClip(region);          /* save clip */  ClipRect(&amp;window-&gt;portRect);  AdjustScrollValues(window, true);  /* pass true for canRedraw */  SetClip(region);          /* restore clip */  DisposeRgn(region);}// GetOldClickLoop returns the address of the default click loop routine that we put into the// TERec when creating it.pascal TEClickLoopUPP GetOldClickLoop(void){  return ((DocumentPeek)FrontWindow())-&gt;docClick;}/*  Check to see if a window belongs to the application. If the window pointer  passed was NIL, then it could not be an application window. WindowKinds  that are negative belong to the system and windowKinds less than userKind  are reserved by Apple except for windowKinds equal to dialogKind, which  mean it is a dialog.  1.02 - In order to reduce the chance of accidentally treating some window  as an AppWindow that shouldn't be, we'll only return true if the windowkind  is userKind. If you add different kinds of windows to Sample you'll need  to change how this all works. */#pragma segment MainBoolean IsAppWindow(window)  WindowPtr  window;{  short    windowKind;  if ( window == nil )    return false;  else {  /* application windows have windowKinds = userKind (8) */    windowKind = ((WindowPeek) window)-&gt;windowKind;    return (windowKind == userKind);  }} /*IsAppWindow*//* Check to see if a window belongs to a desk accessory. */#pragma segment MainBoolean IsDAWindow(window)  WindowPtr  window;{  if ( window == nil )    return false;  else  /* DA windows have negative windowKinds */    return ((WindowPeek) window)-&gt;windowKind &lt; 0;} /*IsDAWindow*/// check to see if a given trap is implemented. We follow IM VI-3-8.Boolean TrapAvailable(short theTrap){  TrapType theTrapType;  short numToolboxTraps;    if ((theTrap &amp; 0x0800) &gt; 0)    theTrapType = ToolTrap;  else    theTrapType = OSTrap;  if (theTrapType == ToolTrap)  {    theTrap = theTrap &amp; 0x07ff;    if (NGetTrapAddress(_InitGraf, ToolTrap) == NGetTrapAddress(0xaa6e, ToolTrap))      numToolboxTraps = 0x0200;    else      numToolboxTraps = 0x0400;    if (theTrap &gt;= numToolboxTraps)      theTrap = _Unimplemented;  };  return (NGetTrapAddress(theTrap, theTrapType) != NGetTrapAddress(_Unimplemented, ToolTrap));}/*  Display an alert that tells the user an error occurred, then exit the program.  This routine is used as an ultimate bail-out for serious errors that prohibit  the continuation of the application. Errors that do not require the termination  of the application should be handled in a different manner. Error checking and  reporting has a place even in the simplest application. The error number is used  to index an 'STR#' resource so that a relevant message can be displayed. */#pragma segment Mainvoid AlertUser(error)  short    error;{  short    itemHit;  Str255    message;  SetCursor(&amp;qd.arrow);  /* type Str255 is an array in MPW 3 */  GetIndString(message, kErrStrings, error);  ParamText(message, &quot;&quot;, &quot;&quot;, &quot;&quot;);  itemHit = Alert(rUserAlert, nil);} /* AlertUser */</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/TE_Over_Background/listing1.html%3Fid%3DDTS10000172-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/TE_Over_Background/listing1.html%3Fid%3DDTS10000172-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/TE_Over_Background/listing1.html%3Fid%3DDTS10000172-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>