<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Mouse Handling (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING67></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-66.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-68.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-21.html"><B>Part 1 - MacApp Theory and Architecture</B></A><BR><DD><A HREF="MacAppProgGuide-63.html"><B>Chapter 8 - Displaying, Manipulating, and Printing Data</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING67-0></A>
<H1><A NAME=MARKER-9-155></A><A NAME=MARKER-2-156></A>Mouse Handling</H1>
 Almost all applications need to track mouse movement and respond to mouse clicks. When a user moves the mouse or presses or releases the mouse button, MacApp receives a Toolbox event from the operating system describing the action. In some cases, MacApp handles the event for you; in others, it passes the event on to your code. For example, MacApp takes care of a mouse click in the Apple menu, but your application handles the event when a user clicks in the content area of your window.<P>
 Mouse actions in a window's content area are commonly used for activities such as drawing, selecting, and dragging. An application may need to track the mouse while the user drags, then take some action when the user releases the mouse button. MacApp supplies the <CODE>TTracker</CODE> class to help your application track the mouse and provide visual feedback.<P>
<DL>
<DT><B>Note</B>
<DD>This chapter uses the term <I>mouse event</I> primarily to describe the Toolbox mouse-down event that is generated when a user clicks with the mouse. Most applications are less interested in mouse-up events, although MacApp provides facilities for working with them as well.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING67-4></A>
<H2>Which Objects Can Handle a Mouse Event</H2>
 Any object based on a class that descends from <CODE>TView</CODE> can handle a mouse event by overriding the <CODE><A NAME=MARKER-2-157></A>DoMouseCommand</CODE> method. Any object instantiated from a class that descends from <CODE>TBehavior</CODE> can also override the <CODE>DoMouseCommand</CODE> method. So your application can handle mouse events directly in subclasses of <CODE>TView</CODE> and <CODE>TWindow</CODE>, or by adding a behavior to an object based on the <CODE>TEventHandler</CODE> class. Mouse events are most commonly handled by view objects or by behavior objects attached to them.<P>
<A NAME=HEADING67-6></A>
<H2>Dispatching Mouse Events</H2>
 <A HREF=MacAppProgGuide-42.html#MARKER-9-64>"View Hierarchy Dispatching" on page 103</A> describes how MacApp dispatches mouse events to objects in your application. In summary, MacApp dispatches a mouse event by calling the <CODE><A NAME=MARKER-2-158></A>HandleMouseDown</CODE> method of the window in which the event occurs. The window normally gives its subviews a chance to handle the event, and a subview may do the same for <I>its</I> subviews. A mouse event is usually handled in the <CODE>DoMouseCommand</CODE> method of the most deeply nested view that contains the mouse event and is visible and enabled to respond to it.<P>
<A NAME=HEADING67-8></A>
<H2><A NAME=MARKER-2-159></A>Creating a Command to Handle a Mouse Event</H2>
 A view object's <CODE>DoMouseCommand</CODE> method commonly handles a mouse event by creating a mouse-tracking command object and posting it to the command queue. The tracking command is instantiated from <CODE>TTracker</CODE> or a subclass. The <CODE><A NAME=MARKER-2-160></A>TTracker</CODE> class adds mouse-tracking capability to command objects.<P>
 To handle drawing, selecting, or dragging with the mouse, you can define a subclass of the <CODE>TTracker</CODE> command and override the <CODE>TrackConstrain</CODE>, <CODE>TrackFeedback</CODE>, and <CODE>TrackMouse</CODE> methods. For selecting with the mouse, you also override the <CODE>DoHighlightSelection</CODE> method of the view object in which the selecting takes place.<P>
 <A HREF=MacAppProgGuide-94.html#MARKER-9-19>Chapter 15, "Working With the Mouse,"</A> provides recipes and code samples for working with the mouse.<P>
<A NAME=HEADING67-12></A>
<H2><A NAME=MARKER-2-162></A>Selecting With the Mouse</H2>
 Your application may allow the user to select some or all of the items displayed in a view. To handle selection, you create and post a selection command based on a subclass of <CODE>TTracker</CODE>. Your selection command needs to detect when the user attempts to select something, determine what was selected, mark it in the view by highlighting it, and mark it as selected in your data structure. To do so, it implements a <CODE>TrackMouse</CODE> method that examines the mouse point and looks through any visible items in the view to determine whether a selection action has taken place.<P>
 MacApp's <CODE>TTEView</CODE> class <A HREF=MacAppProgGuide-70.html#MARKER-9-316>(page 246)</A> handles text selection automatically.<P>
<A NAME=HEADING67-15></A>
<H2><A NAME=MARKER-2-163></A>Dragging With the Mouse</H2>
 Many applications allow the user to drag selected objects to reposition them within a view. Implementing simple dragging within a view is similar to implementing selecting with the mouse. You define a dragger class that is a subclass of <CODE>TTracker</CODE>. You override methods such as <CODE><A NAME=MARKER-2-164></A>TrackMouse</CODE>, <CODE><A NAME=MARKER-2-165></A>TrackConstrain</CODE>, and <CODE><A NAME=MARKER-2-166></A>TrackFeedback</CODE> to manage the movement of the object on the screen and to make changes to your view or document to reflect the changed position of the object. You may need to override the <CODE>Draw</CODE> and <CODE>DoHighlightSelection</CODE> methods in your view class to check whether dragging is currently in process, because those methods may act differently during dragging.<P>
 MacApp also supports drag and drop based on the Macintosh Drag Manager. Drag Manager support allows a user to drag information within a view, between views in an application, and between applications. MacApp's drag-and-drop support is described in <A HREF=MacAppProgGuide-72.html#MARKER-9-29>Chapter 9, "Drag and Drop."</A><P>
<A NAME=HEADING67-18></A>
<H2><A NAME=MARKER-2-167></A><A NAME=MARKER-9-168></A>Drawing With the Mouse</H2>
 When the user clicks while the cursor image is over your view, MacApp calls the <CODE><A NAME=MARKER-2-169></A>HandleMouseDown</CODE> method of the window object that contains your view. If the mouse event is in the window's frame or controls, the window's <CODE>HandleMouseDown</CODE> method performs the required action, such as closing or zooming the window.<P>
 If the mouse event is in the content area of the window, the window object's <CODE>HandleMouseDown</CODE> method calls <CODE>Inherited</CODE>, which invokes the <CODE>HandleMouseDown</CODE> method of <CODE>TView</CODE>. That method iterates over the views in the window's view hierarchy, calling the <CODE>DoMouseCommand</CODE> method. To handle drawing with the mouse, your view class overrides the <CODE>DoMouseCommand</CODE> method to create and post a drawing-command object. As with commands for selecting and dragging with the mouse, your drawing command should be a subclass of <CODE>TTracker</CODE>.<P>
 <A HREF=#MARKER-9-170>Figure 8-6</A> shows how a drawing command is created in the IconEdit sample application. For a code sample that implements drawing with the mouse, see <A HREF=MacAppProgGuide-96.html#MARKER-9-25>"Recipe--Implementing a Recordable Drawing Command," beginning on page 375</A>.<P>
<B>Figure 8-6  <A NAME=MARKER-9-170></A>Creating a drawing command</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-009.gif"><P>
<A NAME=HEADING67-24></A>
<H3><A NAME=MARKER-2-171></A>The Tracking Sequence</H3>
 While the mouse button is held down, MacApp calls the three mouse-tracking methods of the drawing command object, in this order: <CODE>TrackConstrain</CODE>, <CODE>TrackFeedback</CODE>, <CODE>TrackMouse</CODE>, and <CODE>TrackFeedback</CODE> (a second time). <P>
 Note that MacApp makes these four method calls in a continuous loop until the mouse button is released. You should minimize the processing you do in these methods so that if the user moves the mouse quickly, the mouse won't get ahead of the feedback you are providing.<P>
 Note also that while the mouse button remains down, the <CODE>TrackFeedback</CODE> method is called twice for each call to <CODE>TrackMouse</CODE>: once to erase the previous feedback and then again to draw it in the new location.<P>
 <A HREF=#MARKER-9-172>Figure 8-7</A> shows the flow of control during mouse tracking and drawing in the IconEdit application. The command is created in the <CODE>DoMouseCommand</CODE> method of a <CODE>TIconEditView</CODE> object. As the user continues to draw, holding the mouse button down, the <CODE>TrackConstrain</CODE>, <CODE>TrackFeedback</CODE>, <CODE>TrackMouse</CODE>, and <CODE>TrackFeedback</CODE> methods are called repeatedly.<P>
<B>Figure 8-7  <A NAME=MARKER-9-172></A>Drawing with the mouse in the IconEdit sample application</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-010.gif"><P>
 The last thing the <CODE>TrackMouse</CODE> method does is to return a reference to the drawing command it is part of. This tells MacApp to continue using this command. You could create a new command each time through the mouse-tracking loop, but it's more efficient to reuse the same command.<P>
 When the mouse button is finally released, MacApp calls two methods for the last time: <CODE>TrackFeedback</CODE> to erase feedback and <CODE>TrackMouse</CODE> to record the final position of the mouse.<P>
 If your drawing command's initialization method calls the <CODE>ITracker</CODE> method, passing a reference to the scroller for the view in which drawing takes place, the command will automatically support autoscrolling. For more information, see <A HREF=MacAppProgGuide-65.html#MARKER-9-127>"Autoscrolling" on page 220</A>.<A NAME=MARKER-2-173></A><P>
<A NAME=HEADING67-34></A>
<H3><A NAME=MARKER-2-174></A>The TrackConstrain Method</H3>
 A user can move the cursor image anywhere on the screen during drawing. You shouldn't try to constrain cursor movement, but your application can constrain feedback to a particular area, using the <CODE>TrackConstrain</CODE> method of your drawing command. For example, views in the IconEdit sample application have a border area in which drawing is not allowed. The <CODE>TrackConstrain</CODE> method of IconEdit's drawing command constrains drawing to the content area of the window, adjusted for the border area.<P>
<A NAME=HEADING67-36></A>
<H3><A NAME=MARKER-2-175></A>The TrackFeedback Method</H3>
 The <CODE>TrackFeedback</CODE> method allows your application to provide simple feedback while the user drags. The <CODE>TrackFeedback</CODE> method of the <CODE>TTracker</CODE> command class calls the <CODE>TrackFeedback</CODE> method of the view where the cursor is being tracked. The default <CODE>TrackFeedback</CODE> method for the <CODE>TView</CODE> class draws a gray rectangle from the point where the mouse button was pressed to the current cursor location. This feedback is sufficient for some drawing operations.<P>
 To supply specialized drawing feedback in your application, you can override <CODE>TrackFeedback</CODE> in your drawing view. If you just want to disable the default gray rectangle (as IconEdit does), you can override <CODE>TrackFeedback</CODE> with an empty implementation in either your drawing command or your drawing view.<P>
<A NAME=HEADING67-39></A>
<H3><A NAME=MARKER-2-176></A>The TrackMouse Method</H3>
 The <CODE>TrackMouse</CODE> method tracks cursor location and mouse state, including the current phase of mouse tracking: either the mouse button has just been pressed, the user is dragging, or the mouse button has just been released. Depending on your application, the <CODE>TrackMouse</CODE> method of your drawing command may need to determine whether the user is drawing or dragging, supply more complicated feedback than the default gray rectangle supplied by <CODE>TView</CODE>, or perform other processing while the user drags.<CODE><A NAME=MARKER-2-177></A><A NAME=MARKER-2-178></A><A NAME=MARKER-2-179></A></CODE><P>
<A NAME=HEADING67-41></A>
<H3><A NAME=MARKER-2-180></A><A NAME=MARKER-9-181></A>Undoing Drawing</H3>
 If you support drawing with the mouse, your drawing command should support the Undo menu item. Your command object inherits the <CODE>DoIt</CODE>, <CODE>UndoIt</CODE>, and <CODE>RedoIt</CODE> methods from <CODE>TTracker</CODE>. You can override these methods to perform a command action when the tracker has finished tracking, then undo or redo the action. However, that approach is not compatible with scripting and recording. A better approach is to have the tracker command send an Apple event to perform the command action, as shown in <A HREF=MacAppProgGuide-96.html#MARKER-9-25>"Recipe--Implementing a Recordable Drawing Command," beginning on page 375</A>. A still more robust approach is to have the tracker command post a separate, recordable command to perform the command action.<A NAME=MARKER-2-182></A><A NAME=MARKER-2-183></A><A NAME=MARKER-2-184></A><A NAME=MARKER-2-185></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-66.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-68.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
