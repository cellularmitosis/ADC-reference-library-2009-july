// Play Movie with Controller Sample// Based on QTShell// WWDC 2000#include "ComApplication.h"#include "ComFramework.h"#include "MacFramework.h"////////////// OpenMovieInWindow// Open a movie in a new movie window; return true if successful.//// This function is called from several places in our framework. The following combinations are possible://	* theMovie == NULL, theFSSpec == NULL: no movie, no file; elicit a movie file from user and open it//	* theMovie != NULL, theFSSpec == NULL: new movie, no file (yet)//	* theMovie == NULL, theFSSpec != NULL: no movie, but we have an FSSpec; so just open the specified movie file//	* theMovie != NULL, theFSSpec != NULL: new movie, theFSSpec contains (at least) the movie name////////////Boolean OpenMovieInWindow (Movie theMovie, FSSpec *theFSSpec){	WindowObject			myWindowObject = NULL;	Movie					myMovie = NULL;	MovieController			myMC = NULL;	GraphicsImportComponent	myImporter = NULL;	WindowReference			myWindow = NULL;	FSSpec					myFSSpec;	short					myRefNum = kInvalidFileRefNum;	short					myResID = 0;	OSType 					myTypeList[] = {kQTFileTypeMovie, kQTFileTypeQuickTimeImage};	short					myNumTypes = 2;	GrafPtr					mySavedPort;	Rect					myRect = {0, 0, 0, 0};	Point					myPoint;	QTFrameFileFilterUPP	myFileFilterUPP = NULL;	OSErr					myErr = noErr;#if TARGET_OS_MAC	myNumTypes = 0;#endif	// get the current port; we may need to restore it if we cannot successfully create a new window	GetPort(&mySavedPort);		// if we got neither a movie nor an FSSpec passed in, prompt the user for a movie file	if ((theMovie == NULL) && (theFSSpec == NULL)) {		myFileFilterUPP = QTFrame_GetFileFilterUPP((ProcPtr)QTFrame_FilterFiles);			myErr = QTFrame_GetOneFileWithPreview(myNumTypes, (QTFrameTypeListPtr)myTypeList, &myFSSpec, myFileFilterUPP);			if (myFileFilterUPP != NULL)			DisposeNavObjectFilterUPP(myFileFilterUPP);		if (myErr != noErr)			goto bail;	}		// if we got an FSSpec passed in, copy it into myFSSpec	if (theFSSpec != NULL) {		FSMakeFSSpec(theFSSpec->vRefNum, theFSSpec->parID, theFSSpec->name, &myFSSpec);			}	// if we got no movie passed in, read one from the specified file	if (theMovie == NULL) {		// see if the FSSpec picks out an image file; if so, skip the movie-opening code		myErr = GetGraphicsImporterForFile(&myFSSpec, &myImporter);		if (myImporter != NULL)			goto gotImageFile;					// ideally, we'd like read and write permission, but we'll settle for read-only permission		myErr = OpenMovieFile(&myFSSpec, &myRefNum, fsRdWrPerm);		if (myErr != noErr)			myErr = OpenMovieFile(&myFSSpec, &myRefNum, fsRdPerm);		// if we couldn't open the file with even just read-only permission, bail....		if (myErr != noErr)			goto bail;		// now fetch the first movie from the file		myResID = 0;		myErr = NewMovieFromFile(&myMovie, myRefNum, &myResID, NULL, newMovieActive, NULL);		if (myErr != noErr)			goto bail;	} else {		myMovie = theMovie;	}	//////////	//	// at this point, myMovie is an open movie, but myFSSpec may or may not be a valid FSSpec	//	//////////		// set the default progress procedure for the movie	SetMovieProgressProc(myMovie, (MovieProgressUPP)-1, 0);		gotImageFile:	// create a new window to display the movie in	myWindow = QTFrame_CreateMovieWindow();	if (myWindow == NULL)		goto bail;		myWindowObject = QTFrame_GetWindowObjectFromWindow(myWindow);	if (myWindowObject == NULL)		goto bail;		// set the window title	QTFrame_SetWindowTitleFromFSSpec(myWindow, &myFSSpec, true);	// make sure the movie or image file uses the window GWorld	if (myMovie != NULL)		SetMovieGWorld(myMovie, (CGrafPtr)QTFrame_GetPortFromWindowReference(myWindow), NULL);	if (myImporter != NULL)		GraphicsImportSetGWorld(myImporter, (CGrafPtr)QTFrame_GetPortFromWindowReference(myWindow), NULL);	// create and configure the movie controller	myMC = CreateController(myMovie, myWindow, true);			// store movie info in the window record	(**myWindowObject).fMovie = myMovie;	(**myWindowObject).fController = myMC;	(**myWindowObject).fGraphicsImporter = myImporter;	(**myWindowObject).fFileResID = myResID;	(**myWindowObject).fFileRefNum = myRefNum;	(**myWindowObject).fCanResizeWindow = true;	(**myWindowObject).fIsDirty = false;	(**myWindowObject).fIsQTVRMovie = QTUtils_IsQTVRMovie(myMovie);	(**myWindowObject).fInstance = NULL;	(**myWindowObject).fAppData = NULL;	(**myWindowObject).fFileFSSpec = myFSSpec;		// do any application-specific window object initialization	QTApp_SetupWindowObject(myWindowObject);		// size the window to fit the movie and controller	QTFrame_SizeWindowToMovie(myWindowObject);	// set the movie's play hints to allow dynamic resizing	SetMoviePlayHints(myMovie, hintsAllowDynamicResize, hintsAllowDynamicResize);	// set the movie's position, if it has a 'WLOC' user data atom	myErr = QTUtils_GetWindowPositionFromFile(myMovie, &myPoint);	// show the window#if TARGET_OS_MAC	MoveWindow(myWindow, myPoint.h, myPoint.v, false);	ShowWindow(myWindow);	SelectWindow(myWindow);								// make it front-most, since it's just been created	InvalWindowRect(myWindow, GetWindowPortBounds(myWindow, &myRect));#endif#if TARGET_OS_WIN32	SetWindowPos(myWindow, 0, myPoint.h, myPoint.v, 0, 0, SWP_NOZORDER | SWP_NOSIZE);	ShowWindow(myWindow, SW_SHOW);	UpdateWindow(myWindow);#endif	// if the movie is a streamed movie, then start it playing immediately	if (QTUtils_IsStreamedMovie(myMovie))		MCDoAction(myMC, mcActionPrerollAndPlay, (void *)GetMoviePreferredRate(myMovie));			return(true);	bail:	if (myWindow != NULL)#if TARGET_OS_MAC		DisposeWindow(myWindow);#endif#if TARGET_OS_WIN32		SendMessage(ghWndMDIClient, WM_MDIDESTROY, (WPARAM)myWindow, 0L);#endif			if (myMC != NULL)		DisposeMovieController(myMC);			if (myMovie != NULL)		DisposeMovie(myMovie);			if (myRefNum != 0)		CloseMovieFile(myRefNum);	if (myImporter != NULL)		CloseComponent(myImporter);			MacSetPort(mySavedPort);	// restore the port that was active when this function was called	return(false);}