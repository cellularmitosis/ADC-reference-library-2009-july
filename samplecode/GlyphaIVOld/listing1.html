<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GlyphaIVOld - /G4Enemy.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Games/index.html">Games</a> &gt; <a href="../../samplecode/Games/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">GlyphaIVOld</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Games/idxGraphicsImaging-date.html" target="_blank">Games > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GlyphaIVOld</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/G4Enemy.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/G4Enemy.c</option>
<option value="listing2.html">/G4Externs.h</option>
<option value="listing3.html">/G4Graphics.c</option>
<option value="listing4.html">/G4Interface.c</option>
<option value="listing5.html">/G4Lava.c</option>
<option value="listing6.html">/G4Main.c</option>
<option value="listing7.html">/G4Play.c</option>
<option value="listing8.html">/G4Prefs.c</option>
<option value="listing9.html">/G4SetUpTakeDown.c</option>
<option value="listing10.html">/G4Sound.c</option>
<option value="listing11.html">/G4Utilities.c</option></select>
				</p>
				</form>
				<p><strong><a href="GlyphaIVOld.zip">Download Sample</a></strong> (&#147;GlyphaIVOld.zip&#148;, 106.6K)<BR>
<strong><a href="GlyphaIVOld.dmg">Download Sample</a></strong> (&#147;GlyphaIVOld.dmg&#148;, 175.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//============================================================================//----------------------------------------------------------------------------//                  Enemy.c//----------------------------------------------------------------------------//============================================================================// This file contains all enemy related functions (enemy &quot;AI&quot;).  It handles\xC9// the enemy decision making proccess, moves the enemies, etc.#include &quot;G4Externs.h&quot;#define kEnemyImpulse      8#define kOwlMaxHVel        96#define kOwlMaxVVel        320#define kOwlHeightSmell      96#define kOwlFlapImpulse      32#define kWolfMaxHVel      128#define kWolfMaxVVel      400#define kWolfHeightSmell    160#define kWolfFlapImpulse    48#define kJackalMaxHVel      192#define kJackalMaxVVel      512#define kJackalHeightSmell    240#define kJackalFlapImpulse    72Boolean SetEnemyInitialLocation (Rect *);void SetEnemyAttributes (short);short AssignNewAltitude (void);void InitEnemy (short, Boolean);void CheckEnemyPlatformHit (short);void CheckEnemyRoofCollision (short);void HandleIdleEnemies (short);void HandleFlyingEnemies (short);void HandleWalkingEnemy (short);void HandleSpawningEnemy (short);void HandleFallingEnemy (short);void HandleEggEnemy (short);void ResolveEnemyPlayerHit (short);handInfo  theHand;eyeInfo    theEye;Rect    grabZone;short    deadEnemies, spawnedEnemies, numEnemiesThisLevel, numOwls;extern  playerType  thePlayer;extern  enemyType  theEnemies[kMaxEnemies];extern  Rect    platformRects[6], enemyInitRects[5];extern  long    theScore;extern  short    numLedges, numEnemies, countDownTimer;extern  short    levelOn;extern  Boolean    evenFrame, doEnemyFlapSound, doEnemyScrapeSound;//==============================================================  Functions//--------------------------------------------------------------  SetEnemyInitialLocation// When a new enemy is about to be &quot;born&quot;, this function is called to determine\xC9// the enemies starting location.  The only thing important here is that the enemy\xC9// appears on a valid platform for the particular level we're on.  As well, which\xC9// platform he (it) appears on should be random.Boolean SetEnemyInitialLocation (Rect *theRect){  short    where, possibilities;  Boolean    facing;    possibilities = numLedges - 1;    // Determine number of valid platforms.  where = RandomInt(possibilities);  // Choose one at random.  *theRect = enemyInitRects[where];  // Initially place enemy at default location.    switch (where)            // Determine if enemy facing left or right.  {                  // It depends upon which platform they're on.    case 0:              // These are the left-most platforms.    case 2:    facing = TRUE;          // Enemy will face right.    break;        case 3:              // Special case for the center platform.    if (RandomInt(2) == 0)      // Enemy randomly faces either left or right.      facing = TRUE;    else      facing = FALSE;    break;        default:            // Catch remaining (right-most) platforms.    facing = FALSE;          // Enemy will face left.    break;  }    if ((levelOn % 5) == 4)        // Handle special case for Egg Wave  {                  // Re-define enemy bounds.    theRect-&gt;left += 12 + RandomInt(48) - 24;    theRect-&gt;right = theRect-&gt;left + 24;    theRect-&gt;top = theRect-&gt;bottom - 24;  }    return (facing);}//--------------------------------------------------------------  SetEnemyAttributes// Depending upon the type of enemy this function is passed (there are three\xC9// types of sphinx enemies), this function sets up that enemies various\xC9// attributes - such as maximum vertical velocity, etc.void SetEnemyAttributes (short i){  short    h;                      // Point enemy toward center of screen.  h = (theEnemies[i].dest.left + theEnemies[i].dest.right) &gt;&gt; 1;  if (h &lt; 320)              // If enemy in left half of screen\xC9    theEnemies[i].facingRight = TRUE;  // the enemy will face to the right.  else                  // Otherwise, if in right half of screen\xC9    theEnemies[i].facingRight = FALSE;  // face to the left.    switch (theEnemies[i].kind)        // Okay, depending upon what &quot;kind&quot; of enemy\xC9  {                    // we're dealing with....    case kOwl:              // The owl is the simplest (wimpiest) enemy.    if (theEnemies[i].facingRight)    // Choose which graphic to use.      theEnemies[i].srcNum = 0;    else      theEnemies[i].srcNum = 2;                      // Set owl's velocity limitations.    theEnemies[i].maxHVel = kOwlMaxHVel;    theEnemies[i].maxVVel = kOwlMaxVVel;                      // This is the distance within which he will\xC9                      // pursue the player (it's strictly Y distance).    theEnemies[i].heightSmell = kOwlHeightSmell;                      // This is how powerful the owl's &quot;flap&quot; is.    theEnemies[i].flapImpulse = kOwlFlapImpulse;    break;        case kWolf:              // The wolf sphinx is of medium difficulty.    if (theEnemies[i].facingRight)    // Choose which graphic to use.      theEnemies[i].srcNum = 4;    else      theEnemies[i].srcNum = 6;                      // Set wolf's velocity limitations.    theEnemies[i].maxHVel = kWolfMaxHVel;    theEnemies[i].maxVVel = kWolfMaxVVel;                      // This is the distance within which he will\xC9                      // pursue the player (it's strictly Y distance).    theEnemies[i].heightSmell = kWolfHeightSmell;                      // This is how powerful the wolf's &quot;flap&quot; is.    theEnemies[i].flapImpulse = kWolfFlapImpulse;    break;        case kJackal:            // The jackal is the swiftest, toughest enemy.    if (theEnemies[i].facingRight)    // Choose which graphic to use.      theEnemies[i].srcNum = 8;    else      theEnemies[i].srcNum = 10;                      // Set jackal's velocity limitations.    theEnemies[i].maxHVel = kJackalMaxHVel;    theEnemies[i].maxVVel = kJackalMaxVVel;                      // This is the distance within which he will\xC9                      // pursue the player (it's strictly Y distance).    theEnemies[i].heightSmell = kJackalHeightSmell;                      // This is how powerful the jackal's &quot;flap&quot; is.    theEnemies[i].flapImpulse = kJackalFlapImpulse;    break;  }}//--------------------------------------------------------------  AssignNewAltitude// The sphinxes &quot;patrol&quot; specific altitudes in the arena.  After wrapping around\xC9// the screen a few times, they randomly select a new altitude to patrol (this\xC9// keeps the player from finding a &quot;safe&quot; place to stand.  This function chooses\xC9// a new altitude for the enemy to patrol.short AssignNewAltitude (void){  short    which, altitude;    which = RandomInt(4);    // There are only 4 &quot;patrol altitudes&quot;.  switch (which)        // Depending on which random number came up\xC9  {    case 0:          // This is just below the ceiling.    altitude = 65 &lt;&lt; 4;    break;        case 1:          // This is below the top platforms but above the\xC9    altitude = 150 &lt;&lt; 4;  // center platform.    break;        case 2:          // This is just below the center platform.    altitude = 245 &lt;&lt; 4;    break;        case 3:          // This is striahgt across the lava pit.    altitude = 384 &lt;&lt; 4;    break;  }    return (altitude);}//--------------------------------------------------------------  InitEnemy// This resets an enemies info.  It is called when a new enemy is to be born.// It is called if an egg is about to hatch, if a new level has begun, or if\xC9// if it is simply time to add a new enemy.void InitEnemy (short i, Boolean reincarnated){  Boolean    facing;    if (spawnedEnemies &lt; numEnemiesThisLevel)  // New enemy to appear (in other words\xC9  {                      // this enemy is not hatched).                        // Call function to set new location.    facing = SetEnemyInitialLocation(&amp;theEnemies[i].dest);    theEnemies[i].wasDest = theEnemies[i].dest;    theEnemies[i].h = theEnemies[i].dest.left &lt;&lt; 4;    theEnemies[i].v = theEnemies[i].dest.top &lt;&lt; 4;    theEnemies[i].wasH = theEnemies[i].h;  // Reset &quot;old locations&quot; variables.    theEnemies[i].wasV = theEnemies[i].v;                        // Assign the &quot;patrol altitude&quot;.    theEnemies[i].targetAlt = theEnemies[i].v - (40 &lt;&lt; 4);    theEnemies[i].hVel = 0;          // Zero velocity vraiables.    theEnemies[i].vVel = 0;    theEnemies[i].pass = 0;          // Zero number of times wrapped around.    if ((levelOn % 5) == 4)          // If this is an Egg Wave\xC9      theEnemies[i].mode = kEggTimer;    // set enemy in &quot;wait to hatch&quot; mode.    else                  // Otherwise, just sut enemy in\xC9      theEnemies[i].mode = kIdle;      // idle mode.    if (i &lt; numOwls)            // Determine what kind of enemy.      theEnemies[i].kind = kOwl;    else if (i &gt; (numOwls + 6))        theEnemies[i].kind = kJackal;    else      theEnemies[i].kind = kWolf;    theEnemies[i].facingRight = facing;    SetEnemyAttributes(i);          // Initialize enemy attributes.        if (reincarnated)            // If this is an egg that will hatch\xC9      theEnemies[i].frame = RandomInt(48) + 8 + (numOwls * 32);    else      theEnemies[i].frame = RandomInt(48) + 32 + (64 * i) + (numOwls * 32);        if ((levelOn % 5) == 4)          // If this is an Egg Wave      theEnemies[i].kind--;        // Decrement &quot;kind&quot; (since it's incremented\xC9                        // when they hatch).    spawnedEnemies++;            // Keep track of number of enemies active.  }}//--------------------------------------------------------------  GenerateEnemies// This function is called only for a new level.  It goes through and\xC9// intializes a whole host of enemies in one go.void GenerateEnemies (void){  short    i;    if ((levelOn % 5) == 4)      // If this is an Egg Wave\xC9  {    numEnemies = kMaxEnemies;  // we insist upon the maximum number of enemies.    numEnemiesThisLevel = numEnemies;  }  else              // If not an egg wave, use a formula to determine\xC9  {                // the max number of enemies that are to be active.    numEnemies = ((levelOn / 5) + 2) * 2;    if (numEnemies &gt; kMaxEnemies)      numEnemies = kMaxEnemies;    numEnemiesThisLevel = numEnemies * 2;  }    deadEnemies = 0;        // No dead enemies yet.                    // Use formula to determine the number of owls\xC9                  // to appear.  This number goes down as the levels\xC9                  // increase.  It is used not merely to determine\xC9                  // how many owls are to appear, but also how many\xC9                  // of the more advanced enemies.  For example, when\xC9                  // numOwls goes down to zero, all the enemies will\xC9                  // be of the more advanced breed (wolves and jackals).  numOwls = 4 - ((levelOn + 2) / 5);  if (numOwls &lt; 0)    numOwls = 0;    spawnedEnemies = 0;        // No enemies have been &quot;born&quot; yet.                  // Go through and set up all the enemies.  for (i = 0; i &lt; numEnemies; i++)    InitEnemy(i, FALSE);}//--------------------------------------------------------------  CheckEnemyPlatformHit// This is the enemy counterpart to a similarly named function that tests for\xC9// player collsions with the platforms.void CheckEnemyPlatformHit (short h){  Rect    hRect, vRect, whoCares;  short    i, offset;    for (i = 0; i &lt; numLedges; i++)          // Test all platforms.  {                        // Do a simple bounds test.    if (SectRect(&amp;theEnemies[h].dest, &amp;platformRects[i], &amp;whoCares))    {                      // If the enemy has hit the platform\xC9      hRect.left = theEnemies[h].dest.left;  // Determine if enemy hit platform sides.      hRect.right = theEnemies[h].dest.right;      hRect.top = theEnemies[h].wasDest.top;      hRect.bottom = theEnemies[h].wasDest.bottom;                          // Test this new special rect to see if\xC9                          // the enemy hit on of the platform sides.      if (SectRect(&amp;hRect, &amp;platformRects[i], &amp;whoCares))      {                    // If enemy hit from side, see which side.                          // We handle left and right seperatrely\xC9                          // so that there's no ambiguity as to\xC9                          // what the new velocity and location\xC9                          // of the enemy is.  If we did not do it\xC9                          // this way, there is the chance that an\xC9                          // enemy get's &quot;stuck&quot; on the edge of\xC9                          // a platform (due to round-off errors).        if (theEnemies[h].h &gt; theEnemies[h].wasH)        {                  // Enemy was moving right (hit left side).          offset = theEnemies[h].dest.right - platformRects[i].left;                          // Slide enemy &quot;off&quot; platform.          theEnemies[h].dest.left -= offset;          theEnemies[h].dest.right -= offset;          theEnemies[h].h = theEnemies[h].dest.left &lt;&lt; 4;          theEnemies[h].wasH = theEnemies[h].h;                          // Bounce enemy (negate velocity).          if (theEnemies[h].hVel &gt; 0)            theEnemies[h].hVel = -(theEnemies[h].hVel &gt;&gt; 1);          else            theEnemies[h].hVel = theEnemies[h].hVel &gt;&gt; 1;        }        if (theEnemies[h].h &lt; theEnemies[h].wasH)        {                  // Enemy was moving left (hit right side).          offset = platformRects[i].right - theEnemies[h].dest.left;                          // Slide enemy &quot;off&quot; platform.          theEnemies[h].dest.left += offset;          theEnemies[h].dest.right += offset;          theEnemies[h].h = theEnemies[h].dest.left &lt;&lt; 4;          theEnemies[h].wasH = theEnemies[h].h;                          // Bounce enemy (negate velocity).          if (theEnemies[h].hVel &lt; 0)            theEnemies[h].hVel = -(theEnemies[h].hVel &gt;&gt; 1);          else            theEnemies[h].hVel = theEnemies[h].hVel &gt;&gt; 1;        }        doEnemyScrapeSound = TRUE;      // Play a collision sound.                          // Flip enemy to face opposite direction.        theEnemies[h].facingRight = !theEnemies[h].facingRight;      }      else                  // Enemy didn't hit from side.      {                    // See if enemy hit top/bottom.        vRect.left = theEnemies[h].wasDest.left;        vRect.right = theEnemies[h].wasDest.right;        vRect.top = theEnemies[h].dest.top;        vRect.bottom = theEnemies[h].dest.bottom;                          // Special &quot;test rect&quot; for top/bottom hit.        if (SectRect(&amp;vRect, &amp;platformRects[i], &amp;whoCares))        {                  // If hit the top/bottom of platform\xC9          if (theEnemies[h].mode == kFalling)          {                // Was the enemy a falling egg?                          // Bounce egg (with some inelasticity).            theEnemies[i].hVel -= (theEnemies[i].hVel &gt;&gt; 3);                          // When the eggs velocity is between\xC9                          // +/- 8, consider the egg at rest.            if ((theEnemies[i].hVel &lt; 8) &amp;&amp; (theEnemies[i].hVel &gt; -8))            {              if (theEnemies[i].hVel &gt; 0)                theEnemies[i].hVel--;              else if (theEnemies[i].hVel &lt; 0)                theEnemies[i].hVel++;            }          }                          // Specifically, did enemy hit the top?          if (theEnemies[h].v &gt; theEnemies[h].wasV)          {                // Enemy heading down (hit platform top).            offset = theEnemies[h].dest.bottom - platformRects[i].top;                          // Move enemy up off platform.            theEnemies[h].dest.top -= offset;            theEnemies[h].dest.bottom -= offset;            theEnemies[h].v = theEnemies[h].dest.top &lt;&lt; 4;            theEnemies[h].wasV = theEnemies[h].v;            if (theEnemies[h].vVel &gt; kDontFlapVel)              doEnemyScrapeSound = TRUE;                          // &quot;Bounce&quot; enemy.            if (theEnemies[h].vVel &gt; 0)              theEnemies[h].vVel = -(theEnemies[h].vVel &gt;&gt; 1);            else              theEnemies[h].vVel = theEnemies[h].vVel &gt;&gt; 1;            if ((theEnemies[h].vVel &lt; 8) &amp;&amp; (theEnemies[h].vVel &gt; -8) &amp;&amp;                 (theEnemies[h].hVel == 0) &amp;&amp; (theEnemies[h].mode == kFalling))            {            // Here we handle an egg come to rest.              if (((theEnemies[h].dest.right - 8) &gt; platformRects[i].right) &amp;&amp;                   (theEnemies[h].hVel == 0))              {          // Special case where egg right on edge.                theEnemies[h].hVel = 32;              }              else if (((theEnemies[h].dest.left + 8) &lt; platformRects[i].left) &amp;&amp;                   (theEnemies[h].hVel == 0))              {          // Special case where egg right on edge.                theEnemies[h].hVel = -32;              }              else        // If egg not on the edge of platform\xC9              {          // switch to &quot;timer&quot; mode.                theEnemies[h].mode = kEggTimer;                theEnemies[h].frame = (numOwls * 96) + 128;                theEnemies[h].vVel = 0;              }            }          }          if (theEnemies[h].v &lt; theEnemies[h].wasV)          {              // Enemy was rising - hit bottom of platform.            offset = theEnemies[h].dest.top - platformRects[i].bottom;                        // Slide enemy off platform.            theEnemies[h].dest.top -= offset;            theEnemies[h].dest.bottom -= offset;            theEnemies[h].v = theEnemies[h].dest.top &lt;&lt; 4;            theEnemies[h].wasV = theEnemies[h].v;                        // Play collision sound.            doEnemyScrapeSound = TRUE;                        // &quot;Bounce&quot; enemy downward from platform.            if (theEnemies[h].vVel &lt; 0)              theEnemies[h].vVel = -(theEnemies[h].vVel &gt;&gt; 2);            else              theEnemies[h].vVel = theEnemies[h].vVel &gt;&gt; 2;            if ((theEnemies[h].vVel &lt; 8) &amp;&amp; (theEnemies[h].vVel &gt; -8) &amp;&amp;                 (theEnemies[h].hVel == 0) &amp;&amp; (theEnemies[h].mode == kFalling))            {              theEnemies[h].mode = kEggTimer;              theEnemies[h].frame = (numOwls * 96) + 128;              theEnemies[h].vVel = 0;            }          }        }      }    }  }}//--------------------------------------------------------------  CheckEnemyRoofCollision// Like the player counterpart, this function checks to see if an enemy has hit\xC9// the ceiling or the lava.  It handles the consequences of both cases.void CheckEnemyRoofCollision (short i){  short    offset;    if (theEnemies[i].dest.top &lt; (kRoofHeight - 2))  {          // If enemy has hit the ceiling\xC9    offset = kRoofHeight - theEnemies[i].dest.top;            // Move enemy down to a &quot;legal&quot; altitude.    theEnemies[i].dest.top += offset;    theEnemies[i].dest.bottom += offset;    theEnemies[i].v = theEnemies[i].dest.top &lt;&lt; 4;            // Play a collision sound.    doEnemyScrapeSound = TRUE;            // Bounce enemy downward.    theEnemies[i].vVel = -(theEnemies[i].vVel &gt;&gt; 2);  }  else if (theEnemies[i].dest.top &gt; kLavaHeight)  {          // If enemy has fallen into lava\xC9            // kill that enemy.    theEnemies[i].mode = kDeadAndGone;    deadEnemies++;            // Play a splash sound.    {      short left = theEnemies[i].dest.left;      short right = theEnemies[i].dest.right;      short bottom = theEnemies[i].dest.bottom;      short delta = (right - left);      short temp = left * 32;      short splashItr;            for(splashItr = 0; splashItr &lt; 32; splashItr++)      {        StartPixelShatter(temp / 32, bottom, (theEnemies[i].hVel * 0.75), -(theEnemies[i].vVel * 0.75), kShatterLavaSplash);        temp += delta;      }    }    PlayExternalSound(kSplashSound, kSplashPriority);            // Call up another from the ranks.    InitEnemy(i, TRUE);  }}//--------------------------------------------------------------  HandleIdleEnemies// The following functions handle the various enemy modes.  Enemies are\xC9// considered to be in a specific mode and each mode is handled differently.// Idle enemies are ones who are &quot;invisible&quot; - not yet born.  While idle, a\xC9// timer is ticking down - when it reaches zero, the enemy appears.void HandleIdleEnemies (short i){  theEnemies[i].frame--;          // Decrement timer.  if (theEnemies[i].frame &lt;= 0)      // If timer is zero or less\xC9  {    theEnemies[i].mode = kSpawning;    // enemy is &quot;born&quot;.    theEnemies[i].wasH = theEnemies[i].h;    theEnemies[i].wasV = theEnemies[i].v;    theEnemies[i].hVel = 0;    theEnemies[i].vVel = 0;    theEnemies[i].frame = 0;    SetEnemyAttributes(i);        // Initialize enemy attributes.    PlayExternalSound(kSpawnSound, kSpawnPriority);  }}//--------------------------------------------------------------  HandleFlyingEnemies// Once an enemy takes off from a platform, they will always be in flying mode\xC9// unless they should be killed.  This function handles the flying mode.void HandleFlyingEnemies (short i){  short    dist;  Boolean    shouldFlap;                // Take into account gravity pulling enemy down.  theEnemies[i].vVel += kGravity;                // Get absolute difference in enemy/player altitude.  dist = thePlayer.dest.top - theEnemies[i].dest.top;  if (dist &lt; 0)    dist = -dist;                // See if the player is within the enemy's &quot;seek&quot; range.  if ((dist &lt; theEnemies[i].heightSmell) &amp;&amp;       ((thePlayer.mode == kFlying) || (thePlayer.mode == kWalking)))  {              // Enemy will actively seek the player.    if (thePlayer.dest.left &lt; theEnemies[i].dest.left)    {            // Determine if quicker to go left or right to get player.      dist = theEnemies[i].dest.left - thePlayer.dest.left;      if (dist &lt; 320)    // Closest route is to the left.        theEnemies[i].facingRight = FALSE;      else        // Closest route is to the right.        theEnemies[i].facingRight = TRUE;    }    else if (thePlayer.dest.left &gt; theEnemies[i].dest.left)    {            // Determine if quicker to go left or right to get player.      dist = thePlayer.dest.left - theEnemies[i].dest.left;      if (dist &lt; 320)    // Closest route is to the right.        theEnemies[i].facingRight = TRUE;      else        // Closest route is to the left.        theEnemies[i].facingRight = FALSE;    }                // Seek an altitude 16 pixels above player.    if (((theEnemies[i].v + 16) &gt; thePlayer.v) &amp;&amp; (evenFrame))      shouldFlap = TRUE;    else      shouldFlap = FALSE;  }  else            // Else, player not within enemy's &quot;seek&quot; altitude.  {              // Flap if necessary to maintain &quot;patrol altitude&quot;.    if ((theEnemies[i].v &gt; theEnemies[i].targetAlt) &amp;&amp; (evenFrame))      shouldFlap = TRUE;    else      shouldFlap = FALSE;  }    if (shouldFlap)        // If the enemy has determined that it needs to flap\xC9  {              // Give the enemy lift &amp; play the flap sound.    theEnemies[i].vVel -= theEnemies[i].flapImpulse;    doEnemyFlapSound = TRUE;  }                // Enemy never hovers - must move right or left.  if (theEnemies[i].facingRight)  {              // If enemy facing right - move enemy to the right.    theEnemies[i].hVel += kEnemyImpulse;    if (theEnemies[i].hVel &gt; theEnemies[i].maxHVel)      theEnemies[i].hVel = theEnemies[i].maxHVel;                // Determine correct graphic for enemy.    switch (theEnemies[i].kind)    {      case kOwl:      if (shouldFlap)        theEnemies[i].srcNum = 12;      else        theEnemies[i].srcNum = 13;      break;            case kWolf:      if (shouldFlap)        theEnemies[i].srcNum = 16;      else        theEnemies[i].srcNum = 17;      break;            case kJackal:      if (shouldFlap)        theEnemies[i].srcNum = 20;      else        theEnemies[i].srcNum = 21;      break;    }      }  else            // If enemy not facing right (left) move to the left.  {    theEnemies[i].hVel -= kEnemyImpulse;    if (theEnemies[i].hVel &lt; -theEnemies[i].maxHVel)      theEnemies[i].hVel = -theEnemies[i].maxHVel;                // Determine correct graphic for enemy.    switch (theEnemies[i].kind)    {      case kOwl:      if (shouldFlap)        theEnemies[i].srcNum = 14;      else        theEnemies[i].srcNum = 15;      break;            case kWolf:      if (shouldFlap)        theEnemies[i].srcNum = 18;      else        theEnemies[i].srcNum = 19;      break;            case kJackal:      if (shouldFlap)        theEnemies[i].srcNum = 22;      else        theEnemies[i].srcNum = 23;      break;    }  }                    // Move enemy horizontally based on hori velocity.  theEnemies[i].h += theEnemies[i].hVel;  theEnemies[i].dest.left = theEnemies[i].h &gt;&gt; 4;  theEnemies[i].dest.right = theEnemies[i].dest.left + 64;                    // Move enemy vertically based on vertical velocity.  theEnemies[i].v += theEnemies[i].vVel;  theEnemies[i].dest.top = theEnemies[i].v &gt;&gt; 4;  theEnemies[i].dest.bottom = theEnemies[i].dest.top + 40;                    // Check for wrap-around.  if (theEnemies[i].dest.left &gt; 640)  {                  // If off right edge, wrap around to left side.    OffsetRect(&amp;theEnemies[i].dest, -640, 0);    theEnemies[i].h = theEnemies[i].dest.left &lt;&lt; 4;    OffsetRect(&amp;theEnemies[i].wasDest, -640, 0);    theEnemies[i].pass++;      // Increment number of &quot;wrap-arounds&quot; for this enemy.    if (theEnemies[i].pass &gt; 2)    // After two screen passes (wrap arounds)\xC9    {                // enemy patrols a new altitude.      theEnemies[i].targetAlt = AssignNewAltitude();      theEnemies[i].pass = 0;    }  }  else if (theEnemies[i].dest.right &lt; 0)  {                  // If off left edge, wrap around to right side.    OffsetRect(&amp;theEnemies[i].dest, 640, 0);    theEnemies[i].h = theEnemies[i].dest.left &lt;&lt; 4;    OffsetRect(&amp;theEnemies[i].wasDest, 640, 0);    theEnemies[i].pass++;    if (theEnemies[i].pass &gt; 2)    {      theEnemies[i].targetAlt = AssignNewAltitude();      theEnemies[i].pass = 0;    }  }                    // Throw a touch of friction into the mix.  theEnemies[i].vVel -= theEnemies[i].vVel &gt;&gt; 4;                    // Keep enemies from moving excessively fast.  if (theEnemies[i].vVel &gt; theEnemies[i].maxVVel)    theEnemies[i].vVel = theEnemies[i].maxVVel;  else if (theEnemies[i].vVel &lt; -theEnemies[i].maxVVel)    theEnemies[i].vVel = -theEnemies[i].maxVVel;    CheckEnemyRoofCollision(i);      // Check for lava/celing collisions.  CheckEnemyPlatformHit(i);      // Check for platform collisions.}//--------------------------------------------------------------  HandleWalkingEnemy// This is a brief mode for an enemy.  When an enemy has hatched from an egg, it\xC9// walks only for 8 game frames at which point it takes off and flies for the rest\xC9// of its life.void HandleWalkingEnemy (short i){  if (theEnemies[i].facingRight)    // If enemy facing right, walk to the right.  {    theEnemies[i].dest.left += 6;  // Move enemy to right.    theEnemies[i].dest.right += 6;    switch (theEnemies[i].kind)    // Determine correct graphic for walking enemy.    {      case kOwl:      theEnemies[i].srcNum = 1 - theEnemies[i].srcNum;      break;            case kWolf:      theEnemies[i].srcNum = 9 - theEnemies[i].srcNum;      break;            case kJackal:      theEnemies[i].srcNum = 17 - theEnemies[i].srcNum;      break;    }    theEnemies[i].hVel = 6 &lt;&lt; 4;  }  else                // If enemy not facing right (left), walk to the left.  {    theEnemies[i].dest.left -= 6;  // Move enemy to left.    theEnemies[i].dest.right -= 6;    switch (theEnemies[i].kind)    // Determine correct graphic for walking enemy.    {      case kOwl:      theEnemies[i].srcNum = 5 - theEnemies[i].srcNum;      break;            case kWolf:      theEnemies[i].srcNum = 13 - theEnemies[i].srcNum;      break;            case kJackal:      theEnemies[i].srcNum = 21 - theEnemies[i].srcNum;      break;    }    theEnemies[i].hVel = -6 &lt;&lt; 4;  }    theEnemies[i].frame++;        // Increment number of frames it has walked for.  if (theEnemies[i].frame &gt;= 8)    // If over 8, enemy takes off an flies.  {    theEnemies[i].mode = kFlying;  // Switch to flying mode.    theEnemies[i].frame = 0;    // Reset &quot;frame&quot; variable.    switch (theEnemies[i].kind)    // Determine correct graphic for flying enemy.    {      case kOwl:      if (theEnemies[i].facingRight)        theEnemies[i].srcNum = 12;      else        theEnemies[i].srcNum = 14;      break;            case kWolf:      if (theEnemies[i].facingRight)        theEnemies[i].srcNum = 16;      else        theEnemies[i].srcNum = 18;      break;            case kJackal:      if (theEnemies[i].facingRight)        theEnemies[i].srcNum = 20;      else        theEnemies[i].srcNum = 22;      break;    }                    // Re-size enemy bounds to a &quot;flying&quot; size.    theEnemies[i].dest.left -= 8;    theEnemies[i].dest.right += 8;    theEnemies[i].dest.bottom = theEnemies[i].dest.top + 40;    theEnemies[i].h = theEnemies[i].dest.left * 16;    theEnemies[i].v = theEnemies[i].dest.top * 16;  }}//--------------------------------------------------------------  HandleSpawningEnemy// This is an enemy &quot;rising out of a platform&quot;.  Either an egg has just hatched\xC9// or a brand new enemy has been introduced.  Irregardless, the sphinx is born.// When the enemy is at its full height, it will begin to walk.void HandleSpawningEnemy (short i){  theEnemies[i].frame++;        // Advance timer.  if (theEnemies[i].frame &gt;= 48)    // If timer &gt;= 48, enemy begins to walk.  {    theEnemies[i].mode = kWalking;    theEnemies[i].frame = 0;        switch (theEnemies[i].kind)    // Determine appropriate graphic.    {      case kOwl:      if (theEnemies[i].facingRight)        theEnemies[i].srcNum = 0;      else        theEnemies[i].srcNum = 2;      break;            case kWolf:      if (theEnemies[i].facingRight)        theEnemies[i].srcNum = 4;      else        theEnemies[i].srcNum = 6;      break;            case kJackal:      if (theEnemies[i].facingRight)        theEnemies[i].srcNum = 8;      else        theEnemies[i].srcNum = 10;      break;    }  }  else              // If not full height, use &quot;timer&quot; to determine height.    theEnemies[i].dest.top = theEnemies[i].dest.bottom - theEnemies[i].frame;}//--------------------------------------------------------------  HandleFallingEnemy// A &quot;falling&quot; enemy is an air borne egg.  The enemy was killed, turned into an egg, \xC9// and the egg is in freefall.  If the egg comes to rest, it will begin a countdown\xC9// until it is hatched.void HandleFallingEnemy (short i){                  // Take into account gravity - accelerate egg down.  theEnemies[i].vVel += kGravity;                  // Don't allow velocities to skyrocket.  if (theEnemies[i].vVel &gt; theEnemies[i].maxVVel)    theEnemies[i].vVel = theEnemies[i].maxVVel;  else if (theEnemies[i].vVel &lt; -theEnemies[i].maxVVel)    theEnemies[i].vVel = -theEnemies[i].maxVVel;    if (evenFrame)          // Apply friction on even frames (who knows).  {                // &quot;Friction&quot; is 1/32nd of the velocity.    theEnemies[i].hVel -= (theEnemies[i].hVel &gt;&gt; 5);    if ((theEnemies[i].hVel &lt; 32) &amp;&amp; (theEnemies[i].hVel &gt; -32))    {      if (theEnemies[i].hVel &gt; 0)        theEnemies[i].hVel--;      else if (theEnemies[i].hVel &lt; 0)        theEnemies[i].hVel++;    }  }                  // Move egg horizontally.  theEnemies[i].h += theEnemies[i].hVel;  theEnemies[i].dest.left = theEnemies[i].h &gt;&gt; 4;  theEnemies[i].dest.right = theEnemies[i].dest.left + 24;                  // Move egg vertically.  theEnemies[i].v += theEnemies[i].vVel;  theEnemies[i].dest.top = theEnemies[i].v &gt;&gt; 4;  theEnemies[i].dest.bottom = theEnemies[i].dest.top + 24;                  // Check for wrap around.  if (theEnemies[i].dest.left &gt; 640)  {    OffsetRect(&amp;theEnemies[i].dest, -640, 0);    theEnemies[i].h = theEnemies[i].dest.left &lt;&lt; 4;    OffsetRect(&amp;theEnemies[i].wasDest, -640, 0);  }  else if (theEnemies[i].dest.right &lt; 0)  {    OffsetRect(&amp;theEnemies[i].dest, 640, 0);    theEnemies[i].h = theEnemies[i].dest.left &lt;&lt; 4;    OffsetRect(&amp;theEnemies[i].wasDest, 640, 0);  }    CheckEnemyRoofCollision(i);  // See if egg hit ceiling or lava.  CheckEnemyPlatformHit(i);  // Handle platform hit (it is here it determines if\xC9                // egg has come to rest and should begin countdown).}//--------------------------------------------------------------  HandleEggEnemy// This is the &quot;idle&quot; egg mode.  This is a static egg, sitting peacefully on\xC9// a platform.  Waiting patiently so it might hatch into a death-sphinx and\xC9// slaughter the player.void HandleEggEnemy (short i){  short    center;    theEnemies[i].frame--;        // Decrement the egg timer!  if (theEnemies[i].frame &lt; 24)    // When it falls below 24, egg starts shrinking.  {                  // Use &quot;frame&quot; to determine height of egg.    theEnemies[i].dest.top = theEnemies[i].dest.bottom - theEnemies[i].frame;    if (theEnemies[i].frame &lt;= 0)  // When the egg is completely flat (gone)\xC9    {                // then BOOM! a sphinx is spawned!      theEnemies[i].frame = 0;      PlayExternalSound(kSpawnSound, kSpawnPriority);      center = (theEnemies[i].dest.left + theEnemies[i].dest.right) &gt;&gt; 1;                    // Resize enemy bounds to new &quot;walking enemy&quot; size.      theEnemies[i].dest.left = center - 24;      theEnemies[i].dest.right = center + 24;      theEnemies[i].wasDest = theEnemies[i].dest;      theEnemies[i].h = theEnemies[i].dest.left &lt;&lt; 4;      theEnemies[i].v = theEnemies[i].dest.top &lt;&lt; 4;                    // Set up all other enemy variables.      theEnemies[i].wasH = theEnemies[i].h;      theEnemies[i].wasV = theEnemies[i].v;      theEnemies[i].hVel = 0;      theEnemies[i].vVel = 0;      theEnemies[i].mode = kSpawning;      theEnemies[i].kind++;      if (theEnemies[i].kind &gt; kJackal)        theEnemies[i].kind = kJackal;      SetEnemyAttributes(i);    }  }}//--------------------------------------------------------------  MoveEnemies// This is the &quot;master&quot; enemy function.  It goes through all the enemies\xC9// and calls the above functions depending upon an enemy's mode.void MoveEnemies (void){  short    i;    doEnemyFlapSound = FALSE;    // Intially, assume no flap or scrape sounds.  doEnemyScrapeSound = FALSE;                  // Go through each enemy.  for (i = 0; i &lt; numEnemies; i++)  {    switch (theEnemies[i].mode)    {              // Handle enemy according to mode it is in.      case kIdle:        // Enemy not born yet.      HandleIdleEnemies(i);      break;            case kFlying:      // Enemy air borne.      HandleFlyingEnemies(i);      break;            case kWalking:      // Enemy just born, walking off platform.      HandleWalkingEnemy(i);      break;            case kSpawning:      // Enemy growing from a platform.      HandleSpawningEnemy(i);      break;            case kFalling:      // Enemy is an egg in flight.      HandleFallingEnemy(i);      break;            case kEggTimer:      // Enemy is a patient, idle, silent egg.      HandleEggEnemy(i);      break;            case kDeadAndGone:    // Enemy no more - gone for good this level.      break;    }  }                  // If any sounds were flagged, play them.  if (doEnemyFlapSound)    PlayExternalSound(kFlap2Sound, kFlap2Priority);  if (doEnemyScrapeSound)    PlayExternalSound(kScrape2Sound, kScrape2Priority);                  // See if enough enemies were killed to advance to\xC9                  // next level (wave).  if ((deadEnemies &gt;= numEnemiesThisLevel) &amp;&amp; (countDownTimer == 0))    countDownTimer = 30;}//--------------------------------------------------------------  InitHandLocation// This simply sets up the hand.  Puts it deep in the lava (off bottom of screen).void InitHandLocation (void){  SetRect(&amp;theHand.dest, 0, 0, 56, 57);  OffsetRect(&amp;theHand.dest, 48, 460);}//--------------------------------------------------------------  HandleHand// This is the hand &quot;AI&quot;.  The hand, like the sphinx enemies, has modes.void HandleHand (void){  Rect    whoCares;  short    hDiff, vDiff, pull, speed;    switch (theHand.mode)  {    case kLurking:        // Hand is down, waiting for player to stray near.    if ((thePlayer.mode == kFlying) &amp;&amp; (SectRect(&amp;thePlayer.dest, &amp;grabZone, &amp;whoCares)))    {              // If player flies near, hand begins to reach out.      theHand.mode = kOutGrabeth;      InitHandLocation();    }    break;        case kOutGrabeth:      // Hand is either coming after or has a hold of player.    case kClutching:    if (SectRect(&amp;thePlayer.dest, &amp;grabZone, &amp;whoCares))    {              // See if player in the &quot;grab/clutch zone&quot;.      hDiff = theHand.dest.left - thePlayer.dest.left;      vDiff = theHand.dest.top - thePlayer.dest.top;                  // Ah!  Player caught.  Move player to correct\xC9                  // location relative to the hand (so the player\xC9                  // appears to, in fact, be held).      if (thePlayer.facingRight)        hDiff -= 3;      else        hDiff -= 21;      vDiff -= 29;                  // How hard/fast the hand moves depends on level.      speed = (levelOn &gt;&gt; 3) + 1;      if (hDiff &lt; 0)      {        theHand.dest.left += speed;        theHand.dest.right += speed;      }      else if (hDiff &gt; 0)      {        theHand.dest.left -= speed;        theHand.dest.right -= speed;      }      if (vDiff &lt; 0)      {        theHand.dest.top += speed;        theHand.dest.bottom += speed;      }      else if (vDiff &gt; 0)      {        theHand.dest.top -= speed;        theHand.dest.bottom -= speed;      }                  // Determine absolute distance player is from hand.      if (hDiff &lt; 0)        hDiff = -hDiff;      if (vDiff &lt; 0)        vDiff = -vDiff;            if ((hDiff &lt; 8) &amp;&amp; (vDiff &lt; 8))      {            // If player in the &quot;hot zone&quot;, player is nabbed!        theHand.mode = kClutching;        thePlayer.clutched = TRUE;                  // Player's movement is severely dampened.        thePlayer.hVel = thePlayer.hVel &gt;&gt; 3;        thePlayer.vVel = thePlayer.vVel &gt;&gt; 3;                  // Hand pulls player down (strength is greater on\xC9                  // higher levels).        pull = levelOn &lt;&lt; 2;        if (pull &gt; 48)    // Set an absolute limit on hand strength.          pull = 48;                  // Pull player donw!        thePlayer.vVel += pull;        theHand.dest.top = thePlayer.dest.top + 29;        theHand.dest.bottom = theHand.dest.top + 57;        if (thePlayer.facingRight)          theHand.dest.left = thePlayer.dest.left + 3;        else          theHand.dest.left = thePlayer.dest.left + 21;        theHand.dest.right = theHand.dest.left + 58;      }      else          // If player not in &quot;sweet spot&quot;, hand is seeking.      {        thePlayer.clutched = FALSE;        theHand.mode = kOutGrabeth;      }    }    else            // Player not even close to hand\xC9    {              // Hand sinks back down into lava.      theHand.dest.top++;      theHand.dest.bottom++;                  // When hand is off screen, hand resumes lurking.      if (theHand.dest.top &gt; 460)        theHand.mode = kLurking;      else        theHand.mode = kOutGrabeth;      thePlayer.clutched = FALSE;    }    break;  }}//--------------------------------------------------------------  InitEye// This initializes all the eye's variables.void InitEye (void){  SetRect(&amp;theEye.dest, 0, 0, 48, 31);  OffsetRect(&amp;theEye.dest, 296, 97);  theEye.mode = kWaiting;  theEye.frame = (numOwls + 2) * 720;  theEye.srcNum = 0;  theEye.opening = 1;  theEye.killed = FALSE;  theEye.entering = FALSE;}//--------------------------------------------------------------  KillOffEye// This function handles a &quot;slain&quot; eye!void KillOffEye (void){  if (theEye.mode == kStalking)  {    theEye.killed = TRUE;    theEye.opening = 1;    theEye.entering = FALSE;    if (theEye.srcNum == 0)      theEye.srcNum = 1;  }  else    InitEye();}//--------------------------------------------------------------  HandleEye// But of course, the eye has modes as well.  This function handles the eye\xC9// depending upon the mode it is in.void HandleEye (void){  short    diffH, diffV, speed;    if (theEye.mode == kStalking)    // Eye is alive!  {    speed = (levelOn &gt;&gt; 4) + 1;    // How fast it moves depends on level.    if (speed &gt; 3)      speed = 3;                    // When eye appears or dies, it is stationary.    if ((theEye.killed) || (theEye.entering))    {      speed = 0;    }    else if ((thePlayer.mode != kFlying) &amp;&amp; (thePlayer.mode != kWalking))    {      diffH = theEye.dest.left - 296;      diffV = theEye.dest.bottom - 128;    }    else    {      diffH = theEye.dest.left - thePlayer.dest.left;      diffV = theEye.dest.bottom - thePlayer.dest.bottom;    }                    // Find direction to player (no wrap-around for eye).    if (diffH &gt; 0)    {      if (diffH &lt; speed)        theEye.dest.left -= diffH;      else        theEye.dest.left -= speed;      theEye.dest.right = theEye.dest.left + 48;    }    else if (diffH &lt; 0)    {      if (-diffH &lt; speed)        theEye.dest.left -= diffH;      else        theEye.dest.left += speed;      theEye.dest.right = theEye.dest.left + 48;    }    if (diffV &gt; 0)    {      if (diffV &lt; speed)        theEye.dest.bottom -= diffV;      else        theEye.dest.bottom -= speed;      theEye.dest.top = theEye.dest.bottom - 31;    }    else if (diffV &lt; 0)    {      if (-diffV &lt; speed)        theEye.dest.bottom -= diffV;      else        theEye.dest.bottom += speed;      theEye.dest.top = theEye.dest.bottom - 31;    }        theEye.frame++;          // Increment eye frame (timer).                    // Determine correct graphic for eye.    if (theEye.srcNum != 0)    {      if (theEye.frame &gt; 3)    // &quot;Eye-closing frame&quot; holds for 3 frames.      {        theEye.frame = 0;        theEye.srcNum += theEye.opening;        if (theEye.srcNum &gt; 3)        {          theEye.srcNum = 3;          theEye.opening = -1;          if (theEye.killed)            InitEye();        }        else if (theEye.srcNum &lt;= 0)        {          theEye.srcNum = 0;          theEye.opening = 1;          theEye.frame = 0;          theEye.entering = FALSE;        }      }    }    else if (theEye.frame &gt; 256)    {      theEye.srcNum = 1;      theEye.opening = 1;      theEye.frame = 0;    }                    // Get absolute distance from eye to player.    diffH = theEye.dest.left - thePlayer.dest.left;    diffV = theEye.dest.bottom - thePlayer.dest.bottom;    if (diffH &lt; 0)      diffH = -diffH;    if (diffV &lt; 0)      diffV = -diffV;                    // See if player close enough to be killed!    if ((diffH &lt; 16) &amp;&amp; (diffV &lt; 16) &amp;&amp; (!theEye.entering) &amp;&amp;         (!theEye.killed))    // Close enough to call it a kill.    {      if (theEye.srcNum == 0)    // If eye was open, player is killed.      {              // Strike lightning (hit the player).              StartPixelShatterRect(&amp;thePlayer.dest, 0, 0, kShatterPlayerDeath);        thePlayer.electrical = 15;                            // Player is smokin' bones!        thePlayer.mode = kFalling;        if (thePlayer.facingRight)          thePlayer.srcNum = 8;        else          thePlayer.srcNum = 9;        thePlayer.dest.bottom = thePlayer.dest.top + 37;        PlayExternalSound(kBoom2Sound, kBoom2Priority);      }      else            // If the eye was &quot;blinking&quot;, IT was killed!      {              // Player killed the eye!        if (lightningCount == 0)        {            // Strike the eye with lightning!          lightH = theEye.dest.left + 24;          lightV = theEye.dest.top + 16;                    // Hit 'er with 15 bolts!          lightningCount = 15;        }        theScore += 2000L;    // A big 2000 points for killing the eye!        UpdateScoreNumbers();  // Refresh score display.        PlayExternalSound(kBonusSound, kBonusPriority);                KillOffEye();      // Slay eye!      }              // Hey, anyone remember that giant eye from\xC9    }                // Johnny Socko and his Flying Robot?  }                  // As a kid, I thought that was cool!  else if (theEye.frame &gt; 0)      // Eye has not yet appeared, but waits, lurking!  {    theEye.frame--;          // Decrement eye timer.    if (theEye.frame &lt;= 0)      // When timer hits zero, eye appears!    {      theEye.mode = kStalking;  // The eye is after the player!      if (lightningCount == 0)  // Strike lightning at eye!      {        lightH = theEye.dest.left + 24;        lightV = theEye.dest.top + 16;        lightningCount = 6;      }      theEye.srcNum = 3;      theEye.opening = 1;      theEye.entering = TRUE;    }  }  }//--------------------------------------------------------------  ResolveEnemyPlayerHit// Okay, a bounds test determined that the player and an enemy have collided.// This function looks at the two and determines who wins or if it's a draw.void ResolveEnemyPlayerHit (short i){  short    wasVel, diff, h, v;    if ((theEnemies[i].mode == kFalling) || (theEnemies[i].mode == kEggTimer))  {            // Okay, if the enemy is an egg\xC9    deadEnemies++;    // simple - the enemy dies.        theEnemies[i].mode = kDeadAndGone;    theScore += 500L;  // Add that to our score!    {      Point pt;      pt.h = theEnemies[i].dest.left;      pt.v = theEnemies[i].dest.top;      StartScoreFloater(500, pt);    }    UpdateScoreNumbers();    PlayExternalSound(kBonusSound, kBonusPriority);    InitEnemy(i, TRUE);  // Reset the enemy (I guess you could say they're reincarnated.  }  else          // Now, here's a real, live sphinx enemy.  {            // Get their difference in altitude.    diff = (theEnemies[i].dest.top + 25) - (thePlayer.dest.top + 19);        if (diff &lt; -2)    // Player is bested.  :(    {          // Strike player with lightning.      thePlayer.electrical = 15;      StartPixelShatterRect(&amp;thePlayer.dest, theEnemies[i].hVel, theEnemies[i].vVel, kShatterPlayerDeath);      // Player is bones.      thePlayer.mode = kFalling;      if (thePlayer.facingRight)        thePlayer.srcNum = 8;      else        thePlayer.srcNum = 9;      thePlayer.dest.bottom = thePlayer.dest.top + 37;      PlayExternalSound(kBoom2Sound, kBoom2Priority);    }    else if (diff &gt; 2)  // Yes!  Enemy is killed!    {          // Well ... we can't kill an enemy who is spawning.      if ((theEnemies[i].mode == kSpawning) &amp;&amp; (theEnemies[i].frame &lt; 16))        return;              // Resize enemy bounds (use an egg bounds).      h = (theEnemies[i].dest.left + theEnemies[i].dest.right) &gt;&gt; 1;      if (theEnemies[i].mode == kSpawning)        v = theEnemies[i].dest.bottom - 2;      else        v = (theEnemies[i].dest.top + theEnemies[i].dest.bottom) &gt;&gt; 1;      theEnemies[i].dest.left = h - 12;      theEnemies[i].dest.right = h + 12;      if (theEnemies[i].mode == kSpawning)        theEnemies[i].dest.top = v - 24;      else        theEnemies[i].dest.top = v - 12;      theEnemies[i].dest.bottom = theEnemies[i].dest.top + 24;      theEnemies[i].h = theEnemies[i].dest.left &lt;&lt; 4;      theEnemies[i].v = theEnemies[i].dest.top &lt;&lt; 4;            StartPixelShatterRect(&amp;theEnemies[i].dest, thePlayer.hVel, thePlayer.vVel, kShatterEnemyDeath);                    // Enemy is a falling egg!      theEnemies[i].mode = kFalling;      theEnemies[i].wasDest = theEnemies[i].dest;      theEnemies[i].wasH = theEnemies[i].h;      theEnemies[i].wasV = theEnemies[i].v;              // Give player points based on enemy kind.      {        unsigned long newScore;        Point pt;        switch (theEnemies[i].kind)        {          case kOwl:          newScore = 500L;          break;                    case kWolf:          newScore = 1000L;          break;                    case kJackal:          newScore = 1500L;          break;        }                theScore += newScore;                      pt.h = theEnemies[i].dest.left;        pt.v = theEnemies[i].dest.top;        StartScoreFloater(newScore, pt);      }      UpdateScoreNumbers();      PlayExternalSound(kBoom2Sound, kBoom2Priority);    }    else    // Rare case - neither the player nor the enemy get killed.    {      // They'll bounce off one another.      if (theEnemies[i].hVel &gt; 0)        theEnemies[i].facingRight = TRUE;      else        theEnemies[i].facingRight = FALSE;      PlayExternalSound(kScreechSound, kScreechPriority);            StartPixelShatter(  (theEnemies[i].dest.left + thePlayer.dest.right) / 2,                 (theEnemies[i].dest.top + thePlayer.dest.bottom) / 2, 0,0, kShatterPlayerEnemyScrape);    }        wasVel = thePlayer.hVel;    thePlayer.hVel = theEnemies[i].hVel;    theEnemies[i].hVel = wasVel;    wasVel = thePlayer.vVel;    thePlayer.vVel = theEnemies[i].vVel;    theEnemies[i].vVel = wasVel;  }}//--------------------------------------------------------------  CheckPlayerEnemyCollision// This is a simple &quot;bounds test&quot; for determining player/enemy collisions.void CheckPlayerEnemyCollision (void){  Rect    whoCares, playTest, wrapTest;  short    i;    playTest = thePlayer.dest;    // Make a copy of player's bounds.  InsetRect(&amp;playTest, 8, 8);    // Shrink it by 8 pixels all 'round.  if (thePlayer.wrapping)      // Need to test 2 players if &quot;wraparounding&quot;.    wrapTest = thePlayer.wrap;  InsetRect(&amp;wrapTest, 8, 8);                  // Test all enemies.  for (i = 0; i &lt; numEnemies; i++)  {                // Ignore non-existant enemies.    if ((theEnemies[i].mode != kIdle) &amp;&amp; (theEnemies[i].mode != kDeadAndGone))    {              // Simple bounds test.      if (SectRect(&amp;playTest, &amp;theEnemies[i].dest, &amp;whoCares))      {            // Call function to determine who wins (or tie).        ResolveEnemyPlayerHit(i);      }            // If &quot;wrap-arounding&quot;, test other rect.      else if (thePlayer.wrapping)      {        if (SectRect(&amp;wrapTest, &amp;theEnemies[i].dest, &amp;whoCares))          ResolveEnemyPlayerHit(i);      }    }  }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/GlyphaIVOld/listing1.html%3Fid%3DDTS10000053-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/GlyphaIVOld/listing1.html%3Fid%3DDTS10000053-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/GlyphaIVOld/listing1.html%3Fid%3DDTS10000053-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>