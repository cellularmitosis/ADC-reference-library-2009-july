<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Displaying Alert and Dialog Boxes(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING384></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-383.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-385.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-370.html"><B>Chapter 6 - Dialog Manager</B></A> / <A HREF="Toolbox-378.html"><B>Using the Dialog Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING384-0></A>
<H2><A NAME=MARKER-9-231></A>Displaying Alert and Dialog Boxes</H2>
 <A NAME=MARKER-2-232></A><A NAME=MARKER-2-233></A>You typically define alerts and dialog boxes in resources, as described in <A HREF=Toolbox-379.html#MARKER-9-89>"Creating Alert Sounds and Alert Boxes" beginning on page 6-18</A> and in <A HREF=Toolbox-380.html#MARKER-9-111>"Creating Dialog Boxes" beginning on page 6-23</A>. To create an alert or a dialog box, you use a Dialog Manager function--such as <CODE>Alert</CODE> or <CODE>GetNewDialog</CODE>--that incorporates information from your item list resource and from your alert resource or dialog resource into a data structure, called a dialog record, in memory. The Dialog Manager creates a dialog record, which is a data structure of type <CODE>DialogRecord<DFN>, </DFN></CODE>whenever your application creates an alert or a dialog box. <P>
 The Dialog Manager automatically displays alert boxes at the appropriate alert stages; it also automatically displays those dialog boxes that you specify as visible in their dialog resources. But you must use a Window Manager routine such as <CODE>ShowWindow<DFN> </DFN></CODE>to display dialog boxes that you specify as invisible in their dialog resources.<P>
 When you use a function that creates an alert (namely, <CODE>Alert</CODE>, <CODE>StopAlert</CODE>, <CODE>NoteAlert</CODE>, or <CODE>CautionAlert</CODE>), the Dialog Manager automatically displays the alert box at the alert stages that you specify with the <CODE>visible</CODE> constant in your alert resource. You do not use any routines other than the <CODE>Alert</CODE>, <CODE>StopAlert</CODE>, <CODE>NoteAlert</CODE>, and <CODE>CautionAlert</CODE> functions to display an alert box.<P>
 When you specify the <CODE>visible</CODE> constant in a dialog resource, the Dialog Manager immediately displays the dialog box when you use the <CODE>GetNewDialog</CODE> function. If <BR>you instead specify the <CODE>invisible</CODE> constant so that the dialog box is initially invisible when you call <CODE>GetNewDialog</CODE>, use the Window Manager procedure <CODE>ShowWindow</CODE> <BR>to display it. This is useful if you need to manipulate a dialog item dynamically using <CODE>GetDialogItem</CODE> and <CODE>SetDialogItem</CODE> before you display the dialog box. For example, if you want to install an application-defined draw procedure for a dialog box, you specify the <CODE>invisible</CODE> constant in a dialog resource, pass the resource ID of that dialog resource in a parameter to <CODE>GetNewDialog</CODE>, use <CODE>GetDialogItem</CODE> and <CODE>SetDialogItem</CODE> to install the application-defined draw procedure, then call <CODE>ShowWindow</CODE> to display the dialog box, as previously shown in <A HREF=Toolbox-383.html#MARKER-9-227>Listing 6-16 on page 6-58</A>.<A NAME=MARKER-2-234></A><P>
 You should always specify <CODE>Pointer(-1)</CODE> as a parameter to <CODE>GetNewDialog</CODE> to display a dialog box as the active (that is, frontmost) window.<A NAME=MARKER-2-235></A><P>
 You should perform the following tasks in conjunction with displaying an alert box or a dialog box:<P>
<UL>
<LI>Specify an appropriate screen position at which to display the alert box or dialog box.
<LI>Deactivate the frontmost window (if one exists) before displaying an alert box or a modal dialog box.
<LI>Determine whether you've already created a modeless dialog box and, if so, select it instead of creating a new instance of it.
<LI>Adjust your menus appropriately for a modal dialog box with editable text items and for any movable modal and modeless dialog box you wish to display.<P>
</UL>
 <CODE><A NAME=MARKER-2-236></A></CODE>The <CODE>DialogSelect</CODE> function uses the QuickDraw procedure <CODE>SetPort</CODE> to make the alert or dialog box the current graphics port. The <CODE>ModalDialog</CODE> procedure and the functions that create alert boxes use <CODE>DialogSelect</CODE> to respond to update and activate events. You can also use <CODE>DialogSelect</CODE> to respond to update and activate events in your modeless and movable modal dialog boxes. In response to update events, you can instead use the <CODE>UpdateDialog</CODE> function, which also makes the dialog box the current graphics port. <BR>In these cases, it's generally not necessary for your application to call <CODE>SetPort</CODE> when displaying, updating, or activating alert boxes and dialog boxes. See <I>Inside Macintosh: Imaging</I> for more information about <CODE>SetPort</CODE>.<A NAME=MARKER-2-237></A><A NAME=MARKER-2-238></A><P>
 These and other related issues are explained in detail in the next several sections of <BR>this chapter.<P>
<A NAME=HEADING384-13></A>
<H3><A NAME=MARKER-9-239></A>Positioning Alert and Dialog Boxes</H3>
 As previously described in <A HREF=Toolbox-379.html#MARKER-9-89>"Creating Alert Sounds and Alert Boxes" beginning on page 6-18</A> and <A HREF=Toolbox-380.html#MARKER-9-111>"Creating Dialog Boxes" beginning on page 6-23</A>, you specify a rectangle in every alert resource and dialog resource. The dimensions of this rectangle determine the dimensions of the alert box or dialog box. You can also let the rectangle coordinates serve as the global coordinates that determine the position of the alert box or dialog box, or you can let the Dialog Manager automatically locate it for you according to three standard positions. To specify these standard positions in System 7, your application can use the following constants in the Rez input files for alert resources and dialog resources:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Constant<TH>Description<TR>
<TD>alertPositionParentWindow<TD>Position the alert or dialog box over the frontmost window<TR>
<TD>alertPositionMainScreen<TD>Position the alert or dialog box on <BR>the main screen<TR>
<TD>alertPositionParentWindowScreen<TD>Position the alert or dialog box on <BR>the screen containing the frontmost window</TABLE>
<P>
 If your application positions alert or dialog boxes on its own, don't use these <BR>constants, because your code may conflict with the Dialog Manager. If you do use <BR>these constants, use them to specify the positions of both alert boxes and dialog boxes.<P>
 The next three figures illustrate various alert boxes that might appear when the user is working on two monitors: a 12-inch monitor (the main screen) that displays the menu bar and a full-page monitor that displays a document window. These figures show where the Dialog Manager places an alert box according to the position specified in <BR>the alert resource.<P>
 <A NAME=MARKER-2-240></A><A HREF=#MARKER-9-242>Figure 6-33</A> shows an alert box displayed in response to an error made by the <BR>user while working on a document; the alert resource specifies the <CODE>alertPositionParentWindow</CODE> constant, which tells the Dialog Manager to <BR>position the alert box over the frontmost window so that the window's title bar <BR>appears. This position is appropriate for an alert box or a dialog box that relates <BR>directly to the frontmost window. You should always try to position alert boxes <BR>and dialog boxes where the user is working.<A NAME=MARKER-2-241></A><P>
<B>Figure 6-33  <A NAME=MARKER-9-242></A>An alert box in front of a document window</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DM-L-13.jpg"><P>
 Not all alert boxes or dialog boxes relate to the frontmost window. Some may relate <BR>only to actions the user performs on the main screen. For example, <A HREF=#MARKER-9-244>Figure 6-34</A> <BR>illustrates an alert box displayed when the user chooses the About command from <BR>the Apple menu. For an alert box or dialog box such as this, you should specify the <CODE>alertPositionMainScreen</CODE> constant in the alert or dialog resource. <A HREF=#MARKER-9-244>Figure 6-34</A> shows how the Dialog Manager centers such an alert box near the top of the main screen.<A NAME=MARKER-2-243></A><P>
<B>Figure 6-34  <A NAME=MARKER-9-244></A>An alert box on the main screen</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DM-L-14.jpg"><P>
 Sometimes you may need to display an alert box or a dialog box that applies neither to the frontmost window nor to an action performed on the main screen. To catch the user's attention, you should position such an alert or dialog box on the screen where the user is working. For example, if you need to alert the user that available disk space is low, you should specify the <CODE>alertPositionParentWindowScreen</CODE> constant. <A HREF=#MARKER-9-246>Figure 6-35</A> shows how the Dialog Manager displays such an alert box or dialog box when a document window appears on a screen other than the main screen.<A NAME=MARKER-2-245></A><P>
<B>Figure 6-35  <A NAME=MARKER-9-246></A>An alert box in the alert position of the document window screen</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DM-L-15.jpg"><P>
 If you don't specify a positioning constant, the Dialog Manager uses the rectangle coordinates in your alert resource or dialog resource as global coordinates specifying where to position your alert or dialog box. If you wish to specify the position yourself in this manner, you should generally try to center alert and dialog boxes between the left and right margins of the screen or the window where the user is working, whichever is most appropriate. If you don't use the positioning constants, you should also place the tops of alert and dialog boxes (including the title bars of modeless and movable modal dialog boxes) below the menu bar. You can use the <CODE>GetMBarHeight</CODE> function, described in the chapter "Menu Manager" in this book, to determine the height of the menu bar.<A NAME=MARKER-2-247></A><P>
<A NAME=HEADING384-27></A>
<H3>Deactivating Windows Behind Alert and Modal Dialog Boxes</H3>
 <A NAME=MARKER-2-248></A><A NAME=MARKER-2-249></A>For alert and modal dialog boxes, the <CODE>ModalDialog</CODE> procedure traps all events before they are passed to your event loop, which normally handles activate events for your windows. Thus, if a window is active, you must explicitly deactivate it before displaying an alert box or a modal dialog box.<P>
 Your modeless dialog boxes and movable modal dialog boxes never use the <CODE>ModalDialog</CODE> procedure. Therefore, you do not have to deactivate the frontmost window explicitly before displaying a modeless or a movable modal dialog box. <BR>Instead, the Event Manager continues sending your application activate events for <BR>your windows as needed, which you typically handle in your normal event loop. (The chapters "Event Manager" and "Window Manager" in this book explain how to <BR>activate and deactivate windows.)<P>
 Plate 2 at the front of this book shows an alert box that an application displays when the user chooses the About command in the Apple menu. <A HREF=#MARKER-9-250>Listing 6-18</A> shows an application- defined routine, <CODE>ShowMyAboutBox</CODE>, that displays this alert box.<P>
<B>Listing 6-18  <A NAME=MARKER-9-250></A>Deactivating the front window before displaying an alert box</B><P>
<PRE>
PROCEDURE ShowMyAboutBox;
VAR
   itemHit:    Integer;
   docWindow:  WindowPtr;
   event:      EventRecord;
BEGIN
   docWindow := FrontWindow;     {get the front window}
   {if there's a front window, deactivate it}
   IF docWindow &lt;&gt; NIL THEN 
      DoActivate(docWindow, FALSE, event);
   {then show the alert box}
   itemHit := Alert(kAboutBoxID, @MyEventFilter);
END;
</PRE>
 The <CODE>ShowMyAboutBox</CODE> routine uses the Window Manager function <CODE>FrontWindow</CODE>. If <CODE>FrontWindow</CODE> returns a valid pointer, <CODE>ShowMyAboutBox</CODE> calls its <CODE>DoActivate</CODE> procedure to deactivate that window before calling the <CODE>Alert</CODE> function to display the alert box. When the user clicks the OK button, the alert box is dismissed. The Event Manager then sends the application update events so that it can update the contents of any windows as appropriate, and the Event Manager sends the application an activate event so that it can activate the previously frontmost window again. The application handles these events in its normal event loop.<P>
 If your application does not display an alert box during certain alert stages, use the <CODE>GetAlertStage</CODE> function to test for those stages before deactivating the active window. The <CODE>GetAlertStage</CODE> function returns the last occurrence of an alert as a number from <BR>0 to 3. <A HREF=#MARKER-9-251>Figure 6-36</A> shows an alert box that appears only after the user repeats an error three consecutive times.<P>
<B>Figure 6-36  <A NAME=MARKER-9-251></A>An alert box displayed only after the third alert stage</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DM-S-12.jpg"><P>
 <A HREF=#MARKER-9-253>Listing 6-19</A> shows how you might use <CODE>GetAlertStage</CODE> to determine if such an alert needs to be displayed before deactivating the document window.<A NAME=MARKER-2-252></A><P>
<B>Listing 6-19  <A NAME=MARKER-9-253></A>Using <CODE>GetAlertStage</CODE> to determine when to deactivate the front window</B><P>
<PRE>
PROCEDURE MyAlert;
VAR
   itemHit:       Integer;
   alertStage:    Integer;
   docWindow:     WindowPtr;
   event:         EventRecord;
BEGIN
   docWindow := FrontWindow;
   alertStage := GetAlertStage;
   IF (alertStage &gt;= 2) AND (docWindow &lt;&gt; NIL) THEN    {at 3rd alert stage, }
      DoActivate(docWindow, FALSE, event);      { deactivate front window &amp; }
   itemHit := StopAlert(kStopAlertID, @MyEventFilter);   { display alert box}
END;
</PRE>
<A NAME=HEADING384-40></A>
<H3>Displaying Modeless Dialog Boxes</H3>
 For a modeless dialog box, check to make sure it isn't already open before you create and display it. For example, the modeless dialog box shown in <A HREF=#MARKER-9-254>Figure 6-37</A> should appear when the user chooses the Global Changes command. After invoking this command, the user may select another window, thereby deactivating the modeless dialog box.<P>
<B>Figure 6-37  <A NAME=MARKER-9-254></A>A modeless dialog box for changing text in a document</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DM-S-36.jpg"><P>
 So as not to create multiple versions of this dialog box whenever the user chooses the Global Changes command, the application-defined routine <CODE>DoGlobalChangesDialog</CODE>, shown in <A HREF=#MARKER-9-255>Listing 6-20</A>, checks whether the dialog box already exists.<P>
<B>Listing 6-20  <A NAME=MARKER-9-255></A>Ensuring that the modeless dialog box isn't already open before creating it</B><P>
<PRE>
FUNCTION DoGlobalChangesDialog: OSErr;
BEGIN
   DoGlobalChangesDialog := kSuccess;  {assume success}
   IF gChangeDialogPtr = NIL THEN      {it doesn't exist, so create it}
   BEGIN
      gChangeDialogPtr := GetNewDialog(kGlobalChangesDlog, NIL, Pointer(-1));
      IF gChangeDialogPtr = NIL THEN   {handle failure}
      BEGIN
         DoGlobalChangesDialog := kFailed;
         EXIT(DoShowModelessFindDialogBox);
      END;
      {set window refCon to store value that identifies the dbox}
      SetWRefCon(gChangeDialogPtr, LongInt(kGlobalChangesDlog));
   END
   ELSE        {it does exist, so display and select it}
   BEGIN
      ShowWindow(gChangeDialogPtr); {it's hidden; so show it}
      SelectWindow(gChangeDialogPtr);{bring it to the front}
   END;
   MyAdjustMenus;                {adjust the menus}
END;
</PRE>
 In this example, a pointer to the modeless dialog box is stored in a global variable. If <BR>the global variable does not contain a pointer, <CODE>DoGlobalChangesDialog</CODE> uses <CODE>GetNewDialog</CODE> to create and draw the dialog box. Later, if the user decides to close the modeless dialog box, the application merely hides it so that when the user needs it again, <CODE>DoGlobalChangesDialog</CODE> can display the dialog box in the same location and with the same text selected as when the user last used it. Hiding this dialog box is illustrated later in <A HREF=Toolbox-385.html#MARKER-9-367>Listing 6-30 on page 6-87</A>.<P>
 If the dialog box has already been created, <CODE>DoGlobalChangesDialog</CODE> uses the Window Manager procedures <CODE>ShowWindow</CODE> to make the dialog box visible and <CODE>SelectWindow</CODE> to make it active.<P>
 Finally, <CODE>DoGlobalChangesDialog</CODE> uses the application-defined routine <CODE>MyAdjustMenus</CODE> to adjust the menus as appropriate for the modeless dialog box.<A NAME=MARKER-2-256></A><P>
 <A HREF=Toolbox-385.html#MARKER-9-378>Listing 6-34 on page 6-91</A> illustrates an application-defined routine,<CODE> DoActivateGlobalChangesDialog</CODE>, that handles activate events for this <BR>modeless dialog box. The <CODE>DoActivateGlobalChangesDialog</CODE> routine in <BR>turn uses <CODE>DialogSelect</CODE>, which sets the graphics port to the modeless dialog <BR>box whenever the user makes it active.<P>
<A NAME=HEADING384-51></A>
<H3><A NAME=MARKER-9-257></A>Adjusting Menus for Modal Dialog Boxes</H3>
 <A NAME=MARKER-2-258></A>The Dialog Manager and the Menu Manager interact to provide various degrees of access to the menus in your menu bar. For alert boxes and modal dialog boxes without editable text items, you can simply allow system software to provide the appropriate access to your menu bar.<A NAME=MARKER-2-259></A> <A NAME=MARKER-2-260></A><A NAME=MARKER-2-261></A><A NAME=MARKER-2-262></A><A NAME=MARKER-2-263></A><A NAME=MARKER-2-264></A><A NAME=MARKER-2-265></A><P>
 When your application displays either an alert box or a modal dialog box (that is, a window of type <CODE>dBoxProc</CODE>), these actions occur:<P>
<OL>
<LI>System software disables all menu items in the Help menu, except the Show Balloons (or Hide Balloons) command, which system software enables.
<LI>System software disables all menu items in the Application menu.
<LI>If the Keyboard menu appears in the menu bar, system software enables that menu but disables the About Keyboards command.<A NAME=MARKER-2-266></A><P>
</OL>
 When your application displays an alert box or calls the <CODE>ModalDialog</CODE> procedure <BR>for a modal dialog box (described in <A HREF=Toolbox-385.html#MARKER-9-332>"Responding to Events in Modal Dialog Boxes" beginning on page 6-75</A>), the Dialog Manager determines whether any of the following cases is true:<P>
<UL>
<LI>Your application does not have an Apple menu.
<LI>Your application has an Apple menu, but the menu is disabled when the dialog box <BR>is displayed.
<LI>Your application has an Apple menu, but the first item in that menu is disabled when the dialog box is displayed.<P>
</UL>
 If none of these cases is true, system software behaves as follows:<P>
<OL>
<LI>The Menu Manager disables all of your application's menus.
<LI>If the modal dialog box contains a visible and active editable text field--and if the menu bar contains a menu having commands with the standard keyboard equivalents Command-X, Command-C, and Command-V--then the Menu Manager enables <BR>those three commands and the menu that contains them. The user can then use either the menu commands or their keyboard equivalents to cut, copy, and paste text. <BR>(The menu item having keyboard equivalent Command-X must be one of the first <BR>five menu items.)<P>
</OL>
 When your application displays alert boxes and modal dialog boxes with no editable text items, it can safely allow system software to handle menu bar access as described in steps 1 and 2.<P>
 However, because system software cannot handle the Undo or Clear command (or any other context-appropriate command) for you, your application should handle its own menu bar access for modal dialog boxes with editable text items by performing the following tasks:<P>
<UL>
<LI>disable the Apple menu or the first item in the Apple menu (typically, your application's About command) in order to take control of its menu bar access <BR>when displaying a modal dialog box<A NAME=MARKER-2-267></A>
<LI>disable all of its menus except the Edit menu, as well as any inappropriate commands in the Edit menu
<LI>use the Dialog Manager procedures <CODE>DialogCut</CODE>, <CODE>DialogCopy</CODE>, <CODE>DialogPaste</CODE>, <BR>and <CODE>DialogDelete</CODE> to support the Cut, Copy, Paste, and Clear commands in editable text items<A NAME=MARKER-2-268></A><A NAME=MARKER-2-269></A> <A NAME=MARKER-2-270></A>
<LI>provide your own code for supporting the Undo command
<LI>enable your application's items in the Help menu as appropriate (system software disables all items except the Hide Balloons/Show Balloons command)<P>
</UL>
 You don't need to do anything else for the system-handled menus--namely, Application, Keyboard, and Help. System software handles these menus for you automatically.<P>
 The <CODE>DialogCut</CODE>, <CODE>DialogCopy</CODE>, <CODE>DialogPaste</CODE>, and <CODE>DialogDelete</CODE> procedures are described beginning on <A HREF=Toolbox-421.html#MARKER-9-532>page 6-132</A>. Your application can test whether a dialog box is the front window when handling mouse-down events in the Edit menu and then call these routines as appropriate.<A NAME=MARKER-2-271></A><A NAME=MARKER-2-272></A><A NAME=MARKER-2-273></A><A NAME=MARKER-2-274></A><A NAME=MARKER-2-275></A><P>
 <A HREF=#MARKER-9-276>Figure 6-38</A> illustrates how an application disables all of its own menus except its Edit menu when displaying a modal dialog box containing editable text items. Access to the Edit menu benefits the user who instead of typing prefers copying from and pasting into editable text items.<P>
<B>Figure 6-38  <A NAME=MARKER-9-276></A>Menu access when displaying a modal dialog box</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DM-S-46.jpg"><P>
 <A HREF=#MARKER-9-277>Listing 6-21</A> on the next page shows an application-defined routine, <CODE>MyAdjustMenus</CODE>, that the SurfWriter application calls to adjust its menus after it displays a window or dialog box, but before it calls <CODE>ModalDialog</CODE> to handle events in a modal dialog box. When <CODE>MyAdjustMenus</CODE> determines that the frontmost window is a modal dialog box containing an editable text item, it calls another application-defined routine, <CODE>MyAdjustMenusForDialogs</CODE>, which adjusts the menus appropriately. <A HREF=#MARKER-9-278>Listing 6-22</A> on the next page shows the <CODE>MyAdjustMenusForDialogs</CODE> routine.<P>
<B>Listing 6-21  <A NAME=MARKER-9-277></A>Adjusting menus for various windows</B><P>
<PRE>
PROCEDURE MyAdjustMenus;
VAR
   window:     WindowPtr;
   windowType: Integer;
   menu:       MenuHandle;
BEGIN
   window := FrontWindow;
   windowType := MyGetWindowType(window);
   CASE windowType OF 
   kMyDocWindow:   {document window is in front}
      MyAdjustMenusForDocWindows;
   kMyDialogWindow:  {a dialog box is in front}
      MyAdjustMenusForDialogs; 
   kDAWindow:  {adjust menus accordingly for a DA window}
      MyAdjustMenusForDA; 
   kNil: {there isn't a front window}
      MyAdjustMenusNoWindows;
   END; {of CASE}
   DrawMenuBar;   {redraw menu bar}
END;
</PRE>
 The <CODE>MyAdjustMenusForDialogs</CODE> routine in <A HREF=#MARKER-9-278>Listing 6-22</A> first determines what type of dialog box is in front: modal, movable modal, or modeless. For modal dialog boxes, <CODE>MyAdjustMenusForDialogs</CODE> disables the Apple menu so that the application can take control of its menus away from the Dialog Manager. The <CODE>MyAdjustMenusForDialogs</CODE> routine then uses the Menu Manager routines <CODE>GetMenuHandle</CODE> and <CODE>DisableItem</CODE> to disable all other application menus except the Edit menu. (To provide help balloons that explain why these menus are unavailable to the user, <CODE>MyAdjustMenusForDialogs</CODE> uses the Help Manager procedure <CODE>HMSetMenuResID</CODE> to reassign help resources to these menus; see the chapter "Help Manager" in Inside Macintosh: More Macintosh Toolbox for more information.)<P>
<B>Listing 6-22  <A NAME=MARKER-9-278></A>Disabling menus for a modal dialog box with editable text items</B><P>
<PRE>
PROCEDURE MyAdjustMenusForDialogs;
   VAR
      window:     WindowPtr;
      windowType: Integer;
      myErr:      OSErr;
      menu:       MenuHandle;
BEGIN
   window := FrontWindow;
   windowType := MyGetWindowType(window);
   CASE windowType OF
      kMyModalDialogs:
      BEGIN
         menu := GetMenuHandle(mApple);   {get handle to Apple menu}
         IF menu = NIL THEN
            EXIT(MyAdjustMenusForDialogs);
         DisableItem(menu, 0);   {disable Apple menu to get control of menus}
         myErr := HMSetMenuResID(mFile, kFileHelpID); {set up help balloons}
         menu := GetMenuHandle(mFile);       {get handle to File menu}
         IF menu = NIL THEN
            EXIT(MyAdjustMenusForDialogs);
         DisableItem(menu, 0);      {disable File menu}
         myErr := HMSetMenuResID(mFile, kFileHelpID); {set up help balloons}
         IF myErr &lt;&gt; NoErr THEN
            EXIT(MyAdjustMenusForDialogs);
         menu := GetMenuHandle(mTools);   {get handle to Tools menu}
         IF menu = NIL THEN
            EXIT(MyAdjustMenusForDialogs);
         DisableItem(menu, 0);         {disable Tools menu}
         myErr := HMSetMenuResID(mTools, kToolsHelpID);  {help balloons}
         IF myErr &lt;&gt; NoErr THEN
            EXIT(MyAdjustMenusForDialogs);
         MyAdjustEditMenuForModalDialogs;
      END;        {of kMyModalDialogs CASE} 
      kMyGlobalChangesModelessDialog: 
         ;  {adjust menus here as needed}
      kMyMovableModalDialog: 
         ;  {adjust menus here as follows: }
            { disable all menus except Apple, then }
            { call MyAdjustEditMenuForModalDialogs for editable text items}
   END; {of CASE}
END;
</PRE>
 To adjust the items in the Edit menu, MyAdjustMenusForDialogs calls another application-defined routine, <CODE>MyAdjustEditMenuForModalDialogs</CODE>, which is <BR>shown in <A HREF=#MARKER-9-279>Listing 6-23</A> on the next page. The <CODE>MyAdjustEditMenuForModalDialogs</CODE> routine uses application-defined code to implement the Undo command; uses the <BR>Menu Manager procedure <CODE>EnableItem</CODE> to enable the Cut, Copy, Paste, and Clear commands when appropriate; and disables the commands that support Edition <BR>Manager capabilities. Remember that your application should use the Dialog Manager procedures <CODE>DialogCut</CODE>, <CODE>DialogCopy</CODE>, <CODE>DialogPaste</CODE>, and <CODE>DialogDelete</CODE> to support the Cut, Copy, Paste, and Clear commands in editable text items.<P>
<B>Listing 6-23  <A NAME=MARKER-9-279></A>Adjusting the Edit menu for a modal dialog box</B><P>
<PRE>
PROCEDURE MyAdjustEditMenuForModalDialogs;
VAR
   window:           WindowPtr;
   menu:             MenuHandle;
   selection, undo:  Boolean;
   offset:           LongInt;
   undoText:         Str255;
BEGIN
   window := FrontWindow;
   menu := GetMenuHandle(mEdit); {get a handle to the Edit menu}
   IF menu = NIL THEN            {add your own error handling}
      EXIT (MyAdjustEditMenuForModalDialogs);
   undo := MyIsLastActionUndoable(undoText);
   IF undo THEN   {if action can be undone}
   BEGIN
      EnableItem(menu, iUndo);
      SetMenuItemText(menu, iUndo, undoText);
   END
   ELSE           {if action can't be undone}
   BEGIN
      SetMenuItemText(menu, iUndo, gCantUndo);
      DisableItem(menu, iUndo);
   END;
   selection := MySelection(window);
   IF selection THEN
   BEGIN    {enable editing items if there's a selection}
      EnableItem(menu, iCut); 
      EnableItem(menu, iCopy);
   END
   ELSE
   BEGIN    {disable editing items if there isn't a selection}
      DisableItem(menu, iCut); 
      DisableItem(menu, iCopy);
   END;
   IF MyGetScrap(NIL, 'TEXT', offset) &gt; 0 THEN
      EnableItem(menu, iPaste) {enable if something to paste}
   ELSE
      DisableItem(menu, iPaste);{disable if nothing to paste}
   DisableItem(menu, iSelectAll);
   DisableItem(menu, iCreatePublisher);
   DisableItem(menu, iSubscribeTo);
   DisableItem(menu, iPubSubOptions);
   END;
END;
</PRE>
 See the chapter "Menu Manager" in this book for more information on menus and the menu bar.<P>
 When the user dismisses the alert box or modal dialog box, the Menu Manager restores all menus to their state prior to the appearance of the alert or modal dialog box--unless your application handles its own menu bar access, in which case you must restore the menus to their previous states. You can use a routine similar to <CODE>MyAdjustMenus</CODE>, shown in <A HREF=#MARKER-9-277>Listing 6-21 on page 6-63</A>, to adjust the menus appropriately according to the type of window that becomes the frontmost window.<P>
<A NAME=HEADING384-87></A>
<H3><A NAME=MARKER-9-280></A>Adjusting Menus for Movable Modal and Modeless Dialog Boxes</H3>
 Although it always leaves the Help, Keyboard, and Application menus and their commands enabled, system software does nothing else to manage the menu bar when you display movable modal and modeless dialog boxes. Instead, your application should allow or deny access to the rest of your menus as appropriate to the context. For example, if your application displays a modeless dialog box for a search-and-replace command, you should allow access to the Edit menu to assist the user with the editable text items, and you should allow use of the File menu so that the user can open another file to be searched. However, you should disable other menus if their commands cannot be used inside the active modeless dialog box.<P>
 When creating a modeless dialog box, your application should perform the following tasks:<P>
<UL>
<LI>disable only those menus whose commands are invalid in the current context
<LI>if the modeless dialog box includes editable text items, use the Dialog Manager procedures <CODE>DialogCut</CODE>, <CODE>DialogCopy</CODE>, <CODE>DialogPaste</CODE>, and <CODE>DialogDelete</CODE> to support the Cut, Copy, Paste, and Clear commands in editable text items<P>
</UL>
 When your application creates a movable modal dialog box, it should perform the following tasks:<P>
<UL>
<LI><A NAME=MARKER-2-281></A>leave the Apple menu enabled so that the user can open other applications with it
<LI>if your movable modal dialog box contains editable text items, leave the Edit menu enabled but use the Dialog Manager procedures <CODE>DialogCut</CODE>, <CODE>DialogCopy</CODE>, <CODE>DialogPaste</CODE>, and <CODE>DialogDelete</CODE> to support the Cut, Copy, Paste, and <BR>Clear commands
<LI>disable all of your other menus<P>
</UL>
 <A HREF=#MARKER-9-277>Listing 6-21 on page 6-63</A> shows an application-defined routine, <CODE>MyAdjustMenus</CODE>, that SurfWriter uses to adjust its menus after it displays a window or dialog box. You can use a similar routine to adjust your menus as appropriate given the nature of the active window, movable modal dialog box, or modeless dialog box.<A NAME=MARKER-2-282></A><A NAME=MARKER-2-283></A><A NAME=MARKER-2-284></A><A NAME=MARKER-2-285></A><A NAME=MARKER-2-286></A><P>
<A NAME=HEADING384-97></A>
<H3>Displaying Multiple Alert and Dialog Boxes</H3>
 You should generally present the user with only one modal dialog box or alert box at a time. Sometimes, you may need to present a modal dialog box and an alert box on the screen at one time. For example, when the user saves a file with the same name as another file, the Standard File Package displays an alert box on top of the standard file dialog box. The alert box asks the user whether to replace the existing file.<P>
 Avoid closing a modal dialog box and immediately displaying another modal dialog <BR>box or an alert box in response to a user action. This situation creates a "tunneling modal dialog box" effect that might confuse the user. Missing the content of the previous <BR>modal dialog box and unable to return to it, the user has difficulty predicting what will happen next.<P>
  However, the user should never see more than one modal dialog and one alert box on the screen simultaneously. You can present multiple simultaneous modeless dialog boxes, just as you can present multiple document windows.<P>
 When you remove an alert box or a modal dialog box that overlies the default button <BR>of a previous alert box, the Dialog Manager doesn't redraw that button's bold outline. Therefore, you should not use an alert box if you need to display another overlapping alert box or dialog box. Instead, you should create a modal dialog box, and you must provide it with an application-defined item that draws the bold outline around the default button. The <CODE>ModalDialog</CODE> procedure then causes the item to be redrawn after an update event.<P>
 In System 7, the Window Manager automatically dims the window frame of a dialog box when you deactivate it to display an alert box, another modal dialog box, or a window. When you deactivate a dialog box, you should use the Control Manager procedure <CODE>HiliteControl</CODE> to make the controls of a dialog box inactive. You should also draw the outline of the default button of a deactivated dialog box in gray instead of black. <A HREF=Toolbox-383.html#MARKER-9-227>Listing 6-16 on page 6-58</A> shows an application-defined procedure that draws a gray outline when the default button is inactive; <A HREF=Toolbox-385.html#MARKER-9-378>Listing 6-34 on page 6-91</A> shows how to use <CODE>HiliteControl</CODE> to make buttons inactive and active in response to activate events for a dialog box.<A NAME=MARKER-2-287></A><P>
<A NAME=HEADING384-103></A>
<H3>Displaying Alert and Dialog Boxes From the Background</H3>
 If you ever need to display an alert box or a modal dialog box while your application is running in the background or is otherwise invisible to the user, you should use the Notification Manager to post a notification to the user. For example, if your application performs lengthy background tasks such as printing many documents or transferring large amounts of data to other computers, you might wish to inform the user that the operation is completed. In these cases, you should post a notification request to notify the user when the operation is completed. Then the Notification Manager automatically displays an alert box containing whatever message you specify; you do not need to use the Dialog Manager to create the alert box yourself.<P>
 Note that the Notification Manager provides a one-way communications path from your application to the user. There is no provision for carrying information back from the user to your application while it is in the background (although it is possible for your application to determine if the notification was received). If you need to solicit information from the user, use the Notification Manager to ask the user to bring your application to the foreground. The user can then respond to your alert box or modal dialog box. See the chapter "Notification Manager" in Inside Macintosh: Processes for information about the Notification Manager<A NAME=MARKER-2-288></A>.<A NAME=MARKER-2-289></A><P>
<A NAME=HEADING384-106></A>
<H3><A NAME=MARKER-9-290></A>Including Color in Your Alert and Dialog Boxes</H3>
 On color monitors, the Dialog Manager automatically adds color to your alert and dialog boxes so that they match the colors of the windows, alert boxes, and dialog boxes used by system software. These colors provide aesthetic consistency across all monitors, from black-and-white displays to 8-bit color displays. On a color monitor, for example, the racing stripes in the title bar of a modeless dialog box are gray, the close box and window frame are in color, and the buttons and text are black.<P>
 When you create alert and dialog resources, your application's alert and dialog boxes use the system's default colors. With the following exceptions, creating alert and dialog resources is typically all you need to do to provide color for your alert and dialog boxes:<P>
<UL>
<LI>When you need to include a color version of an icon in an alert box or a dialog box, you must create a resource of type <CODE>'cicn'</CODE> with the same resource ID as the black-and-white <CODE>'ICON'</CODE> resource specified in the item list resource. Plate 2 at the front of this book shows an alert box that includes a color icon.
<LI>If you use <CODE>GetNewDialog</CODE> or <CODE>NewDialog</CODE> to create a dialog box and you need to produce a blended gray color for outlining the inactive (that is, dimmed) default button, you must create a <B>dialog color table </B>(<CODE>'dctb'</CODE>) <B>resource</B> with the same resource ID as the dialog resource.<P>
</UL>
 <A HREF=Toolbox-383.html#MARKER-9-223>"Using an Application-Defined Item to Draw the Bold Outline for a Default Button" beginning on page 6-56</A> explains how to create a draw routine that outlines the default button of a dialog box. If you deactivate a dialog box, you should dim its buttons and use gray to draw the outline for the default button. Because <CODE>GetNewDialog</CODE> and <CODE>NewDialog</CODE> supply black-and-white graphics ports for dialog boxes, you can create a dialog color table resource for the dialog box to force the Dialog Manager to supply a color graphics port. Then you can use a blended gray color for the outline for the default button. (<CODE>NewColorDialog</CODE> supplies a color graphics port.)<P>
 Even when you create a dialog color table resource for drawing a gray outline, you should not change the system's default colors. <A HREF=#MARKER-9-293>Listing 6-24</A> shows a dialog color table resource that leaves the default colors intact but forces the Dialog Manager to supply a color graphics port.<A NAME=MARKER-2-292></A><P>
<B>Listing 6-24  <A NAME=MARKER-9-293></A>Rez input for a dialog color table resource using the system's default colors</B><P>
<PRE>
data 'dctb' (kGlobalChangesDialog, purgeable) {
   $&quot;0000 0000 0000 FFFF&quot;  /*use default colors*/
};
</PRE>
 By using the system's default colors, you ensure that your application's interface is consistent with that of the Finder and other applications. However, if you feel absolutely compelled to break from this consistency, the Dialog Manager offers you the ability to specify colors other than the default colors. Be aware, however, that nonstandard colors in your alert and dialog boxes may initially confuse your users.<P>
 Also be aware that despite any changes you make, users can alter the colors of alert and dialog boxes anyway by changing the settings in the Color control panel. <P>
 Your application can specify its own colors in an <B>alert color table </B>(<CODE>'actb'</CODE>) <B>resource</B> with the same resource ID as the alert resource or in a dialog color table (<CODE>'dctb'</CODE>) resource with the same resource ID as the dialog resource. Both of these resources have exactly the same format as a window color table (<CODE>'wctb'</CODE>) resource, described in the chapter "Window Manager" in this book.<P>
<DL>
<DT><B>WARNING</B>
<DD>Because the behavior of color alert and dialog boxes, color items, and color icons is unreliable on computers using system software versions earlier than System 7, do not specify colors for these elements if you wish to maintain backward compatibility.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 You don't have to call any new routines to change the colors used in alert or dialog boxes. When you call the <CODE>GetNewDialog</CODE> function, for example, the Dialog Manager automatically attempts to load a dialog color table resource with the same resource ID <BR>as the dialog resource.<P>
 Likewise, you can change the system default colors for controls and the color, style, typeface, and size of text used in an alert box or a dialog box by creating an <B>item color table </B>(<CODE>'ictb'</CODE>) <B>resource</B> with the same resource ID as the item list resource. You don't have to call any routines to create color items. When you use the <CODE>GetNewDialog</CODE> function, the Dialog Manager looks first for an <DFN>item color table resource </DFN>with the same resource ID as that of the item list resource.<P>
<DL>
<DT><B>Note</B>
<DD>If you want to provide an item color table resource for an alert box or <BR>a dialog box, you must create an alert color table resource or a dialog <BR>color table resource, even if the item color table resource has no actual color information and describes only static text and editable text style changes. You cannot use an item color table resource to set the font on computers that do not support Color QuickDraw. Also, be aware that changing the default system font makes your application more difficult to localize.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 Even if you provide your own <CODE>'dctb'</CODE>, <CODE>'actb'</CODE>, or <CODE>'ictb'</CODE> resources, you do not <BR>need to test whether your application is running on a computer that supports Color QuickDraw in order to use these resources. <P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-383.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-385.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
