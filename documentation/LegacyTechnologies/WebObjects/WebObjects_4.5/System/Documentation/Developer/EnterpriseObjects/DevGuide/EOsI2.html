<html><head><title>Designing Enterprise Objects</title></head><body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOF Developer's Guide</font><br><br><!--end of path --> <a href="EOsI.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="EOsI1.html"><IMG SRC="ArrowLeft.gif">Previous Section</a> <a name="313"><h1> Defining the Model</h1></a><a name="314">The work of writing enterprise objects typically begins in EOModeler. You make the following decisions for your enterprise object in EOModeler:<p></a><ul><a name="318"><p><li>Should your enterprise object be an EOGenericRecord or a custom class?</a><a name="315"><p><li>What database attributes do you want to include as properties in your class?</a><a name="316"><p><li>What data types should the class properties be?</a><a name="317"><p><li>What relationships does your enterprise object have with other objects?</a><a name="331"><p><li>What referential integrity rules should you specify for the relationships in your enterprise object?</a><a name="332"><p><li>Does your enterprise object class have inheritance relationships with other enterprise object classes?</a></ul><a name="834">These issues are discussed in the following sections. <p></a><a name="825"><h2> EOGenericRecord or Custom Class?</h2></a><a name="12476">Enterprise Objects Framework provides a "default" enterprise object class, EOGenericRecord. An EOGenericRecord can take on values for any properties defined in your application's model (see the section <a href="EOsI3.html#9425"> "Accessing an Enterprise Object's Data"</a> for more discussion of this), but implements no custom behavior. EOGenericRecord objects can hold simple values as well as refer to other enterprise objects through relationships defined in the model.<p></a><a name="333">The criterion for deciding whether to make your enterprise objects custom classes or to simply use the EOGenericRecord class is behavior. One of the main reasons to use the Enterprise Objects Framework is to associate behavior with your persistent data. Behavior is implemented as methods that "do something," as opposed to merely returning the value for a property. Since the Framework itself handles most of the behavior related to persistent storage, you can focus on the behavior specific to your application.<p></a><a name="840">Because the Customer class in the Rentals database has specialized behavior-for example, it rents units-it needs to be a custom class.<p></a><a name="821"><h2> Which Attributes Should Be Class Properties?</h2></a><a name="334">By default, EOModeler marks all of the attributes read in from the database as class properties. When an attribute is marked as a class property, it means that the attribute will be included in your class definition when you generate source files for the class, and that it will be fetched and passed to your enterprise object when you create instances from the database.<p></a><a name="335">The attributes you mark as class properties should only be ones whose values are meaningful in the object graph that's created when you fetch objects from the database. Attributes that are essentially database artifacts shouldn't be marked as class properties. For example:<p></a><ul><a name="336"><p><li>As a general rule, foreign and primary keys shouldn't be included in your enterprise object as class properties. The only exception to this rule is when the key has meaning to the user (such as a credit card number) and therefore must be displayed in the user interface.</a><a name="338"><p><li>Relationships that are just used in EOModeler as a vehicle for flattening attributes from another entity shouldn't be included as class properties. For example, suppose an Employee class flattens address properties (<strong>streetAddress</strong>, <strong>city</strong>, and so on) from an Address entity and that Employee includes these flattened attributes as class properties. The relationship from Employee to Address doesn't need to be a class property if it's otherwise not needed. For more discussion of this topic see <a href="EOsI2.html#341"> "How Should Your Enterprise Object Manage Relationships with Other Objects?"</a>.</a><a name="1211"><p><li>Relationships that represent an entity's relationship to an intermediate join table (also known as a <em>correlation</em> table) shouldn't be included in your enterprise objects as class properties (unless they contain data that's meaningful in your application).</a><a name="337"><p>For example, in the Movie database, the Director table acts as an intermediate table between Movie and Talent and exists purely to define that relationship. It has no data besides its foreign keys. Because of this, you never need to fetch instances of Director into your application. However, it makes sense to specify a relationship between Movie and Director and between Director and Talent, and to flatten that second relationship to give Movie access to the Talent table. The flattened relationship, possibly named <strong>directors</strong>, can then be marked as a class property, because it contains objects that should be included in the object graph.<p></a><a name="339"><p>Although Director contains no data besides its foreign keys, some intermediate tables do. For example, the MovieRole table acts as an intermediate table between Movie and Talent, and it includes the attribute <strong>roleName</strong>. Because of this, it's likely that if your enterprise object had a relationship to MovieRole, you'd want to include that relationship as a class property to be able to access the value of <strong>roleName</strong>.<p></a></ul><a name="340"><h2> What Data Types Should Your Properties Be?</h2></a><a name="7044">When you create a new model, Enterprise Objects Framework maps external database data types to the following standard value classes: <Table Border="3"><caption></caption><tr><th><a name="7021"><strong>Java</strong></a></th><th><a name="7023">Objective-C</a></th></tr><tr><td scope="row"><a name="7025">String</a></td><td><a name="7027">NSString</a></td></tr><tr><td scope="row"><a name="7029">BigDecimal (java.math)</a></td><td><a name="7031">NSDecimalNumber</a></td></tr><tr><td scope="row"><a name="7033">Number</a></td><td><a name="7035">NSNumber</a></td></tr><tr><td scope="row"><a name="7037">NSGregorianDate</a></td><td><a name="7039">NSCalendarDate</a></td></tr><tr><td scope="row"><a name="7041">NSData</a></td><td><a name="7043">NSData</a></td></tr></Table><Table><tr><td></Table><p></a><a name="7055">Additionally, you can map external data types to custom value classes defined by your application. When you're working with custom data, you'll typically want to convert binary data into a meaningful form. However, since you define its form, you have to convert it yourself. The &#32;Framework allows you to define a custom class whose instances are initialized with binary or string data; this prevents your accessor methods from having to explicitly convert the data, and allows other objects to access your enterprise object's property in its intended form rather than as an NSData object. For more discussion of this subject, see the chapter <a href="EOsII.html#14046"> "Advanced Enterprise Object Modeling"</a>.<p></a><a name="351"><h3> Working with Numeric Values</h3></a><a name="355">There are basically two different choices for representing numeric values in your model:<p></a><ul><a name="359"><p><li>Numbers that correspond to money values should be represented in your model as BigDecimals (or NSDecimalNumbers in Objective-C). This is because in the Enterprise Objects Framework, numeric database values are stored in one of two types of objects: Number and its subclasses or BigDecimal (NSNumber or NSDecimalNumber in Objective-C). When you use Number, values are limited to double precision, and operations are inexact. Using BigDecimal provides high precision and smooth conversions between strings, BigDecimals, and money.</a><a name="357"><p><li>Numbers that represent integer or floating point values in your database should be declared as Number objects (NSNumbers in Objective-C) in your model. You then use the Attribute Inspector to specify the scalar type to which the Number will be coerced. For &#32;example, if you're working with scientific data, you should represent it as a Number that will be coerced to a <strong>double</strong>.</a></ul><a name="360"><h3> Conversion of Numeric Values</h3></a><a name="361">When the Framework passes a Number value (NSNumber in Objective-C) to your object, the value can be converted to the corresponding scalar (numeric) type if your accessor method or instance variable requires it (for more information, see<a href="EOsI3.html#9425"> "Accessing an Enterprise Object's Data"</a>). For example, suppose your enterprise object defines these accessor methods:<p></a><a name="362"><p>public &#32;void <strong>setAge</strong>(int <em>age</em>)<br>public int <strong>age</strong><p></a><a name="363">For the <strong>setAge</strong> method, the Number value for the "age" key is converted to an<strong> int</strong> and passed as <em>age</em>. Similarly, the return value of the <strong>age</strong> method is converted to an Number.<p></a><a name="341"><h2> How Should Your Enterprise Object Manage Relationships with Other Objects?</h2></a><a name="343">In EOModeler you can specify relationships between entities. For example, in the Rentals database in the on-line examples, the Member entity can have several relationships to other entities, including:<p></a><ul><a name="356"><li>To-one relationship to Customer</a><a name="855"><li>To-one relationship to CreditCard</a><a name="857"><li>To-many relationship to Guest</a><a name="858"><li>To-many relationship to Rental</a><a name="859"><li>To-many relationship to Fee</a></ul><a name="852">You can use relationships to access data in the destination entity from the source entity.<p></a><a name="7193">When you include relationships as class properties, to-one relationships are represented as references in the object graph and to-many relationships are represented as NSArrays. You can see this more clearly if you look at the way Customer's to-one relationship to CreditCard and to-many relationship to Rental are represented as instance variables in the Customer class:<p></a><pre><a name="7194">// Reference to a CreditCard object in the object graph<br>protected CreditCard creditCard;<br><br>// Array of Rental objects<br>protected NSMutableArray rentals;</a></pre><a name="853">For the most part, you access the data in other objects by using relationship properties to traverse the in-memory object graph in your running application. For example, the following statement uses Customer's <strong>creditCard</strong> relationship to access the <strong>authorizationDate</strong> property in the CreditCard object:<p></a><pre><a name="814">date = customer.creditCard().authorizationDate();</a></pre><a name="815">Likewise, the following statement uses the Customer's <strong>rentals</strong> relationship to return an NSArray containing a customer's Rental objects:<p></a><pre><a name="826">rentalArray = customer.rentals(); </a></pre><a name="366"><h3> Referential Integrity</h3></a><a name="12840">When your enterprise object has relationships with other objects, you can use EOModeler to define rules to govern those relationships. Each of the rules possible are described briefly in the following sections. For more information on how to set these options, see the book <em>Enterprise Objects Framework Tools and Techniques</em>.<p></a><a name="11869"> Optionality<p></a><a name="784">Optionality refers to whether a relationship is optional or mandatory. For example, you can require all departments to have a location (mandatory), but not require that every employee have a manager (optional).<p></a><a name="799"> Delete Rules<p></a><a name="832">This refers to the rules that should be applied to an entity that's involved in a relationship when the source object is deleted. For example, you might have a department with multiple employees. When a user tries to delete the department, you can:<p></a><ul><a name="844"><p><li>Delete the department and remove any back reference the employee has to the department (nullify).</a><a name="845"><p><li>Delete the department and all of the employees it contains (cascade).</a><a name="846"><p><li>Refuse the deletion if the department contains employees (deny).</a><a name="6304"><p><li>Delete the department but <em>do not</em> remove any back reference the employee has to the department. <em>Use this option with caution as dangling references may result.</em></a><a name="11864"> Owns Destination<p></a></ul><a name="849">You can set a source object as owning its destination objects. When a source object owns its destination objects and you remove a destination object from the source object's relationship array, you're also deleting it from the database (alternatively, you can transfer it to a new owner). This is because ownership implies that the owned object can't exist without an owner-for example, line items can't exist outside of a purchase order. By &#32;contrast, you might have a department object that doesn't own its employee objects. If you remove an employee from a department's employees array, the employee continues to exist in the database, but its department variable is set to <strong>null</strong> (or <strong>nil</strong> in Objective-C). If you really intend to delete the employee from the database, you'd have to do it explicitly.<p></a><a name="11865"> Propagates Primary Key<p></a><a name="848">You can also specify in EOModeler that the primary key of the source entity should be propagated to newly inserted objects in the destination of the relationship. This is used for a to-one owning relationship, where the owned object has the same primary key as the source. For example, in the Movies database the TalentPhoto entity has the same primary key as the entity that owns it, Talent. In this scenario, if you create a new Talent object and the Talent doesn't already have a TalentPhoto, the Framework automatically creates a TalentPhoto object for you.<p></a><a name="712"><h3> Mapping an Entity Across Multiple Tables</h3></a><a name="358">In certain special cases you may decide to use EOModeler to "flatten" attributes from one entity into another. In general you should only flatten attributes across one-to-one relationships (like Employee to Address) where the destination entity is never fetched directly. Otherwise, you run the risk that the values of flattened attributes can get out of sync with the most current view of data in your application. <p></a><a name="713">Some examples of good uses of flattened attributes are as follows:<p></a><ul><a name="12179"><p><li>Combining multiple tables to form a logical unit. </a><a name="12180"><p>For example, you might have employee data that's spread across multiple tables such as Address, Benefits, and so on. If you have no need to access these tables individually (that is, if you'd never create an Address object since the address data is always subsumed in Employee), then it makes sense to flatten attributes from those entities into Employee.<p></a><a name="714"><p><li>Implementing vertical inheritance mapping.</a><a name="12864"><p>For example, the Member class in the RentalsInheritance model has two flattened attributes: <strong>firstName</strong> and <strong>lastName</strong>. It flattens these attributes from the Customer entity. Customer is a parent entity of Member and Guest that provides attributes common to both. Because Customer is an abstract entity and is therefore never instantiated in the object graph, the only way to access Customer's data is to flatten the appropriate attributes into its sub-entities. The relationship between Member, Guest, and Customer is an example of vertical inheritance mapping-for more discussion of this topic, see the chapter <a href="EOsII.html#14046"> "Advanced Enterprise Object Modeling"</a>. <p></a><a name="12868"><p><li>If your application (or the property in question) is read-only.</a></ul><a name="867">When you use flattened attributes, you don't need to include the relationship as a class property-there's no need to since the data it would be used to access is already included in the source entity.<p></a><a name="12853">For more discussion of this topic, see the book <em>Enterprise Objects Framework Tools and Techniques</em>.<p></a><a name="709"><h2> What about Inheritance?</h2></a><a name="2652">You can use the Advanced Entity Inspector in EOModeler to specify an entity's parent entity. For example, the Customer entity is a parent to both Member and Guest in the RentalsInheritance model. For more discussion of the different approaches you can use for inheritance, see the chapter<a href="EOsII.html#14046"> "Advanced Enterprise Object Modeling"</a>.<p></a><P> <a href="EOsI.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="EOsI3.html"><IMG SRC="ArrowRight.gif">Next Section</a><P></body></html>