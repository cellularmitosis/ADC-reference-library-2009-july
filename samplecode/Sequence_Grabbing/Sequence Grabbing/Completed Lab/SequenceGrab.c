/*	Sequence Grabber Lab	This sample shows how to use a sequence grabber component to preview and record captured data.	The example also demonstrates how to set up VideoBottlenecks and draw over top of captured data	during the GrabFrameComplete callback.*/	#include "SequenceGrab.h"// globals// ------------------------BitMap screenBits;ICMAlignmentProcRecord	apr;// functions// ------------------------// GrabFrameCompleteProc// This is where we draw text over the captured framepascal ComponentResult GrabFrameCompleteProc(SGChannel sgChan, short nBufferNum, Boolean *pbDone, long lRefCon){	ComponentResult		err = noErr;		// call the default grab-complete function 	err = SGGrabFrameComplete(sgChan,		// channel reference 							  nBufferNum,	// buffer identifier, provided for you 							  pbDone);		// pointer to a boolean, has the frame been completely captured? provided for you 	 	// if the frame is done, draw some text over it	if (*pbDone) {		CGrafPtr		pOldPort;		CGrafPtr		pTempPort = (CGrafPtr)lRefCon;		GDHandle		hghOldDevice;		PixMapHandle	hPixMap, hOldPixMap;		Rect			rectBuffer;		// set to our temporary port		GetGWorld(&pOldPort, &hghOldDevice);		SetGWorld(pTempPort, NULL);		// obtain information about a buffer that has		// been passed to your callback function		err = SGGetBufferInfo(sgChan,		// channel reference							  nBufferNum,	// buffer identifier, the sg component provides this value to your callback function.							  &hPixMap,		// pointer to a location to receive a handle to the pixel map that contains the image.							  &rectBuffer,	// rectangle structure that is to receive the dimensions of the image’s boundary rectangle.							  NULL,			// pointer to filter buffer, NULL for no buffer							  NULL);		// filter buffer rect				if (err == noErr) {			// set up to draw into this buffer			hOldPixMap = GetPortPixMap(pTempPort);			SetPortPix(hPixMap);			// draw some text into the buffer			TextSize(10);			TextMode(srcXor);			MoveTo(rectBuffer.left + 5, rectBuffer.bottom - 5);			DrawString("\pGrabFrameCompleteProc");						// restore temporary port			SetPortPix(hOldPixMap);		}		// restore old ports		SetGWorld(pOldPort, hghOldDevice);	}		return err;}// SetupVideoBottlenecks// This function initializes the video bottleneck procedure so the sequence grabber// will call us when a frame has been captured. There are nine bottleneck procs./* 		struct VideoBottles {    		short                           procCount;    		SGGrabBottleUPP                 grabProc;		    SGGrabCompleteBottleUPP         grabCompleteProc;		    SGDisplayBottleUPP              displayProc;		    SGCompressBottleUPP             compressProc;		    SGCompressCompleteBottleUPP     compressCompleteProc;		    SGAddFrameBottleUPP             addFrameProc;		    SGTransferFrameBottleUPP        transferFrameProc;		    SGGrabCompressCompleteBottleUPP  grabCompressCompleteProc;		    SGDisplayCompressBottleUPP      displayCompressProc;		}*/OSErr SetupVideoBottlenecks(SGChannel sgchanVideo, CGrafPtr pTempPort){	OSErr	err = noErr;	// set the value of a reference constant that is passed to the callback functions	err = SGSetChannelRefCon(sgchanVideo, (long)pTempPort);		if (err == noErr) {		VideoBottles	vb;		// get the current bottlenecks		vb.procCount = 9;		err = SGGetVideoBottlenecks(sgchanVideo, &vb);				if (err == noErr) {			RgnHandle	theRgn = NewRgn();						// add our GrabFrameComplete function			vb.grabCompleteProc = NewSGGrabCompleteBottleUPP(GrabFrameCompleteProc);			err = SGSetVideoBottlenecks(sgchanVideo, &vb);						// set up the temporary port with			// a wide open visible and clip region...			// so that you can use it in any video buffer			SetRectRgn(theRgn, -32000, -32000, 32000, 32000);			SetPortVisibleRegion(pTempPort, theRgn);			SetPortClipRegion(pTempPort, theRgn);						// tell QuickDraw about the changes			PortChanged((GrafPtr)pTempPort);						DisposeRgn(theRgn);		}	}	return err;}// MakeSequenceGrabber// Open the default sequence graber component and initialize itSeqGrabComponent MakeSequenceGrabber(WindowPtr pMacWnd){	SeqGrabComponent	seqGrab = NULL;	long				flags = 0;	OSErr				err = noErr;	// open up the default sequence grabber	seqGrab = OpenDefaultComponent(SeqGrabComponentType, 0);		if (seqGrab != NULL) { 		// initialize the default sequence grabber component		err = SGInitialize(seqGrab);		if (err == noErr) {			// get and set the sequence grabber control flags			SGGetFlags(seqGrab, &flags);			//flags |= sgFlagAllowNonRGBPixMaps;			SGSetFlags(seqGrab, flags);						// set the graphics world to the specified window			err = SGSetGWorld(seqGrab, GetWindowPort(pMacWnd), NULL);						// get the default sequence grabber drag aligned proc			SGGetAlignmentProc(seqGrab, &apr);		}	}	if (err && (seqGrab != NULL)) {		// clean up on failure		CloseComponent(seqGrab);		seqGrab = NULL;	}	return seqGrab;}// MakeSequenceGrabChannels// Create the new video and sound channels and set up the channel usagevoid MakeSequenceGrabChannels(SeqGrabComponent seqGrab, SGChannel *sgchanVideo, SGChannel *sgchanSound, const Rect *rect, Boolean bWillRecord){	long	lUsage;		OSErr	err = noErr;	// figure out the channel usage	lUsage = seqGrabPreview;		// always previewing by default	if (bWillRecord)		lUsage |= seqGrabRecord;	// are we going to record?	// create a video channel	err = SGNewChannel(seqGrab, VideoMediaType, sgchanVideo);	if (err == noErr) {		// set boundaries for new video channel		err = SGSetChannelBounds(*sgchanVideo, rect);				// set usage for new video channel		if (err == noErr)			err = SGSetChannelUsage(*sgchanVideo, lUsage | seqGrabPlayDuringRecord);				if (err != noErr) {			// clean up on failure			SGDisposeChannel(seqGrab, *sgchanVideo);			*sgchanVideo = NULL;		}	}	// create a sound channel	err = SGNewChannel(seqGrab, SoundMediaType, sgchanSound);	if (err == noErr) {		// set usage of new sound channel		err = SGSetChannelUsage(*sgchanSound, lUsage);				if (err != noErr) {			// clean up on failure			SGDisposeChannel(seqGrab, *sgchanSound);			*sgchanSound = NULL;		}	}}OSErr DoRecord(SeqGrabComponent seqGrab){	FSSpec	theFSSpec;	Boolean isSelected, isReplacing;	OSErr				err = noErr;		// Stop everything while the dialogs are up	SGStop(seqGrab);		err = PutFile("\pSave new movie file as:", "\pSequenceGrab.mov", &theFSSpec, &isSelected, &isReplacing);	if ((err = SGSetDataOutput(seqGrab, &theFSSpec, seqGrabToDisk)))		goto bail;			// Attempt to recover the preview area obscured by dialogs	SGUpdate(seqGrab, 0);	// Make the movie file	DeleteMovieFile(&theFSSpec);	err = CreateMovieFile(&theFSSpec, sigMoviePlayer, smSystemScript,						 createMovieFileDontOpenFile |						 createMovieFileDontCreateMovie |						 createMovieFileDontCreateResFile,						 nil,						 nil);	if (err) goto bail;			FlushEvents(mDownMask+mUpMask,0);		// Record!	err = SGStartRecord(seqGrab);	if (err) goto bail;	while (!Button() && (err == noErr))	{		err = SGIdle(seqGrab);	}		FlushEvents(mDownMask+mUpMask,0);	// If we recorded until we ran out of space, then allow SGStop to be	// called to write the movie resource.  The assumption here is that the	// data output filled up but the disk has enough free space left to	// write the movie resource.	if (!((err == dskFulErr) || (err != eofErr))) {		DeleteMovieFile(&theFSSpec);		goto bail;	}			err = SGStop(seqGrab);bail:			err = SGStartPreview(seqGrab);	return err;}WindowRef MakeAWindow(void){	WindowPtr		pMacWnd;	Rect			rectWnd = {0, 0, 230, 320};	Rect			rectBest;	// figure out the best monitor for the window	GetBestDeviceRect(NULL, &rectBest);	// put the window in the top left corner of that monitor	OffsetRect(&rectWnd, rectBest.left + 10, rectBest.top + 50);	// create the window	pMacWnd = NewCWindow(NULL, &rectWnd, "\pSequence Grabber",true, kWindowDocumentProc, (WindowPtr)-1,true, 0);	// set the port to the new window	SetPort(GetWindowPort(pMacWnd));	return pMacWnd;}Boolean IsQuickTimeInstalled(void) {	OSErr	err;	long	lResult;	err = Gestalt(gestaltQuickTime, &lResult);	return (err == noErr);}void main(void){	WindowRef				pMacWnd;	CGrafPtr				pTempPort;	SeqGrabComponent		seqGrab;	SGChannel				sgchanVideo, sgchanSound;	Rect					thePortRect;	Boolean					bDone = false;		OSErr					err = noErr;	// initialize for carbon & QuickTime	InitCursor();	if ( IsQuickTimeInstalled() )		EnterMovies();	else		goto bail;			GetQDGlobalsScreenBits( &screenBits );		// create a window	pMacWnd = MakeAWindow();		// create a sequence grabber	seqGrab = MakeSequenceGrabber(pMacWnd);	if (seqGrab == NULL)		return;	// create the grab channels	GetPortBounds(GetWindowPort(pMacWnd), &thePortRect);	MakeSequenceGrabChannels(seqGrab, &sgchanVideo, &sgchanSound, &thePortRect, true); // true = recording		// set up a video bottleneck	// create a temporary port for drawing...	pTempPort = CreateNewPort();				 	if (sgchanVideo != NULL) {		err = SetupVideoBottlenecks(sgchanVideo, pTempPort);	}		// start the sequence grabber preview	err = SGStartPreview(seqGrab);	while (!bDone) {		short		nPart;		WindowRef	pWhichWnd;		EventRecord	er; 		GetNextEvent(everyEvent, &er);		switch (er.what) {		case nullEvent:			// give the sequence grabber time								err = SGIdle(seqGrab);			if (err != noErr)				bDone = true;			break;		case updateEvt:			if (er.message == (long)pMacWnd) {				RgnHandle updateRgn = NewRgn();								GetWindowRegion(pMacWnd, kWindowUpdateRgn, updateRgn);								// inform the sequence grabber of the update				SGUpdate(seqGrab,updateRgn);								// and swallow the update event				BeginUpdate(pMacWnd);				EndUpdate(pMacWnd);								DisposeRgn(updateRgn);			}			break;		case mouseDown:			nPart = FindWindow(er.where, &pWhichWnd);			if (pWhichWnd == pMacWnd) {				switch (nPart) {				case inContent:					if ( er.modifiers & cmdKey ) {						DoRecord( seqGrab );						break;					}										// pause until mouse button is released					SGPause(seqGrab, true);					while (StillDown())						;					SGPause(seqGrab, false);					break;								case inGoAway:					bDone = TrackGoAway(pMacWnd, er.where);					break;				case inDrag:					if (StillDown()) {											// pause when dragging window so video 						// doesn't draw in the wrong place						SGPause(seqGrab, true);						DragAlignedWindow(pMacWnd, er.where, &screenBits.bounds, NULL, &apr);						SGPause(seqGrab, false);					}					break;								} // switch			}			break;					} // switch	} // while	bail:	// clean up	if ( seqGrab ) {		SGStop(seqGrab);		CloseComponent(seqGrab);	}	if ( pMacWnd )		DisposeWindow(pMacWnd);}