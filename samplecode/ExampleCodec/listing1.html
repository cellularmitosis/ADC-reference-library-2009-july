<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ExampleCodec - /examplecodec.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxQuickTimeComponentCreation-date.html">QuickTime Component Creation</a> &gt; <A HREF="javascript:location.replace('index.html');">ExampleCodec</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ExampleCodec</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/examplecodec.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/examplecodec.c</option>
<option value="listing2.html">/examplecodec.r</option></select>
				</p>
				</form>
				<p><strong><a href="ExampleCodec.zip">Download Sample</a></strong> (&#147;ExampleCodec.zip&#148;, 19.7K)<BR>
<strong><a href="ExampleCodec.dmg">Download Sample</a></strong> (&#147;ExampleCodec.dmg&#148;, 82.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    examplecodec.c  Contains:  This is an example of am image compression codec that handles both        compression and decompression of images as passed to it by the         Image Compression manager. It is built as a Component Manager Component.        The compression scheme here is 411 YUV. The image is stored as separate         luminance and chrominance channels. For each 2x2 block of pixels in the        source image we store 4 luminance (Y) components, 1 Y-Red component (U) and        1 Y-Blue (V) component. Each Y-component is stored as 6-bits,  resulting in a         savings of 2.4:1 over a 24-bit/pixel image (6*4 + 2*8)/4 = 10 bits/pixel.    Written by:     Copyright:  Copyright &copy; 1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/29/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &lt;Memory.h&gt;#include &lt;Resources.h&gt;#include &lt;QuickDraw.h&gt;  #include &lt;QDOffscreen.h&gt;#include &lt;OSUtils.h&gt;#include &lt;Errors.h&gt;#include &lt;FixMath.h&gt;#include &quot;ImageCodec.h&quot;/* Version information */#define  EXAMPLE_CODEC_REV      1#define  codecInterfaceVersion    1        /* high word returned in component GetVersion *//* Some useful macros and constants */#define  R_W  0x4ccd#define  G_W  0x970a#define  B_W  0x1c29#define  PIN(_n)    ((_n) &lt; 0 ? 0 : (_n) &gt; 255 ? 255 : (_n))/*  Our data structure declarations*//* This is the structure we use to hold data used by all instances of   this compressor and decompressor */typedef struct  {            Handle  rgbwTable;          /* optional encode/decode table */  Handle  giwTable;          /* another optional encode/decode table */  CodecInfo  **info;          /* our cached codec info structure */} SharedGlobals;/* This is the structure we use to store our global data for each instance */typedef struct  {              SharedGlobals  *sharedGlob;    /* pointer to instance-shared globals */} Globals;/* Function prototypes to keep the compiler smiling. */ComponentResultInitSharedTables(Globals **glob,ComponentInstance self);pascal ComponentResultEXAMPLECODEC(ComponentParameters *params,char **storage);pascal ComponentResultOpenCodec(ComponentInstance self);pascal ComponentResultCloseCodec(Handle storage,ComponentInstance self);pascal ComponentResultCanDoSelector(short selector);pascal ComponentResult GetVersion();pascal voidCompressStrip(char *data,char *baseAddr,short rowBytes,short w,SharedGlobals *sg);pascal voidDecompressStrip(char *data,char *baseAddr,short rowBytes,short w,SharedGlobals *sg);pascal longCDPreCompress(Handle storage,register CodecCompressParams *p);pascal longCDBandCompress(Handle storage,register CodecCompressParams *p);pascal longCDPreDecompress(Handle storage,register CodecDecompressParams *p);pascal longCDBandDecompress(Handle storage,register CodecDecompressParams *p);pascal ComponentResultCDGetCodecInfo(Handle storage,CodecInfo *info);pascal ComponentResultCDGetSimilarity(Handle storage,PixMapHandle src,const Rect *srcRect,ImageDescriptionHandle desc,        Ptr data,Fixed *similarity);pascal ComponentResultCDGetCompressedImageSize(Handle storage,ImageDescriptionHandle desc,Ptr data,long dataSize,  ICMDataProcRecordPtr dataProc,long *size);pascal ComponentResultCDGetMaxCompressionSize(Handle storage,PixMapHandle src,const Rect *srcRect,short depth,  CodecQ quality,long *size);  pascal ComponentResultCDGetCompressionTime(Handle storage,PixMapHandle src,const Rect *srcRect,short depth,    CodecQ *spatialQuality,CodecQ *temporalQuality,unsigned long *time);    pascal ComponentResultCDTrimImage(Handle storage,ImageDescriptionHandle desc,Ptr inData,long inDataSize,    ICMDataProcRecordPtr dataProc,Ptr outData,long outDataSize,ICMFlushProcRecordPtr flushProc,    Rect *trimRect,ICMProgressProcRecordPtr progressProc);pascal voidCompressStrip(char *data,char *baseAddr,short rowBytes,short len,SharedGlobals *sg);/************************************************************************************  *  This is the main dispatcher for our codec. All calls from the codec manager *  will come through here, with a unique selector and corresponding parameter block. * *  This routine must be first in the code segment of the codec thing. */pascal ComponentResultEXAMPLECODEC(ComponentParameters *params,char **storage){  /*  If the selector is less than zero, it's a Component manager selector.  */    if ( params-&gt;what &lt; 0  ) {     switch ( params-&gt;what ) {    case kComponentOpenSelect:      return CallComponentFunction(params, (ComponentFunctionUPP) OpenCodec );    case  kComponentCloseSelect:      return CallComponentFunctionWithStorage(storage,params,(ComponentFunctionUPP) CloseCodec );          case  kComponentCanDoSelect:      return CallComponentFunction(params, (ComponentFunctionUPP) CanDoSelector);    case kComponentVersionSelect :       return CallComponentFunction(params, (ComponentFunctionUPP) GetVersion);    default :      return (paramErr);    }  }    /*   *  Here we dispatch the rest of our calls. We use the magic thing manager routine which   *  calls our subroutines with the proper parameters. The prototypes are in Image Codec.h.   */    switch ( params-&gt;what ) {  case kImageCodecPreCompressSelect:      return CallComponentFunctionWithStorage(storage,params,(ComponentFunctionUPP)CDPreCompress);      case kImageCodecBandCompressSelect:    return CallComponentFunctionWithStorage(storage,params,(ComponentFunctionUPP)CDBandCompress);      case kImageCodecPreDecompressSelect:    return CallComponentFunctionWithStorage(storage,params,(ComponentFunctionUPP)CDPreDecompress);  case kImageCodecBandDecompressSelect:    return CallComponentFunctionWithStorage(storage,params,(ComponentFunctionUPP)CDBandDecompress);  case kImageCodecBusySelect:    return 0;          /* our codec is never asynchronously busy */  case kImageCodecGetCodecInfoSelect:    return CallComponentFunctionWithStorage(storage,params,(ComponentFunctionUPP)CDGetCodecInfo);      case kImageCodecGetCompressedImageSizeSelect:    return CallComponentFunctionWithStorage(storage,params,(ComponentFunctionUPP)CDGetCompressedImageSize);  case kImageCodecGetMaxCompressionSizeSelect:    return CallComponentFunctionWithStorage(storage,params,(ComponentFunctionUPP)CDGetMaxCompressionSize);  case kImageCodecGetCompressionTimeSelect:    return CallComponentFunctionWithStorage(storage,params,(ComponentFunctionUPP)CDGetCompressionTime);  case kImageCodecGetSimilaritySelect:    return CallComponentFunctionWithStorage(storage,params,(ComponentFunctionUPP)CDGetSimilarity);  case kImageCodecTrimImageSelect:    return CallComponentFunctionWithStorage(storage,params,(ComponentFunctionUPP)CDTrimImage);    default:    return(paramErr);  }  }/************************************************************************************  *  This gets called when the thing instance is opened. We allocate our storage at this *  point. If we have shared globals, we check if they exist, and put a pointer to them  *  in our instance globals so that other calls can get to them. */pascal ComponentResultOpenCodec(ComponentInstance self){  ComponentResult result;  Globals       **glob;    /*     First we allocate shared storage. This should be a handle to any    kind of data used by the thing instance. They should be allocated    in the current heap.    */          if ( (glob = (Globals **)NewHandleClear(sizeof(Globals))) == nil )  {    return(MemError());  }  SetComponentInstanceStorage(self,(Handle)glob);    /*   Check and initialize our shared globals */    result = InitSharedTables(glob,self);    return result;}/************************************************************************************  *  This gets called when the thing instance is opened. We allocate our shared storage at this *  point.   *  If we have shared globals, we check if they exist, otherwise we allocate *  them and set the ComponentRefCon so that other instances can use them. * *  The shared globals hold our CodecInfo struct, which we read from our resource file, *  and some tables that we use for speed. If we cant get the tables we can work without *  them. All items in the shared globals are made purgeable when the last of our  *  instances is closed. If our component was loaded in the application heap ( because *  there was no room in the system heap) then we keep our shared storage in the app heap. * *  We keep a pointer to the shared globals in our instance globals so that other calls can get to them. */ComponentResultInitSharedTables(Globals **glob,ComponentInstance self){  SharedGlobals  *sGlob;  long      i,j,*lp;  char      *cp;  short      resFile;  THz        saveZone;  Boolean      inAppHeap;  OSErr      result = noErr;         saveZone = GetZone();  inAppHeap = ( GetComponentInstanceA5(self) != 0 );  if ( !inAppHeap )    SetZone(SystemZone());  if ( (sGlob=(SharedGlobals*)GetComponentRefcon((Component)self)) == nil  ) {    if ( (sGlob = (SharedGlobals*)NewPtrClear(sizeof(SharedGlobals))) == nil ) {       result = MemError();      goto obail;    }     SetComponentRefcon((Component)self,(long)sGlob);  }  (*glob)-&gt;sharedGlob = sGlob;  // keep this around where it's easy to get at    if ( sGlob-&gt;info == nil || *(Handle)sGlob-&gt;info == nil  )  {    if ( sGlob-&gt;info )       DisposeHandle((Handle)sGlob-&gt;info);    /* Get the CodecInfo struct which we keep in our resource fork */        resFile = OpenComponentResFile((Component)self);    if (resFile == -1) {      result = memFullErr;      goto obail;    }    sGlob-&gt;info = (CodecInfo **) Get1Resource(codecInfoResourceType,128);    if ( sGlob-&gt;info == nil ) {      CloseComponentResFile(resFile);      result = ResError();      goto obail;    }    LoadResource((Handle)sGlob-&gt;info);    if ( ResError() ) {      CloseComponentResFile(resFile);      result = ResError();      goto obail;    }    DetachResource((Handle)sGlob-&gt;info);    CloseComponentResFile(resFile);  }  HNoPurge((Handle)sGlob-&gt;info);    if ( sGlob-&gt;rgbwTable == nil || *sGlob-&gt;rgbwTable == nil )  {    if ( sGlob-&gt;rgbwTable )      ReallocateHandle(sGlob-&gt;rgbwTable,3*256*sizeof(long));    else       sGlob-&gt;rgbwTable = NewHandleSys(3*256*sizeof(long));          /* we can actual still work without these tables, so we dont bail       if we cant get the memory for them */           if ( sGlob-&gt;rgbwTable  &amp;&amp; *sGlob-&gt;rgbwTable ) {      lp = (long *)*sGlob-&gt;rgbwTable;      for ( i=0, j = 0; i &lt; 256; i++, j += R_W )        *lp++ = j;      for ( i=0, j = 0; i &lt; 256; i++, j += G_W )        *lp++ = j;      for ( i=0, j = 0; i &lt; 256; i++, j += B_W )        *lp++ = j;    }  }  if ( sGlob-&gt;rgbwTable )     HNoPurge(sGlob-&gt;rgbwTable);      /* make sure it wont get purged while we are open */    /* green inverse table */  if ( sGlob-&gt;giwTable == nil || *sGlob-&gt;giwTable == nil  )  {    if ( sGlob-&gt;giwTable )       ReallocateHandle(sGlob-&gt;giwTable,256);    else       sGlob-&gt;giwTable = NewHandleSys(256);    /* we can actual still work without these tables, so we dont bail       if we cant get hte memory for them */    if ( sGlob-&gt;giwTable &amp;&amp; *sGlob-&gt;giwTable  ) {      for ( i=0, cp = *sGlob-&gt;giwTable ; i &lt; 256; i++ )        *cp++ = PIN( (i&lt;&lt;16) / G_W);    }  }  if ( sGlob-&gt;giwTable )     HNoPurge(sGlob-&gt;giwTable);      /* make sure it wont get purged while we are open */obail:  SetZone(saveZone);  if ( result != noErr &amp;&amp; sGlob != nil ) {    if ( sGlob-&gt;rgbwTable )      DisposeHandle(sGlob-&gt;rgbwTable);    if ( sGlob-&gt;info )      DisposeHandle((Handle)sGlob-&gt;info);    DisposePtr((Ptr)sGlob);    SetComponentRefcon((Component)self,(long)nil);  }  return(result);}/************************************************************************************  *  This gets called when the thing instance is closed. We need to get rid of any  *  instance storage here.  */pascal ComponentResultCloseCodec(Handle storage,ComponentInstance self){  SharedGlobals  *sGlob;  Globals      **glob = (Globals **)storage;      /*  If we are closing our last instance     then we make the shared global items purgeable to    speed things up next instance.   */    if ( CountComponentInstances((Component)self) == 1) {    if ( (sGlob=(SharedGlobals*)(*glob)-&gt;sharedGlob) != nil  ) {      if ( sGlob-&gt;rgbwTable )        HPurge(sGlob-&gt;rgbwTable);      if ( sGlob-&gt;giwTable )        HPurge(sGlob-&gt;giwTable);      if ( sGlob-&gt;info )        HPurge((Handle)sGlob-&gt;info);    }  }  if ( glob )      DisposeHandle((Handle)glob);  return(noErr);}/************************************************************************************  *   Return true if we can handle the selector, otherwise false. */pascal ComponentResultCanDoSelector(short selector){    switch(selector) {    case kComponentOpenSelect:    case kComponentCloseSelect:    case kComponentCanDoSelect:    case kComponentVersionSelect :     case kImageCodecPreCompressSelect:    case kImageCodecBandCompressSelect:    case kImageCodecPreDecompressSelect:    case kImageCodecBandDecompressSelect:    case kImageCodecBusySelect:    case kImageCodecGetCodecInfoSelect:    case kImageCodecGetCompressedImageSizeSelect:    case kImageCodecGetMaxCompressionSizeSelect:    case kImageCodecGetCompressionTimeSelect:    case kImageCodecGetSimilaritySelect:    case kImageCodecTrimImageSelect:      return(true);    default:      return (false);  }}/************************************************************************************  *  Return the version of this component ( defines interface ) and revision level *  of the code. */pascal ComponentResult GetVersion(){  return ((codecInterfaceVersion&lt;&lt;16) | EXAMPLE_CODEC_REV);    /* interface version in hi word, code rev in lo word  */}/************************************************************************************  *  CDPreCompress gets called before an image is compressed, or whenever the source pixmap *  pixel size changes when compressing a sequence. We return information about *  how we can compress the image to the codec manager, so that it can fit the source data *  to our requirements. The ImageDescriptor is already filled in, so we can use it for  *  reference (or even add to it ). PixelSize is the pixel depth of the source pixmap, we *  use this as a reference for deciding what we can do. The other parameters return information *  to the CodecManager about what we can do. We can also do setup here if we want to. */pascal longCDPreCompress(Handle storage,register CodecCompressParams *p){  #pragma unused(storage)  CodecCapabilities *capabilities = p-&gt;capabilities;  /*   *  First we return which depth input pixels we can deal with - based on what the   *  app has available - we can only work with 32 bit input pixels.   */       switch ( (*p-&gt;imageDescription)-&gt;depth )  {    case 16:      capabilities-&gt;wantedPixelSize = 32;      break;    default:      return(codecConditionErr);      break;  }  /* if the buffer gets banded,  return the smallest one we can deal with */    capabilities-&gt;bandMin = 2;  /* if the buffer gets banded, return the increment it be should grown */  capabilities-&gt;bandInc = 2;      /*   *  If a codec needs the dimensions of the source pixmap to be of certain multiples   *  it can ask for the image to be extended out (via pixel replication) vertically   *  and/or horizontally.   *   *  In our case, we're dealing with 2 by 2 blocks and therefore we want the image   *  height and width to both be multiples of 2.  If either dimension is odd, we   *  ask it have it extended by one pixel.   */  capabilities-&gt;extendWidth = (*p-&gt;imageDescription)-&gt;width &amp; 1;  capabilities-&gt;extendHeight = (*p-&gt;imageDescription)-&gt;height &amp; 1;    return(noErr);}/************************************************************************************  *  CDBandCompress gets called when the codec manager wants us to compress an image, or a horizontal  *  band of an image. The pixel data at sBaseAddr is guaranteed to conform to the criteria we  *  demanded in BeginCompress. */pascal longCDBandCompress(Handle storage,register CodecCompressParams *p){  short        width,height;  Ptr          cDataPtr,dataStart;  short        depth;  Rect        sRect;  long        offsetH,offsetV;  Globals        **glob  = (Globals **)storage;  register char     *baseAddr;  long        numLines,numStrips;  short        rowBytes;  long        stripBytes;  char        mmuMode = 1;  register short    y;  ImageDescription  **desc = p-&gt;imageDescription;  OSErr        result = noErr;    /*  If there is a progress proc, give it an open call at the start of this band. */  if (p-&gt;progressProcRecord.progressProc)    CallICMDataProc(p-&gt;progressProcRecord.progressProc,codecProgressOpen,0,      p-&gt;progressProcRecord.progressRefCon);  width = (*desc)-&gt;width;  height = (*desc)-&gt;height;  depth = (*desc)-&gt;depth;  dataStart = cDataPtr = p-&gt;data;  /* figure out offset to first pixel in baseAddr from the pixelsize and bounds */  rowBytes = p-&gt;srcPixMap.rowBytes &amp; 0x3fff;  sRect =  p-&gt;srcPixMap.bounds;  numLines = p-&gt;stopLine - p-&gt;startLine;    /* number of scanlines in this band */  numStrips = (numLines+1)&gt;&gt;1;        /* number of strips in this band */  stripBytes = ((width+1)&gt;&gt;1) * 5;    /* adjust the source baseAddress to be at the beginning of the desired rect */  switch ( p-&gt;srcPixMap.pixelSize ) {  case 32:    offsetH = sRect.left&lt;&lt;2;    break;  case 16:    offsetH = sRect.left&lt;&lt;1;    break;  case 8:    offsetH = sRect.left;    break;  default:    result = codecErr;    goto bail;  }  offsetV = sRect.top * rowBytes;  baseAddr = p-&gt;srcPixMap.baseAddr + offsetH + offsetV;  /* if there is not a flush proc, adjust the pointer to the next band */    if (  p-&gt;flushProcRecord.flushProc == nil )    cDataPtr += (p-&gt;startLine&gt;&gt;1) * stripBytes;  else {    if ( p-&gt;bufferSize &lt; stripBytes ) {      result = codecSpoolErr;      goto bail;    }  }  /* do the slower flush/progress case if we have too */    if (  p-&gt;flushProcRecord.flushProc  || p-&gt;progressProcRecord.progressProc ) {    SharedGlobals *sg = (*glob)-&gt;sharedGlob;    for ( y=0; y &lt; numStrips; y++) {      SwapMMUMode(&amp;mmuMode);      CompressStrip(cDataPtr,baseAddr,rowBytes,width,sg);      SwapMMUMode(&amp;mmuMode);      baseAddr += rowBytes&lt;&lt;1;      if ( p-&gt;flushProcRecord.flushProc ) {         if (( result=CallICMFlushProc(p-&gt;flushProcRecord.flushProc,cDataPtr,stripBytes,            p-&gt;flushProcRecord.flushRefCon)) != noErr) {          result = codecSpoolErr;          goto bail;        }      } else {        cDataPtr += stripBytes;      }      if (p-&gt;progressProcRecord.progressProc) {        if(( result=CallICMProgressProc(p-&gt;progressProcRecord.progressProc,codecProgressUpdatePercent,          FixDiv(y,numStrips),p-&gt;progressProcRecord.progressRefCon)) != noErr ) {            result = codecAbortErr;            goto bail;          }      }    }  } else {    SharedGlobals *sg = (*glob)-&gt;sharedGlob;    short  tRowBytes = rowBytes&lt;&lt;1;    SwapMMUMode(&amp;mmuMode);    for ( y=numStrips; y--; ) {      CompressStrip(cDataPtr,baseAddr,rowBytes,width,sg);      cDataPtr += stripBytes;      baseAddr += tRowBytes;    }    SwapMMUMode(&amp;mmuMode);  }  /*      return size and similarity on the last band       */    if ( p-&gt;conditionFlags &amp; codecConditionLastBand ) {    (*p-&gt;imageDescription)-&gt;dataSize = stripBytes * ((height+1)&gt;&gt;1);  /* return the actual size of the compressed data */    p-&gt;similarity = 0;              /* we don't do frame differencing */  }  bail:  /*  If there is a progress proc, give it a close call at the end of this band. */  if (p-&gt;progressProcRecord.progressProc)    CallICMProgressProc(p-&gt;progressProcRecord.progressProc,codecProgressClose,0,      p-&gt;progressProcRecord.progressRefCon);      return(result);}/************************************************************************************  *  CDPreDecompress gets called before an image is decompressed. We return information about *  how we can decompress the image to the codec manager, so that it can fit the destination data *  to our requirements.  */pascal longCDPreDecompress(Handle storage,register CodecDecompressParams *p){  #pragma unused(storage)  register CodecCapabilities  *capabilities = p-&gt;capabilities;  Rect  dRect = p-&gt;srcRect;    /*  Check if the matrix is okay for us. We don't do anything fancy. */    if ( !TransformRect(p-&gt;matrix,&amp;dRect,nil) )    return(codecConditionErr);  /*  Decide which depth compressed data we can deal with. */    switch ( (*p-&gt;imageDescription)-&gt;depth )  {    case 16:      break;    default:      return(codecConditionErr);      break;  }    /*  We can deal only 32 bit pixels. */  capabilities-&gt;wantedPixelSize = 32;      /*  The smallest possible band we can do is 2 scan lines. */    capabilities-&gt;bandMin = 2;  /*  We can deal with 2 scan line high bands. */  capabilities-&gt;bandInc = 2;    /*  If we needed our pixels to be aligned on some integer multiple we would set these to   *  the number of pixels we need the dest extended by. If we dont care, or we take care of   *  it ourselves we set them to zero.   */  capabilities-&gt;extendWidth = p-&gt;srcRect.right &amp; 1;  capabilities-&gt;extendHeight = p-&gt;srcRect.bottom &amp; 1;    return(noErr);}/************************************************************************************  *  CDBandDecompress gets called when the codec manager wants us to decompress an image or a horizontal  *  band of an image. The pixel data at baseAddr is guaranteed to conform to the criteria we  *  demanded in BeginDecompress. If maskIn is true, then the mask data at mBaseAddr is valid, and *  we need to clear bits in it that correspond to any pixels in the destination we do not want to  *  change. ( We always write all pixels, so we dont care. This mode is important only for those *  codecs that have frame differencing and don't always write all the pixels. ) */pascal longCDBandDecompress(Handle storage,register CodecDecompressParams *p){  Rect        dRect;  long        offsetH,offsetV;  Globals        **glob  = (Globals **)storage;  long        numLines,numStrips;  short        rowBytes;  long        stripBytes;  short        width;  register short    y;  register char    *baseAddr;  char        *cDataPtr;  char        mmuMode = 1;  OSErr        result = noErr;    /*  Calculate the real base address based on the bounds rect. If it's not     a linear transformation, we dont do it. */  dRect = p-&gt;srcRect;  if ( !TransformRect(p-&gt;matrix,&amp;dRect,nil) )    return(paramErr);  /*  If there is a progress proc, give it an open call at the start of this band. */  if (p-&gt;progressProcRecord.progressProc)    CallICMProgressProc(p-&gt;progressProcRecord.progressProc,codecProgressOpen,0,      p-&gt;progressProcRecord.progressRefCon);      /* initialize some local variables */    width = (*p-&gt;imageDescription)-&gt;width;  rowBytes = p-&gt;dstPixMap.rowBytes;            numLines = p-&gt;stopLine - p-&gt;startLine;      /* number of scanlines in this band */  numStrips = (numLines+1)&gt;&gt;1;          /* number of strips in this band */  stripBytes = ((width+1)&gt;&gt;1) * 5;        /* number of bytes in one strip of blocks */  cDataPtr = p-&gt;data;    /* adjust the destination baseaddress to be at the beginning of the desired rect */    offsetH = (dRect.left - p-&gt;dstPixMap.bounds.left);  switch (  p-&gt;dstPixMap.pixelSize ) {  case 32:    offsetH &lt;&lt;=2;          /* 1 pixel = 4 bytes */    break;  case 16:    offsetH &lt;&lt;=1;          /* 1 pixel = 2 bytes */    break;  case 8:                    break;              /* 1 pixel = 1 byte */  default:    result = codecErr;        /* we dont handle these cases, thow we could */    goto bail;  }  offsetV = (dRect.top - p-&gt;dstPixMap.bounds.top) * rowBytes;  baseAddr = p-&gt;dstPixMap.baseAddr + offsetH + offsetV;  /*    *  If we are skipping some data, we just skip it here. We can tell because   *  firstBandInFrame says this is the first band for a new frame, and   *  if startLine is not zero, then that many lines were clipped out.   */  if ( (p-&gt;conditionFlags &amp; codecConditionFirstBand) &amp;&amp; p-&gt;startLine != 0 ) {    if ( p-&gt;dataProcRecord.dataProc ) {      for ( y=0; y  &lt; p-&gt;startLine&gt;&gt;1; y++ )  {        if ( (result=CallICMDataProc(p-&gt;dataProcRecord.dataProc,&amp;cDataPtr,stripBytes,            p-&gt;dataProcRecord.dataRefCon)) != noErr ) {          result = codecSpoolErr;          goto bail;        }        cDataPtr += stripBytes;      }    } else      cDataPtr += (p-&gt;startLine&gt;&gt;1) * stripBytes;  }    /*   *  If theres a dataproc spooling the data to us, then we have to do the data   *  in whatever size chunks they want to give us, or if there is a progressProc   *  make sure to call it as we go along.   */    if ( p-&gt;dataProcRecord.dataProc || p-&gt;progressProcRecord.progressProc ) {    SharedGlobals *sg = (*glob)-&gt;sharedGlob;      for (y=0; y &lt; numStrips; y++) {      if (p-&gt;dataProcRecord.dataProc) {        if ( (result=CallICMDataProc(p-&gt;dataProcRecord.dataProc,&amp;cDataPtr,stripBytes,            p-&gt;dataProcRecord.dataRefCon)) != noErr ) {          result = codecSpoolErr;          goto bail;        }      }      SwapMMUMode(&amp;mmuMode);      DecompressStrip(cDataPtr,baseAddr,rowBytes,width,sg);      SwapMMUMode(&amp;mmuMode);      baseAddr += rowBytes&lt;&lt;1;      cDataPtr += stripBytes;      if (p-&gt;progressProcRecord.progressProc) {        if ( (result=CallICMProgressProc(p-&gt;progressProcRecord.progressProc,codecProgressUpdatePercent,          FixDiv(y, numStrips),p-&gt;progressProcRecord.progressRefCon)) != noErr ) {          result = codecAbortErr;           goto bail;        }      }    }      /*    *   * otherwise - do the fast case.    *   */       } else {    SharedGlobals *sg = (*glob)-&gt;sharedGlob;    short  tRowBytes = rowBytes&lt;&lt;1;        SwapMMUMode(&amp;mmuMode);    for ( y=numStrips; y--; ) {      DecompressStrip(cDataPtr,baseAddr,rowBytes,width,sg);      baseAddr += tRowBytes;      cDataPtr += stripBytes;    }    SwapMMUMode(&amp;mmuMode);  }    /*    *   *  IMPORTANT: update pointer to data in params, so when we get the  next   *  band we'll be at the right place in our data.   *     */    p-&gt;data = cDataPtr;    if ( p-&gt;conditionFlags &amp; codecConditionLastBand ) {    /* Tie up any loose ends on the last band of the frame, if we had any */  }bail:  /*  If there is a progress proc, give it a close call at the end of this band. */  if (p-&gt;progressProcRecord.progressProc)    CallICMProgressProc(p-&gt;progressProcRecord.progressProc,codecProgressClose,0,      p-&gt;progressProcRecord.progressRefCon);  return(result);}/************************************************************************************  *  CDGetCodecInfo allows us to return information about ourselves to the codec manager. *   *  There will be a tool for determining appropriate values for the accuracy, speed *  and level information. For now we estimate with scientific wild guessing. * *  The info is stored as a resource in the same file with our component. */pascal ComponentResultCDGetCodecInfo(Handle storage,CodecInfo *info){  Globals **glob = (Globals **)storage;  if ( info == nil )     return(paramErr);  BlockMove((Ptr)*((*glob)-&gt;sharedGlob)-&gt;info,(Ptr)info,sizeof(CodecInfo));  return(noErr);}/************************************************************************************  *  When CDGetSimilarity is called, we return the percent of the compressed image A that *  is different from compressed image B. This can be used by applications that use sequence *  dynamics as an indicator for editing image sequences. *   *  If the codec cannot do a direct similarity comparison, the ICM decompresses image A and *  do a comparison with image B.  This call is provided so that a codec can save the time *  of the intermediate decompress if it can do the comparison directly. */pascal ComponentResultCDGetSimilarity(Handle storage,PixMapHandle src,const Rect *srcRect,ImageDescriptionHandle desc,        Ptr data,Fixed *similarity){#pragma  unused(storage,src,srcRect,desc,data,similarity)  /*  This call is not implemented yet, which is okay, because its not used very much and is not mandatory */  return(codecUnimpErr);}/************************************************************************************  *  When CDGetCompressedImageSize is called, we return the size in bytes of the given compressed *  data ( for one image frame). */pascal ComponentResultCDGetCompressedImageSize(Handle storage,ImageDescriptionHandle desc,Ptr data,long dataSize,  ICMDataProcRecordPtr dataProc,long *size){#pragma  unused(storage,data,dataSize,dataProc)  short  width =(*desc)-&gt;width;  short  height = (*desc)-&gt;height;    if ( size == nil )    return(paramErr);      /*   *  Our data has a size which is deterministic based on the image size. If it were not we   *  could encode the size in the compressed data, or figure it out by walking the   *  compressed data.   */     *size = ((width+1)/2) * 5 * ((height+1)/2);  return(noErr);}/************************************************************************************  *  When CDGetMaxCompressionSize is called, we return the maximum size the compressed data for *  the given image would be in bytes. */pascal ComponentResultCDGetMaxCompressionSize(Handle storage,PixMapHandle src,const Rect *srcRect,short depth,  CodecQ quality,long *size){#pragma  unused(storage,src,depth,quality)    short width = srcRect-&gt;right - srcRect-&gt;left;  short height = srcRect-&gt;bottom - srcRect-&gt;top;  /*  we always end up with a fixed size. If we did not, we would return the worst case size */    *size = ((width+1)/2) * 5 * ((height+1)/2);    return(noErr);}/************************************************************************************  *  When CDGetCompressionTime is called, we return the approximate time for compressing *  the given image would be in milliseconds. We also return the closest actual quality *  we can handle for the requested value. */pascal ComponentResultCDGetCompressionTime(Handle storage,PixMapHandle src,const Rect *srcRect,short depth,    CodecQ *spatialQuality,CodecQ *temporalQuality,unsigned long *time){#pragma  unused(storage,src,srcRect,depth)  if (time)    *time = 0;                  /* we don't know how many msecs */  if (spatialQuality)    *spatialQuality = codecNormalQuality;    /* we have only one quality level for now */    if (temporalQuality)    *temporalQuality = 0;            /* we cannot do temporal compression */  return(noErr);}/************************************************************************************  *  When CDTrimImage is called, we take the given compressed data and return only the portion *  which is represented by the trimRect. We can return a little more if we have too, but we *  need only return enough so that the image in trimRect is properly displayed. We then *  adjust the rectangle to corresond to the same rectangle in the new trimmed data. */pascal ComponentResultCDTrimImage(Handle storage,ImageDescriptionHandle desc,Ptr inData,long inDataSize,    ICMDataProcRecordPtr dataProc,Ptr outData,long outDataSize,ICMFlushProcRecordPtr flushProc,    Rect *trimRect,ICMProgressProcRecordPtr progressProc){#pragma  unused(storage,inDataSize)  Rect  rect = *trimRect;  char  *dataP,*startP;  short  trimOffTop;  short  trimOffBottom;  short  trimOffLeft;  short  trimOffRight;  short  bytesOffLeft;  short  newHeight,newWidth;  long  size;  short  stripBytes;  short  newStripBytes;  short  y;  OSErr  result = noErr;        if ( dataProc-&gt;dataProc == nil )    dataProc = nil;  if ( flushProc-&gt;flushProc == nil )    flushProc = nil;  if ( progressProc-&gt;progressProc == nil )    progressProc = nil;  if ( progressProc )     CallICMProgressProc(progressProc-&gt;progressProc,codecProgressOpen,0,progressProc-&gt;progressRefCon);  dataP = inData;  newHeight = (*desc)-&gt;height;  newWidth = (*desc)-&gt;width;  stripBytes = ((newWidth+1)&gt;&gt;1) * 5;      /* the number of bytes in a strip (2-scanlines/strip) */    /* figure out how many 2x2 blocks we want to strip from each side of the image */  trimOffTop = rect.top&gt;&gt;1;  trimOffBottom  = (newHeight - rect.bottom) &gt;&gt; 1;  trimOffLeft = rect.left&gt;&gt;1;  trimOffRight  = (newWidth - rect.right) &gt;&gt; 1;  /* point to the start of the first strip we are using */  startP  = dataP + stripBytes * trimOffTop;  /* make the trim values pixel based */    trimOffLeft &lt;&lt;= 1;  trimOffTop &lt;&lt;= 1;  trimOffBottom &lt;&lt;= 1;  trimOffRight &lt;&lt;= 1;    /* calculate new height and width */    newHeight -= trimOffTop + trimOffBottom;  newWidth -=  trimOffLeft + trimOffRight;    /* calc size in bytes of strips of the new width */    newStripBytes = ((newWidth+1)&gt;&gt;1) * 5;      /* figure number of bytes to toss at the beginning of each strip  */    bytesOffLeft = (trimOffLeft&gt;&gt;1) * 5;  /* figure size of new trimmed image */    size = newStripBytes * (newHeight&gt;&gt;1);    /* make sure it's gonna fit */    if ( size &gt; outDataSize )  {    result = codecErr;    goto bail;  }      /* now go through the strips and copy the needed portion of each to the new data */  if (  dataProc ) {    short rightBytes = stripBytes - newStripBytes - bytesOffLeft;    for ( y=0; y &lt; trimOffTop; y++ ) {      if ( (result=CallICMDataProc(dataProc-&gt;dataProc,&amp;inData,stripBytes,dataProc-&gt;dataRefCon)) != noErr )        goto bail;      inData += stripBytes;      if (progressProc ) {        if ( (result=CallICMProgressProc(progressProc-&gt;progressProc,codecProgressUpdatePercent,          FixDiv(y, (*desc)-&gt;height),progressProc-&gt;progressRefCon)) != noErr)  {          result = codecAbortErr;          goto bail;        }      }    }    for ( y=0; y &lt; newHeight; y+= 2) {      if ( bytesOffLeft ) {        if ( (result=CallICMDataProc(dataProc-&gt;dataProc,&amp;inData,bytesOffLeft,dataProc-&gt;dataRefCon)) != noErr )          goto bail;        inData += bytesOffLeft;      }      if ( (result=CallICMDataProc(dataProc-&gt;dataProc,&amp;inData,newStripBytes,dataProc-&gt;dataRefCon)) != noErr )        goto bail;      if (  flushProc ) {        if ( (result=CallICMFlushProc(flushProc-&gt;flushProc,inData,newStripBytes,flushProc-&gt;flushRefCon)) != noErr ) {          result = codecSpoolErr;          goto bail;        }      }      else {        BlockMove(inData,outData,newStripBytes);        outData += newStripBytes;      }      inData += newStripBytes;      if ( rightBytes ) {        if ( (result=CallICMDataProc(dataProc-&gt;dataProc,&amp;inData,rightBytes,dataProc-&gt;dataRefCon)) != noErr ) {          result = codecSpoolErr;          goto bail;        }        inData += rightBytes;      }      if (progressProc) {        if ( (result=CallICMProgressProc(progressProc-&gt;progressProc,codecProgressUpdatePercent,          FixDiv((trimOffTop + y),(*desc)-&gt;height),progressProc-&gt;progressRefCon)) != noErr ) {          result = codecAbortErr;          goto bail;        }      }    }  }  else {    inData += stripBytes * trimOffTop;    for ( y=0; y &lt; newHeight; y += 2, inData += stripBytes) {      if (  flushProc ) {        if ( (result=CallICMFlushProc(flushProc-&gt;flushProc,inData + bytesOffLeft,newStripBytes,flushProc-&gt;flushRefCon)) != noErr ) {          result = codecSpoolErr;          goto bail;        }      }      else {        BlockMove(inData + bytesOffLeft,outData,newStripBytes);        outData += newStripBytes;      }      if (progressProc ) {        if ( (result=CallICMProgressProc(progressProc-&gt;progressProc,codecProgressUpdatePercent,          FixDiv((trimOffTop + y),(*desc)-&gt;height),progressProc-&gt;progressRefCon)) != noErr ) {          result = codecAbortErr;          goto bail;        }      }    }  }  /* adjust the rectangle to reflect our changes */    trimRect-&gt;top -= trimOffTop;  trimRect-&gt;bottom -= trimOffTop;  trimRect-&gt;left -= trimOffLeft;  trimRect-&gt;right -= trimOffLeft;  /* return the new width and height in the image description and the size */    (*desc)-&gt;height = newHeight;  (*desc)-&gt;width = newWidth;  (*desc)-&gt;dataSize = size;bail:  if ( progressProc )     CallICMProgressProc(progressProc-&gt;progressProc,codecProgressClose,0,progressProc-&gt;progressRefCon);  return(result);}  #ifndef  HAS_ASM    /* we could do this part in assembly for speed if we desired */#define  READPIXEL(n)        \  l = *lp++;            \  r = (l&gt;&gt;16);          \  g = (l&gt;&gt;8);            \  b = l;              \  yt = (R_W*r + G_W*g + B_W*b);  \  if ( yt &gt; ((256L&lt;&lt;16)-1) ) yt = ((256L&lt;&lt;16)-1); \  ys[n] = yt&gt;&gt;16;          \  y += yt;            \  u += r;              \  v += b;            #define  READPIXEL_TAB(n)        \  l = *lp++;            \  r = (l&gt;&gt;16);          \  g = (l&gt;&gt;8);            \  b = l;              \  yt = (rwTable[r] + gwTable[g] + bwTable[b]);  \  if ( yt &gt; ((256L&lt;&lt;16)-1) ) yt = ((256L&lt;&lt;16)-1); \  ys[n] = yt&gt;&gt;16;          \  y += yt;            \  u += r;              \  v += b;            pascal voidCompressStrip(char *data,char *baseAddr,short rowBytes,short len,SharedGlobals *sg){  register long  l,*lp = (long *)baseAddr;  register unsigned char   r,g,b;  unsigned char  ys[4];  register long  y,yt;  short  u,v;  short  rowLongs = (rowBytes&gt;&gt;2);              len++;  len&gt;&gt;=1;    if ( sg-&gt;rgbwTable &amp;&amp; *sg-&gt;rgbwTable  ) {    long  *rwTable,*gwTable,*bwTable;      rwTable = (long *)*sg-&gt;rgbwTable;    gwTable = rwTable + 256;    bwTable = rwTable + 512;    while ( len-- &gt; 0) {      y = u = v = 0;      READPIXEL_TAB(0);      READPIXEL_TAB(1);      lp += rowLongs-2;      READPIXEL_TAB(2);      READPIXEL_TAB(3);      lp -= rowLongs;          y &gt;&gt;= 16;      u = (u - y)&gt;&gt;4;      v = (v - y)&gt;&gt;4;            l =  (long)(0xfc &amp; (ys[0])) &lt;&lt; 24;      l |= (long)(0xfc &amp; (ys[1])) &lt;&lt; 18;      l |= (long)(0xfc &amp; (ys[2])) &lt;&lt; 12;      l |= (long)(0xfc &amp; (ys[3])) &lt;&lt;  6;      l |= u &amp; 0xff;      *(long *)data = l;      data += sizeof(long);      *data++ = v;    }  } else {    while ( len-- &gt; 0) {      y = u = v = 0;      READPIXEL(0);      READPIXEL(1);      lp += rowLongs-2;      READPIXEL(2);      READPIXEL(3);      lp -= rowLongs;          y &gt;&gt;= 16;      u = (u - y)&gt;&gt;4;      v = (v - y)&gt;&gt;4;            l =  (long)(0xfc &amp; (ys[0])) &lt;&lt; 24;      l |= (long)(0xfc &amp; (ys[1])) &lt;&lt; 18;      l |= (long)(0xfc &amp; (ys[2])) &lt;&lt; 12;      l |= (long)(0xfc &amp; (ys[3])) &lt;&lt;  6;      l |= u &amp; 0xff;      *(long *)data = l;      data += sizeof(long);      *data++ = v;    }  }}#define  WRITEPIXEL        \  r = PIN(u+y);        \  b = PIN(v+y);        \  y &lt;&lt;= 16;          \  y -= r * R_W;        \  y -= b * B_W;        \  g = PIN(y / G_W);      \  *lp++ = (long) ( (long) r &lt;&lt;16) | ( (long) g &lt;&lt;8) | b;  #define  WRITEPIXEL_TAB      \  r = PIN(u+y);        \  b = PIN(v+y);        \  y &lt;&lt;= 16;          \  y -= rwTable[r];    \  y -= bwTable[b];    \  g = giwTable[PIN(y&gt;&gt;16)];  \  *lp++ = (long) ( (long) r &lt;&lt;16) | ( (long) g &lt;&lt;8) | b;    pascal voidDecompressStrip(char *data,char *baseAddr,short rowBytes,short len,SharedGlobals *sg){  register long  y;  register unsigned char   r,g,b;  register long  l,*lp;  long   u,v;  unsigned char  ys[4];  short  rowLongs = (rowBytes&gt;&gt;2);  short  blen = len;  lp = (long *)baseAddr;  blen++;  blen &gt;&gt;= 1;    if ( sg-&gt;rgbwTable &amp;&amp; *sg-&gt;rgbwTable &amp;&amp;  sg-&gt;giwTable &amp;&amp; *sg-&gt;giwTable ) {    unsigned char  *giwTable;      long  *rwTable,*bwTable;    giwTable = (unsigned char*)*sg-&gt;giwTable;    rwTable = (long *)*sg-&gt;rgbwTable;    bwTable = rwTable + 512;    while ( blen-- &gt; 0 ) {      l = *(long *)data;      data += sizeof(long);      ys[0] = (0xfc &amp; (l&gt;&gt;24));      ys[1] = (0xfc &amp; (l&gt;&gt;18));      ys[2] = (0xfc &amp; (l&gt;&gt;12));      ys[3] = (0xfc &amp; (l&gt;&gt;6));      u = (char)l;      v = *data++;      u&lt;&lt;=2;      v&lt;&lt;=2;      y = ys[0];      WRITEPIXEL_TAB;      y = ys[1];      WRITEPIXEL_TAB;      lp += rowLongs - 2;      y = ys[2];      WRITEPIXEL_TAB;      y = ys[3];      WRITEPIXEL_TAB;      lp -= rowLongs;    }  } else {    while ( blen-- &gt; 0 ) {      l = *(long *)data;      data += sizeof(long);      ys[0] = (0xfc &amp; (l&gt;&gt;24));      ys[1] = (0xfc &amp; (l&gt;&gt;18));      ys[2] = (0xfc &amp; (l&gt;&gt;12));      ys[3] = (0xfc &amp; (l&gt;&gt;6));      u = (char)l;      v = *data++;      u&lt;&lt;=2;      v&lt;&lt;=2;      y = ys[0];      WRITEPIXEL;      y = ys[1];      WRITEPIXEL;      lp += rowLongs - 2;      y = ys[2];      WRITEPIXEL;      y = ys[3];      WRITEPIXEL;      lp -= rowLongs;    }  }}#endif</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ExampleCodec/listing1.html%3Fid%3DDTS10000816-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ExampleCodec/listing1.html%3Fid%3DDTS10000816-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ExampleCodec/listing1.html%3Fid%3DDTS10000816-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>