/*	File:		TGraphic.h	Contains:	See TGraphic.cp for description and the list of changes.	Written by: Timothy Carroll		Copyright:	Copyright © 1996-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/2/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				*/#ifndef _TGRAPHIC_#define _TGRAPHIC_#pragma once#include <QDOffscreen.h>#include "Error Macros.h"#if PRAGMA_STRUCT_ALIGN#pragma options align=power#endifenum eDrawFlag{	kDrawGraphic = 0,	kDrawBackground = 1};// We declare the app color table here, must be defined in the app's codeextern CTabHandle gAppColorTable;class TGraphic	{	public:/*************************************************************************************Static Creator and Reference Counting	These are the routines that handle the actual creation of the objects, alongwith reference counting and so on.*************************************************************************************/	static TGraphic 		*NewGraphic (SInt16 resID);	void AddReference (void);	void DisposeReference (void);/*************************************************************************************Locking and Unlocking	You are never required to lock a graphic -- the routines run fine either way. These functions are provided because most of the time, all of the graphics will be allocatedahead of time, and locking them high means more memory for the app, and less handlesto move around.*************************************************************************************/	OSStatus	LockGraphic (void);	OSStatus	UnlockGraphic (void);		/*************************************************************************************Creating and destroying the graphic	CreateGraphic loads the resource and processes it to the internal graphic format.DestroyGraphic disposes of any internal data allocated for a TGraphic.*************************************************************************************/	OSStatus	CreateGraphic (void);	OSStatus	DestroyGraphic (void);/*************************************************************************************File Output	These routines allow convenient writing of a graphic out to a resource fork, in either the compressed format or as a PICT resource.*************************************************************************************/	OSStatus	WriteToGraphicResource (void);	OSStatus	WriteToPICTResource (void);	/*************************************************************************************Accessors FunctionsThese are inlined for speed, most other information about the sprite is private andsubject to change.*************************************************************************************/	SInt16		GetResID(void) {return fResID;}	Rect		GetBounds (void) {return fBounds;}		/*************************************************************************************Core FunctionsHere are the primary functions of TGraphic, methods to draw or hit test!	CopyImage accept a point in the local coordinate system of the destination PixMap.If the "useBackground" flag is set and a background PixMap was specified, it will drawfrom the background to the destination, using the graphic's data only as a mask.This allows a cheap and easy "erase" function.	HitTest accepts a point in coordinates local to the TGraphic's bounds rect, and returnstrue if that point hits a "drawn" portion of the graphic.	Intersect is a static function that accepts two TGraphic objects and the top leftcoordinate for each object.  Both points should be in the same coordinate system. It returns true if the masks intersect at any point.*************************************************************************************/		void			CopyImage (SInt32 top, SInt32 left, Boolean useBackground);	Boolean			HitTest (SInt32 v, SInt32 h);	static Boolean	Intersect (TGraphic *object1, TGraphic *object2,								SInt32 v1, SInt32 h1, SInt32 v2, SInt32 h2);			protected:/*************************************************************************************Internal FunctionsWe have a number of routines that can load from various resource formats, along withthe actual sprite encoder.We also have a number of routines that actually get called to do the blitting.*************************************************************************************/	OSStatus	LoadFromGraphicResource (void);	OSStatus	LoadFromPICTResource (void);	OSStatus	LoadFromICN8Resource (void);	OSStatus	LoadFromCIconResource (void);		OSStatus	EncodeGraphic (PixMapHandle theGraphic, Rect *encodeRect);	void GraphicClipped (SInt32 top, SInt32 left, UInt32 clipLeft, UInt32 clipRight, UInt32 clipTop, UInt32 clipBottom);	void GraphicUnclipped (SInt32 top, SInt32 left);	void BackgroundClipped (SInt32 top, SInt32 left, UInt32 clipLeft, UInt32 clipRight, UInt32 clipTop, UInt32 clipBottom);	void BackgroundUnclipped (SInt32 top, SInt32 left);	// There are mostly useful for dumping to a PICT file, so we don't have clipped	// versions of these, and the functionality isn't exposed to outside clients.		void DrawMaskUnclipped (SInt32 top, SInt32 left);	void HitMaskUnclipped (SInt32 top, SInt32 left);/*************************************************************************************Constructor/DestructorThe constructor and destructor shouldn't be called directly.  These routines arecalled automatically when a new sprite is created by the static routine, and whenall references are released.*************************************************************************************/	TGraphic (SInt16 resID);	~TGraphic(void);/*************************************************************************************Data StructuresI force alignment to PPC, but the alignment would be the same on 68K.	*************************************************************************************/	SInt16			fResID;	UInt16			fReferenceCount;			UInt16			fBitDepth;	UInt16			fFlags;	Rect			fBounds;// This handle holds the data the TGraphic class uses to draw itself	Handle			fImage;	// This handle holds the data the TGraphic class uses for hit testing	Handle			fHitMask;	};#if PRAGMA_STRUCT_ALIGN#pragma options align=reset#endif#endif /* _TGRAPHIC_ */