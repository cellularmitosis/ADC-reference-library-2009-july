<html><head><title>Mac OS X
 Manual Page For Encode(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/Encode" title="Mac OS X
 Manual Page for Encode(3pm)"><a name="//apple_ref/doc/man/3/Encode" title="Mac OS X
 Manual Page for Encode(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/Encode"; name=Encode(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Encode(3pm)                           Perl Programmers Reference Guide                           Encode(3pm)



<b>NAME</b>
       Encode - character encodings

<b>SYNOPSIS</b>
           use Encode;

       <b>Table</b> <b>of</b> <b>Contents</b>

       Encode consists of a collection of modules whose details are too big to fit in one document.  This
       POD itself explains the top-level APIs and general topics at a glance.  For other topics and more
       details, see the PODs below:

         Name                          Description
         --------------------------------------------------------<font color="#ffffff" class="whiteout">Encode::Alias&nbsp;-------------------------------------------------------Encode::Alias</font>
         Encode::Alias         Alias definitions to encodings
         Encode::Encoding      Encode Implementation Base Class
         Encode::Supported     List of Supported Encodings
         Encode::CN            Simplified Chinese Encodings
         Encode::JP            Japanese Encodings
         Encode::KR            Korean Encodings
         Encode::TW            Traditional Chinese Encodings
         --------------------------------------------------------<font color="#ffffff" class="whiteout">DESCRIPTION&nbsp;-------------------------------------------------------DESCRIPTION</font>

<b>DESCRIPTION</b>
       The "Encode" module provides the interfaces between Perl's strings and the rest of the system.  Perl
       strings are sequences of <b>characters</b>.

       The repertoire of characters that Perl can represent is at least that defined by the Unicode Consor-<font color="#ffffff" class="whiteout">tium.&nbsp;Consortium.</font>
       tium. On most platforms the ordinal values of the characters (as returned by "ord(ch)") is the "Uni-<font color="#ffffff" class="whiteout">code&nbsp;"Unicode</font>
       code codepoint" for the character (the exceptions are those platforms where the legacy encoding is
       some variant of EBCDIC rather than a super-set of ASCII - see perlebcdic).

       Traditionally, computer data has been moved around in 8-bit chunks often called "bytes". These chunks
       are also known as "octets" in networking standards. Perl is widely used to manipulate data of many
       types - not only strings of characters representing human or computer languages but also "binary"
       data being the machine's representation of numbers, pixels in an image - or just about anything.

       When Perl is processing "binary data", the programmer wants Perl to process "sequences of bytes".
       This is not a problem for Perl - as a byte has 256 possible values, it easily fits in Perl's much
       larger "logical character".

       <b>TERMINOLOGY</b>


        <u>character</u>: a character in the range 0..(2**32-1) (or more).  (What Perl's strings are made of.)

        <u>byte</u>: a character in the range 0..255 (A special case of a Perl character.)

        <u>octet</u>: 8 bits of data, with ordinal values 0..255 (Term for bytes passed to or from a non-Perl con-<font color="#ffffff" class="whiteout">text,&nbsp;context,</font>
         text, e.g. a disk file.)

<b>PERL</b> <b>ENCODING</b> <b>API</b>
       $octets  = encode(ENCODING, $string [, CHECK])
         Encodes a string from Perl's internal form into <u>ENCODING</u> and returns a sequence of octets.  ENCOD-<font color="#ffffff" class="whiteout">ING&nbsp;ENCODING</font>
         ING can be either a canonical name or an alias.  For encoding names and aliases, see "Defining
         Aliases".  For CHECK, see "Handling Malformed Data".

         For example, to convert a string from Perl's internal format to iso-8859-1 (also known as Latin1),

           $octets = encode("iso-8859-1", $string);

         <b>CAVEAT</b>: When you run "$octets = encode("utf8", $string)", then $octets <b>may</b> <b>not</b> <b>be</b> <b>equal</b> <b>to</b> $string.
         Though they both contain the same data, the utf8 flag for $octets is <b>always</b> off.  When you encode
         anything, utf8 flag of the result is always off, even when it contains completely valid utf8
         string. See "The UTF-8 flag" below.

         If the $string is "undef" then "undef" is returned.

       $string = decode(ENCODING, $octets [, CHECK])
         Decodes a sequence of octets assumed to be in <u>ENCODING</u> into Perl's internal form and returns the
         resulting string.  As in <u>encode()</u>, ENCODING can be either a canonical name or an alias. For encod-<font color="#ffffff" class="whiteout">ing&nbsp;encoding</font>
         ing names and aliases, see "Defining Aliases".  For CHECK, see "Handling Malformed Data".

         For example, to convert ISO-8859-1 data to a string in Perl's internal format:

           $string = decode("iso-8859-1", $octets);

         <b>CAVEAT</b>: When you run "$string = decode("utf8", $octets)", then $string <b>may</b> <b>not</b> <b>be</b> <b>equal</b> <b>to</b> $octets.
         Though they both contain the same data, the utf8 flag for $string is on unless $octets entirely
         consists of ASCII data (or EBCDIC on EBCDIC machines).  See "The UTF-8 flag" below.

         If the $string is "undef" then "undef" is returned.

       [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])
         Converts <b>in-place</b> data between two encodings. The data in $octets must be encoded as octets and not
         as characters in Perl's internal format. For example, to convert ISO-8859-1 data to Microsoft's
         CP1250 encoding:

           from_to($octets, "iso-8859-1", "cp1250");

         and to convert it back:

           from_to($octets, "cp1250", "iso-8859-1");

         Note that because the conversion happens in place, the data to be converted cannot be a string con-<font color="#ffffff" class="whiteout">stant;&nbsp;constant;</font>
         stant; it must be a scalar variable.

         <u>from</u><b>_</b><u>to()</u> returns the length of the converted string in octets on success, <u>undef</u> on error.

         <b>CAVEAT</b>: The following operations look the same but are not quite so;

           from_to($data, "iso-8859-1", "utf8"); #1
           $data = decode("iso-8859-1", $data);  #2

         Both #1 and #2 make $data consist of a completely valid UTF-8 string but only #2 turns utf8 flag
         on.  #1 is equivalent to

           $data = encode("utf8", decode("iso-8859-1", $data));

         See "The UTF-8 flag" below.

       $octets = encode_utf8($string);
         Equivalent to "$octets = encode("utf8", $string);" The characters that comprise $string are encoded
         in Perl's internal format and the result is returned as a sequence of octets. All possible charac-<font color="#ffffff" class="whiteout">ters&nbsp;characters</font>
         ters have a UTF-8 representation so this function cannot fail.

       $string = decode_utf8($octets [, CHECK]);
         equivalent to "$string = decode("utf8", $octets [, CHECK])".  The sequence of octets represented by
         $octets is decoded from UTF-8 into a sequence of logical characters. Not all sequences of octets
         form valid UTF-8 encodings, so it is possible for this call to fail.  For CHECK, see "Handling Mal-<font color="#ffffff" class="whiteout">formed&nbsp;Malformed</font>
         formed Data".

       <b>Listing</b> <b>available</b> <b>encodings</b>

         use Encode;
         @list = Encode-&gt;encodings();

       Returns a list of the canonical names of the available encodings that are loaded.  To get a list of
       all available encodings including the ones that are not loaded yet, say

         @all_encodings = Encode-&gt;encodings(":all");

       Or you can give the name of a specific module.

         @with_jp = Encode-&gt;encodings("Encode::JP");

       When "::" is not in the name, "Encode::" is assumed.

         @ebcdic = Encode-&gt;encodings("EBCDIC");

       To find out in detail which encodings are supported by this package, see Encode::Supported.

       <b>Defining</b> <b>Aliases</b>

       To add a new alias to a given encoding, use:

         use Encode;
         use Encode::Alias;
         define_alias(newName =&gt; ENCODING);

       After that, newName can be used as an alias for ENCODING.  ENCODING may be either the name of an
       encoding or an <u>encoding</u> <u>object</u>

       But before you do so, make sure the alias is nonexistent with "resolve_alias()", which returns the
       canonical name thereof.  i.e.

         Encode::resolve_alias("latin1") eq "iso-8859-1" # true
         Encode::resolve_alias("iso-8859-12")   # false; nonexistent
         Encode::resolve_alias($name) eq $name  # true if $name is canonical

       <u>resolve</u><b>_</b><u>alias()</u> does not need "use Encode::Alias"; it can be exported via "use Encode
       qw(resolve_alias)".

       See Encode::Alias for details.

<b>Encoding</b> <b>via</b> <b>PerlIO</b>
       If your perl supports <u>PerlIO</u> (which is the default), you can use a PerlIO layer to decode and encode
       directly via a filehandle.  The following two examples are totally identical in their functionality.

         # via PerlIO
         open my $in,  "&lt;:encoding(shiftjis)", $infile  or die;
         open my $out, "&gt;:encoding(euc-jp)",   $outfile or die;
         while(&lt;$in&gt;){ print $out $_; }

         # via from_to
         open my $in,  "&lt;", $infile  or die;
         open my $out, "&gt;", $outfile or die;
         while(&lt;$in&gt;){
           from_to($_, "shiftjis", "euc-jp", 1);
           print $out $_;
         }

       Unfortunately, it may be that encodings are PerlIO-savvy.  You can check if your encoding is sup-<font color="#ffffff" class="whiteout">ported&nbsp;supported</font>
       ported by PerlIO by calling the "perlio_ok" method.

         Encode::perlio_ok("hz");             # False
         find_encoding("euc-cn")-&gt;perlio_ok;  # True where PerlIO is available

         use Encode qw(perlio_ok);            # exported upon request
         perlio_ok("euc-jp")

       Fortunately, all encodings that come with Encode core are PerlIO-savvy except for hz and ISO-2022-kr.
       For gory details, see Encode::Encoding and Encode::PerlIO.

<b>Handling</b> <b>Malformed</b> <b>Data</b>
       The optional <u>CHECK</u> argument tells Encode what to do when it encounters malformed data.  Without
       CHECK, Encode::FB_DEFAULT ( == 0 ) is assumed.

       As of version 2.12 Encode supports coderef values for CHECK.  See below.

       <b>NOTE:</b> Not all encoding support this feature
         Some encodings ignore <u>CHECK</u> argument.  For example, Encode::Unicode ignores <u>CHECK</u> and it always
         croaks on error.

       Now here is the list of <u>CHECK</u> values available

       <u>CHECK</u> = Encode::FB_DEFAULT ( == 0)
         If <u>CHECK</u> is 0, (en|de)code will put a <u>substitution</u> <u>character</u> in place of a malformed character.
         When you encode, &lt;subchar&gt; will be used.  When you decode the code point 0xFFFD is used.  If the
         data is supposed to be UTF-8, an optional lexical warning (category utf8) is given.

       <u>CHECK</u> = Encode::FB_CROAK ( == 1)
         If <u>CHECK</u> is 1, methods will die on error immediately with an error message.  Therefore, when <u>CHECK</u>
         is set to 1,  you should trap the error with eval{} unless you really want to let it die.

       <u>CHECK</u> = Encode::FB_QUIET
         If <u>CHECK</u> is set to Encode::FB_QUIET, (en|de)code will immediately return the portion of the data
         that has been processed so far when an error occurs. The data argument will be overwritten with
         everything after that point (that is, the unprocessed part of data).  This is handy when you have
         to call decode repeatedly in the case where your source data may contain partial multi-byte charac-<font color="#ffffff" class="whiteout">ter&nbsp;character</font>
         ter sequences, (i.e. you are reading with a fixed-width buffer). Here is a sample code that does
         exactly this:

           my $buffer = ''; my $string = '';
           while(read $fh, $buffer, 256, length($buffer)){
             $string .= decode($encoding, $buffer, Encode::FB_QUIET);
             # $buffer now contains the unprocessed partial character
           }

       <u>CHECK</u> = Encode::FB_WARN
         This is the same as above, except that it warns on error.  Handy when you are debugging the mode
         above.

       perlqq mode (<u>CHECK</u> = Encode::FB_PERLQQ)
       HTML charref mode (<u>CHECK</u> = Encode::FB_HTMLCREF)
       XML charref mode (<u>CHECK</u> = Encode::FB_XMLCREF)
         For encodings that are implemented by Encode::XS, CHECK == Encode::FB_PERLQQ turns (en|de)code into
         "perlqq" fallback mode.

         When you decode, "\xHH" will be inserted for a malformed character, where <u>HH</u> is the hex representa-<font color="#ffffff" class="whiteout">tion&nbsp;representation</font>
         tion of the octet  that could not be decoded to utf8.  And when you encode, "\x{HHHH}" will be
         inserted, where <u>HHHH</u> is the Unicode ID of the character that cannot be found in the character
         repertoire of the encoding.

         HTML/XML character reference modes are about the same, in place of "\x{HHHH}", HTML uses "&amp;#NNN;"
         where <u>NNN</u> is a decimal number and XML uses "&amp;#xHHHH;" where <u>HHHH</u> is the hexadecimal number.

         In Encode 2.10 or later, "LEAVE_SRC" is also implied.

       The bitmask
         These modes are actually set via a bitmask.  Here is how the FB_XX constants are laid out.  You can
         import the FB_XX constants via "use Encode qw(:fallbacks)"; you can import the generic bitmask con-<font color="#ffffff" class="whiteout">stants&nbsp;constants</font>
         stants via "use Encode qw(:fallback_all)".

                              FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ
          DIE_ON_ERR    0x0001             X
          WARN_ON_ERR   0x0002                               X
          RETURN_ON_ERR 0x0004                      X        X
          LEAVE_SRC     0x0008                                        X
          PERLQQ        0x0100                                        X
          HTMLCREF      0x0200
          XMLCREF       0x0400

       <b>coderef</b> <b>for</b> <b>CHECK</b>

       As of Encode 2.12 CHECK can also be a code reference which takes the ord value of unmapped caharacter
       as an argument and returns a string that represents the fallback character.  For instance,

         $ascii = encode("ascii", $utf8, sub{ sprintf "&lt;U+%04X&gt;", shift });

       Acts like FB_PERLQQ but &lt;U+<u>XXXX&gt;</u> is used instead of \x{<u>XXXX</u>}.

<b>Defining</b> <b>Encodings</b>
       To define a new encoding, use:

           use Encode qw(define_encoding);
           define_encoding($object, 'canonicalName' [, alias...]);

       <u>canonicalName</u> will be associated with <u>$object</u>.  The object should provide the interface described in
       Encode::Encoding.  If more than two arguments are provided then additional arguments are taken as
       aliases for <u>$object</u>.

       See Encode::Encoding for more details.

<b>The</b> <b>UTF-8</b> <b>flag</b>
       Before the introduction of utf8 support in perl, The "eq" operator just compared the strings repre-<font color="#ffffff" class="whiteout">sented&nbsp;represented</font>
       sented by two scalars. Beginning with perl 5.8, "eq" compares two strings with simultaneous consider-<font color="#ffffff" class="whiteout">ation&nbsp;consideration</font>
       ation of <u>the</u> <u>utf8</u> <u>flag</u>. To explain why we made it so, I will quote page 402 of "Programming Perl, 3rd
       ed."

       Goal #1:
         Old byte-oriented programs should not spontaneously break on the old byte-oriented data they used
         to work on.

       Goal #2:
         Old byte-oriented programs should magically start working on the new character-oriented data when
         appropriate.

       Goal #3:
         Programs should run just as fast in the new character-oriented mode as in the old byte-oriented
         mode.

       Goal #4:
         Perl should remain one language, rather than forking into a byte-oriented Perl and a character-ori-<font color="#ffffff" class="whiteout">ented&nbsp;character-oriented</font>
         ented Perl.

       Back when "Programming Perl, 3rd ed." was written, not even Perl 5.6.0 was born and many features
       documented in the book remained unimplemented for a long time.  Perl 5.8 corrected this and the
       introduction of the UTF-8 flag is one of them.  You can think of this perl notion as of a byte-ori-<font color="#ffffff" class="whiteout">ented&nbsp;byte-oriented</font>
       ented mode (utf8 flag off) and a character-oriented mode (utf8 flag on).

       Here is how Encode takes care of the utf8 flag.

        When you encode, the resulting utf8 flag is always off.

        When you decode, the resulting utf8 flag is on unless you can unambiguously represent data.  Here
         is the definition of dis-ambiguity.

         After "$utf8 = decode('foo', $octet);",

           When $octet is...   The utf8 flag in $utf8 is
           ---------------------------------------------<font color="#ffffff" class="whiteout">In&nbsp;--------------------------------------------In</font>
           In ASCII only (or EBCDIC only)            OFF
           In ISO-8859-1                              ON
           In any other Encoding                      ON
           ---------------------------------------------<font color="#ffffff" class="whiteout">As&nbsp;--------------------------------------------As</font>

         As you see, there is one exception, In ASCII.  That way you can assume Goal #1.  And with Encode
         Goal #2 is assumed but you still have to be careful in such cases mentioned in <b>CAVEAT</b> paragraphs.

         This utf8 flag is not visible in perl scripts, exactly for the same reason you cannot (or you <u>don't</u>
         <u>have</u> <u>to</u>) see if a scalar contains a string, integer, or floating point number.   But you can still
         peek and poke these if you will.  See the section below.

       <b>Messing</b> <b>with</b> <b>Perl's</b> <b>Internals</b>

       The following API uses parts of Perl's internals in the current implementation.  As such, they are
       efficient but may change.

       is_utf8(STRING [, CHECK])
         [INTERNAL] Tests whether the UTF-8 flag is turned on in the STRING.  If CHECK is true, also checks
         the data in STRING for being well-formed UTF-8.  Returns true if successful, false otherwise.

         As of perl 5.8.1, utf8 also has <u>utf8::is</u><b>_</b><u>utf8()</u>.

       _utf8_on(STRING)
         [INTERNAL] Turns on the UTF-8 flag in STRING.  The data in STRING is <b>not</b> checked for being well-<font color="#ffffff" class="whiteout">formed&nbsp;wellformed</font>
         formed UTF-8.  Do not use unless you <b>know</b> that the STRING is well-formed UTF-8.  Returns the previ-<font color="#ffffff" class="whiteout">ous&nbsp;previous</font>
         ous state of the UTF-8 flag (so please don't treat the return value as indicating success or fail-<font color="#ffffff" class="whiteout">ure),&nbsp;failure),</font>
         ure), or "undef" if STRING is not a string.

       _utf8_off(STRING)
         [INTERNAL] Turns off the UTF-8 flag in STRING.  Do not use frivolously.  Returns the previous state
         of the UTF-8 flag (so please don't treat the return value as indicating success or failure), or
         "undef" if STRING is not a string.

<b>UTF-8</b> <b>vs.</b> <b>utf8</b>
         ....We now view strings not as sequences of bytes, but as sequences
         of numbers in the range 0 .. 2**32-1 (or in the case of 64-bit
         computers, 0 .. 2**64-1) -- Programming Perl, 3rd ed.

       That has been the perl's notion of UTF-8 but official UTF-8 is more strict; Its ranges is much nar-<font color="#ffffff" class="whiteout">rower&nbsp;narrower</font>
       rower (0 .. 10FFFF), some sequences are not allowed (i.e. Those used in the surrogate pair, 0xFFFE,
       et al).

       Now that is overruled by Larry Wall himself.

         From: Larry Wall &lt;larry@wall.org&gt;
         Date: December 04, 2004 11:51:58 JST
         To: perl-unicode@perl.org
         Subject: Re: Make Encode.pm support the real UTF-8
         Message-Id: &lt;20041204025158.GA28754@wall.org&gt;

         On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
         : I've no problem with 'utf8' being perl's unrestricted uft8 encoding,
         : but "UTF-8" is the name of the standard and should give the
         : corresponding behaviour.

         For what it's worth, that's how I've always kept them straight in my
         head.

         Also for what it's worth, Perl 6 will mostly default to strict but
         make it easy to switch back to lax.

         Larry

       Do you copy?  As of Perl 5.8.7, <b>UTF-8</b> means strict, official UTF-8 while <b>utf8</b> means liberal, lax,
       version thereof.  And Encode version 2.10 or later thus groks the difference between "UTF-8" and
       C"utf8".

         encode("utf8",  "\x{FFFF_FFFF}", 1); # okay
         encode("UTF-8", "\x{FFFF_FFFF}", 1); # croaks

       "UTF-8" in Encode is actually a canonical name for "utf-8-strict".  Yes, the hyphen between "UTF" and
       "8" is important.  Without it Encode goes "liberal"

         find_encoding("UTF-8")-&gt;name # is 'utf-8-strict'
         find_encoding("utf-8")-&gt;name # ditto. names are case insensitive
         find_encoding("utf8")-&gt;name  # ditto. "_" are treated as "-"
         find_encoding("UTF8")-&gt;name  # is 'utf8'.

<b>SEE</b> <b>ALSO</b>
       Encode::Encoding, Encode::Supported, Encode::PerlIO, encoding, perlebcdic, "open" in perlfunc, perlu-<font color="#ffffff" class="whiteout">nicode,&nbsp;perlunicode,</font>
       nicode, utf8, the Perl Unicode Mailing List &lt;perl-unicode@perl.org&gt;

<b>MAINTAINER</b>
       This project was originated by Nick Ing-Simmons and later maintained by Dan Kogai &lt;danko-
       gai@dan.co.jp&gt;.  See AUTHORS for a full list of people involved.  For any questions, use &lt;perl-uni-
       code@perl.org&gt; so we can all share.



perl v5.8.8                                      2001-09-21                                      Encode(3pm)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Encode.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Encode.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Encode.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
