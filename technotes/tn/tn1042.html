<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1042: Strategies for Dealing with Low-Memory Conditions</title>    <meta name="keywords" content="Mac OS 8 low memory conditions loadseg growzone procedures malloc">    <meta name="Description" content="Technical Note TN1042: This Technical Note describes variousstrategies your application might take in dealing with low-memoryconditions. It is also useful as a memory-management primerfor those developers starting out on the Macintosh, or portingapplications from other platforms. Topics include: usinga purgeable cushion, installing a grow zone procedure, checkingfor memory allocations, dealing with 68k Code Segments, andusing temporary memory."><meta name="categories" content="Memory"><meta name="week-posted" content="Apr 29, 1996 - May 3, 1996"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002884" title="Strategies for Dealing with Low-Memory Conditions"></a><A NAME="top"></A> <!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/HardwareDrivers/idxPerformance-date.html" target="_blank">Hardware & Drivers > Performance</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1042</div>
<div id="pageheadsub">Strategies for Dealing with Low-Memory Conditions</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td></tr><tr bgcolor="#e6e6e6">    <td background="images/tnmenubody.gif" width=300 align=left><span id="menutitle">    CONTENTS     <BR>    <BR></span>    </td></tr><tr bgcolor="#e6e6e6">    <td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><P id = "menutext"><A HREF = "#RTFToC1">Maintaining a Memory Reserve</a><br><br><A HREF = "#RTFToC2">Checking for Memory Allocations</a><br><br><A HREF = "#RTFToC3">Informing the User of Low-Memory Conditions</a><br><br><A HREF = "#RTFToC4">Using Temporary Memory</a><br><br><A HREF = "#RTFToC5">Dealing With 68K Code Segments</a><br><br><A HREF = "#RTFToC6">Special Problems with malloc and new</a><br><br><A HREF = "#Summary">Summary</a><br><br><A HREF = "#References">References</a><br><br><A HREF="#Downloads">Downloadables</A></P>   <!-- end_toc -->  </td></tr><tr>    <td width=300 align=left scope="row"><img src="images/tnmenubottom.gif" alt="" width=300 height=16>    </td></tr>    </table></td><td width=300 valign="top" align=left><!-- begin_intro_text --> <P id = "introtext">One of the constants in writing software for the Macintosh is that sooner or later your application will run out of available memory. While applicationsrunning on other operating systems may use memory allocated from a global pool(backed by virtual memory), and can thus draw on an apparently limitlesssupply, each Mac application must work to avoid exhausting the fixed amount ofmemory the Process Manager gave it. Since Toolbox calls share the same heapwith application calls, and parts of the Toolbox are notoriously poor atdealing with failed allocations, it's essential that you put into place arobust strategy to manage the problem. Applications that fail under low-memoryconditions are not very friendly.</P><P id = "introtext">This Technote describes various strategies your application might take indealing with low-memory conditions. It is also useful as a memory-managementprimer for those developers starting out on the Macintosh, or portingapplications from other platforms.</p><P id = "introtext">This Technote expands on the chapter "Introduction to Memory Management" in<i>Inside Macintosh: Memory</i>. You should read at least pages 1-37 through1-49 as a background to this Technote. Also, information on 68K segmentationassumes that you've read chapter 7 of <i>Inside Macintosh: Processes.</i></p><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Mar 1 1996]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR> <!-- begin_content --><a name = "RTFToC1"></a><h2>Maintaining a Memory Reserve</h2><P>The primary strategy for dealing with low-memory conditions is to maintain amemory reserve. Out of this reserve you can supply sufficient memory for smallto moderate-sized allocations, as well as provide information to the rest ofyour application. By checking your reserve, you can determine the status ofyour memory supply. As the reserve supply dwindles, your app can gracefullyrestrict what the user can do by limiting her choices, in addition to informingthe user that she's running out of memory.</p><h3>Using A Purgeable Cushion </h3><P>The advantage of using a purgeable cushion technique lies in its simplicity: there's little code to write. The disadvantage is that it can be difficult toensure total safety when large portions of your application's memory isallocated indirectly by the Toolbox.</p><P>To create the memory reserve, allocate a handle early in your app's startupcode. This handle should be in the range of 32K to 64K bytes in size, andshould be marked as purgeable. When the Memory Manager later needs to createmore free space, it will automatically purge any purgeable handles orresources.</p><P>During the main event loop, the application can check to see if the handle hasbeen purged (if its master pointer is zero, it's been purged), and attempt toreallocate it with ReallocateHandle back to the original size. If this fails,then there is less than that amount of contiguous memory remaining, and theapplication can set a global flag to indicate that there is not enough memoryto continue running as usual. It could then respond by warning the user toclose documents, disabling menus that lead to memory-hungry functionality or ingeneral keeping the user from pushing the limits of memory. When the handle canbe reallocated again, the application can clear the global flag and reverse thesteps it took earlier.</p><P>A useful technique is to only clear the global flag if you can recover theoriginal memory plus an extra amount, as illustrated in the following codesnippet: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>extern Handle gReserveHandle;if (*gReserveHandle == nil)    {    ReallocateHandle(gReserveHandle, kReserveSize + kSlopFactor);    if (MemError()!= noErr)        {        SetHandleSize(gReserveHandle, kReserveSize);        HPurge(gReserveHandle);        SetReserveWasRecoveredFlag();        }    }</pre>	</TD></TR></TABLE></CENTER><P>If the application is running right at the edge of the low-memory condition,using a "slop factor" can keep the warnings to the user from reappearing toofrequently as the application "teeters on the edge."</p><P>How large to make the handle depends on your application's needs. If largeToolbox data structures, such as GWorlds or pictures, can routinely consume allavailable memory, then a size larger than 64K may be necessary. The only way toknow is to experiment with different sizes and test your application's featuresnear the limits of memory. If it dies, increase the reserve size; if itsurvives gracefully, you may try to lower the size.</p><h3>Installing A Grow Zone Procedure</h3><P>A slightly more complicated technique is to install a grow zone procedure using<code>SetGrowZone</code>. This procedure is called by the Memory Manager after it hasexhausted all other strategies for finding free space, including purgingpurgeable handles and resources and compacting the heap. The grow zoneprocedure is called as the last resort. Often the grow zone procedure will haveno idea whose allocation triggered the problem: it could be application codewhich will handle out-of-memory errors gracefully or Toolbox routines that failto do any checking at all.</p><h4>Grow Zone Proc Strategies</h4><P>The grow zone procedure can attempt to provide additional memory by simplyfreeing or marking purgeable a single "cushion" memory block and allowing themain event loop to attempt to reallocate it, as previously described. The growzone proc could also shrink the cushion handle with <code>SetHandleSize</code> and attemptto grow it in the main event loop.</p><P>The grow zone procedure can also undertake more complex and intelligentstrategies to make memory available than the simple cushion techniques. Theapplication may use buffers that can be shrunk or eliminated, or free up datastructures stored in handles or pointers, or even mark additional resources aspurgeable. It can also reduce its memory requirements in a gradual manner.Because the application may have knowledge of what blocks of memory andresources represent, it can free, shrink, or mark purgeable buffers to makememory available that cannot be made available automatically by the MemoryManager.</p><P>If the grow zone procedure returns with an indication that some memory wasfreed, the Memory Manager will again attempt another cycle of purging andcompaction. It will continue calling the Grow Zone proc and purging andcompacting until either memory becomes available or the Grow Zone proc returnszero. In the latter case, the Memory Manager will give up and return<code>memFullErr</code> to the code which attempted the allocation.</p><P>During the main event loop, attempts should be made to recover the memory. Asthe reserve is used and then recovered, a global variable or state could keeptrack of what level of reserves remain, and make this information available tothe rest of the application.</p><h4>A List of Safe Memory Manager Calls</h4><P>The following are the only Memory Manager calls that you can safely call insidethe grow zone procedure: </p><ul><li>SetHandleSize, but only to a smaller size</li><li>SetPtrSize, but only to a smaller size</li><li>DisposeHandle</li><li>DisposePtr</li><li>EmptyHandle</li><li>HPurge or the equivalent HSetState</li><li>HUnlock or the equivalent HSetState</li></ul><P>In 68K applications, you can also call <code>UnloadSeg</code> on segments not in the currentcall chain. See also the section "Dealing With 68K Segments" later in thisTechnote.</p><h4>GZSaveHnd</h4><P>You need to always call <code>GZSaveHnd</code>, which returns the handle on which the MemoryManager is currently operating, and not make any of the above calls with thishandle.</p><h4>What A Grow Zone Procedure Should Not Do</h4><P>Basically, you can't make any calls that may directly or indirectly move memoryor trigger additional requests for more free memory. These may result inrecursive calls to the Memory Manager and to the grow zone procedure. TheMemory Manager is <i>not</i>  reentrant. Forcing it to rearrange the heap whileit is already rearranging the heap is likely to cause unpredictable results,all of them unpleasant.</p><h4>Examples of Things to Avoid in Grow Zone Procedures</h4><P>Bearing in mind the caveat mentioned in the previous paragraph, here are someexamples of things to avoid doing in grow zone procedures. Many of theseproblems originally came from developer questions over the years.</p><h4>Don't allocate memory </h4><P>This seems rather obvious but can be triggered indirectly by a varietyof things. Most of the following problems are ultimately caused by allocatingmemory or causing the heap to be rearranged. You can never be completely surethat sufficient memory is available for even a small block. It's better to notrisk confusing the Memory Manager.</p><h4>Don't do synchronous file I/O </h4><P>File Manager calls are only guaranteed to not move memory when calledasynchronously. Unfortunately, doing asynchronous file I/O won't help theimmediate need for releasing memory, so it isn't possible to make more roomavailable by saving data to disk.</p><h4>Don't update resources </h4><P>Calls to <code>ChangedResource</code> and many other Resource Manager calls should beavoided because the Resource Manager uses the Memory Manager without takinginto account the possibility that it might be called from the grow zone.</p><h4>Don't put up dialogs</h4><P>If you need to inform the user that memory is low, you should set aglobal flag and check it in your main event loop. Calling any user interfacecode during <code>GrowZone</code> is likely to allocate memory. Allowing the user to savedocuments from inside the grow zone procedure has been attempted, but withoutmuch success. Don't even think about it.</p><h4>On 68K Macintoshes, don't call any routine that may force a segment to beloaded</h4><P>This one can occur in very subtle ways. For example, in C++ you maydecide to delete some objects that contain member variables that are MemoryManager heap handles or pointers, and thus free up some space. You call<i>delete</i> on the object. Unfortunately the destructor for the object'sclass, or a destructor for a superclass, resides in a code segment that iscurrently not in memory. Calling this code to free up some space actuallyconsumes more space, leading to recursive calls to your grow zone procedure andprobable crashes. Make sure everything that can be called from your grow zoneprocedure is kept in resident segments.</p><P><A HREF="#top">Back to top</A></P> <a name = "RTFToC2"></a><h2>Checking for Memory Allocations</h2><P>Even with a low-memory strategy in place, it is still very important to alwaysdetermine if memory allocations have succeeded. However, careful use ofpurgeable cushions or grow zone procedures can greatly simplify the handling offailed allocations. If you have a global flag or function which returns thecurrent state of the cushion or memory reserve, you can quickly check to see ifyou have sufficient memory to perform a task or operation in your application.If the reserves are low, you can abort the task at the start. If the reservesare intact, then there is at least that much memory available, and you canproceed with confidence.</p><P>You can avoid checking some allocations for failure, as long as you can becertain your memory state indicates the reserve or cushion will supply whatevermemory is needed. You should avoid making potentially time-consuming calls suchas <code>PurgeSpace</code> to determine if enough memory is available. This type of callcould be saved until you need to check a memory requirement larger than couldbe supplied by the reserve or cushion.</p><P><A HREF="#top">Back to top</A></P> <a name = "RTFToC3"></a><h2>Informing the User of Low-Memory Conditions</h2><P>Letting the user know that memory is running low is a delicate art. If theapplication is running with very little memory, it may be possible to get intoa state where the "out of memory" alert arrives continuously, which is highlyannoying.</p><h3>Developing a Two-Stage Plan</h3><P>A good thing to do is to wait a fixed amount of time between warnings in orderto allow the user time to quit, close documents, or perform other actions. Itis also useful to have a two-stage plan: </p><ol><li>A warning that memory is becoming low (which could be shown when the memoryreserve is shrunk, then reallocated)</li><li>A more serious indication that there is no memory remaining (when thememory reserve cannot be recovered)</li></ol><P>At the second stage, most program functions should be made unavailable, exceptfor those involved in closing documents, saving, etc. It's always better tokeep the user from reaching the absolute limit than to sadly inform her that"the application is out of memory, and will have to quit now," or even greether with a rude bomb alert.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>Since memory alerts appear when there isn't very much memory left to work with,the resources and code needed to display them should be resident in memory.Many applications collect alert strings into a single STR# resource. If the Outof Memory message is in such a large resource, it may not be possible to loadthe resource to extract the individual string. It's better to keep these alertsresident in memory as much as possible with the string as a static item in thealert.</P></TD></TR></TABLE></CENTER><BR><h3>Guaranteeing the User Can Save Documents</h3><P>You always want to guarantee that the user can save documents when theapplication is running with low memory. This seems fairly obvious, but savingdocuments can use varying amounts of memory to convert in-memory data to a fileformat, or save resources, such as edition records or preview images. It may benecessary to keep a separate reserve of memory strictly for saving documents.</p><P>You may also want to inform the user when a low memory crisis has been averted,i.e., now the user can relax because she's closed the necessary documents.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Applications that show memory availability in their About box should ensurethat opening the About box when memory is very low does not exhaust what littlememory remains. </P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></P> <a name = "RTFToC4"></a><h2>Using Temporary Memory</h2><P>Temporary memory allocations can assist your application if it is running lowon memory. If the app detects that memory is low, it can check to see iftemporary memory is available, and switch some allocations to usingTempNewHandle. However, it should be stressed that this is only useful foritems of a temporary nature, not data that will exist throughout the lifetimeof the application.</p><P>When you allocate memory in the temporary heap (actually the Process Managerheap), you may make it difficult for the user to launch additionalapplications, since the applications will be launched into this heap. Yourapplication also can't count on having any temporary memory available, soalternative strategies must always be designed for dealing with its absence.</p><P><A HREF="#top">Back to top</A></P> <a name = "RTFToC5"></a><h2>Dealing With 68K Code Segments</h2><P>Applications that continue to support the Motorola 68000 family have theadditional burden of managing code segments. If the Segment Loader can't load asegment (usually due to insufficient memory), you'll get System Error #15.Another problem you may have is limiting the amount of memory used for codesegments to the minimum amount necessary at any one time.</p><P>Here are a few good strategies for dealing with 68K code segments.</p><h3>A Few Good Strategies</h3><P>All strategies begin by dividing code into "resident" and "non-resident"segments. Resident segments contain the main event loop, the grow zoneprocedure, any interrupt time code, and any other code frequently referenced.The remaining segments should be based on an analysis of which sections of codeget called together.</p><P>The goal is to minimize the number of segments (and memory) needed for eachoperation or feature in the application. To accomplish this, you need tounderstand which parts of your app get called for each operation. A utilityprogram such as Metrowerks' ZoneRanger can let you watch where the memorysegments reside as your application executes.</p><h4>Use a Single Segment</h4><P>The simplest strategy is to build your application with an option like MPW'smodel far and use a single segment. This way everything is in memory, and thereis no code to write. If you can afford the memory footprint, it makes no senseto complicate memory management with segmentation. (In single-segment CFMapplications, having all the code loaded all the time is the only option youget anyway, although virtual memory can help.)</p><P>This may be ideal if your application is small, or memory requirements are notan issue -- e.g., for some vertical applications. Also, there's another importantissue with regard to single-segment applications. If the application is going tobe used on a PowerBook computer, then having a single segment is very desirable --multiple segments will keep the hard disk spinning and decrease battery life.</p><h4>Unload Segments in the Event Loop</h4><P>The next simplest strategy is to call <code>UnloadSeg</code> with a routine from eachnon-resident segment each time through the event loop (after the event has beenhandled, or right before <code>WaitNextEvent</code>). If your application uses little memorybeyond what is needed by the code, and especially if it makes only smallpermanent allocations from one call to <code>WaitNextEvent</code> to the next, then this maybe sufficient by itself. Assuming that the division of code into segments waswell done, the only problem is to determine a routine to use in callingUnloadSeg for each segment. Here are two examples: </p><ol><li>Create a special routine in each segment with the name of the segment, anduse that routine address in UnloadSeg. The segment contents can then be shiftedaround, without the need to search for a new routine to use, or worry if you'vemissed something.</li><li>Get the address directly by scanning the jump table for the first routinein each segment. This is highly dependent on the jump table format produced byyour development environment. See the MacApp source file "USegments.cp" for anexample.</li></ol><h4>Unload Segments at Any Time</h4><P>At any point during the application's execution, you could conceivably unloadany code segments not currently in the call chain.</p><P>The way to determine this at runtime is to scan the stack for any addressescontained within loaded segments. The steps to take each time are: </p><ol><li>Construct a table with entries for each segment, containing the currentmemory location and size for each segment in memory, and a 'keep' flag. Markall resident segments' flag with true; mark all others as false.</li><li>Starting at the current value of register A7, scan to the address returnedby LMGetCurStackBase, skipping two bytes at a time. Consider each value as apointer. If this value is contained within the application heap zone, check tosee if it is contained within a segment (using the table you constructed inStep #1). If it is, set the keep flag to true for that segment. Here you arebasically looking for return addresses put on the stack during subroutinecalls, which would indicate code in the call chain.</li><li>(using the technique of your choice to obtain an address from the segment).</li></ol><P>A somewhat complex example of this can also be found in the MacApp source file"USegments.cp".</p><h4>Patch LoadSeg</h4><P>Another alternative solution is to patch <code>LoadSeg</code>. The patch will check to seeif sufficient memory exists to load the segment from disk (if it has beenpurged). (One way to do this is to simply load the segment resource with a callto <code>GetResource</code>.) If the patch finds room, it then calls the real <code>LoadSeg</code>. Ifthere isn't enough memory, the patch tries to make room available by performingthe actions of a grow zone procedure such as releasing buffers, shrinkingreserves, or unloading code segments not currently in use. Then the patch goesahead and calls the real <code>LoadSeg</code>. This way a segment load will always succeed(provided the underlying reserve memory and segmentation scheme is sound).</p><P>For cases in which a segment cannot be loaded, you might want to throw a (C++)exception.</p><P><A HREF="#top">Back to top</A></P> <a name = "RTFToC6"></a><h2>Special Problems with malloc and new</h2><P>Applications written in C++, and applications using the standard C allocators(particularly those ported from other platforms) have special problems inmixing their memory allocations with the Memory Manager.</p><P>All C/C++ development environments provide versions of malloc and new whichsub-allocate out of Memory Manager blocks created with <code>NewPtr</code>. These blocks arenon-relocatable, and thus can severely fragment the heap, especially whenmemory is becoming scarce.</p><P>An additional problem is that some of these implementations of new and mallocfail to release these <code>NewPtr</code> blocks when they no longer contain anysub-allocated information. As these blocks begin to fill up the heap, there isless and less space available for Toolbox items such as windows, menus, orresources. It is important to limit the growth of these blocks to keepsufficient room available for Memory Manager allocations.</p><P>Some implementations of malloc and new allow you some control over theirbehavior; check your compiler's documentation for details. There are alsocommercially available alternative allocators, such as Smartheap, which may beof some help in dealing with this problem. Another possible solution is tocreate alternative heap zones within the application zone and keep allnon-Memory Manager allocations within them.</p><P><A HREF="#top">Back to top</A></P> <a name = "Summary"></a><h2>Summary</h2><p>Dealing with low-memory conditions is necessary for successful Macintoshapplication development. This Note outlines a number of strategies that you canfollow in order to handle low-memory conditions. Maintaining a memory reserve,for example, is essential to keep your application from dying when it runs outof memory. Other strategies, such managing 68K code segments, or properlychecking for failed memory allocations, are also important in building qualityapplications for the Macintosh. Failing to devise a proper memory strategy mayresult in a product that is badly behaved and frustrating to your customers.</p><P><A HREF="#top">Back to top</A></P> <a name="References"></a><h2>References</h2><p><i><a href="../../documentation/mac/Memory/Memory-2.html">Inside Macintosh: Memory</a></i></p><p><i><a href="../../documentation/mac/Processes/Processes-2.html">Inside Macintosh: Processes</a></i></p><p>MacApp 3.3 on ETO #19</p><P><A HREF="#top">Back to top</A></P>          <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (64K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1042.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1042.html%3Fid%3DDTS10002884-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1042.html%3Fid%3DDTS10002884-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1042.html%3Fid%3DDTS10002884-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>