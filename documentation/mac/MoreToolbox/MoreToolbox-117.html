<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Putting Data in the Scrap (IM: MTb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING117></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MoreToolbox-116.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-118.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MoreToolbox-2.html"><B>More Macintosh Toolbox</B></A> / <BR><DD><A HREF="MoreToolbox-109.html"><B>Chapter 2 - Scrap Manager</B></A> / <A HREF="MoreToolbox-115.html"><B>Using the Scrap Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING117-0></A>
<H2>Putting Data in the Scrap</H2>
 Your application should write data to the scrap (or to its own private scrap) whenever the user chooses the Cut or Copy command and the document the user is working with contains a selection. In addition, if your application uses a private scrap, your application must copy the contents of its private scrap to the scrap upon receiving a suspend event. The next sections explain how to perform these tasks.<P>
<A NAME=HEADING117-2></A>
<H3>Handling the Cut Command<A NAME=MARKER-9-99></A></H3>
 When the user chooses the Cut command and the document the user is working with contains a selection, your application should remove the data from the selection and save the data (either in the scrap or in your application's private scrap). <A NAME=MARKER-2-106></A><A NAME=MARKER-2-183></A><P>
 The SurfWriter application doesn't use a private scrap; whenever the user performs a cut operation, SurfWriter writes the current selection to the scrap. The SurfWriter application does define its own private scrap format type and writes this format to the scrap, along with one of the standard scrap formats. <A HREF=#MARKER-9-70>Listing 2-1</A> shows SurfWriter's routine for handling the Cut command (it also uses this routine for the Copy command).<P>
<B>Listing 2-1  <A NAME=MARKER-9-70></A>Writing data to the scrap</B><P>
<PRE>
PROCEDURE DoCutOrCopyCmd (cut: Boolean);
VAR
   window:              WindowPtr;
   windowType:          Integer;
   isText:              Boolean;
   ptrToScrapData:      Ptr;
   length, myLongErr:   LongInt;
BEGIN
   window := FrontWindow;
   windowType := MyGetWindowType(window);
   IF windowType = kMyDocWindow THEN
   BEGIN
      ptrToScrapData := NewPtr(kDefaultSize);
      isText := MyIsSelectionText;
      IF isText THEN {selection contains text}
      BEGIN
         MyGetSelection('SURF', ptrToScrapData, length);
         myLongErr := ZeroScrap;
         myLongErr := PutScrap(length, 'SURF', ptrToScrapData);
         IF myLongErr &lt;&gt; noErr THEN DoError(myLongErr);
         MyGetSelection('TEXT', ptrToScrapData, length);
         myLongErr := PutScrap(length, 'TEXT', ptrToScrapData);
         IF myLongErr &lt;&gt; noErr THEN DoError(myLongErr);
      END
      ELSE           {selection contains graphics}
      BEGIN
         MyGetSelection('PICT', ptrToScrapData, length);
         myLongErr := ZeroScrap;
         myLongErr := PutScrap(length, 'PICT', ptrToScrapData);
         IF myLongErr &lt;&gt; noErr THEN DoError(myLongErr);
      END;
      DisposePtr(ptrToScrapData);
      IF cut THEN
         MyDeleteSelection;
   END
   ELSE 
   IF windowType &lt;&gt; kNIL THEN
   BEGIN       {window is a dialog box}
      IF cut THEN
         DialogCut(window) 
      ELSE
         DialogCopy(window);
   END;
END;
</PRE>
 The <CODE>DoCutOrCopyCmd</CODE> procedure first determines the type of window that is frontmost. If the frontmost window is a document window, <CODE>DoCutOrCopyCmd</CODE> uses another application-defined routine, <CODE>MyIsSelectionText</CODE>, to determine whether the current selection contains text or graphics. If the selection contains only text, SurfWriter writes the data to the scrap using two formats: its own private format (<CODE>'SURF'</CODE>) and the standard format <CODE>'TEXT'</CODE>. The <CODE>DoCutOrCopyCmd</CODE> procedure uses another application-defined routine, <CODE>MyGetSelection</CODE>, to return the current selection in a particular format. <CODE>DoCutOrCopyCmd</CODE> then calls the <CODE>ZeroScrap</CODE> function to clear the contents of the scrap. After calling <CODE>ZeroScrap</CODE>, <CODE>DoCutOrCopyCmd</CODE> calls <CODE>PutScrap</CODE>, specifying the length of the data, a pointer to the data, and identifying the scrap format type as <CODE>'SURF'</CODE>. <CODE>DoCutOrCopyCmd</CODE> then uses the <CODE>MyGetSelection</CODE> routine again, this time to return the current selection in the <CODE>'TEXT'</CODE> format type. <CODE>DoCutOrCopyCmd</CODE> calls <CODE>PutScrap</CODE> to write the data to the scrap, specifying a pointer to the data and identifying the scrap format type as <CODE>'TEXT'</CODE>.<P>
 If the selection contains a picture, <CODE>DoCutOrCopyCmd</CODE> uses the <CODE>MyGetSelection</CODE> routine to return the current selection using the <CODE>'PICT'</CODE> format type. After calling <CODE>ZeroScrap</CODE>, <CODE>DoCutOrCopyCmd</CODE> calls <CODE>PutScrap</CODE> to write the data to the scrap, specifying a pointer to the data and identifying the scrap format type as <CODE>'PICT'</CODE>.<P>
 Finally, if <CODE>DoCutOrCopyCmd</CODE> was called as a result of the user performing a cut operation, <CODE>DoCutOrCopyCmd</CODE> deletes the selection from the current document.<P>
 If the frontmost window is a dialog box, <CODE>DoCutOrCopyCmd</CODE> uses the Dialog Manager's <CODE>DialogCut</CODE> (or <CODE>DialogCopy</CODE>) procedure to write the selected data to the scrap.<P>
 Note that you should always call <CODE>ZeroScrap</CODE> before writing data to the scrap. If you write multiple formats to the scrap, call <CODE>ZeroScrap</CODE> once before you write the first format to the scrap. <A NAME=MARKER-2-284></A><P>
 You should always write data to the scrap in your application's preferred order <BR>of formats. For example, SurfWriter's preferred format for text data is its own private format (<CODE>'SURF'</CODE>), so it writes that format first and then writes the standard format <CODE>'TEXT'</CODE>.<P>
 If your application uses TextEdit in its document windows, then use the TextEdit routine <CODE>TECut</CODE> (or <CODE>TECopy</CODE>) instead of <CODE>ZeroScrap</CODE> and <CODE>PutScrap</CODE>. See <A HREF=MoreToolbox-120.html#MARKER-9-126>Listing 2-8 on page 2-29</A> for an application-defined routine that uses TextEdit routines to help handle the Cut and Copy commands.<P>
 If your application uses a private scrap, then copy the selected data to your private scrap rather than to the scrap. For example, the SurfPaint application uses a private scrap. <A HREF=#MARKER-9-74>Listing 2-2</A> shows SurfPaint's application-defined routine that handles the Cut command by writing the selected data to its private scrap.<A NAME=MARKER-9-111></A><P>
<B>Listing 2-2  <A NAME=MARKER-9-74></A>Writing data to a private scrap</B><P>
<PRE>
PROCEDURE DoCutOrCopyCmd (cut: Boolean);
VAR
   window:           WindowPtr;
   windowType:       Integer;
BEGIN
   window := FrontWindow;
   windowType := MyGetWindowType(window);
   IF windowType = kMyDocWindow THEN
   BEGIN
      MyWriteDataToPrivateScrap;
      {reset gScrapNewData to indicate that this app's private }
      { scrap now contains the most recent data}
      IF gScrapNewData THEN
         gScrapNewData := FALSE;
      IF cut THEN
         MyDeleteSelection;
   END
   ELSE 
   IF windowType &lt;&gt; kNil THEN
   BEGIN          {window is a dialog window}
      IF cut THEN
         DialogCut(window) 
      ELSE
         DialogCopy(window);
   END;
END;
</PRE>
 The application-defined <CODE>DoCutOrCopyCmd</CODE> procedure shown in <A HREF=#MARKER-9-74>Listing 2-2</A> calls another application-defined procedure, <CODE>MyWriteDataToPrivateScrap</CODE>, to write the data in the current selection to the application's private scrap. SurfPaint uses the application-defined global variable <CODE>gScrapNewData</CODE> to indicate when data should be read from the scrap instead of its own private scrap as a result of the user choosing the Paste command. Upon receiving a resume event, if the contents of the scrap have changed, SurfPaint sets the <CODE>gScrapNewData</CODE> global variable to <CODE>TRUE</CODE>. If the user chooses Paste and <CODE>gScrapNewData</CODE> is <CODE>TRUE</CODE>, SurfPaint reads the scrap to get the data to paste; otherwise SurfPaint reads its own private scrap to get the data to paste.<P>
 If the user chooses Cut or Copy before the next Paste command, SurfPaint writes the newly selected data to its private scrap, eliminating the need to read the previous contents of the scrap, and thus the <CODE>DoCutOrCopyCmd</CODE> procedure resets the <CODE>gScrapNewData</CODE> global variable to <CODE>FALSE</CODE>.<A NAME=MARKER-2-378></A><A NAME=MARKER-2-101></A><A NAME=MARKER-2-40></A><P>
<A NAME=HEADING117-19></A>
<H3>Handling the Copy Command</H3>
 When the user chooses the Copy command and the document the user is working with contains a selection, your application should copy the selected data (without deleting it) and save the copied data (either in the scrap or in your application's private scrap). See <A HREF=#MARKER-9-70>Listing 2-1 on page 2-16</A>, <A HREF=#MARKER-9-74>Listing 2-2 on page 2-18</A>, and <A HREF=MoreToolbox-120.html#MARKER-9-126>Listing 2-8 on page 2-29</A> for application-defined routines that handle the Copy command.<A NAME=MARKER-2-265></A><A NAME=MARKER-9-278></A><P>
<A NAME=HEADING117-21></A>
<H3>Handling Suspend Events<A NAME=MARKER-9-176></A><A NAME=MARKER-2-371></A></H3>
 As previously described, if your application uses a private scrap, your application must copy the contents of its private scrap to the scrap upon receiving a suspend event. In addition, if your application supports the Show Clipboard command, it should hide the Clipboard window if it's currently showing (because the contents of the scrap may change while your application yields time to another application).<P>
 <A HREF=#MARKER-9-84>Listing 2-3</A> shows SurfPaint's routine that responds to suspend events (and resume events).<A NAME=MARKER-2-100></A><P>
<B>Listing 2-3  <A NAME=MARKER-9-84></A>Copying data from the scrap in response to suspend events<A NAME=MARKER-9-164></A></B><P>
<PRE>
PROCEDURE DoSuspendResumeEvent (event: EventRecord);
VAR
   currentFrontWindow: WindowPtr;
BEGIN                         
   currentFrontWindow := FrontWindow;
   IF (BAnd(event.message, resumeFlag) &lt;&gt; 0) THEN 
   BEGIN                      {it's a resume event; }
   END                        { handle as shown in Listing 2-6}
   ELSE
   BEGIN                      {it's a suspend event}
                              {copy private scrap to the scrap}
      MyConvertScrap(kPrivateToClipboard);
      gInBackground := TRUE;
                              {deactivate front window}
      DoActivate(currentFrontWindow, NOT gInBackground, event);
      MyHideClipboardWindow;  {hide Clipboard window if showing}
      MyHideFloatingWindows;  {hide any floating windows}
   END;
END;           
</PRE>
 <A HREF=#MARKER-9-84>Listing 2-3</A> shows a procedure that responds to suspend and resume events. The <CODE>DoSuspendResumeEvent</CODE> procedure first gets a pointer to the front window using the Window Manager function <CODE>FrontWindow</CODE>. It then examines bit 0 of the <CODE>message</CODE> field of the event record to determine whether the event is a suspend or resume event. See <A HREF=MoreToolbox-118.html#MARKER-9-109>Listing 2-6 on page 2-25</A> for details on handling resume events.<P>
 For suspend events, the <CODE>DoSuspendResumeEvent</CODE> procedure calls the application-defined <CODE>MyConvertScrap</CODE> procedure to copy the contents of its private scrap to the scrap. (See <A HREF=MoreToolbox-119.html#MARKER-9-116>Listing 2-7 on page 2-27</A> for the <CODE>MyConvertScrap</CODE> procedure.) It then sets the private global flag <CODE>gInBackground</CODE> to <CODE>TRUE</CODE> to indicate that the application is in the background. It calls another application-defined routine to deactivate the application's front window. It also calls the application-defined routine <CODE>MyHideClipboardWindow</CODE> to hide the Clipboard window if it's currently showing. <A NAME=MARKER-2-253></A><A NAME=MARKER-9-134></A><A NAME=MARKER-2-177></A><A NAME=MARKER-9-182></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MoreToolbox-116.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-118.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MoreToolbox-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>   
