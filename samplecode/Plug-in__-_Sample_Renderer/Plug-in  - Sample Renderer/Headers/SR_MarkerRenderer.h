/****************************************************************************** **																			 ** ** 	Module:		SR_MarkerRenderer.h										 ** ** 																		 ** ** 																		 ** ** 	Purpose: 					 										 ** ** 																		 ** ** 																		 ** ** 																		 ** ** 	Copyright (C) 1996 Apple Computer, Inc. All rights reserved.		 ** ** 																		 ** ** 																		 ** *****************************************************************************/#include "QD3D.h"#include "SR.h"#include "SR_Marker.h"#include "SR_Rasterizers.h"/*===========================================================================*\ * *	Routine:	SRMarker_Rasterize_8 *				SRMarker_Rasterize_8_WClip *				SRMarker_32_WClip *				SRMarker_Rasterize_32_WClip * *	Comments:	 *\*===========================================================================*/#if defined(SR_PIXELTYPE)	#undef SR_PIXELTYPE#endif  /*  SR_PIXELTYPE  */#ifdef SR_RASTERIZE_8BITS	#define	SR_PIXELTYPE	unsigned char	#define	SR_SIZEOF_PIXEL	1	#endif  /*  SR_RASTERIZE_8BITS  */#ifdef SR_RASTERIZE_32BITS	#define	SR_PIXELTYPE	unsigned long	#define	SR_SIZEOF_PIXEL	4	#endif  /*  SR_RASTERIZE_32BITS  */#ifdef SR_RASTERIZE_8BITS	#ifdef SR_WIN_CLIP		TQ3Status SRMarker_Rasterize_8_WClip(	#else		TQ3Status SRMarker_Rasterize_8(	#endif  /*  SR_WIN_CLIP  */	#endif  /*  SR_RASTERIZE_8BITS  */#ifdef SR_RASTERIZE_32BITS	#ifdef SR_WIN_CLIP		TQ3Status SRMarker_Rasterize_32_WClip(	#else		TQ3Status SRMarker_Rasterize_32(	#endif  /*  SR_WIN_CLIP  */#endif  /*  SR_RASTERIZE_32BITS  */	const struct TSRPrivate 		*srPrivate, 	const TQ3Point3D			*pt0, 	const TSRMarkerRasterData	*markerRaster,	const TQ3ColorRGB		 	*pointColorRGB){	long				rowBytes;	long				markerRowBytes;	SR_PIXELTYPE		*cBuffer;	#ifdef SR_WIN_CLIP	long				clipX, clipY;	TQ3Bitmap			*clipMask = NULL;	unsigned long		*clipMaskPtr, clipBits, clipXMask;	unsigned long		clipMaskRowBytes;	float				upperLeftX, upperLeftY;#endif  /*  SR_WIN_CLIP  */	SR_PIXELTYPE		pointColor;	long				longX, longY;	long				width = markerRaster->bitmap->width - markerRaster->endRowSkip,						height = markerRaster->bitmap->height - (markerRaster->startLineSkip + markerRaster->endLineSkip);	unsigned long		leftOver;	unsigned char		leftOverPickIndex = 0x80;	unsigned char		*cRowPtr;	unsigned char		*markerBitmap;	unsigned char		*markerRowPtr;	const TQ3XDrawRegionDescriptor	*descriptor;	void							*image;	descriptor = srPrivate->descriptor;	image = srPrivate->image;	rowBytes = descriptor->rowBytes;	#ifdef SR_WIN_CLIP	if (Q3XDrawRegion_GetClipMask(srPrivate->drawRegion, &clipMask) == kQ3Failure) {		return (kQ3Failure);	}	if (clipMask == NULL) {		return (kQ3Failure);	}#endif  /*  SR_WIN_CLIP  */	markerRowBytes = markerRaster->bitmap->width;	markerRowBytes = markerRowBytes / 8 + (markerRowBytes % 8 > 0);	longX = (long)pt0->x;	longY = (long)pt0->y;		COLOR_TO_PIXEL(pointColor,				   srPrivate->drawRegion,				   descriptor->pixelType,				   pointColorRGB->r,				   pointColorRGB->g,				   pointColorRGB->b);	cBuffer = (SR_PIXELTYPE *)((unsigned char *) image +				(((long)longY * rowBytes) + 					(long)longX * SR_SIZEOF_PIXEL));#ifdef SR_WIN_CLIP	clipMaskRowBytes = clipMask->rowBytes;	Q3XDrawRegion_GetDeviceOffsetX(srPrivate->drawRegion, &upperLeftX);	Q3XDrawRegion_GetDeviceOffsetY(srPrivate->drawRegion, &upperLeftY);	clipX = longX - upperLeftX;	clipY = longY - upperLeftY;	clipMaskPtr = (unsigned long *)((unsigned char *)clipMask->image +									(clipY * clipMaskRowBytes) + ((clipX >> 5) << 2));	clipBits = *clipMaskPtr;	clipXMask = (unsigned long)(1 << (0x1F - (clipX & 0x1F))); #endif  /*  SR_WIN_CLIP  */	cRowPtr = (unsigned char *) cBuffer;		markerRowPtr = markerRaster->bitmap->image;			leftOver = width & 0x00000007;	width -= leftOver;	/* 	 *  This is true if the marker is clipped on the top 	 */	if (markerRaster->startLineSkip ) {		markerRowPtr += markerRaster->startLineSkip * markerRowBytes;	}		/* 	 *  This is true if the marker is clipped on the left 	 */	if (markerRaster->startRowSkip) {		width -= markerRaster->startRowSkip;		markerRowPtr += markerRaster->startRowSkip / 8;				if (width < 0) {			leftOver += width;			leftOverPickIndex >>= -width;		}	}	do {		long			scanWidth, scanLeftOver;		unsigned char 	pickIndex = 0x80 >> (markerRaster->startRowSkip & 0x7);		cBuffer = (SR_PIXELTYPE *) cRowPtr;		markerBitmap = markerRowPtr;		scanWidth = width;				if (scanWidth > 0) {			do {				do {					if ((*markerBitmap & pickIndex) #ifdef SR_WIN_CLIP						&& (clipBits & clipXMask)#endif  /*  SR_WIN_CLIP  */					   ) {						*cBuffer = pointColor;					}					cBuffer++;#ifdef SR_WIN_CLIP					clipXMask >>= 1;					if (clipXMask == 0) {						clipMaskPtr++;						clipXMask = (unsigned long)(1 << 0x1F);						clipBits = *clipMaskPtr;					}#endif  /*  SR_WIN_CLIP  */					pickIndex >>= 1;				} while (pickIndex);								pickIndex = 0x80;				markerBitmap++;				scanWidth -= 8;							} while (scanWidth > 0);		}				scanLeftOver = leftOver;		pickIndex = leftOverPickIndex;				if (scanLeftOver > 0) {			do {				if ((*markerBitmap & pickIndex) #ifdef SR_WIN_CLIP					&& (clipBits & clipXMask)#endif  /*  SR_WIN_CLIP  */					){					*cBuffer = pointColor;				}				cBuffer++;#ifdef SR_WIN_CLIP				clipXMask >>= 1;				if (clipXMask == 0) {					clipMaskPtr++;					clipXMask = (unsigned long)(1 << 0x1F);					clipBits = *clipMaskPtr;				}#endif  /*  SR_WIN_CLIP  */				pickIndex >>= 1;			} while (--scanLeftOver && pickIndex);		}		markerRowPtr += markerRowBytes;		cRowPtr += rowBytes;			} while (--height);		return (kQ3Success);}