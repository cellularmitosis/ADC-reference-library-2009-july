<html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="Stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN2037: Exclusive File Access in Mac OS X</title> <meta name="keywords" content="Advisory Lock PBLockRange lockfile GrabBag EXLOCK Exclusive File Access"><meta name="Description" content="Technical Note TN2037: TN2037: This technote covers exclusivefile access In Mac OS X"><meta name="categories" content="Files"><meta name="week-posted" content="Apr 29, 2002 - May 3, 2002"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></head><body bgcolor="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003072" title="Exclusive File Access in Mac OS X"></a><a name="top"> </a> <!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxFileManagement-date.html">File Management</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN2037</div>
<div id="pageheadsub">Exclusive File Access in Mac OS X</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><center><table border="0" cellspacing="1" width="600"><tr><td align="left" scope="row"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left>            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->					<p id="menutext"><a href="#Overview"> Overview </a> <br><br><a href="#CheckingAvailability"> Checking Availability of Exclusive File Access </a> <br><br><a href="#Workarounds"> Common Workarounds </a> <br><br><a href="#OSSolutions"> Mac OS X Solutions </a> <br><br><a href="#AdvisoryLocking"> Implementing Advisory Locking </a> <br><br><a href="#References"> References </a> <br><br><a href="#Downloads">Downloadables</a> </p>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This document discusses the issues surrounding obtaining exclusive file access in current versions of Mac OS X and how it differs from classic Mac OS. Exclusive file access is an issue which affects all Mac OS X developers, Carbon, Cocoa, Java, and BSD.</P>              <!-- end_intro_text --><!-- begin_date --><h3 align=center>[May 01 2002]</h3><!-- end_date -->                </td>             </TR>          </TABLE><!-- end_table_box --><br><br><hr width=500 align=center><br><br><!-- begin_content --><a name="Overview"></a> <h2> Overview </h2> <p>Opening a file from classic Mac OS (pre Mac OS X) with <code>fsWrPerm</code>, <code>fsRdWrPerm</code>, or the default <code>fsCurPerm</code>, meant that any other application trying to open that same file with write access would not be able to do so. Usually an <code>fsRdWrPerm</code> error would be returned when other attempts were made to open the file for write access, though attempts to open such a file for read only access would succeed.  This default behavior allows for one "writer" and multiple "readers" of the file.</p> <p>Mac OS X's BSD subsystem does not enforce file read/write privileges in the same way as classic Mac OS. Opening a file for writing does not ensure other processes cannot write to the same file. The default behavior of BSD allows for multiple "writers" to a single file. In the current implementation, all of  the File Manager calls in Mac OS X call through to the underlying BSD file system.  As a result,  opening a file via <code>PBHOpenDF, PBHOpenRF, PBHOpen, PBOpenFork, FSOpenFork, HOpen,</code> etc. on a local volume and passing in a permissions value of <code>fsCurPerm</code>, <code>fsWrPerm</code>, or <code>fsRdWrPerm</code> does not guarantee exclusive file access on Mac OS X.  On Mac OS X subsequent Open calls to open a file with write permission may succeed without error. Similarly the <code>PBLockRange()</code> routines may not actually guarentee byte ranges cannot be modified by other processes. Because these routines may return without error, you should <a href="#CheckingAvailability">check the availability</a> of exclusive file access before making any assumptions about the underlying file access. If the 'supports advisory locks' feature is not available your application will not know if the file is already in use by another application.</p><p>AppleShare servers and Personal File Sharing on Mac OS X do enforce exclusive file access and range locking for volumes accessed over the network. However, this functionality is only available when accessing files over a networked file sharing connection and is not available to applications running on the server itself.</p><h3>Guidelines for working with non-exclusivity</h3><p>We realize that many applications rely on the behavior of the classic Mac OS File Manager to prevent multiple applications from writing to the same file (or to control write access through byte range locking).  Since that behavior is not implemented in all versions of Mac OS X, some common workarounds that you may wish to use in your code are described below.<BR>BSD was designed without exclusive locks in order to prevent denial of serviceattacks in which one process opens a file with an exclusive lock which may be required by another process, effectively blocking the other process.</p><BR><BR><a name="CheckingAvailability"></a> <h2>Checking Availability of Exclusive File Access</h2><p>Mac OS X will enforce exclusive file access, i.e. one writer and many readers of a file, through it's application frameworks, Carbon, Cocoa, and Java, by enforcing BSD advisory locks as though they are exclusive. The 'supports advisory locks' feature is defined if both the OS and file system for the volume in question support advisory locks.  In this case, the  default behavior of the application frameworks is to open files with exclusive access when opened as writable. Applications built on these frameworks automatically get this functionallity and do not need to be modified. When the conditions are met to support exclusive file access, <code>PBLockRange</code> will also call down through to the BSD advisory locks.  Since <code>PBLockRange</code> will be based on BSD advisory locks at this point, range locks can be applied to local files as well as those on file servers.</p><P>Since not all versions of Carbon on Mac OS X support exclusive file access nor do all file systems support BSD advisory locks, you should check a couple things before making assumptions about the underlying file access behavior.You should only assume these features are available if the gestalt bit, <code>gestaltFSSupportsExclusiveLocks</code>, as well as the <code>GetVolParms</code> bit, <code>bSupportsExclusiveLocks</code>, are both set.For instance, the Carbon Framework File Manager routines support advisory locks by default when <code>SupportsExclusiveFileAccess</code> returns true.</p><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#ifndef gestaltFSSupportsExclusiveLocks   #define    gestaltFSSupportsExclusiveLocks    15   #define    bSupportsExclusiveLocks            18#endifBoolean    SupportsExclusiveFileAccess( short vRefNum ){   OSErr                    err;   GetVolParmsInfoBuffer    volParmsBuffer;   HParamBlockRec           hPB;   long                     response;   Boolean                  exclusiveAccess    = false;   err = Gestalt( gestaltSystemVersion, &response );   if ( (err == noErr) && (response &lt 0x01000) )   {      err = Gestalt( gestaltMacOSCompatibilityBoxAttr, &response );      if ( (err != noErr)      || ((response & (1 &lt&lt gestaltMacOSCompatibilityBoxPresent)) == 0) )         return( true );        //    Running on Mac OS 9, not in Classic   }   err = Gestalt( gestaltFSAttr, &response );   if ( (err == noErr)        && (response & (1L &lt&lt gestaltFSSupportsExclusiveLocks)) )   {      hPB.ioParam.ioVRefNum     = vRefNum;      hPB.ioParam.ioNamePtr     = NULL;      hPB.ioParam.ioBuffer      = (Ptr) &amp;volParmsBuffer;      hPB.ioParam.ioReqCount    = sizeof( volParmsBuffer );      err = PBHGetVolParmsSync( &amp;hPB );      if ( err == noErr )         exclusiveAccess =                (volParmsBuffer.vMExtendedAttributes                &amp; (1L &lt&lt bSupportsExclusiveLocks)) != 0;   }   return( exclusiveAccess );}</pre></TD></TR></TABLE></CENTER> <BR><BR><p>To check if a volume supports byte range locking via <code>PBLockRange</code> you should check the <code>bHasOpenDeny</code> bit returned from GetVolParms.  See <a href="../fl/fl_37.html">Technical Note FL37</A> for more information about <code>PBLockRange</code> details.</p><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>      hPB.ioParam.ioVRefNum     = vRefNum;      hPB.ioParam.ioNamePtr     = NULL;      hPB.ioParam.ioBuffer      = (Ptr) &amp;volParmsBuffer;      hPB.ioParam.ioReqCount    = sizeof( volParmsBuffer );      err = PBHGetVolParmsSync( &amp;hPB );      if ( err == noErr )         supportsByteRangeLocking =             (volParmsBuffer.vMAttrib &amp; (1L &lt&lt bHasOpenDeny)) != 0;</pre></TD></TR></TABLE></CENTER> <p><a href="#top">Back to top</a></p><BR><BR><a name="Workarounds"></a> <h2> Common Workarounds </h2><p>The following two techniques are frequently used to work around this issue on platforms that do not enforce exclusive file access:</p><BR><BR><h3>Lockfiles</h3><p>A common approach used by many developers is to create a "lockfile" in the same directory as the file being opened.  Whenever opening a file, "foo", for instance, with write access you first try to create a lockfile, "foo.lock", in the same location.  If the file creation fails because the file already exists, you assume "foo" is already open by another application. Upon closing "foo" the application is also responsible for deleting "foo.lock". A strength of this technique is it only makes one assumption about the underlying file system: the file creation operation is atomic.  The obvious weakness is that since there is no OS support for this method, each application is responsible for implementing its own lock file mechanism, and there are no agreed upon standards or conventions for the naming of lock files</p><p>The included sample, <A HREF="downloads/GrabBag.sit">GrabBag</A>, implements a variation of this "lockfile" technique. Not only does it create the lockfile, it stores its ProcessSerialNumber in the file.  Before opening a file, the code checks if a lockfile exists, and if it does, verifies the PSN in the file is valid.  This helps guard against files being left in a locked state in the event of an application crash.</p><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Workarounds should be requalified with a system supporting the 'supports advisory locks' feature. It will be announced when it becomes available.</P></TD></TR></TABLE></CENTER><BR><BR><h3>Edit a Copy</h3><P>Another work around relies on operating on a unique copy of the file.  When a file is opened for editing, a duplicate of the file is created in the <code>/tmp</code> directory with a unique name, and opened.  When the user tries to save the document, the modification date of the original is matched against the date cached during the open of the file. If it has changed, you know the file was modified.</P><p><a href="#top">Back to top</a></p><BR><BR><p><a name="OSSolutions"></a></p><h2> Mac OS X Solutions </h2> <BR><BR><h3>BSD Advisory Locking</h3><P>Although Mac OS X's BSD subsystem does not implement provisions for exclusive write access, (i.e. mandatory locks), it does provide advisory locks. An advisory lock is a voluntary locking mechanism in which the underlying file system maintains a linked list of record locks. As long as your application and other applications respect the locks, only one application at a time will have write access to a particular file. Since these locks are voluntary it is the choice/responsibility of the application developer to respect or ignore advisory locks. If you would like to use advisory locks, this can be done by following the instructions later in this  document. By accessing files through the application frameworks (Carbon, Cocoa, Java), in versions of the OS supporting the advisory locks feature in frameworks, this will be provided automatically if you use the framework's <a href="#CheckingAvailability">file access methods</a>.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>All applications should respect and use advisory locks.</P></TD></TR></TABLE></CENTER><BR><BR>                    <P>Applications that call BSD file I/O functions directly will not gain this behavior for free, and therefore should be revised to set and respect advisory locks by specifying the appropriate flags when opening a file.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P>i.e. You should evaluate changing calls from:</P><pre>    fd = open( "./foo", O_RDWR );</pre><P>to:</P><pre>    fd = open( "./foo", O_RDWR + O_EXLOCK + O_NONBLOCK );</pre><P>- Where, <B><code>O_EXLOCK</code></B> means Atomically obtain an exclusive lock, and <B><code>O_NONBLOCK</code></B> means Do not block on open or for data to become available orDo not wait for the device or file to be ready or available.</P></TD></TR></TABLE></CENTER><BR><BR><p><a href="#top">Back to top</a></p><BR><BR><a name="AdvisoryLocking"></a> <h3>Implementing Advisory Locking</h3><P>Anywhere you are calling the System.framework version of <code>open(2)</code> with write access, you should modify the parameters to include the <code>"O_EXLOCK + O_NONBLOCK"</code> flags, and handle errors being returned, where they may have succeeded in the past.  The <code>open(2)</code> call will then fail if the file has already been opened for exclusive access by another process.</P><P>Advisory locks are associated with a process and a file.  This has two implications:  </P><ul><li>When a process terminates all its locks are released.<BR><BR></li><li>Whenever a descriptor is closed, any locks on the file referenced by that descriptor are released.<BR><BR></li></ul><BR><BR><h3>Implementing Byte Range Locking</h3><P>BSD also provides advisory byte range locking support through the <code>fcntl()</code> function.By using advisory locking, your application will be able to work in a cooperative manner with Carbon, Classic, and other applications in the future.  In these circumstances, files should be opened with the <code>O_EXLOCK</code> set and then ranges locked through the <code>fcntl()</code> call.</P><P>Stevens' "Advanced Programming in the Unix Environment" (page 367) describes some techniques for using the Unix service <code>fcntl()</code> to lock portions of a file for reading and writing. (Stevens, 1999, p. 367)</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>WARNING:</B><BR>A file lock request which is blocked can be interrupted by a signal. In this case the lock operation returns <code>EINTR</code>. Thus you may think you got a lock when you really did not. A solution is to block signals when locking. Another solution is to test the value returned by the lock operation and relock if the value is <code>EINTR</code>. Another solution, which we adopt here, is to do nothing about it.</P></TD></TR></TABLE></CENTER><BR><BR>                    <P><i>Record Locking</i> is the term normally used to describe the ability of a process to prevent other processes from modifying a region of a file while the first process is reading or modifying that portion of the file. BSD provides access to its record locking mechanism through the <code>fcntl</code> function: </P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    #include &lt;sys/types.h&gt;    #include &lt;unistd.h&gt;    #include &lt;fcntl.h&gt;    /*     * Returns:     *    -1 on error     */    int fcntl(int filedes, int cmd, ... /* struct flock *flockptr */ );</pre>	</TD></TR></TABLE></CENTER> <BR><BR><P>We'll start with the third argument (<code>flockptr</code>), which points to a <code>flock</code> structure: </P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>struct flock {    short l_type;     /* F_RDLCK (shared read lock), or                       * F_WRLCK (shared write lock), or                       * F_UNLCK (unlocking a region)                       */    off_t l_start;    /* offset in bytes, relative to l_whence */    short l_whence;   /* SEEK_SET: file's offset is set to                       *           l_start bytes from beginning of file                       * SEEK_CUR: file's offset is set to its current                       *           value plus the l_start (which can                       *           be + or -)                       * SEEK_END: file's offset is set to the size of                       *           the file plus the l_start (which can                       *           be + or -)                       */    off_t l_len;      /* length of region, in bytes                       * special case: if (l_len == 0), it means that                       * the lock extends to the largest possible                       * offset of the file. This allows us to lock a                       * region starting anywhere in the file, up                       * through and including any data that is                       * appended to the file                       */    pid_t l_pid;      /* returned when cmd = F_GETLK */}</pre>	</TD></TR></TABLE></CENTER> <BR><BR><P><B>This structure describes:</B></P><ul><li>The type of lock desired (i.e. read lock, write lock, unlock)<BR><BR></li><li>The starting byte offset of the region being locked or unlocked (<code>l_start<code> and </code>l_whence</code>)<BR><BR></li><li>The size of the region (<code>l_len</code>) <BR><BR></li></ul><P>To lock an entire file, set <code>l_start</code> and <code>l_whence</code> to point to the beginning of the file (i.e. <code>l_start= 0</code>, <code>l_whence= SEEK_SET</code>), and specify a length (<code>l_len</code>) of <code>0</code>. </P><P>Any number of processes can have a shared read lock on a given byte, but only one process can have an exclusive write lock on a given byte. To obtain a read lock the descriptor must be open for reading, and the region cannot have an exclusive write lock. To obtain a write lock the descriptor must be open for writing, and the region cannot have an exclusive write lock nor any read locks. </P><P>Now, we will describe the second parameter (<code>cmd</code>) for <code>fcntl</code>. The possible commands and what they mean are described in the following table: </P><BR><BR><CENTER><TABLE BORDER="1" CELLSPACING="2" CELLPADDING="2" width ="550">	<TR>		<td width=71 valign=top align=left><P align=center><B>Command</B></P></TD>		<td align="left"><P align=center><B>Meaning</B></P></TD>	</TR>	<TR>		<td width=71 valign=top align=left><B><code>F_GETLK</code></B></TD>		<TD  ALIGN=LEFT>Determine if the lock described by <code>flockptr</code> is blocked by some other lock. 						If a lock exists that would prevent ours from being created, the information on that 						existing lock overwrites the information pointed to by <code>flockptr</code>. If no 						lock exists that would prevent ours from being created, the structure pointed to by 						<code>flockptr</code> is left unchanged except for the <code>l_type member</code>, 						which is set to <code>F_UNLCK</code>.		</TD>	</TR>	<TR>		<td valign=top align=left><B><code>F_SETLK</code></B></TD>		<TD  ALIGN=LEFT>Set the lock described by <code>flockptr</code>. If we are unable to obtain a lock 						(because of previous locks already granted for the region) then <code>fcntl</code> 						returns <code>-1</code> and <code>errno</code> is set to either <code>EACCES</code> 						or <code>EAGAIN</code>.		</TD>	</TR>	<TR>		<td valign=top align=left><B><code>F_SETLKW</code></B></TD>		<TD  ALIGN=LEFT>This command is a blocking version of <code>F_SETLK</code> (the W in the command means 						"wait"). If the requested read lock or write lock cannot be granted because another 						process currently has some part of the requested region locked, the calling process 						is put to sleep. This sleep is interrupted is a signal is caught.		</TD>	</TR></TABLE></CENTER><BR><BR><P>Be aware that testing for a lock with <code>F_GETLK</code> and then trying to obtain that lock with <code>F_SETLK</code> or <code>F_SETLKW</code> is not an atomic operation. We have no guarantee that between the two <code>fcntrl</code> calls some other process won't come in and obtain the same lock. </P><P>To save ourselves the trouble of allocating a <code>flock</code> structure and filling in all the elements each time, Stevens defines the function <code>lock_reg</code> and a number of macros that call it. Notice that the macros shorten the number of parameters by two, and save us from having to remember the <code>F_*</code> constants mentioned above. </P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#define read_lock(fd, offset, whence, len)    \         lock_reg  (fd, F_SETLK,  F_RDLCK, offset, whence, len)#define readw_lock(fd, offset, whence, len)   \         lock_reg  (fd, F_SETLKW, F_RDLCK, offset, whence, len)#define write_lock(fd, offset, whence, len)   \         lock_reg  (fd, F_SETLK,  F_WRLCK, offset, whence, len)#define writew_lock(fd, offset, whence, len)  \         lock_reg  (fd, F_SETLKW, F_WRLCK, offset, whence, len)#define un_lock(fd, offset, whence, len)      \         lock_reg  (fd, F_SETLK,  F_UNLCK, offset, whence, len)pid_t    lock_test(int, int , off_t , int , off_t );#define    is_readlock(fd, offset, whence, len) \            lock_test(fd, F_RDLCK, offset, whence, len)#define    is_writelock(fd, offset, whence, len) \            lock_test(fd, F_WRLCK, offset, whence, len)int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len){    struct flock lock;    lock.l_type   = type;     /* F_RDLCK, F_WRLCK, F_UNLCK         */    lock.l_start  = offset;   /* byte offset, relative to l_whence */    lock.l_whence = whence;   /* SEEK_SET, SEEK_CUR, SEEK_END      */    lock.l_len    = len;      /* #bytes (0 means to EOF)           */    return ( fcntl(fd, cmd, &amp;lock) );}pid_t    lock_test(int fd, int type, off_t offset, int whence, off_t len){  struct flock lock;  lock.l_type = type;     /* F_RDLCK or F_WRLCK */  lock.l_start = offset;  /* byte offset relative to l_whence */  lock.l_whence = whence; /* SEEK_SET, SEEK_CUR, SEEK_END */  lock.l_len = len;       /* #bytes (0 means to EOF) */  if (fcntl(fd,F_GETLK,&amp;lock) &lt; 0){    perror("fcntl"); exit(1);}  if (lock.l_type == F_UNLCK)    return (0);        /* false, region is not locked by another process */  return (lock.l_pid); /* true, return pid of lock owner */}</pre>	</TD></TR></TABLE></CENTER> <BR><BR><P>There are three important rules regarding automatic inheritance and release of record locks: </P><ul><li>Locks are associated with a process and a file. When a process terminates, all its locks are released. Whenever a descriptor is closed, any locks on the file referenced by that descriptor for that process are released. <BR><BR></li><li>Locks are never inherited by the child across a fork (otherwise we could end up with two processes sharing a write lock) <BR><BR></li><li>Locks may be inherited by a new program across an <code>exec</code>. This is not required by BSD and is therefore machine dependent <BR><BR></li></ul><p><a href="#top">Back to top</a></p><BR><BR><a name="References"></a> <h2>References </h2> <P><B>Stevens, Richard W. (1999). Advanced Programming in the Unix Environment</B> <BR>Massachusetts: Addison Wesley Longman, Inc.<BR>ISBN: 0201563177</P><p><a href="#top">Back to top</a></p><BR><BR> <P><A NAME=Downloads></A></P>         		<H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (68K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn2037.pdf">Download</A></P>               </TD>            </TR>            <TR>               <td width=50 align=left>  <P ALIGN=center><img src="images/redbook.gif" width=20 height=20 align=bottom alt="Redbook gif"></P>               </TD>               <td align="left">                  <P>GrabBag, a Carbon application demonstrating the use of "lockfiles" (200 K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="downloads/GrabBag.sit">Download</A></P>               </TD>            </TR>         </TABLE>         <BR>                          <P><A HREF="#top">Back to top</A></P>                  </TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn2037.html%3Fid%3DDTS10003072-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn2037.html%3Fid%3DDTS10003072-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn2037.html%3Fid%3DDTS10003072-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>