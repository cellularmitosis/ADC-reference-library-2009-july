<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> Driver Initialization and Resource Verification</TITLE></HEAD><BODY BGCOLOR="#ffffff"><DIV><a name="top"></a><!-- start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!-- start of path --><font face="Geneva,Helvetica,Arial" size="1"><b><br>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Documentation</a> &gt; <!-- a href="" target="_top" -->Hardware<!-- /a -->  <b>&gt; </b><a href="../../devicemgrs.html" target="_top">Device Managers and Drivers</a> <b>&gt; </b><a href="../pci_srvcs.html" target="_top">PCI Card Services</a> <b>&gt; </b>Designing PCI Cards and Drivers for Power Macintosh Computers</font><br><br><!-- end of path --><A HREF="PCI_BOOK.86.html"><img src="images/up.gif" border="0" width="36" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.89.html"><img src="images/previous.gif" border="0" width="66" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.8b.html"><img src="images/next.gif" border="0" width="49" height="16"></A><!-- insert Show/Hide frames --><a href="javascript:testFrame()"><script><!--document.write(frameLink);//--></script><!-- end Show/Hide frames --></A><HR></DIV><H1 CLASS="H1.Heading1"><A NAME="pgfId=3384"> </A><A NAME="21936"> </A>Driver Initialization and Resource Verification</H1><P CLASS="T1.Text1"><A NAME="pgfId=3385"> </A>After finding a match between a hardware device and its driver, the driver initialization code must check to make sure that all needed resources are available. This section describes a typical algorithm for resource verification. Driver <A NAME="marker=3386"> </A>initialization code should perform this algorithm for two reasons:</P><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=3387"> </A>The driver may not have all the address resources it requires. This event is unlikely, but the driver should check.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3388"> </A>If the PCI card expansion ROM doesn't contain FCode, the driver may need to perform a diagnostic to make sure the card it has been matched with is actually the card it is designed to control. This problem is discussed in <A HREF="PCI_BOOK.41.html#35752" CLASS="XRef">Open Firmware FCode Options</A>.</LI></UL><DIV><blockquote><p CLASS="ImportantHead"><b><A NAME="pgfId=14261"> </A>IMPORTANT</b></p><P CLASS="I.Important"><A NAME="pgfId=3392"> </A>The driver must enable the card's address space for a PCI device to be usable. </P></blockquote><P CLASS="T1.Text1"><A NAME="pgfId=3396"> </A>The following is a typical resource verification and card address enabling procedure:</P><OL><LI CLASS="N/.NList=1"><A NAME="pgfId=3397"> </A>Check for existence of an <TT CLASS="cv">assigned-addresses</TT> property for the device. If no <TT CLASS="cv">assigned-addresses</TT> property exists, exit the driver initialization routine with an error message (address resources not available). The <TT CLASS="cv">assigned-addresses</TT> property is discussed in <A HREF="PCI_BOOK.12e.html#31251" CLASS="XRef">Standard Properties</A>. If an <TT CLASS="cv">assigned-addresses</TT> property exists, go to step 2.</LI><LI CLASS="N.NList"><A NAME="pgfId=3401"> </A>Check the <TT CLASS="cv">assigned-addresses</TT> property for the existence of the base registers required for full operation of the driver. Do this by looking at the last byte of the first long word of each <TT CLASS="cv">assigned-addresses</TT> entry that is required. A typical assigned-addresses entry looks like this: If the required base registers are not present, exit the driver initialization routine with an error message (address resources not available). If the required base registers are present, continue.</LI><TABLE border=1 cellpadding=3><TR><TD ROWSPAN="1" COLSPAN="1"><CODE CLASS="TbCv.TblCode"><A NAME="pgfId=4206"> </A><TT CLASS="cv">82006810 00000000 80000000 000000000 00008000<BR>81006814 00000000 00000400 000000000 00000100</TT></CODE></TD></TR></TABLE><LI CLASS="N.NList"><A NAME="pgfId=3406"> </A>Note where in the <A NAME="marker=3405"> </A><TT CLASS="cv">assigned-addresses</TT> property the entries for the required base registers are located. The first entry is 0, the next is 1, and so on. That same order will be preserved in the <TT CLASS="cv">AAPL,address</TT> property, which is an array of 32-bit values corresponding to the logical address for your base register's physical address. For more information about the <TT CLASS="cv">AAPL,address</TT> property, see <A HREF="PCI_BOOK.1ba.html#14782" CLASS="XRef">Fast I/O Space Cycle Generation</A>. A typical <TT CLASS="cv">AAPL,address</TT> property looks like this: If the driver uses Expansion Bus Manager routines (such as <TT CLASS="cv">ExpMgrIOReadByte</TT>) it must pass the physical address for the I/O base register, which it gets from the <TT CLASS="cv">assigned-addresses</TT> property. The Expansion Bus Manager does byte swapping and EIEIO synchronization for the driver, but it's node-based and it's slow. The <TT CLASS="cv">AAPL,address</TT> version just uses a pointer, so it's as fast as accessing memory space.</LI><TABLE border=1 cellpadding=3><TR><TD ROWSPAN="1" COLSPAN="1"><CODE CLASS="TbCv.TblCode"><A NAME="pgfId=4208"> </A><TT CLASS="cv">80000000 F2000400</TT></CODE></TD></TR></TABLE><LI CLASS="N.NList"><A NAME="pgfId=3413"> </A>If the driver can be confused with another driver--if, for example, the card doesn't have FCode and another vendor uses the same PCI ASIC on a different card--the driver must perform a diagnostic routine on the card to make sure that it has been matched correctly. The <TT CLASS="cv">DeviceProbe</TT> function, described below, helps a driver determine if a device is present at an address. If the diagnostic routine fails, the driver must exit its initialization routine with an error message (not my card). If the driver verifies that the card is correct, continue.</LI><LI CLASS="N.NList"><A NAME="pgfId=3414"> </A>The driver must read or write to the device's configuration command register to enable its PCI spaces. <A HREF="PCI_BOOK.8a.html#41186" CLASS="XRef">Listing&nbsp;7-2</A> presents typical code for doing this. It uses the <TT CLASS="cv">ExpMgrConfigReadWord</TT> routine <A HREF="PCI_BOOK.1c4.html#18280" CLASS="XRef">ExpMgrConfigReadWord</A>.</LI></OL><P CLASS="L.Listing"><B><A NAME="pgfId=3422"> </A>Listing&nbsp;7-2	<A NAME="41186"> </A>Enabling PCI spaces</B></P><CODE CLASS="Cv.Code"><A NAME="pgfId=14271"> </A>ExpMgrConfigReadWord (yourNode, 4, &amp;yourvalue);<BR>yourvalue = yourvalue | yourEnables;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* if I/O space, bit 0;<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if memory space, bit 1 */<BR>ExpMgrConfigWriteWord (yourNode, 4, yourvalue);</CODE><P CLASS="T1.Text1"><A NAME="pgfId=3427"> </A><A HREF="PCI_BOOK.8a.html#10683" CLASS="XRef">Listing&nbsp;7-3</A> shows a routine that extracts a device's logical address by using its <TT CLASS="cv">assigned-addresses</TT> and <TT CLASS="cv">AAPL,address</TT> properties. It accepts as input the offsets into PCI configuration space that match the device's space request. For example, an Ethernet card may want two address spaces, I/O and memory. The card is designed so that offset 0x10 in configuration space corresponds to the I/O space and 0x14 corresponds to the memory space.</P><P CLASS="L.Listing"><B><A NAME="pgfId=3429"> </A>Listing&nbsp;7-3	<A NAME="10683"> </A>Getting a device's logical address</B></P><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=14419"> </A>//The following values are valid for offset Values(:<BR>//<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#define kPCIConfigBase10Offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x10<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#define kPCIConfigBase14Offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x14<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#define kPCIConfigBase18Offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x18<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#define kPCIConfigBase1COffset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x1C<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#define kPCIConfigBase20Offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x20<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#define kPCIConfigBase24Offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x24<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#define kPCIConfigBaseROM30Offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x30<BR><BR>//Input:<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theID - the NameRegistryID for a PCI card<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base RegAddress - no input value<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offsetValue -&nbsp;&nbsp;&nbsp;config base offset, determines which address space<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logical address is returned<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spaceAllocated - noinputvalue<BR><BR>//Output:<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifer = kOTNoError, *baseRegAddress - contains the logical address of a PCI<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addresss pace, also space Allocated is a byte count fortheamountofspace<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that was allocated<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returns various errors<BR>//<BR>//----------------------------------------------------------------------------------<BR><BR>OSStatus GetPCICardBaseAddress(RegEntryID *theID, UInt32 *baseRegAddress,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UInt 8offsetValue, UInt32 *spaceAllocated)<BR>{<BR>OSStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;osStatus;<BR>PCIAssignedAddress&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*assignedArray;<BR>RegPropertyValueSize&nbsp;&nbsp;&nbsp;&nbsp;propertySize;<BR>UInt32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numberOfElements,*virtualArray;<BR>Boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foundMatch;<BR>UInt16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index;<BR><BR>*baseRegAddress = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//defaultvalue<BR>foundMatch = kFalse;<BR><BR>osStatus = GetAProperty(theID, kPCIAssignedAddressProperty,(void**)&amp;assignedArray,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;propertySize);<BR><BR>if ((osStatus == kOTNoError) &amp;&amp; propertySize)<BR>&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;numberOfElements = propertySize/sizeof(PCIAssignedAddress);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;osStatus = GetAProperty(theID, kAAPLDeviceLogicalAddress, (void**)&amp;virtualArray,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;propertySize);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;if ((osStatus == kOTNoError) &amp;&amp; propertySize)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;// search through the assigned addresses property looking for base register<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (index = 0;(index !=numberOfElements) &amp;&amp; !foundMatch; ++index)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (assignedArray[index].registerNumber == offsetValue)<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*spaceAllocated = assignedArray[index].size.lo;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*baseRegAddress = virtualArray[index];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foundMatch = kTrue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DisposeProperty((void **)&amp;virtualArray);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;osStatus = kENXIOErr;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;DisposeProperty((void **)&amp;assignedArray);<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>else<BR>&nbsp;&nbsp;&nbsp;&nbsp;osStatus = kENXIOErr;<BR><BR>return osStatus;<BR>}</CODE></DIV><H2 CLASS="RoH.RoutineHeadingTOC"><A HREF="PCI_BOOK.8b.html#pgfId=3823" CLASS="Hypertext">DeviceProbe</A></H2><HR>&#169 1999 Apple Computer, Inc. &#150 (Last Updated 26 March 99)<P><A HREF="PCI_BOOK.86.html"><img src="images/up.gif" border="0" width="36" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.89.html"><img src="images/previous.gif" border="0" width="66" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.8b.html"><img src="images/next.gif" border="0" width="49" height="16"></A><!-- insert Show/Hide frames --><a href="javascript:testFrame()"><script><!--document.write(frameLink);//--></script><!-- end Show/Hide frames --></A><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></body></HTML>