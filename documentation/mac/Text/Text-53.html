<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Text Attributes(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING53></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-52.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-54.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-40.html"><B>Chapter 2 - TextEdit</B></A> / <A HREF="Text-49.html"><B>Using TextEdit</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING53-0></A>
<H2><A NAME=MARKER-9-249></A>Text Attributes</H2>
 This section describes how your application can check the current attributes of a range of text to determine which ones are consistent across the text. It also describes how you can manipulate the font, style, size, and color of a range of text; <A NAME=MARKER-2-86></A>the text selection can consist of a segment of text, the entire text of the edit record, a single character, or even an insertion point.<A NAME=MARKER-2-68></A><P>
 You use the <A NAME=MARKER-2-793></A><CODE>TEContinuousStyle</CODE> function to determine the current attributes for a range of text, and you use the <CODE>TESetStyle</CODE> procedure to change them. You can change character attributes singly, collectively, or in any combination using <CODE>TESetStyle</CODE>. <A NAME=MARKER-2-17></A>For example, you can change the font style to bold or italic, and you can underline, outline, or shadow the selected text. You can increase or decrease the type size incrementally, or change the color in which the text is displayed. You use the <CODE>TESetAlignment</CODE> procedure to change the alignment of the entire text of an edit record.<P>
 This section describes these tasks in this order:<P>
<UL>
<LI>checking the text attributes across a selection range
<LI>toggling an attribute
<LI>handling a font menu that lets the user change the font family
<LI>handling a font size menu that lets the user change the text size
<LI>handling a style menu that lets the user change the style of the text
<LI>changing the text alignment<P>
</UL>
 Some general information about <CODE>TESetStyle</CODE> that applies to many of the tasks for which you can use it is discussed here. If you call <CODE>TESetStyle</CODE> for an insertion point, TextEdit stores the input character attribute information in the null scrap's style scrap record. If the user then enters text (pastes without attributes, inserts, or types it), the attributes are written to the style record and applied to that text.<P>
 There are many ways in which you can use <CODE>TESetStyle</CODE> to handle menu commands that let the user modify text attributes. If your application allows a user to change any or all the text attributes from a single format menu before redrawing the text, you can make <A NAME=MARKER-2-176></A>one call to <CODE>TESetStyle</CODE> specify<A NAME=MARKER-2-544></A>ing the particular attributes to be changed. If your application provides separate menus to let a user manipulate different aspects of the text, you can make separate calls to <CODE>TESetStyle</CODE> specifying the discrete text attribute to be changed.<P>
<DL>
<DT><B>Note</B>
<DD>A field in the text style record is only valid if the corresponding bit is set in the <CODE>mode</CODE> parameter; otherwise, the field contains invalid information.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The value of <CODE>mode</CODE> specifies which existing character attributes are to be changed to the new character attributes specified by <CODE>newStyle</CODE>.
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Constant<TH>Value<TH>Description<TR>
<TD>doFont<TD>1<TD>Sets the font family ID<TR>
<TD>doFace<TD>2<TD>Sets the character style<TR>
<TD>doSize<TD>4<TD>Sets the type size<TR>
<TD>doColor<TD>8<TD>Sets the color<TR>
<TD>doAll<TD>15<TD>Sets all attributes<TR>
<TD>addSize<TD>16<TD>Increases or decreases the type size<TR>
<TD>doToggle<TD>32<TD>Modifies the mode</TABLE>
<P>
<A NAME=HEADING53-14></A>
<H3>Checking the Text Attributes Across a Selection Range</H3>
 When a particular attribute is set for an entire selection range, that attribute is said to be <I>contin<A NAME=MARKER-2-127></A>uous</I> over the selection. For example, in the selected text in <A HREF=#MARKER-9-257>Figure 2-10</A>, the bold attribute is continuous over the selection range and italic is not.<P>
<B>Figure 2-10  <A NAME=MARKER-9-257></A>Continuous attributes over a selection range</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/TE_L-30.jpg">
 To determine the actual values for continuous attributes, you can use the <A NAME=MARKER-9-68></A><CODE>TEContinuousStyle</CODE> function. This function takes two variable parameters: <CODE>mode</CODE> and <CODE>aStyle</CODE>. For its input value, <CODE>mode</CODE> specifies the attributes to be checked; for its output value, <CODE>mode</CODE> specifies those attributes that are continuous over the selection range. For the input value of <CODE>aStyle</CODE>, you pass a pointer to a text style record (of type <CODE>TextStyle</CODE>); for those attributes that are continuous, the text style record fields contain the actual values when <CODE>TEContinuousStyle</CODE> returns.<P>
 A field in the text style record is only valid if the corresponding bit is set in the <CODE>mode</CODE> parameter; otherwise, the field contains invalid information. Possible values for the <CODE>TEContinuousStyle</CODE> <CODE>mode</CODE> parameter are defined by the following constants.
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Constant<TH>Value<TH>Description<TR>
<TD>doFont<TD>1<TD>Specifies the font family number<TR>
<TD>doFace<TD>2<TD>Specifies the character style<TR>
<TD>doSize<TD>4<TD>Specifies the type size<TR>
<TD>doColor<TD>8<TD>Specifies the color<TR>
<TD>doAll<TD>15<TD>Specifies all the attributes</TABLE>
 <P>
 <A HREF=#MARKER-9-259>Listing 2-9</A> illustrates how to use the <CODE>TEContinuousStyle</CODE> function to determine the font, style, size, and color of the current selection range. The code sets the <CODE>mode</CODE> parameter. Then it calls <CODE>TEContinuousStyle</CODE>, passing it the text style record. When <CODE>TEContinuousStyle</CODE> returns, it checks each bit of the <CODE>mode</CODE> parameter to see which attributes are continuous across the selection.<P>
<B>Listing 2-9  <A NAME=MARKER-9-259></A>Determining the font, style, size, and color of the current selection range</B><P>
<PRE>
PROCEDURE MyGetCurrentSelection (VAR mode: Integer; 
         VAR continuous: Boolean; VAR astyle: TextStyle; 
         myTERec: TEHandle);
BEGIN
   mode := doFont + doFace + doSize + doColor;
   continuous := TEContinuousStyle(mode, aStyle, myTERec);
   IF BitAnd(mode, doFont) &lt;&gt; 0 THEN
      {font for selection = aStyle.tsFont} 
   ELSE
      {more than one font in selection};
   IF BitAnd(mode, doFace) &lt;&gt; 0 THEN
      {aStyle.tsFace contains the text faces (or plain) that }
      { are common to the selection.}
   ELSE
      {No text face is common to the entire selection.};
   IF BitAnd(mode, doSize) &lt;&gt; 0 THEN
      {size for selection = aStyle.tsSize}
   ELSE
      {more than one size in selection};
   IF BitAnd(mode, doColor) &lt;&gt; 0 THEN
      {color for selection = aStyle.tsColor}
   ELSE
      {more than one color in selection}
END;
</PRE>
<A NAME=HEADING53-23></A>
<H3>Toggling an Attribute</H3>
 Once you know what attributes are continuous across a selection range, you can use <CODE>TESetStyle</CODE> to toggle an attribute on and off. For example, if you specify a <CODE>mode</CODE> parameter for <CODE>TESetStyle</CODE> that includes both <CODE>doToggle</CODE> and <CODE>doFace</CODE>, and an attribute that has been set in the <CODE>tsFace</CODE> field of the text style record exists across the current selection range, then <CODE>TESetStyle</CODE> removes that attribute. However, if the attribute isn't continuous over the current selection, then all of the selected text is set to include it.<P>
 For example, in the selected text shown in <A HREF=#MARKER-9-260>Figure 2-11</A>, the bold style is continuous over the selection range and the italic style is not.<P>
<B>Figure 2-11  <A NAME=MARKER-9-260></A><A NAME=MARKER-21-261></A>An initial selection before <CODE>TESetStyle</CODE> is called</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/TE_L-24.jpg">
 If you call <CODE>TESetStyle</CODE> with a <CODE>mode</CODE> of <CODE>doFace</CODE> + <CODE>doToggle</CODE> and a text style record parameter with its <CODE>tsFace</CODE> field set to <CODE>bold</CODE>, the resulting selection is no longer bold, as shown in <A HREF=#MARKER-9-262>Figure 2-12</A>.<P>
<B>Figure 2-12  <A NAME=MARKER-9-262></A><A NAME=MARKER-21-263></A>The result of calling <CODE>TESetStyle</CODE> to toggle to bold</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/TE_L-25.jpg">
 On the other hand, if instead you call <CODE>TESetStyle</CODE> with a <CODE>mode</CODE> of <CODE>doFace</CODE> + <CODE>doToggle</CODE> and a text style record with its <CODE>tsFace</CODE> field set to <CODE>italic</CODE>, the resulting selection is all bold italic as shown in <A HREF=#MARKER-9-264>Figure 2-13</A>.<P>
<B>Figure 2-13  <A NAME=MARKER-9-264></A><A NAME=MARKER-21-265></A>The result of calling <CODE>TESetStyle</CODE> to toggle italics</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/TE_L-26.jpg">
<A NAME=HEADING53-34></A>
<H3>Handling a Font Menu</H3>
 You can use <CODE>TESetStyle</CODE> to handle a Font menu that allows the user to change the font family for a text selection. The user might select the entire text of an edit record or a portion of it, then choose a different font family from your menu to be used to render the text. <A HREF=#MARKER-9-266>Listing 2-10</A> shows how to handle a Font menu that allows the user to do this. The code determines which font the user has selected from the menu. Next, it calls the Font Manager's <CODE>GetFNum</CODE> procedure to get the font family ID for the font of the selected text. Then it calls <CODE>TESetStyle</CODE> passing it the text style record with the <CODE>tsFont</CODE> field set to the font ID. Because the <CODE>redraw</CODE> parameter is set to <CODE>TRUE</CODE>, the current selection range is redrawn immediately in the new font.<P>
<B>Listing 2-10  <A NAME=MARKER-9-266></A>Handling the Font menu</B><P>
<PRE>
PROCEDURE MyHandleFontMenu (myWindow: WindowPtr; myTERec: TEHandle; 
                              menuItem: Integer);
VAR
   txStyle:    TextStyle;  {holds style selected}
   fontName:   Str255;     {name of font selected}
   fontID:     Integer;    {ID of font selected} 
BEGIN 
   GetItem(GetMenuHandle(mFont), menuItem, fontName);
   GetFNum(fontName, fontID);
   txStyle.tsFont := fontID;
   TESetStyle(doFont, txStyle, true, myTERec);
   MyAdjustScrollBars(window, FALSE);
END; 
</PRE>
<A NAME=HEADING53-38></A>
<H3>Handling a Font Size Menu</H3>
 If your application includes a <A NAME=MARKER-2-9></A>menu that allows us<A NAME=MARKER-2-43></A>ers to change the font size of the selected text, you can use the <CODE>TESetStyle</CODE> procedure to handle this modification. The code in <A HREF=#MARKER-9-270>Listing 2-11</A> sets the <A NAME=MARKER-2-42></A><CODE>tsSize</CODE> field of the text style record to the font size that the user selects; then it calls <CODE>TESetStyle</CODE> to apply the new font size immediately. The <CODE>doSize</CODE> mode parameter value forces all the text to the new size.<P>
<B>Listing 2-11  <A NAME=MARKER-9-270></A>Handling the Size menu</B><P>
<PRE>
PROCEDURE MyHandleSizeCommand (myTERec: TEHandle; menuItem: Integer);
VAR
   txStyle:    TextStyle;
BEGIN
   MyGetSize(GetMenuHandle(mSize), menuItem, sizeChosen);
   txStyle.tsSize := sizeChosen;
   TESetStyle(doSize, txStyle, TRUE, myTERec);
   MyAdjustScrollBars(window, FALSE);
END;
</PRE>
<A NAME=HEADING53-42></A>
<H3>Handling a Style Menu</H3>
 Your application can also use <CODE>TESetStyle</CODE> to handle Style menu commands. For example, you can set the <CODE>mode</CODE> parameter to <CODE>doFace</CODE> and set the <CODE>tsFace</CODE> field of the text style record to any of the font attributes that the user selects. If your menu supports a Plain option to remove all attributes from the text selection, you need to explicitly set <CODE>tsFace</CODE>. Because of the behavior of <CODE>TESetStyle</CODE>, you cannot implement a Plain selection by passing a null (empty set) text style record to remove the current attributes. <A HREF=#MARKER-9-271>Listing 2-12</A> shows how to use <CODE>TESetStyle</CODE> to change the text attributes, including how to render plain text.<P>
<B>Listing 2-12  <A NAME=MARKER-9-271></A>Handling a Style menu</B><P>
<PRE>
PROCEDURE MyHandleStyleMenu (myWindow: WindowPtr; myTERec: TEHandle;
                              menuItem: Integer);
VAR
   txStyle:    TextStyle;
   anIntPtr:   Integer;
BEGIN {mStyle}
   WITH txStyle DO BEGIN
      CASE menuItem OF
         plainItem: 
            BEGIN
               anIntPtr := @txStyle.tsFace; 
               anIntPtr^ := 0;
               tsFace := [];
            END;
         boldItem:
          tsFace := [bold];
         italicItem:
          tsFace := [italic];
         underlineItem:
          tsFace := [underline];
         outlineItem:
          tsFace := [outline];
         shadowItem:
          tsFace := [shadow];
      END; {case}

      IF menuItem &lt;&gt; 1 THEN
         TESetStyle(doFace + doToggle, txStyle, TRUE, myTERec)
            {if we don't select plain then use doToggle}
      ELSE
         TESetStyle(doFace, txStyle, TRUE, myTERec);
            {TESetStyle has problems with plain and doToggle }
            { has no effect!so we need to special case it.}
      MyAdjustScrollBars(window, FALSE);
   END; 
END;
</PRE>
 If you set <CODE>redraw</CODE> to <CODE>TRUE</CODE>, TextEdit redraws the current selection with the new attributes, recalculating line breaks, line heights, and font ascents. If you call <CODE>TESetStyle</CODE> with a value of <CODE>FALSE</CODE> for the <CODE>redraw</CODE> parameter, TextEdit does not redraw the text or recalculate line breaks, line heights, and font ascents until the next update event occurs. Consequently, when your application calls a routine that uses any of this information, such as<A NAME=MARKER-2-10></A> <CODE>TEGetHeight</CODE> (which returns a total height between two specified lines), the routine uses the old character attribute information that existed before you called <CODE>TESetStyle</CODE> to change it. To be certain that the new information is always reflected immediately, call the <CODE>TESetStyle</CODE> procedure with a <CODE>redraw</CODE> parameter of <CODE>TRUE</CODE>.<P>
 <A HREF=#MARKER-9-274>Listing 2-13</A> shows a sample procedure that calls <A NAME=MARKER-2-24></A><CODE>TEContinuousStyle</CODE> to check the character attributes of the current selection range; it determines whether the style is plain, bold, or italic. For each style that is continuous across the text, the <CODE>MyAdjustStyleNew</CODE> procedure marks the item on the style menu. In this case, if <CODE>TEContinuousStyle</CODE> returns a <CODE>mode</CODE> parameter that contains <CODE>doFace</CODE> and the text style record <CODE>tsFace</CODE> field is bold, it means that the selected text is all bold, but may contain other text styles, such as italic, as well. Italic does not apply to all of the selected text, or it would have been included in the <CODE>tsFace</CODE> field. If the <CODE>tsFace</CODE> field is an empty set, then all of the selected text is plain.<P>
<B>Listing 2-13  Checking the style and mark<A NAME=MARKER-9-274></A>ing Style menu items to reflect <BR>the current selection range</B><P>
<PRE>
PROCEDURE MyAdjustStyleNew (myTERec: TEHandle);
VAR
styleMenu:  MenuHandle;
aStyle:     TextStyle;
mode:       Integer;
BEGIN
   mode := doFace;
   styleMenu := GetMenuHandle(mStyle);
   IF TEContinuousStyle(mode, aStyle, myTERec) THEN
      BEGIN
         {There is at least one style that is continuous over }
         { the selection. Note that it might be plain, which is }
         { actually the absence of all styles.}
         CheckItem(styleMenu, plainItem, aStyle.tsFace = []);
         CheckItem(styleMenu, boldItem, bold IN aStyle.tsFace);
         CheckItem(styleMenu, italicItem, italic IN aStyle.tsFace);
         {Set other menu items appropriately.}
   END
   ELSE
      BEGIN
         {No text face is common to the entire selection.}
         CheckItem(styleMenu, plainItem, FALSE);
         CheckItem(styleMenu, boldItem, FALSE);
         CheckItem(styleMenu, italicItem, FALSE);
         {Set other menu items appropriately.}
   END;
END;
</PRE>
<A NAME=HEADING53-51></A>
<H3><A NAME=MARKER-2-955></A><A NAME=MARKER-9-276></A>Changing the Text Alignment</H3>
 Your application <A NAME=MARKER-2-70></A>can change the alignment of the entire text of an edit record by calling the <CODE>TESetAlignment</CODE> procedure. The default alignment used to display the text of an edit record is based on the primary line direction of the system script. For example, when the system script is Arabic or that of any language that is read from right to left, the default line direction is right to left and the text is right aligned.<P>
 For a script system whose primary line direction is right to left, you can force left alignment of the text by specifying <CODE>teFlushLeft</CODE> as the value of the <CODE>align</CODE> parameter, as shown in the following example:<P>
<PRE>
TESetAlignment (teFlushLeft, myTERec);
</PRE>
 You can use any of the following constants to specify how text is aligned.
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Constant<TH>Description<TR>
<TD><A NAME=MARKER-2-80></A>teFlushDefault<TD>Default alignment according to the primary line direction<TR>
<TD><A NAME=MARKER-2-6></A>teCenter<TD>Center for all scripts<TR>
<TD><A NAME=MARKER-2-7></A>teFlushRight<TD>Right for all scripts<TR>
<TD><A NAME=MARKER-2-10></A>teFlushLeft<TD>Left for all scripts</TABLE>
<P>
 Make sure that you call the Window Manager's <CODE>InvalRect</CODE> procedure after you change the alignment so the text is redrawn with the new alignment. For more information about <CODE>InvalRect</CODE>, see the chapter "Window Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>.<A NAME=MARKER-2-421></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-52.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-54.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
