<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Carbon Event Manager Programming Guide: Carbon Event Manager Tasks</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Carbon Event Manager Tasks"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000989-CH203" title="Carbon Event Manager Tasks"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../EventsOtherInput-date.html#//apple_ref/doc/uid/TP30000440-TP30000420-TP30000447" target="_top">Events &amp; Other Input</a> &gt; <a href="../Intro/CarbonEventsIntro.html#//apple_ref/doc/uid/TP30000989-CH201-DontLinkElementID_33">Carbon Event Manager Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Concept/CarbonEventsConcept.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ApdxARev/CarbonEventsApdxRev.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_35" title="Carbon Event Manager Tasks"></a><h1><a name="//apple_ref/doc/uid/TP30000989-CH203-TPXREF101" title="Carbon Event Manager Tasks"></a>Carbon Event Manager Tasks</h1><p>This chapter expands on the basic concepts introduced in <span class="content_text"><a href="../Concept/CarbonEventsConcept.html#//apple_ref/doc/uid/TP30000989-CH202-BABDIGIF">“Carbon Event Manager Concepts”</a></span> and shows you how to create and install event handlers using the Carbon Event Manager interface.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-TPXREF103">Event Classes and Kinds</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-TPXREF104">Executing the Event Loop</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-TPXREF105">Creating and Registering an Event Handler</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHEAFCI">Event Parameters</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-TPXREF106">Other Event Attributes</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CHDIBFIJ">Queue-Synchronized Events (Mac OS X v.10.2 and Later)</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-TPXREF107">Command Events</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHEBEIH">Text Events</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-TPXREF108">Mouse Events</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHCJBGE">Installing Timers</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHFIHIF">Processing Events Manually</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-TPXREF110">Creating Your Own Events</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHJICGJ">Carbon Events in Multiple Threads</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-TPXREF111">Modal Event States</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000989-CH203-TPXREF103" title="Event Classes and Kinds"></a><h2>Event Classes and Kinds</h2><p>As introduced in <span class="content_text"><a href="../Concept/CarbonEventsConcept.html#//apple_ref/doc/uid/TP30000989-CH202-BABDFHAH">“Event Types,”</a></span> each Carbon event is defined by an event class (for example, mouse or window events) as well as an event kind (for example, a mouse-down event).</p><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_92"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_93"></a>All of the available event classes and kinds are designated by constants defined in the Universal Interfaces header file <code>CarbonEvents.h</code>. Nominally, these values are 32-bit integers; but in practice, the constants denoting event classes are specified as four-character tags—for instance, </p><div class="codesample"><table><tr><td scope="row"><pre>kEventClassMouse = FOUR_CHAR_CODE('mous');<span></span></pre></td></tr></table></div><p>—while those representing event kinds are defined as simple integers:</p><div class="codesample"><table><tr><td scope="row"><pre>kEventMouseDown = 1;<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_94"></a>The event class and kind form a unique signature called an <em>event type</em>, which is specified in the Carbon Event Manager by the <code>EventTypeSpec</code> structure. When you register an event handler, you need to pass one or more <code>EventTypeSpec</code> structures to specify which events you want to handle. </p><p>The inclusion of standard handlers for many common events means that you can intercept actions only at the level you require. Some examples:</p><ul class="ul"><li class="li"><p>If the user clicks the zoom box in a window, your handler can intercept the overall action at any of the following levels: </p><ul class="nested"><li class="nested li"><p>When the mouse is pressed (<code>kEventMouseDown</code>).</p></li><li class="nested li"><p>When the mouse is determined to be in the zoom region (<code>kEventWindowClickZoomRgn</code>). </p></li><li class="nested li"><p>When the mouse is released in the zoom region and the zoom is to take place (<code>kEventWindowZoom</code>). </p></li><li class="nested li"><p>When the zoom is completed (<code>kEventWindowZoomed</code>).</p></li></ul></li><li class="li"><p>When a window needs to be updated (redrawn), you can begin to take action at either of the following times:</p><ul class="nested"><li class="nested li"><p>Immediately (<code>kEventWindowUpdate</code>). You must handle all the usual update actions (calling <code>SetPort</code>, <code>BeginUpdate</code>/<code>EndUpdate</code>, drawing) yourself. </p></li><li class="nested li"><p>Only when it is time to draw (<code>kEventWindowDrawContent</code>). The standard handler for <code>kEventWindowUpdate</code> calls <code>SetPort</code> and <code>BeginUpdate</code>/<code>EndUpdate</code> for you. (It also sends the <code>kEventWindowDrawContent</code> event.) </p></li></ul></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_36" title="Note"></a><p><strong>Note:</strong>&nbsp;On Mac OS X, you can view all the events that are sent to your application on-the-fly by setting the environment variable EventDebug<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_95"></a> to 1 in the Terminal application (that is, by entering <code>setenv EventDebug 1</code>) and then launching your application from the command line using the LaunchCFMApp tool. </p></div><a name="//apple_ref/doc/uid/TP30000989-CH203-TPXREF104" title="Executing the Event Loop"></a><h2>Executing the Event Loop</h2><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_96"></a>The Carbon Event Manager provides several ways to execute event loops. The most common method is to simply call the function <code>RunApplicationEventLoop<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_97"></a></code>, which does the following: </p><ul class="ul"><li class="li"><p>Installs the standard application event handler</p></li><li class="li"><p>Puts the application in a suspended state, waiting for events</p></li><li class="li"><p>Places events into the application event queue as they occur</p></li><li class="li"><p>Dispatches the events to your handlers or to standard event handlers</p></li></ul><p>Using <code>RunApplicationEventLoop</code>, the basic structure of a Carbon application is as shown in <span class="content_text">Listing 2-1</span>. </p><a name="//apple_ref/doc/uid/TP30000989-CH203-SW1" title="Listing 2-1Structure of a typical Carbon application"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHFEEFE" title="Listing 2-1Structure of a typical Carbon application"></a><strong>Listing 2-1&nbsp;&nbsp;</strong>Structure of a typical Carbon application</p><div class="codesample"><table><tr><td scope="row"><pre>void main (void)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   // Main function<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   {<span></span></pre></td></tr><tr><td scope="row"><pre>      Initialize (); // Do one-time-only initialization<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>         RunApplicationEventLoop (); // Process events until time to quit<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>      Finalize (); // Do one-time-only finalization<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   }  /* end main */<span></span></pre></td></tr></table></div><p>You would register your event handlers in the <code>Initialize</code> function. Once in the loop, the only actions the application can take are in response to events. </p><p>To break out of the event loop, you must call the <code>QuitApplicationEventLoop<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_98"></a></code> function from whichever event handler handles the quit event. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_37" title="Note"></a><p><strong>Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_99"></a>On Mac OS X, you typically install an Apple event handler to handle the quit event. The <code>RunApplicationEventLoop</code> function installs a simple quit Apple event handler for you, but you may want to install your own if you want to take additional actions (such as displaying a “Save changes before quitting?” dialog). </p></div><p>The <code>RunApplicationEventLoop</code> function works only on the main event loop; if your application creates preemptive threads, each of them will have its own event loop and queue, and you must retrieve and dispatch these events manually. For more information, see <span class="content_text"><a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHBEEIG">“Processing events manually.”</a></span></p><p>Each event loop is represented by an event loop reference, an opaque data object of type <code>EventLoopRef<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_100"></a></code>. A thread can obtain a reference to its own event loop or to the program’s main event loop by calling the functions <code>GetCurrentEventLoop<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_101"></a></code> or <code>GetMainEventLoop<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_102"></a></code>, respectively. </p><p>The function <code>RunCurrentEventLoop<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_103"></a></code> runs the event loop belonging to the currently executing thread for a specified time (which can be infinite). This function can be useful if you want your thread to block for a specified time. During execution, it will place events into the queue and fire timers, but will take no other actions (for example, it won’t dispatch events to handlers). The function <code>QuitEventLoop<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_104"></a></code> terminates a designated event loop.<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_105"></a></p><a name="//apple_ref/doc/uid/TP30000989-CH203-TPXREF105" title="Creating and Registering an Event Handler"></a><h2>Creating and Registering an Event Handler</h2><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_106"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_107"></a>The function for installing an event handler is called <code>InstallEventHandler<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_108"></a></code>:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus InstallEventHandler (EventTargetRef        target,<span></span></pre></td></tr><tr><td scope="row"><pre>                              EventHandlerUPP       handlerProc,<span></span></pre></td></tr><tr><td scope="row"><pre>                              UInt32                numTypes,<span></span></pre></td></tr><tr><td scope="row"><pre>                              const EventTypeSpec*  typeList,<span></span></pre></td></tr><tr><td scope="row"><pre>                              void*                 userData,<span></span></pre></td></tr><tr><td scope="row"><pre>                              EventHandlerRef*      handlerRef);<span></span></pre></td></tr></table></div><p>The second parameter, <code>handlerProc</code>, is a universal procedure pointer (UPP) to your handler routine. The conversion function <code>NewEventHandlerUPP</code> returns a UPP of the required type; for instance,</p><div class="codesample"><table><tr><td scope="row"><pre>EventHandlerUPP  handlerUPP;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>handlerUPP = NewEventHandlerUPP(ThisHandler);<span></span></pre></td></tr></table></div><p>(where <code>ThisHandler</code> is the name of your handler routine). </p><p>The target parameter to <code>InstallEventHandler</code> identifies the event target on which the handler is to be installed. You can obtain a reference to the desired target by calling one of the following functions: <code>GetApplicationEventTarget</code>, <code>GetWindowEventTarget</code>, <code>GetMenuEventTarget</code>, or <code>GetControlEventTarget</code>. </p><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_109"></a>For convenience, The Carbon Event Manager also defines a set of specialized macros, <code>InstallWindowEventHandler</code>, <code>InstallMenuEventHandler</code>, and <code>InstallControlEventHandler</code>, which accept the targeted object as a parameter, obtain the corresponding target reference for you, and pass it to <code>InstallEventHandler</code>. The remaining parameters to these macros are the same as for the <code>InstallEventHandler</code> routine itself. For example, the macro call</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef theWindow;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>InstallWindowEventHandler (theWindow, handlerUPP,<span></span></pre></td></tr><tr><td scope="row"><pre>                           numTypes, typeList,<span></span></pre></td></tr><tr><td scope="row"><pre>                           userData, &amp;handlerRef);<span></span></pre></td></tr></table></div><p>is equivalent to</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef theWindow;<span></span></pre></td></tr><tr><td scope="row"><pre>EventTargetRef theTarget;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>theTarget = GetWindowEventTarget(theWindow);<span></span></pre></td></tr><tr><td scope="row"><pre>InstallEventHandler (theTarget, handlerUPP,<span></span></pre></td></tr><tr><td scope="row"><pre>                     numTypes, typeList,<span></span></pre></td></tr><tr><td scope="row"><pre>                     userData, &amp;handlerRef);<span></span></pre></td></tr></table></div><p>A similar macro, <code>InstallApplicationEventHandler</code>, needs no parameter to identify the application itself as the target; the call</p><div class="codesample"><table><tr><td scope="row"><pre>InstallApplicationEventHandler (handlerUPP,<span></span></pre></td></tr><tr><td scope="row"><pre>                                numTypes, typeList,<span></span></pre></td></tr><tr><td scope="row"><pre>                                userData, &amp;handlerRef);<span></span></pre></td></tr></table></div><p>is equivalent to</p><div class="codesample"><table><tr><td scope="row"><pre>theTarget = GetApplicationEventTarget();<span></span></pre></td></tr><tr><td scope="row"><pre>InstallEventHandler (theTarget, handlerUPP,<span></span></pre></td></tr><tr><td scope="row"><pre>                     numTypes, typeList,<span></span></pre></td></tr><tr><td scope="row"><pre>                     userData, &amp;handlerRef);<span></span></pre></td></tr></table></div><p>In all of these cases, the <code>typeList</code> parameter specifies the event types for which the handler is to be installed. This parameter is nominally declared as a pointer to an event type specifier giving the class and kind of a single event type; but since the C language considers pointers and arrays to be equivalent, it may actually designate an array of such specifiers for more than one type. The <code>numTypes</code> parameter tells how many event types are being specified. For example, the following code installs a single handler for both key-down and key-repeat events:</p><div class="codesample"><table><tr><td scope="row"><pre>EventTypeSpec    eventTypes[2];<span></span></pre></td></tr><tr><td scope="row"><pre>EventHandlerUPP  handlerUPP;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>eventTypes[0].eventClass = kEventClassKeyboard;<span></span></pre></td></tr><tr><td scope="row"><pre>eventTypes[0].eventKind  = kEventRawKeyDown;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>eventTypes[1].eventClass = kEventClassKeyboard;<span></span></pre></td></tr><tr><td scope="row"><pre>eventTypes[1].eventKind  = kEventRawKeyRepeat;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>handlerUPP = NewEventHandlerUPP(KeyboardHandler);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>InstallApplicationEventHandler (handlerUPP,<span></span></pre></td></tr><tr><td scope="row"><pre>                                2, eventTypes,<span></span></pre></td></tr><tr><td scope="row"><pre>                                NULL, NULL);<span></span></pre></td></tr></table></div><p>The <code>userData</code> parameter to <code>InstallEventHandler</code> is a pointer to an arbitrary data value. Any value you supply for this parameter will later be passed back to your handler routine each time it’s called. You can use this capability for any purpose that makes sense to your program; for example, you can use it to pass a window reference to the handler for window events. </p><p>Finally, <code>handlerRef</code> is an output parameter that returns an event handler reference, an opaque object representing the new event handler. The handler reference is needed as a parameter to Carbon routines such as <code>AddEventTypesToHandler</code> and <code>RemoveEventTypesFromHandler</code>, for dynamically changing the event types to which a handler applies, and <code>RemoveEventHandler</code>, for deinstalling it. If you’re not going to be using any of these operations, you can simply pass <code>NULL</code> for the <code>handlerRef</code> parameter, indicating that no handler reference should be returned. In particular, the handler will be disposed of automatically when you dispose of the target object it’s associated with, so there’s no need to call <code>RemoveEventHandler</code> explicitly unless for some reason you want to deinstall the handler while the underlying target object still exists. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_38" title="Important:"></a><p><strong>Important:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_110"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_111"></a>Note that if you install an event handler from a plugin, you must explicitly remove your handler before the plugin unloads. Otherwise, the system may attempt to call event handling code that no longer exists. </p><p></p></div><p><span class="content_text">Listing 2-2</span> shows an initialization function that installs an event handler for window close events.</p><a name="//apple_ref/doc/uid/TP30000989-CH203-SW2" title="Listing 2-2Installing a Carbon event handler"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHDIAJG" title="Listing 2-2Installing a Carbon event handler"></a><strong>Listing 2-2&nbsp;&nbsp;</strong>Installing a Carbon event handler</p><div class="codesample"><table><tr><td scope="row"><pre>#define kWindowTop 100<span></span></pre></td></tr><tr><td scope="row"><pre>#define kWindowLeft 50<span></span></pre></td></tr><tr><td scope="row"><pre>#define kWindowRight 250<span></span></pre></td></tr><tr><td scope="row"><pre>#define kWindowBottom 250<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void Initialize (void)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   // Do one-time-only initialization<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   {<span></span></pre></td></tr><tr><td scope="row"><pre>      WindowRef         theWindow;                 // Reference to window<span></span></pre></td></tr><tr><td scope="row"><pre>      WindowAttributes  windowAttrs;               // Window attribute flags<span></span></pre></td></tr><tr><td scope="row"><pre>      Rect              contentRect;               // Boundary of content region<span></span></pre></td></tr><tr><td scope="row"><pre>      EventTypeSpec     eventType;                 // Specifier for event type<span></span></pre></td></tr><tr><td scope="row"><pre>      EventHandlerUPP   handlerUPP;                // Pointer to event handler routine<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>      windowAttrs = kWindowStandardDocumentAttributes      // Standard document window<span></span></pre></td></tr><tr><td scope="row"><pre>                       | kWindowStandardHandlerAttribute;  // Use standard event handler<span></span></pre></td></tr><tr><td scope="row"><pre>      SetRect (&amp;contentRect, kWindowLeft,  kWindowTop,     // Set content rectangle<span></span></pre></td></tr><tr><td scope="row"><pre>                             kWindowRight, kWindowBottom);<span></span></pre></td></tr><tr><td scope="row"><pre>      CreateNewWindow (kDocumentWindowClass, windowAttrs,  // Create the window<span></span></pre></td></tr><tr><td scope="row"><pre>                       &amp;contentRect, &amp;theWindow);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>      SetWindowTitleWithCFString (theWindow, CFSTR("Happy Cows")); // Set title<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>      eventType.eventClass = kEventClassWindow;          // Set event class<span></span></pre></td></tr><tr><td scope="row"><pre>      eventType.eventKind  = kEventWindowClose;          // Set event kind<span></span></pre></td></tr><tr><td scope="row"><pre>      handlerUPP = NewEventHandlerUPP(DoWindowClose);    // Point to handler<span></span></pre></td></tr><tr><td scope="row"><pre>      InstallWindowEventHandler (theWindow, handlerUPP,  // Install handler<span></span></pre></td></tr><tr><td scope="row"><pre>                                 1, &amp;eventType,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 NULL, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>      ShowWindow (theWindow);                      // Display window on the screen<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>      InitCursor ();                               // Set standard arrow cursor<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   }  /* end Initialize */<span></span></pre></td></tr></table></div>	<p>By specifying the <code>kWindowStandardHandlerAttribute<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_112"></a></code> when we call <code>CreateNewWindow</code>, we automatically install the standard window handlers. Alternatively, you could call the <code>InstallStandardEventHandler</code> function, specifying the window as the event target. <a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_113"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_114"></a></p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_39" title="Important:"></a><p><strong>Important:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_115"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_116"></a>The Carbon Event Manager does not automatically dispose of the event handler UPP, so you should call <code>DisposeEventHandlerUPP</code> when you are done with it. </p><p></p></div><p><span class="content_text">Listing 2-3</span> shows an event handler that can respond to the window close event registered in <span class="content_text">Listing 2-2</span>.</p><a name="//apple_ref/doc/uid/TP30000989-CH203-SW3" title="Listing 2-3A window close event handler"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHEFIAJ" title="Listing 2-3A window close event handler"></a><strong>Listing 2-3&nbsp;&nbsp;</strong>A window close event handler</p><div class="codesample"><table><tr><td scope="row"><pre>pascal OSStatus DoWindowClose (EventHandlerCallRef  nextHandler,<span></span></pre></td></tr><tr><td scope="row"><pre>                               EventRef             theEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                               void*                userData)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   // Handle window close event<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   {<span></span></pre></td></tr><tr><td scope="row"><pre>      DoCloseStuff();                 // Do any interesting stuff<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>      return noErr;                                // Report success<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   }  /* end DoWindowClose */<span></span></pre></td></tr></table></div><p>You should be aware that the Carbon Event Manager provides a standard handler for the window close event, so this example handler is useful only if you wanted to override the standard close behavior. However, installing your own handler can also be useful if you want to augment the standard behavior. For example, you may want to display a dialog asking if the user wants to save changes before letting the standard handler close the window. To do so, you use the function <code>CallNextEventHandler<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_117"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_118"></a></code>.</p><p>The <code>CallNextEventHandler</code> function uses <code>theEventHandlerCallRef</code> parameter (passed to your event handler), which is a pointer to the next event handler in the calling hierarchy. The Carbon Event Manager will relay the event to the next handler after this one in the hierarchy of handlers for the given type of event, continuing up until it finds a handler willing to accept and process the event. A hander that chooses not to handle the event returns <code>eventNotHandledErr</code>, while one that does should return <code>noErr</code> after it has finished processing. Assuming that you have not installed any other window close handlers, <span class="content_text">Listing 2-4</span> shows how you can use <code>CallNextEventHandler</code> to add pre- and post-processing to the standard window close handler. </p><a name="//apple_ref/doc/uid/TP30000989-CH203-SW4" title="Listing 2-4Augmenting the standard window close handler"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHCJECE" title="Listing 2-4Augmenting the standard window close handler"></a><strong>Listing 2-4&nbsp;&nbsp;</strong>Augmenting the standard window close handler</p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_119"></a><div class="codesample"><table><tr><td scope="row"><pre>pascal OSStatus DoWindowClose (EventHandlerCallRef  nextHandler,<span></span></pre></td></tr><tr><td scope="row"><pre>                             EventRef             theEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                             void*                userData)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   // Example event handler to illustrate explicit event propagation<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   {<span></span></pre></td></tr><tr><td scope="row"><pre>      OSStatus  result;                            // Function result<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>      /* Your preprocessing here */                // Do preprocessing<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Now propagate the event to the next handler (in this case the standard)<span></span></pre></td></tr><tr><td scope="row"><pre>      result = CallNextEventHandler (nextHandler, theEvent);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>      if (result == noErr)                         // Did it succeed?<span></span></pre></td></tr><tr><td scope="row"><pre>         {<span></span></pre></td></tr><tr><td scope="row"><pre>            /* Your postprocessing here */         // Do postprocessing<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            /* Note that at this point the  */<span></span></pre></td></tr><tr><td scope="row"><pre>            /* standard handler has removed */<span></span></pre></td></tr><tr><td scope="row"><pre>            /* the window, so any attempts  */<span></span></pre></td></tr><tr><td scope="row"><pre>            /* to access it will cause an   */<span></span></pre></td></tr><tr><td scope="row"><pre>            /* error.                       */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            return noErr;                          // Report success<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>         }  /* end if (result == noErr) */<span></span></pre></td></tr><tr><td scope="row"><pre>      else<span></span></pre></td></tr><tr><td scope="row"><pre>         return result;                            // Report failure<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   }  /* end ThisHandler */<span></span></pre></td></tr></table></div><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_40" title="Important:"></a><p><strong>Important:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_120"></a>Your code should not make any assumptions about how the standard handler behavior for an event is implemented, as this may change in the future. </p><p></p></div><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHEAFCI" title="Event Parameters"></a><h2>Event Parameters</h2><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_121"></a>Many events<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_122"></a> require more information than just the basic event to be truly useful. For example, knowing that the mouse was clicked is usually not very interesting unless you know where the click occurred. This additional information is embedded in the event reference structure, and you need to call the function <code>GetEventParameter<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_123"></a></code> to obtain it. These additional parameters are identified by parameter name and type. <a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_124"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_125"></a>A mouse-down event, for example, has four event parameters:</p><ul class="ul"><li class="li"><p><code>kEventParamMouseLocation</code>, a point (parameter type <code>typeQDPoint</code>) giving the screen coordinates at which the mouse button was pressed</p></li><li class="li"><p><code>kEventParamMouseButton</code>, an integer code (parameter type <code>typeMouseButton</code>) identifying which button was pressed (allowing support for a one-, two-, or three-button mouse)</p></li><li class="li"><p><code>kEventParamKeyModifiers</code>, a set of flag bits (parameter type <code>typeUInt32</code>) telling which modifier keys, if any, were being held down at the time the button was pressed </p></li><li class="li"><p><code>kEventParamClickCount</code>, an integer (parameter type <code>typeUInt32</code>) telling how many times the button was clicked in the same location (1 for a single click, 2 for a double click, and so on) </p></li></ul><p>To obtain the mouse location from the event reference <code>mouseDownEvent</code>, you would make the following call:</p><div class="codesample"><table><tr><td scope="row"><pre>EventRef mouseDownEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>Point wheresMyMouse;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>GetEventParameter (mouseDownEvent, kEventParamMouseLocation, typeQDPoint,<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL, sizeof(Point), NULL, &amp;wheresMyMouse);<span></span></pre></td></tr></table></div><p>The values <code>kEventParamMouseLocation</code> and <code>typeQDPoint</code> specify that you want to obtain the mouse location parameter which is of type <code>Point</code>. (There are also a pair of arguments for returning the actual parameter type and size of the value returned; you can specify <code>NULL</code> for these arguments if you don’t need this information or don’t expect the actual type and size to differ from those requested.) Obviously, certain parameter values only make sense for certain types of events (for example, you couldn’t obtain a mouse location from the event reference for a window update).</p><p>Many events specify a <code>kEventParamDirectObject</code> parameter, which usually indicates the actual object the event acted upon. For example, the direct object parameter for a window activation event (<code>kEventWindowActivated</code>) would be the reference to the window being activated (that is, a <code>WindowRef</code>).</p><p>In some cases, you can modify the behavior of an event by setting the value of one or more event parameters with the related Carbon function <code>SetEventParameter<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_126"></a></code>. For example, if you wanted to snap the window to a particular position as it was being dragged, you could install a handler on the <code>kEventWindowBoundsChanging</code> event (which indicates that the window bounds are changing because of resizing or movement) and use <code>SetEventParameter</code> to set the origin when some condition is met. </p><p> The <em><a href="../../../Reference/Carbon_Event_Manager_Ref/index.html#//apple_ref/doc/uid/TP30000135" target="_top">Carbon Event Manager Reference</a></em> lists the permissible parameters (and the associated values to pass to <code>GetEventParameter</code>) for many event kinds. Documentation for other event parameters is available in the API reference for each technology (such as the<em><a href="../../../Reference/HIObjectReference/index.html#//apple_ref/doc/uid/TP30000783" target="_top"> HIObject Reference</a></em>).</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_41" title="Note"></a><p><strong>Note:</strong>&nbsp;In Mac OS X, all events support the <code>kEventParamPostTarget</code> parameter (<code>typeEventTargetRef)</code>, which lets you indicate to the standard event dispatcher where an event should be sent. </p></div><a name="//apple_ref/doc/uid/TP30000989-CH203-TPXREF106" title="Other Event Attributes"></a><h2>Other Event Attributes</h2><p>In addition to the event parameters, you can obtain other attributes of an event by calling various accessor functions. For example, the functions <code>GetEventClass<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_127"></a></code> and <code>GetEventKind<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_128"></a></code> each accept an event reference as a parameter and return a 32-bit integer representing the event’s class and kind, respectively:</p><div class="codesample"><table><tr><td scope="row"><pre>EventRef  theEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32    eventClass;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32    eventKind;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>eventClass = GetEventClass(theEvent);<span></span></pre></td></tr><tr><td scope="row"><pre>eventKind  = GetEventKind(theEvent);<span></span></pre></td></tr></table></div><p>Similarly, the function <code>GetEventTime<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_129"></a></code> returns the time an event occurred, expressed as a floating point value of type <code>EventTime</code> measured in seconds since the system was started up: </p><div class="codesample"><table><tr><td scope="row"><pre>EventRef   theEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>EventTime  timeInSeconds;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>timeInSeconds = GetEventTime(theEvent);<span></span></pre></td></tr></table></div><p>Another Carbon routine, <code>GetCurrentEventTime<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_130"></a></code>, returns the current time in seconds since system startup: </p><div class="codesample"><table><tr><td scope="row"><pre>EventTime  currentTime;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>currentTime = GetCurrentEventTime();<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_131"></a>The Carbon interface defines a set of convenience constants for expressing event times and intervals:</p><div class="codesample"><table><tr><td scope="row"><pre>#define kEventDurationSecond       1.0<span></span></pre></td></tr><tr><td scope="row"><pre>#define kEventDurationMillisecond  ((EventTime)(kEventDurationSecond / 1000))<span></span></pre></td></tr><tr><td scope="row"><pre>#define kEventDurationMicrosecond  ((EventTime)(kEventDurationSecond<span></span></pre></td></tr><tr><td scope="row"><pre>                                                        / 1000000))<span></span></pre></td></tr><tr><td scope="row"><pre>#define kEventDurationNanosecond   ((EventTime)(kEventDurationSecond<span></span></pre></td></tr><tr><td scope="row"><pre>                                                        / 1000000000))<span></span></pre></td></tr><tr><td scope="row"><pre>#define kEventDurationMinute       kEventDurationSecond * 60<span></span></pre></td></tr><tr><td scope="row"><pre>#define kEventDurationHour         kEventDurationMinute * 60<span></span></pre></td></tr><tr><td scope="row"><pre>#define kEventDurationDay          kEventDurationHour * 24<span></span></pre></td></tr><tr><td scope="row"><pre>#define kEventDurationNoWait       0.0<span></span></pre></td></tr><tr><td scope="row"><pre>#define kEventDurationForever     -1.0<span></span></pre></td></tr></table></div><p>These constants are especially useful when creating event timers. See <span class="content_text"><a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHCJBGE">“Installing Timers”</a></span> for more information. </p><a name="//apple_ref/doc/uid/TP30000989-CH203-CHDIBFIJ" title="Queue-Synchronized Events (Mac OS X v.10.2 and Later)"></a><h2>Queue-Synchronized Events (Mac OS X v.10.2 and Later)</h2><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_132"></a>Beginning with Mac OS X version 10.2, your application can distinguish between two different user event states. The hardware state is the actual state of an input device. The <em>queue-synchronized state</em> is the state of the device according to the events dispatched from the event queue. </p><p>Depending on how long it takes to pop the event off the queue and dispatch it, this queue-synchronized user event may be different from the actual state of the hardware. For example, when the user presses the mouse, a mouse down event is placed into the event queue. If the user releases the mouse immediately while the mouse down event is being handled, then the queue-synchronized mouse button state is still down, but the hardware button state is up. </p><p>In most cases, you should determine the state of a user input device by checking the queue-synchronized state rather than polling the hardware directly. Not only does this method use less processor time, but it also provides a better user experience when using nonhardware input methods to place events in the queue (for example, when taking input through Apple events or speech recognition).</p><a name="//apple_ref/doc/uid/TP30000989-CH203-TPXREF112" title="Obtaining Mouse and Keyboard Modifer States"></a><h3>Obtaining Mouse and Keyboard Modifer States</h3><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_133"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_134"></a>The queue-synchronized state of the mouse button and any keyboard modifiers is determined by state variables set by the event dispatcher. For example, the "mouse button state" variable is set to "down"  when a mouse-down event is dispatched, and it remains in that state until a mouse-up event is dispatched. You can use the following functions to obtain the values of these state variables:</p><ul class="spaceabove"><li class="li"><p><code>GetCurrentEventButtonState<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_135"></a></code> determines the queue-synchronized state of the mouse button(s). You should use this function instead of the <code>Button</code> or <code>GetCurrentButtonState</code> functions.</p><div class="codesample"><table><tr><td scope="row"><pre>UInt32 GetCurrentEventButtonState(void);<span></span></pre></td></tr></table></div><p>Bit zero indicates the state of the primary button, bit one the state of the secondary button, and so on.</p></li><li class="li"><p><code>GetCurrentEventKeyModifiers<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_136"></a></code> determines the queue-synchronized keyboard modifier state. You should use this function instead of <code>EventAvail</code> or <code>GetCurrentKeyModifiers</code>. </p><div class="codesample"><table><tr><td scope="row"><pre>UInt32 GetCurrentEventKeyModifiers(void);<span></span></pre></td></tr></table></div><p>See <span class="content_text"><a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-SW5">Table 2-1</a></span> for a listing of keyboard modifier bits. </p></li></ul><p>Note that <code>GetCurrentEventButtonState</code> and <code>GetCurrentEventKeyModifiers</code> do not return useful values if your application is not active. If your application wants to determine the current mouse or keyboard modifier state while in the background, it  must query the hardware using <code>GetCurrentButtonState<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_137"></a></code> or <code>GetCurrentKeyModifiers<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_138"></a></code>. </p><a name="//apple_ref/doc/uid/TP30000989-CH203-TPXREF113" title="Obtaining the Current User Event"></a><h3>Obtaining the Current User Event</h3><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_139"></a>When a user event is dispatched, the Carbon Event Manager caches it as the current event and disposes of it after the event is handled. The <code>GetCurrentEvent<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_140"></a></code> function retrieves the event currently being dispatched (which could be <code>NULL</code> if the event is not a user event):</p><div class="codesample"><table><tr><td scope="row"><pre>EventRef GetCurrentEvent(void);<span></span></pre></td></tr></table></div><p>You should call this function only from an event handler to determine what user event (if any) triggered the call to your handler.</p><a name="//apple_ref/doc/uid/TP30000989-CH203-TPXREF107" title="Command Events"></a><h2>Command Events</h2><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_141"></a>The Carbon Event Manager has a special class of events that correspond with the command IDs introduced with Mac OS 8.0. A command ID is a location-independent way to identify an action or command. For example, if you associate a command ID with a menu item, a command event is generated whenever that item is selected, whether by mouse selection or keyboard equivalent. If you associate the same ID with a button, then a menu selection, keyboard equivalent command, or button press will all generate the same event. Because standard handlers can take care of much of the busywork (such as toggling the button, flashing the selected menu or menu item), you only need to handle one event for three different types of selection. </p><p>Command events are initially sent to the event target associated with the command. For example, a menu command event is sent to the menu event target, while a command associated with a button is sent to that control. </p><p>Command event handlers can be placed anywhere in the containment hierarchy, but it’s usually convenient to place them at the application level. Doing so allows you to install one handler that can take the event whether it propagates up the containment hierarchy from a control or from a menu. </p><p>Command IDs are 32-bit integers, but they are usually specified as a four-character code. Many common menu items and controls have reserved codes. For example, </p><div class="codesample"><table><tr><td scope="row"><pre>kHICommandOK        = 'ok '; // the OK button (as in a dialog)<span></span></pre></td></tr><tr><td scope="row"><pre>kHICommandCopy      = 'copy';// the Copy menu item<span></span></pre></td></tr><tr><td scope="row"><pre>kHICommandAbout     = 'about';// the About item<span></span></pre></td></tr></table></div><p>If you want to create custom command IDs, you must define them in your application and register them by calling the Menu Manager function <code>SetMenuItemCommandID</code> or the Control Manager function <code>SetControlCommandID</code>, depending on the desired target.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_42" title="Note"></a><p><strong>Note:</strong>&nbsp;If you use the Interface Builder development tool to build your user interface, you can assign command IDs directly to your controls and menus without having to write any code. All you need to do is define and install the proper handlers to process the generated command events. </p></div><p>The event class for commands is <code>kEventClassCommand</code>, and to receive commands to process, the event kind is <code>kEventCommandProcess</code>. The command ID itself is stored in the event reference and you need to call the <code>GetEventParameter</code> function to retrieve it. For example, to handle a (fictitious) menu item Explode, you would need to first define the command ID, register it with the Menu Manager, and then install the handler in your initialization code: </p><div class="codesample"><table><tr><td scope="row"><pre>const MenuCommand kCommandExplode = FOUR_CHAR_CODE ('Boom');<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyInitialize()<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>    …<span></span></pre></td></tr><tr><td scope="row"><pre>    SetMenuItemCommandID (GetMenuRef(mFile), iExplode, kCommandExplode);<span></span></pre></td></tr><tr><td scope="row"><pre>    …<span></span></pre></td></tr><tr><td scope="row"><pre>    EventTypeSpec myEvents = {kEventClassCommand, kEventCommandProcess};<span></span></pre></td></tr><tr><td scope="row"><pre>    InstallApplicationEventHandler(NewEventHandlerUPP(MyEventHandler),<span></span></pre></td></tr><tr><td scope="row"><pre>                                1, &amp;myEvents, 0, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>    …<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>The constant <code>iExplode</code> represents the index value of the Explode item in the File menu. </p><p>This example installs the handler <code>MyEventHandler</code> on the application target, but you can choose a different target if that better suits your needs. </p><p>Your actual event handler needs to obtain the command ID of the Explode command using <code>GetEventParameter</code>. The command ID is stored as the direct object parameter:</p><div class="codesample"><table><tr><td scope="row"><pre>HICommand commandStruct;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>GetEventParameter (event, kEventParamDirectObject,<span></span></pre></td></tr><tr><td scope="row"><pre>                    typeHICommand, NULL, sizeof(HICommand),<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL, &amp;commandStruct);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (commandStruct.commandID == kCommandExplode)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // process explode command<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHEBEIH" title="Text Events"></a><h2>Text Events</h2><p>The Carbon Event Manager provides two ways of obtaining keyboard information: as raw keyboard events, or as text input events. (Text input events are those that have been processed by the Text Services Manager). To avoid conflict with other input methods, you should rely on text input events for handling text.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_43" title="Note"></a><p><strong>Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_142"></a>If your text input needs are modest, you may be able to use the Multilingual Text Engine (MLTE), which does most of the text event handling for you, instead of writing your own handlers. </p></div><p>Text input events are of class <code>kEventClassTextInput</code>, and the event kind used to signify text input is <code>kEventTextInputUnicodeForKeyEvent</code>. Text returned by a text input event may be a character or a string, depending on the circumstances, so you should not make assumptions about its length. For more information about text input methods as well as about event kinds directly related to the Text Services Manager, see the Text Services Manager documentation.</p><p> To obtain the actual text, you need to call the <code>GetEventParameter</code> function, specifying the <code>kEventParamTextInputSendText</code> parameter, as shown in <span class="content_text">Listing 2-5</span></p><a name="//apple_ref/doc/uid/TP30000989-CH203-SW6" title="Listing 2-5Obtaining text from a text input event"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHJIBAE" title="Listing 2-5Obtaining text from a text input event"></a><strong>Listing 2-5&nbsp;&nbsp;</strong>Obtaining text from a text input event</p><div class="codesample"><table><tr><td scope="row"><pre>EventRef     theTextEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>UniChar      *text;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32       actualSize;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>GetEventParameter (theTextEvent, kEventParamTextInputSendText,<span></span></pre></td></tr><tr><td scope="row"><pre>                typeUnicodeText, NULL, 0, &amp;actualSize, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>text = (UniChar*) NewPtr(actualSize);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>GetEventParameter (theTextEvent, kEventParamTextInputSendText,<span></span></pre></td></tr><tr><td scope="row"><pre>                typeUnicodeText, NULL, actualSize, NULL, text);<span></span></pre></td></tr></table></div><p>This example makes two calls to <code>GetEventParameter</code>, the first to obtain the size of the string, and the second to actually obtain it. The rationale for doing so is that the string can be arbitrarily large as it may have resulted from an inline input session intended for a nonRoman script. </p><p>If your application doesn’t support Unicode, you can examine the <code>kEventParamTextSendKeyboardEvent</code> parameter to obtain the raw keyboard event that generated the text event and from that event extract the equivalent Macintosh character codes. </p><p>In rare cases where your application might need to handle individual key presses (for example, for game controls, or if it will perform its own keyboard translation), you may want to obtain the key presses before the Text Services Manager processes them. In such cases, you should install handlers to obtain raw keyboard events (class <code>kEventClassKeyboard</code>).</p><p>In any case, all keyboard and text input events are sent to whichever target currently has the user focus (for example, the window, or the text field control). If desired, you can install an event handler on the <em>user focus event target</em>, which you obtain by calling <code>GetUserFocusEventTarget<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_143"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_144"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_145"></a></code>. All events directed to the current user focus will then be sent to your handler. If you don’t handle the event (or if no handler was installed), the event is then propagated to the actual target that has the user focus. </p><a name="//apple_ref/doc/uid/TP30000989-CH203-TPXREF108" title="Mouse Events"></a><h2>Mouse Events</h2><p>In today’s graphical user interfaces, the mouse provides the user’s primary means of controlling and interacting with the system. All of the user’s actions with the mouse are reported to your program in the form of mouse events.</p><p>All mouse events have parameters named <code>kEventParamMouseLocation</code> and <code>kEventParamKeyModifiers</code> giving, respectively, the location of the mouse cursor on the screen and the modifier keys that were being held down at the time the event occurred. The value of <code>kEventParamMouseLocation</code> is a point giving the horizontal and vertical position of the mouse in global coordinates. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_44" title="Note"></a><p><strong>Note:</strong>&nbsp;Beginning in Mac OS X, v. 10.1, mouse events also support the <code>kEventParamWindowMouseLocation</code> parameter, which returns the mouse position in coordinates local to the window in which the event occurred. </p></div><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_146"></a>The value of the <code>kEventParamKeyModifiers</code> parameter is an unsigned 32-bit integer (type UInt32) containing flag bits corresponding to the various modifier keys. The mask constants shown in <span class="content_text">Table 2-1</span> can be used to extract the bit representing any desired modifier key. A bit value of 1 means that the given key was down when the event occurred; 0 means it was not. Thus, for example, you could use the code in <span class="content_text">Listing 2-6</span> to determine whether the Caps Lock key was down at the time of a mouse event: </p><a name="//apple_ref/doc/uid/TP30000989-CH203-SW7" title="Listing 2-6Obtaining the modifier key for a mouse event"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHBEGEG" title="Listing 2-6Obtaining the modifier key for a mouse event"></a><strong>Listing 2-6&nbsp;&nbsp;</strong>Obtaining the modifier key for a mouse event</p><div class="codesample"><table><tr><td scope="row"><pre>EventRef  theEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32    modifierKeys;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>GetEventParameter (theEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                   kEventParamKeyModifiers,<span></span></pre></td></tr><tr><td scope="row"><pre>                   typeUInt32, NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                   sizeof(modifierKeys), NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                   &amp;modifierKeys);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (modifierKeys &amp; alphaLock)<span></span></pre></td></tr><tr><td scope="row"><pre>/* Caps Lock down */<span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>   /* Caps Lock not down */<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000989-CH203-SW5" title="Table 2-1Mask constants for modifier keys "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHGCJAD" title="Table 2-1Mask constants for modifier keys "></a><strong>Table 2-1&nbsp;&nbsp;</strong>Mask constants for modifier keys </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Mask constant</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Modifier</p></th></tr><tr><td  scope="row"><p><code>cmdKey</code></p></td><td ><p>Command</p></td></tr><tr><td  scope="row"><p><code>shiftKey</code></p></td><td ><p>Shift</p></td></tr><tr><td  scope="row"><p><code>alphaLock</code></p></td><td ><p>Caps Lock</p></td></tr><tr><td  scope="row"><p><code>optionKey</code></p></td><td ><p>Option</p></td></tr><tr><td  scope="row"><p><code>controlKey</code></p></td><td ><p>Control</p></td></tr><tr><td  scope="row"><p><code>kEventKeyModifierNumLockMask</code></p></td><td ><p>Num lock (Mac OS X only)</p></td></tr><tr><td  scope="row"><p><code>kEventKeyModifierFnMask</code></p></td><td ><p>Fn (Function) (Mac OS X only)</p></td></tr></table></div><p>For a complete listing of modifier constants, see the <code>EventModifers</code> enumeration in <code>Events.h</code>.</p><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHDHDJC" title="Mouse Button Events"></a><h3>Mouse Button Events</h3><p>When the user presses or releases the mouse button, it’s reported to your program by a mouse-down or mouse-up event (event kind <code>kEventMouseDown</code> or <code>kEventMouseUp</code>), respectively. Ordinarily, such events are handled by the standard event handler, which analyzes them and converts them into higher-level events representing the meaning of the mouse action, such as <code>kEventWindowClose</code> (when the user clicks a window’s close button), <code>kEventWindowClickContentRgn</code> (when the click is in the window’s contents), <code>kEventControlHit</code> (when it’s in a control such as a push button or checkbox), or <code>kEventCommandProcess</code> (when the user chooses a command from a menu). These higher-level events are usually all your program needs to be concerned with. However, you’re free to intercept the “raw” mouse events and handle them yourself if necessary. </p><p>In addition to the <code>kEventParamMouseLocation</code> and <code>kEventParamKeyModifiers</code> parameters shared by all mouse events, mouse-up and mouse-down events have two additional parameters: <code>kEventParamMouseButton</code> and <code>kEventParamClickCount</code>. The latter is used to identify multiple (for instance, double or triple) mouse clicks, in case your program wishes to assign some special meaning to them. Consecutive presses of the mouse button are considered to constitute a multiple click if they fall within a certain time interval, which is under the user’s control via the Mouse pane of System Preferences (on Mac OS X) or the Mouse control panel (on earlier versions). The Classic Event Manager function <code>GetDblTime</code> returns the current value of this interval, expressed in ticks (sixtieths of a second, the time unit used by earlier versions of Mac OS). When a mouse-down event is separated from the previous such event by more than the multiple-click interval, its <code>kEventParamClickCount</code> parameter is set to 1; if it falls within the double-click interval the parameter is incremented by 1 from that of the previous event. Thus the first event in a multiple click has a click count of 1, the second has a click count of 2, the third 3, and so on. (Triple clicks are the most your program should realistically process.) </p><p>Unlike earlier versions of Mac OS, which were limited to a one-button mouse, Carbon is designed to support multiple mouse buttons. (Theoretically, it can handle as many as 65,535 buttons, though the most you’re likely to encounter in practice is 3.) The <code>kEventParamMouseButton</code> parameter of a mouse-down or mouse-up event identifies which button was pressed or released, using one of the following constants: </p><div class="codesample"><table><tr><td scope="row"><pre>typedef UInt16  EventMouseButton;<span></span></pre></td></tr><tr><td scope="row"><pre>enum<span></span></pre></td></tr><tr><td scope="row"><pre>   {<span></span></pre></td></tr><tr><td scope="row"><pre>      kEventMouseButtonPrimary   = 1,<span></span></pre></td></tr><tr><td scope="row"><pre>      kEventMouseButtonSecondary = 2,<span></span></pre></td></tr><tr><td scope="row"><pre>      kEventMouseButtonTertiary  = 3<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   }; /* end enum */<span></span></pre></td></tr></table></div><p>On a two- or three-button mouse, the left button is normally considered primary and the right button secondary, but left-handed users can reverse these settings as a matter of preference. The middle button on a three-button mouse is always the tertiary button. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_45" title="Important:"></a><p><strong>Important:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_147"></a>The Classic Event Manager includes a number of functions that let you poll the state of the primary mouse button. You should avoid using these functions (<code>Button<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_148"></a></code>, <code>GetMouse<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_149"></a></code>, <code>StillDown<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_150"></a></code>, <code>WaitMouseUp<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_151"></a></code>) (especially on Mac OS X), as they use excessive processor time and slow down the system. Instead of using <code>StillDown</code> or <code>WaitMouseUp</code>, you should use <code>TrackMouseLocation</code> or <code>TrackMouseRegion</code>, which are discussed in <span class="content_text"><a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-TPXREF109">“Tracking Mouse Movements.”</a></span> On Mac OS X 10.2 and later, if you need the current button state, you should use <code>GetCurrentEventButtonState</code> (described in <span class="content_text"><a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CHDIBFIJ">“Queue-Synchronized Events (Mac OS X v.10.2 and Later)”</a></span>)instead of <code>Button</code>. In most cases you’re less interested in the instantaneous state of the button than in its transitions from up to down or vice versa, so it’s better to keep track of the button state with mouse-down and mouse-up events than to poll it directly. This is especially true in the common situation where you want to track the mouse’s movements and take some repeated action for as long as the button is held down.</p><p></p></div><a name="//apple_ref/doc/uid/TP30000989-CH203-TPXREF109" title="Tracking Mouse Movements"></a><h3>Tracking Mouse Movements</h3><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_152"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_153"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_154"></a>The basic task of moving the cursor around on the screen to reflect the physical movements of the mouse is handled for you automatically, with no need for any explicit action on your program’s part. In addition, each time the cursor location changes by as much as one pixel horizontally or vertically, a mouse-moved event (<code>kEventMouseMoved</code>) is generated. If the user is also holding down the mouse button (or any button on a multiple-button mouse), the result is a mouse-dragged event (<code>kEventMouseDragged</code>) instead. Both types of event have the usual <code>kEventParamMouseLocation</code> and <code>kEventParamKeyModifiers</code> parameters, and the mouse-dragged event also has a <code>kEventParamMouseButton</code> parameter to identify the button being held down, as described under <span class="content_text"><a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHDHDJC">“Mouse Button Events.”</a></span></p><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_155"></a>As with the primary mouse button, it’s possible to poll the mouse’s location on the screen directly by calling the Classic Event Manager function <code>GetMouse</code>. However, using this kind of direct polling to track the mouse’s movements is usually not a good idea. For instance, as mentioned above, a common reason for tracking the mouse is to provide visual feedback on the screen during a drag by performing some repeated action for as long as the user holds down the button. Doing this with an active polling loop such as </p><div class="codesample"><table><tr><td scope="row"><pre>while ( WaitMouseUp() )<span></span></pre></td></tr><tr><td scope="row"><pre>   {<span></span></pre></td></tr><tr><td scope="row"><pre>      GetMouse (&amp;mouseLoc);<span></span></pre></td></tr><tr><td scope="row"><pre>      /* Provide feedback based on mouse location */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   } /* end while ( WaitMouseUp() ) */<span></span></pre></td></tr></table></div><p>is horribly inefficient, needlessly tying up the processor while spinning the loop waiting for something to happen. Using mouse-dragged events to do the tracking offers some improvement, since the event loop suspends execution except while actively processing an event and hence consumes no extraneous processor cycles. This allows the idle time to be put to better use running other programs or processes in the background—including any periodic timers you may have installed yourself (see <span class="content_text"><a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHCJBGE">“Installing Timers”</a></span>). However, there is an even better way, using the Carbon Event Manager function <code>TrackMouseLocation<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_156"></a></code>, as shown in <span class="content_text">Listing 2-7</span>.</p><a name="//apple_ref/doc/uid/TP30000989-CH203-SW8" title="Listing 2-7Tracking the mouse with TrackMouseLocation"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHIGBBJ" title="Listing 2-7Tracking the mouse with TrackMouseLocation"></a><strong>Listing 2-7&nbsp;&nbsp;</strong>Tracking the mouse with TrackMouseLocation</p><div class="codesample"><table><tr><td scope="row"><pre>Point                mouseLoc;<span></span></pre></td></tr><tr><td scope="row"><pre>MouseTrackingResult  trackingResult;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>GetMouse (&amp;mouseLoc);<span></span></pre></td></tr><tr><td scope="row"><pre>trackingResult = kMouseTrackingMouseDown;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>while (trackingResult != kMouseTrackingMouseUp)<span></span></pre></td></tr><tr><td scope="row"><pre>   {<span></span></pre></td></tr><tr><td scope="row"><pre>      /* Provide feedback based on mouse location */<span></span></pre></td></tr><tr><td scope="row"><pre>      TrackMouseLocation (NULL, &amp;mouseLoc, &amp;trackingResult);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   } /* end while (trackingResult != kMouseTrackingMouseUp) */<span></span></pre></td></tr></table></div><p>The call to <code>TrackMouseLocation</code> suspends execution until either the mouse’s location or button state changes. It then returns, in its second and third parameters, the coordinates of the new mouse location and a tracking result indicating the nature of the mouse occurrence. (The first parameter specifies a graphics port in whose coordinate system to report the mouse location; passing <code>NULL</code> for this parameter designates the current port, which is usually what you want.) The tracking result returned is one of the following values: </p><div class="codesample"><table><tr><td scope="row"><pre>typedef UInt16  MouseTrackingResult;<span></span></pre></td></tr><tr><td scope="row"><pre>enum<span></span></pre></td></tr><tr><td scope="row"><pre>   {<span></span></pre></td></tr><tr><td scope="row"><pre>        kMouseTrackingMouseDown = 1,<span></span></pre></td></tr><tr><td scope="row"><pre>        kMouseTrackingMouseUp = 2,<span></span></pre></td></tr><tr><td scope="row"><pre>        kMouseTrackingMouseExited   = 3,<span></span></pre></td></tr><tr><td scope="row"><pre>        kMouseTrackingMouseEntered  = 4,<span></span></pre></td></tr><tr><td scope="row"><pre>        kMouseTrackingMouseDragged = 5,<span></span></pre></td></tr><tr><td scope="row"><pre>        kMouseTrackingKeyModifiersChanged = 6,<span></span></pre></td></tr><tr><td scope="row"><pre>        kMouseTrackingUserCancelled = 7,<span></span></pre></td></tr><tr><td scope="row"><pre>        kMouseTrackingTimedOut = 8,<span></span></pre></td></tr><tr><td scope="row"><pre>        kMouseTrackingMouseMoved = 9<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   }; /* end enum */<span></span></pre></td></tr></table></div><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_46" title="Important:"></a><p><strong>Important:</strong>&nbsp;The <code>kMouseTrackingMouseMoved</code> constant has been repurposed for Mac OS X v.10.2 and later. In earlier system software versions, <code>kMouseTrackingMouseMoved</code> was equivalent to the <code>kMouseTrackingMouseDragged</code> result, indicating that the mouse was moved while the mouse button was <em>down</em>. In Mac OS X v.10.2. and later, you receive the <code>kMouseTrackingMouseMoved</code> tracking result if the user moves the mouse while the mouse button is <em>up</em>. If you have code that interprets <code>kMouseTrackingMouseMoved</code> in its older sense, you should update it before running it on Mac OS X v.10.2 or later.</p><p></p></div><p>The tracking results <code>kMouseTrackingExited</code> and <code>kMouseTrackingEntered</code> are used by another related Carbon routine, <code>TrackMouseRegion</code>. This is typically called after a mouse press in a control (such as a checkbox or a window’s close button), to track the mouse’s movements in and out of the control so you can provide appropriate visual feedback by highlighting and unhighlighting the control accordingly. The standard event handler ordinarily does all this for you and reports the result with a higher-level event such as <code>kEventWindowClose</code>, <code>kEventWindowZoom</code>, or <code>kEventControlHit</code>; but you may occasionally encounter a situation where you need to make the <code>TrackMouseRegion</code> call and process the results yourself. </p><p><span class="content_text">Listing 2-8</span> shows a code fragment illustrating how to use <code>TrackMouseRegion<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_157"></a></code> to respond to a mouse press in a control. </p><a name="//apple_ref/doc/uid/TP30000989-CH203-SW9" title="Listing 2-8Tracking the mouse in a region"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHDJGFG" title="Listing 2-8Tracking the mouse in a region"></a><strong>Listing 2-8&nbsp;&nbsp;</strong>Tracking the mouse in a region</p><div class="codesample"><table><tr><td scope="row"><pre>RgnHandle            controlRegion;                // Region occupied by control<span></span></pre></td></tr><tr><td scope="row"><pre>Boolean              isInRegion;                   // Mouse released in region?<span></span></pre></td></tr><tr><td scope="row"><pre>MouseTrackingResult  trackingResult;               // Tracking result<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Set controlRegion to control's region */        // Indicate region<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>trackingResult = kMouseTrackingMouseEntered;       // Initialize for first<span></span></pre></td></tr><tr><td scope="row"><pre>                                                  // pass of loop<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>while (trackingResult != kMouseTrackingMouseUp) // Loop until released<span></span></pre></td></tr><tr><td scope="row"><pre>   {<span></span></pre></td></tr><tr><td scope="row"><pre>      switch (trackingResult)                      // Dispatch on tracking result<span></span></pre></td></tr><tr><td scope="row"><pre>         {<span></span></pre></td></tr><tr><td scope="row"><pre>            case kMouseTrackingMouseEntered:       // Highlight on entry<span></span></pre></td></tr><tr><td scope="row"><pre>               /* Highlight control */<span></span></pre></td></tr><tr><td scope="row"><pre>               break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            case kMouseTrackingMouseExited:        // Unhighlight on exit<span></span></pre></td></tr><tr><td scope="row"><pre>               /* Unhighlight control */<span></span></pre></td></tr><tr><td scope="row"><pre>               break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>         } /* end switch (trackingResult) */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>      TrackMouseRegion (NULL, controlRegion,       // Track mouse in region<span></span></pre></td></tr><tr><td scope="row"><pre>                        &amp;isInRegion,<span></span></pre></td></tr><tr><td scope="row"><pre>                        &amp;trackingResult);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   } /* end while (trackingResult != kMouseTrackingMouseUp) */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (isInRegion)                                    // Released in region?<span></span></pre></td></tr><tr><td scope="row"><pre>   /* Perform associated action */                 // Take action in response<span></span></pre></td></tr></table></div><p>You call <code>TrackMouseRegion</code> repeatedly for as long as the mouse button remains down, passing as a parameter a region representing the area the control occupies on the screen. Each time the mouse crosses the boundary in or out of the specified region, <code>TrackMouseRegion</code> returns with a tracking result of <code>kMouseTrackingEntered</code> or <code>kMouseTrackingExited</code>, indicating whether to highlight or unhighlight the control. (Mere mouse movements that don’t cross the region boundary are not reported.) When the mouse button is released, <code>TrackMouseRegion</code> returns the tracking result <code>kMouseTrackingMouseReleased</code> along with a Boolean value indicating whether the button was released inside or outside the region; you can then use this information to determine whether to perform the action associated with the control.</p><a name="//apple_ref/doc/uid/TP30000989-CH203-CHDEDIHB" title="Mouse Tracking Regions (Mac OS X v.10.2 and Later)"></a><h3>Mouse Tracking Regions (Mac OS X v.10.2 and Later)</h3><p>In Mac OS X version 10.2 and later, you can designate special mouse tracking regions within windows. When the mouse enters one of these regions, your application receives a <code>kEventMouseEntered</code> event (<code>kEventClassMouse</code>). When the mouse leaves, the application receives a <code>kEventMouseExited</code> event. A window can contain any number of regions; each mouse tracking region has a unique ID, which makes it easy to determine which region was entered. If desired, you can also temporarily disable a region. </p><p>Mouse tracking regions make it simple to implement various rollover effects such as highlighting a clickable area, or changing the cursor when it enters a region. If you must use processor-intensive polling for mouse locations (for example, in a drawing program), you can use mouse tracking regions to allow pollling only within particular regions of interest. </p><p>To create a mouse tracking region, you call the <code>CreateMouseTrackingRegion<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_158"></a></code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus CreateMouseTrackingRegion (WindowRef inWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>                            RgnHandle inRegion,<span></span></pre></td></tr><tr><td scope="row"><pre>                            RgnHandle inClip,<span></span></pre></td></tr><tr><td scope="row"><pre>                            MouseTrackingOptions inOptions,<span></span></pre></td></tr><tr><td scope="row"><pre>                            MouseTrackingRegionID inID,<span></span></pre></td></tr><tr><td scope="row"><pre>                            void* inRefCon,<span></span></pre></td></tr><tr><td scope="row"><pre>                            EventTargetRef inTargetToNotify,<span></span></pre></td></tr><tr><td scope="row"><pre>                            MouseTrackingRef* outTrackingRef);<span></span></pre></td></tr></table></div><ul class="spaceabove"><li class="li"><p>The <code>inWindow</code> parameter indicates which window owns this region. Mouse tracking regions are always bound to a particular window. </p></li><li class="li"><p>The <code>inRegion</code> parameter is a standard region handle defining the tracking region. </p></li><li class="li"><p>The <code>inClip</code> parameter specifies an optional clip region. If the clip region is valid (that is, you don’t pass <code>NULL)</code>, the active tracking region is the intersection of the tracking region and the clip region. </p></li><li class="li"><p>For mouse tracking options you can pass either <code>kMouseTrackingOptionsLocalClip</code> or <code>kMouseTrackingOptionsGlobalClip</code>:</p><ul class="nested"><li class="nested li"><p><code>kMouseTrackingOptionsLocalClip</code> indicates that the region is defined in local coordinates and that the region is clipped to the owning windows’s content region. </p></li><li class="nested li"><p><code>kMouseTrackingOptionsGlobalClip</code> indicates the region is defined in global coordinates and that the region is clipped to the owning window’s structure region. </p></li></ul></li><li class="li"><p>The <code>inID</code> parameter holds a unique mouse tracking ID, which is a combination of an <code>OSType</code>, which is a four-character code that uniquely defines your application, and an integer:</p><div class="codesample"><table><tr><td scope="row"><pre>struct MouseTrackingRegionID {<span></span></pre></td></tr><tr><td scope="row"><pre>                    OSType signature;<span></span></pre></td></tr><tr><td scope="row"><pre>                    SInt32 id;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>If you have not already done so, you can register an application signature with Apple Developer Technical Support. </p></li><li class="li"><p>If you want to associate any application-specific data with this region, you can pass it in the <code>inRefCon</code> parameter. </p></li><li class="li"><p>The <code>inTargetToNotify</code> parameter is currently unused; pass <code>NULL</code>.</p></li></ul><p>On return, you receive a mouse tracking reference which you can pass to additional mouse tracking region functions. This reference is also included in the event reference for the <code>kEventMouseEntered</code> and <code>kEventMouseExited</code> events. Use the <code>GetEventParameter</code> function to obtain the direct object parameter.</p><p>Additional useful mouse tracking region functions include the following: </p><ul class="spaceabove"><li class="li"><p>To dispose of a tracking region, use the <code>ReleaseMouseTrackingRegion<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_159"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus ReleaseMouseTrackingRegion (MouseTrackingRef inMouseRef);<span></span></pre></td></tr></table></div><p>Note that because mouse tracking regions are associated with a window, disposing the window will also dispose of its tracking regions. </p></li><li class="li"><p>To increase the reference count of a tracking region, call the <code>RetainMouseTrackingRegion<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_160"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus RetainMouseTrackingRegion (MouseTrackingRef inMouseRef);<span></span></pre></td></tr></table></div><p>Calling <code>ReleaseMouseTrackingRegion<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_161"></a></code> decrements the reference count; if the count reaches 0, the tracking region is disposed. </p></li><li class="li"><p>To obtain the ID of a mouse tracking region, call the <code>GetMouseTrackingRegionID<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_162"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus GetMouseTrackingRegionID (MouseTrackingRef inMouseRef,<span></span></pre></td></tr><tr><td scope="row"><pre>                                MouseTrackingRegionID* outID);<span></span></pre></td></tr></table></div></li><li class="li"><p>To enable or disable a mouse tracking region, call the <code>SetMouseTrackingRegionEnabled<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_163"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus SetMouseTrackingRegionEnabled (MouseTrackingRef inMouseRef,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        Boolean inEnabled);<span></span></pre></td></tr></table></div><p>You can use this function to adjust tracking regions that are dependent on the state of your application. </p></li><li class="li"><p>To obtain the application-specific data associated with the tracking region, call the <code>GetMouseTrackingRegionRefCon<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_164"></a></code> function:<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_165"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_166"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_167"></a></p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus GetMouseTrackingRegionRefCon (MouseTrackingRef inMouseRef,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        void** outRefCon);<span></span></pre></td></tr></table></div></li></ul><p>Mac OS X v10.4 introduced new HIView-based tracking region functions. These work much like the older mouse tracking regions, with the following exceptions:</p><ul class="spaceabove"><li class="li"><p>You create these tracking areas on a per-view, rather than per-window basis. </p></li><li class="li"><p>The tracking areas are described using HIShape objects rather than QuickDraw regions.</p></li><li class="li"><p>The tracking area is identified by a <code>UInt64</code> integer rather than a data structure. </p></li><li class="li"><p>The area entered and exited events are <code>kEventControlTrackingAreaEntered</code> and <code>kEventControlTrackingAreaExited</code> respectively. You obtain the tracking area reference in the <code>kEventParamHIViewTrackingArea</code> parameter (<code>typeHIViewTrackingAreaRef</code>).</p></li></ul><p>To create a view-based tracking area, call the <code>HIViewNewTrackingArea</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewNewTrackingArea(<span></span></pre></td></tr><tr><td scope="row"><pre>  HIViewRef                inView,<span></span></pre></td></tr><tr><td scope="row"><pre>  HIShapeRef               inShape,       /* can be NULL */<span></span></pre></td></tr><tr><td scope="row"><pre>  HIViewTrackingAreaID     inID,<span></span></pre></td></tr><tr><td scope="row"><pre>  HIViewTrackingAreaRef *  outRef)<span></span></pre></td></tr></table></div><p>To modify a tracking area, call <code>HIViewChangeTrackingArea</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewChangeTrackingArea(<span></span></pre></td></tr><tr><td scope="row"><pre>  HIViewTrackingAreaRef   inArea,<span></span></pre></td></tr><tr><td scope="row"><pre>  HIShapeRef              inShape)<span></span></pre></td></tr></table></div><p>To obtain an area’s ID, call <code>HIViewGetTrackingAreaID</code>:</p><div class="codesample"><table><tr><td scope="row"><pre> OSStatus HIViewGetTrackingAreaID(<span></span></pre></td></tr><tr><td scope="row"><pre>   HIViewTrackingAreaRef   inArea,<span></span></pre></td></tr><tr><td scope="row"><pre>   HIViewTrackingAreaID *  outID)<span></span></pre></td></tr></table></div><p>To dispose of a tracking area, call <code>HIViewDisposeTrackingArea</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewDisposeTrackingArea (HIViewTrackingAreaRef inArea)<span></span></pre></td></tr></table></div><p>If possible, you should use view-based tracking areas in place of the older tracking regions. </p><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHCJBGE" title="Installing Timers"></a><h2>Installing Timers</h2><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_168"></a>Installing a timer<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_169"></a> is similar to installing an event handler. Timers are associated with a particular event loop (usually the program’s main loop), and they fire as the loop runs. Instead of a list of event types, you specify an initial delay before the timer fires for the first time and a timer interval between subsequent firings, both expressed in seconds. (<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_170"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_171"></a>Setting the timer interval to 0 produces a one-shot timer that will fire only once, at the expiration of the initial delay.) As in installing an event handler, you can also supply an arbitrary item of user data that will be passed back to your timer routine each time it’s called. The timer routine itself is identified with a universal procedure pointer of type <code>EventLoopTimerUPP</code>, obtained using the conversion function <code>NewEventLoopTimerUPP</code>. <span class="content_text">Listing 2-9</span> shows how to install a timer routine named <code>TimerAction</code> in the program’s main event loop with an initial delay of 5 seconds, a timer interval of 1 second, and no user data item</p><a name="//apple_ref/doc/uid/TP30000989-CH203-SW10" title="Listing 2-9Installing a timer"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHFJCCH" title="Listing 2-9Installing a timer"></a><strong>Listing 2-9&nbsp;&nbsp;</strong>Installing a timer</p><div class="codesample"><table><tr><td scope="row"><pre>EventLoopRef       mainLoop;<span></span></pre></td></tr><tr><td scope="row"><pre>EventLoopTimerUPP  timerUPP;<span></span></pre></td></tr><tr><td scope="row"><pre>EventLoopTimerRef  theTimer;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>mainLoop = GetMainEventLoop();<span></span></pre></td></tr><tr><td scope="row"><pre>timerUPP = NewEventLoopTimerUPP(TimerAction);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>InstallEventLoopTimer (mainLoop,<span></span></pre></td></tr><tr><td scope="row"><pre>                       5*kEventDurationSecond,<span></span></pre></td></tr><tr><td scope="row"><pre>                       kEventDurationSecond,<span></span></pre></td></tr><tr><td scope="row"><pre>                       timerUPP,<span></span></pre></td></tr><tr><td scope="row"><pre>                       NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                       &amp;theTimer);<span></span></pre></td></tr></table></div><p>The last parameter of the <code>InstallEventLoopTimer<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_172"></a></code> function is an output parameter that returns a <em>timer reference</em> representing the timer just installed. This value is needed as a parameter to various Carbon Event Manager functions that operate on timers, the most important of which is <code>RemoveEventLoopTimer</code>, for uninstalling the timer. This same timer reference will also be passed automatically to your timer routine each time it’s called.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_47" title="Important:"></a><p><strong>Important:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_173"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_174"></a>As with the <code>InstallEventHandler</code> function, if you are installing a timer from a plugin, you must explicitly remove the timer before your plugin is unloaded. Otherwise, the still-existent timer may attempt to call code that no longer exists. </p><p></p></div><p>The timer routine itself must have the following prototype: </p><div class="codesample"><table><tr><td scope="row"><pre>pascal void TimerAction (EventLoopTimerRef  theTimer,<span></span></pre></td></tr><tr><td scope="row"><pre>                         void* userData);<span></span></pre></td></tr></table></div><p>where <code>theTimer</code> is the timer reference identifying the timer and <code>userData</code> is the data value you supplied at the time the timer was installed. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_48" title="Note"></a><p><strong>Note:</strong>&nbsp;A timer fires only when the low-level event loop (which fetches events and places them on the event queue) is actually running. For example, if you start a timer that is set to fire in 1 second, then call a handler that does some computation for 5 seconds, the timer will not fire until you complete the calculation and return to the event loop. The following Carbon Event Manager and Classic Event Manager functions will run an event loop: <code>RunApplicationEventLoop</code>, <code>ReceiveNextEvent</code>, <code>RunCurrentEventLoop</code>, <code>WaitNextEvent</code>, <code>GetNextEvent</code>, and <code>EventAvail</code>. </p></div><p>One more useful function is <code>SetEventLoopTimerNextFireTime<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_175"></a></code>, which resets the interval until the next time the timer fires. For example, if <code>theTimer</code> is the timer installed in the example above, the call </p><div class="codesample"><table><tr><td scope="row"><pre>SetEventLoopTimerNextFireTime (theTimer, kEventDurationMinute);<span></span></pre></td></tr></table></div><p>will cause the timer to “sleep” for one minute and then resume its one-second firing cycle. The effect is equivalent to deinstalling the timer and then reinstalling it with a new initial delay and the same timer interval.</p><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_176"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_177"></a>A variant of the basic timer is the idle timer, which is available in Mac OS X v.10.2 and later. The idle timer functions just like a normal timer except that it does not fire until the user has been inactive for the initial delay time. Such timers are useful for letting the application know that it is safe to do some processing without interfering with the user. For example, if the user is entering text into a search field, you should wait for a second or two after the user has stopped typing before beginning the search. </p><p>To install an idle timer, you call the <code>InstallEventLoopIdleTimer<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_178"></a></code> function, which has the same format as the basic <code>InstallEventLoopTimer</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus InstallEventLoopIdleTimer(<span></span></pre></td></tr><tr><td scope="row"><pre>                            EventLoopRef         inEventLoop,<span></span></pre></td></tr><tr><td scope="row"><pre>                            EventTimerInterval   inFireDelay,<span></span></pre></td></tr><tr><td scope="row"><pre>                            EventTimerInterval   inInterval,<span></span></pre></td></tr><tr><td scope="row"><pre>                            EventLoopIdleTimerUPP    inTimerProc,<span></span></pre></td></tr><tr><td scope="row"><pre>                            void *               inTimerData,<span></span></pre></td></tr><tr><td scope="row"><pre>                            EventLoopTimerRef *  outTimer);<span></span></pre></td></tr></table></div><p>The only difference is that the timer callback routine takes an additional <code>EventIdleAction</code> parameter indicating the idle status:</p><div class="codesample"><table><tr><td scope="row"><pre>pascal void IdleTimerAction (EventLoopTimerRef inTimer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                void *inUserData,<span></span></pre></td></tr><tr><td scope="row"><pre>                                EventIdleAction inAction );<span></span></pre></td></tr></table></div><p>When your idle timer routine is called, it is passed one of three constants indicating the current idle status:</p><div class="codesample"><table><tr><td scope="row"><pre>enum<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    kEventLoopIdleTimerStarted,<span></span></pre></td></tr><tr><td scope="row"><pre>    kEventLoopIdleTimerIdling,<span></span></pre></td></tr><tr><td scope="row"><pre>    kEventLoopIdleTimerStopped<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>EventIdleAction;<span></span></pre></td></tr></table></div><ul class="ul"><li class="li"><p><code>kEventLoopIdleTimerStarted<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_179"></a></code> indicates that the idle period has just begun (and this is the first time your callback is being called for this period).</p></li><li class="li"><p><code>kEventLoopIdleTimerIdling<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_180"></a></code> indicates that your callback is being called in the middle of an idle period. </p></li><li class="li"><p><code>kEventLoopIdleTimerStopped<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_181"></a></code> is sent to your callback function when the idle period ends (for example, when the user hits a key). </p></li></ul><p>For example, say your application wants to calculate the value of pi. When your callback function receives the <code>kEventLoopIdleTimerStarted</code> constant, you create a special pi calculation object. Each time you receive <code>kEventLoopIdleTimerIdling</code>, you call an object method to calculate the next digit. When you receive <code>kEventLoopIdleTimerStopped</code>, you store the currently calculated value of pi and dispose of the pi calculation object.<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_182"></a></p><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHFIHIF" title="Processing Events Manually"></a><h2>Processing Events Manually</h2><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_183"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_184"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_185"></a>In most cases, using the <code>RunApplicationEventLoop</code> function to collect and dispatch events is the simplest and most practical way to handle events. However, sometimes you may want more control over the event collection and dispatching mechanism, or you may need to process events that don’t occur in the main application thread. In cases like these, you can call other Carbon Event Manager functions to manually collect and dispatch your events. </p><p>The <code>RunApplicationEventLoop</code> function itself calls several Carbon Event Manager functions to accomplish its task:</p><ul class="ul"><li class="li"><p><code>ReceiveNextEvent<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_186"></a></code> runs the low-level event loop, placing events as they occur into the event queue. The function returns when an event you specified occurs, or when the specified timeout is exceeded.</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus ReceiveNextEvent(<span></span></pre></td></tr><tr><td scope="row"><pre>            UInt32 inNumTypes,<span></span></pre></td></tr><tr><td scope="row"><pre>            const EventTypeSpec *inList,<span></span></pre></td></tr><tr><td scope="row"><pre>            EventTimeout inTimeout,<span></span></pre></td></tr><tr><td scope="row"><pre>            Boolean inPullEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>            EventRef *outEvent);<span></span></pre></td></tr></table></div><ul class="nested"><li class="nested li"><p>The <code>inNumTypes</code> parameter specifies the number of events for which <code>ReceiveNextEvent</code> should return. Passing 0 indicates you want to return on all events. </p></li><li class="nested li"><p>The <code>inList</code> parameter points to the <code>EventTypeSpec</code> structure or array containing the class and kind of events to return on. Passing <code>NULL</code> indicates that you want to return on all events. </p></li><li class="nested li"><p>The <code>inTimeout</code> parameter is the duration to wait before timing out. </p></li><li class="nested li"><p>The <code>inPull</code> parameter specifies if whether you want <code>ReceiveNextEvent</code> to pull the event off the queue when it returns. Passing <code>true</code> causes the event to be pulled. If you pass <code>false</code>, <code>ReceiveNextEvent</code> only peeks at the event to determine its type. You still can dispatch the event, but it remains on the queue.</p></li><li class="nested li"><p>On return, <code>outEvent</code> contains the event that caused <code>ReceiveNextEvent</code> to return.</p></li></ul></li><li class="li"><p><code>GetEventDispatcherTarget<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_187"></a></code> gets the event target reference for the <em>standard toolbox dispatcher</em><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_188"></a>, which is the default target for all events. The toolbox dispatcher determines the proper target for each event (window, control, and so on) and sends the event there. Note that because the toolbox dispatcher is itself a valid event target, you can actually attach a handler to it. Such a handler can intercept an event before it gets sent on to the actual event target. </p></li><li class="li"><p><code>SendEventToEventTarget<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_189"></a></code> dispatches the event to the appropriate event target. </p></li><li class="li"><p><code>ReleaseEvent</code> releases the event (disposing of it if necessary). </p></li></ul><p><span class="content_text">Listing 2-10</span> shows how you can use these calls to implement the basic functionality of <code>RunApplicationEventLoop</code>.</p><a name="//apple_ref/doc/uid/TP30000989-CH203-SW11" title="Listing 2-10Processing events manually"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHBEEIG" title="Listing 2-10Processing events manually"></a><strong>Listing 2-10&nbsp;&nbsp;</strong>Processing events manually</p><div class="codesample"><table><tr><td scope="row"><pre>EventRef theEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>EventTargetRef theTarget;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>theTarget = GetEventDispatcherTarget();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while  (ReceiveNextEvent(0, NULL,kEventDurationForever,true,<span></span></pre></td></tr><tr><td scope="row"><pre>            &amp;theEvent)== noErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            SendEventToEventTarget (theEvent, theTarget);<span></span></pre></td></tr><tr><td scope="row"><pre>            ReleaseEvent(theEvent);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr></table></div><p>The <code>ReceiveNextEvent</code> function is blocked forever (<code>kEventDurationForever</code>) until an event occurs. Specifying zero and null for the first two parameters indicates that <code>ReceiveNextEvent</code> should return on all events. (Alternatively, you could specify that the function wait only for particular events). Passing <code>true</code> in the third parameter indicates that the application should take ownership of the event (which means it is pulled off the event queue). </p><p>After an event occurs, we dispatch it to the event dispatcher target, which automatically sends it to the proper event target. Because the application owns the event, the application is then responsible for releasing it by calling <code>ReleaseEvent<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_190"></a></code>. (There is also a complementary function <code>RetainEvent<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_191"></a></code>, which you can use to increment the reference count of the event, thus ensuring that it will not get disposed before you are finished with it.)</p><p>The only drawback to making your own event loop dispatching calls in the main application thread is that you won’t get the standard application event handler installed. Specifically, the <code>RunApplicationEventLoop</code> function installs handlers to do the following:</p><ul class="ul"><li class="li"><p>Allow clicks in the menu bar to begin menu tracking</p></li><li class="li"><p>Dispatch <a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_192"></a>Apple events by calling <code>AEProcessAppleEvent</code></p></li><li class="li"><p>Respond to quit Apple events by quitting <code>RunApplicationEventLoop</code>. </p></li></ul><p>One way to work around this limitation is by creating a dummy custom event handler. When you are ready to process events, create the dummy event yourself, post it to the queue. and then call <code>RunApplicationEventLoop</code> (to install the standard application event handler). The dummy event handler can then process the events manually. For an example of using this method, see <span class="content_text"><a href="http://developer.apple.com/qa/qa2001/qa1061.html" target="_top">Technical Q&amp;A 1061</a></span> in Developer Documentation Technical Q&amp;As.</p><a name="//apple_ref/doc/uid/TP30000989-CH203-TPXREF110" title="Creating Your Own Events"></a><h2>Creating Your Own Events</h2><p>In addition to processing and dispatching events, the Carbon Event Manager also lets you create your own events. You may want to create your own custom events, or you might want to reproduce standard events. </p><p>You create an event using the <code>CreateEvent<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_193"></a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus CreateEvent( CFAllocatorRef inAllocator&lt;null>,<span></span></pre></td></tr><tr><td scope="row"><pre>                    UInt32 inClassID, UInt32 kind,EventTime when,<span></span></pre></td></tr><tr><td scope="row"><pre>                    EventAttributes flags, EventRef* outEvent);<span></span></pre></td></tr></table></div><ul class="ul"><li class="li"><p>The <code>inAllocator</code> parameter refers to the allocator you want to use to allocate memory for the event. You can pass <code>NULL</code> to specify the default allocator.</p></li><li class="li"><p>The <code>inClassID</code> and <code>kind</code> parameters indicate the event class and kind. If you are creating custom events, you need to define new values that don’t conflict with existing event classes and kinds. And, of course, you must specify this class and kind when your register a handler to process this type of event. </p></li><li class="li"><p>The <code>when</code> parameter indicates when the event occurred. You can pass 0 to specify the current event time (as returned by the <code>GetCurrentEventTime</code> function). This value may or may not be useful for custom events. </p></li><li class="li"><p>The <code>flags</code> parameter indicates any event attributes you may want to set. The current choices are <code>kEventAttributeNone</code> and <code>kEventAttributeUserEvent</code>. </p></li><li class="li"><p>On return, <code>outEvent</code> contains the newly-created event reference. </p></li></ul><p>If your event requires additional information, you can add data by calling <code>SetEventParameter</code>. If you are creating custom events, you need to define constants for your parameter names and types if they don’t already exist. For example, if you define a parameter for a screen location, you may want to define a new parameter name, but you can probably still use <code>typeQDPoint</code> for the parameter type. </p><p>Once you create an event, you need to send it to a handler. There are two basic methods for doing so:</p><ul class="ul"><li class="li"><p>You can post the event to a queue by calling the <code>PostEventToQueue<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_194"></a></code> function. You need to obtain the queue reference for the queue you want to post to by calling either <code>GetCurrentEventQueue</code> (which returns the current thread’s queue) or <code>GetMainEventQueue</code> (which returns the queue for the main application thread). The event you post will not be processed until it is pulled from the queue and dispatched to the appropriate event target.</p><p>Note that in Mac OS X, you can indicate in the event reference where a posted event should be dispatched by specifying a <code>kEventParamPostTarget<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_195"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_196"></a></code> event parameter. </p></li><li class="li"><p>You can send it directly to the desired event target by calling <code>SendEventToEventTarget<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_197"></a></code>. If this is a custom event, the target you choose should be the one to which you attached your custom event handler. Dispatching the event yourself will ensure that your handler is called immediately. </p></li></ul><p>Note that if you send an event to the standard toolbox dispatcher and it does not recognize it (that is, it’s a custom event), then it will dispatch the event to the application event target (unless you specified an event target in your custom event using the <code>kEventParamPostTarget</code> parameter). </p><p>If you want to create and process command events, the Carbon Event Manager provides the function <code>ProcessHICommand<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_198"></a></code>:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus ProcessHICommand (const HICommand* inCommand);<span></span></pre></td></tr></table></div><p>When you pass an Command ID to <code>ProcessHICommand</code>, it builds a <code>kEventCommandProcess</code> event containing the ID and then dispatches the event to either</p><ul class="ul"><li class="li"><p>a menu, if the command is defined in a menu, or</p></li><li class="li"><p>the current user focus</p></li></ul><a name="//apple_ref/doc/uid/TP30000989-CH203-CIHJICGJ" title="Carbon Events in Multiple Threads"></a><h2>Carbon Events in Multiple Threads</h2><p>The Carbon Event Manager scales to work with multiple execution threads. If you are creating cooperative threads, each thread shares the main application event loop and queue, so your event handling mechanism does not change. However, the <code>RunApplicationEventLoop</code> function never explicitly yields to other threads, so you should create a timer that will call the Thread Manager function <code>YieldToAnyThread<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_199"></a><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_200"></a></code> as necessary. </p><p>If you create preemptively-scheduled threads, each such thread contains its own event queue and needs to be processed independently. </p><p>Because <code>RunApplicationEventLoop</code> works only for the main execution thread, any preemptive threads you create should use <code>ReceiveNextEvent</code> to process events, as described in <code><a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHFIHIF">“Processing Events Manually”</a></code>. Depending on the thread, you can wait for particular events to occur or process every event (much the way <code>RunApplicationEventLoop</code> does). </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_49" title="Important:"></a><p><strong>Important:</strong>&nbsp;Event loops in preemptive threads you create do not receive user events. The only events your threads receive are those created by your application. </p><p></p></div><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_201"></a>You use the event queues primarily to communicate between threads. For example, if you wanted your preemptive thread to tell the main application it was finished processing data, it could post a custom event on the main application event queue. One advantage of this method is that your application does not have to use extra processing time polling a Multiprocessing Services queue or semaphore. </p><p>Depending on the circumstances, either Carbon event queues or Multiprocessing Services notification methods may be suitable for signaling between threads. If you want to use Carbon event queues, here is breakdown of how you might do it:</p><ul class="ul"><li class="li"><p>After first creating the thread, it should call <code>GetCurrentEventQueue<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_202"></a></code> to obtain its queue reference. It can then create a custom event signifying that it is ready for use, call <code>SetEventParameter</code> to store the queue reference in the event, then post the event to the main thread. It can then call <code>ReceiveNextEvent</code>, blocking until someone sends it an event. </p></li><li class="li"><p>When the main thread receives the ready event, the appropriate handler can call <code>GetEventParameter</code> to extract the queue reference. Then, whenever it needs to signal the other thread, it can create a “start processing” event and post it to the proper queue. </p></li><li class="li"><p>Whenever the preemptive thread receives the process event, it can carry out its particular task. Afterwards, it posts a “processing completed” event to the main event queue and returns to a blocked state in <code>ReceiveNextEvent</code>.</p></li><li class="li"><p>When it comes time to terminate the thread, the main application thread sends a termination event and waits for confirmation from the thread. </p></li></ul><p>For more information about creating cooperatively-scheduled threads, see the Thread Manager documentation and <span class="content_text"><a href="http://developer.apple.com/qa/qa2001/qa1061.html" target="_top">Technical Q&amp;A 1061</a></span>, “RunApplicationEventLoop and the Thread Manager.” For information about creating preemptively-scheduled threads, see the Multiprocessing Services documentation. </p><a name="//apple_ref/doc/uid/TP30000989-CH203-TPXREF111" title="Modal Event States"></a><h2>Modal Event States</h2><p><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_203"></a>If you need to create application-modal dialogs, you can use several Carbon Event Manager functions to enter and exit the modal state. A modal dialog is a window that allows no other application actions until the window is dismissed. For example, an alert that warns the user about the consequences of some action is typically a modal dialog.</p><p>For more information about the proper design and usage of modal dialogs, see <em>Inside Mac OS X: Aqua Human Interface Guidelines</em>. </p><p>The simplest way to enter the modal state is to call the function <code>RunAppModalLoopForWindow<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_204"></a></code>, passing the window reference of the window you want to make modal. This function is analogous to the <code>RunApplicationEventLoop</code> functions for applications. It runs a sub-event loop, disables the menu bar and dispatches events.</p><p>When in a modal state, the standard toolbox dispatcher only processes events for the modal window and any window above it (that is, closer to the front). Typically a modal window is frontmost, but if another window is in front of it, that window will also receive events. This feature was designed to allow stacked modal dialogs. See <span class="content_text"><a href="CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHFIHIF">“Processing Events Manually”</a></span> for more information about the toolbox dispatcher. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_50" title="Note"></a><p><strong>Note:</strong>&nbsp;You should use <code>RunAppModalLoopForWindow</code> instead of the older Dialog Manager function <code>ModalDialog</code>. </p></div><p>To leave the modal state, you call the function <code>QuitAppModalLoopForWindow<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_205"></a></code>. </p><p>To make construction of modal dialogs simpler, the Carbon Event Manager also includes some utility functions for setting the default and cancel buttons. </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus SetWindowDefaultButton(<span></span></pre></td></tr><tr><td scope="row"><pre>                WindowRef    inWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>                ControlRef   inControl);      /* can be NULL */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus SetWindowCancelButton(<span></span></pre></td></tr><tr><td scope="row"><pre>                WindowRef    inWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>                ControlRef   inControl);      /* can be NULL */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus GetWindowDefaultButton(<span></span></pre></td></tr><tr><td scope="row"><pre>                WindowRef     inWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>                ControlRef *  outControl);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus GetWindowCancelButton(<span></span></pre></td></tr><tr><td scope="row"><pre>                WindowRef     inWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>                ControlRef *  outControl);<span></span></pre></td></tr></table></div><p>Calling the “set” versions of these functions causes the standard event handlers to map keyboard input to the respective controls: pressing the Return or Enter keys will activate the default button, and pressing escape or Command-period will activate the cancel button.</p><p>As with the standard event loops, you can also choose to run the modal event loop manually and dispatch events yourself. To do so, you call the low-level function <code>BeginAppModalStateForWindow<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_206"></a></code> for the desired window. Once in this state you can call the usual low-level event processing functions. (<code>ReceiveNextEvent<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_207"></a></code>, <code>RunCurrentEventLoop<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_208"></a></code>). Note that because the event filtering occurs in the toolbox dispatcher (not the event queue), it is possible to receive and process events that are not related to the window. To leave the modal state, you call <code>EndAppModalStateForWindow<a name="//apple_ref/doc/uid/TP30000989-CH203-DontLinkElementID_209"></a></code>. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Concept/CarbonEventsConcept.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ApdxARev/CarbonEventsApdxRev.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2005 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2005-07-07<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/Carbon_Event_Manager/Tasks/CarbonEventsTasks.html%3Fid%3DTP30000989-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/Carbon_Event_Manager/Tasks/CarbonEventsTasks.html%3Fid%3DTP30000989-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/Carbon_Event_Manager/Tasks/CarbonEventsTasks.html%3Fid%3DTP30000989-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>