<html><head><title>Mac OS X
 Manual Page For class(n)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/n/class" title="Mac OS X
 Manual Page for class(n)"><a name="//apple_ref/doc/man/n/class" title="Mac OS X
 Manual Page for class(n)"><!-- headerDoc=man; indexgroup=Section n; uid="//apple_ref/doc/man/n/class"; name=class(n) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
class(n)                                         [incr Tcl]                                         class(n)



<b>NAME</b>
       class - create a class of objects

<b>SYNOPSIS</b>
       <b>class</b> <u>className</u> <b>{</b>
           <b>inherit</b> <u>baseClass</u> ?<u>baseClass</u>...?
           <b>constructor</b> <u>args</u> ?<u>init</u>? <u>body</u>
           <b>destructor</b> <u>body</u>
           <b>method</b> <u>name</u> ?<u>args</u>? ?<u>body</u>?
           <b>proc</b> <u>name</u> <u>?args</u>? ?<u>body</u>?
           <b>variable</b> <u>varName</u> ?<u>init</u>? ?<u>config</u>?
           <b>common</b> <u>varName</u> ?<u>init</u>?

           <b>public</b> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
           <b>protected</b> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
           <b>private</b> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

           <b>set</b> <u>varName</u> ?<u>value</u>?
           <b>array</b> <u>option</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
       <b>}</b>

       <u>className</u> <u>objName</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <u>objName</u> <u>method</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <u>className::proc</u> <u>?arg</u> <u>arg</u> <u>...</u>?


<b>DESCRIPTION</b>
       The  fundamental  construct in <b>[incr</b> <b>Tcl]</b> is the class definition.  Each class acts as a template for
       actual objects that can be created.  The class itself is a namespace which contains things common  to
       all  objects.   Each  object has its own unique bundle of data which contains instances of the "vari-<font color="#ffffff" class="whiteout">ables"&nbsp;"variables"</font>
       ables" defined in the class definition.  Each object also has a built-in variable named "this", which
       contains  the name of the object.  Classes can also have "common" data members that are shared by all
       objects in a class.

       Two types of functions can be included in the class definition.  "Methods" are functions which  oper-<font color="#ffffff" class="whiteout">ate&nbsp;operate</font>
       ate  on  a  specific object, and therefore have access to both "variables" and "common" data members.
       "Procs" are ordinary procedures in the class namespace, and only have access to  "common"  data  mem-<font color="#ffffff" class="whiteout">bers.&nbsp;members.</font>
       bers.

       If  the body of any method or proc starts with "<b>@</b>", it is treated as the symbolic name for a C proce-<font color="#ffffff" class="whiteout">dure.&nbsp;procedure.</font>
       dure.  Otherwise, it is treated as a Tcl code script.  See below for details on registering and using
       C procedures.

       A class can only be defined once, although the bodies of class methods and procs can be defined again
       and again for interactive debugging.  See the <b>body</b> and <b>configbody</b> commands for details.

       Each namespace can have its own collection of objects and classes.  The list of classes available  in
       the  current  context can be queried using the "<b>itcl::find</b> <b>classes</b>" command, and the list of objects,
       with the "<b>itcl::find</b> <b>objects</b>" command.

       A class can be deleted using the "<b>delete</b> <b>class</b>" command.  Individual objects can be deleted using the
       "<b>delete</b> <b>object</b>" command.


<b>CLASS</b> <b>DEFINITIONS</b>
       <b>class</b> <u>className</u> <u>definition</u>
              Provides  the  definition for a class named <u>className</u>.  If the class <u>className</u> already exists,
              or if a command called <u>className</u> exists in the current namespace context, this command returns
              an  error.  If the class definition is successfully parsed, <u>className</u> becomes a command in the
              current context, handling the creation of objects for this class.

       The class <u>definition</u> is evaluated as a series of Tcl  statements  that  define  elements  within  the
       class.  The following class definition commands are recognized:

              <b>inherit</b> <u>baseClass</u> ?<u>baseClass</u>...?
                     Causes  the  current  class  to  inherit characteristics from one or more base classes.
                     Classes must have been defined by a previous <b>class</b> command, or must be available to the
                     auto-loading  facility  (see "AUTO-LOADING" below).  A single class definition can con-<font color="#ffffff" class="whiteout">tain&nbsp;contain</font>
                     tain no more than one <b>inherit</b> command.

                     The order of <u>baseClass</u> names in the <b>inherit</b> list affects the name resolution for  class
                     members.  When the same member name appears in two or more base classes, the base class
                     that appears first in the <b>inherit</b> list takes precedence.  For example, if classes "Foo"
                     and  "Bar"  both  contain the member "x", and if another class has the "<b>inherit</b>" state-<font color="#ffffff" class="whiteout">ment:&nbsp;statement:</font>
                     ment: inherit Foo Bar then the name "x" means "Foo::x".  Other inherited members  named
                     "x" must be referenced with their explicit name, like "Bar::x".

              <b>constructor</b> <u>args</u> ?<u>init</u>? <u>body</u>
                     Declares  the  <u>args</u> argument list and <u>body</u> used for the constructor, which is automati-<font color="#ffffff" class="whiteout">cally&nbsp;automatically</font>
                     cally invoked whenever an object is created.

                     Before the <u>body</u> is executed, the optional <u>init</u> statement is used  to  invoke  any  base
                     class  constructors that require arguments.  Variables in the <u>args</u> specification can be
                     accessed in the <u>init</u> code fragment, and passed to base class constructors.  After eval-<font color="#ffffff" class="whiteout">uating&nbsp;evaluating</font>
                     uating  the <u>init</u> statement, any base class constructors that have not been executed are
                     invoked automatically without arguments.  This ensures that all base classes are  fully
                     constructed  before  the  constructor <u>body</u> is executed.  By default, this scheme causes
                     constructors to be invoked in order from least- to most-specific.  This is exactly  the
                     opposite of the order that classes are reported by the <b>info</b> <b>heritage</b> command.

                     If  construction  is successful, the constructor always returns the object name-regard-<font color="#ffffff" class="whiteout">less&nbsp;name-regardless</font>
                     less of how the <u>body</u> is defined-and the object name becomes a command  in  the  current
                     namespace context.  If construction fails, an error message is returned.

              <b>destructor</b> <u>body</u>
                     Declares  the  <u>body</u>  used  for  the  destructor, which is automatically invoked when an
                     object is deleted.  If the destructor is successful, the object data is  destroyed  and
                     the object name is removed as a command from the interpreter.  If destruction fails, an
                     error message is returned and the object remains.

                     When an object is destroyed, all destructors in its  class  hierarchy  are  invoked  in
                     order from most- to least-specific.  This is the order that the classes are reported by
                     the "<b>info</b> <b>heritage</b>" command, and it is exactly the opposite of the default  constructor
                     order.

              <b>method</b> <u>name</u> ?<u>args</u>? ?<u>body</u>?
                     Declares  a  method  called <u>name</u>.  When the method <u>body</u> is executed, it will have auto-<font color="#ffffff" class="whiteout">matic&nbsp;automatic</font>
                     matic access to object-specific variables and common data members.

                     If the <u>args</u> list is specified, it establishes the usage information  for  this  method.
                     The  <b>body</b> command can be used to redefine the method body, but the <u>args</u> list must match
                     this specification.

                     Within the body of another class method, a method can be invoked like  any  other  com-<font color="#ffffff" class="whiteout">mand-simply&nbsp;command-simply</font>
                     mand-simply  by  using its name.  Outside of the class context, the method name must be
                     prefaced an object name, which provides the context for the data that  it  manipulates.
                     Methods  in  a base class that are redefined in the current class, or hidden by another
                     base class, can be qualified using the "<u>className</u>::<u>method</u>" syntax.

              <b>proc</b> <u>name</u> ?<u>args</u>? ?<u>body</u>?
                     Declares a proc called <u>name</u>.  A proc is an ordinary procedure within the  class  names-<font color="#ffffff" class="whiteout">pace.&nbsp;namespace.</font>
                     pace.  Unlike a method, a proc is invoked without referring to a specific object.  When
                     the proc <u>body</u> is executed, it will have automatic access only to common data members.

                     If the <u>args</u> list is specified, it establishes the usage information for this proc.  The
                     <b>body</b>  command  can be used to redefine the proc body, but the <u>args</u> list must match this
                     specification.

                     Within the body of another class method or proc, a proc can be invoked like  any  other
                     command-simply  by using its name.  In any other namespace context, the proc is invoked
                     using a qualified name like "<u>className</u><b>::</b><u>proc</u>".  Procs in a base class  that  are  rede-<font color="#ffffff" class="whiteout">fined&nbsp;redefined</font>
                     fined  in  the current class, or hidden by another base class, can also be accessed via
                     their qualified name.

              <b>variable</b> <u>varName</u> ?<u>init</u>? ?<u>config</u>?
                     Defines an object-specific variable named <u>varName</u>.  All object-specific  variables  are
                     automatically available in class methods.  They need not be declared with anything like
                     the <b>global</b> command.

                     If the optional <u>init</u> string is specified, it is used as the initial value of the  vari-<font color="#ffffff" class="whiteout">able&nbsp;variable</font>
                     able  when  a new object is created.  Initialization forces the variable to be a simple
                     scalar value; uninitialized variables, on the other hand, can be set  within  the  con-<font color="#ffffff" class="whiteout">structor&nbsp;constructor</font>
                     structor and used as arrays.

                     The  optional  <u>config</u>  script is only allowed for public variables.  If specified, this
                     code fragment is executed whenever a public variable is modified by the built-in  "con-<font color="#ffffff" class="whiteout">figure"&nbsp;"configure"</font>
                     figure"  method.   The <u>config</u> script can also be specified outside of the class defini-<font color="#ffffff" class="whiteout">tion&nbsp;definition</font>
                     tion using the <b>configbody</b> command.

              <b>common</b> <u>varName</u> ?<u>init</u>?
                     Declares a common variable named <u>varName</u>.  Common variables reside in the class  names-<font color="#ffffff" class="whiteout">pace&nbsp;namespace</font>
                     pace  and  are shared by all objects belonging to the class.  They are just like global
                     variables, except that they need not be declared with the usual <b>global</b>  command.   They
                     are automatically visible in all class methods and procs.

                     If  the optional <u>init</u> string is specified, it is used as the initial value of the vari-<font color="#ffffff" class="whiteout">able.&nbsp;variable.</font>
                     able.  Initialization forces the variable to be a simple  scalar  value;  uninitialized
                     variables,  on  the  other  hand, can be set with subsequent <b>set</b> and <b>array</b> commands and
                     used as arrays.

                     Once a common data member has been defined, it can be set using <b>set</b> and <b>array</b>  commands
                     within  the  class  definition.   This  allows common data members to be initialized as
                     arrays.  For example: class Foo {
                         common boolean
                         set boolean(true) 1
                         set boolean(false) 0 } Note that if common data members are initialized within  the
                     constructor, they get initialized again and again whenever new objects are created.

              <b>public</b> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

              <b>protected</b> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

              <b>private</b> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
                     These  commands are used to set the protection level for class members that are created
                     when <u>command</u> is evaluated.  The <u>command</u> is usually <b>method</b>, <b>proc</b>, <b>variable</b> or<b>common</b>, and
                     the  remaining  <u>arg</u>'s  complete  the member definition.  However, <u>command</u> can also be a
                     script containing many different member definitions,  and  the  protection  level  will
                     apply to all of the members that are created.


<b>CLASS</b> <b>USAGE</b>
       Once  a class has been defined, the class name can be used as a command to create new objects belong-<font color="#ffffff" class="whiteout">ing&nbsp;belonging</font>
       ing to the class.

       <u>className</u> <u>objName</u> ?<u>args...</u>?
              Creates a new object in class <u>className</u> with the name <u>objName</u>.  Remaining arguments are passed
              to  the  constructor  of the most-specific class.  This in turn passes arguments to base class
              constructors before invoking its own body of commands.  If construction is successful, a  com-<font color="#ffffff" class="whiteout">mand&nbsp;command</font>
              mand  called  <u>objName</u>  is created in the current namespace context, and <u>objName</u> is returned as
              the result of this operation.  If an error is encountered during construction, the destructors
              are  automatically  invoked  to  free  any  resources  that have been allocated, the object is
              deleted, and an error is returned.

              If <u>objName</u> contains the string "<b>#auto</b>", that string is replaced with an  automatically  gener-<font color="#ffffff" class="whiteout">ated&nbsp;generated</font>
              ated  name.   Names  have  the form <u>className&lt;number&gt;</u>, where the <u>className</u> part is modified to
              start with a lowercase letter.  In class "Toaster", for  example,  the  "<b>#auto</b>"  specification
              would  produce  names  like  toaster0, toaster1, etc.  Note that "<b>#auto</b>" can be also be buried
              within an object name: fileselectiondialog .foo.bar.#auto -background red This would  generate
              an object named ".foo.bar.fileselectiondialog0".


<b>OBJECT</b> <b>USAGE</b>
       Once  an  object  has  been  created, the object name can be used as a command to invoke methods that
       operate on the object.

       <u>objName</u> <u>method</u> ?<u>args...</u>?
              Invokes a method named <u>method</u> on an object named <u>objName</u>.  Remaining arguments are  passed  to
              the  argument  list  for  the method.  The method name can be "constructor", "destructor", any
              method name appearing in the class definition, or any of the following built-in methods.

<b>BUILT-IN</b> <b>METHODS</b>
       <u>objName</u> <b>cget</b> <b>option</b>
              Provides access to public variables as configuration options.  This mimics the behavior of the
              usual  "cget"  operation  for  Tk widgets.  The <u>option</u> argument is a string of the form "<b>-</b><u>var</u>-<font color="#ffffff" class="whiteout">Name",&nbsp;"-varName",</font>
              <u>Name</u>", and this method returns the current value of the public variable <u>varName</u>.

       <u>objName</u> <b>configure</b> ?<u>option</u>? ?<u>value</u> <u>option</u> <u>value</u> <u>...</u>?
              Provides access to public variables as configuration options.  This mimics the behavior of the
              usual  "configure" operation for Tk widgets.  With no arguments, this method returns a list of
              lists describing all of the public variables.  Each list has  three  elements:   the  variable
              name, its initial value and its current value.

              If  a single <u>option</u> of the form "<b>-</b><u>varName</u>" is specified, then this method returns the informa-<font color="#ffffff" class="whiteout">tion&nbsp;information</font>
              tion for that one variable.

              Otherwise, the arguments are treated as <u>option</u>/<u>value</u> pairs  assigning  new  values  to  public
              variables.   Each  variable is assigned its new value, and if it has any "config" code associ-<font color="#ffffff" class="whiteout">ated&nbsp;associated</font>
              ated with it, it is executed in the context of the class where it was defined.  If  the  "con-<font color="#ffffff" class="whiteout">fig"&nbsp;"config"</font>
              fig"  code generates an error, the variable is set back to its previous value, and the <b>config</b>-<font color="#ffffff" class="whiteout">ure&nbsp;configure</font>
              <b>ure</b> method returns an error.

       <u>objName</u> <b>isa</b> <u>className</u>
              Returns non-zero if the given <u>className</u> can be found in the object's heritage, and zero other-<font color="#ffffff" class="whiteout">wise.&nbsp;otherwise.</font>
              wise.

       <u>objName</u> <b>info</b> <u>option</u> ?<u>args...</u>?
              Returns  information related to a particular object named <u>objName</u>, or to its class definition.
              The <u>option</u> parameter includes the following things, as well as the options recognized  by  the
              usual Tcl "info" command:

              <u>objName</u> <b>info</b> <b>class</b>
                     Returns the name of the most-specific class for object <u>objName</u>.

              <u>objName</u> <b>info</b> <b>inherit</b>
                     Returns  the  list of base classes as they were defined in the "<b>inherit</b>" command, or an
                     empty string if this class has no base classes.

              <u>objName</u> <b>info</b> <b>heritage</b>
                     Returns the current class name and the entire list of base classes in  the  order  that
                     they are traversed for member lookup and object destruction.

              <u>objName</u> <b>info</b> <b>function</b> ?<u>cmdName</u>? ?<b>-protection</b>? ?<b>-type</b>? ?<b>-name</b>? ?<b>-args</b>? ?<b>-body</b>?
                     With no arguments, this command returns a list of all class methods and procs.  If <u>cmd</u>-<font color="#ffffff" class="whiteout">Name&nbsp;cmdName</font>
                     <u>Name</u> is specified, it returns information for a specific method or proc.  If  no  flags
                     are specified, this command returns a list with the following elements:  the protection
                     level, the type (method/proc), the qualified name, the  argument  list  and  the  body.
                     Flags can be used to request specific elements from this list.

              <u>objName</u> <b>info</b> <b>variable</b> ?<u>varName</u>? ?<b>-protection</b>? ?<b>-type</b>? ?<b>-name</b>? ?<b>-init</b>? ?<b>-value</b>? ?<b>-config</b>?
                     With  no  arguments,  this  command returns a list of all object-specific variables and
                     common data members.  If <u>varName</u> is specified, it returns information  for  a  specific
                     data member.  If no flags are specified, this command returns a list with the following
                     elements:  the protection level, the type (variable/common), the  qualified  name,  the
                     initial  value,  and  the current value.  If <u>varName</u> is a public variable, the "config"
                     code is included on this list.  Flags can be used to  request  specific  elements  from
                     this list.


<b>CHAINING</b> <b>METHODS/PROCS</b>
       Sometimes  a base class has a method or proc that is redefined with the same name in a derived class.
       This is a way of making the derived class handle the same operations as the base class, but with  its
       own  specialized  behavior.  For example, suppose we have a Toaster class that looks like this: class
       Toaster {
           variable crumbs 0
           method toast {nslices} {
               if {$crumbs &gt; 50} {
                   error "== FIRE! FIRE! =="
               }
               set crumbs [expr $crumbs+4*$nslices]
           }
           method clean {} {
               set crumbs 0
           } } We might create another class like SmartToaster that redefines the  "toast"  method.   If  we
       want to access the base class method, we can qualify it with the base class name, to avoid ambiguity:
       class SmartToaster {
           inherit Toaster
           method toast {nslices} {
               if {$crumbs &gt; 40} {
                   clean
               }
               return [Toaster::toast $nslices]
           } } Instead of hard-coding the base class name, we can use the "chain" command like  this:  class
       SmartToaster {
           inherit Toaster
           method toast {nslices} {
               if {$crumbs &gt; 40} {
                   clean
               }
               return [chain $nslices]
           }  }  The  chain  command  searches through the class hierarchy for a slightly more generic (base
       class) implementation of a method or proc, and invokes it with the specified arguments.  It starts at
       the  current  class  context and searches through base classes in the order that they are reported by
       the "info heritage" command.  If another implementation is not found, this command does  nothing  and
       returns the null string.


<b>AUTO-LOADING</b>
       Class  definitions need not be loaded explicitly; they can be loaded as needed by the usual Tcl auto-<font color="#ffffff" class="whiteout">loading&nbsp;autoloading</font>
       loading facility.  Each directory containing class  definition  files  should  have  an  accompanying
       "tclIndex"  file.   Each  line in this file identifies a Tcl procedure or <b>[incr</b> <b>Tcl]</b> class definition
       and the file where the definition can be found.

       For example, suppose a directory contains the definitions for classes "Toaster"  and  "SmartToaster".
       Then  the  "tclIndex" file for this directory would look like: # Tcl autoload index file, version 2.0
       for [incr Tcl] # This file is generated by the "auto_mkindex" command # and sourced to set up  index-<font color="#ffffff" class="whiteout">ing&nbsp;indexing</font>
       ing  information for one or # more commands.  Typically each line is a command that # sets an element
       in the auto_index array, where the # element name is the name of a command  and  the  value  is  #  a
       script that loads the command.

       set   auto_index(::Toaster)   "source   $dir/Toaster.itcl"   set  auto_index(::SmartToaster)  "source
       $dir/SmartToaster.itcl"

       The <b>auto_mkindex</b> command is used to automatically generate "tclIndex" files.  The auto-loader must be
       made  aware of this directory by appending the directory name to the "auto_path" variable.  When this
       is in place, classes will be auto-loaded as needed when used in an application.


<b>C</b> <b>PROCEDURES</b>
       C procedures can be integrated into an <b>[incr</b> <b>Tcl]</b> class definition to implement methods,  procs,  and
       the  "config"  code  for  public variables.  Any body that starts with "<b>@</b>" is treated as the symbolic
       name for a C procedure.

       Symbolic names are established by registering procedures via <b>Itcl_RegisterC()</b>.  This is usually  done
       in the <b>Tcl_AppInit()</b> procedure, which is automatically called when the interpreter starts up.  In the
       following example, the procedure My_FooCmd() is registered with the symbolic name "foo".  This proce-<font color="#ffffff" class="whiteout">dure&nbsp;procedure</font>
       dure can be referenced in the <b>body</b> command as "@foo".  int Tcl_AppInit(interp)
           Tcl_Interp *interp;     /* Interpreter for application. */ {
           if (Itcl_Init(interp) == TCL_ERROR) {
               return TCL_ERROR;
           }

           if (Itcl_RegisterC(interp, "foo", My_FooCmd) != TCL_OK) {
               return TCL_ERROR;
           }  }  C  procedures are implemented just like ordinary Tcl commands.  See the <b>CrtCommand</b> man page
       for details.  Within the procedure, class data members can be accessed like ordinary variables  using
       <b>Tcl_SetVar()</b>,  <b>Tcl_GetVar()</b>, <b>Tcl_TraceVar()</b>, etc.  Class methods and procs can be executed like ordi-<font color="#ffffff" class="whiteout">nary&nbsp;ordinary</font>
       nary commands using <b>Tcl_Eval()</b>.  <b>[incr</b> <b>Tcl]</b> makes this possible by automatically setting up the  con-<font color="#ffffff" class="whiteout">text&nbsp;context</font>
       text before executing the C procedure.

       This scheme provides a natural migration path for code development.  Classes can be developed quickly
       using Tcl code to implement the bodies.  An entire application can be built and tested.  When  neces-<font color="#ffffff" class="whiteout">sary,&nbsp;necessary,</font>
       sary, individual bodies can be implemented with C code to improve performance.


<b>KEYWORDS</b>
       class, object, object-oriented



itcl                                                                                                class(n)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/mann/class.n.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/mann/class.n.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/mann/class.n.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
