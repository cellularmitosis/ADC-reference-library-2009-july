<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Optimizing Display Modes and Window Arrangement With the Display Manager (Legacy): Using the Display Manager</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Using the Display Manager"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	<meta name="ROBOTS" content="NOINDEX"/>
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000271" title="Using the Display Manager"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../LegacyTechnologies/index.html#//apple_ref/doc/uid/TP30000440-TP30000470" target="_top">Legacy Documents</a> &gt; <a href="../../../../LegacyTechnologies/Carbon-date.html#//apple_ref/doc/uid/TP30000440-TP30000470-TP30000494" target="_top">Carbon</a> &gt; <a href="../01introduction/introduction.html#//apple_ref/doc/uid/TP30000248-DontLinkElementID_14">Optimizing Display Modes and Window Arrangement With the Display Manager (Legacy)</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../02concepts/concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../appendixa/appendixa.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        <script type="text/javascript" language="JavaScript">placeWatermark()</script>
<div id="legacyOuterWrapper"><div align="center" id="watermark">
<div class="legacybox">
<h1>Legacy Document<span class="closebutton"><a href="javascript:closeWatermark()"><img src="../../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The Display Manager is deprecated as of Mac OS X v10.4. You should use Quartz Display Services instead (as described in <em><a href="../../../../GraphicsImaging/Conceptual/QuartzDisplayServicesConceptual/index.html#//apple_ref/doc/uid/TP40004316" target="_top">Quartz Display Services Programming Topics</a></em>).</p></div></div></div>
        <a name="//apple_ref/doc/uid/TP30000271-SW5" title="Using the Display Manager"></a><h1>Using the Display Manager</h1><p>The previous chapter explains how the Display Manager automatically repositions windows if necessary to ensure that windows are accessible when the user changes the display environment. If the Display Manager moves windows in a manner inappropriate for your application, your application should reposition them instead. Applications that use only the standard window definition functions provided by the Window Manager generally do not need to use the Display Manager.</p><p>However, you may need or want your application to perform its own window positioning under various circumstances, such as when</p><ul class="ul"><li class="li"><p>your application benefits by displaying windows and their contents on the display controlled by the video device with the greatest pixel depth</p></li><li class="li"><p>your application benefits by displaying windows on the largest available display</p></li><li class="li"><p>your application uses nonstandard window definition functions that draw windows lacking title bars; examples include fixed-sized windows without title bars (games often use such windows), tool palettes with drag regions on the left sides of their windows, and floating windows</p></li></ul><p>When necessary, the Display Manager automatically repositions windows of type <code>dBoxProc</code> (that is, alert boxes and modal dialog boxes) so that the lower-left corners of the windows appear onscreen. This gives users access to the area with the OK and Cancel buttons.</p><p>In addition, your application should respond to Display Manager changes if your application relies on display information that it stores internally. For example, if your application caches display positions, <code>GDevice</code> structures for displays other than the main screen, or the value in the <code>screenBits.bounds</code> field of the <code>screenBits</code> global variable, this information may become invalid after the user changes the display configuration. Therefore, your application should update its internal values accordingly after a display configuration change.</p><p>To determine whether the Display Manager is available, use the <code>Gestalt</code> function with the <code>gestaltDisplayMgrAttr</code> selector. Test the bit field indicated by the <code>gestaltDisplayMgrPresent</code> constant in the <code>response</code> parameter. If the bit is set, then the Display Manager is present.</p><p>Presence of the Display Manager does not guarantee that a computer also supports video mirroring. To determine whether QuickDraw supports video mirroring on the user’s computer system, use the <code>DMQDIsMirroringCapable</code> function.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000271-DontLinkElementID_8">Handling Events in Response to Display Manager Changes</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000271-DontLinkElementID_9">Handling the Display Notice Event as a High-Level Event</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000271-DontLinkElementID_10">Handling the Display Notice Event Outside of an Event Loop</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000271-DontLinkElementID_11">Managing Windows In Response to the Display Notice Event</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000271-DontLinkElementID_12">Determining the Characteristics of the Video Devices</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000271-DontLinkElementID_13">Setting Configurations and Display Modes for Video Devices</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000271-DontLinkElementID_8" title="Handling Events in Response to Display Manager Changes"></a><h2>Handling Events in Response to Display Manager Changes</h2><p>Users indirectly inform the Display Manager of changes they wish to make to their display environment by using the Monitors control panel, or by attaching or removing additional displays. The Display Manager in turn sends an Apple event—the Display Notice event—to notify applications that the display environment has changed.</p><p>After changing the display environment, the Display Manager also generates an update event to notify all current applications to update their windows.</p><p>Your application should always handle update events for its windows. However, your application needs to respond to the Display Notice event only if your application repositions its own windows, uses nonstandard windows, or must update any display information that it stores internally.</p><p>To receive the Display Notice event informing you of changes to the user’s display configuration, you must either</p><ul class="ul"><li class="li"><p>handle the Display Notice event as a high-level event in your application’s normal event loop; or</p></li><li class="li"><p>use the <code>DMRegisterExtendedNotifyProc</code> function to register a function that handles the Display Notice event as soon as the Display Manager issues it</p></li></ul><p>If you write a utility—such as a control panel—that does not handle events through a normal event loop, or if you want your application to handle the Display Notice event as soon as it is issued instead of waiting for it to appear in the event queue, you should use the <code>DMRegisterExtendedNotifyProc</code> function.</p><p>Here is a summary of the Display Notice event (remember that you must use Apple Event Manager functions to obtain the information contained in Apple events such as this):</p><p>Display Notice—respond to display configuration changes</p><dl class="termdef">	<dt><code>Event class</code></dt><dd><p><code>kCoreEventClass</code></p></dd><dt><code>Event ID</code></dt><dd><p><code>kAESystemConfigNotice</code></p></dd><dt><code>Required parameter</code></dt><dt><code>Keyword:</code></dt><dd><p><code>kAEDisplayNotice</code></p></dd><dt><code>Descriptor type:</code></dt><dd><p><code>AEDesc</code></p></dd><dt><code>Data:</code></dt><dd><p>A list of descriptor structures, each specified by the keyword <code>kDisplayID</code>. Each <code>kDisplayID</code> descriptor structure contains information about a video device attached to the user’s system. Within each <code>kDisplayID</code> descriptor structure are a pair of additional keyword-specified descriptor structures: <code>keyDisplayOldConfig</code> and <code>keyDisplayNewConfig</code>. A description of the video device’s previous state is saved in the <code>keyDisplayOldConfig</code> descriptor structure, and a description of the video device’s current state is saved in the <code>keyDisplayNewConfig</code> descriptor structure.</p><p>Descriptions of these keyword-specified descriptor structures are in <span class="content_text">Table 2-1</span>.</p></dd><dt><code>Requested action</code></dt><dd><p>Ensure that all windows appear to the user, and update any necessary display information that your application or utility stores internally.</p></dd></dl><a name="//apple_ref/doc/uid/TP30000271-SW1" title="Table 2-1Keyword-specified descriptor structures."></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>Keyword-specified descriptor structures.</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Keyword</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Value</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>keyDeviceDepthMode</code></p></td><td ><p><code>'dddm'</code></p></td><td ><p><code>typeLongInteger</code></p></td><td ><p>The depth mode for the video device; that is, the value of the <code>gdMode</code> field in the <code>GDevice</code> structure for the device</p></td></tr><tr><td  scope="row"><p><code>keyDeviceFlags</code></p></td><td ><p><code>'dddf'</code></p></td><td ><p><code>typeShortInteger</code></p></td><td ><p>The attributes for the video device as maintained in the <code>gdFlags</code> field of the <code>GDevice</code> structure for the device</p></td></tr><tr><td  scope="row"><p><code>keyDeviceRect</code></p></td><td ><p><code>'dddr'</code></p></td><td ><p><code>typeQDRectangle</code></p></td><td ><p>The boundary rectangle of the video device; that is, the value of the <code>gdRect</code> field in the <code>GDevice</code> structure for the device</p></td></tr><tr><td  scope="row"><p><code>keyDisplayDevice</code></p></td><td ><p><code>'dmdd'</code></p></td><td ><p><code>typeLongInteger</code></p></td><td ><p>A handle to the <code>GDevice</code> structure for the video device</p></td></tr><tr><td  scope="row"><p><code>keyDisplayID</code></p></td><td ><p><code>'dmid'</code></p></td><td ><p><code>typeLongInteger</code></p></td><td ><p>The display ID for the video device</p></td></tr><tr><td  scope="row"><p><code>keyDisplayMode</code></p></td><td ><p><code>'dmdm'</code></p></td><td ><p><code>typeLongInteger</code></p></td><td ><p>The <code>sResource</code> number from the video device for this display mode</p></td></tr><tr><td  scope="row"><p><code>keyDMConfigVersion</code></p></td><td ><p><code>'dmcv'</code></p></td><td ><p><code>typeLongInteger</code></p></td><td ><p>The version number for this Display Notice event</p></td></tr><tr><td  scope="row"><p><code>keyPixMapAlignment</code></p></td><td ><p><code>'dppa'</code></p></td><td ><p><code>typeLongInteger</code></p></td><td ><p>Reserved for future use</p></td></tr><tr><td  scope="row"><p><code>keyPixMapCmpCount</code></p></td><td ><p><code>'dpcc'</code></p></td><td ><p><code>typeShortInteger</code></p></td><td ><p>The number of components used to represent a color for a pixel; that is, the value of the <code>cmpCount</code> field in the <code>PixMap</code> structure for the <code>GDevice</code> structure for the device</p></td></tr><tr><td  scope="row"><p><code>keyPixMapCmpSize</code></p></td><td ><p><code>'dpcs'</code></p></td><td ><p><code>typeShortInteger</code></p></td><td ><p>The size in bits of each component for a pixel; that is, the value of the <code>cmpSize</code> field in the <code>PixMap</code> structure for the <code>GDevice</code> structure for the device</p></td></tr><tr><td  scope="row"><p><code>keyPixMapColorTableSeed</code></p></td><td ><p><code>'dpct'</code></p></td><td ><p><code>typeLongInteger</code></p></td><td ><p>The value of the <code>ctSeed</code> field of the <code>ColorTable</code> structure for the <code>PixMap</code> structure for the <code>GDevice</code> structure for the video device</p></td></tr><tr><td  scope="row"><p><code>keyPixMapHResolution</code></p></td><td ><p><code>'dphr'</code></p></td><td ><p><code>typeFixed</code></p></td><td ><p>he horizontal resolution of the pixel image in the <code>PixMap</code> structure for the <code>GDevice</code> structure for the video device</p></td></tr><tr><td  scope="row"><p><code>keyPixMapPixelSize</code></p></td><td ><p><code>'dpps'</code></p></td><td ><p><code>typeShortInteger</code></p></td><td ><p>Pixel depth for the device; that is, the value of the <code>pixelSize</code> field in the <code>PixMap</code> structure for the <code>GDevice</code> structure for the video device</p></td></tr><tr><td  scope="row"><p><code>keyPixMapPixelType</code></p></td><td ><p><code>'dppt'</code></p></td><td ><p><code>typeShortInteger</code></p></td><td ><p>The storage format for the pixel image on the device; that is, the value of the <code>pixelType</code> field in the <code>PixMap</code> structure for the <code>GDevice</code> structure for the video device</p></td></tr><tr><td  scope="row"><p><code>keyPixMapRect</code></p></td><td ><p><code>'dpdr'</code></p></td><td ><p><code>typeQDRectangle</code></p></td><td ><p>The boundary rectangle into which QuickDraw can draw; that is, the <code>bounds</code> field in the <code>PixMap</code> structure for the <code>GDevice</code> structure for the video device</p></td></tr><tr><td  scope="row"><p><code>keyPixMapReserved</code></p></td><td ><p><code>'dppr'</code></p></td><td ><p><code>typeLongInteger</code></p></td><td ><p>Reserved for future use</p></td></tr><tr><td  scope="row"><p><code>keyPixMapResReserved</code></p></td><td ><p><code>'dprr'</code></p></td><td ><p><code>typeLongInteger</code></p></td><td ><p>Reserved for future use</p></td></tr><tr><td  scope="row"><p><code>keyPixMapVResolution</code></p></td><td ><p><code>'dpvr'</code></p></td><td ><p><code>typeFixed</code></p></td><td ><p>The vertical resolution of the pixel image in the <code>PixMap</code> structure for the <code>GDevice</code> structure for the video device</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000271-DontLinkElementID_9" title="Handling the Display Notice Event as a High-Level Event"></a><h2>Handling the Display Notice Event as a High-Level Event</h2><p>To handle the Display Notice event as a high-level event like any other Apple event, you need to </p><ul class="ul"><li class="li"><p>set the <code>isHighLevelEventAware</code> bit in your application’s '<code>SIZE</code>' resource to indicate that your application supports high-level events (in which case your application must also support the four required Apple events)</p></li><li class="li"><p>include code to handle high-level events in your main event loop (as illustrated in <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000271-SW2">Listing 2-1</a></span>)</p></li><li class="li"><p>write a function that handles the Display Notice event (as illustrated in <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000271-SW3">Listing 2-2</a></span>)</p></li><li class="li"><p>use the <code>AEInstallEventHandler</code> function to install the entry for handling the Display Notice event in your application’s Apple event dispatch table</p></li></ul><p>If you want your application to handle all window positioning itself (that is, if you do not want the Display Manager to automatically move any of your windows), you should also set the <code>isDisplayManagerAware</code> bit in the '<code>SIZE</code>' resource.</p><a name="//apple_ref/doc/uid/TP30000271-SW2" title="Listing 2-1Handling Apple events in the event loop"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Handling Apple events in the event loop</p><div class="codesample"><table><tr><td scope="row"><pre>void MyDoEvent(EventRecord *event)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    short           part, err;<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowPtr       window;<span></span></pre></td></tr><tr><td scope="row"><pre>    char            key;<span></span></pre></td></tr><tr><td scope="row"><pre>    switch ( event->what ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* here, handle null, mouse down, key down, update, and<span></span></pre></td></tr><tr><td scope="row"><pre>            other necessary events */<span></span></pre></td></tr><tr><td scope="row"><pre>        case kHighLevelEvent:<span></span></pre></td></tr><tr><td scope="row"><pre>DoHighLevelEvent(event);<span></span></pre></td></tr><tr><td scope="row"><pre>break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>void DoHighLevelEvent(EventRecord *event)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr   myErr;<span></span></pre></td></tr><tr><td scope="row"><pre>        /* handling only Apple-event types of high-level events */<span></span></pre></td></tr><tr><td scope="row"><pre>        myErr = AEProcessAppleEvent(event);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Your application must use the <code>AEInstallEventHandler</code> function to add an entry to your application’s Apple event dispatch table. This entry is the function that responds to the Display Notice event. For example, the following code fragment illustrates how to use <code>AEInstallEventHandler</code> to install an application-defined function called <code>DoAEDisplayUpdate</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>err = AEInstallEventHandler (kCoreEventClass,<span></span></pre></td></tr><tr><td scope="row"><pre>                            kAESystemConfigNotice,<span></span></pre></td></tr><tr><td scope="row"><pre>                            (ProcPtr)DoAEDisplayUpdate, 0, false);<span></span></pre></td></tr></table></div><p></p><p><span class="content_text">Listing 2-2</span> shows an application-defined function called <code>DoAEDisplayUpdate</code> that uses Apple Event Manager functions to obtain information about the various video devices reported by the Display Notice event. The function <code>DoAEDisplayUpdate</code> uses this information to update its internal data structures for its windows and then calls another application-defined function that ensures that its windows are displayed optimally in the new configuration environment.</p><a name="//apple_ref/doc/uid/TP30000271-SW3" title="Listing 2-2Responding to the Display Notice event"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Responding to the Display Notice event</p><div class="codesample"><table><tr><td scope="row"><pre>pascal OSErr DoAEDisplayUpdate<span></span></pre></td></tr><tr><td scope="row"><pre>(AppleEvent theAE,AppleEvent reply,long ref) {<span></span></pre></td></tr><tr><td scope="row"><pre>    #pragma unused(theAE,reply,ref)<span></span></pre></td></tr><tr><td scope="row"><pre>    AEDescList      DisplayList;<span></span></pre></td></tr><tr><td scope="row"><pre>    AEDescList      DisplayID;<span></span></pre></td></tr><tr><td scope="row"><pre>    AERecord        OldConfig,NewConfig;<span></span></pre></td></tr><tr><td scope="row"><pre>    AEKeyword       tempWord;<span></span></pre></td></tr><tr><td scope="row"><pre>    AEDesc          returnType;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr           myErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    long            result;<span></span></pre></td></tr><tr><td scope="row"><pre>    long            count;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect            oldRect, newRect;<span></span></pre></td></tr><tr><td scope="row"><pre>    Size            actualSizeUnused;<span></span></pre></td></tr><tr><td scope="row"><pre>/* get a list of the displays from the Display Notice event */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    myErr =<span></span></pre></td></tr><tr><td scope="row"><pre>    AEGetParamDesc(&amp;theAE,kAEDisplayNotice,typeWildCard,&amp;DisplayList);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* count the elements in the list */<span></span></pre></td></tr><tr><td scope="row"><pre>    myErr = AECountItems(&amp;DisplayList,&amp;count);<span></span></pre></td></tr><tr><td scope="row"><pre>    while (count >0)        /* decode the Display Notice event */<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>        myErr = AEGetNthDesc(&amp;DisplayList, count, typeWildCard,<span></span></pre></td></tr><tr><td scope="row"><pre>            &amp;tempWord, &amp;DisplayID);<span></span></pre></td></tr><tr><td scope="row"><pre>        myErr = AEGetNthDesc(&amp;DisplayID, 1, typeWildCard, &amp;tempWord,<span></span></pre></td></tr><tr><td scope="row"><pre>            &amp;OldConfig);<span></span></pre></td></tr><tr><td scope="row"><pre>        myErr = AEGetKeyPtr(&amp;OldConfig, keyDeviceRect, typeWildCard,<span></span></pre></td></tr><tr><td scope="row"><pre>            &amp;returnType, &amp;oldRect, 8, actualSizeUnused);<span></span></pre></td></tr><tr><td scope="row"><pre>        myErr = AEGetNthDesc(&amp;DisplayID, 2, typeWildCard, &amp;tempWord,<span></span></pre></td></tr><tr><td scope="row"><pre>            &amp;NewConfig);<span></span></pre></td></tr><tr><td scope="row"><pre>        myErr = AEGetKeyPtr(&amp;NewConfig, keyDeviceRect, typeWildCard,<span></span></pre></td></tr><tr><td scope="row"><pre>            &amp;returnType, &amp;newRect, 8, actualSizeUnused);<span></span></pre></td></tr><tr><td scope="row"><pre>/* update internal info about the gdRects for the devices */<span></span></pre></td></tr><tr><td scope="row"><pre>        MyUpdateWindowStructures(oldRect, newRect);<span></span></pre></td></tr><tr><td scope="row"><pre>        count--;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>/* move and resize windows as necessary*/<span></span></pre></td></tr><tr><td scope="row"><pre>    MyDisplayWindows();<span></span></pre></td></tr><tr><td scope="row"><pre>    return (noErr);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000271-DontLinkElementID_10" title="Handling the Display Notice Event Outside of an Event Loop"></a><h2>Handling the Display Notice Event Outside of an Event Loop</h2><p>You may want your application to handle the Display Notice event as soon as it is issued instead of waiting for it to appear in the event queue. You can use the <code>DMRegisterExtendedNotifyProc</code> function to register a function to which the Display Manager directly sends the Display Notice event. By using <code>DMRegisterExtendedNotifyProc</code>, and by not setting the <code>isHighLevelEventAware</code> bit in the '<code>SIZE</code>' resource, you cause the Display Manager to send a Display Notice event directly to your handling function; your application or utility then receives no high-level Display Notice event.</p><p>To remove your Display Notice event-handling function, use the <code>DMRemoveExtendedNotifyProc</code> function.</p><a name="//apple_ref/doc/uid/TP30000271-DontLinkElementID_11" title="Managing Windows In Response to the Display Notice Event"></a><h2>Managing Windows In Response to the Display Notice Event</h2><p>Using the Monitors control panel, the user can switch displays to use a different display mode and to change the display configurations. When your application receives the Display Notice event as described in the previous section, your application must determine whether it needs to reposition and perhaps resize its windows.</p><p><span class="content_text">Listing 2-3</span> illustrates how an application can check whether its nonstandard window appears onscreen after Display Manager configuration changes have occurred. In this example, the application has a window with a title bar on its left side, as shown in the tool palette illustrated in <span class="content_text"><a href="../02concepts/concepts.html#//apple_ref/doc/uid/TP30000272-SW3">Figure 1-4</a></span>. After receiving the Display Notice event as shown in <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000271-SW3">Listing 2-2</a></span>, the application calls its <code>MyDisplayWindows</code> function, which in turn calls its <code>MyMakeToolWindowVisible</code> function. If <code>MyMakeToolWindowVisible</code> determines that the nonstandard title bar does not appear on any displays (in which case the user cannot move the window), <code>MyMakeToolWindowVisible</code> moves the entire window to the main screen where the user has access to the window.</p><a name="//apple_ref/doc/uid/TP30000271-SW4" title="Listing 2-3Ensuring that a nonstandard window appears onscreen"></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>Ensuring that a nonstandard window appears onscreen</p><div class="codesample"><table><tr><td scope="row"><pre>static pascal OSErr MyMakeToolWindowVisible (WindowPeek window) {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (window->windowKind == applicationFloatKind) {<span></span></pre></td></tr><tr><td scope="row"><pre>        Rect        checkRect;<span></span></pre></td></tr><tr><td scope="row"><pre>        Rect        mainRect;<span></span></pre></td></tr><tr><td scope="row"><pre>        GDHandle    maxAreaDevice;<span></span></pre></td></tr><tr><td scope="row"><pre>        short       theWVariant;<span></span></pre></td></tr><tr><td scope="row"><pre>        Rect        windowRect;<span></span></pre></td></tr><tr><td scope="row"><pre>        theWVariant = GetWVariant(&amp;window->port);<span></span></pre></td></tr><tr><td scope="row"><pre>        MyGetWindowGlobalRect(window, &amp;windowRect);<span></span></pre></td></tr><tr><td scope="row"><pre>        /*get rectangle of window, in global coordinates, here */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (0 != (kVerBarFW &amp; theWVariant))<span></span></pre></td></tr><tr><td scope="row"><pre>        /* check if this is the window with a vertical title bar */<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* following line gets the rectangle of the title bar */<span></span></pre></td></tr><tr><td scope="row"><pre>        SetRect(&amp;checkRect, windowRect.left-kMyVertTitleWidth+kMyMinVisX,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     windowRect.top+kkMyMinVisV,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     windowRect.left-1-kMyMinVisX,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     windowRect.bottom-kMyMinVisV);<span></span></pre></td></tr><tr><td scope="row"><pre>        /* following line calls an application-defined function that<span></span></pre></td></tr><tr><td scope="row"><pre>        determines which screen contains the largest amount of the title<span></span></pre></td></tr><tr><td scope="row"><pre>        bar */<span></span></pre></td></tr><tr><td scope="row"><pre>        maxAreaDevice = MyFindMaxCoverageDevice(&amp;checkRect);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (nil == maxAreaDevice)<span></span></pre></td></tr><tr><td scope="row"><pre>        /* if the title bar doesn't appear on any screen, move window to<span></span></pre></td></tr><tr><td scope="row"><pre>        the main screen */<span></span></pre></td></tr><tr><td scope="row"><pre>        {   mainRect = (*GetMainDevice()) -> gdRect;<span></span></pre></td></tr><tr><td scope="row"><pre>            MoveWindow(&amp;Window->port, mainRect.left+10+kMyVertTitleWidth,<span></span></pre></td></tr><tr><td scope="row"><pre>            mainRect.bottom-10-(windowRect.bottom-windowRec.top, FALSE);<span></span></pre></td></tr><tr><td scope="row"><pre>        } }<span></span></pre></td></tr><tr><td scope="row"><pre>        MyKeepWindowOnscreen(window, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>        /* handle other nonstandard window variants here */<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p></p><p>Your application may find it useful to resize a window after moving it, or to optimize the color for its newly configured video device. You can use Display Manager functions to determine the characteristics of video devices, as explained in the next section.</p><a name="//apple_ref/doc/uid/TP30000271-DontLinkElementID_12" title="Determining the Characteristics of the Video Devices"></a><h2>Determining the Characteristics of the Video Devices</h2><p>To determine the characteristics of available video devices, your application can use the <code>DMGetFirstScreenDevice</code> function to obtain a handle to the <code>GDevice </code>structure for the first video device in the device list. The <code>DMGetFirstScreenDevice</code> function is similar to the QuickDraw function <code>GetDeviceList</code>, except that when returning <code>GDevice</code> structures, <code>GetDeviceList</code> does not distinguish between the <code>GDevice</code> structures for video devices and the <code>GDevice</code> structures associated with no video devices. (For example, if system software uses the function <code>DMDisableDisplay</code> to disable the last remaining device in the device list, then <code>DMDisableDisplay</code> inserts into the device list a <code>GDevice</code> structure that is not associated with any video device. The <code>DMGetFirstScreenDevice</code> function will not return this <code>GDevice</code> structure, but <code>GetDeviceList</code> might.) </p><p>After using the <code>DMGetFirstScreenDevice</code> function to obtain a handle to the first <code>GDevice</code> structure for a display in the device list, your application can use the <code>DMGetNextScreenDevice</code> function to loop through all of the video devices in the device list. The <code>DMGetNextScreenDevice</code> function is similar to the QuickDraw function <code>GetNextDevice</code>, except that when returning <code>GDevice</code> structures, <code>GetNextDevice</code> does not distinguish between the <code>GDevice</code> structures for video devices and the <code>GDevice</code> structures associated with no video devices. </p><p>Another important difference between these two Display Manager functions (<code>DMGetFirstScreenDevice</code> and <code>DMGetNextScreenDevice</code>) and their related QuickDraw functions (<code>GetDeviceList</code> and <code>GetNextDevice</code>) is that with both Display Manager functions, your application can specify that the Display Manager return handles only to active video devices. (An active device is a video device whose display area is included in the user’s desktop; the display area of an inactive device does not appear on the user’s desktop.)</p><p>To get a handle to the <code>GDevice</code> structure for a video device that mirrors another, your application can use the <code>DMGetNextMirroredDevice</code> function. </p><p>Your application can pass the <code>GDevice</code> handle returned for any of these video devices to a QuickDraw function like <code>TestDeviceAttribute</code> or <code>HasDepth</code> to determine various characteristics of the video device, or your application can examine the <code>gdRect</code> field of the <code>GDevice</code> structure to determine the dimensions of the screen it represents.</p><p>Macintosh system software uses the <code>DMCheckDisplayMode</code> function to determine whether a video device supports a particular display mode and pixel depth. Typically, your application does not need to know whether a display mode is supported, but only whether a specific pixel depth is supported, in which case your application can use the Color QuickDraw function <code>HasDepth</code>.</p><p>To determine whether QuickDraw supports video mirroring on the user’s computer system, your application can use the <code>DMQDIsMirroringCapable</code> function. Your application can use the <code>DMCanMirrorNow</code> function to determine whether video mirroring can activate. And to determine whether the user’s computer system currently uses video mirroring, your application can use the <code>DMIsMirroringOn</code> function. </p><p>Finally, your application can use the <code>DMGetDisplayIDByGDevice</code> function to determine the display ID for a video device. A display ID is a long integer used by the Display Manager to uniquely identify a video device. Associating a display by its display ID is helpful when using functions such as <code>DMRemoveDisplay</code> that could change the <code>GDevice</code> structure associated with a video device. You can first determine the display ID for a device by using the <code>DMGetDisplayIDByGDevice</code> function. To later retrieve that device’s <code>GDevice</code> structure after calling various Display Manager functions, your application can use the <code>DMGetGDeviceByDisplayID</code> function. Display IDs are not guaranteed to be persistent across reboots or sleep.</p><a name="//apple_ref/doc/uid/TP30000271-DontLinkElementID_13" title="Setting Configurations and Display Modes for Video Devices"></a><h2>Setting Configurations and Display Modes for Video Devices</h2><p>The Monitors control panel is the user interface for changing the pixel depth, color capabilities, and positions of video devices. Because the user can control the capabilities of the video devices, your application should be flexible. For instance, although your application may have a preferred pixel depth, it should do its best to accommodate less than ideal conditions. </p><p>Your application can use Display Manager functions to change the display mode and display configuration of the user’s video devices, but your application should do so only with the consent of the user. </p><p>If your application must have a specific pixel depth, for example, it can display a dialog box that offers the user a choice between changing to that depth or canceling display of the image. This dialog box saves the user the trouble of going to the control panel before returning to your application. If it is absolutely necessary for your application to draw on a video device of a specific pixel depth, your application can then use either the <code>SetDepth</code> function or the <code>DMSetDisplayMode</code> function.</p><p>With the possible exception of the <code>DMSetDisplayMode</code> function and the <code>DMMirrorDevices</code> and <code>DMUnmirrorDevice</code> functions, applications should not need to use any of the Display Manager functions that change the user’s display configuration. However, they are described for completeness, in case you find a compelling need for your application to change the user’s display configuration. If your application must use multiple Display Manager calls that configure the user’s displays, your application should first use the <code>DMBeginConfigureDisplays</code> function to postpone Display Manager configuration checking, the rebuilding of desktop regions, and Apple event notification of Display Manager changes. When finished configuring the user’s displays, use the <code>DMEndConfigureDisplays</code> function. Using <code>DMBeginConfigureDisplays</code> and <code>DMEndConfigureDisplays</code> allows your application to wait until it has made all display changes before managing its windows in response to a single Display Notice event. It is important to pass the <code>displayState</code> variable obtained in <code>DMBeginConfigureDisplays</code> to the <code>DMEndConfigureDisplays</code> function.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../02concepts/concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../appendixa/appendixa.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-05-03<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/Optimizing_DisplayManager/03tasks/tasks.html%3Fid%3DTP40000920-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/Optimizing_DisplayManager/03tasks/tasks.html%3Fid%3DTP40000920-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/Optimizing_DisplayManager/03tasks/tasks.html%3Fid%3DTP40000920-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>