<html><head><title>Mac OS X
 Manual Page For Archive::Zip(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/Archive::Zip" title="Mac OS X
 Manual Page for Archive::Zip(3pm)"><a name="//apple_ref/doc/man/3/Archive::Zip" title="Mac OS X
 Manual Page for Archive::Zip(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/Archive::Zip"; name=Archive::Zip(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Archive::Zip(3)                      User Contributed Perl Documentation                     Archive::Zip(3)



<b>NAME</b>
       Archive::Zip - Provide an interface to ZIP archive files.

<b>SYNOPSIS</b>
          use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
          my $zip = Archive::Zip-&gt;new();
          my $member = $zip-&gt;addDirectory( 'dirname/' );
          $member = $zip-&gt;addString( 'This is a test', 'stringMember.txt' );
          $member-&gt;desiredCompressionMethod( COMPRESSION_DEFLATED );
          $member = $zip-&gt;addFile( 'xyz.pl', 'AnotherName.pl' );
          die 'write error' unless $zip-&gt;writeToFileNamed( 'someZip.zip' ) == AZ_OK;
          $zip = Archive::Zip-&gt;new();
          die 'read error' unless $zip-&gt;read( 'someZip.zip' ) == AZ_OK;
          $member = $zip-&gt;memberNamed( 'stringMember.txt' );
          $member-&gt;desiredCompressionMethod( COMPRESSION_STORED );
          die 'write error' unless $zip-&gt;writeToFileNamed( 'someOtherZip.zip' ) == AZ_OK;

<b>DESCRIPTION</b>
       The Archive::Zip module allows a Perl program to create, manipulate, read, and write Zip archive
       files. Zip archives can be created, or you can read from existing zip files. Once created, they can
       be written to files, streams, or strings. Members can be added, removed, extracted, replaced,
       rearranged, and enumerated. They can also be renamed or have their dates, comments, or other
       attributes queried or modified. Their data can be compressed or uncompressed as needed. Members can
       be created from members in existing Zip files, or from existing directories, files, or strings. This
       module uses the Compress::Zlib library to read and write the compressed streams inside the files.

<b>FILE</b> <b>NAMING</b>
       Regardless of what your local file system uses for file naming, names in a Zip file are in Unix
       format (<u>forward</u> slashes (/) separating directory names, etc.).  "Archive::Zip" tries to be consistent
       with file naming conventions, and will translate back and forth between native and Zip file names.
       However, it can't guess which format names are in. So two rules control what kind of file name you
       must pass various routines:

       Names of files are in local format.
           "File::Spec" and "File::Basename" are used for various file operations. When you're referring to
           a file on your system, use its file naming conventions.

       Names of archive members are in Unix format.
           This applies to every method that refers to an archive member, or provides a name for new archive
           members. The "extract()" methods that can take one or two names will convert from local to zip
           names if you call them with a single name.

<b>OBJECT</b> <b>MODEL</b>
       <b>Overview</b>

       Archive::Zip::Archive objects are what you ordinarily deal with.  These maintain the structure of a
       zip file, without necessarily holding data. When a zip is read from a disk file, the (possibly
       compressed) data still lives in the file, not in memory. Archive members hold information about the
       individual members, but not (usually) the actual member data. When the zip is written to a
       (different) file, the member data is compressed or copied as needed.  It is possible to make archive
       members whose data is held in a string in memory, but this is not done when a zip file is read.
       Directory members don't have any data.

       <b>Inheritance</b>

         Exporter
          Archive::Zip                            Common base class, has defs.
              Archive::Zip::Archive               A Zip archive.
              Archive::Zip::Member                Abstract superclass for all members.
                  Archive::Zip::StringMember      Member made from a string
                  Archive::Zip::FileMember        Member made from an external file
                      Archive::Zip::ZipFileMember Member that lives in a zip file
                      Archive::Zip::NewFileMember Member whose data is in a file
                  Archive::Zip::DirectoryMember   Member that is a directory

<b>EXPORTS</b>
       :CONSTANTS
           Exports the following constants: FA_MSDOS FA_UNIX GPBF_ENCRYPTED_MASK
           GPBF_DEFLATING_COMPRESSION_MASK GPBF_HAS_DATA_DESCRIPTOR_MASK COMPRESSION_STORED
           COMPRESSION_DEFLATED IFA_TEXT_FILE_MASK IFA_TEXT_FILE IFA_BINARY_FILE COMPRESSION_LEVEL_NONE
           COMPRESSION_LEVEL_DEFAULT COMPRESSION_LEVEL_FASTEST COMPRESSION_LEVEL_BEST_COMPRESSION

       :MISC_CONSTANTS
           Exports the following constants (only necessary for extending the module): FA_AMIGA FA_VAX_VMS
           FA_VM_CMS FA_ATARI_ST FA_OS2_HPFS FA_MACINTOSH FA_Z_SYSTEM FA_CPM FA_WINDOWS_NTFS
           GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK
           GPBF_IS_COMPRESSED_PATCHED_DATA_MASK COMPRESSION_SHRUNK DEFLATING_COMPRESSION_NORMAL
           DEFLATING_COMPRESSION_MAXIMUM DEFLATING_COMPRESSION_FAST DEFLATING_COMPRESSION_SUPER_FAST
           COMPRESSION_REDUCED_1 COMPRESSION_REDUCED_2 COMPRESSION_REDUCED_3 COMPRESSION_REDUCED_4
           COMPRESSION_IMPLODED COMPRESSION_TOKENIZED COMPRESSION_DEFLATED_ENHANCED
           COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED

       :ERROR_CODES
           Explained below. Returned from most methods. AZ_OK AZ_STREAM_END AZ_ERROR AZ_FORMAT_ERROR
           AZ_IO_ERROR

<b>ERROR</b> <b>CODES</b>
       Many of the methods in Archive::Zip return error codes. These are implemented as inline subroutines,
       using the "use constant" pragma. They can be imported into your namespace using the ":ERROR_CODES"
       tag:

         use Archive::Zip qw( :ERROR_CODES );
         ...
         die "whoops!" unless $zip-&gt;read( 'myfile.zip' ) == AZ_OK;

       AZ_OK (0)
           Everything is fine.

       AZ_STREAM_END (1)
           The read stream (or central directory) ended normally.

       AZ_ERROR (2)
           There was some generic kind of error.

       AZ_FORMAT_ERROR (3)
           There is a format error in a ZIP file being read.

       AZ_IO_ERROR (4)
           There was an IO error.

<b>COMPRESSION</b>
       Archive::Zip allows each member of a ZIP file to be compressed (using the Deflate algorithm) or
       uncompressed. Other compression algorithms that some versions of ZIP have been able to produce are
       not supported. Each member has two compression methods: the one it's stored as (this is always
       COMPRESSION_STORED for string and external file members), and the one you desire for the member in
       the zip file. These can be different, of course, so you can make a zip member that is not compressed
       out of one that is, and vice versa. You can inquire about the current compression and set the desired
       compression method:

         my $member = $zip-&gt;memberNamed( 'xyz.txt' );
         $member-&gt;compressionMethod();    # return current compression
         # set to read uncompressed
         $member-&gt;desiredCompressionMethod( COMPRESSION_STORED );
         # set to read compressed
         $member-&gt;desiredCompressionMethod( COMPRESSION_DEFLATED );

       There are two different compression methods:

       COMPRESSION_STORED
           file is stored (no compression)

       COMPRESSION_DEFLATED
           file is Deflated

       <b>Compression</b> <b>Levels</b>

       If a member's desiredCompressionMethod is COMPRESSION_DEFLATED, you can choose different compression
       levels. This choice may affect the speed of compression and decompression, as well as the size of the
       compressed member data.

         $member-&gt;desiredCompressionLevel( 9 );

       The levels given can be:

       0 or COMPRESSION_LEVEL_NONE
           This is the same as saying

             $member-&gt;desiredCompressionMethod( COMPRESSION_STORED );

       1 .. 9
           1 gives the best speed and worst compression, and 9 gives the best compression and worst speed.

       COMPRESSION_LEVEL_FASTEST
           This is a synonym for level 1.

       COMPRESSION_LEVEL_BEST_COMPRESSION
           This is a synonym for level 9.

       COMPRESSION_LEVEL_DEFAULT
           This gives a good compromise between speed and compression, and is currently equivalent to 6
           (this is in the zlib code).  This is the level that will be used if not specified.

<b>Archive::Zip</b> <b>methods</b>
       The Archive::Zip class (and its invisible subclass Archive::Zip::Archive) implement generic zip file
       functionality. Creating a new Archive::Zip object actually makes an Archive::Zip::Archive object, but
       you don't have to worry about this unless you're subclassing.

       <b>Constructor</b>


       new( [$fileName] )
           Make a new, empty zip archive.

               my $zip = Archive::Zip-&gt;new();

           If an additional argument is passed, <u>new()</u> will call <u>read()</u> to read the contents of an archive:

               my $zip = Archive::Zip-&gt;new( 'xyz.zip' );

           If a filename argument is passed and the read fails for any reason, new will return undef. For
           this reason, it may be better to call read separately.

       <b>Zip</b> <b>Archive</b> <b>Utility</b> <b>Methods</b>

       These Archive::Zip methods may be called as functions or as object methods. Do not call them as class
       methods:

           $zip = Archive::Zip-&gt;new();
           $crc = Archive::Zip::computeCRC32( 'ghijkl' );    # OK
           $crc = $zip-&gt;computeCRC32( 'ghijkl' );            # also OK
           $crc = Archive::Zip-&gt;computeCRC32( 'ghijkl' );    # NOT OK

       Archive::Zip::computeCRC32( $string [, $crc] )
           This is a utility function that uses the Compress::Zlib CRC routine to compute a CRC-32. You can
           get the CRC of a string:

               $crc = Archive::Zip::computeCRC32( $string );

           Or you can compute the running CRC:

               $crc = 0;
               $crc = Archive::Zip::computeCRC32( 'abcdef', $crc );
               $crc = Archive::Zip::computeCRC32( 'ghijkl', $crc );

       Archive::Zip::setChunkSize( $number )
           Report or change chunk size used for reading and writing.  This can make big differences in
           dealing with large files.  Currently, this defaults to 32K. This also changes the chunk size used
           for Compress::Zlib. You must call <u>setChunkSize()</u> before reading or writing. This is not
           exportable, so you must call it like:

               Archive::Zip::setChunkSize( 4096 );

           or as a method on a zip (though this is a global setting).  Returns old chunk size.

       <u>Archive::Zip::chunkSize()</u>
           Returns the current chunk size:

               my $chunkSize = Archive::Zip::chunkSize();

       Archive::Zip::setErrorHandler( \&amp;subroutine )
           Change the subroutine called with error strings. This defaults to \&amp;Carp::carp, but you may want
           to change it to get the error strings. This is not exportable, so you must call it like:

               Archive::Zip::setErrorHandler( \&amp;myErrorHandler );

           If myErrorHandler is undef, resets handler to default.  Returns old error handler. Note that if
           you call Carp::carp or a similar routine or if you're chaining to the default error handler from
           your error handler, you may want to increment the number of caller levels that are skipped (do
           not just set it to a number):

               $Carp::CarpLevel++;

       Archive::Zip::tempFile( [$tmpdir] )
           Create a uniquely named temp file. It will be returned open for read/write. If $tmpdir is given,
           it is used as the name of a directory to create the file in. If not given, creates the file using
           "File::Spec::tmpdir()". Generally, you can override this choice using the

               $ENV{TMPDIR}

           environment variable. But see the File::Spec documentation for your system. Note that on many
           systems, if you're running in taint mode, then you must make sure that $ENV{TMPDIR} is untainted
           for it to be used.  Will <u>NOT</u> create $tmpdir if it doesn't exist (this is a change from prior
           versions!). Returns file handle and name:

               my ($fh, $name) = Archive::Zip::tempFile();
               my ($fh, $name) = Archive::Zip::tempFile('myTempDir');
               my $fh = Archive::Zip::tempFile();  # if you don't need the name

       <b>Zip</b> <b>Archive</b> <b>Accessors</b>


       <u>members()</u>
           Return a copy of the members array

               my @members = $zip-&gt;members();

       <u>numberOfMembers()</u>
           Return the number of members I have

       <u>memberNames()</u>
           Return a list of the (internal) file names of the zip members

       memberNamed( $string )
           Return ref to member whose filename equals given filename or undef. $string must be in Zip (Unix)
           filename format.

       membersMatching( $regex )
           Return array of members whose filenames match given regular expression in list context. Returns
           number of matching members in scalar context.

               my @textFileMembers = $zip-&gt;membersMatching( '.*\.txt' );
               # or
               my $numberOfTextFiles = $zip-&gt;membersMatching( '.*\.txt' );

       <u>diskNumber()</u>
           Return the disk that I start on. Not used for writing zips, but might be interesting if you read
           a zip in. This should be 0, as Archive::Zip does not handle multi-volume archives.

       <u>diskNumberWithStartOfCentralDirectory()</u>
           Return the disk number that holds the beginning of the central directory. Not used for writing
           zips, but might be interesting if you read a zip in. This should be 0, as Archive::Zip does not
           handle multi-volume archives.

       <u>numberOfCentralDirectoriesOnThisDisk()</u>
           Return the number of CD structures in the zipfile last read in.  Not used for writing zips, but
           might be interesting if you read a zip in.

       <u>numberOfCentralDirectories()</u>
           Return the number of CD structures in the zipfile last read in.  Not used for writing zips, but
           might be interesting if you read a zip in.

       <u>centralDirectorySize()</u>
           Returns central directory size, as read from an external zip file. Not used for writing zips, but
           might be interesting if you read a zip in.

       <u>centralDirectoryOffsetWRTStartingDiskNumber()</u>
           Returns the offset into the zip file where the CD begins. Not used for writing zips, but might be
           interesting if you read a zip in.

       zipfileComment( [$string] )
           Get or set the zipfile comment. Returns the old comment.

               print $zip-&gt;zipfileComment();
               $zip-&gt;zipfileComment( 'New Comment' );

       <u>eocdOffset()</u>
           Returns the (unexpected) number of bytes between where the EOCD was found and where it expected
           to be. This is normally 0, but would be positive if something (a virus, perhaps) had added bytes
           somewhere before the EOCD. Not used for writing zips, but might be interesting if you read a zip
           in. Here is an example of how you can diagnose this:

             my $zip = Archive::Zip-&gt;new('somefile.zip');
             if ($zip-&gt;eocdOffset())
             {
               warn "A virus has added ", $zip-&gt;eocdOffset, " bytes of garbage\n";
             }

           The "eocdOffset()" is used to adjust the starting position of member headers, if necessary.

       <u>fileName()</u>
           Returns the name of the file last read from. If nothing has been read yet, returns an empty
           string; if read from a file handle, returns the handle in string form.

       <b>Zip</b> <b>Archive</b> <b>Member</b> <b>Operations</b>

       Various operations on a zip file modify members. When a member is passed as an argument, you can
       either use a reference to the member itself, or the name of a member. Of course, using the name
       requires that names be unique within a zip (this is not enforced).

       removeMember( $memberOrName )
           Remove and return the given member, or match its name and remove it. Returns undef if member or
           name doesn't exist in this Zip. No-op if member does not belong to this zip.

       replaceMember( $memberOrName, $newMember )
           Remove and return the given member, or match its name and remove it. Replace with new member.
           Returns undef if member or name doesn't exist in this Zip, or if $newMember is undefined.

           It is an (undiagnosed) error to provide a $newMember that is a member of the zip being modified.

               my $member1 = $zip-&gt;removeMember( 'xyz' );
               my $member2 = $zip-&gt;replaceMember( 'abc', $member1 );
               # now, $member2 (named 'abc') is not in $zip,
               # and $member1 (named 'xyz') is, having taken $member2's place.

       extractMember( $memberOrName [, $extractedName ] )
           Extract the given member, or match its name and extract it.  Returns undef if member doesn't
           exist in this Zip. If optional second arg is given, use it as the name of the extracted member.
           Otherwise, the internal filename of the member is used as the name of the extracted file or
           directory.  If you pass $extractedName, it should be in the local file system's format.  All
           necessary directories will be created. Returns "AZ_OK" on success.

       extractMemberWithoutPaths( $memberOrName [, $extractedName ] )
           Extract the given member, or match its name and extract it.  Does not use path information
           (extracts into the current directory). Returns undef if member doesn't exist in this Zip.  If
           optional second arg is given, use it as the name of the extracted member (its paths will be
           deleted too). Otherwise, the internal filename of the member (minus paths) is used as the name of
           the extracted file or directory. Returns "AZ_OK" on success.

       addMember( $member )
           Append a member (possibly from another zip file) to the zip file. Returns the new member.
           Generally, you will use <u>addFile()</u>, <u>addDirectory()</u>, <u>addFileOrDirectory()</u>, <u>addString()</u>, or <u>read()</u>
           to add members.

               # Move member named 'abc' to end of zip:
               my $member = $zip-&gt;removeMember( 'abc' );
               $zip-&gt;addMember( $member );

       updateMember( $memberOrName, $fileName )
           Update a single member from the file or directory named $fileName.  Returns the (possibly added
           or updated) member, if any; "undef" on errors.  The comparison is based on "lastModTime()" and
           (in the case of a non-directory) the size of the file.

       addFile( $fileName [, $newName ] )
           Append a member whose data comes from an external file, returning the member or undef. The member
           will have its file name set to the name of the external file, and its desiredCompressionMethod
           set to COMPRESSION_DEFLATED. The file attributes and last modification time will be set from the
           file.  If the name given does not represent a readable plain file or symbolic link, undef will be
           returned. $fileName must be in the format required for the local file system.  The optional
           $newName argument sets the internal file name to something different than the given $fileName.
           $newName, if given, must be in Zip name format (i.e. Unix).  The text mode bit will be set if the
           contents appears to be text (as returned by the "-T" perl operator).

           <u>NOTE</u> that you shouldn't (generally) use absolute path names in zip member names, as this will
           cause problems with some zip tools as well as introduce a security hole and make the zip harder
           to use.

       addDirectory( $directoryName [, $fileName ] )
           Append a member created from the given directory name. The directory name does not have to name
           an existing directory.  If the named directory exists, the file modification time and permissions
           are set from the existing directory, otherwise they are set to now and permissive default
           permissions.  $directoryName must be in local file system format.  The optional second argument
           sets the name of the archive member (which defaults to $directoryName). If given, it must be in
           Zip (Unix) format.  Returns the new member.

       addFileOrDirectory( $name [, $newName ] )
           Append a member from the file or directory named $name. If $newName is given, use it for the name
           of the new member.  Will add or remove trailing slashes from $newName as needed.  $name must be
           in local file system format.  The optional second argument sets the name of the archive member
           (which defaults to $name). If given, it must be in Zip (Unix) format.

       addString( $stringOrStringRef, $name )
           Append a member created from the given string or string reference. The name is given by the
           second argument.  Returns the new member. The last modification time will be set to now, and the
           file attributes will be set to permissive defaults.

               my $member = $zip-&gt;addString( 'This is a test', 'test.txt' );

       contents( $memberOrMemberName [, $newContents ] )
           Returns the uncompressed data for a particular member, or undef.

               print "xyz.txt contains " . $zip-&gt;contents( 'xyz.txt' );

           Also can change the contents of a member:

               $zip-&gt;contents( 'xyz.txt', 'This is the new contents' );

           If called expecting an array as the return value, it will include the status as the second value
           in the array.

               ($content, $status) = $zip-&gt;contents( 'xyz.txt');

       <b>Zip</b> <b>Archive</b> <b>I/O</b> <b>operations</b>

       A Zip archive can be written to a file or file handle, or read from one.

       writeToFileNamed( $fileName )
           Write a zip archive to named file. Returns "AZ_OK" on success.

               my $status = $zip-&gt;writeToFileNamed( 'xx.zip' );
               die "error somewhere" if $status != AZ_OK;

           Note that if you use the same name as an existing zip file that you read in, you will clobber
           ZipFileMembers. So instead, write to a different file name, then delete the original.  If you use
           the "overwrite()" or "overwriteAs()" methods, you can re-write the original zip in this way.
           $fileName should be a valid file name on your system.

       writeToFileHandle( $fileHandle [, $seekable] )
           Write a zip archive to a file handle. Return AZ_OK on success. The optional second arg tells
           whether or not to try to seek backwards to re-write headers. If not provided, it is set if the
           Perl "-f" test returns true. This could fail on some operating systems, though.

               my $fh = IO::File-&gt;new( 'someFile.zip', 'w' );
               if ( $zip-&gt;writeToFileHandle( $fh ) != AZ_OK)
                   {
                           # error handling
                   }

           If you pass a file handle that is not seekable (like if you're writing to a pipe or a socket),
           pass a false second argument:

               my $fh = IO::File-&gt;new( '| cat &gt; somefile.zip', 'w' );
               $zip-&gt;writeToFileHandle( $fh, 0 );   # fh is not seekable

           If this method fails during the write of a member, that member and all following it will return
           false from "wasWritten()". See <u>writeCentralDirectory()</u> for a way to deal with this.  If you want,
           you can write data to the file handle before passing it to <u>writeToFileHandle()</u>; this could be
           used (for instance) for making self-extracting archives. However, this only works reliably when
           writing to a real file (as opposed to STDOUT or some other possible non-file).  See
           examples/selfex.pl for how to write a self-extracting archive.

       writeCentralDirectory( $fileHandle [, $offset ] )
           Writes the central directory structure to the given file handle. Returns AZ_OK on success. If
           given an $offset, will seek to that point before writing. This can be used for recovery in cases
           where writeToFileHandle or writeToFileNamed returns an IO error because of running out of space
           on the destination file. You can truncate the zip by seeking backwards and then writing the
           directory:

               my $fh = IO::File-&gt;new( 'someFile.zip', 'w' );
                   my $retval = $zip-&gt;writeToFileHandle( $fh );
               if ( $retval == AZ_IO_ERROR )
                   {
                           my @unwritten = grep { not $_-&gt;wasWritten() } $zip-&gt;members();
                           if (@unwritten)
                           {
                                   $zip-&gt;removeMember( $member ) foreach my $member ( @unwritten );
                                   $zip-&gt;writeCentralDirectory( $fh,
                                           $unwritten[0]-&gt;writeLocalHeaderRelativeOffset());
                           }
                   }

       overwriteAs( $newName )
           Write the zip to the specified file, as safely as possible.  This is done by first writing to a
           temp file, then renaming the original if it exists, then renaming the temp file, then deleting
           the renamed original if it exists. Returns AZ_OK if successful.

       <u>overwrite()</u>
           Write back to the original zip file. See <u>overwriteAs()</u> above.  If the zip was not ever read from
           a file, this generates an error.

       read( $fileName )
           Read zipfile headers from a zip file, appending new members.  Returns "AZ_OK" or error code.

               my $zipFile = Archive::Zip-&gt;new();
               my $status = $zipFile-&gt;read( '/some/FileName.zip' );

       readFromFileHandle( $fileHandle, $filename )
           Read zipfile headers from an already-opened file handle, appending new members. Does not close
           the file handle.  Returns "AZ_OK" or error code. Note that this requires a seekable file handle;
           reading from a stream is not yet supported.

               my $fh = IO::File-&gt;new( '/some/FileName.zip', 'r' );
               my $zip1 = Archive::Zip-&gt;new();
               my $status = $zip1-&gt;readFromFileHandle( $fh );
               my $zip2 = Archive::Zip-&gt;new();
               $status = $zip2-&gt;readFromFileHandle( $fh );

       <b>Zip</b> <b>Archive</b> <b>Tree</b> <b>operations</b>

       These used to be in Archive::Zip::Tree but got moved into Archive::Zip. They enable operation on an
       entire tree of members or files.  A usage example:

         use Archive::Zip;
         my $zip = Archive::Zip-&gt;new();
         # add all readable files and directories below . as xyz/*
         $zip-&gt;addTree( '.', 'xyz' );
         # add all readable plain files below /abc as def/*
         $zip-&gt;addTree( '/abc', 'def', sub { -f &amp;&amp; -r } );
         # add all .c files below /tmp as stuff/*
         $zip-&gt;addTreeMatching( '/tmp', 'stuff', '\.c$' );
         # add all .o files below /tmp as stuff/* if they aren't writable
         $zip-&gt;addTreeMatching( '/tmp', 'stuff', '\.o$', sub { ! -w } );
         # add all .so files below /tmp that are smaller than 200 bytes as stuff/*
         $zip-&gt;addTreeMatching( '/tmp', 'stuff', '\.o$', sub { -s &lt; 200 } );
         # and write them into a file
         $zip-&gt;writeToFileNamed('xxx.zip');
         # now extract the same files into /tmpx
         $zip-&gt;extractTree( 'stuff', '/tmpx' );

       $zip-&gt;addTree( $root, $dest [,$pred] ) -- Add tree of files to a zip
           $root is the root of the tree of files and directories to be added. It is a valid directory name
           on your system. $dest is the name for the root in the zip file (undef or blank means to use
           relative pathnames). It is a valid ZIP directory name (that is, it uses forward slashes (/) for
           separating directory components). $pred is an optional subroutine reference to select files: it
           is passed the name of the prospective file or directory using $_, and if it returns true, the
           file or directory will be included. The default is to add all readable files and directories. For
           instance, using

             my $pred = sub { /\.txt/ };
             $zip-&gt;addTree( '.', '', $pred );

           will add all the .txt files in and below the current directory, using relative names, and making
           the names identical in the zipfile:

             original name           zip member name
             ./xyz                   xyz
             ./a/                    a/
             ./a/b                   a/b

           To translate absolute to relative pathnames, just pass them in: $zip-&gt;addTree( '/c/d', 'a' );

             original name           zip member name
             /c/d/xyz                a/xyz
             /c/d/a/                 a/a/
             /c/d/a/b                a/a/b

           Returns AZ_OK on success. Note that this will not follow symbolic links to directories. Note also
           that this does not check for the validity of filenames.

           Note that you generally <u>don't</u> want to make zip archive member names absolute.

       $zip-&gt;addTreeMatching( $root, $dest, $pattern [,$pred] )
           $root is the root of the tree of files and directories to be added $dest is the name for the root
           in the zip file (undef means to use relative pathnames) $pattern is a (non-anchored) regular
           expression for filenames to match $pred is an optional subroutine reference to select files: it
           is passed the name of the prospective file or directory in $_, and if it returns true, the file
           or directory will be included.  The default is to add all readable files and directories. To add
           all files in and below the current dirctory whose names end in ".pl", and make them extract into
           a subdirectory named "xyz", do this:

             $zip-&gt;addTreeMatching( '.', 'xyz', '\.pl$' )

           To add all <u>writable</u> files in and below the dirctory named "/abc" whose names end in ".pl", and
           make them extract into a subdirectory named "xyz", do this:

             $zip-&gt;addTreeMatching( '/abc', 'xyz', '\.pl$', sub { -w } )

           Returns AZ_OK on success. Note that this will not follow symbolic links to directories.

       $zip-&gt;updateTree( $root, [ $dest, [ $pred [, $mirror]]] );
           Update a zip file from a directory tree.

           "updateTree()" takes the same arguments as "addTree()", but first checks to see whether the file
           or directory already exists in the zip file, and whether it has been changed.

           If the fourth argument $mirror is true, then delete all my members if corresponding files weren't
           found.

           Returns an error code or AZ_OK if all is well.

       $zip-&gt;<u>extractTree()</u>
       $zip-&gt;extractTree( $root )
       $zip-&gt;extractTree( $root, $dest )
       $zip-&gt;extractTree( $root, $dest, $volume )
           If you don't give any arguments at all, will extract all the files in the zip with their original
           names.

           If you supply one argument for $root, "extractTree" will extract all the members whose names
           start with $root into the current directory, stripping off $root first.  $root is in Zip (Unix)
           format.  For instance,

             $zip-&gt;extractTree( 'a' );

           when applied to a zip containing the files: a/x a/b/c ax/d/e d/e will extract:

           a/x as ./x

           a/b/c as ./b/c

           If you give two arguments, "extractTree" extracts all the members whose names start with $root.
           It will translate $root into $dest to construct the destination file name.  $root and $dest are
           in Zip (Unix) format.  For instance,

              $zip-&gt;extractTree( 'a', 'd/e' );

           when applied to a zip containing the files: a/x a/b/c ax/d/e d/e will extract:

           a/x to d/e/x

           a/b/c to d/e/b/c and ignore ax/d/e and d/e

           If you give three arguments, "extractTree" extracts all the members whose names start with $root.
           It will translate $root into $dest to construct the destination file name, and then it will
           convert to local file system format, using $volume as the name of the destination volume.

           $root and $dest are in Zip (Unix) format.

           $volume is in local file system format.

           For instance, under Windows,

              $zip-&gt;extractTree( 'a', 'd/e', 'f:' );

           when applied to a zip containing the files: a/x a/b/c ax/d/e d/e will extract:

           a/x to f:d/e/x

           a/b/c to f:d/e/b/c and ignore ax/d/e and d/e

           If you want absolute paths (the prior example used paths relative to the current directory on the
           destination volume, you can specify these in $dest:

              $zip-&gt;extractTree( 'a', '/d/e', 'f:' );

           when applied to a zip containing the files: a/x a/b/c ax/d/e d/e will extract:

           a/x to f:\d\e\x

           a/b/c to f:\d\e\b\c and ignore ax/d/e and d/e

           Returns an error code or AZ_OK if everything worked OK.

<b>MEMBER</b> <b>OPERATIONS</b>
       <b>Member</b> <b>Class</b> <b>Methods</b>

       Several constructors allow you to construct members without adding them to a zip archive. These work
       the same as the <u>addFile()</u>, <u>addDirectory()</u>, and <u>addString()</u> zip instance methods described above, but
       they don't add the new members to a zip.

       Archive::Zip::Member-&gt;newFromString( $stringOrStringRef [, $fileName] )
           Construct a new member from the given string. Returns undef on error.

               my $member = Archive::Zip::Member-&gt;newFromString( 'This is a test',
                                                            'xyz.txt' );

       newFromFile( $fileName )
           Construct a new member from the given file. Returns undef on error.

               my $member = Archive::Zip::Member-&gt;newFromFile( 'xyz.txt' );

       newDirectoryNamed( $directoryName [, $zipname ] )
           Construct a new member from the given directory.  $directoryName must be a valid name on your
           file system; it doesn't have to exist.

           If given, $zipname will be the name of the zip member; it must be a valid Zip (Unix) name. If not
           given, it will be converted from $directoryName.

           Returns undef on error.

               my $member = Archive::Zip::Member-&gt;newDirectoryNamed( 'CVS/' );

       <b>Member</b> <b>Simple</b> <b>accessors</b>

       These methods get (and/or set) member attribute values.

       <u>versionMadeBy()</u>
           Gets the field from the member header.

       fileAttributeFormat( [$format] )
           Gets or sets the field from the member header. These are "FA_*" values.

       <u>versionNeededToExtract()</u>
           Gets the field from the member header.

       <u>bitFlag()</u>
           Gets the general purpose bit field from the member header.  This is where the "GPBF_*" bits live.

       <u>compressionMethod()</u>
           Returns the member compression method. This is the method that is currently being used to
           compress the member data.  This will be COMPRESSION_STORED for added string or file members, or
           any of the "COMPRESSION_*" values for members from a zip file. However, this module can only
           handle members whose data is in COMPRESSION_STORED or COMPRESSION_DEFLATED format.

       desiredCompressionMethod( [$method] )
           Get or set the member's "desiredCompressionMethod". This is the compression method that will be
           used when the member is written. Returns prior desiredCompressionMethod. Only
           COMPRESSION_DEFLATED or COMPRESSION_STORED are valid arguments. Changing to COMPRESSION_STORED
           will change the member desiredCompressionLevel to 0; changing to COMPRESSION_DEFLATED will change
           the member desiredCompressionLevel to COMPRESSION_LEVEL_DEFAULT.

       desiredCompressionLevel( [$method] )
           Get or set the member's desiredCompressionLevel This is the method that will be used to write.
           Returns prior desiredCompressionLevel. Valid arguments are 0 through 9, COMPRESSION_LEVEL_NONE,
           COMPRESSION_LEVEL_DEFAULT, COMPRESSION_LEVEL_BEST_COMPRESSION, and COMPRESSION_LEVEL_FASTEST. 0
           or COMPRESSION_LEVEL_NONE will change the desiredCompressionMethod to COMPRESSION_STORED.  All
           other arguments will change the desiredCompressionMethod to COMPRESSION_DEFLATED.

       <u>externalFileName()</u>
           Return the member's external file name, if any, or undef.

       <u>fileName()</u>
           Get or set the member's internal filename. Returns the (possibly new) filename. Names will have
           backslashes converted to forward slashes, and will have multiple consecutive slashes converted to
           single ones.

       <u>lastModFileDateTime()</u>
           Return the member's last modification date/time stamp in MS-DOS format.

       <u>lastModTime()</u>
           Return the member's last modification date/time stamp, converted to unix localtime format.

               print "Mod Time: " . scalar( localtime( $member-&gt;lastModTime() ) );

       <u>setLastModFileDateTimeFromUnix()</u>
           Set the member's lastModFileDateTime from the given unix time.

               $member-&gt;setLastModFileDateTimeFromUnix( time() );

       <u>internalFileAttributes()</u>
           Return the internal file attributes field from the zip header. This is only set for members read
           from a zip file.

       <u>externalFileAttributes()</u>
           Return member attributes as read from the ZIP file. Note that these are NOT UNIX!

       unixFileAttributes( [$newAttributes] )
           Get or set the member's file attributes using UNIX file attributes. Returns old attributes.

               my $oldAttribs = $member-&gt;unixFileAttributes( 0666 );

           Note that the return value has more than just the file permissions, so you will have to mask off
           the lowest bits for comparisions.

       localExtraField( [$newField] )
           Gets or sets the extra field that was read from the local header. This is not set for a member
           from a zip file until after the member has been written out. The extra field must be in the
           proper format.

       cdExtraField( [$newField] )
           Gets or sets the extra field that was read from the central directory header. The extra field
           must be in the proper format.

       <u>extraFields()</u>
           Return both local and CD extra fields, concatenated.

       fileComment( [$newComment] )
           Get or set the member's file comment.

       <u>hasDataDescriptor()</u>
           Get or set the data descriptor flag. If this is set, the local header will not necessarily have
           the correct data sizes. Instead, a small structure will be stored at the end of the member data
           with these values. This should be transparent in normal operation.

       <u>crc32()</u>
           Return the CRC-32 value for this member. This will not be set for members that were constructed
           from strings or external files until after the member has been written.

       <u>crc32String()</u>
           Return the CRC-32 value for this member as an 8 character printable hex string. This will not be
           set for members that were constructed from strings or external files until after the member has
           been written.

       <u>compressedSize()</u>
           Return the compressed size for this member. This will not be set for members that were
           constructed from strings or external files until after the member has been written.

       <u>uncompressedSize()</u>
           Return the uncompressed size for this member.

       <u>isEncrypted()</u>
           Return true if this member is encrypted. The Archive::Zip module does not currently create or
           extract encrypted members.

       isTextFile( [$flag] )
           Returns true if I am a text file. Also can set the status if given an argument (then returns old
           state). Note that this module does not currently do anything with this flag upon extraction or
           storage. That is, bytes are stored in native format whether or not they came from a text file.

       <u>isBinaryFile()</u>
           Returns true if I am a binary file. Also can set the status if given an argument (then returns
           old state). Note that this module does not currently do anything with this flag upon extraction
           or storage. That is, bytes are stored in native format whether or not they came from a text file.

       extractToFileNamed( $fileName )
           Extract me to a file with the given name. The file will be created with default modes.
           Directories will be created as needed.  The $fileName argument should be a valid file name on
           your file system.  Returns AZ_OK on success.

       <u>isDirectory()</u>
           Returns true if I am a directory.

       <u>writeLocalHeaderRelativeOffset()</u>
           Returns the file offset in bytes the last time I was written.

       <u>wasWritten()</u>
           Returns true if I was successfully written. Reset at the beginning of a write attempt.

       <b>Low-level</b> <b>member</b> <b>data</b> <b>reading</b>

       It is possible to use lower-level routines to access member data streams, rather than the extract*
       methods and <u>contents()</u>. For instance, here is how to print the uncompressed contents of a member in
       chunks using these methods:

           my ( $member, $status, $bufferRef );
           $member = $zip-&gt;memberNamed( 'xyz.txt' );
           $member-&gt;desiredCompressionMethod( COMPRESSION_STORED );
           $status = $member-&gt;rewindData();
           die "error $status" unless $status == AZ_OK;
           while ( ! $member-&gt;readIsDone() )
           {
           ( $bufferRef, $status ) = $member-&gt;readChunk();
           die "error $status"
                               if $status != AZ_OK &amp;&amp; $status != AZ_STREAM_END;
           # do something with $bufferRef:
           print $$bufferRef;
           }
           $member-&gt;endRead();

       readChunk( [$chunkSize] )
           This reads the next chunk of given size from the member's data stream and compresses or
           uncompresses it as necessary, returning a reference to the bytes read and a status. If size
           argument is not given, defaults to global set by Archive::Zip::setChunkSize. Status is AZ_OK on
           success until the last chunk, where it returns AZ_STREAM_END. Returns "( \$bytes, $status)".

               my ( $outRef, $status ) = $self-&gt;readChunk();
               print $$outRef if $status != AZ_OK &amp;&amp; $status != AZ_STREAM_END;

       <u>rewindData()</u>
           Rewind data and set up for reading data streams or writing zip files. Can take options for
           "inflateInit()" or "deflateInit()", but this isn't likely to be necessary.  Subclass overrides
           should call this method. Returns "AZ_OK" on success.

       <u>endRead()</u>
           Reset the read variables and free the inflater or deflater.  Must be called to close files, etc.
           Returns AZ_OK on success.

       <u>readIsDone()</u>
           Return true if the read has run out of data or errored out.

       <u>contents()</u>
           Return the entire uncompressed member data or undef in scalar context. When called in array
           context, returns "( $string, $status )"; status will be AZ_OK on success:

               my $string = $member-&gt;contents();
               # or
               my ( $string, $status ) = $member-&gt;contents();
               die "error $status" unless $status == AZ_OK;

           Can also be used to set the contents of a member (this may change the class of the member):

               $member-&gt;contents( "this is my new contents" );

       extractToFileHandle( $fh )
           Extract (and uncompress, if necessary) the member's contents to the given file handle. Return
           AZ_OK on success.

<b>Archive::Zip::FileMember</b> <b>methods</b>
       The Archive::Zip::FileMember class extends Archive::Zip::Member. It is the base class for both
       ZipFileMember and NewFileMember classes. This class adds an "externalFileName" and an "fh" member to
       keep track of the external file.

       <u>externalFileName()</u>
           Return the member's external filename.

       <u>fh()</u>
           Return the member's read file handle. Automatically opens file if necessary.

<b>Archive::Zip::ZipFileMember</b> <b>methods</b>
       The Archive::Zip::ZipFileMember class represents members that have been read from external zip files.

       <u>diskNumberStart()</u>
           Returns the disk number that the member's local header resides in.  Should be 0.

       <u>localHeaderRelativeOffset()</u>
           Returns the offset into the zip file where the member's local header is.

       <u>dataOffset()</u>
           Returns the offset from the beginning of the zip file to the member's data.

<b>REQUIRED</b> <b>MODULES</b>
       Archive::Zip requires several other modules:

       Carp

       Compress::Zlib

       Cwd

       File::Basename

       File::Copy

       File::Find

       File::Path

       File::Spec

       File::Spec

       IO::File

       IO::Seekable

       Time::Local

<b>AUTHOR</b>
       Ned Konz, &lt;nedkonz@cpan.org&gt;

<b>CURRENT</b> <b>MAINTAINER</b>
       Steve Peters, &lt;steve@fisharerojo.org&gt;

       File attributes code by Maurice Aubrey &lt;maurice@lovelyfilth.com&gt;

<b>COPYRIGHT</b>
       Copyright (c) 2000-2004 Ned Konz, 2005 Steve Peters. All rights reserved.  This program is free
       software; you can redistribute it and/or modify it under the same terms as Perl itself.

<b>SEE</b> <b>ALSO</b>
       Compress::Zlib

       Archive::Tar

       There is a Japanese translation of this document at
       &lt;<a href="http://www.memb.jp/~deq/perl/doc-ja/Archive-Zip.html">http://www.memb.jp/~deq/perl/doc-ja/Archive-Zip.html</a> that was done by DEQ &lt;deq@oct.zaq.ne.jp&gt; .
       Thanks!



perl v5.8.8                                      2005-06-22                                  Archive::Zip(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Archive__Zip.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Archive__Zip.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Archive__Zip.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
