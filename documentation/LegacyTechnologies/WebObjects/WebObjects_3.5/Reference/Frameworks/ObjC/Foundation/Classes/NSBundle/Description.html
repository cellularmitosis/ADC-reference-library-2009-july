<html><head><title></title></head>

<body bgcolor="#ffffff">

 

 

<h1>

<FONT COLOR="#000066">

<a name="122">

 <a name="//apple_ref/occ/cl/NSBundle">NSBundle</a>

</a>

</FONT>

</h1>

<p><B>Inherits From:</B><BR>  

 NSObject 



<p><B>Conforms To:</B><BR>

 NSObject (NSObject) 



<p><B>Declared In:	</B><BR>

 Foundation/NSBundle.h 



<p><p>

<a name="153"></a>

<HR WIDTH=75% SIZE=4 ALIGN=LEFT>

<H3>

<FONT COLOR="#201040">

Class At A Glance

</FONT>

</H3>

<dl><a name="154"></a>

<dt><h4>Purpose</h4>

<dd><dl>

<dt>An NSBundle represents a location in the file system that groups code and resources that can be used in a program. NSBundles locate program resources, dynamically load executable code, and assist in localization. You build a bundle in Project Builder using one of these project types: Application, Framework, Loadable Bundle, Palette.

</dl></dd>

<a name="156"></a>

<dt><h4>Principal Attribute</h4>

</dl><ul><li>Directory path<br>

</ul><dl><a name="158"></a>

<dt><h4>Creation<p>

<Table Border="3">

<caption></caption>

<tr><td scope="row">-<code> </code>initWithPath:

</td><td>(designated initializer)

</td></tr>

<tr><td scope="row">+ mainBundle

</td><td>Returns the NSBundle for the application wrapper.

</td></tr>

<tr><td scope="row">+<code> </code>bundleForClass:

</td><td>Returns the NSBundle in which the class is implemented.

</td></tr>

<tr><td scope="row">+ bundleWithPath:

</td><td>Returns the NSBundle at a location in the file system.

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

</h4>

<a name="159"></a>

<dt><h4>Commonly Used Methods<p>

<Table Border="3">

<caption></caption>

<tr><td>-<code> </code>localizedStringForKey:value:table:

</td><td>Returns a localized version of a string.

</td></tr>

<tr><td scope="row">- pathForResource:ofType:

</td><td>Returns the path for the specified resource.

</td></tr>

<tr><td scope="row">- principalClass

</td><td>Returns the principal class, dynamically loading code if needed.

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

</h4>

</dl><HR WIDTH=75% SIZE=4 ALIGN=LEFT>

<p><a name="161"></a>

<a name="description"></a>

<H2>Class Description 

</H2>

An NSBundle is an object that corresponds to a directory where related resources-including executable code-are stored. The directory, in essence, "bundles" a set of resources used by an application into convenient chunks, and the NSBundle object makes those resources available to the application. NSBundle can find requested resources in the directory and can dynamically load executable code. The term <em>bundle</em> refers both to the object and to the directory it represents.<p>

Bundles are useful in a variety of contexts. Since bundles combine executable code with the resources used by that code, they facilitate installation and localization. NSBundles are also used to locate specific resources, to obtain localized strings, to load code dynamically, and to determine which classes are loaded.<p>

Each resource in a bundle usually resides in its own file. Bundled resources include such things as:<p>

<ul><li>Executable code<br>

<li>Images-TIFF or EPS images used by an application's user interface <br>

<li>Sounds<br>

<li>Localized character strings<br>

<li>Nib files-Interface Builder files describing user-interface objects and their relationships <br>

</ul>The Project Builder application defines four types of projects that build bundles as <em>file packages.</em> A file package is a directory that the Workspace Manager presents to users as if it were a simple file; the contents of the directory are hidden. The four types of Project Builder bundles are:<p>

<ul><li><code>Application</code>. The application wrapper is a bundle that contains the resources needed to launch the application, including the application executable. This bundle is also known as the main bundle. Its extension is ".app".<p>

<li><code>Framework</code>. A framework is a directory containing a dynamic shared library and all the resources that go with that library, such as header files, images, and documentation. Its extension is ".framework".<p>

<li><code>Loadable Bundle</code>. Like an application, a loadable bundle usually contains executable code and associated resources. Loadable bundles differ from applications and frameworks because they must be explicitly loaded into a running application. (See "Loadable Bundles," below for more information.) The extension of a loadable bundle is conventionally ".bundle" but can be something else (for example, ".preference").<p>

<li><code>Palette</code>. A palette is a type of loadable bundle specialized for Interface Builder. It contains custom user-interface objects and compiled code that are loaded into an Interface Builder palette.<p>

</ul>For all types of bundles, the executable-code file of a bundle (of which there can be only one) is in the immediate bundle directory and takes the same name as the bundle, minus the extension. Bundles also encode (as a property list) the important attributes of the bundle, such as the main nib file name, executable name, document extensions, and so forth. You can access these attributes with NSBundle's <code>infoDictionary</code> method, which returns the file's contents as an NSDictionary.<p>

You shouldn't attempt to create an NSBundle subclass since the designated initializer, <code>initWithPath:</code>, might substitute another NSBundle for <code>self</code>.<p>

<h3>

<a name="177">

 The Main Bundle

</a>

</h3>

Every application has at least one bundle-its <em>main bundle</em>-which is the ".app" directory where its executable file is located. This file is loaded into memory when the application is launched. It includes at least the <code>main()</code> function and other code necessary to start up the application. You obtain an NSBundle object corresponding to the main bundle with the class method <code>mainBundle</code>.<p>

<h3>

<a name="179">

 Framework Bundles

</a>

</h3>

Frameworks are bundles that package dynamic shared libraries along with the nib files, images, and other resources that support the executable code and with the header files and documentation that describe the associated APIs. As long as your applications are dynamically linked with frameworks, you should have little need to do anything explicitly with those frameworks thereafter; in a running application, the framework code is automatically loaded, as needed. You can however, get an NSBundle object associated with a framework by invoking the class method <code>bundleForClass:</code> specifying, as the argument, a class that's defined in the framework. <p>

<h3>

<a name="181">

 Loadable Bundles and Dynamic Loading

</a>

</h3>

An application can be organized into any number of other bundles in addition to the main bundle and the bundles of linked-in frameworks. Although these loadable bundles usually reside inside the application file package, they can be located anywhere in the file system. Each loadable-bundle directory-by convention, with a ".bundle" extension-is represented in the application by a separate NSBundle object. Through this object the application can dynamically load the code and resources in the bundle when it needs them. For example, an application for managing PostScript printers may have a bundle full of PostScript code to be downloaded to printers. <p>

The executable code files in loadable bundles hold class (and category) definitions that the NSBundle object can dynamically load while the application runs. When asked for a certain class (through the invocation of<code> classNamed:</code> or <code>principalClass</code>), the NSBundle loads the object file that contains the class definition (if it's not already loaded) and returns the class object; it also loads other classes and categories that are stored in the file. <p>

The major advantage of bundles is application extensibility. A set of bundled classes often supports a small collection of objects that can be integrated into the larger object network already in place. (NEXTSTEP Preferences is one example of this.) The linkage is established through an instance of the <em>principal class</em>. This object might have methods to return other objects that the application can talk to, but typically all messages from the application to the subnetwork are funneled through the one instance.<p>

Since each bundle can have only one executable file, that file should be kept free of localizable content. Anything that needs to be localized should be segregated into separate resource files and stored in localized-resource subdirectories.<p>

<B>Note:	</B>

To create a loadable bundle-a bundle with dynamically loadable code-without using Project 

Builder, use the <code>ld</code>(1) <code>-bundle</code> flag on the <code>cc</code> command line.

<h3>

<a name="187">

 Localized Resources

</a>

</h3>

If an application is to be used in more than one part of the world, its resources may need to be customized, or "localized," for language, country, or cultural region. An application may need, for example, to have separate Japanese, English, French, Hindu, and Swedish versions of the character strings that label menu commands.<p>

Resource files specific to a particular language are grouped together in a subdirectory of the bundle directory. The subdirectory has the name of the language (in English) followed by a ".lpro<code>j</code>" extension (for "language project"). The application mentioned above, for example, would have <code>Japanese.lproj</code>, <code>English.lproj</code>, <code>French.lproj</code>, <code>Hindi.lproj</code>, and <code>Swedish.lproj</code> subdirectories. Each ".lproj" subdirectory in a bundle has the same set of files; all versions of a resource file must have the same name. Thus, <code>Hello.snd</code> in <code>French.lproj</code> should be the French counterpart to the Swedish <code>Hello.snd</code> in <code>Swedish.lproj</code>, and so on. If a resource doesn't need to be localized at all, it's stored in the bundle directory itself, not in the ".lproj" subdirectories.<p>

The user determines which set of localized resources will actually be used by the application. NSBundle objects rely on the language preferences set by the user in the Preferences application. Preferences lets users order a list of available languages so that the most preferred language is first, the second most preferred language is second, and so on.<p>

When an NSBundle is asked for a resource file, it provides the path to the resource that best matches the user's language preferences. For details, see the descriptions of<code> pathForResource:ofType:inDirectory</code> and <code>pathForResource:ofType:.</code><p>

<h3>

<a name="192">

 How NSBundles Locate Resources

</a>

</h3>

A bundle's resources are typically stored in a directory named <code>Resources</code> within the bundle directory. Within the <code>Resources</code> directory are non-localized resources and localized resource directories (<code>English.lproj</code>, <code>Swedish.lproj</code>, and so on). Generally, when an NSBundle looks for resources, it starts at the top, in a non-localized location, and searches "downward" toward the localized directories.<p>

For example, suppose you want to find a resource with name "Main" and type "nib". NSBundle searches the <code>Resource</code> directory at the "top" non-localized level for the file "Main.nib". If it doesn't find the file there, NSBundle then searches each of the language subdirectories in the user's preferred order of languages. By this scheme, the localized version of a resource that also exists at the top level will not be found, but the non-localized one will be. For this reason, you should place all non-localized resources in the top level of Resources, and you shouldn't put any localized resources there.<p>

When it finds a resource, an NSBundle checks if a resource of the name "Main<code>-</code><em>$(PLATFORM_OS)</em>" of type "nib" exists. <em>$(PLATFORM_OS)</em> represents the make variable of the same name, and takes on the same values that the make variable takes on at compile time. For example, on Windows, during a project build, "$(PLATFORM_OS)" in the <code>Makefile.postamble</code> will yield the value "winnt". When "Main.nib" is found in a directory, the NSBundle also sees if "Main-winnt.nib" exists in that same directory. If it does, the NSBundle returns the path to the platform-specific resource; if it does not, it returns the path to "Main.nib". Note that for "Main-winnt.nib" to be found, a file named "Main.nib" must exist in the same directory (including language-specific resource directories). You typically give one platform-general version of a resource the name without this <em>$(PLATFORM_OS)</em> suffix, and give the platform-specific versions of the resource extended names. The values that <em>$(PLATFORM_OS)</em> can take are currently "winnt" (on OPENSTEP for Windows), "nextstep" (on OPENSTEP for MACH), "hpux"(on PDO for HP-UX), and "solaris" (on PDO for Solaris).<p>

Another way to accommodate platform-specific resources is to use the <code>inDirectory:</code> parameter of NSBundle's resource-searching methods. The <code>inDirectory:</code> parameter is intended for locating resources of a common type or purpose that are put in a single directory; for example, all images could be put into a directory called "Images" within the <code>Resource</code> directory. (However, note that the Application Kit's <code>imageNamed:</code> class method in NSImage does not support searching arbitrary directories for images.) You can thus use specialized resource subdirectories and the <code>inDirectory:</code> parameter to manage platform-specific resources. This is not "automatic" functionality, however, since it requires the developer to specify the name of the platform-specific directory as well as replicate the required resources and language projects within that directory. The <em>$(PLATFORM_OS)</em> mechanism is simpler to use, particularly if the number of platform-specific resources is small.<p>

<h3>

<a name="197">

 Application Kit Additions to NSBundle

</a>

</h3>

The Application Kit defines three categories of NSBundle: one for locating image resources, one for loading nib files, and one for accessing context help. The methods in these categories become part of the NSBundle class only for those applications that use the Application Kit. For details, see the NSBundleAdditions specification in the Application Kit reference documentation.<p>

<a name="199">

<HR WIDTH=50% ALIGN=LEFT>

<h2>Method Types 

</h2>

</a><dl>

<dt>Initializing an NSBundle<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSBundle/initWithPath:">- initWithPath:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Getting an NSBundle<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSBundle/bundleForClass:">+ bundleForClass:</a><dt><a href="#//apple_ref/occ/clm/NSBundle/bundleWithPath:">+ bundleWithPath:</a><dt><a href="#//apple_ref/occ/clm/NSBundle/mainBundle">+ mainBundle</a><dt><a href="#//apple_ref/occ/clm/NSBundle/allBundles">+ allBundles</a><dt><a href="#//apple_ref/occ/clm/NSBundle/allFrameworks">+ allFrameworks</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Getting a bundled class<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSBundle/classNamed:">- classNamed:</a><dt><a href="#//apple_ref/occ/instm/NSBundle/principalClass">- principalClass</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Finding a resource<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSBundle/pathForResource:ofType:inDirectory:">+ pathForResource:ofType:inDirectory:</a><dt><a href="#//apple_ref/occ/instm/NSBundle/pathForResource:ofType:">- pathForResource:ofType:</a><dt><a href="#//apple_ref/occ/instm/NSBundle/pathForResource:ofType:inDirectory:">- pathForResource:ofType:inDirectory:</a><dt><a href="#//apple_ref/occ/instm/NSBundle/pathsForResourcesOfType:inDirectory:">- pathsForResourcesOfType:inDirectory:</a><dt><a href="#//apple_ref/occ/instm/NSBundle/resourcePath">- resourcePath</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Getting the bundle directory<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSBundle/bundlePath">- bundlePath</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Getting bundle information<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSBundle/infoDictionary">- infoDictionary</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Managing localized resources<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSBundle/localizedStringForKey:value:table:">- localizedStringForKey:value:table:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Loading a bundle's code<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSBundle/load">- load</a></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<HR WIDTH=50% ALIGN=LEFT>

<a name="225"></a>

<a name="clm"></a>

<h2>Class Methods</h2>  





<a name="226"></a>

<h3><a name="//apple_ref/occ/clm/NSBundle/allBundles">allBundles</a></h3>

+ (NSArray *)<code>allBundles</code>

<P>Returns an array of all the application's non-framework bundles. This includes the main bundle and all bundles that have been dynamically created but doesn't contain any bundles that represent frameworks.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="229"></a>

<h3><a name="//apple_ref/occ/clm/NSBundle/allFrameworks">allFrameworks</a></h3>

+ (NSArray *)<code>allFrameworks</code>

<P>Returns an array of all of the application's bundles that represent frameworks. This includes frameworks which are linked into an application when the application is built and bundles for frameworks which have been dynamically created.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="232"></a>

<h3> <a name="//apple_ref/occ/clm/NSBundle/bundleForClass:">bundleForClass:</a></h3>

+ (NSBundle *)<code>bundleForClass:</code>(Class)<em>aClass</em> 

<P>Returns the NSBundle that dynamically loaded <em>aClass</em> (a loadable bundle), the NSBundle for the framework in which <em>aClass</em> is defined, or the main bundle object if <em>aClass</em> was not dynamically loaded or is not defined in a framework. <p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSBundle/mainBundle">+ mainBundle</a></code>, <a href="#//apple_ref/occ/clm/NSBundle/bundleWithPath:"><code>+ bundleWithPath:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="236"></a>

<h3> <a name="//apple_ref/occ/clm/NSBundle/bundleWithPath:">bundleWithPath:</a></h3>

+ (NSBundle *)<code>bundleWithPath:</code>(NSString *)<em>path</em> 

<P>Returns an NSBundle that corresponds to the specified directory <em>path</em> or <code>nil</code> if <em>path</em> does not identify an accessible bundle directory. This method allocates and initializes the returned object if it doesn't already exist.   <p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSBundle/mainBundle">+ mainBundle</a></code>, <a href="#//apple_ref/occ/clm/NSBundle/bundleForClass:"><code>+ bundleForClass:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="240"></a>

<h3> <a name="//apple_ref/occ/clm/NSBundle/mainBundle">mainBundle</a></h3>

+ (NSBundle *)<code>mainBundle</code> 

<P>Returns an NSBundle that corresponds to the directory where the application executable is located or <code>nil</code> if this executable is not located in a accessible bundle directory. This method allocates and initializes the returned NSBundle if it doesn't already exist.<p>

In general, the main bundle corresponds to an application file package or application wrapper: a directory that bears the name of the application and is marked by a ".app" extension.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSBundle/bundleForClass:">+ bundleForClass:</a></code>, <a href="#//apple_ref/occ/clm/NSBundle/bundleWithPath:"><code>+ bundleWithPath:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="245"></a>

<h3> <a name="//apple_ref/occ/clm/NSBundle/pathForResource:ofType:inDirectory:">pathForResource:ofType:inDirectory:</a></h3>

+ (NSString *)<code>pathForResource:</code>(NSString *)<em>name<br></em><code>ofType:</code>(NSString *)<em>extension<br></em><code>inDirectory:</code>(NSString *)<em>bundlePath</em>

<P>Returns the full pathname for the resource identified by <em>name</em>, having the specified file name <em>extension</em>, and residing in the directory <em>bundlePath</em>; returns <code>nil</code> if no matching resource file exists in the bundle. The argument <em>bundlePath</em> must be a valid bundle directory. The argument <em>extension</em> can be an empty string or <code>nil</code>; in either case the pathname returned is the first one encountered with <em>name</em>, regardless of the extension. If <em>bundlePath</em> is specified, the method searches in this order:<p>

	<em>bundlePath</em><code>/Resources/</code><em>name.extension<br></em>	<em>bundlePath</em><code>/Resources/</code>&lt;language.lproj&gt;/<em>name.extension<br></em>	<em>bundlePath</em>/<em>name.extension<br></em>	<em>bundlePath</em>/&lt;language.lproj&gt;/<em>name.extension</em><p>

The order of language directories searched corresponds to the user's preferences.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSBundle/localizedStringForKey:value:table:">- localizedStringForKey:value:table:</a></code>, <a href="#//apple_ref/occ/instm/NSBundle/pathForResource:ofType:"><code>- pathForResource:ofType:</a></code>, <a href="#//apple_ref/occ/instm/NSBundle/pathForResource:ofType:inDirectory:"><code>- pathForResource:ofType:inDirectory:</code></a>, 

<a href="#//apple_ref/occ/instm/NSBundle/pathsForResourcesOfType:inDirectory:"><code>- pathsForResourcesOfType:inDirectory:</a>

</code><p><HR WIDTH=50% ALIGN=LEFT>

<a name="instm"></a>

<h2>Instance Methods</h2>  





<a name="252"></a>

<h3>

 <a name="//apple_ref/occ/instm/NSBundle/bundlePath">bundlePath</a>

</h3>

- (NSString *)<code>bundlePath</code> 

<P>Returns the full pathname of the receiver's bundle directory.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="255"></a>

<h3> <a name="//apple_ref/occ/instm/NSBundle/classNamed:">classNamed:</a></h3>

- (Class)<code>classNamed:</code>(NSString *)<em>className</em> 

<P>Returns the class named <em>className</em>. If the bundle's executable code is not yet loaded, this method dynamically loads it into memory. The method returns <code>nil</code> if <em>className</em> isn't one of the classes associated with the receiver or if there is an error in loading the executable code containing the class implementation. Classes (and categories) are loaded from just one file within the bundle directory; this code file has the same name as the directory, but without the extension (".bundle," ".app," ".framework"). As a side-effect of code loading, the receiver posts NSBundleNotification for each class and category loaded; see "Notifications," below for details. <p>

The following example loads a bundle's executable code containing the class "FaxWatcher."<p>

<blockquote><pre>- (void)loadBundle:(id)sender<br>{<br>    Class exampleClass;<br>    id newInstance;<br>    NSString *str = @"/me/Projects/BundleExample/BundleExample.bundle";<br>    NSBundle *bundleToLoad = [NSBundle bundleWithPath:str];<br>    if (exampleClass = [bundleToLoad classNamed:@"FaxWatcher"]) {<br>        newInstance = [[exampleClass alloc] init];<br>    // [newInstance doSomething];<br>    }<br>}

</pre></blockquote><p><B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSBundle/principalClass">- principalClass</a></code><code>, <a href="#//apple_ref/occ/instm/NSBundle/load"></code><code>- load</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="261"></a>

<h3><a name="//apple_ref/occ/instm/NSBundle/infoDictionary">infoDictionary</a></h3>

- (NSDictionary *)<code>infoDictionary</code>

<P>Returns a dictionary that contains information about the receiver. This information is extracted from the property list (<code>Info.plist</code>) associated with the bundle. The returned dictionary is empty if no <code>Info.plist</code> can be found. Common keys for accessing the values of the dictionary are NSExecutable, NSExtensions, NSIcon, NSMainNibFile, and NSPrincipalClass. <p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSBundle/principalClass">- principalClass</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="265"></a>

<h3> <a name="//apple_ref/occ/instm/NSBundle/initWithPath:">initWithPath:</a></h3>

- (id)<code>initWithPath:</code>(NSString *)<em>fullPath</em> 

<P>Returns an NSBundle corresponding to the directory<em> fullPath</em>. This method initializes and returns a new instance only if there is no existing NSBundle associated with <em>fullPath</em>, in which case it deallocates <code>self</code> and returns the existing object. <em>fullPath</em> must be a full pathname for a directory; if it contains any symbolic links, they must be resolvable. If the directory doesn't exist or the user doesn't have access to it, this method returns <code>nil</code>. <p>

It's not necessary to allocate and initialize an instance for the main bundle; use the <code>mainBundle</code> class method to get this instance. You can also use the <code>bundleWithPath:</code> class method to obtain a bundle identified by its directory path.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSBundle/bundleForClass:">+ bundleForClass:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="270"></a>

<h3><a name="//apple_ref/occ/instm/NSBundle/load">load</a></h3>

- (BOOL)<code>load</code>

<P>Dynamically loads the bundle's executable code into a running program, if the code has not already been loaded. A bundle attempts to load its code-if it has any-only once. Returns YES if the method successfully loaded the bundle's code or if the code had already been loaded. Returns NO if the method failed to load the code.<p>

<B>Note:	</B>

You don't need to load a bundle's executable code to search the bundle's resources.

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSBundle/classNamed:">- classNamed:</a></code>, <a href="#//apple_ref/occ/instm/NSBundle/principalClass"><code>- principalClass</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="275"></a>

<h3> <a name="//apple_ref/occ/instm/NSBundle/localizedStringForKey:value:table:">localizedStringForKey:value:table:</a></h3>

- (NSString *)<code>localizedStringForKey:</code>(NSString *)<em>key <br></em><code>value:</code>(NSString *)<em>value <br></em><code>table:</code>(NSString *)<em>tableName</em> 

<P>Returns a localized version of the string designated by <em>key</em> in table <em>tableName</em>.<em> </em>The argument<em> tableName</em> specifies the receiver's string table to search. If <em>tableName</em> is <code>nil</code> or is an empty string, the method attempts to use the table in <code>Localizable.strings</code>.<em> </em>The<em> value</em> argument specifies the value to return if <em>key</em> is <code>nil</code> or if a localized string for <em>key</em> can't be found in the table. If <em>value</em> is <code>nil</code> or an empty string, and a localized string is not found in the table, the method returns <em>key</em>. If <em>key</em> and <em>value</em> are both <code>nil</code>, the method returns the empty string.<p>

<B>Note:	</B>

Using the user default NSShowNonLocalizedStrings, you can alter the behavior of 

<code>localizedStringForKey:value:table:</code> to log a message when the method can't find a localized string. 

If you set this default to YES (in the global domain or in the application's domain), then when the 

method can't find a localized string in the table, it logs a message to the console and capitalizes <em>key</em> 

before returning it.

The following example cycles through a static array of keys when a button is clicked, gets the value for each key from a strings table named <code>Buttons.strings</code>, and sets the button title with the returned value.<p>

<blockquote><pre>- (void)changeTitle:(id)sender<br>{<br>    static int keyIndex = 0;<br>    NSBundle *thisBundle = [NSBundle bundleForClass:[self class]];<br><br>    NSString *locString = [thisBundle<br>        localizedStringForKey:assortedKeys[keyIndex++] <br>        value:@"" table:@"Buttons"];<br>    [sender setTitle:locString];<br>    if (keyIndex == MAXSTRINGS) keyIndex=0;<br>}

</pre></blockquote><p><B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSBundle/pathForResource:ofType:">- pathForResource:ofType:</a></code>, <a href="#//apple_ref/occ/instm/NSBundle/pathForResource:ofType:inDirectory:"><code>- pathForResource:ofType:inDirectory:</a></code>, 

<code><a href="#//apple_ref/occ/instm/NSBundle/pathsForResourcesOfType:inDirectory:">- pathsForResourcesOfType:inDirectory:</a>, <a href="#//apple_ref/occ/clm/NSBundle/pathForResource:ofType:inDirectory:">+ pathForResource:ofType:inDirectory:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="282"></a>

<h3> <a name="//apple_ref/occ/instm/NSBundle/pathForResource:ofType:">pathForResource:ofType:</a></h3>

- (NSString *)<code>pathForResource:</code>(NSString *)<em>name </em><code>ofType:</code>(NSString *)<em>extension</em>

<P>Returns the full pathname for the resource identified by <em>name</em> and having the specified file <em>extension</em>. If the <em>extension</em> argument is <code>nil</code> or an empty string (@""), the resource sought is identified by <em>name</em>, with no extension. The method first looks for a non-localized resource in the immediate bundle directory; if the resource is not there, it looks for the resource in the language-specific ".lproj" directory (the local language is determined by user defaults).<p>

The following code fragment gets the path to a localized sound, creates an Sound instance from it, and plays the sound.<p>

<blockquote><pre>NSString *soundPath;<br>Sound *thisSound;<br>NSBundle *thisBundle = [NSBundle bundleForClass:[self class]];<br>if (soundPath = [thisBundle pathForResource:@"Hello" ofType:@"snd"]) {<br>    thisSound = [[[Sound alloc] initFromSoundfile:soundPath] autorelease];<br>    [thisSound play];<br>}

</pre></blockquote><p><B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSBundle/localizedStringForKey:value:table:">- localizedStringForKey:value:table:</a></code>,<code> <a href="#//apple_ref/occ/instm/NSBundle/pathForResource:ofType:inDirectory:"></code><code>- pathForResource:ofType:inDirectory:</a></code>, 

<code><a href="#//apple_ref/occ/instm/NSBundle/pathsForResourcesOfType:inDirectory:">- pathsForResourcesOfType:inDirectory:</a></code>,<code> <a href="#//apple_ref/occ/clm/NSBundle/pathForResource:ofType:inDirectory:">+ pathForResource:ofType:inDirectory:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="288"></a>

<h3> <a name="//apple_ref/occ/instm/NSBundle/pathForResource:ofType:inDirectory:">pathForResource:ofType:inDirectory:</a></h3>

- (NSString *)<code>pathForResource:</code>(NSString *)<em>name <br></em><code>ofType:</code>(NSString *)<em>extension <br></em><code>inDirectory:</code>(NSString *)<em>bundlePath </em>

<P>Returns the full pathname for the resource identified by <em>name</em>, having the specified file name <em>extension</em>, and residing in the directory <em>bundlePath</em>; returns <code>nil</code> if no matching resource file exists in the bundle. The argument <em>bundlePath</em> must be a valid bundle directory or <code>nil</code>. The argument <em>extension</em> can be an empty string or <code>nil</code>; in either case the pathname returned is the first one encountered with <em>name</em>, regardless of the extension. If <em>bundlePath</em> is specified, the method searches in this order:<p>

	&lt;main bundle path&gt;<code>/Resources/</code><em>bundlePath</em><code>/</code><em>name</em>.<em>extension<br>	</em>&lt;main bundle path&gt;<code>/Resources/</code><em>bundlePath</em><code>/</code>&lt;language.lproj&gt;<code>/</code><em>name</em>.<em>extension<br></em>	&lt;main bundle path&gt;<code>/</code><em>bundlePath</em><code>/</code><em>name</em>.<em>extension<br></em>	&lt;main bundle path&gt;<code>/</code><em>bundlePath</em><code>/</code>&lt;language.lproj&gt;<code>/</code><em>name</em>.<em>extension</em><p>

The order of language directories searched corresponds to the user's preferences. If <em>bundlePath</em> is <code>nil</code>, the same search order as described above is followed, minus <em>bundlePath</em>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSBundle/localizedStringForKey:value:table:">- localizedStringForKey:value:table:</a></code>,<code> <a href="#//apple_ref/occ/instm/NSBundle/pathForResource:ofType:"></code><code>- pathForResource:ofType:</a></code>, 

<code><a href="#//apple_ref/occ/instm/NSBundle/pathsForResourcesOfType:inDirectory:">- pathsForResourcesOfType:inDirectory:</a></code>,<code> <a href="#//apple_ref/occ/clm/NSBundle/pathForResource:ofType:inDirectory:">+ pathForResource:ofType:inDirectory:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="294"></a>

<h3> <a name="//apple_ref/occ/instm/NSBundle/pathsForResourcesOfType:inDirectory:">pathsForResourcesOfType:inDirectory:</a></h3>

- (NSArray *)<code>pathsForResourcesOfType:</code>(NSString *)<em>extension <br></em><code>inDirectory:</code>(NSString *)<em>bundlePath </em>

<P>Returns an array containing pathnames for all bundle resources having the specified file name <em>extension</em> and residing in the directory <em>bundlePath</em>; returns an empty array if no matching resource files are found. This method provides a means for dynamically discovering bundle resources. The argument <em>bundlePath</em> must be a valid bundle directory or <code>nil</code>. The <em>extension</em> argument can be an empty string or <code>nil</code>; if you specify either of these for <em>extension</em>, however, all bundle resources are returned. Although there is no guaranteed search order, all of the following directories will be searched:<p>

	&lt;main bundle path&gt;<code>/Resources/</code><em>bundlePath</em><code>/</code><em>name</em>.<em>extension<br>	</em>&lt;main bundle path&gt;<code>/Resources/</code><em>bundlePath</em><code>/</code>&lt;language.lproj&gt;<code>/</code><em>name</em>.<em>extension<br></em>	&lt;main bundle path&gt;<code>/</code><em>bundlePath</em><code>/</code><em>name</em>.<em>extension<br></em>	&lt;main bundle path&gt;<code>/</code><em>bundlePath</em><code>/</code>&lt;language.lproj&gt;<code>/</code><em>name</em>.<em>extension</em><p>

The language directories searched corresponds to the user's preferences. If <em>bundlePath</em> is <code>nil</code>, the same search order as described above is followed, minus <em>bundlePath</em>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSBundle/localizedStringForKey:value:table:">- localizedStringForKey:value:table:</a></code>,<code> <a href="#//apple_ref/occ/instm/NSBundle/pathForResource:ofType:"></code><code>- pathForResource:ofType:</a></code>,<code> <a href="#//apple_ref/occ/instm/NSBundle/pathForResource:ofType:inDirectory:"></code><code>- pathForResource:ofType:inDirectory:</a></code>,<code> <a href="#//apple_ref/occ/clm/NSBundle/pathForResource:ofType:inDirectory:">+ pathForResource:ofType:inDirectory:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="300"></a>

<h3> <a name="//apple_ref/occ/instm/NSBundle/principalClass">principalClass</a></h3>

- (Class)<code>principalClass</code> 

<P>Returns the NSBundle's principal class after ensuring that the code containing the definition of that class is dynamically loaded. If the NSBundle encounters errors in loading or if it can't find the executable code file in the bundle directory, it returns <code>nil</code>. The principal class typically controls all the other classes in the bundle; it should mediate between those classes and classes external to the bundle. Classes (and categories) are loaded from just one file within the bundle directory. NSBundle obtains the name of the code file to load from the dictionary returned from <code>infoDictionary</code>, using "NSExecutable" as the key. The NSBundle determines its principal class in one of two ways:<p>

<ul><li>It first looks in its own information dictionary, which extracts the information encoded in the bundle's property list (<code>Info.plist</code>). NSBundle obtains the principal class from the dictionary using the key NSPrincipalClass. For non-loadable bundles (applications and frameworks), if the principal class is not specified in the property list, the method returns <code>nil</code>. <p>

<li>If the principal class is not specified in the information dictionary, NSBundle identifies the first class loaded as the principal class. When several classes are linked into a dynamically loadable file, the default principal class is the first one listed on the <code>ld</code> command line. In the following example, Reporter would be the principal class:<p>

</ul><blockquote><pre>ld -o myBundle -r Reporter.o NotePad.o QueryList.o<br>

</pre></blockquote><p><B>Note:	</B>

The order of classes in Project Builder's project browser is the order in which they will be linked. To 

designate the principal class, Control-drag the file containing its implementation to the top of the list.

As a side-effect of code loading, the receiver posts NSBundleDidLoadNotification after each class and category is loaded; see "Notifications," below for details. <p>

The following method obtains a bundle by specifying its path (<code>bundleWithPath:</code>), then loads the bundle with <code>principalClass</code> and uses the returned class object to allocate and initialize an instance of that class.<p>

<blockquote><pre>- (void)loadBundle:(id)sender<br>{<br>    Class exampleClass;<br>    id newInstance;<br>    NSString *path = @"/tmp/Projects/BundleExample/BundleExample.bundle";<br>    NSBundle *bundleToLoad = [NSBundle bundleWithPath:path];<br>    if (exampleClass = [bundleToLoad principalClass]) {<br>        newInstance = [[exampleClass alloc] init];<br>        [newInstance doSomething];<br>    }<br>}

</pre></blockquote><p><B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSBundle/classNamed:">- classNamed:</a></code>, <a href="#//apple_ref/occ/instm/NSBundle/infoDictionary"><code>- infoDictionary</a></code>,<code> <a href="#//apple_ref/occ/instm/NSBundle/load"></code><code>- load</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="311"></a>

<h3> <a name="//apple_ref/occ/instm/NSBundle/resourcePath">resourcePath</a></h3>

- (NSString *)<code>resourcePath</code>

<P>Returns the full pathname of the receiving bundle's subdirectory containing resources.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSBundle/bundlePath">- bundlePath</a>

</code><p><a name="315">

<HR WIDTH=50% ALIGN=LEFT>

<h2>Notifications

</h2>

</a>The following notification is declared and posted by NSBundle. <p>

<a name="317"></a>

<h3> NSBundleDidLoadNotification</h3>

This notification contains a notification object and a userInfo dictionary. The notification object is the NSBundle that dynamically loads classes. The userInfo dictionary contains these keys and values:<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Key</b>

</th><th><b>Value</b>

</th></tr>

<tr><td scope="row">NSLoadedClasses

</td><td>An NSArray containing the names (as NSStrings) of each class that 

was loaded

</td></tr>



</Table>



<Table>

<tr><td>

</Table>

<p>

NSBundle posts NSBundleDidLoadNotification to notify observers which classes have been dynamically loaded. When a request is made to an NSBundle for a class (<code>classNamed:</code> or <code>principalClass</code>), the bundle dynamically loads the executable code file that contain the class implementation and all other class definitions contained in the file. After the module is loaded, the NSBundle posts a notification with a <code>userInfo</code> dictionary containing all classes that were loaded.<p>

In a typical use of this notification, an object might want to enumerate the <code>userInfo</code> NSArray to check if each loaded class conformed to a certain protocol (say, a protocol for a plug-and-play tool set); if a class does conform, the object would create an instance of that class and add the instance to another NSArray.<p>



 

 





<i>Copyright &#169; 1997, Apple Computer, Inc.   All rights

reserved.</i>



<!-- Last updated: 06/17/97 16:46:07 -->



</body>

</html>

