<HTML>		<HEAD>		<TITLE>					</TITLE>		</HEAD>	<body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../../webobjects.html" target="_top">WebObjects 4.5 Documentation</a> <b>&gt;</b>EOControl Reference</font><br><br><!--end of path --><a href="../../EOControlTOC.html"><img src="../../../../../../../images/up.gif" border="0" alt="Table of Contents"></a><h1><FONT COLOR="#000066"><a name="//apple_ref/java/cl/EODelayedObserverQueue">EODelayedObserverQueue</a></FONT></h1><br><br><a name = "BABDFBBD"></a><h2>Enqueuing a Delayed Observer</h2><p>The  <a href="../EODelayedObserverQueue.html#//apple_ref/java/instm/EODelayedObserverQueue/enqueueObserver">enqueueObserver</a> method records anEODelayedObserver for later change notification. However, enqueuingis usually performed automatically by an EODelayedObserver in its  <a href="../EODelayedObserver.html#//apple_ref/java/instm/EODelayedObserver/objectWillChange">objectWillChange</a> method.Hence, it's typically enough that an object being observed invoke  <a href="../../Protocols/EOEnterpriseObject.html#//apple_ref/java/intfm/EOEnterpriseObject/willChange">willChange</a> as needed. For example,in Java Client and Application Kit applications, an EODisplayGroup(EOInterface) does this (among many other things) on receiving an  <a href="../EOEditingContext.html#BIDCFHHF">ObjectsChangedInEditingContextNotification</a><code> </code>fromits EOEditingContext.</p><p>Although you can create individual EODelayedObserverQueues,you typically use the single instance provided by the static method  <a href="../EODelayedObserverQueue.html#//apple_ref/java/clm/EODelayedObserverQueue/defaultObserverQueue">defaultObserverQueue</a>.Using separate queues bypasses the prioritization mechanism, whichmay cause problems between the objects using the separate queues.If you do use separate queues, your EODelayedObserver subclassesshould record a designated EODelayedObserverQueue that they alwaysuse, and implement  <a href="../EODelayedObserver.html#//apple_ref/java/instm/EODelayedObserver/observerQueue">observerQueue</a> to return that object.</p><p>If you need to remove an enqueued observer, you can do sousing the  <a href="../EODelayedObserverQueue.html#//apple_ref/java/instm/EODelayedObserverQueue/dequeueObserver">dequeueObserver</a> method. EODelayedObserveralso defines the  <a href="../EODelayedObserver.html#//apple_ref/java/instm/EODelayedObserver/discardPendingNotification">discardPendingNotification</a> method,which removes the receiver from its designated queue.</p><br><a name = "BABDHJBI"></a><h2>Change Notification</h2><p>The actual process of change notification is initiated bythe  <a href="../EODelayedObserverQueue.html#//apple_ref/java/instm/EODelayedObserverQueue/enqueueObserver">enqueueObserver</a> messages that line observersup to receive notifications. Regardless of how many times <code>enqueueObserver</code> isinvoked for a particular observer, that observer is only put inthe queue once. The first observer enqueued during the run loopalso sets up the EODelayedObserverQueue to receive a message atthe end of the run loop. EODelayedObserver sets up this delayedinvocation in NSRunLoop.DefaultRunLoopMode, but you can change themode or add additional modes in which delayed invocation occursusing  <a href="../EODelayedObserverQueue.html#//apple_ref/java/instm/EODelayedObserverQueue/setRunLoopModes">setRunLoopModes</a> (Yellow Box only).</p><p> <a href="../EODelayedObserverQueue.html#//apple_ref/java/instm/EODelayedObserverQueue/notifyObserversUpToPriority">notifyObserversUpToPriority</a> cyclesthrough the queue of EODelayedObservers in priority order, from  <a href="../EODelayedObserver.html#CEGDEGFB">ObserverPriorityFirst</a> to the prioritygiven, sending each observer a  <a href="../EODelayedObserver.html#//apple_ref/java/instm/EODelayedObserver/subjectChanged">subjectChanged</a> message. Each time,it returns to the earliest priority (rather than continuing throughthe queue) in case the message resulted in another EODelayedObserverwith a earlier priority being enqueued. This guarantees an optimaldelivery of change notifications.</p><br><a name = "BABCJAEA"></a><h2>Observer Proxies</h2><p>It may not always be possible for a custom observer classto inherit from EODelayedObserver. To aid such objects in participatingin delayed change notifications, the Framework defines a subclassof EODelayedObserver, EOObserverProxy, which implements its  <a href="../EODelayedObserver.html#//apple_ref/java/instm/EODelayedObserver/subjectChanged">subjectChanged</a> method to invoke an actionmethod of your custom object. You create an EOObserverProxy, providing the"real" observer, the action method to invoke, and the priorityat which the EOObserverProxy should be enqueued. Then, instead ofregistering the custom object as an observer of objects, you registerthe proxy (using EOObserverCenter's  <a href="../EOObserverCenter.html#//apple_ref/java/clm/EOObserverCenter/addObserver">addObserver</a><code>)</code>.When the proxy receives an  <a href="../EODelayedObserver.html#//apple_ref/java/instm/EODelayedObserver/objectWillChange">objectWillChange</a> message,it enqueues itself for delayed change notification, receives the <code>subjectChanged</code> messagefrom the EODelayedObserverQueue, and then sends the action messageto the "real" observer.</p><br><a href="../../EOControlTOC.html"><img src="../../../../../../../images/up.gif" border="0" alt="Table of Contents"></a></BODY></HTML>