<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Exchanging Data During a PPC Session(IM:IC)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING431></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="IAC-430.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-432.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="IAC-2.html"><B>Interapplication Communication</B></A> / <BR><DD><A HREF="IAC-423.html"><B>Chapter 11 - Program-to-Program Communications Toolbox</B></A> / <A HREF="IAC-427.html"><B>Using the PPC Toolbox</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING431-0></A>
<H2><A NAME=MARKER-9-160></A><A NAME=MARKER-21-161></A>Exchanging Data During a PPC Session</H2>
 After a session begins, each application can send data to and receive data from the other using a sequence of message blocks. The PPC Toolbox treats each message block as a byte stream and does not interpret the contents of the message block. The size of a message block can be between 0 and (232-1) bytes. The PPC Toolbox treats the buffer size as an unsigned long integer.<A NAME=MARKER-2-162></A><P>
 The PPC Toolbox delivers the message blocks in the same sequence as they are sent and without duplicates. In <A HREF=#MARKER-9-163>Figure 11-17</A>, an application transmits message blocks during a session.<P>
<B>Figure 11-17  <A NAME=MARKER-9-163></A><A NAME=MARKER-21-164></A>Transmitting message blocks</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/PPC-L-17.jpg"><P>
 For each message block, you specify a block creator, block type, and user data. The first <CODE>PPCWrite</CODE> function that you use to create a new message block sets the attributes for the block. The <CODE>PPCRead</CODE> function returns the block creator, block type, and user data attributes for the current message block when the call completes.<P>
 Although the PPC Toolbox does not interpret these attributes, they can give the receiving application information about how to process the contents of the message block. For example, a database application may specify, in the block creator field, a counter to indicate the block number (block number 20 of 30 total blocks). This application could also specify a code, such as <CODE>'DREC'</CODE>, in the block type field to indicate that the information it contains is a database record. In addition, this application could specify, in the user data field, the length of the message block.<A NAME=MARKER-2-214></A><P>
<A NAME=HEADING431-7></A>
<H3><A NAME=MARKER-21-166></A>Reading Data From an Application</H3>
 An application can both read from and write data to another application during a session. Use the <CODE>PPCRead</CODE> function during a session to read incoming blocks of data from another application.<A NAME=MARKER-2-163></A><A NAME=MARKER-2-164></A><P>
 Once a session is initiated, you should have a <CODE>PPCRead</CODE> function pending. You can issue a <CODE>PPCRead</CODE> function from inside a completion routine. This provides you with immediate notification if an error condition arises or the session closes. <P>
 The <CODE>blockCreator</CODE>, <CODE>blockType</CODE>, and <CODE>userData</CODE> fields are returned for the block you are reading. (These fields are set by the <CODE>PPCWrite</CODE> function.) To determine whether there is additional data to be read, check the <CODE>more</CODE> field. The value <CODE>FALSE</CODE> indicates the end of a message block.<P>
 <A HREF=#MARKER-9-169>Listing 11-14</A> illustrates how you use the <CODE>PPCRead</CODE> function to read data during a session.<P>
<B>Listing 11-14  <A NAME=MARKER-9-169></A><A NAME=MARKER-21-170></A>Using the <CODE>PPCRead</CODE> function to read data during a session</B><P>
<PRE>
FUNCTION MyPPCRead(thePPCReadPBPtr: PPCReadPBPtr; 
                     theSessRefNum: PPCSessRefNum; 
                     theBufferLength: Size; 
                     theBufferPtr: Ptr): OSErr;
BEGIN
   WITH thePPCReadPBPtr^ DO
   BEGIN
      ioCompletion := NIL;
      sessRefNum := theSessRefNum;  {from PPCStart or PPCInform}
      bufferLength := theBufferLength;
      bufferPtr := theBufferPtr;
   END;
   MyPPCRead := PPCRead(thePPCReadPBPtr, TRUE); {asynchronous}
END;
</PRE>
 You should make any calls to <CODE>PPCRead</CODE> asynchronously. You can provide a completion routine that will be called when the <CODE>PPCRead</CODE> function has completed, or you can poll the <CODE>ioResult</CODE> field of the PPC parameter block to determine whether the <CODE>PPCRead</CODE> function has completed. A <CODE>PPCRead</CODE> completion routine can issue another asynchronous PPC Toolbox call or set global variables. If another PPC Toolbox call is made from a completion routine, then the <CODE>PPCRead</CODE> function must use a record of data type <CODE>PPCParamBlockRec</CODE> instead of type <CODE>PPCReadPBRec</CODE>.<A NAME=MARKER-2-414></A><P>
 <A HREF=#MARKER-9-172>Listing 11-15</A> illustrates a function that can be used to poll the <CODE>ioResult</CODE> field of a record of data type <CODE>PPCReadPBRec</CODE>. The function returns <CODE>TRUE</CODE> when the <CODE>PPCRead</CODE> function associated with <CODE>PPCReadPBRec</CODE> has completed.<P>
<B>Listing 11-15  <A NAME=MARKER-9-172></A><A NAME=MARKER-21-173></A>Polling the <CODE>ioResult</CODE> field to determine if a <CODE>PPCRead</CODE> function has completed</B><P>
<PRE>
FUNCTION MyReadComplete(thePPCReadPBPtr: PPCReadPBPtr; 
                        VAR err: OSErr): Boolean;
BEGIN
   err := thePPCReadPBPtr^.ioResult;
   MyReadComplete := err &lt;&gt; 1;
END;
</PRE>
<A NAME=HEADING431-18></A>
<H3><A NAME=MARKER-21-174></A>Sending Data to an Application</H3>
 Use the <CODE>PPCWrite</CODE> function to send a message block during a session specified by the session reference number.<A NAME=MARKER-2-175></A><A NAME=MARKER-2-3></A><P>
 You should call the <CODE>PPCWrite</CODE> function asynchronously. You can provide a completion routine that will be called when the <CODE>PPCWrite</CODE> function has completed, or you can poll the <CODE>ioResult</CODE> field of the PPC parameter block to determine whether the <CODE>PPCWrite</CODE> function has completed. A <CODE>PPCWrite</CODE> completion routine can issue another PPC Toolbox call or set global variables. If another PPC Toolbox call is made from a completion routine, then the <CODE>PPCWrite</CODE> function must use a record of data type <CODE>PPCParamBlockRec</CODE> instead of type <CODE>PPCWritePBRec</CODE>. Note that message blocks are sent in the order in which they are written.<A NAME=MARKER-21-150></A><P>
 <A HREF=#MARKER-9-178>Listing 11-16</A> illustrates how you use the <CODE>PPCWrite</CODE> function to write data during a session.<P>
<B>Listing 11-16  <A NAME=MARKER-9-178></A><A NAME=MARKER-21-179></A>Using the <CODE>PPCWrite</CODE> function to write data during a session</B><P>
<PRE>
FUNCTION MyPPCWrite(thePPCWritePBPtr: PPCWritePBPtr; 
                   theSessRefNum: PPCSessRefNum; 
                   theBufferLength: Size; 
                   theBufferPtr: Ptr): OSErr;
BEGIN
   WITH thePPCWritePBPtr^ DO
   BEGIN
      ioCompletion := NIL;
      sessRefNum := theSessRefNum;  {from PPCStart or PPCInform}
      bufferLength := theBufferLength;
      bufferPtr := theBufferPtr;
      more := FALSE;          {no more data to read}
      userData := 0;          {application-specific data}
      blockCreator := '????'; {application-specific data}
      blockType := '????';    {application-specific data}
   END;
   MyPPCWrite := PPCWrite(thePPCWritePBPtr, TRUE); {asynchronous}
END;
</PRE>
 The first <CODE>PPCWrite</CODE> function that you use to create a new message block sets the block creator, block type, and user data attributes for the block. These attributes are returned to the application when it reads from the message block. Set the <CODE>more</CODE> field to <CODE>FALSE</CODE> to indicate the end of the message block or set this field to <CODE>TRUE</CODE> if you want to append additional data to a message block.<A NAME=MARKER-2-4></A><P>
 <A HREF=#MARKER-9-181>Listing 11-17</A> illustrates a function that can be used to poll the <CODE>ioResult</CODE> field of a record of data type <CODE>PPCWritePBRec</CODE>. The function returns <CODE>TRUE</CODE> when the <CODE>PPCWrite</CODE> function associated with <CODE>PPCWritePBRec</CODE> has completed.<P>
<B>Listing 11-17  <A NAME=MARKER-9-181></A><A NAME=MARKER-2-8></A><A NAME=MARKER-2-9></A><A NAME=MARKER-21-184></A>Polling the <CODE>ioResult</CODE> field to determine if a <CODE>PPCWrite</CODE> function has completed</B><P>
<PRE>
FUNCTION MyWriteComplete(thePPCWritePBPtr: PPCWritePBPtr;
                         VAR err: OSErr): Boolean;
BEGIN
   err := thePPCWritePBPtr^.ioResult;
   MyWriteComplete := err &lt;&gt; 1;
END;
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="IAC-430.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-432.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="IAC-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
