/*	File:		MyMovieStuff.c		Contains:	My Application Shell.	Written by:	John Wang	Copyright:	© 1994 by Apple Computer, Inc., all rights reserved.	Change History (most recent first):		<1>		03/14/94	JW		Re-Created for Universal Headers.	To Do:	*/#ifdef THINK_C#define		applec#endif#include	<Types.h>#include	<Memory.h>#include	<QuickDraw.h>#include	<Palettes.h>#include	<QDOffscreen.h>#include	<Errors.h>#include	<Fonts.h>#include	<Dialogs.h>#include	<Windows.h>#include	<Menus.h>#include	<Events.h>#include	<Desk.h>#include	<DiskInit.h>#include	<OSUtils.h>#include	<Resources.h>#include	<ToolUtils.h>#include	<AppleEvents.h>#include	<EPPC.h>#include	<GestaltEqu.h>#include	<Processes.h>#include	<Balloons.h>#include	<Aliases.h>#include	<MixedMode.h>#include	<Scrap.h>#include	<LowMem.h>#include	<Movies.h>#include	"MyApplication Shell (2.0).h"#include	"MyApplication.h"#include	"BetterFlattenMovie.h"#include	"MyMovieStuff.h"/* ------------------------------------------------------------------------- */void adjustMoviesMenu(WindowPtr theWindow){	WindowInfoHandle	myWinfo;	FSSpec				theFSSpec;	short				theRefNum;	MenuHandle			myMenu;	short				movieCount;	Handle				movieResource;	short				movieID;	ResType				movieType;	Str255				movieName;	short				i;		//	Delete old menu if it exists.	if (myMenu = GetMHandle(kMENU_MOVIES)) {		DeleteMenu(kMENU_MOVIES);		DisposeMenu(myMenu);	}	//	If a window is passed, then update the menu for it.	if (IsMyWindow(theWindow)) {		myWinfo = (WindowInfoHandle) GetWRefCon(theWindow);		theFSSpec = (**myWinfo).theFSSpec;		theRefNum = (**myWinfo).refNum;		myMenu = NewMenu(kMENU_MOVIES, theFSSpec.name);		InsertMenu(myMenu, 0);				//	Add resource fork movies into menu.		if (theRefNum != -1) {			movieCount = Count1Resources('moov');			for (i=1; i<=movieCount; i++) {				movieResource = Get1IndResource('moov', i);				GetResInfo(movieResource, &movieID, &movieType, movieName);				if (movieName[0] == 0) {					NumToString(movieID, &movieName[23]);					movieName[0] = movieName[23] + 23;					BlockMove("Resource Fork Movie ID#", &movieName[1], 23);				}				AppendMenu(myMenu, movieName);				ReleaseResource(movieResource);			}		}				//	Add single fork movies into menu.		if (CountMoviesInDataFork(&theFSSpec, &movieCount) == noErr) {			for (i=0; i<movieCount; i++) {				NumToString(i+1, &movieName[19]);				movieName[0] = movieName[19] + 19;				BlockMove("Single Fork Movie #", &movieName[1], 19);				AppendMenu(myMenu, movieName);			}		}	}	//	Update MenuBar.	DrawMenuBar();}void SelectThisMovie(short item){	OSErr				err;	WindowPtr			frontWindow;	WindowInfoHandle	myWinfo;	short				resCount, dataCount;	Handle				movieResource;	short				movieID;	ResType				movieType;	long 				controllerFlags;	Rect				movieBounds;	short				i, xoffset, yoffset;	Str255				junkStr;	short				myRefNum;	Movie				tempMovie;	short				tempResId;	long				tempMovieOffset;		if ((frontWindow = FrontWindow()) == nil)		return;			if (IsMyWindow(frontWindow)) {		myWinfo = (WindowInfoHandle) GetWRefCon(frontWindow);		//	Get rid of old movie		if ((**myWinfo).theMC != nil)			DisposeMovieController((**myWinfo).theMC);		if ((**myWinfo).theMovie != nil)			DisposeMovie((**myWinfo).theMovie);		(**myWinfo).theMovie = nil;		(**myWinfo).theMC = nil;		(**myWinfo).moviename[0] = 0;		(**myWinfo).resId = -1;		(**myWinfo).movieOffset = -1;		//	Invalidate window.		InvalRect(&(frontWindow->portRect));				//	Count the number of movies in resource fork and data fork		resCount = Count1Resources('moov');		CountMoviesInDataFork(&((**myWinfo).theFSSpec), &dataCount);		//	Find which movie to play.		if (item <= resCount) {			movieResource = Get1IndResource('moov', item);			GetResInfo(movieResource, &tempResId, &movieType, (**myWinfo).moviename);			ReleaseResource(movieResource);			err = NewMovieFromFile(&tempMovie, (**myWinfo).refNum, &tempResId, nil,								newMovieActive, (Boolean *) 0);			(**myWinfo).theMovie = tempMovie;			(**myWinfo).resId = tempResId;			if (err) {				Alert(kALERT_CANTOPEN, nil);				return;			}		} else {			item = item-resCount;			err = SearchMoviesInDataFork(&((**myWinfo).theFSSpec), item, &tempMovieOffset);			(**myWinfo).movieOffset = tempMovieOffset;			if (err) {				Alert(kALERT_CANTOPEN, nil);				return;			}			if (FSpOpenDF(&((**myWinfo).theFSSpec), fsRdPerm, &myRefNum) == noErr) {				err = NewMovieFromDataFork(&tempMovie, myRefNum, (**myWinfo).movieOffset, newMovieActive, nil);				(**myWinfo).theMovie = tempMovie;				FSClose(myRefNum);				if (err) {					Alert(kALERT_CANTOPEN, nil);					return;				}			}		}				//	Set the movie box into middle of window.		SetMovieGWorld((**myWinfo).theMovie, (CGrafPtr) frontWindow, 0);		GetMovieBox((**myWinfo).theMovie, &movieBounds);		OffsetRect(&movieBounds, -movieBounds.left, -movieBounds.top);		SetMovieBox((**myWinfo).theMovie, &movieBounds);		xoffset = (frontWindow->portRect.right - frontWindow->portRect.left					 - movieBounds.right + movieBounds.left) / 2;		yoffset = (frontWindow->portRect.bottom - frontWindow->portRect.top					 - movieBounds.bottom + movieBounds.top) / 2;		OffsetRect(&movieBounds, xoffset, yoffset);		(**myWinfo).theMC = NewMovieController((**myWinfo).theMovie, &movieBounds, mcTopLeftMovie);			//	Tell the controller to attach a movie’s CLUT to the window as appropriate.		MCDoAction((**myWinfo).theMC, mcActionGetFlags, &controllerFlags);		MCDoAction((**myWinfo).theMC, mcActionSetFlags, (void *)(controllerFlags | mcFlagsUseWindowPalette));			//	Allow the controller to accept keyboard events.		MCDoAction((**myWinfo).theMC, mcActionSetKeysEnabled, (void *)true);	}	}void getNewMovie(Movie *theMovie, Str255 *movieName){	StandardFileReply		reply;	SFTypeList				types;	short					refNum, resId;		*theMovie = nil;		types[0] = 'MooV';	StandardGetFilePreview(nil, 1, types, &reply);	if (!reply.sfGood) return;		//	Read movie atom of source movie.	if (OpenMovieFile(&reply.sfFile, &refNum, fsRdPerm)) {		SysBeep(50);		return;	}	resId = 0;	(*movieName)[0] = 0;	if (NewMovieFromFile(theMovie, refNum, &resId, *movieName, 0, (Boolean *) 0)) {		SysBeep(50);		*theMovie = nil;		return;	}	if ((*movieName)[0] == 0)		BlockMove(reply.sfFile.name, *movieName, reply.sfFile.name[0]+1);	CloseMovieFile(refNum);}void Mac_AddMovieResAtom(short *docRefNum, FSSpec *docFSSpec){	Movie					theMovie;	Str255					movieName;	short					resId;	getNewMovie(&theMovie, &movieName);		if (theMovie != nil) {		resId = 0;		AddMovieResource(theMovie, *docRefNum, &resId, movieName);		DisposeMovie(theMovie);	}}void Mac_AddMovieAll(short *docRefNum, FSSpec *docFSSpec){	Movie					theMovie;	Str255					movieName;	getNewMovie(&theMovie, &movieName);		if (theMovie != nil) {		CloseMovieFile(*docRefNum);		BetterFlattenMovie(theMovie, 0, docFSSpec, 'WnG1', smSystemScript, 0, nil, movieName);		OpenMovieFile(docFSSpec, docRefNum, fsRdWrPerm);		DisposeMovie(theMovie);	}}void Cross_AddMovieAll(short *docRefNum, FSSpec *docFSSpec){	Movie					theMovie;	Str255					movieName;	getNewMovie(&theMovie, &movieName);		if (theMovie != nil) {		CloseMovieFile(*docRefNum);		BetterFlattenMovieData(theMovie, flattenAddMovieToDataFork, docFSSpec, 'WnG1', smSystemScript, 0);		OpenMovieFile(docFSSpec, docRefNum, fsRdWrPerm);		DisposeMovie(theMovie);	}}void Both_AddMovieAll(short *docRefNum, FSSpec *docFSSpec){	Movie					theMovie;	Str255					movieName;	getNewMovie(&theMovie, &movieName);		if (theMovie != nil) {		CloseMovieFile(*docRefNum);		BetterFlattenMovie(theMovie, flattenAddMovieToDataFork, docFSSpec, 'WnG1', smSystemScript, 0, nil, movieName);		OpenMovieFile(docFSSpec, docRefNum, fsRdWrPerm);		DisposeMovie(theMovie);	}}