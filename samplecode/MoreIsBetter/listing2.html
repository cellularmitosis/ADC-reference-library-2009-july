<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MoreIsBetter - /MIB-Clients/MacCVSProTool/MacCVSProTool.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">MoreIsBetter</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MoreIsBetter</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MIB-Clients/MacCVSProTool/MacCVSProTool.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MIB-Clients/Demos/MoreOpenAndSaveDemo/AnswerShell.c</option>
<option value="listing2.html">/MIB-Clients/MacCVSProTool/MacCVSProTool.c</option>
<option value="listing3.html">/MIB-Clients/SampleSubmit/SampleSubmit.c</option>
<option value="listing4.html">/MIB-Documentation/index.html</option>
<option value="listing5.html">/MIB-Documentation/MoreDocumentation/0ReleaseNotes.html</option>
<option value="listing6.html">/MIB-Documentation/MoreDocumentation/0toc.html</option>
<option value="listing7.html">/MIB-Documentation/MoreDocumentation/banner.html</option>
<option value="listing8.html">/MIB-Documentation/MoreDocumentation/BuildingAndUsing.html</option>
<option value="listing9.html">/MIB-Documentation/MoreDocumentation/ContributingToMoreIsBetter.html</option>
<option value="listing10.html">/MIB-Documentation/MoreDocumentation/copyright.html</option>
<option value="listing11.html">/MIB-Documentation/MoreDocumentation/index.html</option>
<option value="listing12.html">/MIB-Documentation/MoreDocumentation/intro.html</option>
<option value="listing13.html">/MIB-Documentation/MoreDocumentation/MoreAppearance.html</option>
<option value="listing14.html">/MIB-Documentation/MoreDocumentation/MoreAppleEvents.html</option>
<option value="listing15.html">/MIB-Documentation/MoreDocumentation/MoreCDs.html</option>
<option value="listing16.html">/MIB-Documentation/MoreDocumentation/MoreCodeFragments.html</option>
<option value="listing17.html">/MIB-Documentation/MoreDocumentation/MoreControls.html</option>
<option value="listing18.html">/MIB-Documentation/MoreDocumentation/MoreDevices.html</option>
<option value="listing19.html">/MIB-Documentation/MoreDocumentation/MoreDialogs.html</option>
<option value="listing20.html">/MIB-Documentation/MoreDocumentation/MoreDisks.html</option>
<option value="listing21.html">/MIB-Documentation/MoreDocumentation/MoreErrors.html</option>
<option value="listing22.html">/MIB-Documentation/MoreDocumentation/MoreEvents.html</option>
<option value="listing23.html">/MIB-Documentation/MoreDocumentation/MoreInterfaceLib.html</option>
<option value="listing24.html">/MIB-Documentation/MoreDocumentation/MoreLists.html</option>
<option value="listing25.html">/MIB-Documentation/MoreDocumentation/MoreMemory.html</option>
<option value="listing26.html">/MIB-Documentation/MoreDocumentation/MoreMenus.html</option>
<option value="listing27.html">/MIB-Documentation/MoreDocumentation/MoreMultiprocessing.html</option>
<option value="listing28.html">/MIB-Documentation/MoreDocumentation/MoreNavigation.html</option>
<option value="listing29.html">/MIB-Documentation/MoreDocumentation/MoreNetworkSetup.html</option>
<option value="listing30.html">/MIB-Documentation/MoreDocumentation/MoreOpenAndSave.html</option>
<option value="listing31.html">/MIB-Documentation/MoreDocumentation/MoreOpenTransport.html</option>
<option value="listing32.html">/MIB-Documentation/MoreDocumentation/MoreOSL.html</option>
<option value="listing33.html">/MIB-Documentation/MoreDocumentation/MoreOSUtils.html</option>
<option value="listing34.html">/MIB-Documentation/MoreDocumentation/MorePatches.html</option>
<option value="listing35.html">/MIB-Documentation/MoreDocumentation/MorePreferences.html</option>
<option value="listing36.html">/MIB-Documentation/MoreDocumentation/MoreProcesses.html</option>
<option value="listing37.html">/MIB-Documentation/MoreDocumentation/MoreQuickDraw.html</option>
<option value="listing38.html">/MIB-Documentation/MoreDocumentation/MoreResources.html</option>
<option value="listing39.html">/MIB-Documentation/MoreDocumentation/MoreTextUtils.html</option>
<option value="listing40.html">/MIB-Documentation/MoreDocumentation/MoreToolbox.html</option>
<option value="listing41.html">/MIB-Documentation/MoreDocumentation/MoreWindows.html</option>
<option value="listing42.html">/MIB-Libraries/MIB_Carbon.h</option>
<option value="listing43.html">/MIB-Libraries/MIB_SourceHeader.txt</option>
<option value="listing44.html">/MIB-Libraries/MoreAppearance/MoreAppearance.cp</option>
<option value="listing45.html">/MIB-Libraries/MoreAppearance/MoreAppearance.h</option>
<option value="listing46.html">/MIB-Libraries/MoreAppleEvents/MoreAEDataModel.c</option>
<option value="listing47.html">/MIB-Libraries/MoreAppleEvents/MoreAEDataModel.h</option>
<option value="listing48.html">/MIB-Libraries/MoreAppleEvents/MoreAEObjects.c</option>
<option value="listing49.html">/MIB-Libraries/MoreAppleEvents/MoreAEObjects.h</option>
<option value="listing50.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEvents.cp</option>
<option value="listing51.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEvents.h</option>
<option value="listing52.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEventsPlus.c</option>
<option value="listing53.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEventsPlus.h</option>
<option value="listing54.html">/MIB-Libraries/MoreAppleEvents/MoreFinderEvents.c</option>
<option value="listing55.html">/MIB-Libraries/MoreAppleEvents/MoreFinderEvents.h</option>
<option value="listing56.html">/MIB-Libraries/MoreAppleEvents/MoreOSA.c</option>
<option value="listing57.html">/MIB-Libraries/MoreAppleEvents/MoreOSA.h</option>
<option value="listing58.html">/MIB-Libraries/MoreAppleEvents/ProductInfo.txt</option>
<option value="listing59.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/Carbon.r</option>
<option value="listing60.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/HelloWorld.c</option>
<option value="listing61.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/Info.plist.r</option>
<option value="listing62.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/TestMoreAppleEvents.c</option>
<option value="listing63.html">/MIB-Libraries/MoreAppleEvents/VersionInfo.r</option>
<option value="listing64.html">/MIB-Libraries/MoreCarbonEvents/MoreCarbonEvents.c</option>
<option value="listing65.html">/MIB-Libraries/MoreCarbonEvents/MoreCarbonEvents.h</option>
<option value="listing66.html">/MIB-Libraries/MoreCFQ/MoreCFQ.c</option>
<option value="listing67.html">/MIB-Libraries/MoreCFQ/MoreCFQ.h</option>
<option value="listing68.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/CallMachOFramework.c</option>
<option value="listing69.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/CallMachOFramework.r</option>
<option value="listing70.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/Read Me CallMachOFramework.txt</option>
<option value="listing71.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/System Framework Stub/Stub Library Read Me.txt</option>
<option value="listing72.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CFMLateImport.c</option>
<option value="listing73.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CFMLateImport.h</option>
<option value="listing74.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/LateImportTest/LateImportTest.c</option>
<option value="listing75.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/LateImportTest/TestLibrary/TestLibrary.h</option>
<option value="listing76.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/LateImportTest/TestLibrary/TestLibraryImpl.c</option>
<option value="listing77.html">/MIB-Libraries/MoreControls/MoreControls.cp</option>
<option value="listing78.html">/MIB-Libraries/MoreControls/MoreControls.h</option>
<option value="listing79.html">/MIB-Libraries/MoreCRC/MoreCRC.c</option>
<option value="listing80.html">/MIB-Libraries/MoreCRC/MoreCRC.h</option>
<option value="listing81.html">/MIB-Libraries/MoreDebugging/MoreAddrToSym.c</option>
<option value="listing82.html">/MIB-Libraries/MoreDebugging/MoreAddrToSym.h</option>
<option value="listing83.html">/MIB-Libraries/MoreDebugging/MoreBacktrace.c</option>
<option value="listing84.html">/MIB-Libraries/MoreDebugging/MoreBacktrace.h</option>
<option value="listing85.html">/MIB-Libraries/MoreDebugging/MoreBacktraceTest/MoreBacktraceTest.c</option>
<option value="listing86.html">/MIB-Libraries/MoreDebugging/MoreBBLog.c</option>
<option value="listing87.html">/MIB-Libraries/MoreDebugging/MoreBBLog.h</option>
<option value="listing88.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/GenerateFont/GenerateFont.c</option>
<option value="listing89.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/InterruptSafeDebug.c</option>
<option value="listing90.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/InterruptSafeDebug.h</option>
<option value="listing91.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/InterruptSafeDebug.s</option>
<option value="listing92.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/TestInterruptSafeDebug/TestInterruptSafeDebug.c</option>
<option value="listing93.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/ReadMe.html</option>
<option value="listing94.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TestTradDriverLoaderLib/TestDriver/TestDriverMain.c</option>
<option value="listing95.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TestTradDriverLoaderLib/TestTradDriverLoader.c</option>
<option value="listing96.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TradDriverLoaderLib.c</option>
<option value="listing97.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TradDriverLoaderLib.h</option>
<option value="listing98.html">/MIB-Libraries/MoreDialogs/MoreDialogs.cp</option>
<option value="listing99.html">/MIB-Libraries/MoreDialogs/MoreDialogs.h</option>
<option value="listing100.html">/MIB-Libraries/MoreDisks/MoreCDs.c</option>
<option value="listing101.html">/MIB-Libraries/MoreDisks/MoreCDs.h</option>
<option value="listing102.html">/MIB-Libraries/MoreDisks/MoreDisks.c</option>
<option value="listing103.html">/MIB-Libraries/MoreDisks/MoreDisks.h</option>
<option value="listing104.html">/MIB-Libraries/MoreDisks/TestMoreDisks/TestMoreDisks.c</option>
<option value="listing105.html">/MIB-Libraries/MoreErrors/MoreErrors.c</option>
<option value="listing106.html">/MIB-Libraries/MoreErrors/MoreErrors.h</option>
<option value="listing107.html">/MIB-Libraries/MoreErrors/MoreErrors.r</option>
<option value="listing108.html">/MIB-Libraries/MoreEvents/MoreEvents.h</option>
<option value="listing109.html">/MIB-Libraries/MoreInterfaceLib/MoreInterfaceLib.c</option>
<option value="listing110.html">/MIB-Libraries/MoreInterfaceLib/MoreInterfaceLib.h</option>
<option value="listing111.html">/MIB-Libraries/MoreInterfaceLib/RemoteAccessInterface.h</option>
<option value="listing112.html">/MIB-Libraries/MoreInterfaceLib/TestMoreInterfaceLib/TestMoreInterfaceLib.c</option>
<option value="listing113.html">/MIB-Libraries/MoreIsBetter.h</option>
<option value="listing114.html">/MIB-Libraries/MoreLists/MoreLists.c</option>
<option value="listing115.html">/MIB-Libraries/MoreLists/MoreLists.h</option>
<option value="listing116.html">/MIB-Libraries/MoreMemory/MoreMemory.c</option>
<option value="listing117.html">/MIB-Libraries/MoreMemory/MoreMemory.h</option>
<option value="listing118.html">/MIB-Libraries/MoreMemory/TestMoreMemory/TestMoreMemory.c</option>
<option value="listing119.html">/MIB-Libraries/MoreMenus/MenuKeyGlyphs.h</option>
<option value="listing120.html">/MIB-Libraries/MoreMenus/MoreMenus.c</option>
<option value="listing121.html">/MIB-Libraries/MoreMenus/MoreMenus.h</option>
<option value="listing122.html">/MIB-Libraries/MoreMenus/MoreSystemMenus.c</option>
<option value="listing123.html">/MIB-Libraries/MoreMenus/MoreSystemMenus.h</option>
<option value="listing124.html">/MIB-Libraries/MoreMenus/TestMoreSystemMenus/TestMoreSystemMenus.c</option>
<option value="listing125.html">/MIB-Libraries/MoreMultiprocessing/MoreBlueActions.c</option>
<option value="listing126.html">/MIB-Libraries/MoreMultiprocessing/MoreBlueActions.h</option>
<option value="listing127.html">/MIB-Libraries/MoreMultiprocessing/MoreMPLog.c</option>
<option value="listing128.html">/MIB-Libraries/MoreMultiprocessing/MoreMPLog.h</option>
<option value="listing129.html">/MIB-Libraries/MoreNavigation/MoreNavigation.c</option>
<option value="listing130.html">/MIB-Libraries/MoreNavigation/MoreNavigation.h</option>
<option value="listing131.html">/MIB-Libraries/MoreOpenAndSave/MoreOpenAndSave.cp</option>
<option value="listing132.html">/MIB-Libraries/MoreOpenAndSave/MoreOpenAndSave.h</option>
<option value="listing133.html">/MIB-Libraries/MoreOpenTransport/MoreAutoPush.c</option>
<option value="listing134.html">/MIB-Libraries/MoreOpenTransport/MoreAutoPush.h</option>
<option value="listing135.html">/MIB-Libraries/MoreOpenTransport/MoreAutoPushTest/MoreAutoPushTest.c</option>
<option value="listing136.html">/MIB-Libraries/MoreOpenTransport/OTClassicContext.h</option>
<option value="listing137.html">/MIB-Libraries/MoreOpenTransport/OTClassicContextTest/OTClassicContextTest.c</option>
<option value="listing138.html">/MIB-Libraries/MoreOpenTransport/OTMP.c</option>
<option value="listing139.html">/MIB-Libraries/MoreOpenTransport/OTMP.h</option>
<option value="listing140.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTP.c</option>
<option value="listing141.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTP.h</option>
<option value="listing142.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTPTest.c</option>
<option value="listing143.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTPTest.r</option>
<option value="listing144.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/Sample HTTP Source/index.html</option>
<option value="listing145.html">/MIB-Libraries/MoreOpenTransport/OTMPTest/OTMPTest.c</option>
<option value="listing146.html">/MIB-Libraries/MoreOpenTransport/Read_Me_About_OTMP.html</option>
<option value="listing147.html">/MIB-Libraries/MoreOpenTransport/ReadMeOTClassicContext.html</option>
<option value="listing148.html">/MIB-Libraries/MoreOSL/MoreOSL.c</option>
<option value="listing149.html">/MIB-Libraries/MoreOSL/MoreOSL.h</option>
<option value="listing150.html">/MIB-Libraries/MoreOSL/MoreOSLHelpers.c</option>
<option value="listing151.html">/MIB-Libraries/MoreOSL/MoreOSLHelpers.h</option>
<option value="listing152.html">/MIB-Libraries/MoreOSL/MoreOSLStringComp.applescript</option>
<option value="listing153.html">/MIB-Libraries/MoreOSL/MoreOSLStringCompare.c</option>
<option value="listing154.html">/MIB-Libraries/MoreOSL/MoreOSLStringCompare.h</option>
<option value="listing155.html">/MIB-Libraries/MoreOSL/MoreOSLTokens.c</option>
<option value="listing156.html">/MIB-Libraries/MoreOSL/MoreOSLTokens.h</option>
<option value="listing157.html">/MIB-Libraries/MoreOSL/ReadMe.html</option>
<option value="listing158.html">/MIB-Libraries/MoreOSL/TestMoreOSL/Test Script.applescript</option>
<option value="listing159.html">/MIB-Libraries/MoreOSL/TestMoreOSL/TestMoreOSL.c</option>
<option value="listing160.html">/MIB-Libraries/MoreOSL/TestMoreOSL/TestMoreOSLTerminology.h</option>
<option value="listing161.html">/MIB-Libraries/MoreOSL/TestMoreOSL/TestMoreOSLTerminology.r</option>
<option value="listing162.html">/MIB-Libraries/MoreOSUtils/MoreOSUtils.c</option>
<option value="listing163.html">/MIB-Libraries/MoreOSUtils/MoreOSUtils.h</option>
<option value="listing164.html">/MIB-Libraries/MoreOSUtils/TestMoreOSUtils/TestMoreOSUtils.c</option>
<option value="listing165.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatches.c</option>
<option value="listing166.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatches.h</option>
<option value="listing167.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatches.s</option>
<option value="listing168.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatchesTest/MoreCFMPatchesTest.c</option>
<option value="listing169.html">/MIB-Libraries/MorePreferences/MorePreferences.cp</option>
<option value="listing170.html">/MIB-Libraries/MorePreferences/MorePreferences.h</option>
<option value="listing171.html">/MIB-Libraries/MoreProcesses/MoreProcesses.cp</option>
<option value="listing172.html">/MIB-Libraries/MoreProcesses/MoreProcesses.h</option>
<option value="listing173.html">/MIB-Libraries/MoreProcesses/MoreScheduledExec.c</option>
<option value="listing174.html">/MIB-Libraries/MoreProcesses/MoreScheduledExec.h</option>
<option value="listing175.html">/MIB-Libraries/MoreProcesses/TestMoreScheduledExec/TestMoreScheduledExec.c</option>
<option value="listing176.html">/MIB-Libraries/MoreQuickDraw/MoreQuickDraw.cp</option>
<option value="listing177.html">/MIB-Libraries/MoreQuickDraw/MoreQuickDraw.h</option>
<option value="listing178.html">/MIB-Libraries/MoreResources/MoreResources.c</option>
<option value="listing179.html">/MIB-Libraries/MoreResources/MoreResources.h</option>
<option value="listing180.html">/MIB-Libraries/MoreSCF/MoreSCF.c</option>
<option value="listing181.html">/MIB-Libraries/MoreSCF/MoreSCF.h</option>
<option value="listing182.html">/MIB-Libraries/MoreSCF/MoreSCFCCLScanner.c</option>
<option value="listing183.html">/MIB-Libraries/MoreSCF/MoreSCFCCLScanner.h</option>
<option value="listing184.html">/MIB-Libraries/MoreSCF/MoreSCFDigest.c</option>
<option value="listing185.html">/MIB-Libraries/MoreSCF/MoreSCFDigest.h</option>
<option value="listing186.html">/MIB-Libraries/MoreSCF/MoreSCFHelpers.c</option>
<option value="listing187.html">/MIB-Libraries/MoreSCF/MoreSCFHelpers.h</option>
<option value="listing188.html">/MIB-Libraries/MoreSCF/MoreSCFPortScanner.c</option>
<option value="listing189.html">/MIB-Libraries/MoreSCF/MoreSCFPortScanner.h</option>
<option value="listing190.html">/MIB-Libraries/MoreSCF/MoreSCFTest/MoreSCFTest.c</option>
<option value="listing191.html">/MIB-Libraries/MoreSCF/ReadMeAboutMoreSCF.html</option>
<option value="listing192.html">/MIB-Libraries/MoreSecurity/MoreSecurity.c</option>
<option value="listing193.html">/MIB-Libraries/MoreSecurity/MoreSecurity.h</option>
<option value="listing194.html">/MIB-Libraries/MoreSecurity/MoreSecurityTest/MoreSecurityTest.c</option>
<option value="listing195.html">/MIB-Libraries/MoreSecurity/MoreSecurityTest/MoreSecurityTestCommon.h</option>
<option value="listing196.html">/MIB-Libraries/MoreSecurity/MoreSecurityTest/MoreSecurityTestTool.c</option>
<option value="listing197.html">/MIB-Libraries/MoreSecurity/ReadMeAboutMoreAuthSample.html</option>
<option value="listing198.html">/MIB-Libraries/MoreSetup.h</option>
<option value="listing199.html">/MIB-Libraries/MoreSetup.r</option>
<option value="listing200.html">/MIB-Libraries/MoreSound/MoreSound.cp</option>
<option value="listing201.html">/MIB-Libraries/MoreSound/MoreSound.h</option>
<option value="listing202.html">/MIB-Libraries/MoreTextUtils/MoreTextUtils.cp</option>
<option value="listing203.html">/MIB-Libraries/MoreTextUtils/MoreTextUtils.h</option>
<option value="listing204.html">/MIB-Libraries/MoreTextUtils/TestMoreTextUtils/TestMoreTextUtils.c</option>
<option value="listing205.html">/MIB-Libraries/MoreTextUtils/TestMoreTextUtils/TestMoreTextUtils.r</option>
<option value="listing206.html">/MIB-Libraries/MoreToolbox/MoreToolbox.cp</option>
<option value="listing207.html">/MIB-Libraries/MoreToolbox/MoreToolbox.h</option>
<option value="listing208.html">/MIB-Libraries/MoreUNIX/MoreUNIX.c</option>
<option value="listing209.html">/MIB-Libraries/MoreUNIX/MoreUNIX.h</option>
<option value="listing210.html">/MIB-Libraries/MoreWindows/MoreWindows.cp</option>
<option value="listing211.html">/MIB-Libraries/MoreWindows/MoreWindows.h</option>
<option value="listing212.html">/MIB-Libraries/NetworkSetup/MoreNetworkSetup.c</option>
<option value="listing213.html">/MIB-Libraries/NetworkSetup/MoreNetworkSetup.h</option>
<option value="listing214.html">/MIB-Libraries/NetworkSetup/Network Setup SDK Bits/ Read Me.txt</option>
<option value="listing215.html">/MIB-Libraries/NetworkSetup/Network Setup SDK Bits/NetworkSetupBigPicture.html</option>
<option value="listing216.html">/MIB-Libraries/NetworkSetup/NetworkSetupHelpers.c</option>
<option value="listing217.html">/MIB-Libraries/NetworkSetup/NetworkSetupHelpers.h</option>
<option value="listing218.html">/MIB-Libraries/NetworkSetup/NetworkSetupTest/NetworkSetupTest.c</option>
<option value="listing219.html">/MIB-Libraries/NetworkSetup/OldStyleAPI/OldOTConfigLib.h</option>
<option value="listing220.html">/MIB-Libraries/NetworkSetup/ReadMe.html</option>
<option value="listing221.html">/MIB-Libraries/PascalInterfaces/MoreSetup.p</option>
<option value="listing222.html">/MIB-Libraries/PascalInterfaces/TradDriverLoaderLib.p</option></select>
				</p>
				</form>
				<p><strong><a href="MoreIsBetter.zip">Download Sample</a></strong> (&#147;MoreIsBetter.zip&#148;, 1.61M)<BR>
<strong><a href="MoreIsBetter.dmg">Download Sample</a></strong> (&#147;MoreIsBetter.dmg&#148;, 2.04M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    MacCVSProTool.c

  Contains:  A tool to help integrate MacCVS Pro with command-line CVS.

  Written by:  Quinn

  Copyright:  Copyright &copy; 2003 by Apple Computer, Inc., All Rights Reserved.

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
        use, installation, modification or redistribution of this Apple software
        constitutes acceptance of these terms.  If you do not agree with these terms,
        please do not use, install, modify or redistribute this Apple software.

        In consideration of your agreement to abide by the following terms, and subject
        to these terms, Apple grants you a personal, non-exclusive license, under Apple's
        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
        reproduce, modify and redistribute the Apple Software, with or without
        modifications, in source and/or binary forms; provided that if you redistribute
        the Apple Software in its entirety and without modifications, you must retain
        this notice and the following text and disclaimers in all such redistributions of
        the Apple Software.  Neither the name, trademarks, service marks or logos of
        Apple Computer, Inc. may be used to endorse or promote products derived from the
        Apple Software without specific prior written permission from Apple.  Except as
        expressly stated in this notice, no other rights or licenses, express or implied,
        are granted by Apple herein, including but not limited to any patent rights that
        may be infringed by your derivative works or by other works in which the Apple
        Software may be incorporated.

        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
        COMBINATION WITH YOUR PRODUCTS.

        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Change History (most recent first):

$Log: MacCVSProTool.c,v $
Revision 1.3  2003/08/27 17:04:53         
Ignore SIGPIPE lest we trip up an assert in MoreUNIXWrite.

Revision 1.2  2003/08/14 21:40:27         
If we exit with an error, always print it to stderr, never stdout, and never test the verbose flag.

Revision 1.1  2003/08/13 14:00:45         
First checked in.


*/

#include &lt;CoreServices/CoreServices.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;sys/sysctl.h&gt;

#include &quot;MoreCFQ.h&quot;
#include &quot;MoreUNIX.h&quot;

/////////////////////////////////////////////////////////////////
#pragma mark ***** MacCVS Pro definitions

// The follow definitions are derived from the MacCVS Pro source code.
// Of course, I couldn't copy'n'paste the definitions because MacCVS Pro 
// is GPL, and GPL code can't be moved into DTS sample code.  Thanks guys.
// Instead, I looked through the file, worked out exactly what I needed, 
// and then wrote my own version.

// From &quot;CMacCVSDoc.h&quot;

#if PRAGMA_STRUCT_ALIGN
  #pragma options align=mac68k
#elif PRAGMA_STRUCT_PACKPUSH
  #pragma pack(push, 2)
#elif PRAGMA_STRUCT_PACK
  #pragma pack(2)
#endif

struct MacCVSPrefsFileMapItem
{  
  Str255    fExtension;
  OSType    fType;
  OSType    fCreator;
  UInt32    fTranslation;
  UInt32    fEncoding;
};
typedef struct MacCVSPrefsFileMapItem MacCVSPrefsFileMapItem;

#if PRAGMA_STRUCT_ALIGN
  #pragma options align=reset
#elif PRAGMA_STRUCT_PACKPUSH
  #pragma pack(pop)
#elif PRAGMA_STRUCT_PACK
  #pragma pack()
#endif

enum
{
  kMacCVSPrefsFileMagicNumber   = 0xBEEFEAFF,

  kMacCVSPrefsFileFormat10    = 0xFEFE0010,
            
  kMacCVSPrefsMappingData      = 'mapp',
  kMacCVSPrefsEOFData        = 'eof '
};

// From &quot;CVSEngine.h&quot;

enum
{
  kMacCVSPrefsLFTranslation    = 0,
  kMacCVSPrefsCRTranslation    = 1,
  kMacCVSPrefsCRLFTranslation    = 2
};

enum {
  kMacCVSPrefsTextEncoding    = 0,
  kMacCVSPrefsBinaryEncoding    = 1,
  kMacCVSPrefsAppleSingleEncoding  = 2,
  kMacCVSPrefsBinhex4Encoding    = 3,
  kMacCVSPrefsMacBinaryEncoding  = 4,
  kMacCVSPrefsRBLEncoding      = 5
};

// From &quot;CCVSEncoders.h&quot;

#if PRAGMA_STRUCT_ALIGN
  #pragma options align=mac68k
#elif PRAGMA_STRUCT_PACKPUSH
  #pragma pack(push, 2)
#elif PRAGMA_STRUCT_PACK
  #pragma pack(2)
#endif

struct AppleSingleHeader
{
  UInt32    fMagicNumber;        // must be either kAppleSingleMagicNumber or kAppleDoubleMagicNumber
  UInt32    fVersion;          // must be kAppleSingleVersion
  UInt32    fFiller1;
  UInt32    fFiller2;
  UInt32    fFiller3;
  UInt32    fFiller4;
  UInt16    fEntriesCount;        // number of entries immediately following this one
};
typedef struct AppleSingleHeader AppleSingleHeader;

struct AppleSingleEntry
{
    UInt32    fEntryType;        // see kAppleSingleDataFork etc below
    UInt32    fOffset;          // from start of file
    UInt32    fLength;            // in bytes
};
typedef struct AppleSingleEntry AppleSingleEntry; 

#if PRAGMA_STRUCT_ALIGN
  #pragma options align=reset
#elif PRAGMA_STRUCT_PACKPUSH
  #pragma pack(pop)
#elif PRAGMA_STRUCT_PACK
  #pragma pack()
#endif

enum {
    kAppleSingleMagicNumber         = 0x00051600,
    kAppleDoubleMagicNumber         = 0x00051607,
    kAppleSingleVersion             = 0x00020000
};

enum {
    kAppleSingleDataFork            = 1,
    kAppleSingleResFork             = 2,
    kAppleSingleComment             = 4,
    kAppleSingleDate                = 8,
    kAppleSingleMacFInfo            = 9
};

/////////////////////////////////////////////////////////////////
#pragma mark ***** Globals and forwards

static const char *gProgramName;

static FILE *gStdOut;

static Boolean gVerboseMode;

static void PrintUsage(void);      // forward declaration

/////////////////////////////////////////////////////////////////
#pragma mark ***** Preferences Common

// Indexed by kMacCVSPrefsLFTranslation etc

static StringPtr kTranslations[3]  = { &quot;\pUnix&quot;, &quot;\pMacintosh&quot;, &quot;\pDOS&quot; };
static const int kTranslationCount = sizeof(kTranslations) / sizeof(StringPtr);

// Indexed by kMacCVSPrefsTextEncoding etc

static StringPtr kEncodings[6]     = { &quot;\pText&quot;, &quot;\pBinary&quot;, &quot;\pAppleSingle&quot;, &quot;\pBinhex 4.0&quot;, &quot;\pMacBinary III&quot;, &quot;\pRBL&quot; };
static const int kEncodingCount    = sizeof(kEncodings)    / sizeof(StringPtr);

// Keys for the XML output

#define kExtensionKey     CFSTR(&quot;Extension&quot;)
#define kTypeKey       CFSTR(&quot;Type&quot;)
#define kCreatorKey     CFSTR(&quot;Creator&quot;)
#define kTranslationKey   CFSTR(&quot;Translation&quot;)
#define kEncodingKey     CFSTR(&quot;Encoding&quot;)

static int ReadPreferenceHeader(int prefsFD)
{
  int      err;
  UInt32     magic;
  UInt32     version;
  
  assert( prefsFD &gt;= 0);

  err = MoreUNIXRead(prefsFD, &amp;magic, sizeof(magic), NULL);
  if ( (err == 0) &amp;&amp; (magic != kMacCVSPrefsFileMagicNumber) ) {
    fprintf(stderr, &quot;%s: Bad magic number.\n&quot;, gProgramName);
    err = -1;
  }
  if (err == 0) {
    err = MoreUNIXRead(prefsFD, &amp;version, sizeof(version), NULL);
  }
  if ( (err == 0) &amp;&amp; (version != kMacCVSPrefsFileFormat10) ) {
    fprintf(stderr, &quot;%s: Preference file version not supported.\n&quot;, gProgramName);
    err = -1;
  }

  // I don't bother returning the version because I only deal 
  // with a single version at this time.
    
  return err;
}

static int WritePreferenceHeader(int prefsFD)
{
  int err;
  static const UInt32 kMagic   = kMacCVSPrefsFileMagicNumber;
  static const UInt32 kVersion = kMacCVSPrefsFileFormat10;
  
  assert( prefsFD &gt;= 0);

  err = MoreUNIXWrite(prefsFD, &amp;kMagic, sizeof(kMagic), NULL);
  if (err == 0) {
    err = MoreUNIXWrite(prefsFD, &amp;kVersion, sizeof(kVersion), NULL);
  }
  return err;
}

static int ReadPreferenceChunk(int prefsFD, OSType *chunkTypePtr, void **chunkPtrPtr, size_t *chunkSizePtr)
{
  int   err;
  OSType  chunkType;
  void *  chunkPtr;
  size_t  chunkSize;
  
  assert( prefsFD &gt;= 0);
  assert( chunkTypePtr != NULL);
  assert( chunkPtrPtr  != NULL);
  assert(*chunkPtrPtr  == NULL);
  assert( chunkSizePtr != NULL);
  
  chunkPtr  = NULL;
  chunkSize = 0;
  
  err = MoreUNIXRead(prefsFD, &amp;chunkType, sizeof(chunkType), NULL);
  if ( (err == 0) &amp;&amp; (chunkType != kMacCVSPrefsEOFData) ) {  
    UInt32 temp;
    
    err = MoreUNIXRead(prefsFD, &amp;temp, sizeof(temp), NULL);
    if (err == 0) {
      chunkSize = temp;
      
      // For kMacCVSPrefsMappingData chunks, the size stored in the 
      // file is the number of map entries, not the actual size in 
      // bytes.  To make the API consistent I multiply by the entry 
      // size here.
      
      if (chunkType == kMacCVSPrefsMappingData) {
        chunkSize *= sizeof(MacCVSPrefsFileMapItem);
      }
      
      chunkPtr = malloc(chunkSize + 1);    // add 1 to avoid malloc(0) unspecified behaviour
      if (chunkPtr == NULL) {
        err = ENOMEM;
      }
    }
    if (err == 0) {
      err = MoreUNIXRead(prefsFD, chunkPtr, chunkSize, NULL);
    }
  }
  
  // Clean up.
  
  if (err != 0) {
    free(chunkPtr);
    chunkPtr  = NULL;
    chunkSize = 0;
    chunkType = 'bad!';
  }
  *chunkTypePtr = chunkType;
  *chunkPtrPtr  = chunkPtr;
  *chunkSizePtr = chunkSize;
  
  assert( (err == 0) == ( (chunkSize == 0) || (*chunkPtrPtr != NULL) ) );
  
  return err;
}

static int WritePreferenceChunk(int prefsFD, OSType chunkType, const void *chunkPtr, size_t chunkSize)
{
  int      err;
  UInt32     sizeField;
  
  assert(prefsFD &gt;= 0);
  assert( (chunkType == kMacCVSPrefsEOFData) == (chunkPtr == NULL) );
  assert( (chunkPtr != NULL) || (chunkSize == 0) );
  
  switch (chunkType) {
    case kMacCVSPrefsEOFData:
      assert(chunkSize == 0);
      sizeField = 0;        // not strictly necessary, but a good idea to assign in all branches of switch
      break;
    case kMacCVSPrefsMappingData:
      assert((chunkSize % sizeof(MacCVSPrefsFileMapItem)) == 0);
      sizeField = chunkSize / sizeof(MacCVSPrefsFileMapItem);
      break;
    default:
      sizeField = chunkSize;
      break;
  }
  err = MoreUNIXWrite(prefsFD, &amp;chunkType, sizeof(chunkType), NULL);
  if ( (err == 0) &amp;&amp; (chunkType != kMacCVSPrefsEOFData)) {
    err = MoreUNIXWrite(prefsFD, &amp;sizeField, sizeof(sizeField), NULL);
    if ( (err == 0) &amp;&amp; (chunkSize != 0) ) {
      err = MoreUNIXWrite(prefsFD, chunkPtr, chunkSize, NULL);
    }
  }
  return err;
}

static int CreateAndOpenTemporyFile(const char *prefsPath, char *newPrefsPath, int *newPrefsFD)
{
  int err;
  int counter;
  
  assert(prefsPath != NULL);
  assert(newPrefsPath != NULL);
  assert( newPrefsFD != NULL);
  assert(*newPrefsFD == -1);
  
  counter = 0;
  do {
    err = 0;
    if ( snprintf(
        newPrefsPath, 
        MAXPATHLEN, 
        &quot;%s temp %d&quot;, 
        prefsPath, 
        counter
       ) &gt;= MAXPATHLEN ) {
      fprintf(stderr, &quot;%s: Path too long.\n&quot;, gProgramName);
      err = EINVAL;
    }
    
    if (err == 0) {
      *newPrefsFD = open(newPrefsPath, O_WRONLY | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);
      err = MoreUNIXErrno(*newPrefsFD);
    }
    
    counter += 1;
  } while ( (err == EEXIST) &amp;&amp; (counter &lt; 100) );
  
  return err;
}

static int ExchangeDataCompat(const char *realPath, const char *tempPath)
{
  int   err;
  int   junk;
  
  err = exchangedata(realPath, tempPath, 0);
  err = MoreUNIXErrno(err);
  
  if (err == 0) {
    // If the exchange succeeded, delete the new file (which now 
    // contains the old data).
    
    junk = unlink(tempPath);
    assert(junk == 0);
  } else {
    // If the exchange failed (may be on a non-HFS volume), do it 
    // the bad (non-atomic) way.
    
    err = unlink(realPath);
    if (err != 0) {
      err = rename(tempPath, realPath);
    }
  }
  
  return err;
}

enum {
  kFolderMagicNumber = 'fold'
};

static UInt32 SniffFile(const char *srcPath)
{
  int     err;
  int     junk;
  int      srcFD;
  UInt32    firstFourBytes;
  
  assert(srcPath != NULL);

  firstFourBytes = 0;
  
  srcFD = open(srcPath, O_RDONLY, 0);
  err = MoreUNIXErrno(srcFD);
  if (err == 0) {
    err = MoreUNIXRead(srcFD, &amp;firstFourBytes, sizeof(firstFourBytes), NULL);
  }
  if (srcFD != -1) {
    junk = close(srcFD);
    assert(junk == 0);
  }
  if (err == EISDIR) {
    err = 0;            // directories are not AppleSingle files (-:
    firstFourBytes = kFolderMagicNumber;
  } else if (err == EPIPE) {
    err = 0;            // file less than 4 bytes long, not an AppleSingle file
  }
  #if MORE_DEBUG
    if (err != 0) {
      fprintf(stderr, &quot;%s: Unexpected error %d sniffing file '%s'.\n&quot;, gProgramName, err, srcPath);
    }
  #endif
  
  return firstFourBytes;
}

/////////////////////////////////////////////////////////////////
#pragma mark ***** Import

static int GetPascalString(CFDictionaryRef dict, CFStringRef key, size_t maxSize, StringPtr pStr)
{
  int        err;
  CFStringRef    tmpStr;
  CFIndex      tmpStrLen;
  CFIndex      pStrLen;

  assert(dict != NULL);
  assert(key != NULL);
  assert(maxSize &gt; 0);      // there must always be space for the length byte
  assert(pStr != NULL);
  
  err = 0;
  tmpStr = CFDictionaryGetValue(dict, key);
  if ( (tmpStr == NULL) || (CFGetTypeID(tmpStr) != CFStringGetTypeID()) ) {
    fprintf(stderr, &quot;%s: Bad XML import file format; string expected.\n&quot;, gProgramName);
    err = -1;
  }

  if (err == 0) {
    tmpStrLen = CFStringGetLength(tmpStr);
    
    if ( CFStringGetBytes(
        tmpStr, 
        CFRangeMake(0, tmpStrLen), 
        kCFStringEncodingMacRoman, 
        0,                 // lossByte
        false,              // isExternalRepresentation
        &amp;pStr[1],
        (CFIndex) (maxSize - 1), 
        &amp;pStrLen
       ) == tmpStrLen ) {
      assert(pStrLen &lt; 256);
      pStr[0] = (UInt8) pStrLen;
    } else {
      fprintf(stderr, &quot;%s: Bad XML import file format; can't convert string to appropriate length MacRoman string.\n&quot;, gProgramName);
      err = -1;
    }
  }
  
  return err;
}

static int GetEnumerated(
  CFDictionaryRef   dict, 
  CFStringRef     key, 
  const StringPtr   enums[], 
  int         enumCount, 
  UInt32 *      valuePtr
)
{
  int     err;
  Str255    tmpStr;
  int      enumIndex;

  assert(dict != NULL);
  assert(key != NULL);
  assert(enums != NULL);
  assert(enumCount &gt; 0);      // makes no sense to offer no choices
  assert(valuePtr != NULL);
  
  err = GetPascalString(dict, key, sizeof(tmpStr), tmpStr);
  if (err == 0) {
    Boolean found;
    
    found = false;
    for (enumIndex = 0; enumIndex &lt; enumCount; enumIndex++) {
      if ( PLstrcmp(tmpStr, enums[enumIndex]) == 0 ) {
        *valuePtr = (UInt32) enumIndex;
        found = true;
        break;
      }
    }
    
    if ( ! found ) {
      fprintf(stderr, &quot;%s: Bad XML import file format; bad enumerated value.\n&quot;, gProgramName);
      err = -1;
    }
  }
  
  return err;
}

static int ReadMapXML(
  const char *        importPath, 
  MacCVSPrefsFileMapItem **   mapItemsPtr, 
  ItemCount *          mapItemCountPtr
)
{
  int                err;
  CFURLRef             url;
  CFArrayRef            mapArray;
  MacCVSPrefsFileMapItem *  mapItems;
  ItemCount            mapItemIndex;
  ItemCount            mapItemCount;
  
  assert(importPath != NULL);
  assert( mapItemsPtr != NULL);
  assert(*mapItemsPtr == NULL);
  assert( mapItemCountPtr != NULL);

  mapArray = NULL;
  mapItems = NULL;
  
  err = 0;
  url = CFURLCreateFromFileSystemRepresentation(NULL, (const UInt8 *) importPath, (CFIndex) strlen(importPath), false);
  if (url == NULL) {
    err = OSStatusToEXXX( coreFoundationUnknownErr );
  }
  if (err == 0) {
    err = OSStatusToEXXX( CFQPropertyListCreateFromXMLCFURL(url, kCFPropertyListImmutable, (CFPropertyListRef *) &amp;mapArray) );
  }
  if ( (err == 0) &amp;&amp; (CFGetTypeID(mapArray) != CFArrayGetTypeID()) ) {
    fprintf(stderr, &quot;%s: Bad XML import file format; root item is not an array.\n&quot;, gProgramName);
    err = -1;
  }
  if (err == 0) {
    mapItemCount = (ItemCount) CFArrayGetCount(mapArray);
    
    mapItems = (MacCVSPrefsFileMapItem *) calloc(1, mapItemCount * sizeof(MacCVSPrefsFileMapItem));
    if (mapItems == NULL) {
      err = ENOMEM;
    }
  }
  if (err == 0) {
    for (mapItemIndex = 0; mapItemIndex &lt; mapItemCount; mapItemIndex++) {
      MacCVSPrefsFileMapItem * thisMapItem;
      CFDictionaryRef         thisArrayItem;
      UInt8             osTypeStr[5];
      
      thisMapItem = &amp;mapItems[mapItemIndex];
      thisArrayItem = CFArrayGetValueAtIndex(mapArray, (CFIndex) mapItemIndex);
      if ( CFGetTypeID(thisArrayItem) != CFDictionaryGetTypeID() ) {
        fprintf(stderr, &quot;%s: Bad XML import file format; item %lu is not a dictionary.\n&quot;, gProgramName, mapItemIndex);
        err = -1;
      }
      
      // kExtensionKey
      
      if (err == 0) {
        err = GetPascalString(thisArrayItem, kExtensionKey, sizeof(Str255), thisMapItem-&gt;fExtension);
      }
      
      // kTypeKey, kCreatorKey
      
      if (err == 0) {
        err = GetPascalString(thisArrayItem, kTypeKey, sizeof(osTypeStr), osTypeStr);
        thisMapItem-&gt;fType = *(OSType *)&amp;osTypeStr[1];
      }
      if (err == 0) {
        err = GetPascalString(thisArrayItem, kCreatorKey, sizeof(osTypeStr), osTypeStr);
        thisMapItem-&gt;fCreator = *(OSType *)&amp;osTypeStr[1];
      }
      
      // kTranslationKey, kEncodingKey
      
      if (err == 0) {
        err = GetEnumerated(thisArrayItem, kTranslationKey, kTranslations, kTranslationCount, &amp;thisMapItem-&gt;fTranslation);
      }
      if (err == 0) {
        err = GetEnumerated(thisArrayItem, kEncodingKey, kEncodings, kEncodingCount, &amp;thisMapItem-&gt;fEncoding);
      }
      
      if (err != 0) {
        break;
      }
    }
  }

  // Clean up.
  
  if (err == 0) {
    *mapItemsPtr = mapItems;
    *mapItemCountPtr = mapItemCount;
  } else {
    free(mapItems);
  }
  CFQRelease(url);
  CFQRelease(mapArray);
  
  assert( (err == 0) == (*mapItemsPtr != NULL) );
  
  return err;
}

static int ReadMapText(
  const char *        importPath, 
  MacCVSPrefsFileMapItem **   mapItemsPtr, 
  ItemCount *          mapItemCountPtr
)
{
  assert(importPath != NULL);
  assert( mapItemsPtr != NULL);
  assert(*mapItemsPtr == NULL);
  assert( mapItemCountPtr != NULL);

  fprintf(stderr, &quot;%s: Importing from a text file is not yet supported.\n&quot;, gProgramName);
  
  return -1;
}

static int ReadMapMacCVS(
  const char *        prefsPath, 
  MacCVSPrefsFileMapItem **   mapItemsPtr, 
  ItemCount *          mapItemCountPtr
)
{
  int              err;
  int             prefsFD;
  int             junk;
  MacCVSPrefsFileMapItem *  mapItems;
  ItemCount          mapItemCount;

  assert(prefsPath != NULL);
  assert( mapItemsPtr != NULL);
  assert(*mapItemsPtr == NULL);
  assert( mapItemCountPtr != NULL);

  mapItems = NULL;
  
  prefsFD = open(prefsPath, O_RDONLY, 0);
  err = MoreUNIXErrno(prefsFD);
  if (err == 0) {
    err = ReadPreferenceHeader(prefsFD);
  }
  if (err == 0) {
    OSType  chunkType;
    void *  chunkPtr;
    size_t  chunkSize;
    
    // I could end this loop when I find the mapping but I let it run 
    // so that I can detect if the preference file is malformed (which 
    // implies that I don't know what's going on).
    
    do {
      chunkPtr = NULL;
      
      err = ReadPreferenceChunk(prefsFD, &amp;chunkType, &amp;chunkPtr, &amp;chunkSize);
      if (err == 0) {
        // fprintf(stderr, &quot;'%.4s' %ld\n&quot;, &amp;chunkType, chunkSize);

        if (chunkType == kMacCVSPrefsMappingData) {
          if (mapItems == NULL) {
            // Can safely divide by sizeof(MacCVSPrefsFileMapItem) 
            // to get the number of map entries without fear of rounding 
            // errors because ReadPreferenceChunk did the equivalent multiply 
            // because the size stored in the file is actually the count, not 
            // the byte size.
            
            assert((chunkSize % sizeof(MacCVSPrefsFileMapItem)) == 0);
            mapItemCount = chunkSize / sizeof(MacCVSPrefsFileMapItem);

            // NULL out chunkPtr so that it's not freed.
            
            mapItems = chunkPtr;
            chunkPtr = NULL;
          } else {
            assert(false);      // two mapping chunks in the same file
          }
        }
      }
      
      free(chunkPtr);
    } while ( (err == 0) &amp;&amp; (chunkType != kMacCVSPrefsEOFData) );
  }
  if ( (err == 0) &amp;&amp; (mapItems == NULL) ) {
    fprintf(stderr, &quot;%s: No mapping data.\n&quot;, gProgramName);
    err = -1;
  }
  
  // Clean up.
  
  if (err == 0) {
    *mapItemsPtr     = mapItems;
    *mapItemCountPtr = mapItemCount;
  } else {
    free(mapItems);
  }
  if (prefsFD != -1) {
    junk = close(prefsFD);
    assert(junk == 0);
  }
  
  return err;
}

static int CommandMappingsImportExecute(
  const char *  prefsPath, 
  const char *  importPath, 
  Boolean     xml
)
{
  int               err;
  int               junk;
  int               oldPrefsFD;
  int                newPrefsFD;
  char              newPrefsPath[MAXPATHLEN];
  Boolean              processedMap;
  MacCVSPrefsFileMapItem *  mapItems;
  ItemCount            mapItemCount;
    
  assert(prefsPath != NULL);
  assert(importPath != NULL);
  
  if (gVerboseMode) {
    fprintf(gStdOut, &quot;Importing mappings from '%s' to '%s'\n&quot;, importPath, prefsPath);
  }
  
  newPrefsFD = -1;
  oldPrefsFD = -1;
  mapItems = NULL;
  
  // Read the input file.
  
  if (xml) {
    err = ReadMapXML(importPath, &amp;mapItems, &amp;mapItemCount);
  } else {
    err = ReadMapText(importPath, &amp;mapItems, &amp;mapItemCount);
  }
  
  // Create a temporary file in the same directory as the destination. 
  // [I could have used the temporary items folder but that complicates 
  // things if there is no temporary items folder on the volume that 
  // we're writing to.
  //
  // As this is a temporary file that we're going to exchange 
  // with the original, there's no need to set the type and creator. 
  // Also, we set the perms to rw------- because we don't care if 
  // the temporary file is readable by our group or others because 
  // we're deleting it later anyway.

  if (err == 0) {
    err = CreateAndOpenTemporyFile(prefsPath, newPrefsPath, &amp;newPrefsFD);
  }
  
  // Open the existing file we're merging in to.
  
  if (err == 0) {
    oldPrefsFD = open(prefsPath, O_RDONLY, 0);
    err = MoreUNIXErrno(oldPrefsFD);
  }

  // Copy across the header.
  
  if (err == 0) {
    err = ReadPreferenceHeader(oldPrefsFD);
  }
  if (err == 0) {
    err = WritePreferenceHeader(newPrefsFD);
  }
  
  // Read through each chunk in the input file, copying them to the 
  // output file.  If we find a mappings chunk, replace it with the 
  // new mappings.
  
  if (err == 0) {
    OSType  chunkType;
    void *  chunkPtr;
    size_t  chunkSize;
    
    do {
      chunkPtr = NULL;
      
      err = ReadPreferenceChunk(oldPrefsFD, &amp;chunkType, &amp;chunkPtr, &amp;chunkSize);
      if (err == 0) {
        // fprintf(stderr, &quot;'%.4s' %ld\n&quot;, &amp;chunkType, chunkSize);

        if (chunkType == kMacCVSPrefsMappingData) {
          if ( ! processedMap ) {
            processedMap = true;
            err = WritePreferenceChunk(newPrefsFD, kMacCVSPrefsMappingData, mapItems, mapItemCount * sizeof(MacCVSPrefsFileMapItem));
          } else {
            assert(false);      // two mapping chunks in the same field
          }
        } else if (chunkType != kMacCVSPrefsEOFData) {
          err = WritePreferenceChunk(newPrefsFD, chunkType, chunkPtr, chunkSize);
        }
      }
      
      free(chunkPtr);
    } while ( (err == 0) &amp;&amp; (chunkType != kMacCVSPrefsEOFData) );
  }
  
  // If we didn't find a mappings chunk, put one before the EOF chunk.
  
  if ( (err == 0) &amp;&amp; ! processedMap ) {
    err = WritePreferenceChunk(newPrefsFD, kMacCVSPrefsMappingData, mapItems, mapItemCount * sizeof(MacCVSPrefsFileMapItem));
  }
  
  // Write out an EOF chunk.
  
  if (err == 0) {
    err = WritePreferenceChunk(newPrefsFD, kMacCVSPrefsEOFData, NULL, 0);
  }

  // Exchange the new and old files.  We close the files before we do this 
  // (which seems sensible).
  
  if (oldPrefsFD != -1) {
    junk = close(oldPrefsFD);
    assert(junk == 0);
  }
  if (newPrefsFD != -1) {
    junk = close(newPrefsFD);
    assert(junk == 0);
  }
  if (err == 0) {
    err = ExchangeDataCompat(prefsPath, newPrefsPath);
  }
  
  // Final clean up.

  if ( (err != 0) &amp;&amp; (newPrefsFD != -1) ) {
    junk = unlink(newPrefsPath);
    assert(junk == 0);
  }
  free(mapItems);
  
  return err;
}

/////////////////////////////////////////////////////////////////
#pragma mark ***** Export

static int ConvertMapToCFArray(
  const MacCVSPrefsFileMapItem   mapItems[], 
  ItemCount             mapItemCount,
  CFArrayRef *          resultPtr
)
{
  int          err;
  CFMutableArrayRef  result;
  ItemCount       mapItemIndex;
  CFIndex        keyIndex;

  assert(mapItems != NULL);
  assert( resultPtr != NULL);
  assert(*resultPtr == NULL);

  result = NULL;
  
  err = OSStatusToEXXX( CFQArrayCreateMutable(&amp;result) );
  if (err == 0) {
    for (mapItemIndex = 0; mapItemIndex &lt; mapItemCount; mapItemIndex++) {
      static const int kKeyCount = 5;
      CFStringRef             keys[kKeyCount];
      CFStringRef             values[kKeyCount];
      const MacCVSPrefsFileMapItem *   thisMapItem;
      CFDictionaryRef            dict;
      
      thisMapItem = &amp;mapItems[mapItemIndex];
      
      dict = NULL;
      
      keys[0] = kExtensionKey;
      keys[1] = kTypeKey;
      keys[2] = kCreatorKey;
      keys[3] = kTranslationKey;
      keys[4] = kEncodingKey;
      
      values[0] = CFStringCreateWithPascalString(NULL, thisMapItem-&gt;fExtension, kCFStringEncodingMacRoman);
      values[1] = CFStringCreateWithBytes(NULL, (const UInt8 *) &amp;thisMapItem-&gt;fType, sizeof(OSType), kCFStringEncodingMacRoman, false);
      values[2] = CFStringCreateWithBytes(NULL, (const UInt8 *) &amp;thisMapItem-&gt;fCreator, sizeof(OSType), kCFStringEncodingMacRoman, false);
      if (thisMapItem-&gt;fTranslation &lt; kTranslationCount) {
        values[3] = CFStringCreateWithPascalString(NULL, kTranslations[thisMapItem-&gt;fTranslation], kCFStringEncodingASCII);
      } else {
        values[3] = NULL;
        fprintf(stderr, &quot;%s: Unrecognised translation.\n&quot;, gProgramName);
        err = -1;
      }
      if (thisMapItem-&gt;fEncoding &lt; kEncodingCount) {
        values[4] = CFStringCreateWithPascalString(NULL, kEncodings[thisMapItem-&gt;fEncoding], kCFStringEncodingASCII);
      } else {
        values[4] = NULL;
        fprintf(stderr, &quot;%s: Unrecognised encoding.\n&quot;, gProgramName);
        err = -1;
      }

      if (   (values[0] == NULL)
         || (values[1] == NULL)
         || (values[2] == NULL)
         || (values[3] == NULL)
         || (values[4] == NULL) ) {
        if (err == 0) {
          err = OSStatusToEXXX( coreFoundationUnknownErr );
        }
      }
      
      if (err == 0) {
        dict = CFDictionaryCreate(
          NULL, 
          (const void **) keys, 
          (const void **) values, 
          kKeyCount, 
          &amp;kCFTypeDictionaryKeyCallBacks, 
          &amp;kCFTypeDictionaryValueCallBacks
        );
        if (dict == NULL) {
          err = OSStatusToEXXX( coreFoundationUnknownErr );
        }
      }
      if (err == 0) {
        CFArrayAppendValue(result, dict);
      }
      
      // Clean up.
      
      // ***\xCAWhy isn't this release right?
      // fprintf(stderr, &quot;retain count = %ld %ld %ld %ld %ld\n&quot;, CFGetRetainCount(keys[0]), CFGetRetainCount(keys[1]), CFGetRetainCount(keys[2]), CFGetRetainCount(keys[3]), CFGetRetainCount(keys[4]));
      for (keyIndex = 0; keyIndex &lt; kKeyCount; keyIndex++) {
        // CFQRelease(keys[keyIndex]);
        CFQRelease(values[keyIndex]);
      }
      CFQRelease(dict);
      
      if (err != 0) {
        break;
      }
    }
  }
  
  // Clean up.
  
  if (err != 0) {
    CFQRelease(result);
    result = NULL;
  }
  *resultPtr = result;
  
  assert( (err == 0) == (*resultPtr != NULL) );
  
  return err;
}


static int ExportMapAsXML(
  const MacCVSPrefsFileMapItem   mapItems[], 
  ItemCount             mapItemCount,
  const char *          exportPath
)
{
  int         err;
  CFArrayRef      output;
  CFDataRef      data;
  CFURLRef      url;
  
  assert(mapItems != NULL);
  assert(exportPath != NULL);
  
  output = NULL;
  data = NULL;
  url = NULL;
  
  err = ConvertMapToCFArray(mapItems, mapItemCount, &amp;output);
  if (err == 0) {
    data = CFPropertyListCreateXMLData(NULL, output);
    if (data == NULL) {
      err = OSStatusToEXXX( coreFoundationUnknownErr );
    }
  }
  if (err == 0) {
    url = CFURLCreateFromFileSystemRepresentation(NULL, (const UInt8 *) exportPath, (CFIndex) strlen(exportPath), false);
    if (url == NULL) {
      err = OSStatusToEXXX( coreFoundationUnknownErr );
    }
  }
  if (err == 0) {
    SInt32 errorCode;
    
    (void) CFURLWriteDataAndPropertiesToResource(url, data, NULL, &amp;errorCode);
    err = errorCode;
  }
  
  // Clean up.
  
  CFQRelease(output);
  CFQRelease(data);
  CFQRelease(url);
  
  return err;
}

static int PrintUTF8String(FILE *outFile, const UInt8 *str, CFIndex strLen)
{
  int        err;
  CFStringRef   cfStr;
  CFIndex      cfStrLen;
  char *      buf;
  CFIndex      bufSize;
  CFIndex      bufUsed;
  
  assert(outFile != NULL);
  assert(str != NULL);

  buf = NULL;
  
  err = 0;
  cfStr = CFStringCreateWithBytes(NULL, str, strLen, kCFStringEncodingMacRoman, false);
  if (cfStr == NULL) {
    err = OSStatusToEXXX( coreFoundationUnknownErr );
  }
  if (err == 0) {
    cfStrLen = CFStringGetLength(cfStr);
    
    bufSize = CFStringGetMaximumSizeForEncoding(cfStrLen, kCFStringEncodingUTF8);
    
    buf = malloc( (size_t) bufSize + 1 );    // add 1 to avoid malloc(0) unspecified behaviour
    if (buf == NULL) {
      err = ENOMEM;
    }
  }
  if (err == 0) {
    if ( CFStringGetBytes(
        cfStr, 
        CFRangeMake(0, cfStrLen), 
        kCFStringEncodingUTF8, 
        0,               // lossByte
        false,             // isExternalRepresentation
        (UInt8 *) buf, 
        bufSize, 
        &amp;bufUsed
       ) != cfStrLen ) {
      err = OSStatusToEXXX( coreFoundationUnknownErr );
    }
  }
  if (err == 0) {
    fprintf(outFile, &quot;%.*s&quot;, bufUsed, buf);
  }
  
  // Clean up.
  
  CFQRelease(cfStr);
  free(buf);
  
  return err;
}

static int ExportMapAsText(
  const MacCVSPrefsFileMapItem   mapItems[], 
  ItemCount             mapItemCount,
  const char *          exportPath
)
{
  int      err;
  int      junk;
  FILE *    outFile;
  ItemCount   mapItemIndex;

  assert(mapItems != NULL);
  assert(exportPath != NULL);
  
  err = 0;
  outFile = fopen(exportPath, &quot;w&quot;);
  if (outFile == NULL) {
    err = errno;
  }
  
  if (err == 0) {
    for (mapItemIndex = 0; mapItemIndex &lt; mapItemCount; mapItemIndex++) {
      const MacCVSPrefsFileMapItem *thisMapItem;
      const UInt8 *tmpStr;

      thisMapItem = &amp;mapItems[mapItemIndex];
      
      err = PrintUTF8String(outFile, &amp;thisMapItem-&gt;fExtension[1], thisMapItem-&gt;fExtension[0]);
      if (err == 0) {
        fprintf(outFile, &quot;\t&quot;);
        err = PrintUTF8String(outFile, (const UInt8 *) &amp;thisMapItem-&gt;fType, sizeof(OSType));
      }
      if (err == 0) {
        fprintf(outFile, &quot;\t&quot;);
        err = PrintUTF8String(outFile, (const UInt8 *) &amp;thisMapItem-&gt;fCreator, sizeof(OSType));
      }
      if (err == 0) {
        if (thisMapItem-&gt;fTranslation &lt; kTranslationCount) {
          fprintf(outFile, &quot;\t&quot;);
          tmpStr = kTranslations[thisMapItem-&gt;fTranslation];
          fprintf(outFile, &quot;%.*s&quot;, tmpStr[0], &amp;tmpStr[1]);
        } else {
          fprintf(stderr, &quot;%s: Unrecognised translation.\n&quot;, gProgramName);
          err = -1;
        }
      }
      if (err == 0) {
        if (thisMapItem-&gt;fEncoding &lt; kEncodingCount) {
          fprintf(outFile, &quot;\t&quot;);
          tmpStr = kEncodings[thisMapItem-&gt;fEncoding];
          fprintf(outFile, &quot;%.*s&quot;, tmpStr[0], &amp;tmpStr[1]);
          fprintf(outFile, &quot;\n&quot;);
        } else {
          fprintf(stderr, &quot;%s: Unrecognised encoding.\n&quot;, gProgramName);
          err = -1;
        }
      }
      
      if (err != 0) {
        break;
      }      
    }
  }
  
  // Clean up.
  
  if (outFile != NULL) {
    junk = fclose(outFile);
    assert(junk == 0);
  }

  return err;
}

static int CommandMappingsExportExecute(
  const char *  prefsPath, 
  const char *  exportPath, 
  Boolean     xml
)
{
  int             err;
  MacCVSPrefsFileMapItem *  mapItems;
  ItemCount          mapItemCount;
    
  assert(prefsPath != NULL);
  assert(exportPath != NULL);
  
  if (gVerboseMode) {
    fprintf(gStdOut, &quot;Exporting mappings from '%s' to '%s'\n&quot;, prefsPath, exportPath);
  }
  
  err = ReadMapMacCVS(prefsPath, &amp;mapItems, &amp;mapItemCount);
  if (err == 0) {
    if (xml) {
      err = ExportMapAsXML(
        mapItems, 
        mapItemCount, 
        exportPath);
    } else {
      err = ExportMapAsText(
        mapItems, 
        mapItemCount, 
        exportPath);
    }
  }

  // Clean up.
  
  free(mapItems);
    
  return err;
}

/////////////////////////////////////////////////////////////////
#pragma mark ***** Import/Export

static int CommandMappingsImportExport(int argc, char **argv, Boolean import)
{
  int        argIndex;
  int       ch;
  Boolean      xml;
  const char *  prefsPath;
  const char *  filePath;
  
  xml = false;
    do {
        ch = getopt(argc, argv, &quot;x&quot;);
        if (ch != -1) {
            switch (ch) {
                case 'x':
                  xml = true;
                    break;
                case '?':
                default:
                    PrintUsage();
                    exit(EXIT_FAILURE);
                    break;
            }
        }
    } while (ch != -1);
  
  argIndex = optind;
  
  if (argIndex &lt; argc) {
    prefsPath = argv[argIndex];
    argIndex += 1;
  } else {
        PrintUsage();
        exit(EXIT_FAILURE);
  }
  if (argIndex &lt; argc) {
    filePath = argv[argIndex];
    argIndex += 1;
  } else {
        PrintUsage();
        exit(EXIT_FAILURE);
  }
  if (argIndex != argc) {
        PrintUsage();
        exit(EXIT_FAILURE);
  }
  
  if (import) {
    return CommandMappingsImportExecute(prefsPath, filePath, xml);
  } else {
    return CommandMappingsExportExecute(prefsPath, filePath, xml);
  }
}

/////////////////////////////////////////////////////////////////
#pragma mark ***** AppleSingle Decode

static const int kBufferSize = 65536;

static int CopyEntryToFork(int srcFD, const AppleSingleEntry *entry, SInt16 forkRef, void *buf)
{
  int   err;
  UInt32  bytesLeft;
  UInt32  bytesThisTime;

  assert(srcFD &gt;= 0);
  assert(entry != NULL);
  assert(forkRef != 0);
  assert(buf != NULL);
  
  // Set the destination fork length.
  
  err = OSStatusToEXXX( FSSetForkSize(forkRef, fsFromStart, entry-&gt;fLength) );
  
  // Seek to the right place in the source.
  
  if (err == 0) {
    err = (int) lseek(srcFD, entry-&gt;fOffset, SEEK_SET);
    err = MoreUNIXErrno(err);
  }
  
  // Copy source to destination.
  
  bytesLeft = entry-&gt;fLength;  
  while ( (err == 0) &amp;&amp; (bytesLeft != 0) ) {
    bytesThisTime = bytesLeft;
    if (bytesThisTime &gt; kBufferSize) {
      bytesThisTime = kBufferSize;
    }
    
    err = MoreUNIXRead(srcFD, buf, bytesThisTime, NULL);
    if (err == 0) {
      err = OSStatusToEXXX( FSWriteFork(forkRef, fsAtMark, 0, bytesThisTime, buf, NULL) );
    }
    if (err == 0) {
      bytesLeft -= bytesThisTime;
    }
  }

  return err;
}

static int ReadFileInfo(int srcFD, const AppleSingleEntry *entry, FSCatalogInfo * catInfo)
{
  int    err;

  assert(srcFD &gt;= 0);
  assert(entry != NULL);
  assert(catInfo != NULL);
  
  err = 0;
  if (entry-&gt;fLength &lt; sizeof(catInfo-&gt;finderInfo)) {
    fprintf(stderr, &quot;%s: File info entry too short.\n&quot;, gProgramName);
    err = -1;
  }
  if (err == 0) {
    err = (int) lseek(srcFD, entry-&gt;fOffset, SEEK_SET);
    err = MoreUNIXErrno(err);
  }
  if (err == 0) {
    err = MoreUNIXRead(srcFD, &amp;catInfo-&gt;finderInfo, sizeof(catInfo-&gt;finderInfo), NULL);
  }
  return err;
}

static int DecodeAppleSingle(const char *srcPath)
{
  int         err;
  int         junk;
  char         dstPath[MAXPATHLEN];
  FSRef        dstRef;
  FSRef        srcRef;
  int          srcFD;
  int          dstFD;
  SInt16        dataFork;
  SInt16        rsrcFork;
  void *        buf;
  AppleSingleHeader  header;
  UInt16        entryIndex;
  Boolean        catInfoValid;
  FSCatalogInfo    catInfo;
  
  assert(srcPath != NULL);

  if (gVerboseMode) {
    fprintf(gStdOut, &quot;Decoding AppleSingle file '%s'\n&quot;, srcPath);
  }
  
  srcFD = -1;
  dstFD = -1;
  rsrcFork = 0;
  dataFork = 0;
  catInfoValid = false;
  
  err = noErr;
  buf = malloc(kBufferSize);
  if (buf == NULL) {
    err = ENOMEM;
  }
  
  // Create a temporary file and open up both forks.
  
  err = CreateAndOpenTemporyFile(srcPath, dstPath, &amp;dstFD);
  if (err == 0) {
    err = OSStatusToEXXX( FSPathMakeRef((UInt8 *) dstPath, &amp;dstRef, NULL) );
  }
  if (err == 0) {
    HFSUniStr255 rsrcForkName;

    err = OSStatusToEXXX( FSGetResourceForkName(&amp;rsrcForkName) );
    if (err == 0) {
      err = OSStatusToEXXX( FSOpenFork(&amp;dstRef, rsrcForkName.length, rsrcForkName.unicode, fsRdWrPerm, &amp;rsrcFork) );
    }
  }
  if (dstFD != -1) {
    junk = close(dstFD);
    assert(junk == 0);
    // IMPORTANT: Leave dstFD set because as a marker for the cleanup code.
  }
  if (err == 0) {
    err = OSStatusToEXXX( FSOpenFork(&amp;dstRef, 0, NULL, fsRdWrPerm, &amp;dataFork) );
  }
  
  // Open up the source file.
  
  if (err == 0) {
    srcFD = open(srcPath, O_RDONLY, 0);
    err = MoreUNIXErrno(srcFD);
  }
  
  // Read and check the header.
  
  if (err == 0) {
    err = MoreUNIXRead(srcFD, &amp;header, sizeof(header), NULL);
  }
  if ( (err == 0) &amp;&amp; (header.fMagicNumber != kAppleSingleMagicNumber) &amp;&amp; (header.fMagicNumber != kAppleDoubleMagicNumber) ) {
    fprintf(stderr, &quot;%s: Not an AppleSingle file.\n&quot;, gProgramName);
    err = -1;
  }
  if ( (err == 0) &amp;&amp; (header.fVersion != kAppleSingleVersion) ) {
    fprintf(stderr, &quot;%s: Unrecognised AppleSingle version.\n&quot;, gProgramName);
    err = -1;
  }
  
  // Process each entry.
  
  if (err == 0) {
    for (entryIndex = 0; entryIndex &lt; header.fEntriesCount; entryIndex++) {
      AppleSingleEntry thisEntry;
      
      err = (int) lseek(srcFD, sizeof(header) + entryIndex * sizeof(thisEntry), SEEK_SET);
      err = MoreUNIXErrno(err);
      
      if (err == 0) {
        err = MoreUNIXRead(srcFD, &amp;thisEntry, sizeof(thisEntry), NULL);
      }
      
      if (err == 0) {
        switch (thisEntry.fEntryType) {
          case kAppleSingleDataFork:
            err = CopyEntryToFork(srcFD, &amp;thisEntry, dataFork, buf);
            break;
          case kAppleSingleResFork:
            err = CopyEntryToFork(srcFD, &amp;thisEntry, rsrcFork, buf);
            break;
          case kAppleSingleMacFInfo:
            err = ReadFileInfo(srcFD, &amp;thisEntry, &amp;catInfo);
            catInfoValid = (err == noErr);
            break;
          default:
            // Ignore unrecognised entry types.
            break;
        }
      }
      
      if (err != noErr) {
        break;
      }
    }
  }
  
  // Clean up.
  
  if (dataFork != 0) {
    junk = FSClose(dataFork);
    assert(junk == 0);
  }
  if (rsrcFork != 0) {
    junk = FSClose(rsrcFork);
    assert(junk == 0);
  }
  if (srcFD != -1) {
    junk = close(srcFD);
    assert(junk == 0);
  }
  if (err == 0) {
    err = ExchangeDataCompat(srcPath, dstPath);
  }
  // At this point we no longer handle errors.  The job is 
  // to set the source file's catInfo (success) or to delete 
  // the destination file (failure).  Failure to do either of 
  // these is not considered an error.
  if (err == 0) {
    if (catInfoValid) {
      err = OSStatusToEXXX( FSPathMakeRef((UInt8 *) srcPath, &amp;srcRef, NULL) );
      if (err == 0) {
        err = OSStatusToEXXX( FSSetCatalogInfo(&amp;srcRef, kFSCatInfoFinderInfo, &amp;catInfo) );
      }
    }
    assert(err == noErr);
    err = noErr;
  } else if (dstFD != -1) {
    junk = unlink(dstPath);
    assert(junk == 0);
  }
  free(buf);
  
  return err;
}

static Boolean FindMapEntryByTheFilesExtension(
  const char *          srcPath,
  const MacCVSPrefsFileMapItem   mapItems[],
  ItemCount             mapItemCount,
  ItemCount *            foundItemIndex
)
{
  Boolean    result;
  ItemCount  mapItemIndex;
  size_t    srcPathLen;
  
  srcPathLen = strlen(srcPath);
  
  result = false;
  
  for (mapItemIndex = 0; mapItemIndex &lt; mapItemCount; mapItemIndex++) {
    const MacCVSPrefsFileMapItem *   thisItem;
    size_t              extensionLength;
    
    thisItem = &amp;mapItems[mapItemIndex];
    extensionLength = thisItem-&gt;fExtension[0];
    if (extensionLength != 0) {              // don't match default entry
      if (srcPathLen &gt;= extensionLength) {      // srcPath must be longer than extension
        if ( memcmp(
            srcPath + srcPathLen - extensionLength,
            &amp;thisItem-&gt;fExtension[1], 
            extensionLength
           ) == 0 ) {
          *foundItemIndex = mapItemIndex;
          result = true;
          break;
        }
      }
    }
  }
  
  return result;
}

static int CommandDecodeExecute(
  const char *          srcPath,
  const MacCVSPrefsFileMapItem   mapItems[],
  ItemCount             mapItemCount
)
{
  int        err;
  const char *  whyIgnored;
  UInt32      foundItemIndex;
  FSRef      srcRef;
  FSCatalogInfo  catInfo;
  FileInfo *    finderInfo;
  Boolean      fileTypeInvalid;
  Boolean      fileCreatorInvalid;
  Boolean      mapTypeValid;
  Boolean      mapCreatorValid;

  // fprintf(stderr, &quot;srcPath = %s\n&quot;, srcPath);
  
  switch ( SniffFile(srcPath) ) {
    case kAppleSingleMagicNumber:
    case kAppleDoubleMagicNumber:
      err = DecodeAppleSingle(srcPath);
      break;
    case kFolderMagicNumber:
      if (gVerboseMode) {
        fprintf(gStdOut, &quot;Ignoring folder '%s'\n&quot;, srcPath);
      }
      err = 0;
      break;
    default:
      err = 0;
      whyIgnored = NULL;
      
      // See whether the file has an extension we recognise.
      
      if ( FindMapEntryByTheFilesExtension(srcPath, mapItems, mapItemCount, &amp;foundItemIndex) ) {
      
        // If so, check whether the file type and creator are both invalid. 
        // This check makes us idempotent.  That is, if you decode an 
        // AppleSingle file with an extension (this decode sets the file 
        // type and creator from the contents of the AppleSingle file)
        // and then run the decode again, the second decode won't change the 
        // file type and creator.
        //
        // We also check whether the map entry has a valid type or creator. 
        // Not much point setting if if not.
          
        err = OSStatusToEXXX( FSPathMakeRef((UInt8 *) srcPath, &amp;srcRef, NULL) );
        if (err == 0) {
          err = OSStatusToEXXX( FSGetCatalogInfo(
            &amp;srcRef,
            kFSCatInfoFinderInfo,
            &amp;catInfo,
            NULL,
            NULL,
            NULL
          ) );
        }
        
        if (err == 0) {
          finderInfo = (FileInfo *) catInfo.finderInfo;
          
          fileTypeInvalid    = ((finderInfo-&gt;fileType    == 0) || (finderInfo-&gt;fileType    == '????'));
          fileCreatorInvalid = ((finderInfo-&gt;fileCreator == 0) || (finderInfo-&gt;fileCreator == '????'));
          mapTypeValid       = ((mapItems[foundItemIndex].fType    != 0) &amp;&amp; (mapItems[foundItemIndex].fType    != '????'));
          mapCreatorValid    = ((mapItems[foundItemIndex].fCreator != 0) &amp;&amp; (mapItems[foundItemIndex].fCreator != '????'));

          if (fileTypeInvalid &amp;&amp; fileCreatorInvalid) {
            if (mapTypeValid &amp;&amp; mapCreatorValid) {

              // If so, set the file type and creator based on the map entry.

              if (gVerboseMode) {
                fprintf(gStdOut, &quot;Setting type and creator of file '%s'\n&quot;, srcPath);
              }
              
              finderInfo-&gt;fileType    = mapItems[foundItemIndex].fType;
              finderInfo-&gt;fileCreator = mapItems[foundItemIndex].fCreator;
              
              err = FSSetCatalogInfo(&amp;srcRef, kFSCatInfoFinderInfo, &amp;catInfo);
            } else {
              whyIgnored = &quot;its mapping has no valid type or creator&quot;;
            }
          } else {
            whyIgnored = &quot;its file type or creator is already set&quot;;
          }
        }
      } else {
        whyIgnored = &quot;its extension is missing or not mapped&quot;;
      }
      if (gVerboseMode &amp;&amp; (whyIgnored != NULL)) {
        fprintf(gStdOut, &quot;Ignoring file '%s' because %s.\n&quot;, srcPath, whyIgnored);
      }
      break;
  }
  
  return err;
}

static const char *kDefaultMapPath = &quot;/Volumes/CWPro8.3MIB/MoreIsBetter CVS&quot;;

enum {
  kPropertyListFileMagicNumber = 0x3C3F786D     // ie '&lt;?xm'
};

static int CommandDecode(int argc, char **argv)
{
  int                err;
  int                ch;
  int                argIndex;
  const char *          mapPath;
  MacCVSPrefsFileMapItem *    mapItems;
  ItemCount             mapItemCount;
  
  mapItems = NULL;
  
  mapPath = kDefaultMapPath;
    do {
        ch = getopt(argc, argv, &quot;m:&quot;);
        if (ch != -1) {
            switch (ch) {
                case 'm':
                  mapPath = optarg;
                    break;
                case '?':
                default:
                    PrintUsage();
                    exit(EXIT_FAILURE);
                    break;
            }
        }
    } while (ch != -1);
  
  argIndex = optind;

  if (argIndex == argc) {
        PrintUsage();
        exit(EXIT_FAILURE);
  }
  
  switch ( SniffFile(mapPath) ) {
    case kMacCVSPrefsFileMagicNumber:
      err = ReadMapMacCVS(mapPath, &amp;mapItems, &amp;mapItemCount);
      break;
    case kPropertyListFileMagicNumber:
      err = ReadMapXML(mapPath, &amp;mapItems, &amp;mapItemCount);
      break;
    case kFolderMagicNumber:
      err = EISDIR;
      break;
    default:
      // assuming a text file
      err = ReadMapText(mapPath, &amp;mapItems, &amp;mapItemCount);
      break;
  }
  
  if (err == 0) {
    do {
      err = CommandDecodeExecute(argv[argIndex], mapItems, mapItemCount);
      argIndex += 1;
    } while ( (err == 0) &amp;&amp; (argIndex &lt; argc) );
  }
  
  // Clean up.
  
  free(mapItems);
  
  return err;
}

/////////////////////////////////////////////////////////////////
#pragma mark ***** Main

#if MORE_DEBUG

  // The following routine was taken directly from 
  // DTS Q&amp;A 1123 &quot;Getting List of All Processes on Mac OS X&quot;.
  //
  // &lt;http://developer.apple.com/qa/qa2001/qa1123.html&gt;.
  
  typedef struct kinfo_proc kinfo_proc;

  static int GetBSDProcessList(kinfo_proc **procList, size_t *procCount)
      // Returns a list of all BSD processes on the system.  This routine
      // allocates the list and puts it in *procList and a count of the
      // number of entries in *procCount.  You are responsible for freeing
      // this list (use &quot;free&quot; from System framework).
      // On success, the function returns 0.
      // On error, the function returns a BSD errno value.
  {
      int                 err;
      kinfo_proc *        result;
      bool                done;
      static const int    name[] = { CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0 };
      // Declaring name as const requires us to cast it when passing it to
      // sysctl because the prototype doesn't include the const modifier.
      size_t              length;

      assert( procList != NULL);
      assert(*procList == NULL);
      assert(procCount != NULL);

      *procCount = 0;

      // We start by calling sysctl with result == NULL and length == 0.
      // That will succeed, and set length to the appropriate length.
      // We then allocate a buffer of that size and call sysctl again
      // with that buffer.  If that succeeds, we're done.  If that fails
      // with ENOMEM, we have to throw away our buffer and loop.  Note
      // that the loop causes use to call sysctl with NULL again; this
      // is necessary because the ENOMEM failure case sets length to
      // the amount of data returned, not the amount of data that
      // could have been returned.

      result = NULL;
      done = false;
      do {
          assert(result == NULL);

          // Call sysctl with a NULL buffer.

          length = 0;
          err = sysctl( (int *) name, (sizeof(name) / sizeof(*name)) - 1,
                        NULL, &amp;length,
                        NULL, 0);
          if (err == -1) {
              err = errno;
          }

          // Allocate an appropriately sized buffer based on the results
          // from the previous call.

          if (err == 0) {
              result = malloc(length);
              if (result == NULL) {
                  err = ENOMEM;
              }
          }

          // Call sysctl again with the new buffer.  If we get an ENOMEM
          // error, toss away our buffer and start again.

          if (err == 0) {
              err = sysctl( (int *) name, (sizeof(name) / sizeof(*name)) - 1,
                            result, &amp;length,
                            NULL, 0);
              if (err == -1) {
                  err = errno;
              }
              if (err == 0) {
                  done = true;
              } else if (err == ENOMEM) {
                  assert(result != NULL);
                  free(result);
                  result = NULL;
                  err = 0;
              }
          }
      } while (err == 0 &amp;&amp; ! done);

      // Clean up and establish post conditions.

      if (err != 0 &amp;&amp; result != NULL) {
          free(result);
          result = NULL;
      }
      *procList = result;
      if (err == 0) {
          *procCount = length / sizeof(kinfo_proc);
      }

      assert( (err == 0) == (*procList != NULL) );

      return err;
  } 

  static Boolean RunningUnderCodeWarriorDebugger(void)
    // Returns true if the program is being run under the 
    // CodeWarrior debugger.  It does this via a hacky heuristic, 
    // namely that the parent process must be GDB and the 
    // grandparent process must be &quot;LaunchCFMApp&quot;.  Getting the 
    // real name of the grandparent process is a pain 
    // (the KERN_PROCARGS just isn't easy to use) so, as 
    // this is only used for debugging, the hacky heuristic 
    // will have to do.
  {
    int      err;
    kinfo_proc *procList;
    size_t    procCount;
    size_t    procIndex;
    Boolean    result;
    pid_t    myParent;
    pid_t    myGrandParent;
    
    result = false;

    procList = NULL;
    
    err = GetBSDProcessList(&amp;procList, &amp;procCount);
    if (err == 0) {
      myParent = getppid();
      
      for (procIndex = 0; procIndex &lt; procCount; procIndex++) {
        if (procList[procIndex].kp_proc.p_pid == myParent) {
          break;
        }
      }
      
      // Our parent must exist.  OK, that's strictly speaking not 
      // true (there's race conditions aplenty), but this is just 
      // user space debugging code, so I'm happy to make the assumption 
      // for now.
      
      assert(procIndex != procCount);
      
      if ( strstr(procList[procIndex].kp_proc.p_comm, &quot;gdb&quot;) != NULL ) {
      
        myGrandParent = procList[procIndex].kp_eproc.e_ppid;
        
        for (procIndex = 0; procIndex &lt; procCount; procIndex++) {
          if (procList[procIndex].kp_proc.p_pid == myGrandParent) {
            if ( strstr(procList[procIndex].kp_proc.p_comm, &quot;LaunchCFMApp&quot;) != NULL ) {
              result = true;
            }
          }
        }
      }
    }

    free(procList);
    
    return result;
  }

  static void SynthesiseArgs(int *argcPtr, char ***argvPtr)
  {
  //  static char *gSyntheticArgs[] = { &quot;MacCVSProTool&quot;, &quot;-v&quot;, &quot;mappings-export&quot;, &quot;-x&quot;, &quot;/Volumes/CWPro8.3MIB/MoreIsBetter CVS&quot;, &quot;/Test.plist&quot; };
  //  static char *gSyntheticArgs[] = { &quot;MacCVSProTool&quot;, &quot;-v&quot;, &quot;mappings-export&quot;, &quot;/Volumes/CWPro8.3MIB/MoreIsBetter CVS&quot;, &quot;/Test.txt&quot; };
  //  static char *gSyntheticArgs[] = { &quot;MacCVSProTool&quot;, &quot;-v&quot;, &quot;mappings-import&quot;, &quot;-x&quot;, &quot;/MoreIsBetter CVS&quot;, &quot;/Test.plist&quot; };
  //  static char *gSyntheticArgs[] = { &quot;MacCVSProTool&quot;, &quot;-v&quot;, &quot;decode&quot; };
  //  static char *gSyntheticArgs[] = { &quot;MacCVSProTool&quot;, &quot;-v&quot;, &quot;decode&quot;, &quot;/PLStringFuncs.stub&quot; };
  //  static char *gSyntheticArgs[] = { &quot;MacCVSProTool&quot;, &quot;-v&quot;, &quot;decode&quot;, &quot;/PLStringFuncs1.stub&quot;, &quot;/PLStringFuncs2.stub&quot; };
  //  static char *gSyntheticArgs[] = { &quot;MacCVSProTool&quot;, &quot;-v&quot;, &quot;decode&quot;, &quot;/&quot; };
  //  static char *gSyntheticArgs[] = { &quot;MacCVSProTool&quot;, &quot;-v&quot;, &quot;decode&quot;, &quot;/MoreSetup.h&quot; };
  //  static char *gSyntheticArgs[] = { &quot;MacCVSProTool&quot;, &quot;-v&quot;, &quot;decode&quot;, &quot;-m&quot;, &quot;/Test.plist&quot;, &quot;/MoreSetup.h&quot; };
    static char *gSyntheticArgs[] = { &quot;MacCVSProTool&quot;, &quot;-v&quot;, &quot;decode&quot;, &quot;-m&quot;, &quot;/Test.txt&quot;, &quot;/MoreSetup.h&quot; };
  //  static char *gSyntheticArgs[] = { &quot;MacCVSProTool&quot;, &quot;-v&quot;, &quot;decode&quot;, &quot;/.DS_Store\r&quot; };
    
    *argvPtr = gSyntheticArgs;
    *argcPtr = sizeof(gSyntheticArgs) / sizeof(char *);
  }

#endif

static void PrintUsage(void)
{
    fprintf(stderr, 
            &quot;Usage: %s [&lt;options&gt;] &lt;command&gt; &lt;arguments&gt;\n&quot;, 
            gProgramName);
    fprintf(stderr, &quot;    Options are:\n&quot;);
    fprintf(stderr, &quot;        -v verbose mode\n&quot;);
    fprintf(stderr, &quot;    Commands are:\n&quot;);
    fprintf(stderr, &quot;        mappings-export [-x] &lt;PrefsFile&gt; &lt;ExportFile&gt;\n&quot;);
    fprintf(stderr, &quot;            -x  export as XML\n&quot;);
    fprintf(stderr, &quot;        mappings-import [-x] &lt;PrefsFile&gt; &lt;ImportFile&gt;\n&quot;);
    fprintf(stderr, &quot;            -x  import XML\n&quot;);
    fprintf(stderr, &quot;        decode [ -m &lt;PrefsFile&gt; ] &lt;File&gt;...\n&quot;);
    fprintf(stderr, &quot;            -x  Read mappings from file\n&quot;);
    fprintf(stderr, &quot;                Default is to read from '%s'\n&quot;, kDefaultMapPath);
}

int main(int argc, char **argv)
{  
  int err;
  int junk;
  int ch;
  
  gStdOut = stdout;

  #if MORE_DEBUG
    if ( RunningUnderCodeWarriorDebugger() ) {
      SynthesiseArgs(&amp;argc, &amp;argv);

      gStdOut = stderr;
    }
  #endif

    gProgramName = strrchr(argv[0], '/');
    if (gProgramName == NULL) {
        gProgramName = argv[0];
    } else {
        gProgramName += 1;
    }

  junk = MoreUNIXIgnoreSIGPIPE();
  assert(junk == 0);
  
  // Process global options.
  
    do {
        ch = getopt(argc, argv, &quot;v&quot;);
        if (ch != -1) {
            switch (ch) {
                case 'v':
                  gVerboseMode = true;
                    break;
                case '?':
                default:
                    PrintUsage();
                    exit(EXIT_FAILURE);
                    break;
            }
        }
    } while (ch != -1);

  if (optind &gt;= argc) {
    PrintUsage();
    exit(EXIT_FAILURE);
  }
  
  // Dispatch based on the command.
  
  optreset = 1;
  optind   += 1;
  if ( strcmp(argv[optind - 1], &quot;mappings-export&quot;) == 0 ) {
    err = CommandMappingsImportExport(argc, argv, false);
  } else if ( strcmp(argv[optind - 1], &quot;mappings-import&quot;) == 0 ) {
    err = CommandMappingsImportExport(argc, argv, true);
  } else if ( strcmp(argv[optind - 1], &quot;decode&quot;) == 0 ) {
    err = CommandDecode(argc, argv);
  } else {
    PrintUsage();
    exit(EXIT_FAILURE);
  }

  if (err == 0) {
    if (gVerboseMode) {
      fprintf(gStdOut, &quot;%s: Done.\n&quot;, gProgramName);
    }
    return EXIT_SUCCESS;
  } else {
    fprintf(stderr, &quot;%s: Failed with error %d.\n&quot;, gProgramName, err);
    return EXIT_FAILURE;
  }
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MoreIsBetter/listing2.html%3Fid%3DDTS10000732-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MoreIsBetter/listing2.html%3Fid%3DDTS10000732-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MoreIsBetter/listing2.html%3Fid%3DDTS10000732-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>