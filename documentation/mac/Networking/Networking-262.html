<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the Ethernet Driver(IM:N)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING262></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Networking-261.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-263.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Networking-2.html"><B>Networking</B></A> / <BR><DD><A HREF="Networking-257.html"><B>Chapter 11 - Ethernet, Token Ring, and Fiber Distributed Data Interface</B></A> / <A HREF="Networking-261.html"><B>Using Ethernet, Token Ring, and FDDI Drivers</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING262-0></A>
<H2>Using the Ethernet Driver</H2>
 You can write your own protocol stack or application that uses the Ethernet driver directly rather than going through the LAP Manager. Apple provides an .ENET <A NAME=MARKER-2-46></A>driver shell that locates and loads the driver for the selected Ethernet NuBus card. The driver shell searches the following locations for existing Ethernet driver resources, and it uses the most current one:<P>
<UL>
<LI>the system resource file
<LI>the card's declaration ROM
<LI>the motherboard's ROM<P>
</UL>
 See <I>Designing Cards and Drivers for the Macintosh Family,</I> second edition, for discussions of NuBus board IDs and slot resources.<P>
<A NAME=HEADING262-6></A>
<H3><A NAME=MARKER-9-47></A><A NAME=MARKER-21-48></A>Opening the Ethernet Driver</H3>
 <A NAME=MARKER-2-49></A>Before you use the Device Manager's <CODE>OpenSlot</CODE> function to open the .ENET driver, you <A NAME=MARKER-2-50></A>use the <CODE>SGetTypeSRsrc</CODE> function described in the Slot Manager chapter of <I><A HREF="../Devices/Devices-2.html">Inside Macintosh: Devices</A></I> to determine which NuBus slots contain Ethernet cards. To find <A NAME=MARKER-2-12></A>Ethernet NuBus cards, use the value <CODE>catNetwork</CODE> in the field <CODE>spCategory</CODE> of the <CODE>GetTypeSRsrc</CODE> function parameter block, and use the value <CODE>typeEthernet</CODE> in the field <CODE>spCType</CODE>. If you cannot find any<A NAME=MARKER-2-59></A> Ethernet NuBus cards, you should also attempt to open the .ENET0 driver in case non-NuBus Ethernet hardware is attached to the system. <BR>You should provide a user interface that allows the user to select a specific Ethernet card in the case that more than one is present.<A NAME=MARKER-2-111></A><A NAME=MARKER-2-95></A><A NAME=MARKER-2-92></A> (The chapter "Device Manager" in <I><A HREF="../Devices/Devices-2.html">Inside Macintosh: Devices</A></I> describes the <CODE>OpenSlot</CODE> function.)<P>
<DL>
<DT><B>Note</B>
<DD>This section refers to the .ENET driver shell, which facilitates multivendor support, as the .ENET driver. When you open the <BR>.ENET driver shell, it loads and opens the particular card's driver.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A HREF=#MARKER-9-56>Listing 11-1</A> illustrates how to identify and open an Ethernet driver.<P>
<B>Listing 11-1  <A NAME=MARKER-9-56></A>Finding an Ethernet card and opening the .ENET driver</B><P>
<PRE>
FUNCTION Get_And_Open_ENET_Driver: Integer;
   VAR
      mySBlk:     SpBlock;
      myPBRec:    ParamBlockRec;
      myErr:      OSErr;
      Found:      Integer;
      ENETRefNum: Integer;
      EnetStr:    Str15;
      Enet0Str:   Str15;
   
BEGIN
   Found := 0;                   {assume no sResource found}
   ENETRefNum := 0;              {indicate no driver found}
   
   WITH mySBlk DO                {set up the SpBlock}
      BEGIN
         spParamData := 1;       {include search of disabled resources }
                                 { starting searching from spSlot and }
                                 { the slots above it}
         spCategory := catNetwork;
         spCType := typeEthernet;
         spDrvrSW := 0;
         spDrvrHW := 0;
         spTBMask := 3;          {match only Category and }
                                 { CType fields}
         spSlot := 0;            {start search from here}
         spID := 0;              {start search from here}
         spExtDev := 0;          {ID of the external device}
      END;
         .
         .
      {REPEAT}
         .
      {At this point you could implement a repeat loop to check }
      { for multiple Ethernet cards. This sample uses the first card.}
         .
myErr := SGetTypeSRsrc(@mySBlk);
IF myErr = noErr THEN            {found an sResource match; }
                                 { save it for later}
   BEGIN
      Found := Found + 1;
      (SaveSInfo(@mySBlk);       {save slot info for later use}
   END;
      {until myErr = smNoMoresRsrcs;} 

 IF Found &gt; 1 THEN
   BEGIN
      {If you find more than one sResource, put up a dialog box }
      { to let the user select one. If any of the sResources }
      { that you found were disabled, let the user know that they }
      { are not available.}
      {This code sample assumes that the selected slot is }
      { returned in mySBlk.spSlot, that the corresponding }
      { sResource ID is returned in mySBlk.spID, and that Found }
      { remains &gt; 1 to indicate that it is okay to open the }
      { driver.}
   END;
   IF found &lt;&gt; 0 THEN
      BEGIN
         EnetStr := '.ENET';
         WITH myPBRec DO
            BEGIN
               ioCompletion := NIL;          {call made synchronously}
               ioNamePtr := @EnetStr;
               ioPermssn := fsCurPerm;
               ioFlags := 0;                 {reserved for driver use}
               ioSlot := mySBlk.spSlot;      {slot of Ethernet card to open}
               ioID := mySBlk.spID;          {sResource ID for slot}
            END;
         myErr := OpenSlot(@myPBRec, FALSE); 
         IF myErr = noErr THEN
         ENETRefNum := myPBRec.ioRefNum;
      END
   ELSE
      BEGIN
         Enet0Str := '.ENET0';
         myErr := OpenDriver(Enet0Str, ENETRefNum);
      END;
   IF myErr &lt;&gt; noErr THEN
      DoError(myErr); {handle the error}
   Get_And_Open_ENET_Driver := ENETRefNum;   {return the refNum or }
                                             { 0 if unsuccessful}
END;
</PRE>
<A NAME=HEADING262-12></A>
<H3><A NAME=MARKER-9-57></A>Using a Write-Data Structure to Transmit Ethernet Data</H3>
 You use <A NAME=MARKER-2-58></A>the <CODE>EWrite</CODE> function to send data to the .ENET driver for transmission over the Ethernet network. When you do this, you provide a pointer to a write-data structure containing one or more pairs of length words and pointers. (<A HREF=#MARKER-9-61>Figure 11-3</A> shows multiple pairs.) Each pair indicates the length and location of a portion of the data packet to be sent over the network. The first length-pointer pair points to a header block that is at least 14 bytes long and that starts with the destination node hardware address. Note that this is not the AppleTalk address, but is the <I>hardware</I> address of the destination node. (Note that this address can also be a multicast address or the broadcast address for the link type.) <P>
 The next 6 bytes of the header block are reserved for use by the .ENET driver. These bytes are followed by the 2-byte Ethernet protocol type field (Ethernet Phase 2 packets use this field to indicate the amount of data in the packet). Data may follow the header block; all other length-pointer pairs point to data. The write-data structure terminates with a 0 word.<P>
<DL>
<DT><B>Note</B>
<DD>Instead of using multiple buffers and length-pointer pairs, you can create a write-data structure that consists of a single buffer that specifies the header block followed directly by the data. For more information about write-data structures, see the chapter "Datagram Delivery Protocol (DDP)" in this book.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 When you first open the .ENET driver, it allocates a 768-byte buffer that it uses for transmitting data packets. This buffer is large enough to hold the largest <A NAME=MARKER-2-59></A>EtherTalk packet, which is 621 bytes in size. If you want to transmit data packets larger than 768 bytes, call the <CODE>ESetGeneral</CODE> function; the .ENET driver can then allocate a data buffer large enough to send packets up to 1514 bytes in size. <A HREF=#MARKER-9-61>Figure 11-3</A> shows the write-data structure that you use to send data to the .ENET driver. <A NAME=MARKER-2-60></A><P>
<B>Figure 11-3  <A NAME=MARKER-9-61></A><A NAME=MARKER-21-62></A>An Ethernet write-data structure</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/EN-L-01.jpg"><P>
 The sample code in <A HREF=#MARKER-9-63>Listing 11-2</A> uses a multicast address instead of a local hardware address. The multicast address is a packet array that is defined as follows:<P>
<PRE>
VAR
   gMultiCastAddr: PACKED ARRAY[0..5] OF Byte;
</PRE>
 The following procedure initializes the <CODE>gMultiCastAddr</CODE> global variable:<P>
<PRE>
PROCEDURE Init_Multicast_Address;
BEGIN
   gMultiCastAddr[1] := $09;
   gMultiCastAddr[2] := $00;
   gMultiCastAddr[3] := $2B;
   gMultiCastAddr[4] := $00;
   gMultiCastAddr[5] := $00;
   gMultiCastAddr[6] := $04;
END;
</PRE>
 The code in <A HREF=#MARKER-9-63>Listing 11-2</A> defines an Ethernet write-data structure, and then it calls the <CODE>EWrite</CODE> function to send a data packet over Ethernet. <P>
<B>Listing 11-2  <A NAME=MARKER-9-63></A><A NAME=MARKER-21-64></A>Sending a data packet over Ethernet</B><P>
<PRE>
FUNCTION Send_Sample_ENET_Packet (ENETRefNum: Integer): OSErr;
CONST
   kSIZE1 = 100;
   kSIZE2 = 333;
TYPE
   WDS = RECORD               {write-data structure}
   length:  Integer;          {length of nth entry}
   aptr:    Ptr;              {pointer to nth entry}
END;

VAR
   myWDS:   ARRAY[1..4] OF WDS;
   myPB:    EParamBlock;      {.ENET parameter block}
   wheader: PACKED ARRAY[0..13] OF Byte;
   stuff1:  ARRAY[1..kSIZE1] OF Byte;
   stuff2:  ARRAY[1..kSIZE2] OF Byte;
   myErr:   OSErr;

BEGIN
   BlockMove(@gMultiCastAddr, @wheader, 6);  {multicast address}
   wheader[12] := $90;                       {protocol type}
   wheader[13] := $90;                       {must match kProtocol value}
   myWDS[1].length := 14;
   myWDS[1].aptr := @wheader;
   myWDS[2].length := kSIZE1;
   myWDS[2].aptr := @stuff1;
   myWDS[3].length := kSIZE2;
   myWDS[3].aptr := @stuff2;
   myWDS[4].length := 0;
   myPB.ePointer := @myWDS;
   myPB.ioRefNum := ENETRefNum;

{Send something.}
   myErr := EWrite(@myPB, FALSE);   
   IF myErr &lt;&gt; noErr THEN
      DoError(myErr);
   Send_Sample_ENET_Packet := myErr;
END;
</PRE>
<A NAME=HEADING262-26></A>
<H3><A NAME=MARKER-9-65></A><A NAME=MARKER-21-66></A>Using <A NAME=MARKER-2-67></A>the Default Ethernet Protocol Handler to Read Data</H3>
 This section describes how to write an application that uses the Apple default protocol handler for Ethernet Phase 1 packets. For Ethernet Phase 2 packets, the process is largely the same, except that you must code and provide your own protocol handler and use the <A NAME=MARKER-2-68></A>LAP Manager to attach it. <P>
 <A NAME=MARKER-2-69></A>When the Ethernet NuBus card or other Ethernet hardware receives a data packet, it generates an interrupt to the CPU. The interrupt handler in ROM determines the source of the interrupt and calls the .ENET driver. The .ENET driver reads the packet header <BR>to determine the protocol type of the data packet and checks to see if any client has specified that protocol type in a call to the <CODE>EAttachPH</CODE> function. If so, the client either specified a <CODE>NIL</CODE> pointer to a protocol handler or provided its own protocol handler. If the client specified a <CODE>NIL</CODE> pointer, the .ENET driver uses its default protocol handler to read the data. If no one has specified the protocol type that the packet header contains in a call to the <CODE>EAttachPH</CODE> function, the .ENET driver discards the data. (For more informa-<BR>tion about the <CODE>EAttachPH</CODE> function, see <A HREF=Networking-271.html#MARKER-9-148>"EAttachPH" on page 11-28</A>.)<P>
 The Ethernet driver looks for a pending <CODE>ERead</CODE> function with a protocol type that matches the packet protocol type. (When you call the <CODE>ERead</CODE> function, you pass it a protocol type.) The Ethernet driver places the entire packet--including the packet header--into the buffer specified by that function. The function returns the number of bytes actually read. If the packet is larger than the data buffer, the <CODE>ERead</CODE> function places as much of the packet as will fit into the buffer and returns the <CODE>buf2SmallErr</CODE> result code.<P>
 You must call the <CODE>ERead</CODE> function asynchronously to await the next data packet. When the .ENET driver receives the data packet, it completes execution of the <CODE>ERead</CODE> function and calls your completion routine. Your completion routine should call the <CODE>ERead</CODE> function again so that an <CODE>ERead</CODE> function is always pending execution. If the .ENET driver receives a data packet with a protocol type for which you specified the default protocol handler while no <CODE>ERead</CODE> function is pending, the .ENET driver discards the packet.<P>
 You can have several asynchronous calls to the <CODE>ERead</CODE> function pending execution simultaneously as long as you use different buffers and a different parameter block <BR>for each call. <P>
 Alternatively, after the <CODE>ERead</CODE> function completes execution, you can call the function again from your completion routine, and reuse the same parameter block. This is the approach the code in <A HREF=#MARKER-9-71>Listing 11-3</A> takes. <P>
 The code in <A HREF=#MARKER-9-71>Listing 11-3</A> calls the <CODE>EAttachPH</CODE> function to specify that the .ENET driver should use the default protocol handler to process packets for the protocol type defined by the following constant:<P>
<PRE>
CONST
   kMyProtocol = $9090;             {must be &gt; $5DC}
</PRE>
 In practice, you should <A NAME=MARKER-2-171></A>call the <CODE>EAttachPH</CODE> function very early, during your program initialization sequence, if possible. As soon as the connection is established and you <BR>are expecting data, you should call the <CODE>ERead</CODE> function asynchronously. The code in <A HREF=#MARKER-9-71>Listing 11-3</A> shows how to attach a protocol handler and read a packet for an Ethernet Phase 1 packet. <P>
<B>Listing 11-3  Attaching a protocol handler and reading a packet<A NAME=MARKER-9-71></A></B><P>
<PRE>
FUNCTION Sample_AttachPH_And_Read_Packet (ENETRefNum: Integer): OSErr;
CONST
   kBigBytes = 8888;

VAR
   myPB:       MyEParamBlock;
   myEPBPtr:   MyEParamBlkPtr;
   aptr:       Ptr;
   myErr:      OSErr;

BEGIN                                  
   myEPBPtr := @myPB;                        {set up EAttachPH parameters}
   WITH myPB.pb DO
      BEGIN
         eProtType := kMyProtocol;           {protocol type}
         ePointer := NIL;                    {use default protocol handler}
         ioRefNum := ENETRefNum;             {.ENET driver reference number}
      END;
   myErr := EAttachPH(EParamBlkPtr(myEPBPtr), FALSE); 
   
   IF myErr &lt;&gt; noErr THEN                    {check if error occurred while }
      DoError(myErr)                         { attaching protocol handler}
   ELSE
      BEGIN
         aptr := NewPtr(kBigBytes);
         myPB.myA5 := SetCurrentA5;          {store the current A5 world}
         WITH myPB.pb DO
            BEGIN
               ioCompletion := @MyCompRoutine;  
                                             {ptr to completion routine}
               eProtType := kMyProtocol;     {protocol type to respond to}
               ePointer := aptr;             {pointer to read-data buffer}
               eBuffSize := kBigBytes;       {size of read-data buffer}
               ioRefNum := ENETRefNum;       {.ENET driver refNum}
            END;
         myErr := ERead(EParamBlkPtr(myEPBPtr), TRUE);
         IF myErr &lt;&gt; noErr THEN
               {check if error occurred queueing read request} 
            BEGIN
               DoError(myErr);               {process error result}
               Detach_SamplePH(ENETRefNum);  {detach protocol handler)
            END;
      END;
      Sample_AttachPH_And_Read_Packet := myErr;
    END; 
</PRE>
 When the .ENET driver receives a packet, it then calls your completion routine if you called the <CODE>ERead</CODE> function asynchronously and the <CODE>ioCompletion</CODE> routine field is not <CODE>NIL</CODE>. Your completion routine should process the packet, after which it can then queue another asynchronous call to the <CODE>ERead</CODE> function to await the next packet. <P>
 The sample completion routine that <A HREF=#MARKER-9-72>Listing 11-4</A> shows uses the following inline function that gets the pointer to the parameter block from register A0. <P>
<PRE>
FUNCTION GetParamBlockPtr: Ptr;
INLINE
   $2E88;         {MOVE.L A0,(SP)}
</PRE>
 Because register A0 is a utility register that compilers often use for their own purposes, the sample code uses the following stub completion routine technique to minimize the possibility that a compiler will overwrite the value in register A0. The stub completion routine calls <CODE>GetParamBlockPtr</CODE> and then calls the actual completion routine. <P>
<PRE>
PROCEDURE MyStubCompRoutine;
VAR
   myEPBPtr: MyEParamBlkPtr;
BEGIN
   myEPBPtr := MyEParamBlkPtr(GetParamBlockPtr); 
               {get parameter block pointer from register A0}
   myCompRoutine(myEPBPtr);
               {now call the actual completion routine}
END; 
</PRE>
 <A HREF=#MARKER-9-72>Listing 11-4</A> shows the actual completion routine that the stub completion routine calls. This completion routine reuses the original parameter block when it calls the <CODE>ERead </CODE>function again. The code also shows how to access global variables from within the completion routine. Note that if you call the <CODE>ERead</CODE> function from within the completion routine, you must call the function asynchronously. You must not call the <CODE>ERead</CODE> function synchronously at interrupt time. <P>
<B>Listing 11-4  <A NAME=MARKER-9-72></A>Completion routine to process received packet and await the next packet</B><P>
<PRE>
PROCEDURE MyCompRoutine (myEPBPtr: MyEParamBlkPtr); 
VAR
   myErr:   OSErr;
   saveA5:  LongInt;
   aptr: Ptr;

BEGIN
   saveA5 := SetA5(myEPBPtr^.myA5);    {set A5 to our world}
   IF (myEPBPtr^.pb.ioResult &lt; noErr) THEN  
                                       {was ERead successful?}
   BEGIN
      IF (myEPBPtr^.pb.ioResult &lt;&gt; reqAborted) THEN 
                                       {was request aborted?}
         DoError(myEPBPtr^.pb.ioResult)
      END
   ELSE
   BEGIN                               {process the packet}
      aptr := myEPBPtr^.pb.EPointer;
      ProcessData(aptr);               {use the data}
   END; 
IF NOT gDone THEN                      {check if we have been called}
   BEGIN                               {if not, call ERead again}
      myErr := ERead(EParamBlkPtr(myEPBPtr), TRUE);
      IF myErr &lt;&gt; noErr THEN 
         DoError(myErr);               {check if error occurred while }
                                       { queueing call to ERead}
   END;
   saveA5 := SetA5(saveA5);            {restore the A5 world}
END; {of MyCompletion routine}
</PRE>
<A NAME=HEADING262-50></A>
<H3><A NAME=MARKER-9-73></A><A NAME=MARKER-2-74></A><A NAME=MARKER-21-75></A>Using <A NAME=MARKER-2-76></A>Your Own Ethernet Protocol Handler to Read <A NAME=MARKER-2-77></A>Data<A NAME=MARKER-2-78></A></H3>
 <A NAME=MARKER-2-79></A>If a client of the .ENET driver has used the<A NAME=MARKER-2-80></A> <CODE>EAttachPH</CODE> function to <A NAME=MARKER-2-81></A>provide a pointer to its own protocol handler, the .ENET driver calls that protocol handler, which must in turn call the .ENET driver's <A NAME=MARKER-2-82></A><CODE>ReadPacket</CODE> and <A NAME=MARKER-2-83></A><CODE>ReadRest</CODE> routines to read the data. Your protocol handler calls these routines in essentially the same way as you called these routines to implement a DDP socket listener. (The chapter "Datagram Delivery Protocol [DDP]" describes how you use these routines to implement a DDP socket listener.) <P>
 The following sections describe how the .ENET driver calls a custom protocol handler and the <CODE>ReadPacket</CODE> and <CODE>ReadRest</CODE> routines.<P>
<DL>
<DT><B>Note</B>
<DD>Because an Ethernet protocol handler must read from and write to <BR>the CPU's registers, you must write the protocol handler in assembly language; you cannot write a protocol handler in Pascal.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING262-54></A>
<H4><A NAME=MARKER-21-84></A>How the .ENET Driver Calls Your Protocol Handler</H4>
 You can provide an Ethernet protocol handler for a particular protocol type and use the <CODE>EAttachPH</CODE> function to attach it to the .ENET driver. When the driver receives an Ethernet packet, it reads the packet header into an internal buffer, reads the protocol type, and calls the protocol handler for that protocol type. The CPU is in interrupt mode, and the registers are used as follows:
<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on call to Ethernet protocol handler<TR>
<TD>A0<TD>Reserved for internal use by the .ENET driver (You must preserve this register <BR>until after the <CODE>ReadRest</CODE> routine has completed execution.)<TR>
<TD>A1<TD>Reserved for internal use by the .ENET driver (You must preserve this register <BR>until after the <CODE>ReadRest</CODE> routine has completed execution.)<TR>
<TD>A2<TD>Free for your use<TR>
<TD>A3<TD>Pointer to first byte past data-link header bytes (the first byte after the 2-byte <BR>protocol-type field)<TR>
<TD>A4<TD>Pointer to the <CODE>ReadPacket</CODE> routine (The <CODE>ReadRest</CODE> routine starts 2 bytes <BR>after the start of the <CODE>ReadPacket</CODE> routine.)<TR>
<TD>A5<TD>Free for your use until after the <CODE>ReadRest</CODE> routine has completed execution<TR>
<TD>D0<TD>Free for your use<TR>
<TD>D1<TD>Number of bytes in the Ethernet packet left to be read (that is, the number of <BR>bytes following the Ethernet header)<TR>
<TD>D2<TD>Free for your use<TR>
<TD>D3<TD>Free for your use</TABLE>
<P>
 If your protocol handler processes more than one protocol type, you can read the protocol type field in the frame header to determine the protocol type of the packet. <BR>The protocol-type field starts 2 bytes before the address pointed to by the A3 register. <P>
<DL>
<DT><B>Note</B>
<DD>The source address starts 8 bytes before the address pointed to by <BR>the A3 register, and the destination address starts 14 bytes before <BR>the address pointed to by the A3 register.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 After you have called the <CODE>ReadRest</CODE> routine, you can use registers A0 through A3 and D0 through D3 for your own use, but you must preserve all other registers. You cannot depend on having access to your application global variables.<P>
<A NAME=HEADING262-59></A>
<H4><A NAME=MARKER-21-85></A>How Your Protocol Handler Calls the .ENET Driver Routines</H4>
 Your protocol handler must call the .ENET driver routines <CODE>ReadPacket</CODE> and <CODE>ReadRest</CODE> to read the incoming data packet. <P>
<DL>
<DT><B>Note</B>
<DD>Before the Ethernet driver calls your protocol handler at interrupt time, you must have already allocated memory for one or more data buffers <BR>to hold the incoming data.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 You may call the <CODE>ReadPacket</CODE> routine as many times as you like to read the data piece by piece into one or more data buffers, but you must always use the <CODE>ReadRest</CODE> routine to read the final piece of the data packet. The <CODE>ReadRest</CODE> routine restores the machine state (the stack pointers, status register, and so forth) and checks for error conditions. <P>
 Before you call the <CODE>ReadPacket</CODE> routine, you must place a pointer to the data buffer in the A3 register. You place the number of bytes you want to read in the D3 register. You must not request more bytes than remain in the data packet. <P>
 To call the <CODE>ReadPacket</CODE> routine, execute a JSR instruction to the address in the A4 register. The <CODE>ReadPacket</CODE> routine uses the registers as follows:
<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on entry to the <CODE>ReadPacket</CODE> routine<TR>
<TD>A3<TD>Pointer to a buffer to hold the data you want to read<TR>
<TD>D3<TD>Number of bytes to read; must be nonzero</TABLE>

<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on exit from the <CODE>ReadPacket</CODE> routine<TR>
<TD>A0<TD>Unchanged<TR>
<TD>A1<TD>Unchanged<TR>
<TD>A2<TD>Unchanged<TR>
<TD>A3<TD>First byte after the last byte read into buffer<TR>
<TD>D0<TD>Changed<TR>
<TD>D1<TD>Number of bytes left to be read<TR>
<TD>D2<TD>Unchanged<TR>
<TD>D3<TD>Equals 0 if requested number of bytes were read, nonzero if error</TABLE>
<P>
 The <CODE>ReadPacket</CODE> routine indicates an error by clearing to 0 the zero (<CODE>z</CODE>) flag in the status register. If the <CODE>ReadPacket</CODE> routine returns an error, you must terminate execution of your protocol handler with an RTS instruction without calling <CODE>ReadPacket</CODE> again or calling <CODE>ReadRest</CODE> at all.<P>
 Call the <CODE>ReadRest</CODE> routine to read the last portion of the data packet, or call it after you have read all the data with <CODE>ReadPacket</CODE> routines and before you do any other processing or terminate execution. You must provide in the A3 register a pointer to a data buffer and must indicate in the D3 register the size of the data buffer. If you have already read all of the data with calls to the <CODE>ReadPacket</CODE> routine, you can specify a buffer of size 0.<P>
<DL>
<DT><B>WARNING</B>
<DD>If you do not call the <CODE>ReadRest</CODE> routine after your last call to the <CODE>ReadPacket</CODE> routine, the system will crash.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To call the <CODE>ReadRest</CODE> routine, execute a JSR instruction to an address 2 bytes past the address in the A4 register. The <CODE>ReadRest</CODE> routine uses the registers as follows:
<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on entry to the <CODE>ReadRest</CODE> routine<TR>
<TD>A3<TD>Pointer to a buffer to hold the data you want to read<TR>
<TD>D3<TD>Size of the buffer (word length); may be 0</TABLE>

<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on exit from the <CODE>ReadRest</CODE> routine<TR>
<TD>A0<TD>Unchanged<TR>
<TD>A1<TD>Unchanged<TR>
<TD>A2<TD>Unchanged<TR>
<TD>A3<TD>Pointer to first byte after the last byte read into buffer<TR>
<TD>D0<TD>Changed<TR>
<TD>D1<TD>Changed<TR>
<TD>D2<TD>Unchanged<TR>
<TD>D3<TD>Equals 0 if requested number of bytes were read; less than 0 if more data was <BR>left than would fit in buffer (extra data equals -D3 bytes); greater than 0 if less data was left than the size of the buffer (extra buffer space equals D3 bytes)</TABLE>
<P>
 The <CODE>ReadRest</CODE> routine indicates an error by clearing to 0 the zero (<CODE>z</CODE>) flag in the status register.<A NAME=MARKER-2-86></A> You must<A NAME=MARKER-2-87></A> terminate execution of your protocol handler with <A NAME=MARKER-2-88></A>an RTS instruction whether or not the <CODE>ReadRest</CODE> routine <A NAME=MARKER-2-89></A>returns an e<A NAME=MARKER-2-90></A>rror.<A NAME=MARKER-2-91></A><P>
<A NAME=HEADING262-70></A>
<H3><A NAME=MARKER-9-92></A><A NAME=MARKER-21-93></A>Changing the Ethernet Hardware Address</H3>
 <A NAME=MARKER-2-94></A>Each Ethernet NuBus card or other Ethernet hardware interface device contains a unique 6-byte hardware address assigned by the manufacturer of the device. The .ENET driver normally uses this address to determine whether to receive a packet. To change the hardware address for your node, place in the System file a resource of type <CODE>'eadr'</CODE> with a resource ID equal to the slot number of the Ethernet NuBus card. <A NAME=MARKER-2-95></A><P>
 <A NAME=MARKER-2-96></A><A NAME=MARKER-2-97></A><A NAME=MARKER-2-98></A><A NAME=MARKER-2-99></A><A NAME=MARKER-2-100></A>The <A NAME=MARKER-2-101></A><CODE>'eadr'</CODE> resource consists only of a 6-byte number. Do not use the broadcast address or a multicast address for this number. (Refer to <I>Inside AppleTalk,</I> second edition, for the broadcast and multicast address formats.)<P>
 When you open the .ENET driver, it looks for an <CODE>'eadr'</CODE> resource with the resource ID that matches the slot number of the card. If it finds one, the driver substitutes the number in this resource for the Ethernet hardware address and uses it until the driver is closed or reset. <P>
<DL>
<DT><B>Note</B>
<DD>To avoid address collisions, you should never arbitrarily change the Ethernet hardware address. This feature should be used only by a system administrator who can keep track of all the Ethernet addresses <BR>in the system.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Networking-261.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-263.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Networking-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
