<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MenuScripter - /Sources/MSAESetData.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">MenuScripter</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MenuScripter</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sources/MSAESetData.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Resources/MenuScripterAETE.r</option>
<option value="listing2.html">/Sources/DebugUtils.c</option>
<option value="listing3.html">/Sources/DebugUtils.h</option>
<option value="listing4.html">/Sources/MenuScripter.r</option>
<option value="listing5.html">/Sources/MenuScripterPPC.r</option>
<option value="listing6.html">/Sources/MSAccessors.c</option>
<option value="listing7.html">/Sources/MSAccessors.h</option>
<option value="listing8.html">/Sources/MSAEClone.c</option>
<option value="listing9.html">/Sources/MSAEClone.h</option>
<option value="listing10.html">/Sources/MSAEClose.c</option>
<option value="listing11.html">/Sources/MSAEClose.h</option>
<option value="listing12.html">/Sources/MSAECoercions.c</option>
<option value="listing13.html">/Sources/MSAECoercions.h</option>
<option value="listing14.html">/Sources/MSAECompare.c</option>
<option value="listing15.html">/Sources/MSAECompare.h</option>
<option value="listing16.html">/Sources/MSAECopy.c</option>
<option value="listing17.html">/Sources/MSAECopy.h</option>
<option value="listing18.html">/Sources/MSAECountElements.c</option>
<option value="listing19.html">/Sources/MSAECountElements.h</option>
<option value="listing20.html">/Sources/MSAECreate.c</option>
<option value="listing21.html">/Sources/MSAECreate.h</option>
<option value="listing22.html">/Sources/MSAECut.c</option>
<option value="listing23.html">/Sources/MSAECut.h</option>
<option value="listing24.html">/Sources/MSAEDelete.c</option>
<option value="listing25.html">/Sources/MSAEDelete.h</option>
<option value="listing26.html">/Sources/MSAEGetData.c</option>
<option value="listing27.html">/Sources/MSAEGetData.h</option>
<option value="listing28.html">/Sources/MSAEGetDataSize.c</option>
<option value="listing29.html">/Sources/MSAEGetDataSize.h</option>
<option value="listing30.html">/Sources/MSAEMenuUtils.c</option>
<option value="listing31.html">/Sources/MSAEMenuUtils.h</option>
<option value="listing32.html">/Sources/MSAEMove.c</option>
<option value="listing33.html">/Sources/MSAEMove.h</option>
<option value="listing34.html">/Sources/MSAEObjectsExist.c</option>
<option value="listing35.html">/Sources/MSAEObjectsExist.h</option>
<option value="listing36.html">/Sources/MSAEPaste.c</option>
<option value="listing37.html">/Sources/MSAEPaste.h</option>
<option value="listing38.html">/Sources/MSAERecording.c</option>
<option value="listing39.html">/Sources/MSAERecording.h</option>
<option value="listing40.html">/Sources/MSAERevert.c</option>
<option value="listing41.html">/Sources/MSAERevert.h</option>
<option value="listing42.html">/Sources/MSAESave.c</option>
<option value="listing43.html">/Sources/MSAESave.h</option>
<option value="listing44.html">/Sources/MSAESelect.c</option>
<option value="listing45.html">/Sources/MSAESelect.h</option>
<option value="listing46.html">/Sources/MSAESetData.c</option>
<option value="listing47.html">/Sources/MSAESetData.h</option>
<option value="listing48.html">/Sources/MSAETextUtils.c</option>
<option value="listing49.html">/Sources/MSAETextUtils.h</option>
<option value="listing50.html">/Sources/MSAEUtils.c</option>
<option value="listing51.html">/Sources/MSAEUtils.h</option>
<option value="listing52.html">/Sources/MSAEWindowUtils.c</option>
<option value="listing53.html">/Sources/MSAEWindowUtils.h</option>
<option value="listing54.html">/Sources/MSAppleEvents.c</option>
<option value="listing55.html">/Sources/MSAppleEvents.h</option>
<option value="listing56.html">/Sources/MSASSubroutines.c</option>
<option value="listing57.html">/Sources/MSASSubroutines.h</option>
<option value="listing58.html">/Sources/MSDrag.c</option>
<option value="listing59.html">/Sources/MSDrag.h</option>
<option value="listing60.html">/Sources/MSFile.c</option>
<option value="listing61.html">/Sources/MSFile.h</option>
<option value="listing62.html">/Sources/MSGlobals.c</option>
<option value="listing63.html">/Sources/MSGlobals.h</option>
<option value="listing64.html">/Sources/MSGXPrinting.c</option>
<option value="listing65.html">/Sources/MSGXPrinting.h</option>
<option value="listing66.html">/Sources/MSMain.c</option>
<option value="listing67.html">/Sources/MSMain.h</option>
<option value="listing68.html">/Sources/MSResultWind.c</option>
<option value="listing69.html">/Sources/MSResultWind.h</option>
<option value="listing70.html">/Sources/MSScript.c</option>
<option value="listing71.html">/Sources/MSScript.h</option>
<option value="listing72.html">/Sources/MSToken.h</option>
<option value="listing73.html">/Sources/MSUtils.c</option>
<option value="listing74.html">/Sources/MSUtils.h</option>
<option value="listing75.html">/Sources/MSWindow.c</option>
<option value="listing76.html">/Sources/MSWindow.h</option>
<option value="listing77.html">/Sources/Offscreen.c</option>
<option value="listing78.html">/Sources/Offscreen.h</option>
<option value="listing79.html">/Sources/PLStrs.c</option>
<option value="listing80.html">/Sources/PLStrs.h</option></select>
				</p>
				</form>
				<p><strong><a href="MenuScripter.zip">Download Sample</a></strong> (&#147;MenuScripter.zip&#148;, 288.0K)<BR>
<strong><a href="MenuScripter.dmg">Download Sample</a></strong> (&#147;MenuScripter.dmg&#148;, 355.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">// MSAESetData.c//// Original version by Jon Lansdell and Nigel Humphreys.// 4.0 and 3.1 updates by Greg Sutton.// &copy;Apple Computer Inc 1996, all rights reserved./*    Changes for 4.0    29-Feb-96 : GS : Added abiltiy to set properties from menus and menu items.    29-Feb-96 : GS : Added script properties to application and document objects.*/#include &quot;MSAESetData.h&quot;#include &quot;MSWindow.h&quot;#include &quot;MSGlobals.h&quot;#include &quot;MSAEUtils.h&quot;#include &quot;MSAETextUtils.h&quot;#include &quot;MSAEWindowUtils.h&quot;#include &quot;MSAEMenuUtils.h&quot;#include &quot;MSAppleEvents.h&quot;#include &quot;MSAESelect.h&quot;#include &quot;MSScript.h&quot;#include &quot;MSAECreate.h&quot;#ifdef THINK_C  #include &quot;PLStrs.h&quot;#else  #include &lt;PLStringFuncs.h&gt;#endif#include &lt;string.h&gt;  // Prototypesvoid  SendwCalcRgnsToWind( WindowPtr wP );// --------------------------------------------------------------------------//  Name:       DoSetData//  Purpose:    Handles the SetData Apple Event, extracting the direct//          object (which says what to set) and the data (what to set//          it to).// --------------------------------------------------------------------------   pascal OSErr  DoSetData(const AppleEvent  *theAppleEvent,                AppleEvent  *reply,                long    handlerRefCon){#ifdef __MWERKS__  #pragma unused (reply, handlerRefCon)#endif    AEDesc   directObj = {typeNull, NULL},      dataDesc = {typeNull, NULL};  OSErr    err;          // pick up the direct object, which is the object whose data is to be set  err = AEGetParamDesc(theAppleEvent,  keyDirectObject,                  typeWildCard, &amp;directObj);  if (noErr != err) goto done;        // now the data to set it to - typeWildCard means get as is    // e.g. this is the name of the font for text  err = AEGetParamDesc(theAppleEvent, keyAEData, typeWildCard, &amp;dataDesc);  if (noErr != err) goto done;      // missing any parameters?  err = GotRequiredParams(theAppleEvent);  if (noErr != err) goto done;      // set the data  err = HandleSetData(&amp;directObj, &amp;dataDesc);done:        (void)AEDisposeDesc(&amp;directObj);  (void)AEDisposeDesc(&amp;dataDesc);  return(err);}  // DoSetData// ---------------------------------------------------------------------------//    Name:       HandleSetData//    Purpose:    Resolves the object into a token (could be one of //            many) andthe sets the data of that object to dataDesc.// ---------------------------------------------------------------------------   OSErr HandleSetData(const AEDesc *theObj, AEDesc *dataDesc){  TextToken       theTextToken;  Size            tokenSize;  AEDesc          objTokenDesc = {typeNull, NULL},          itemDesc = {typeNull, NULL},          ignoreResult = {typeNull, NULL};  long      index;  DescType    returnedType;  OSErr           err;    //  Coerce theObj into a token which we can use -     //   set the property or data for that token  if ( typeObjectSpecifier == theObj-&gt;descriptorType )    err = AEResolve( theObj, kAEIDoMinimum, &amp;objTokenDesc );  else if ( typeNull != theObj-&gt;descriptorType )  // Otherwise, just copy it    err = AEDuplicateDesc( theObj, &amp;objTokenDesc );  if (noErr != err) goto done;        switch (objTokenDesc.descriptorType)  {    case typeMyApplProp:      err = SetApplicationProperty( &amp;objTokenDesc, dataDesc );      break;      case typeMyWindowProp:      err = SetWindowProperty(&amp;objTokenDesc, dataDesc);      break;        case typeMyDocumentProp:      err = SetDocumentProperty(&amp;objTokenDesc, dataDesc);      break;          case typeMyMenuProp:      err = SetMenuProperty( &amp;objTokenDesc, dataDesc );      break;          case typeMyMenuItemProp:      err = SetMenuItemProperty( &amp;objTokenDesc, dataDesc );      break;        case typeMyTextProp:      err = SetTextProperty(&amp;objTokenDesc, dataDesc);      break;          case typeMyText:      GetRawDataFromDescriptor(&amp;objTokenDesc,  (Ptr)&amp;theTextToken,                      sizeof(theTextToken), &amp;tokenSize);                  // itemDesc is a null descriptor here      err = CreateAtTextToken(cText, dataDesc, &amp;theTextToken,                          &amp;itemDesc, &amp;ignoreResult);      break;    case typeAEList:        // If it's a list then do each item      err = AECountItems(&amp;objTokenDesc, &amp;index);      if (noErr != err) goto done;      for (; index &gt; 0; index--)      {        err = AEGetNthDesc(&amp;objTokenDesc, index, typeWildCard, &amp;returnedType, &amp;itemDesc);        if (noErr == err)    // Get property by calling this function again          err = HandleSetData(&amp;itemDesc, dataDesc);                if (itemDesc.dataHandle)          AEDisposeDesc(&amp;itemDesc);      }      break;          default:      err = errAEWrongDataType;  }done:  (void)AEDisposeDesc( &amp;objTokenDesc );  (void)AEDisposeDesc( &amp;itemDesc );  (void)AEDisposeDesc( &amp;ignoreResult );  return err;} // HandleSetDataOSErr  SetApplicationProperty( const AEDesc *theTokenDesc, const AEDesc *dataDesc ){  AppPropToken  aToken;  AEDesc          aDesc = {typeNull, NULL};  Size            tokenSize;  OSErr           err;  err = AECoerceDesc( theTokenDesc, typeMyApplProp, &amp;aDesc );  if (noErr != err) goto done;  GetRawDataFromDescriptor( &amp;aDesc, (Ptr)&amp;aToken,                  sizeof( aToken ), &amp;tokenSize );    SetApplicationTokenProperty( &amp;aToken, dataDesc );  done:  (void)AEDisposeDesc(&amp;aDesc);    return(err);} // SetApplicationPropertyOSErr  SetApplicationTokenProperty( AppPropToken* theToken, const AEDesc *dataDesc ){  OSErr           err;    switch ( theToken-&gt;tokenProperty )  {    case pScript:      err = SetScriptDesc( dataDesc, &amp;gAppRec.theScriptID );      break;      default:        err = errAEEventNotHandled;  }    return err;}OSErr  SetWindowSelectionProperty(WindowPtr theWindow, const AEDesc *dataDesc){  AEDesc    textDesc = {typeNull, NULL},        ignoreResult = {typeNull, NULL};  TextToken  aTextToken;  Size    actualSize;  short    ignore;  OSErr    err;        // first check to see if we are dealing with a TEXT descriptor or  // an object specifier. Since AECoerceDesc will end up calling  // AEResolve, we don't want to call this if the user entered something    // like 'Set selection of window 1 to &quot;some text&quot;  switch (dataDesc-&gt;descriptorType)  {    case typeChar:    case typeIntlText:    case typeStyledText:      err = GetWindowSelection(theWindow, &amp;aTextToken, &amp;ignore);      if (noErr != err) goto done;            // textDesc is a null descriptor here      err = CreateAtTextToken(cText, dataDesc, &amp;aTextToken,                          &amp;textDesc, &amp;ignoreResult);      break;          default:   // we are dealing with an object specifier      err = AECoerceDesc(dataDesc, typeMyText, &amp;textDesc);      if (noErr != err) goto done;            GetRawDataFromDescriptor(&amp;textDesc, (Ptr)&amp;aTextToken, sizeof(aTextToken),                      &amp;actualSize);                            SelectTextToken(&amp;aTextToken);  }done:  (void)AEDisposeDesc(&amp;textDesc);  return(err);}void  SendwCalcRgnsToWind( WindowPtr wP ){// This forces a wCalcRgns message to be sent to the windows proc!! Ughhhhhhh.....    Handle                  h;    long                    param = 0;    SInt8                   hState;    h = (*(WindowPeek)wP).windowDefProc;    hState = HGetState(h);    HLock(h);       // paranoia?    CallWindowDefProc((WindowDefProcPtr)*h, documentProc, wP, wCalcRgns, param);    HSetState(h, hState);}OSErr  SetWindowProperty( const AEDesc *theTokenDesc, const AEDesc *dataDesc ){  WindowPropToken theWindowPropToken;  AEDesc          aDesc = {typeNull, NULL};  Size      tokenSize;  OSErr      err;  err = AECoerceDesc( theTokenDesc, typeMyWindowProp, &amp;aDesc );  if (noErr != err) goto done;  GetRawDataFromDescriptor( &amp;aDesc, (Ptr)&amp;theWindowPropToken,                  sizeof(theWindowPropToken), &amp;tokenSize );                    err = SetWindowTokenProperty( &amp;theWindowPropToken, dataDesc );done:  (void)AEDisposeDesc( &amp;aDesc );  return err;}// ------------------------------------------------------------------------//  Name:     SetWindowTokenProperty//  Purpose:  Sets the window property specified in theToken to//        be that supplied in dataDesc.// ------------------------------------------------------------------------OSErr  SetWindowTokenProperty( WindowPropToken* theToken, const AEDesc* theData ){  Rect    aRect,        strucRect,        contRect;  Boolean    aBoolean;  Str255    aString;  long    aLong;  GrafPtr    aPort;  WindowPeek  aWindowPeek;  OSErr    err = noErr;    switch (theToken-&gt;tokenProperty)  {    case pBounds:      err = GetRectFromDescriptor( theData, &amp;aRect );      if ( noErr != err ) goto done;            err = GetWindowBounds( theToken-&gt;tokenWindowToken.tokenWindow, &amp;strucRect );        // Don't set bounds if they're the same as before      if ( noErr != err || EqualRect( &amp;aRect, &amp;strucRect ) ) goto done;            aWindowPeek = (WindowPeek)theToken-&gt;tokenWindowToken.tokenWindow;      aBoolean = IsVisible( theToken-&gt;tokenWindowToken.tokenWindow );      if ( ! aBoolean )        SendwCalcRgnsToWind( theToken-&gt;tokenWindowToken.tokenWindow );            strucRect = (*aWindowPeek-&gt;strucRgn)-&gt;rgnBBox;      contRect = (*aWindowPeek-&gt;contRgn)-&gt;rgnBBox;      // the rectangle is for the structure region, and is in global coordinates      // MoveWindow and SizeWindow apply to the content region, so we have to massage a little      aRect.top    += contRect.top - strucRect.top;      aRect.left   += contRect.left - strucRect.left;      aRect.bottom -= strucRect.bottom - contRect.bottom;      aRect.right  -= strucRect.right - contRect.right;            if ( EmptyRect( &amp;aRect ) )         err = errAECorruptData;      else      {        if ( aBoolean )    // IsVisible        {          MoveWindow( theToken-&gt;tokenWindowToken.tokenWindow,                     aRect.left,                     aRect.top,                     false );          SizeWindow( theToken-&gt;tokenWindowToken.tokenWindow,                     aRect.right - aRect.left,                     aRect.bottom - aRect.top,                     true );        }        else        {      // Move offscreen first          MoveWindow( theToken-&gt;tokenWindowToken.tokenWindow,                     10000,                     10000,                     false );              // Encapsulate the resizing in Show then Hide          ShowWindow( theToken-&gt;tokenWindowToken.tokenWindow );          SizeWindow( theToken-&gt;tokenWindowToken.tokenWindow,                     aRect.right - aRect.left,                     aRect.bottom - aRect.top,                     true );          HideWindow( theToken-&gt;tokenWindowToken.tokenWindow );              // Move it to the proper place          MoveWindow( theToken-&gt;tokenWindowToken.tokenWindow,                     aRect.left,                     aRect.top,                     false );        }        GetPort( &amp;aPort );        SetPort( theToken-&gt;tokenWindowToken.tokenWindow );        ResizeWindow( DPtrFromWindowPtr( theToken-&gt;tokenWindowToken.tokenWindow ) );        SetPort( aPort );      }      break;    case pVisible:      err = GetBooleanFromDescriptor(theData, &amp;aBoolean);      if (noErr != err) goto done;      if (aBoolean)        ShowMSWindow(theToken-&gt;tokenWindowToken.tokenWindow);      else        HideMSWindow(theToken-&gt;tokenWindowToken.tokenWindow);      break;    case pIsZoomed:      GetPort( &amp;aPort );      SetPort( theToken-&gt;tokenWindowToken.tokenWindow );      err = GetBooleanFromDescriptor( theData, &amp;aBoolean );      if ( aBoolean )        ZoomWindow( qd.thePort, inZoomOut, false );      else        ZoomWindow( qd.thePort, inZoomIn, false );                                 ResizeWindow( DPtrFromWindowPtr( theToken-&gt;tokenWindowToken.tokenWindow ) );      SetPort( aPort );      break;    case pName:      err = GetPStringFromDescriptor(theData, aString);      if (noErr != err) goto done;            SetWTitle(theToken-&gt;tokenWindowToken.tokenWindow, aString);      break;          case pIndex:      err = GetLongIntFromDescriptor(theData, &amp;aLong);      if (noErr != err) goto done;            SetWindowIndex( theToken-&gt;tokenWindowToken.tokenWindow, aLong );      break;    case pBestType:    case pClass:    case pDefaultType:    case pHasCloseBox:    case pIsZoomable:      err = errAEEventNotHandled;      break;          default:      err = errAEEventNotHandled;  }done:    return(err);}OSErr  SetDocumentProperty( const AEDesc *theTokenDesc, const AEDesc *dataDesc ){  WindowPropToken theWindowPropToken;  AEDesc          aDesc = {typeNull, NULL};  Size            tokenSize;  OSErr           err;  err = AECoerceDesc( theTokenDesc, typeMyDocumentProp, &amp;aDesc );  if (noErr != err) goto done;  GetRawDataFromDescriptor( &amp;aDesc, (Ptr)&amp;theWindowPropToken,                  sizeof(theWindowPropToken), &amp;tokenSize );    SetDocumentTokenProperty( &amp;theWindowPropToken, dataDesc );  done:  (void)AEDisposeDesc(&amp;aDesc);    return(err);} // SetDocumentPropertyOSErr  SetDocumentTokenProperty( WindowPropToken* theToken, const AEDesc *dataDesc ){  Str255          aPStr;  DPtr            theDocument;  THPrint         theTHPrint;  TextToken    aTextToken;  Boolean      aBoolean;  AEDesc      nullDesc = {typeNull, NULL},          aDesc = {typeNull, NULL};  Handle          hGXJobData;  OSErr           err = noErr;    theDocument = DPtrFromWindowPtr( theToken-&gt;tokenWindowToken.tokenWindow );    switch ( theToken-&gt;tokenProperty )  {    case pName:      err = GetPStringFromDescriptor( dataDesc, aPStr );      if (noErr != err) goto done;      if ( aPStr[0] == 0)         err = errAEWrongDataType;      else      {        SetWTitle( theToken-&gt;tokenWindowToken.tokenWindow, aPStr );        PLstrcpy( theDocument-&gt;theFileName, aPStr ); // Should we do this???      }      break;    case pText:    case pContents:              // Get whole window as place to insert data      err = TextTokenFromDocumentToken(&amp;(theToken-&gt;tokenWindowToken), &amp;aTextToken);      if (noErr != err) goto done;      err = CreateAtTextToken( cText, dataDesc, &amp;aTextToken,                          &amp;nullDesc, &amp;aDesc );      break;    case pIsModified:      err = GetBooleanFromDescriptor( dataDesc, &amp;aBoolean );      if (noErr != err) goto done;          theDocument-&gt;dirty = aBoolean;      goto done;  // Don't set dirty flag again          case pPageSetup:      if ( ! gGXIsPresent )      {        err = GetTHPrintFromDescriptor(dataDesc, &amp;theTHPrint);                  if (theTHPrint)         {          if (theDocument-&gt;thePrintSetup)             DisposHandle((Handle)theDocument-&gt;thePrintSetup);                      theDocument-&gt;thePrintSetup = theTHPrint;                    ResizePageSetupForDocument(theDocument);        }      }      else        err = errAEEventNotHandled;                 break;          case pGXPageSetup:      if ( gGXIsPresent )      {        err = AECoerceDesc(dataDesc,typeTGXPrint,&amp;aDesc);          hGXJobData = nil;          if (err==noErr)         {          hGXJobData = NewHandle(GetHandleSize(aDesc.dataHandle));            BlockMove(*(aDesc.dataHandle),                    *hGXJobData,                    GetHandleSize(aDesc.dataHandle));        }                  if (hGXJobData)         {          GXUnflattenJobFromHdl(theDocument-&gt;documentJob, hGXJobData);          err = GXGetJobError(theDocument-&gt;documentJob);                    ResizePageSetupForDocument(theDocument);        }      }      else        err = errAEEventNotHandled;                 break;          case pSelection:      err = SetWindowSelectionProperty(theToken-&gt;tokenWindowToken.tokenWindow, dataDesc);      break;      case pScript:      err = SetScriptDesc( dataDesc, &amp;theDocument-&gt;theScriptID );      break;    default:        err = SetWindowTokenProperty( theToken, dataDesc );  }    if ( noErr == err &amp;&amp; pIsModified != theToken-&gt;tokenProperty)    theDocument-&gt;dirty = true;  done:  (void)AEDisposeDesc( &amp;nullDesc );  (void)AEDisposeDesc( &amp;aDesc );    return(err);}OSErr  GetTHPrintFromDescriptor(const AEDesc *sourceDesc, THPrint *result){  Size    ptSize;  AEDesc  resultDesc;  OSErr   err;    *result = NULL;    err = AECoerceDesc(sourceDesc, typeTPrint, &amp;resultDesc);  if (noErr != err) goto done;    *result = (THPrint)NewHandle(sizeof(TPrint));    PrOpen();  PrintDefault(*result);    HLock((Handle)*result);  GetRawDataFromDescriptor(&amp;resultDesc, (Ptr)**result, sizeof(TPrint), &amp;ptSize);  HUnlock((Handle)*result);    if ((ptSize&lt;sizeof(TPrint)) || (PrValidate(*result)))  {    err = errAECoercionFail;    DisposHandle((Handle)*result);    *result = NULL;  }    PrClose();done:    if (resultDesc.dataHandle)     AEDisposeDesc(&amp;resultDesc);      return(err);} // GetTHPrintFromDescriptorOSErr  SetMenuProperty( const AEDesc *theTokenDesc, const AEDesc *dataDesc ){  MenuPropToken  aToken;  Size      tokenSize;  OSErr      err;  if ( typeMyMenuProp != theTokenDesc-&gt;descriptorType )    return errAEWrongDataType;  GetRawDataFromDescriptor( theTokenDesc, (Ptr)&amp;aToken,                  sizeof( aToken ), &amp;tokenSize );                    err = SetMenuTokenProperty( &amp;aToken, dataDesc );  return err;}OSErr  SetMenuTokenProperty( MenuPropToken* theToken, const AEDesc* theData ){  MenuScriptRecPtr  aMenuRecPtr;  OSErr        err;    switch ( theToken-&gt;tokenProperty )  {    case pScript:      aMenuRecPtr = GetMenuScriptRecPtr( theToken-&gt;token.tokenID * 32 );      if ( ! aMenuRecPtr || kOSANullScript == aMenuRecPtr-&gt;theScriptID )      {        err = errAENoSuchObject;        goto done;      }          err = SetScriptDesc( theData, &amp;aMenuRecPtr-&gt;theScriptID );      if ( noErr == err )        aMenuRecPtr-&gt;fChanged = true;      break;          default:      err = errAEEventNotHandled;  }done:    return(err);}OSErr  SetMenuItemProperty( const AEDesc *theTokenDesc, const AEDesc *dataDesc ){  MenuItemPropToken  aToken;  Size        tokenSize;  OSErr        err;  if ( typeMyMenuItemProp != theTokenDesc-&gt;descriptorType )    return errAEWrongDataType;  GetRawDataFromDescriptor( theTokenDesc, (Ptr)&amp;aToken,                  sizeof( aToken ), &amp;tokenSize );                    err = SetMenuItemTokenProperty( &amp;aToken, dataDesc );  return err;}OSErr  SetMenuItemTokenProperty( MenuItemPropToken* theToken, const AEDesc* theData ){  AEDesc        aDesc = { typeNull, NULL };  MenuScriptRecPtr  aMenuRecPtr;  Str255        aPStr;  short        aResID;  OSErr        err;  aResID = theToken-&gt;token.tokenMenuToken.tokenID * 32 + theToken-&gt;token.tokenItem;  aMenuRecPtr = GetMenuScriptRecPtr( aResID );    switch ( theToken-&gt;tokenProperty )  {    case pName:      err = GetPStringFromDescriptor( theData, aPStr );      if ( noErr != err ) goto done;            SetMenuItemName( &amp;theToken-&gt;token, aPStr );              // If there is a script associated then try setting the        // itemName property.      if ( aMenuRecPtr &amp;&amp; kOSANullScript != aMenuRecPtr-&gt;theScriptID )      {        err = PutPStringToDescriptor( &amp;aDesc, &quot;\pitemname&quot; );        if ( noErr != err ) goto done;                // Ignore the error because it may not have the property        (void)SetScriptProperty( aMenuRecPtr-&gt;theScriptID, &amp;aDesc, theData );      }      break;      case pScript:      if ( ! aMenuRecPtr || kOSANullScript == aMenuRecPtr-&gt;theScriptID )      {        err = errAENoSuchObject;        goto done;      }          err = SetScriptDesc( theData, &amp;aMenuRecPtr-&gt;theScriptID );      if ( noErr == err )      {        aMenuRecPtr-&gt;fChanged = true;        err = CheckForMenuItemName( aResID, aMenuRecPtr-&gt;theScriptID );      }      break;          default:      err = errAEEventNotHandled;  }done:  (void)AEDisposeDesc( &amp;aDesc );    return(err);}OSErr  CheckForMenuItemName( short theResID, OSAID theOSAID ){  AEDesc    aDesc = { typeNull, NULL },        aNameDesc = { typeNull, NULL };  Str255    aPStr;  OSErr    anErr;    anErr = PutPStringToDescriptor( &amp;aDesc, &quot;\pitemname&quot; );  if ( noErr != anErr ) goto done;  anErr = GetScriptProperty( theOSAID, &amp;aDesc, &amp;aNameDesc );  if ( noErr == anErr )  {    anErr = GetPStringFromDescriptor( &amp;aNameDesc, aPStr );    if ( noErr != anErr ) goto done;      SetMenuItemText( MenuHandleFromMenuID( theResID / 32 ), theResID % 32, aPStr );  }  else    anErr = noErr;  // Just doesn't have the property so no errordone:    return anErr;}// ----------------------------------------------------------------------//  Name:     SetTextProperty//  Purpose:  Sets the text property specfied by theTextPropToken to//        that in dataDesc.// ----------------------------------------------------------------------   OSErr  SetTextProperty(const AEDesc *tokenDesc, const AEDesc *dataDesc){  DPtr            theDoc;  Str255          name;  short           theSize;  Style           onStyle;  Style           offStyle;  TextPropToken   theTextPropToken;  AEDesc          newDesc = {typeNull, NULL},          nullDesc = {typeNull, NULL},          ignoreResult = {typeNull, NULL};  Size            tokenSize;  OSErr           err;    err = AECoerceDesc(tokenDesc, typeMyTextProp, &amp;newDesc);    if (noErr != err) goto done;  GetRawDataFromDescriptor(&amp;newDesc, (Ptr)&amp;theTextPropToken,                  sizeof(theTextPropToken), &amp;tokenSize);      theDoc = DPtrFromWindowPtr(theTextPropToken.tokenTextToken.tokenWindow);  theDoc-&gt;dirty = true;    switch (theTextPropToken.tokenProperty)  {    case pText:    case pContents:      err = CreateAtTextToken(cText, dataDesc, &amp;(theTextPropToken.tokenTextToken),                                &amp;nullDesc, &amp;ignoreResult);      break;          case pFont:      err = GetPStringFromDescriptor(dataDesc, name);      if (noErr != err) goto done;      err = SetFontOfTextToken(&amp;theTextPropToken.tokenTextToken, name);      break;          case pPointSize:        err = GetIntegerFromDescriptor(dataDesc, &amp;theSize);      if (noErr != err) goto done;      err = SetSizeOfTextToken(&amp;theTextPropToken.tokenTextToken, theSize);      break;          case pTextStyles:      onStyle  = 0;      offStyle = 0;            err = GetTextStyles(dataDesc, &amp;onStyle, &amp;offStyle);      if (noErr != err) goto done;        if (onStyle &amp; offStyle != 0)        err = errAEEventFailed;      else        err = SetStyleOfTextToken(&amp;theTextPropToken.tokenTextToken, onStyle, offStyle);      break;        default:      err = errAEWrongDataType;  }done:  (void)AEDisposeDesc(&amp;newDesc);        return(err);} // SetTextProperty  short ItemForNamedFont(Str255 theName){  Str255  itemName;  short   limit;  limit = CountMItems(myMenus[fontM]);  while (limit&gt;0)  {    GetItem(myMenus[fontM],limit, itemName);    if (IUEqualString(theName, itemName)==0)       return(limit);    else      limit--;  }  return(0);} // ItemForNamedFont// -----------------------------------------------------------------------//  Name:     SetFontOfTextToken//  Purpose:  Sets the font of the text specified by theToken to //        the font in name.// -----------------------------------------------------------------------   OSErr  SetFontOfTextToken(TextToken* theToken, Str255 name){  DPtr    docPtr;  TextToken  oldSelection;  short    theNumber,        theItem;  TextStyle  newStyle;  Boolean    fCurrentSelection;  OSErr    err;  docPtr = DPtrFromWindowPtr(theToken-&gt;tokenWindow);    if (!docPtr) return(errAENoSuchObject);            // ignore theNumber result  err = GetWindowSelection(theToken-&gt;tokenWindow, &amp;oldSelection, &amp;theNumber);  if (noErr != err) goto done;    if (memcmp(theToken, &amp;oldSelection, sizeof(TextToken)))  {    fCurrentSelection = false;    err = SelectTextToken(theToken);  // Only set the selection if it's different    if (noErr != err) goto done;  }  else    fCurrentSelection = true;        GetFNum(name, &amp;theNumber);    theItem = ItemForNamedFont(name); // returns 0 if failed - i.e. SystemFont    if (gFontMItem)    CheckItem(myMenus[fontM], gFontMItem, false);    gFontMItem = theItem;  CheckItem(myMenus[fontM], gFontMItem, true);    docPtr-&gt;theFont = theNumber;      newStyle.tsFont = theNumber;  TESetStyle(doFont, &amp;newStyle, true, docPtr-&gt;theText);     AdjustScrollbars(docPtr, false);  DrawPageExtras(docPtr);  docPtr-&gt;dirty = true;    if (! fCurrentSelection)    err = SelectTextToken(&amp;oldSelection);done:    return(err);} // SetFontOfTextToken  // -----------------------------------------------------------------------//  Name:       SetSizeOfTextToken//  Purpose:    Sets the size of the text specified by theToken to //          the size in theSize.// -----------------------------------------------------------------------   OSErr  SetSizeOfTextToken(TextToken* theToken, short theSize){  DPtr    docPtr;  TextToken  oldSelection;  TextStyle  newStyle;  short    ignore;  Boolean    fCurrentSelection;  OSErr    err;  docPtr = DPtrFromWindowPtr(theToken-&gt;tokenWindow);    if (!docPtr) return(errAENoSuchObject);            // Save the old selection  err = GetWindowSelection(theToken-&gt;tokenWindow, &amp;oldSelection, &amp;ignore);  if (noErr != err) goto done;    if (memcmp(theToken, &amp;oldSelection, sizeof(TextToken)))  {    fCurrentSelection = false;    err = SelectTextToken(theToken);    if (noErr != err) goto done;  }  else    fCurrentSelection = true;                docPtr-&gt;theSize = theSize;    newStyle.tsSize = theSize;  TESetStyle(doSize, &amp;newStyle, true, docPtr-&gt;theText);     AdjustScrollbars(docPtr, false);  DrawPageExtras(docPtr);  docPtr-&gt;dirty = true;    if (! fCurrentSelection)  // If we reset the selection we may loose the    err = SelectTextToken(&amp;oldSelection);  // Size or style just setdone:    return(err);} // SetSizeOfTextToken  // ------------------------------------------------------------------------//  Name:       SetStyleOfTextToken//  Purpose:    Sets the style of the text specified by theToken to //          the style in theStyle.// ------------------------------------------------------------------------   OSErr  SetStyleOfTextToken(TextToken* theToken, Style onStyle, Style offStyle){  DPtr    docPtr;  TextToken  oldSelection;  TextStyle  newStyle;  short    mode;  Boolean    wasContinuous;  short    ignore;  Boolean    fCurrentSelection;  OSErr    err;  docPtr = DPtrFromWindowPtr(theToken-&gt;tokenWindow);    if (!docPtr) return(errAENoSuchObject);            // Save the old selection  err = GetWindowSelection(theToken-&gt;tokenWindow, &amp;oldSelection, &amp;ignore);  if (noErr != err) goto done;    if (memcmp(theToken, &amp;oldSelection, sizeof(TextToken)))  {    fCurrentSelection = false;    err = SelectTextToken(theToken);    if (noErr != err) goto done;  }  else    fCurrentSelection = true;                docPtr-&gt;theStyle = onStyle;      // Check to see if off styles are on for whole selection  mode = doFace;    wasContinuous = TEContinuousStyle(&amp;mode, &amp;newStyle, docPtr-&gt;theText);  if ((newStyle.tsFace &amp; offStyle) != offStyle) // not off styles are on for all  {      // switch on across board so that toggle off will clear all    newStyle.tsFace  = offStyle - (newStyle.tsFace &amp; offStyle);    TESetStyle(doFace+doToggle, &amp;newStyle, false, docPtr-&gt;theText);   }      newStyle.tsFace  = offStyle;  TESetStyle(doFace+doToggle, &amp;newStyle,(onStyle==0), docPtr-&gt;theText); // toggle all to off    mode = doFace;  if (onStyle)  {    wasContinuous = TEContinuousStyle(&amp;mode, &amp;newStyle, docPtr-&gt;theText);    if ((newStyle.tsFace &amp; onStyle) != onStyle) // are they on for only a few chars    {         // Need to make all chars have these characteristics      newStyle.tsFace = onStyle - (newStyle.tsFace &amp; onStyle); // take out those continuous      TESetStyle(doFace+doToggle, &amp;newStyle, true, docPtr-&gt;theText);    }    else      TESetStyle(0, &amp;newStyle, true, docPtr-&gt;theText); // Just Draw it, no changes  }      AdjustScrollbars(docPtr, false);  DrawPageExtras(docPtr);  docPtr-&gt;dirty = true;    if (! fCurrentSelection)    err = SelectTextToken(&amp;oldSelection);done:    return(err);} // SetStyleOfTextToken  OSErr  GetTextStyles(const AEDesc *dataDesc, Style *onStyles, Style *offStyles){  OSErr      myErr;  AEDescList textSDesc = { typeNull, NULL };  AEDescList onDesc = { typeNull, NULL };  AEDescList offDesc = { typeNull, NULL };  Boolean    hadPlain;    *onStyles  = 0;  *offStyles = 0;    myErr = AECoerceDesc(dataDesc, typeAERecord, &amp;textSDesc);    if (myErr==noErr)    myErr = AEGetKeyDesc(&amp;textSDesc, keyAEOnStyles, typeAEList, &amp;onDesc);    if (myErr==noErr)    myErr = AEGetKeyDesc(&amp;textSDesc, keyAEOffStyles, typeAEList, &amp;offDesc);    if (myErr==noErr)    myErr = MakeStyleFromAEList(&amp;onDesc,  onStyles, &amp;hadPlain);    if (hadPlain)    *offStyles = bold+italic+underline+outline+shadow+condense+extend;  else  {    if (myErr==noErr)      myErr = MakeStyleFromAEList(&amp;offDesc, offStyles, &amp;hadPlain);        if (hadPlain)      myErr = errAEEventFailed;  }      (void)AEDisposeDesc(&amp;textSDesc);  (void)AEDisposeDesc(&amp;onDesc);  (void)AEDisposeDesc(&amp;offDesc);    return(myErr);} // GetTextStyles// -----------------------------------------------------------------------//  Name:     AddDescStyleItem//  Purpose:  Adds the kAEXXXX style to theStyle.// -----------------------------------------------------------------------   void  AddDescStyleItem(DescType theDesc, Style *theStyle){  if (theDesc == kAEBold)    *theStyle = *theStyle+bold;  else  if (theDesc == kAEItalic)    *theStyle = *theStyle+italic;  else  if (theDesc == kAEUnderline)    *theStyle = *theStyle+underline;  else  if (theDesc == kAEOutline)    *theStyle = *theStyle+outline;  else  if (theDesc == kAEShadow)    *theStyle = *theStyle+shadow;  else  if (theDesc == kAECondensed)    *theStyle = *theStyle+condense;  else  if (theDesc == kAEExpanded)    *theStyle = *theStyle+extend;  else  if (theDesc == kAEPlain)    *theStyle = 0;} // AddDescStyleItem  OSErr  MakeStyleFromAEList(const AEDescList *styleList, Style *theStyle, Boolean *hadPlain){  OSErr     myErr;  DescType  styleDesc;  long      itemsInList;  long      actSize;  AEKeyword keywd;  DescType  typeCode;      *hadPlain = false;  *theStyle = 0;    myErr = AECountItems(styleList, &amp;itemsInList);  while (itemsInList&gt;0)    if (myErr==noErr)    {      myErr  = AEGetNthPtr(styleList, itemsInList, typeEnumerated, &amp;keywd,                &amp;typeCode, (Ptr)&amp;styleDesc, sizeof(styleDesc), &amp;actSize);            AddDescStyleItem(styleDesc, theStyle);            if (styleDesc == kAEPlain)       {        itemsInList = 0;        *hadPlain = true;      }      else        itemsInList--;    }        return(myErr);} // MakeStyleFromAEList</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MenuScripter/listing46.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MenuScripter/listing46.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MenuScripter/listing46.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>