<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Quartz 2D Programming Guide: Paths</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Paths"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001066-CH211" title="Paths"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../Quartz-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000559" target="_top">Quartz</a> &gt; <a href="../dq_intro/dq_intro.html#//apple_ref/doc/uid/TP30001066-CH201-TPXREF101">Quartz 2D Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../dq_context/dq_context.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../dq_color/dq_color.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001066-CH211-TPXREF101" title="Paths"></a><h1>Paths</h1><p>A <strong>path</strong> defines one or more shapes, or subpaths. A path can consist of straight lines, curves, or both. It can be open or closed. A path can be a simple shape, such as a line, circle, rectangle, or star, or a more complex shape such as the silhouette of a mountain range or an abstract doodle. <span class="content_text">Figure 3-1</span> shows some of the paths you can create. The straight line (at the upper left of the figure) is dashed; lines can also be solid. The squiggly path (in the middle top) is made up of several curves and is an open path. The concentric circles are filled, but not stroked. The State of California is a closed path, made up of many curves and lines, and the path is both stroked and filled. The stars illustrate two options for filling paths, which you’ll read about later in this chapter. </p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBGFABH" title="Figure 3-1Quartz supports path-based drawing"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>Quartz supports path-based drawing</p><img src = "../Art/path_vector_examples.gif" alt = "Quartz supports path-based drawing" width="309" height="224"></div><br/><p>In this chapter, you’ll learn the building blocks that make up paths, how to stroke and paint paths, and the parameters that affect the appearance of paths.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_7">Path Creation and Path Painting</a>
				
			<br/>
			
        
			
			
				<a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-CJBDBDHF">The Building Blocks</a>
				
			<br/>
			
        
			
			
				<a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_12">Creating a Path</a>
				
			<br/>
			
        
			
			
				<a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-CJBEIHHJ">Painting a Path</a>
				
			<br/>
			
        
			
			
				<a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-TPXREF126">Clipping to a Path</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_7" title="Path Creation and Path Painting"></a><h2>Path Creation and Path Painting</h2><p>Path creation and path painting are separate tasks. First you create a path. When you want to render a path, you request Quartz to paint it. As you can see in <span class="content_text">Figure 3-1</span>, you can choose to stroke the path, fill the path, or both stroke and fill the path. You can also use a path to constrain the drawing of other objects within the bounds of the path creating, in effect, a <strong>clipping area</strong>.</p><p><span class="content_text">Figure 3-2</span> shows a path that has been painted and that contains two subpaths. The subpath on the left is a rectangle, and the subpath on the right is an abstract shape made up of straight lines and curves. Each subpath is filled and its outline stroked.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBCFDFC" title="Figure 3-2A path that contains two shapes, or subpaths"></a><p><strong>Figure 3-2&nbsp;&nbsp;</strong>A path that contains two shapes, or subpaths</p><img src = "../Art/subpaths.gif" alt = "A path that contains two shapes, or subpaths" width="237" height="241"></div><br/><p><span class="content_text">Figure 3-3</span> shows multiple paths drawn independently. Each path contains a randomly generated curve, some of which are filled and others stroked. Drawing is constrained to a circular area by a clipping area.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBHBBGI" title="Figure 3-3A clipping area constrains drawing"></a><p><strong>Figure 3-3&nbsp;&nbsp;</strong>A clipping area constrains drawing</p><img src = "../Art/circle_clipping.gif" alt = "A clipping area constrains drawing" width="412" height="327"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBDBDHF" title="The Building Blocks"></a><h2>The Building Blocks</h2><p>Paths are built from lines, arcs, curves, and rectangles. Although a rectangle can be constructed using four lines, this shape is used so frequently that Quartz provides functions that allow you to create a rectangle in one step. Points are also essential building blocks of paths because points define starting and ending locations of shapes. </p><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_8" title="Points"></a><h3>Points</h3><p>Points are x- and y-coordinates that specify a location in user space. You can call the function <code>CGContextMoveToPoint</code> to specify a starting location when you build a path. Quartz keeps track of the <strong>current point</strong>, which is the last location used for path construction. For example, if you call the function <code>CGContextMoveToPoint</code> to set a location at (10, 10), then you draw a horizontal line 50 units long, the last point on the line, that is, (60, 10), becomes the current point. Lines, arcs, and curves are always drawn starting from the current point.</p><p>Most of the time you specify a point by passing to Quartz functions two floating-point values to specify x- and y-coordinates. Some functions require that you pass a <code>CGPoint</code> data structure, which holds two floating-point values. </p><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_9" title="Lines"></a><h3>Lines</h3><p>A line is defined by its endpoints. Its starting point is always assumed to be the current point, so when you create a line, you specify only its endpoint. You use the function <code>CGContextAddLineToPoint</code> to append a single line to a path. </p><p>You can add a series of connected lines to a path by calling the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextAddLines" target="_top">CGContextAddLines</a></code>. You pass this function an array of points. The first point must be the starting point of the first line; the remaining points are endpoints. Quartz connects each point in the array with the next point in the array, using straight line segments.</p><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_10" title="Arcs"></a><h3>Arcs</h3><p>Arcs are circle segments. Quartz provides two functions that create arcs. The function <code>CGContextAddArc</code> creates a curved segment from a circle. You specify the center of the circle, the radius, and the radial angle (in radians). You can create a full circle by specifying a radial angle of 2 pi. <span class="content_text">Figure 3-4</span> shows multiple paths drawn independently. Each path contains a randomly generated circle; some are filled and others are stroked.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBDCAGD" title="Figure 3-4Multiple paths; each path contains a randomly generated circle"></a><p><strong>Figure 3-4&nbsp;&nbsp;</strong>Multiple paths; each path contains a randomly generated circle</p><img src = "../Art/circles.gif" alt = "Multiple paths; each path contains a randomly generated circle" width="412" height="327"></div><br/><p>The function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextAddArcToPoint" target="_top">CGContextAddArcToPoint</a></code> is ideal to use when you want to round the corners of a rectangle. Quartz uses the endpoints you supply to create two tangent lines. You also supply the radius of the circle from which Quartz slices the arc. The center point of the arc is the intersection of two radii, each of which is perpendicular to one of the two tangent lines. Each endpoint of the arc is a tangent point on one of the tangent lines, as shown in <span class="content_text">Figure 3-5</span>. The red portion of the circle is what’s actually drawn.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBDAEBD" title="Figure 3-5Defining an arc with two tangent lines and a radius"></a><p><strong>Figure 3-5&nbsp;&nbsp;</strong>Defining an arc with two tangent lines and a radius</p><img src = "../Art/rounded_corner.gif" alt = "Defining an arc with two tangent lines and a radius" width="429" height="322"></div><br/><p>If the current path already contains a subpath, Quartz appends a straight line segment from the current point to the starting point of the arc. If the current path is empty, Quartz creates a new subpath for the arc and does not add the initial straight line segment.</p><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBFIEHC" title="Curves"></a><h3>Curves</h3><p>Quadratic and cubic Bézier curves are algebraic curves that can specify any number of interesting curvilinear shapes. Points on these curves are calculated by applying a polynomial formula to starting and ending points, and one or more control points. Shapes defined in this way are the basis for vector graphics. A formula is much more compact to store than an array of bits and has the advantage that the curve can be recreated at any resolution.</p><p><span class="content_text">Figure 3-6</span> shows a variety of curves created by drawing multiple paths independently. Each path contains a randomly generated curve; some are filled and others are stroked.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBJIBJE" title="Figure 3-6Multiple paths; each path contains a randomly generated curve"></a><p><strong>Figure 3-6&nbsp;&nbsp;</strong>Multiple paths; each path contains a randomly generated curve</p><img src = "../Art/bezier_paths.gif" alt = "Multiple paths; each path contains a randomly generated curve" width="362" height="287"></div><br/><p>The polynomial formulas that give to rise to quadratic and cubic Bézier curves, and the details on how to generate the curves from the formulas, are discussed in many mathematics texts and online sources that describe computer graphics. These details are not discussed here.</p><p>You use the function <code>CGContextAddCurveToPoint</code> to append a cubic Bézier curve from the current point, using control points and an endpoint you specify. <span class="content_text">Figure 3-7</span> shows the cubic Bézier curve that results from the current point, control points, and endpoint shown in the figure. The placement of the two control points determines the geometry of the curve. If the control points are both above the starting and ending points, the curve arches upward. If the control points are both below the starting and ending points, the curve arches downward. If the second control point is closer to the current point (starting point) than the first control point, the curve crosses over itself, creating a loop. </p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBEEGHC" title="Figure 3-7A cubic B&Atilde;&copy;zier curve uses two control points"></a><p><strong>Figure 3-7&nbsp;&nbsp;</strong>A cubic Bézier curve uses two control points</p><img src = "../Art/cubic_bezier_curve.gif" alt = "A cubic Bézier curve uses two control points" width="331" height="153"></div><br/><p>You can append a quadratic Bézier curve from the current point by calling the function <code>CGContextAddQuadCurveToPoint</code>, and specifying a control point and an endpoint. <span class="content_text">Figure 3-8</span> shows two curves that result from using the same endpoints but different control points. The control point determines the direction that the curve arches. It’s not possible to create as many interesting shapes with a quadratic Bézier curve as you can with a cubic one because quadratic curves use only one control point. For example, it’s not possible to create a crossover using a single control point.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBHIDIE" title="Figure 3-8A quadratic B&Atilde;&copy;zier curve uses one control point"></a><p><strong>Figure 3-8&nbsp;&nbsp;</strong>A quadratic Bézier curve uses one control point</p><img src = "../Art/quadratic_bezier_curve.gif" alt = "A quadratic Bézier curve uses one control point" width="462" height="187"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIHJHEA" title="Ellipses"></a><h3>Ellipses</h3><p>An ellipse is essentially a squashed circle. You create one by defining two focus points and then plotting all the points that lie at a distance such that adding the distance from any point on the ellipse to one focus to the distance from that same point to the other focus point is always the same value. <span class="content_text">Figure 3-9</span> shows multiple paths drawn independently. Each path contains a randomly generated ellipse; some are filled and others are stroked.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIEIDHD" title="Figure 3-9Multiple paths; each path contains a randomly generated ellipse"></a><p><strong>Figure 3-9&nbsp;&nbsp;</strong>Multiple paths; each path contains a randomly generated ellipse</p><img src = "../Art/ellipses.gif" alt = "Multiple paths; each path contains a randomly generated ellipse" width="399" height="329"></div><br/><p>In Mac OS X v10.4 and later, you can add an ellipse to the current path by calling the function <code>CGContextAddEllipseInRect</code>. You supply a rectangle that defines the bounds of the ellipse. Quartz approximates the ellipse using a sequence of Bézier curves. The center of the ellipse is the center of the rectangle. If the width and height of the rectangle are equal (that is, a square), the ellipse is circular, with a radius equal to one-half the width (or height) of the rectangle. If the width and height of the rectangle are unequal, they define the major and minor axes of the ellipse.</p><p>Ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction.</p><p>If your application runs in versions of Mac OS X earlier than v10.3 you can create an ellipse as shown in <span class="content_text">Listing 3-1</span>. First, you apply a transform to the context. Then, you call the function <code>CGContextAddArc</code>, passing 0 as the starting angle and 2 pi as the ending angle, which would normally result in a circle. Because the code in the listing scales the drawing destination so it’s twice as wide as it is high, drawing a circle into the transformed context, results in an ellipse. See <span class="content_text"><a href="../dq_affine/dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-TPXREF101">“Transforms”</a></span> for more information on setting up and using affine transforms.</p><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIHFCCD" title="Listing 3-1Code that creates an ellipse by applying a transform to a circle"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>Code that creates an ellipse by applying a transform to a circle</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextScaleCTM(context, 1,2);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextBeginPath(context);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextAddArc(context, 0, 0, 25, 0, 2*M_PI, false);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextStrokePath(context);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_11" title="Rectangles"></a><h3>Rectangles</h3><p>You can add a rectangle to the current path by calling the function <code>CGContextAddRect</code>. You supply a <code>CGRect</code> structure that contains the origin of the rectangle and its width and height. Quartz draws the rectangle at the origin you specify; the current point has no bearing on the placement of the rectangle. Unlike arcs, if the path already contains a subpath, Quartz does not append a line segment from the current point to the origin of the rectangle.</p><p>You can add many rectangles to the current path by calling the function <code>CGContextAddRects</code> and supplying an array of <code>CGRect</code> structures. <span class="content_text">Figure 3-10</span> shows multiple paths drawn independently. Each path contains a randomly generated rectangle; some are filled and others are stroked.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBFAEDG" title="Figure 3-10Multiple paths; each path contains a randomly generated rectangle"></a><p><strong>Figure 3-10&nbsp;&nbsp;</strong>Multiple paths; each path contains a randomly generated rectangle</p><img src = "../Art/rectangles.gif" alt = "Multiple paths; each path contains a randomly generated rectangle" width="375" height="333"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_12" title="Creating a Path"></a><h2>Creating a Path</h2><p>When you want to construct a path in a graphics context, you signal Quartz by calling the function <code>CGContextBeginPath</code>. Next, you set the starting point for the first shape, or subpath, in the path by calling the function <code>CGContextMoveToPoint</code>. After you establish the first point, you can add lines, arcs, curves, and rectangles to the path, keeping in mind the following:</p><ul class="ul"><li class="li"><p>Lines, arcs, and curves are drawn starting at the current point.</p></li><li class="li"><p>When you want to close a subpath within a path, call the function <code>CGContextClosePath</code> to connect the current point to the starting point.</p></li><li class="li"><p>When you draw arcs, Quartz draws a line between the current point and the starting point. </p></li><li class="li"><p>Quartz does not draw a line between the current point and the origin of a rectangle.</p></li><li class="li"><p>You must call a painting function to fill or stroke the path because creating a path does not draw the path. See <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-CJBEIHHJ">“Painting a Path”</a></span> for detailed information. </p></li><li class="li"><p>Before you begin a new path you call the function <code>CGContextBeginPath</code>.</p></li></ul><p>After you paint a path, it is flushed from the graphics context. You might not want to lose your path so easily, especially if it depicts a complex scene you want to use over and over again. For that reason, Quartz provides two data types for creating reusable paths—<code>CGPathRef</code> and <code>CGMutablePathRef</code>. You can call the function <code>CGPathCreateMutable</code> to create a mutable CGPath object to which you can add lines, arcs, curves, and rectangles. Quartz provides a set of CGPath functions that parallel the functions discussed in <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-CJBDBDHF">“The Building Blocks.”</a></span> The path functions operate on a CGPath object instead of a graphics context. These functions are:</p><ul class="ul"><li class="li"><p><code><a href="../../../Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathCreateMutable" target="_top">CGPathCreateMutable</a></code>, which takes the place of <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextBeginPath" target="_top">CGContextBeginPath</a></code> </p></li><li class="li"><p><code><a href="../../../Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathMoveToPoint" target="_top">CGPathMoveToPoint</a></code>, which is similar to <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextMoveToPoint" target="_top">CGContextMoveToPoint</a></code></p></li><li class="li"><p><code><a href="../../../Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathAddLineToPoint" target="_top">CGPathAddLineToPoint</a></code>, which is similar to<code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextAddLineToPoint" target="_top">CGContextAddLineToPoint</a></code> </p></li><li class="li"><p><code><a href="../../../Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathAddCurveToPoint" target="_top">CGPathAddCurveToPoint</a></code>, which is similar to <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextAddCurveToPoint" target="_top">CGContextAddCurveToPoint</a></code></p></li><li class="li"><p><code><a href="../../../Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathAddEllipseInRect" target="_top">CGPathAddEllipseInRect</a></code>, which is similar to <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextAddEllipseInRect" target="_top">CGContextAddEllipseInRect</a></code></p></li><li class="li"><p><code><a href="../../../Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathAddArc" target="_top">CGPathAddArc</a></code>, which is similar to <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextAddArc" target="_top">CGContextAddArc</a></code></p></li><li class="li"><p><code><a href="../../../Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathAddRect" target="_top">CGPathAddRect</a></code>, which is similar to <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextAddRect" target="_top">CGContextAddRect</a></code></p></li><li class="li"><p><code><a href="../../../Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathCloseSubpath" target="_top">CGPathCloseSubpath</a></code>, which is similar to <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextClosePath" target="_top">CGContextClosePath</a></code></p></li></ul><p>See <em><a href="../../../Reference/Quartz2D_Collection/index.html#//apple_ref/doc/uid/TP40003853" target="_top">Quartz 2D Reference Collection</a></em> for a complete list of the path functions. </p><p>When you want to append the path to a graphics context, you call the function <code>CGContextAddPath</code>. The path stays in the graphics context until Quartz paints it. You can add the path again by calling <code>CGContextAddPath</code>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_61" title="Note"></a><p><strong>Note:</strong>&nbsp; You can replace the path in a graphics context with the stroked version of the path by calling the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextReplacePathWithStrokedPath" target="_top">CGContextReplacePathWithStrokedPath</a></code>. This function is available in Mac OS X v10.4.</p></div><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBEIHHJ" title="Painting a Path"></a><h2>Painting a Path</h2><p>You can paint the current path by stroking or filling or both. <strong>Stroking</strong> paints a line that straddles the path. <strong>Filling</strong> paints the area contained within the path. Quartz has functions that let you stroke a path, fill a path, or both stroke and fill a path. The characteristics of the stroked line (width, color, and so forth), the fill color, and the method Quartz uses to calculate the fill area, are all part of the graphics state (see <span class="content_text"><a href="../dq_overview/dq_overview.html#//apple_ref/doc/uid/TP30001066-CH202-TPXREF132">“Graphics States”</a></span>). </p><a name="//apple_ref/doc/uid/TP30001066-CH211-TPXREF105" title="Parameters That Affect Stroking"></a><h3>Parameters That Affect Stroking</h3><p>You can affect how a path is stroked by modifying the parameters listed in <span class="content_text">Table 3-1</span>. These parameters are part of the graphics state, which means that the value you set for a parameter affects all subsequent stroking until you set the parameter to another value.</p><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIHEDJA" title="Table 3-1Parameters that affect how Quartz strokes the current path"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-1&nbsp;&nbsp;</strong>Parameters that affect how Quartz strokes the current path</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Parameter</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function to Set Parameter Value</p></th></tr><tr><td  scope="row"><p>Line width</p></td><td ><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetLineWidth" target="_top">CGContextSetLineWidth</a></code></p></td></tr><tr><td  scope="row"><p>Line join</p></td><td ><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetLineJoin" target="_top">CGContextSetLineJoin</a></code></p></td></tr><tr><td  scope="row"><p>Line cap</p></td><td ><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetLineCap" target="_top">CGContextSetLineCap</a></code></p></td></tr><tr><td  scope="row"><p>Miter limit</p></td><td ><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetMiterLimit" target="_top">CGContextSetMiterLimit</a></code></p></td></tr><tr><td  scope="row"><p>Line dash pattern</p></td><td ><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetLineDash" target="_top">CGContextSetLineDash</a></code></p></td></tr><tr><td  scope="row"><p>Stroke color space</p></td><td ><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetStrokeColorSpace" target="_top">CGContextSetStrokeColorSpace</a></code></p></td></tr><tr><td  scope="row"><p>Stroke color</p></td><td ><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetStrokeColor" target="_top">CGContextSetStrokeColor</a></code><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetStrokeColorWithColor" target="_top">CGContextSetStrokeColorWithColor</a></code></p></td></tr><tr><td  scope="row"><p>Stroke pattern</p></td><td ><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetStrokePattern" target="_top">CGContextSetStrokePattern</a></code></p></td></tr></table></div><p>The <strong>line width</strong> is the total width of the line, expressed in units of the user space. The line straddles the path, with half of the total width on either side.</p><p>The <strong>line join</strong> specifies how Quartz draws the junction between connected line segments. Quartz supports the line join styles described in <span class="content_text">Table 3-2</span>. The default style is miter join.</p><a name="//apple_ref/doc/uid/TP30001066-CH211-BAJCHJFH" title="Table 3-2Line join styles"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-2&nbsp;&nbsp;</strong>Line join styles</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Style</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Appearance</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Miter join</p></td><td ><p><img src = "../Art/linejoinmiter.gif" alt = "Miter join" width="84" height="64"></p></td><td ><p>Quartz extends the outer edges of the strokes for the two segments until they meet at an angle, as in a picture frame. If the segments meet at too sharp an angle, a bevel join is used instead. A segment is too sharp if the length of the miter divided by the line width is greater than the miter limit.</p></td></tr><tr><td  scope="row"><p>Round join</p></td><td ><p><img src = "../Art/linejoinround.gif" alt = "Round join" width="84" height="59"></p></td><td ><p>Quartz draws a semicircular arc with a diameter equal to the line width around the endpoint. The enclosed area is filled in.</p></td></tr><tr><td  scope="row"><p>Bevel join</p></td><td ><p><img src = "../Art/linejoinbevel.gif" alt = "Bevel join" width="84" height="56"></p></td><td ><p>Quartz finishes the two segments with butt caps. The resulting notch beyond the ends of the segments is filled with a triangle.</p></td></tr></table></div><p>The <strong>line cap</strong> specifies the method used by <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextStrokePath" target="_top">CGContextStrokePath</a></code> to draw the endpoint of the line. Quartz supports the line cap styles described in <span class="content_text">Table 3-3</span>. The default style is butt cap.</p><a name="//apple_ref/doc/uid/TP30001066-CH211-BAJBHIGD" title="Table 3-3Line cap styles"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-3&nbsp;&nbsp;</strong>Line cap styles</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Style</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Appearance</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Butt cap</p></td><td ><p><img src = "../Art/linecapbutt.gif" alt = "Butt cap" width="88" height="13"></p></td><td ><p>Quartz squares off the stroke at the endpoint of the path. There is no projection beyond the end of the path.</p></td></tr><tr><td  scope="row"><p>Round cap</p></td><td ><p><img src = "../Art/linecapround.gif" alt = "Round cap" width="98" height="13"></p></td><td ><p>Quartz draws a circle with a diameter equal to the line width around the point where the two segments meet, producing a rounded corner. The enclosed area is filled in.</p></td></tr><tr><td  scope="row"><p>Projecting square cap</p></td><td ><p><img src = "../Art/linecapsquare.gif" alt = "Projecting square cap" width="98" height="13"></p></td><td ><p>Quartz extends the stroke beyond the endpoint of the path for a distance equal to half the line width. The extension is squared off.</p></td></tr></table></div><p>A <strong>line dash pattern</strong> allows you to draw a segmented line along the stroked path. You control the size and placement of dash segments along the line by specifying the dash array and the dash phase as parameters to <code>CGContextSetLineDash</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>void CGContextSetLineDash (<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRef ctx,<span></span></pre></td></tr><tr><td scope="row"><pre>    float phase,<span></span></pre></td></tr><tr><td scope="row"><pre>    const float lengths[],<span></span></pre></td></tr><tr><td scope="row"><pre>    size_t count<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div><p>The elements of the <code>lengths</code> parameter specify the widths of the dashes, alternating between the painted and unpainted segments of the line. The <code>phase</code> parameter specifies the starting point of the dash pattern. <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBEIBJ">Figure 3-11</a></span> shows some line dash patterns. </p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIBEIBJ" title="Figure 3-11Examples of line dash patterns"></a><p><strong>Figure 3-11&nbsp;&nbsp;</strong>Examples of line dash patterns</p><img src = "../Art/linedash.gif" alt = "Examples of line dash patterns" width="410" height="143"></div><br/><p>The stroke <strong>color space</strong> determines how the stroke <strong>color</strong> values are interpreted by Quartz. Prior to Mac OS X v10.3, you set the color space separately from the color. Starting with Mac OS X v10.3, you can use a Quartz color (<code>CGColorRef</code> data type) that encapsulates both color and color space. For more information on setting color space and color, see <span class="content_text"><a href="../dq_color/dq_color.html#//apple_ref/doc/uid/TP30001066-CH205-TPXREF101">“Color and Color Spaces.”</a></span></p><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_13" title="Functions for Stroking a Path"></a><h3>Functions for Stroking a Path</h3><p>Quartz provides the functions shown in <span class="content_text">Table 3-4</span> for stroking the current path. Some are convenience functions for stroking rectangles or ellipses. </p><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIFIFIG" title="Table 3-4Functions that stroke paths"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-4&nbsp;&nbsp;</strong>Functions that stroke paths</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>CGContextStrokePath</code></p></td><td ><p>Strokes the current path.</p></td></tr><tr><td  scope="row"><p><code>CGContextStrokeRect</code></p></td><td ><p>Strokes the specified rectangle.</p></td></tr><tr><td  scope="row"><p><code>CGContextStrokeRectWithWidth</code></p></td><td ><p>Strokes the specified rectangle, using the specified line width.</p></td></tr><tr><td  scope="row"><p><code>CGContextStrokeEllipseInRect</code></p></td><td ><p>Strokes an ellipse that fits inside the specified rectangle.</p></td></tr><tr><td  scope="row"><p><code>CGContextStrokeLineSegments</code></p></td><td ><p>Strokes a sequence of lines. </p></td></tr><tr><td  scope="row"><p><code>CGContextDrawPath</code></p></td><td ><p>If you pass the constant <code>kCGPathStroke</code>, strokes the current path. See <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-TPXREF106">“Filling a Path”</a></span> if you want to both fill and stroke a path.</p></td></tr></table></div><p>The function <code>CGContextStrokeLineSegments</code> is equivalent to the following code:</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextBeginPath (context);<span></span></pre></td></tr><tr><td scope="row"><pre>for (k = 0; k &lt; count; k += 2) {<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextMoveToPoint(context, s[k].x, s[k].y);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextAddLineToPoint(context, s[k+1].x, s[k+1].y);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextStrokePath(context);<span></span></pre></td></tr></table></div><p>When you call <code>CGContextStrokeLineSegments</code>, you specify the line segments as an array of points, organized as pairs. Each pair consists of the starting point of a line segment followed by the ending point of a line segment. For example, the first point in the array specifies the starting position of the first line, the second point specifies the ending position of the first line, the third point specifies the starting position of the second line, and so forth.</p><a name="//apple_ref/doc/uid/TP30001066-CH211-TPXREF106" title="Filling a Path"></a><h3>Filling a Path</h3><p>When you fill the current path, Quartz fills each subpath independently. Any subpath that has not been explicitly closed is closed implicitly by the fill routines.</p><p>There are two ways Quartz can calculate the fill area. Simple paths such as ovals and rectangles have a well-defined area. But if your path is composed of overlapping segments, such as the concentric circles shown in <span class="content_text">Figure 3-12</span>, there are two rules you can use to determine the fill area.</p><p>The default fill rule is called the <strong>nonzero winding number rule</strong>. To determine whether a specific point should be painted, start at the point and draw a line beyond the bounds of the drawing. Starting with a count of 0, add 1 to the count every time a path segment crosses the line from left to right, and subtract 1 every time a path segment crosses the line from right to left. If the result is 0, the point is not painted. Otherwise, the point is painted. The direction that the path segments are drawn affects the outcome. <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BBCEDHFC">Figure 3-12</a></span> shows two sets of inner and outer circles that are filled using the nonzero winding number rule. When each circle is drawn in the same direction, both circles are filled. When the circles are drawn in opposite directions, the inner circle is not filled.</p><p>You can opt to use the <strong>even-odd rule</strong>. To determine whether a specific point should be painted, start at the point and draw a line beyond the bounds of the drawing. Count the number of path segments that the line crosses. If the result is odd, the point is painted. If the result is even, the point is not painted. The direction that the path segments are drawn doesn’t affect the outcome. As you can see in <span class="content_text">Figure 3-12</span>, it doesn’t matter which direction each circle is drawn, the fill will always be as shown.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BBCEDHFC" title="Figure 3-12Concentric circles filled using different fill rules"></a><p><strong>Figure 3-12&nbsp;&nbsp;</strong>Concentric circles filled using different fill rules</p><img src = "../Art/eosampleone.gif" alt = "Concentric circles filled using different fill rules" width="363" height="94"></div><br/><p>Quartz provides the functions shown in <span class="content_text">Table 3-5</span> for filling the current path. Some are convenience functions for stroking rectangles or ellipses.</p><a name="//apple_ref/doc/uid/TP30001066-CH211-BCICAFCD" title="Table 3-5Functions that fill paths"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-5&nbsp;&nbsp;</strong>Functions that fill paths</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>CGContextEOFillPath</code></p></td><td ><p>Fills the current path using the even-odd rule.</p></td></tr><tr><td  scope="row"><p><code>CGContextFillPath</code></p></td><td ><p>Fills the current path using the non-zero winding number rule.</p></td></tr><tr><td  scope="row"><p><code>CGContextFillRect</code></p></td><td ><p>Fills the area that fits inside the specified rectangle.</p></td></tr><tr><td  scope="row"><p><code>CGContextFillRects</code></p></td><td ><p>Fills the areas that fits inside the specified rectangles.</p></td></tr><tr><td  scope="row"><p><code>CGContextFillEllipseInRect</code></p></td><td ><p>Fills an ellipse that fits inside the specified rectangle.</p></td></tr><tr><td  scope="row"><p><code>CGContextDrawPath</code></p></td><td ><p>Fills the current path if you pass <code>kCGPathFill</code> (non-zero winding number rule) or <code>kCGPathEOFill</code> (even-odd rule). Fills and strokes the current path if you pass <code>kCGPathFillStroke</code> or <code>kCGPathEOFillStroke</code>.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIGICEF" title="Setting Blend Modes"></a><h3>Setting Blend Modes</h3><p><strong>Blend modes</strong> (available starting in Mac OS X v10.4) specify how Quartz applies paint over a background. Quartz uses normal blend mode by default, which combines the foreground painting with the background painting using the following formula:</p><p><code>result = (alpha * foreground) + (1 - alpha) * background</code></p><p><span class="content_text"><a href="../dq_color/dq_color.html#//apple_ref/doc/uid/TP30001066-CH205-TPXREF101">“Color and Color Spaces”</a></span> provides a detailed discussion of the alpha component of a color, which specifies the opacity of a color. For the examples in this section, you can assume a color is completely opaque (alpha value = 1.0). For opaque colors, when you paint using normal blend mode, anything you paint over the background completely obscures the background.</p><p>You can set the blend mode to achieve a variety of effects by calling the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code>, passing the appropriate blend mode constant. Keep in mind that the blend mode is part of the graphics state. If you use the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSaveGState" target="_top">CGContextSaveGState</a></code> prior to changing the blend mode, then calling the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextRestoreGState" target="_top">CGContextRestoreGState</a></code> resets the blend mode to normal.</p><p>The rest of this section show the results of painting the rectangles shown in <span class="content_text">Figure 3-13</span> over the rectangles shown in <span class="content_text">Figure 3-14</span>. In each case (<span class="content_text">Figure 3-15</span> through <span class="content_text">Figure 3-30</span>), the background rectangles are painted using normal blend mode. Then the blend mode is changed by calling the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the appropriate constant. Finally, the foreground rectangles are painted.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI" title="Figure 3-13The rectangles painted in the foreground"></a><p><strong>Figure 3-13&nbsp;&nbsp;</strong>The rectangles painted in the foreground</p><img src = "../Art/vertical.gif" alt = "The rectangles painted in the foreground" width="253" height="253"></div><br/><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI" title="Figure 3-14The rectangles painted in the background"></a><p><strong>Figure 3-14&nbsp;&nbsp;</strong>The rectangles painted in the background</p><img src = "../Art/horizontal.gif" alt = "The rectangles painted in the background" width="252" height="252"></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_62" title="Note"></a><p><strong>Note:</strong>&nbsp; You can also use blend modes to composite two images or to composite an image over any content that’s already drawn to the graphics context. <span class="content_text"><a href="../dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIJEFG">“Using Blend Modes With Images”</a></span> provides information on how to use blend modes to composite images and shows the results of applying blend modes to two images.</p></div><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_14" title="Normal Blend Mode"></a><h4>Normal Blend Mode</h4><p>Because normal blend mode is the default blend mode, you call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeNormal</code> only to reset the blend mode back to the default after you’ve used one of the other blend mode constants. <span class="content_text">Figure 3-15</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using normal blend mode.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIIBACF" title="Figure 3-15Rectangles painted using normal blend mode"></a><p><strong>Figure 3-15&nbsp;&nbsp;</strong>Rectangles painted using normal blend mode</p><img src = "../Art/blm_normal.gif" alt = "Rectangles painted using normal blend mode" width="252" height="252"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_15" title="Multiply Blend Mode"></a><h4>Multiply Blend Mode</h4><p>Multiply blend mode specifies to multiply the foreground image samples with the background image samples. The resulting colors are at least as dark as either of the two contributing sample colors. <span class="content_text">Figure 3-16</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using multiply blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeMultiply</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIFJJCA" title="Figure 3-16Rectangles painted using multiply blend mode"></a><p><strong>Figure 3-16&nbsp;&nbsp;</strong>Rectangles painted using multiply blend mode</p><img src = "../Art/blm_multiply.gif" alt = "Rectangles painted using multiply blend mode" width="253" height="253"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_16" title="Screen Blend Mode"></a><h4>Screen Blend Mode</h4><p>Screen blend mode specifies to multiply the inverse of the foreground image samples with the inverse of the background image samples. The resulting colors are at least as light as either of the two contributing sample colors. <span class="content_text">Figure 3-17</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using screen blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeScreen</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIEBIFG" title="Figure 3-17Rectangles painted using screen blend mode"></a><p><strong>Figure 3-17&nbsp;&nbsp;</strong>Rectangles painted using screen blend mode</p><img src = "../Art/blm_screen.gif" alt = "Rectangles painted using screen blend mode" width="253" height="253"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_17" title="Overlay Blend Mode"></a><h4>Overlay Blend Mode</h4><p>Overlay blend mode specifies to either multiply or screen the foreground image samples with the background image samples, depending on the background color. The background color mixes with the foreground color to reflect the lightness or darkness of the background. <span class="content_text">Figure 3-18</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using overlay blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeOverlay</code>. </p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIJEJCC" title="Figure 3-18Rectangles painted using overlay blend mode"></a><p><strong>Figure 3-18&nbsp;&nbsp;</strong>Rectangles painted using overlay blend mode</p><img src = "../Art/blm_overlay.gif" alt = "Rectangles painted using overlay blend mode" width="253" height="253"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_18" title="Darken Blend Mode"></a><h4>Darken Blend Mode</h4><p>Specifies to create the composite image samples by choosing the darker samples (either from the foreground image or the background). The background image samples are replaced by any foreground image samples that are darker. Otherwise, the background image samples are left unchanged. <span class="content_text">Figure 3-19</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using darken blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeDarken</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIICBHB" title="Figure 3-19Rectangles painted using darken blend mode"></a><p><strong>Figure 3-19&nbsp;&nbsp;</strong>Rectangles painted using darken blend mode</p><img src = "../Art/blm_darken.gif" alt = "Rectangles painted using darken blend mode" width="253" height="253"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_19" title="Lighten Blend Mode"></a><h4>Lighten Blend Mode</h4><p>Specifies to create the composite image samples by choosing the lighter samples (either from the foreground or the background). The result is that the background image samples are replaced by any foreground image samples that are lighter. Otherwise, the background image samples are left unchanged. <span class="content_text">Figure 3-20</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using lighten blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeLighten</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIGFBIA" title="Figure 3-20Rectangles painted using lighten blend mode"></a><p><strong>Figure 3-20&nbsp;&nbsp;</strong>Rectangles painted using lighten blend mode</p><img src = "../Art/blm_lighten.gif" alt = "Rectangles painted using lighten blend mode" width="253" height="253"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_20" title="Color Dodge Blend Mode"></a><h4>Color Dodge Blend Mode</h4><p>Specifies to brighten the background image samples to reflect the foreground image samples. Foreground image sample values that specify black do not produce a change. <span class="content_text">Figure 3-21</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using color dodge blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeColorDodge</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIHAHDH" title="Figure 3-21Rectangles painted using color dodge blend mode"></a><p><strong>Figure 3-21&nbsp;&nbsp;</strong>Rectangles painted using color dodge blend mode</p><img src = "../Art/blm_color_dodge.gif" alt = "Rectangles painted using color dodge blend mode" width="252" height="252"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_21" title="Color Burn Blend Mode"></a><h4>Color Burn Blend Mode</h4><p>Specifies to darken the background image samples to reflect the foreground image samples. Foreground image sample values that specify white do not produce a change. <span class="content_text">Figure 3-22</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using color burn blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeColorBurn</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIIFEDB" title="Figure 3-22Rectangles painted using color burn blend mode"></a><p><strong>Figure 3-22&nbsp;&nbsp;</strong>Rectangles painted using color burn blend mode</p><img src = "../Art/blm_color_burn.gif" alt = "Rectangles painted using color burn blend mode" width="253" height="253"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_22" title="Soft Light Blend Mode"></a><h4>Soft Light Blend Mode</h4><p>Specifies to either darken or lighten colors, depending on the foreground image sample color. If the foreground image sample color is lighter than 50% gray, the background is lightened, similar to dodging. If the foreground image sample color is darker than 50% gray, the background is darkened, similar to burning. If the foreground image sample color is equal to 50% gray, the background is not changed. Image samples that are equal to pure black or pure white produce darker or lighter areas, but do not result in pure black or white. The overall effect is similar to what you’d achieve by shining a diffuse spotlight on the foreground image. Use this to add highlights to a scene. <span class="content_text">Figure 3-23</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using soft light blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeSoftLight</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIGCHDI" title="Figure 3-23Rectangles painted using soft light blend mode"></a><p><strong>Figure 3-23&nbsp;&nbsp;</strong>Rectangles painted using soft light blend mode</p><img src = "../Art/blm_soft_light.gif" alt = "Rectangles painted using soft light blend mode" width="252" height="252"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_23" title="Hard Light Blend Mode"></a><h4>Hard Light Blend Mode</h4><p>Specifies to either multiply or screen colors, depending on the foreground image sample color. If the foreground image sample color is lighter than 50% gray, the background is lightened, similar to screening. If the foreground image sample color is darker than 50% gray, the background is darkened, similar to multiplying. If the foreground image sample color is equal to 50% gray, the foreground image is not changed. Image samples that are equal to pure black or pure white result in pure black or white. The overall effect is similar to what you’d achieve by shining a harsh spotlight on the foreground image. Use this to add highlights to a scene. <span class="content_text">Figure 3-24</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using hard light blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeHardLight</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIJHFJJ" title="Figure 3-24Rectangles painted using hard light blend mode"></a><p><strong>Figure 3-24&nbsp;&nbsp;</strong>Rectangles painted using hard light blend mode</p><img src = "../Art/blm_hard_light.gif" alt = "Rectangles painted using hard light blend mode" width="253" height="253"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_24" title="Difference Blend Mode"></a><h4>Difference Blend Mode</h4><p>Specifies to subtract either the foreground image sample color from the background image sample color, or the reverse, depending on which sample has the greater brightness value. Foreground image sample values that are black produce no change; white inverts the background color values. <span class="content_text">Figure 3-25</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using difference blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeDifference</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIHHJCC" title="Figure 3-25Rectangles painted using difference blend mode"></a><p><strong>Figure 3-25&nbsp;&nbsp;</strong>Rectangles painted using difference blend mode</p><img src = "../Art/blm_difference.gif" alt = "Rectangles painted using difference blend mode" width="253" height="253"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_25" title="Exclusion Blend Mode"></a><h4>Exclusion Blend Mode</h4><p>Specifies an effect similar to that produced by <code>kCGBlendModeDifference</code>, but with lower contrast. Foreground image sample values that are black don’t produce a change; white inverts the background color values. <span class="content_text">Figure 3-26</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using exclusion blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeExclusion</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIGFBAD" title="Figure 3-26Rectangles painted using exclusion blend mode"></a><p><strong>Figure 3-26&nbsp;&nbsp;</strong>Rectangles painted using exclusion blend mode</p><img src = "../Art/blm_exclusion.gif" alt = "Rectangles painted using exclusion blend mode" width="253" height="253"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_26" title="Hue Blend Mode"></a><h4>Hue Blend Mode</h4><p>Specifies to use the luminance and saturation values of the background with the hue of the foreground image. <span class="content_text">Figure 3-27</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using hue blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeHue</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIDHGJC" title="Figure 3-27Rectangles painted using hue blend mode"></a><p><strong>Figure 3-27&nbsp;&nbsp;</strong>Rectangles painted using hue blend mode</p><img src = "../Art/blm_hue.gif" alt = "Rectangles painted using hue blend mode" width="252" height="252"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_27" title="Saturation Blend Mode"></a><h4>Saturation Blend Mode</h4><p>Specifies to use the luminance and hue values of the background with the saturation of the foreground image. Areas of the background that have no saturation (that is, pure gray areas) don’t produce a change. <span class="content_text">Figure 3-28</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using saturation blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeSaturation</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIHBGEG" title="Figure 3-28Rectangles painted using saturation blend mode"></a><p><strong>Figure 3-28&nbsp;&nbsp;</strong>Rectangles painted using saturation blend mode</p><img src = "../Art/blm_saturation.gif" alt = "Rectangles painted using saturation blend mode" width="253" height="253"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_28" title="Color Blend Mode"></a><h4>Color Blend Mode</h4><p>Specifies to use the luminance values of the background with the hue and saturation values of the foreground image. This mode preserves the gray levels in the image. You can use this mode to color monochrome images or to tint color images. <span class="content_text">Figure 3-29</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using color blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeColor</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCICAHDD" title="Figure 3-29Rectangles painted using color blend mode"></a><p><strong>Figure 3-29&nbsp;&nbsp;</strong>Rectangles painted using color blend mode</p><img src = "../Art/blm_color.gif" alt = "Rectangles painted using color blend mode" width="248" height="248"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_29" title="Luminosity Blend Mode"></a><h4>Luminosity Blend Mode</h4><p>Specifies to use the hue and saturation of the background with the luminance of the foreground image. This mode creates an effect that is inverse to the effect created by <code>kCGBlendModeColor</code>. <span class="content_text">Figure 3-30</span> shows the result of painting <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIBBHCI">Figure 3-13</a></span> over <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIDCGEI">Figure 3-14</a></span> using luminosity blend mode. To use this blend mode, call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with the constant <code>kCGBlendModeLuminosity</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH211-BCIBCHDI" title="Figure 3-30Rectangles painted using luminosity blend mode"></a><p><strong>Figure 3-30&nbsp;&nbsp;</strong>Rectangles painted using luminosity blend mode</p><img src = "../Art/blm_luminosity.gif" alt = "Rectangles painted using luminosity blend mode" width="253" height="253"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH211-TPXREF126" title="Clipping to a Path"></a><h2>Clipping to a Path</h2><p>The <strong>current clipping area</strong> is created from a path that serves as a mask, allowing you to block out the part of the page that you don’t want to paint. For example, if you have a very large bitmap image and want to show only a small portion of it, you could set the clipping area to display only the portion you want to show. </p><p>When you paint, Quartz renders paint only within the clipping area. Drawing that occurs inside the closed subpaths of the clipping area is visible; drawing that occurs outside the closed subpaths of the clipping area is not.</p><p>When the graphics context is initially created, the clipping area includes all of the paintable area of the context (for example, the media box of a PDF context). You alter the clipping area by setting the current path and then using a clipping function instead of a drawing function. The clipping function intersects the filled area of the current path with the existing clipping area. Thus, you can intersect the clipping area, shrinking the visible area of the picture, but you cannot increase the area of the clipping area. </p><p>The clipping area is part of the graphics state. To restore the clipping area to a previous state, you can save the graphics state before you clip, and restore the graphics state after you’re done with clipped drawing.</p><p><span class="content_text">Listing 3-2</span> shows a code fragment that sets up a clipping area in the shape of a circle. This code causes drawing to be clipped, similar to what’s shown in <span class="content_text"><a href="dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-CJBHBBGI">Figure 3-3</a></span>. (For another example, see <span class="content_text"><a href="../dq_shadings/dq_shadings.html#//apple_ref/doc/uid/TP30001066-CH207-BBCBCJAE">“Clip the Context”</a></span> in the chapter <span class="content_text"><a href="../dq_shadings/dq_shadings.html#//apple_ref/doc/uid/TP30001066-CH207-TPXREF101">“Gradients.”</a></span>)</p><a name="//apple_ref/doc/uid/TP30001066-CH211-CJBHJCAE" title="Listing 3-2Code that sets up a clip using a circle"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>Code that sets up a clip using a circle</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextBeginPath (context);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextAddArc (context, w/2, h/2, ((w>h) ? h : w)/2, 0, 2*PI, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextClosePath (context);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextClip (context);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001066-CH211-DontLinkElementID_63" title="Table 3-6Functions that clip the graphics context"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-6&nbsp;&nbsp;</strong>Functions that clip the graphics context</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextClip" target="_top">CGContextClip</a></code></p></td><td ><p>Uses the nonzero winding number rule to calculate the intersection of the current path with the current clipping path.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextEOClip" target="_top">CGContextEOClip</a></code></p></td><td ><p>Uses the even-odd rule to calculate the intersection of the current path with the current clipping path.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextClipToRect" target="_top">CGContextClipToRect</a></code></p></td><td ><p>Sets the clipping area to the area that intersects both the current clipping path and the specified rectangle.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextClipToRects" target="_top">CGContextClipToRects</a></code></p></td><td ><p>Sets the clipping area to the area that intersects both the current clipping path and region within the specified rectangles.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextClipToMask" target="_top">CGContextClipToMask</a></code></p></td><td ><p>Maps a mask into the specified rectangle and intersects it with the current clipping area of the graphics context. Any subsequent path drawing you perform to the graphics context is clipped. (See <span class="content_text"><a href="../dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHDDBE">“Masking an Image by Clipping the Context.”</a></span>) Available in Mac OS X v10.4 and later. </p></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../dq_context/dq_context.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../dq_color/dq_color.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-12-11<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_paths/dq_paths.html%3Fid%3DTP30001066-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_paths/dq_paths.html%3Fid%3DTP30001066-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_paths/dq_paths.html%3Fid%3DTP30001066-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>