<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"            "http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note ME09: Coping With VM and Memory Mappings</title><meta name="keywords" content="Mac OS 7 VM Memory mappings GetPhysical holdmemory lockmemory"><meta name="Description" content="Technical Note ME09: This Technical Note describes in detailhow to use the GetPhysical routine. This routine is criticalto the support of alternate bus masters on certain machineswithout Virtual Memory (VM) and all machines with VM. Includedis an ancillary discussion of several closely-related VMroutines, e.g. locking memory, holding memory and lockinghandles. Technical Note also reiterates a number of issuesimportant to VM compatibility and elucidates some of thedeeper VM issues of which specialized developers should beaware (developers of SCSI drivers, NuBus master hardware,and code which runs at interrupt time)."><meta name="categories" content="Memory"><meta name="week-posted" content="Jan 28, 1991 - Feb 1, 1991"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><a name="//apple_ref/doc/uid/DTS10002535" title="Coping With VM and Memory Mappings"></a><a name="top"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note ME09</div>
<div id="pageheadsub">Coping With VM and Memory Mappings</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Everybody Must Get Physical</a><BR><BR> <A HREF="#Section2">Holding and Locking Memory Versus Locking Handles</a><BR><BR> <A HREF="#Section3">VM Compatibility</a><BR><BR> <A HREF="#Section4">User Tips and Helpful Hints for Living With VM</a><BR><BR> <A HREF="#Section5">A Template for GetPhysical Usage</a><BR><BR> <A HREF="#References">References</A><BR><BR> <A HREF="#Changes">Change History</A><BR><BR>   <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">The purpose of this Note is twofold.  First, it describes in detail how to usethe <code>GetPhysical</code> routine.  This routine is critical to the support ofalternate bus masters on certain machines without Virtual Memory (VM) and allmachines with VM.  Included is an ancillary discussion of several closely-related VM routines.  Second, it reiterates a number of issues important to VM compatibility and elucidates some of the deeper VM issues of which specialized developers should be aware.  Compatibility issues are especially important for developers of SCSI drivers, NuBus master hardware, and code which runs at interrupt time.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Feb 01 1991]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name="Section1"></a><h2>Everybody Must Get Physical</h2><p>If you are developing NuBus expansion cards with bus mastership or directmemory access (DMA) capabilities, and if you have ever done development orcompatibility testing with Apple's recent machines, like the Macintosh IIci andMacintosh IIsi, you have undoubtedly noticed some strange behavior.  You mighttell the card to dump data into a buffer at $00300000 and the data insteadappears at $006B0000.  "What's happening here?" you must ask yourself.</p><p>Well, there's a new game in town--it's called a <b>discontiguous physicaladdress space</b>.  What that means in simple terms is that there ispotentially a big hole in memory.  If you have eight megabytes installed in aMacintosh IIci, for instance, that memory appears to the CPU and to NuBus intwo separate 4 MB ranges: [$00000000 - $003FFFFF] and [$04000000 - $043FFFFF].Everything from the end of Bank A to the beginning of Bank B is essentiallyempty. Bank B memory does not start until at least $04000000.</p><p>To compensate for this, the operating system uses the memory management unit(MMU) to map all the <b>physical</b> memory (what the hardware sees) into asingle contiguous <b>logical</b> address space (what all Macintosh code sees).The logical address space looks exactly like the memory map you've known foryears.  The translation is completely transparent to software.  If you're anapplications developer and you read the low-memory global at $10C, you don'tcare that the address that the processor actually looks at is $0400010C.  Whenthe processor originally put a value in that spot, it went through the sametranslation.  Everything is relative and you always get just what you'd expect.</p><p>The sole exception is for software which runs on the Macintosh but communicatesaddresses to NuBus master hardware.  Say, for instance, that you have developeda video frame grabber which dumps an image into a handle you've allocated forthat purpose.  When you call <code>_NewHandle</code> with an argument of<code>frameSize</code>, you get back a logical address.  If you use a 68030, or a68020 with a 68851 PMMU, to store data into that handle, the MMU performs anaddress translation and places data into a corresponding physical address.NuBus hardware, however, does not use the MMU's address mapping tables.  Ifyour driver passes along a logical address from the Memory Manager, the framegrabber does not know to translate it (indeed it cannot), and the logicaladdress is interpreted as a physical address.  External hardware may dump abeautiful captured image well outside your carefully allocated handle andperhaps right across the top of MacsBug and other similarly important things.Bugs like this are extremely difficult to isolate unless you understand theirbehavior and anticipate them.</p><p>The point is, now you must be sure to always convert logical addresses tocorresponding physical addresses before passing them to any alternate busmaster.  A new function to support this is <code>GetPhysical</code>, which isdocumented in <i>Inside Macintosh</i>, Volume VI.  "Great," you say, onceyou've read the documentation.  "But <code>GetPhysical</code> is a System Software7.0 feature and a Virtual Memory feature to boot.  What do I do for System6.0.x or if I'm not running VM?"</p><p>I'm glad you asked, because VM and the memory architecture of the MacintoshIIci are related topics.  <code>GetPhysical,</code> a routine required by the IIci,is one of a suite of functions dispatched by a trap called <code>_MemoryDispatch</code> ($A05C), which is the same trap used by the major VM calls.  Because some machines require <code>GetPhysical</code> even without VM, those machines have a limited form of <code>_MemoryDispatch</code> implemented in ROM.</p><p>You <b>can</b> call <code>GetPhysical</code> under System 6.0.x or under System 7.0even when VM is not running--all you must do first is check to see that the<code>_MemoryDispatch</code> trap is implemented.  If this trap is implemented, itis there for a reason, and you should use it.  Although <code>GetPhysical</code> ispresent only for certain machines without VM, it is present and required forall machines running VM.  If you update your code to be compatible with theIIci and IIsi in the 6.0.x world, you are already doing part of what isrequired to be compatible with Virtual Memory and System Software 7.0.</p><a name="Section2"></a><P><A HREF="#top">Back to top</A></P><h2>Holding and Locking Memory Versus Locking Handles</h2><p>Virtual Memory introduces two new concepts--holding and locking a range ofvirtual memory.  These are not to be confused with locking a handle.  Locking ahandle prevents the handle from changing its logical address during MemoryManager operations. Holding and locking virtual memory affects how VM dealswith arbitrary ranges of memory during paging operations.</p><p>Holding and locking memory (as opposed to a handle) are VM functionsexclusively and are accomplished with four new <code>_MemoryDispatch</code>routines:  <code>HoldMemory</code> and <code>LockMemory</code>, and the correspondingroutines to undo these operations, <code>UnholdMemory</code> and <code>UnlockMemory</code>.  Pay special attention any time you hold or lock a range of memory that you subsequently unhold or unlock the same range.  Every single call to <code>HoldMemory</code> or <code>LockMemory</code> must be balanced by a corresponding <code>UnholdMemory</code> or <code>UnlockMemory</code> because theoperating system supports multiple levels of locking and holding, much like it supports multiple levels of cursor obscuration with <code>_ShowCursor</code> and <code>_HideCursor</code>.</p><p>Holding a range of memory guarantees that the data in that range is actuallysomewhere in physical Macintosh RAM and that no paging activity is necessary toload it.  This is critical for tasks which run at interrupt time, since pagingactivity should not be initiated at interrupt time.  VM is not guaranteed to bereentrant, and because interrupts may occur in the middle of paging, any dataaccessed by an interrupt handler should reside in a held block of memory. Onlyhold memory which legitimately needs to be held though, because any memorywhich is held becomes ineligible for paging.  This reduces the space VM has towork with and may significantly impact system performance.  Some interrupt-timetasks are deferred by VM until paging is safe, so memory they touch does notalways have to be held.  These tasks are called out below, in the section"Compatibility With Other Device Drivers and Interrupt-Level Code."</p><p>Locking a range of memory is more severe than holding it.  This not only forcesthe range to be held resident in physical RAM, but also prevents its logicaladdress from moving with respect to its physical address.  This is importantfor drivers which initiate DMA transactions, because there must be a known,static relationship between logical and physical addresses for the duration ofsuch an operation.  Part of the behavior of <code>LockMemory</code> is to make theassociated memory non-cacheable which is important for DMA transfers.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Warning:</B><BR>Apple cannot make the point too strongly that memory shouldonly be held or locked when absolutely necessary, and only as long asnecessary.  It is worth restating that the impact on performance can besignificant or even fatal in severe cases.  It is a crime against the machineto hold or lock memory unnecessarily.  Failure to unhold or unlock memorypreviously held or locked is most heinous.</P></TD></TR></TABLE></CENTER><BR><p>In non-VM environments, there is no page swapping activity.  This is similar toall of memory being locked, except that caching is still enabled.  Truly lockedmemory is neither cached nor paged.  If you are running System Software 7.0with VM, you <b>must</b> explicitly lock a range of memory with <code>LockMemory</code> before calling <code>GetPhysical</code>.  You may only call <code>GetPhysical</code> on a locked block of virtual memory, or you get an error, since, among other reasons, any paging activity could invalidate the results of a <code>GetPhysical</code> call.  Although it is not necessary to call <code>LockMemory</code> before <code>GetPhysical</code> if VM is not running, <code>LockMemory</code> may still be used for its favorable effect of disabling caching.  This Note includes a code template (located at the end) whichillustrates a "way rad" method to implement driver calls to a generic NuBus master card.  It doesn't even have to know if VM is running.  Hardware and drivers should be designed to support this method for maximum VM friendliness.</p><p>There is one more VM routine of interest, <code>LockMemoryContiguous</code>, whichis provided to assist developers whose DMA hardware is not capable oftransferring blocks of arbitrary size or for some other reason cannot use ageneralized algorithm such as the one provided.  Apple can only warn developersthat <code>LockMemoryContiguous</code> is potentially an expensive operation interms of performance and is one very likely to fail since contiguous physicalmemory may be difficult, if not impossible, to find. <code>LockMemoryContiguous</code> is not particularly useful, unless VM is running, should a range of memory happen to cross a physical discontinuity like that found on a Macintosh IIci.  No hardware or software product should require VM in order to run.  <code>LockMemoryContiguous</code>might be useful for determining whether a range of logical memory is actually physically contiguous, although <code>GetPhysical</code> can do the same thing without actually locking the memory.</p><p>Apple's primary recommendation regarding <code>LockMemoryContiguous</code> is to avoid its use if at all possible. If you must use <code>LockMemoryContiguous</code>,  Apple recommends that you allocate your buffer as early as possible (preferably at startup) and lock it down contiguously at that time.  VM is an entropic system, meaning its pages tend to become shuffled over time, so it's easiest to find contiguous memory early in a session.</p><h3>When to Call?</h3><p><code>HoldMemory</code></p><ul type="disc">	<li>Before taking control of the SCSI bus.<BR><BR></li>	<li>Before accessing memory at interrupt time.<BR><BR></li>	<li>To keep <b>critical</b> ranges of memory resident for performance reasons.<BR><BR></li></ul><p><code>LockMemory</code></p><ul type="disc">	<li>Rarely.  (Always <code>UnlockMemory</code> as soon as possible.)<BR><BR></li>	<li>Before calling <code>GetPhysical</code>.<BR><BR></li>	<li>Before initiating a DMA transfer.<BR><BR></li></ul><p><code>LockMemoryContiguous</code></p><ul type="disc">	<li>Never, if you can help it.  (If necessary, do so as early as possible--see text above.)<BR><BR></li></ul><h3>When Not to Call?</h3><p><code>HoldMemory</code></p><ul type="disc">	<li>To keep <b>large</b> ranges of memory resident for performance reasons.<BR><BR></li></ul><p><code>LockMemory</code></p><ul type="disc">	<li>Before dereferencing a handle.  (<code>LockMemory</code> should not be confused with <code>_HLock</code>.)<BR><BR></li>	<li>When you really mean <code>HoldMemory</code>.<BR><BR></li></ul><h3>What Form Of Address To Pass?</h3><p>All <code>_MemoryDispatch</code> routines described above work as expected in either 24-bit mode or 32-bit mode.  In 24-bit mode, for instance, master pointer flags or other garbage bits in the high-order eight bits are ignoredand taken to be zero.  When switching between 24-bit and 32-bit modes, remember to use <code>_StripAddress</code> as outlined in <u><a href="http://developer.apple.com/documentation/macos8/OSSvcs/MemoryManager/memorymanager.html">Inside Macintosh: Memory</a>, pages 4-20 through 4-24 and 4-27</u>.</p><h3>Special Considerations</h3><p>The <code>GetPhysical</code> call in ROM and system software currently supportsonly logical RAM.  This excludes the ROM, I/O, and NuBus spaces from the set ofaddresses <code>GetPhysical</code> knows how to translate.  Unfortunately, machineslike the Macintosh IIci and Macintosh IIsi use the MMU to map a small amount ofphysical memory into NuBus space so that it looks like a regular video card.Ideally one might like to use <code>GetPhysical</code> to get the actual RAMaddress of the video buffer (to provide DMA support for certain multimediaproducts and graphics accelerators), but the current ROM implementation of<code>GetPhysical</code> returns a <code>paramErr</code> (- 50) in response to logical NuBus addresses.</p><p>Because its ROM is derived from that of the Macintosh IIci, the Macintosh LC may appear to have <code>_MemoryDispatch</code> implemented.  This doesn't make sense, however, because the LC has no MMU.  Although System Software 7.0 patches <code>_MemoryDispatch</code> in this case to make it unimplemented, PrimaryInit code and SCSI drivers which run before system patches are installed could be affected.  Code running at this time should qualify the existence of<code>_MemoryDispatch</code> with the existence of an MMU, using<code>_Gestalt</code>.</p><p>In order to solve both of these problems as cleanly as possible, the MPWlibraries contain an enhanced version of <code>GetPhysical</code> with greaterflexibility than the ROM version.* Although the enhanced version is the same asthe ROM version in most cases, it provides extra validation checks to guaranteestability before system patches are installed, and it applies alternatemechanisms to determine the physical address of a RAM-based video buffer.  Youshould therefore call <code>GetPhysical</code> where it is indicated, even foraddress spaces where the ROM version is known to return an error.  The gluecode may pick up the slack or a future ROM might not return an error.  In anycase, your code should always be prepared to cope with any of the<code>GetPhysical</code> error results documented in <i>Inside Macintosh</i>.Remember always to call <code>LockMemory</code> before calling <code>GetPhysical</code>,and <code>UnlockMemory</code> as soon as possible afterwards.</p><p>(*At this writing, the enhanced <code>GetPhysical</code> code has not yet beenincorporated into beta versions of the System 7.0 interface libraries.  Thiscode will be made available at the earliest opportunity and this Note will berevised to indicate its availability.  If you need <code>GetPhysical</code> tooperate on RAM-based video buffers or you need to call <code>GetPhysical</code> aspart of a PrimaryInit or SCSI driver initialization, you should be certain totake defensive measures against the special cases described above.)</p><a name="Section3"></a><P><A HREF="#top">Back to top</A></P><h2>VM Compatibility</h2><h3>Compatibility With Accelerator Upgrades</h3><p>The burden of compatibility has long been on the shoulders of acceleratormanufacturers. VM may present some additional compatibility challenges forthese manufacturers.</p><p>Virtual Memory requires services which are not present in the ROMs of68000-based machines, so VM is not supported by the Macintosh SE, even one witha 68030 accelerator.  The same is true of the Macintosh Plus, the MacintoshClassic, and the Macintosh Portable.  There is no guarantee that these oldermachines will ever be able to support VM.  For practical reasons, Apple haschosen not to implement VM in a wholly ROM-independent manner.  In theforeseeable future, only machines in which Apple intended to include memorymanagement units can support Virtual Memory.  Machines never intended toinclude an MMU do not have all the ROM code required by VM.</p><p>Virtual Memory depends on low-memory globals to indicate the presence of amemory management unit at a very early stage of the boot process.  In somecases, the low-memory globals are not properly set by the boot code in ROM ifthe hardware features of an accelerator are significantly different from thoseof the stock Macintosh.  The most likely problems are exhibited by 68000Macintoshes, 68020 Macintoshes with 68030 accelerators, and Macintoshes with68040 accelerators.  There is third-party virtual memory software whichprovides much of the VM functionality of System Software 7.0, and which is alsocompatible with accelerator products.  In some cases this software may bebundled with the accelerator.</p><p>Apple is not saying that VM does not work with any accelerator, but rather thatthe System 7.0 implementation of Virtual Memory in general does not supportaccelerators.  Some accelerator products may work or may be modified to work.Apple simply does not guarantee that any particular accelerator product workswith VM.</p><h3>Compatibility With Removable Media</h3><p>Obviously it would be a disaster if a user ejected the cartridge containing hisbacking store (paged out memory) and handed it to a co-worker to take home.This would be much worse than giving away a floppy, to be faced with the"Please insert the disk..." alert.  Someone would actually have part of thecomputer's memory in his briefcase--try to type Command-period and get out ofthat one.  To guard against this possibility, ejectable media are not permittedto host the VM backing store.  Users of removable cartridge drives are notwholly excluded, however.  The driver software for such a drive may imposesoftware interlocks to prevent ejection and indicate in the drive queue thatthe cartridge is nonejectable.  VM accepts any sufficiently large, blockoriented device as long as it is not ejectable.</p><h3>Compatibility With SCSI Code</h3><p>Virtual Memory introduces new requirements for some SCSI hard disk drivers.Users of Apple hard disks may need to update their drivers with a SystemSoftware 7.0-compatible Apple HD SC Setup application.  Third-party hard diskdrivers may also need to be updated.  It is up to these third parties todetermine what enhancements, if any, are required for their drivers and toprovide updates to their customers if necessary.</p><p>For SCSI disk driver developers, one requirement for VM compatibility may besummarized as follows (special thanks to Andy Gong for the detailed analysis):</p><p>On System 6.0.x and earlier, all calls to the SCSI disk driver came from thefile system.  This being true, and the file system being single-threaded, onlyone SCSI disk driver would be called at any one time.  Virtual Memory changesthis scenario because it makes calls to the driver directly, avoiding the filesystem.  This implies the possibility of SCSI drivers being reentered.</p><p>For a SCSI driver to function correctly in the VM environment, the driver musthave complete driver data separation at least on a drive-by-drive basis.  Suchseparation makes the driver reentrant on a drive-by-drive basis.  If the driversupports multiple HFS partitions on the same physical drive, the driver must becompletely reentrant if any of the HFS partitions are to be used for the VMbacking file.</p><p>All this means is that a driver which controls multiple drives or partitionsmust maintain separate driver variables to reference each drive or partition.Otherwise, the state of a transaction to one drive may be lost when the driveris reentered to service another drive.  There is no problem with reentrancy fordrivers which control only a single drive or partition.</p><p>In many cases of SCSI code incompatibility, reentrancy is not the problem.This affects only the small number of SCSI disk drivers which are designed tocontrol multiple drives or partitions from a single driver.  A more commonproblem is caused by a page fault while the SCSI bus is busy.  Since VM dependson the SCSI bus to handle a page fault, a page fault is forbidden to happenwhile the SCSI bus is busy. Code which uses the SCSI Manager needs in generalto ensure that all its code, buffers, and data structures (including TIBs) areheld in real memory before taking control of the bus.</p><p>In the normal course of events, the system heap is held in real memory. Othercritical structures are held for you automatically, like any range of memory passed to a Device Manager <code>_Read</code> or <code>_Write</code> call in <code>ioBuffer</code>and <code>ioReqCount</code>. So if your SCSI code is written as a device driver, and thebuffer's address and length are passed in the normal driver fashion, and if your driver code and data structures are located in the system heap, you should be fully VM-compatible already (as long as you only operate on one drive per driver).</p><p>If your SCSI code is not a standard Device Manager driver or if you referencebuffers as <code>csParam</code>s to <code>_Control</code> or <code>_Status</code> calls,you'll need to do some extra work. Also, Apple does not guarantee that thesystem heap will always be held for ever and ever, so if you come to reviseyour driver you should seriously consider holding explicitly everything youtouch while you own the SCSI bus and everything you might knowingly touch atinterrupt time; and of course you should correspondingly unhold all thesestructures upon releasing the bus.  Be a good citizen.</p><p>In addition to the requirement for reentrancy across drives served by a singledriver, the driver for a disk used as a backing store must load at the earliestpossible opportunity.  Drivers which defer installation until INIT time are toolate to be used by VM.</p><h3>Compatibility With Other Device Drivers and Interrupt-Level Code</h3><p>The primary concern for device drivers is that they commonly run at interrupt time and it is absolutely essential that interrupt-level code does not cause a page fault. To avoid this, drivers should make certain that any data structures they keep or reference at interrupt time are held in physical memory as described earlier.  Locking the structures is typically not necessary except in cases where alternate bus master hardware accesses those structures as well.</p><p>To improve performance and compatibility with existing software and drivers, the first release of System Software 7.0 always holds the entire system heap in physical memory.  No special measures need be taken if your driver and its associated data structures are all installed in the system heap. If yourdriver uses memory statically allocated above <code>BufPtr</code>, it may need to explicitly hold the appropriate ranges of memory to avoid paging at interrupt time.  Please be aware that future versionsof the Macintosh System Software may <b>not</b> hold all of the system heap automatically and it is a good habit to hold explicitly memory you know you access at interrupt time.</p><p>The Device Manager deals with <code>_Read</code> and <code>_Write</code> calls for you,and ensures that the buffers specified for such calls are safe.  However, if abuffer is passed as a <code>csParam</code> to <code>_Status</code> or <code>_Control</code>calls, the Device Manager cannot do anything about it.  Buffers referenced thisway must be held explicitly if they are to be accessed by interrupt-level code.</p><p>Certain code types are always deferred until times when paging is safe, and assuch don't have to be concerned about whether memory they touch is guaranteed to be held.  Those code types include Device Manager I/O completion routines,Time Manager tasks, VBL tasks, and slot VBL tasks.  The trade-off is in real-time performance.  Clearly, since these tasks may be deferred, there is an increased possibility of latency which may be unacceptable for some pseudo-real-time applications. (The Macintosh has never supported true real-time processing.) An arbitrary function which might cause a page fault at interrupt time can be deferred explicitly by calling it via the trap <code>_DeferUserFn</code>.</p><p>The <code>_DeferUserFn</code> trap is asynchronous in nature, so subsequent codemay be executed before the deferred function completes.  If the results of adeferred function are vital to the code which follows, the deferred functionneeds to signal the calling code when it completes.</p><p>Apple Desktop Bus I/O requests are deferred until a time when paging is safeunless VM is certain that all code and associated data structures are locatedin the system heap.  This is required because the ADB Manager normallyprocesses incoming data at interrupt time and there is a potential for pagefaults if the service routine code or other data structures are not held inreal memory.  The only problem with this strategy is reduced performance forspecialized ADB drivers which require most of the ADB bandwidth and don't livein the system heap.  Nonetheless, it's worth mentioning.<u></u></p><p>One final note of interest pertains to a longstanding anomaly in the DeviceManager.  As it turns out, when you make an asynchronous <code>_Open</code> or<code>_Close</code> call to a device driver, any completion routine you supply isnever called.  Since Virtual Memory patches <code>_Open</code> and <code>_Close</code>,and generates an entry for the completion routine in the user function queue,the implication is that the user functions are never executed and the queue maysimply fill up.  There is little reason to call <code>_Open</code> or <code>_Close</code>asynchronously with a completion routine (it never would have amounted to anything anyway), so the workaround is simple: don't do it.</p><h3>Compatibility With the BufPtr Method of Static Allocation</h3><p><i>Inside Macintosh</i>, Volume IV describes, on page 257, a method of staticallocation for resident drivers or other data structures.  This method has beenvery popular with a number of developers.  The main thing for developers toremember about this method in conjunction with VM is that memory allocated inthis way is not held in physical memory by default.  It must be explicitlyheld, unlike memory in the system heap which the operating system automaticallyholds, at least in the first release of System Software 7.0.</p><p>When allocating memory above <code>BufPtr</code>, always use the equation definedin <i>Inside Macintosh</i>.  The actual configuration of memory at boot time ismuch more complicated than the illustration indicates, especially with SystemSoftware 7.0 and VM.  The System 7.0 boot code passes a specially-conditionedversion of <code>MemTop</code> to system extensions, which guarantees that theequation has valid results.  For this reason, do not use <code>MemTop</code> todetermine the actual memory size of the machine; use <code>_Gestalt</code> instead.You may use <code>MemTop</code> to determine RAM size only if <code>_Gestalt</code> isnot implemented, and then only at INIT time.  (Apple continues to point outthat good application software should not need to know this information exceptunder extremely rare circumstances.)</p><p>Due to the way memory is organized with VM in 24-bit addressing, you may not beable to achieve nearly as much memory above <code>BufPtr</code> as you would thinkpossible for a given virtual memory size.  This is due to the possibility of VMfragmentation, which is discussed later.  Without VM, the available space above<code>BufPtr</code> is generally somewhat less than half the amount of memory installed in the machine.  With 24-bit VM, the available space may be significantly less, and is probably far less than one half of the virtual memory size. The "conditioning" of the <code>MemTop</code> variable takes this into account.</p><h3>Compatibility With 32-Bit Addressing</h3><p>To make the most valuable use of Virtual Memory, 32-bit addressing is extremelyimportant.  Needless to say, it is critical that all developers test theirapplications, drivers, and all other types of code extensively under System 7.0while running 32-bit addressing--both with and without VM.  Four megabit SIMMsare becoming less and less expensive, and the day is not far off when machineswith at least 16 MB will be common.  Correct behavior with 32-bit addressing iscritical to the acceptance of both System 7.0 and developer applications.  Itis not acceptable to ask users to reboot with 24-bit addressing in order to useyour hardware or software.  For a few classes of applications it may be necessary to turn VM off in order to run <b>efficiently</b>, but VM should not prevent an application from running at all.  Be sure to include a <code>'SIZE'</code> resource in your application. It should proclaim your 32-bit compatibility to the world, not to mention the Finder.</p><a name="Section4"></a><P><A HREF="#top">Back to top</A></P><h2>User Tips and Helpful Hints for Living With VM</h2><p>Apple suggests that Virtual Memory runs more efficiently with at least fourmegabytes of physical RAM.  Although System Software 7.0 runs on two-megabytesystems, using VM on such a system may result in unacceptable pagingperformance and hard disk thrashing.  After holding the system heap and otherRAM which must remain resident, there is simply not enough room left forefficient paging.  Fortunately, with the recommended four or five megabytes,most users should be able to run arbitrarily large virtual memory environments,with little or no annoyance from paging delays and limited primarily by thesacrifice in disk space.</p><p>Virtual Memory trades virtual RAM size for some degree of performance. VM users should be aware that VM is not always a viable alternative to physical RAM. For example, an application which makes heavy use of an entire 8 MB partition for image processing may execute very sluggishly on a machine with only 4 MB of real RAM. (The benefit of VM in this case that such an application runs at all on a machine with limited RAM.)  On the other hand, the same machine may concurrently run six or seven different megabyte-plus applications with little or no appreciable performance degradation except when switching among them. (This is where VM really shines.) Performance is determined by virtual RAM size versus physical RAM size with the memory access dynamics of each application thrown in as a wild card. Each VM user will find a combination of settings which he or she finds most comfortable.</p><h3>A Special Note Regarding 24-Bit VM</h3><p>Some machines in the installed base are capable of running VM, but do not have32-bit clean ROMs and must run with 24-bit addressing.  What this means to users who want to run VM is that they can only take advantage of 14 MB of virtual memory. That's all there is room for in a 24-bit address map.  More likely the limit is 12 or 13 MB because every installed NuBus card eliminates 1 MB of virtual RAM address space.  (The way VM increases RAM size with 24-bit addressing is--more or less--by making each unused NuBus slot look like a 1 MB RAM card and making ROM and each installed NuBus card look like anon-relocatable 1 MB application partition.)</p><p>You can be a real friend to the Process Manager (formerly known as MultiFinder)by taking care in which slots you install NuBus expansion cards:  ROM alwaysoccupies one megabyte at $800000, limiting the largest contiguous block ofvirtual memory to somewhat less than eight megabytes.  The balance may be in acontiguous block as large as four or five megabytes unless it is fragmented bya poor selection of slots for expansion cards.  Best results are achieved byplacing all expansion cards in consecutive slots at either end of the bus--thishas the effect of collecting all the immovable one megabyte rocks into a singlepile where one is less likely to trip over them.  Haphazard placement of NuBuscards may generate a number of one or two megabyte islands interspersedthroughout the upper portion of the virtual memory space, and that does<b>not</b> help to run more applications or to manipulate larger objects.</p><p>In machines with fewer than six NuBus slots, recall that one "end" of the bus is actually in the middle of the slot address space.  In a Macintosh IIcx, slots are numbered $9 through $B. Expansion cards should be installed from the lowest-numbered slot up (contiguous with the ROM) to avoid fragmentation.  In a Macintosh IIci, slots are numbered $C through $E. This poses a greater problem.  Due to the RAM-based video in virtual slot $B, it is nearly impossible to avoid some degree of fragmentation when using the built-in video option. When not using this option, installing NuBus cards from the highest-numbered slot down (at the end of memory) is the best course. Fortunately, the IIci ROM supports 32-bit addressing. In 32-bit addressing VM,none of this discussion applies.  Virtual Memory and NuBus do not share space in the 32-bit address map.</p><a name="Section5"></a><P><A HREF="#top">Back to top</A></P><h2>A Template for GetPhysical Usage</h2><p>A great deal of the justification for this code may be inferred from the codeitself and the comments within.  The basic rules are all covered in the previous text, but the simmered-down algorithm <i>sans</i> error handling is this:</p><p>See if there is <code>_MemoryDispatch</code>;</p><p>If there is <code>_MemoryDispatch</code>:</p><p><code>LockMemory</code> the interesting range of memory;</p><p>If the memory is locked:</p><p>Loop:</p><p>Call <code>GetPhysical</code> on memory;</p><p>Loop:</p><p>Process a physical block;</p><p>Until all physical blocks have been processed;</p><p>Until all memory is translated;</p><p><code>UnlockMemory</code> the interesting range of memory;</p><p>Otherwise:</p><p>Process the block of memory the way you used to;</p><p>End.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre> PROGRAM GetPhysicalUsage;      USES Types,Traps,Memory,        Utilities;    { see DTS sample code for TrapAvailable }        {In beta versions of the 7.0 interfaces, also use VMCalls, now in Memory.}      CONST        kTestHandleSize = $100000;      VAR        aHandle    : Handle;        aPtr       : Ptr;        aHandleSize: LongInt;        hasGetPhysical: Boolean;        lockOK     : Boolean;        vmErr      : OSErr;        table      : LogicalToPhysicalTable;        physicalEntryCount: LongInt;        index      : Integer;      PROCEDURE SendDMACmd(addr: Ptr; count: LongInt);        BEGIN          { this is where you would probably make a driver call to }          { initiate DMA from a NuBus master or similar hardware   }        END;      BEGIN        aHandle := NewHandle(kTestHandleSize);        IF aHandle &lt;&gt; NIL THEN BEGIN          MoveHHi(aHandle);          HLock(aHandle);          aPtr := aHandle^;          aHandleSize := GetHandleSize(aHandle);          hasGetPhysical := TrapAvailable(_MemoryDispatch);          { if GetPhysical is available it should always be used  }          { without it, DMA fails on IIci and many later machines }          IF hasGetPhysical THEN BEGIN            { must lock range before calling GetPhysical }            { Call LockMemoryContiguous instead of LockMemory if a single        physical block is required, but beware! This            is inefficient and failure-prone! }            vmErr := LockMemory {Contiguous} (aPtr,aHandleSize);            lockOK := (vmErr = noErr);            IF NOT lockOK THEN BEGIN              { handle LockMemory error indicated by vmErr }            END;            IF lockOK THEN BEGIN              table.logical.address := aPtr;              table.logical.count := aHandleSize;              vmErr := noErr;              WHILE (vmErr = noErr)              &amp; (table.logical.count &lt;&gt; 0) DO BEGIN                physicalEntryCount := SizeOf(table) DIV SizeOf(MemoryBlock) - 1;                { this makes it easier to change &quot;table&quot; to include more    }                { MemoryBlocks -- defaultPhysicalEntryCount is a suggestion }                vmErr := GetPhysical(table,physicalEntryCount);                { GetPhysical returns in physicalEntryCount the number   }                { of physical entries actually used in the address table }                IF vmErr = noErr THEN BEGIN                  FOR index := 0 TO (physicalEntryCount - 1) DO                    WITH table DO                      SendDMACmd(physical[index].address,physical[index].count);                END                ELSE BEGIN                  { handle GetPhysical error indicated by vmErr }                  { loop will terminate unless vmErr is negated }                END;              END;              { always unlock any range you lock! }              IF Boolean (UnlockMemory(aPtr,aHandleSize)) THEN                ; { ignore UnlockMemory err }            END;          END          ELSE            { no GetPhysical, life is bliss }            { remember how easy this used to be before GetPhysical? }            SendDMACmd(aPtr,aHandleSize);        END;      END.</pre>	</TD></TR></TABLE></CENTER> <P><A HREF="#top">Back to top</A></P><a name="References"></a><h2>References</h2><P><i>Inside Macintosh</i>, Volume II, Memory Manager</P><P><i>Inside Macintosh</i>, Volume IV, Initialization Resources</P><P><i>Inside Macintosh</i>, Volume VI, Compatibility Guidelines</P><P><i>Inside Macintosh</i>, Volume VI, Memory Management</P><P><a href="http://developer.apple.com/documentation/macos8/OSSvcs/MemoryManager/memorymanager.html">Inside Macintosh: Memory</a></P><P>Technical Note M.HW.Cache -- <u><A HREF = "../hw/hw_06.html">Cache As Cache Can</a></u></P><p>NuBus is a trademark of Texas Instruments</p><p>THINK is a trademark of Symantec Corporation</p><A NAME=Changes></A>                  <H2>Change History</H2>                           <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-Feb-1991</P>               </TD>               <td align="left">                  <P>This update incorporates new issues which have come up during System 7.0 beta testing, and it also attempts to clarify some issues which have proven to be particularly troublesome or widely misunderstood.</p>               </TD>            </TR>         </TABLE>         <BR>                  <P><A HREF="#top">Back to top</A></P>                           <P><A NAME=Downloads></A></P>                  <h2>Downloadables</h2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (56K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/me_09.pdf">Download</A></P>               </TD>            </TR>                     </TABLE>         <BR>                  <P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/me/me_09.html%3Fid%3DDTS10002535-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/me/me_09.html%3Fid%3DDTS10002535-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/me/me_09.html%3Fid%3DDTS10002535-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>