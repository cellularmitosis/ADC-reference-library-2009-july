<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html><head>
<!-- BEGIN META TAG INFO -->
<link rel="home" href="http://developer.apple.com/">
<link rel="find" href="http://developer.apple.com/search/">
<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
<script language="JavaScript" type="text/javascript" src="../../documentation/js/busnav.js"></script>
<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- END META TAG INFO -->
<!-- BEGIN TITLE -->
<title>Technical Note TN2035: ColorSync on Mac OS X</title>
<!-- END TITLE -->
</head>
<!-- BEGIN BODY OPEN -->
<body bgcolor="#ffffff"><a name="//apple_ref/doc/uid/DTS10003071" title="ColorSync on Mac OS X"></a>
<!--END BODY OPEN -->
<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->
<a name="top"></a>
<!-- BEGIN LOGO AND SEARCH -->
<!--#include virtual="/includes/adcnavbar"-->
<!-- END LOGO AND SEARCH -->
<!-- START BREADCRUMB -->
<div id="breadcrumb"><table width="680" border="0" cellpadding="0" cellspacing="0"><tr>
<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
<td><img width="340" height="10" src="images/1dot.gif" alt=""></td></tr><tr valign="middle"><td align="left" colspan="2">
<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../technicalnotes/GraphicsImaging/idxColorSync-date.html">ColorSync</a> &gt; 
</td></tr><tr><td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td></tr></table></div>
<!-- END BREADCRUMB -->

<!-- START MAIN CONTENT -->
<!-- START TITLE GRAPHIC AND INTRO-->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top">
<td><h1>
<div id="pagehead">Technical Note TN2035</div>
<div id="pageheadsub">ColorSync on Mac OS X</div>
</h1></td></tr></table>
<!-- END TITLE GRAPHIC AND INTRO -->
<!-- BEGIN WIDE COLUMN -->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td align="left" width="680">
<!-- BEGIN CONTENTS -->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td><p>ColorSync has a new role in Mac OS X. ColorSync in Mac OS X is fundamentally integrated into the operating system, whereas on previous versions of the operating system it was an optional install. Color management is very important these days to the customer experience. The Mac OS X graphics environment Quartz takes advantage of ColorSync in great detail, plus ColorSync is used throughout the print-path to provide color matching services for printer drivers.</p></td></tr><tr><td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br><img height="1" width="680" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt=""></td></tr></table><table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td width="680"><ul><li><a href="#TNTAG1">Overview</a><ul><li><a href="#TNTAG60">ICC Profiles</a></li><li><a href="#TNTAG61">CMM</a></li></ul></li><li><a href="#TNTAG2">ColorSync and Quartz</a><ul><li><a href="#TNTAG62">ColorSync And Quartz Color Management</a></li><li><a href="#TNTAG63">PDF Color Model</a><ul><li><a href="#TNTAG42">PDF Color Definition</a><li><a href="#TNTAG77">PDF Color Conversion</a></li></ul></li><li><a href="#TNTAG66">ColorSync/ICC Color Model</a><ul><li><a href="#TNTAG67">ICC color definition</a><li><a href="#TNTAG68">ICC Color Conversions</a></li></ul></li></ul></li><li><a href="#TNTAG71">Color Model in Quartz</a><ul><li><a href="#TNTAG69">Integration of PDF and ICC color models</a><ul><li><a href="#TNTAG70">PDF color space equivalence</a><li><a href="#TNTAG72">Color space is one or more ICC profiles</a></li></ul></li><li><a href="#TNTAG73">Color in Quartz Drawing Model</a></li><li><a href="#TNTAG74">Quartz Printing Front End</a></li><li><a href="#TNTAG75">Quartz Raster Printing Back End</a><ul><li><a href="#TNTAG15">ColorSync Color Matching</a><li><a href="#TNTAG40">Custom Driver Color Matching</a></li></ul></li><li><a href="#TNTAG76">Quartz in PostScript Back End</a></li><li><a href="#TNTAG14">Printing Untagged Data</a><ul><li><a href="#TNTAG92">PDF Display</a><li><a href="#TNTAG81">Printing Front End</a><li><a href="#TNTAG93">Printing Back End</a><li><a href="#TNTAG94">Raster Printing</a><li><a href="#TNTAG95">PostScript Printing</a></li></ul></li></ul></li><li><a href="#TNTAG83">Drawing to Multiple Screens</a></li><li><a href="#TNTAG3">Profiles in Mac OS X</a><ul><li><a href="#TNTAG90">Profile prerequisites</a></li><li><a href="#TNTAG91">New optional profile tags</a></li><li><a href="#TNTAG84">ICC4 Profiles</a></li></ul></li><li><a href="#TNTAG4">CMMs in Mac OS X</a><ul><li><a href="#TNTAG85">Building CMMs</a></li></ul></li><li><a href="#TNTAG5">ColorSync Preferences and Supporting APIs</a><ul><li><a href="#TNTAG88">Profiles for Standard Color Spaces</a></li><li><a href="#TNTAG89">ColorSync Preferences Tidbits</a></li><li><a href="#TNTAG96">ColorSync Preferences Summary</a></li></ul></li><li><a href="#TNTAG6">ColorSync Device Support</a><ul><li><a href="#TNTAG99">Notifications</a></li><li><a href="#TNTAG97">ColorSync Device Support Summary</a></li></ul></li><li><a href="#TNTAG32">Color Management in Printing</a><ul><li><a href="#TNTAG33">Color Matching On The Host by ColorSync</a></li><li><a href="#TNTAG34">cupsICCProfile PPD Declaration Entry</a></li></ul></li><li><a href="#TNTAG35">Quartz Filters</a><ul><li><a href="#TNTAG36">Demos of Quartz filters</a></li><li><a href="#TNTAG37">Soft-Proofing</a></li><li><a href="#TNTAG38">Print dialog</a></li></ul></li><li><a href="#TNTAG39">ColorSync Utility</a><ul><li><a href="#TNTAG43">ColorSync Preferences</a><ul><li><a href="#TNTAG44">Quartz Filter Support</a></li></ul></li><li><a href="#TNTAG45">Administration Features</a></li><li><a href="#TNTAG46">3D View Options for Profile Viewer</a></li></ul></li><li><a href="#TNTAG47">ColorSync and OpenGL</a></li><li><a href="#TNTAG31">ColorSync And QuickTime</a></li><li><a href="#TNTAG23">ColorSync And Image Capture</a></li><li><a href="#TNTAG49">Display Calibration</a><ul><li><a href="#TNTAG56">Support for your calibrator</a></li><li><a href="#TNTAG57">Apple Calibrator Expert Mode</a></li></ul></li><li><a href="#TNTAG58">SIPS</a></li><li><a href="#TNTAG24">ColorSync changes for Mac OS X 10.4 Tiger</a><ul><li><a href="#TNTAG30">Floating Point Support</a></li><li><a href="#TNTAG48">New structure: CMFloatBitmap</a></li><li><a href="#TNTAG65">New APIs</a><ul><li><a href="#TNTAG78">CMFloatBitmapMakeChunky</a><li><a href="#TNTAG80">CMConvertXYZFloatBitmap</a><li><a href="#TNTAG86">CMConvertRGBFloatBitmap</a><li><a href="#TNTAG100">CMMatchFloatBitmap</a></li></ul></li><li><a href="#TNTAG102">Use of CFTypes</a><ul><li><a href="#TNTAG103">CMProfileRef and CMWorldRef are now a CFType</a><li><a href="#TNTAG104">CMProfileCopyICCData</a></li></ul></li><li><a href="#TNTAG106">API Changes</a><ul><li><a href="#TNTAG107">Some of the ColorSync defaults/preferences APIs are to be deprecated</a></li></ul></li><li><a href="#TNTAG108">Custom CMMs</a><ul><li><a href="#TNTAG109">Quartz and Printing Graphics Systems will now only use the Apple CMM</a><li><a href="#TNTAG110">Applications can still request a custom CMM using NCWConcatColorWorld and explicitly match data</a><li><a href="#TNTAG111">New CMMMatchFloatMap entry point</a></li></ul></li><li><a href="#TNTAG112">Changes to ColorSync Utility</a><ul><li><a href="#TNTAG113">Removal of Preferences Pane</a><li><a href="#TNTAG114">New Color Calculator Pane</a></li></ul></li></ul></li><li><a href="#TNTAG98">References</a></li><li><a href="#TNT_HISTORY_TAG">Document Revision History</a></li></ul></td></tr><tr><td colspan="3" scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br><img height="1" width="680" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt=""></td></tr></table><A NAME="TNTAG1"></A><H2>Overview</H2><p>There are a wide variety of imaging devices in the market today, such as digital cameras, color scanners, color printers, etc., and each device represents colors in very different ways. They each have different color spaces and different gamuts (ranges of colors). This, of course, makes it very difficult for a document acquired on one device to be rendered correctly on another device. The solution to this problem is ColorSync, a complete color management system, designed to provide consistent color across devices.</p><p>The two key foundations upon which ColorSync is built are International Color Consortium (ICC) profiles and Color Management Modules (CMMs).</p><A NAME="TNTAG60"></A><H3>ICC Profiles</H3><p>ICC profiles use a cross-platform file format defined by the ICC. They are documents containing data that describe how to transform colors from device color space to an intermediate color space. This file format allows for the description of a wide variety of devices. The data format has been designed to be quite flexible, and can be extended by developers via optional tags. Furthermore, the format is an evolving format, with ongoing improvements.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG61"></A><H3>CMM</H3><p>If you think of profiles as the data used for color management, CMMs are the code. CMMs provide the mathematical engine to perform the profile-to-profile transformations. Apple ships a default CMM, the Apple CMM, as part of ColorSync. This is the same default CMM Apple ships on Mac OS 9. However, we've designed the system to be open and expandable, so third parties can developer their own CMMs if they want to provide their own alternate methods for color transformations.</p><p>Here's a diagram showing how ColorSync fits into the Mac OS X architecture:</p><p class="caption"><strong>Figure 1:</strong> Mac OS X Architecture &amp; ColorSync.</p><p><img  src="images/tn2035_1.jpg" width="484" height="228" alt="Figure 1, Mac OS X Architecture &amp; ColorSync."></p><p>The ColorSync 2.0 and greater APIs are fully supported in Mac OS X. This means it should be very easy for developers to port their applications to Mac OS X. There are also some new APIs in ColorSync in Mac OS X which provide some enhancements you may want to take advantage of. Also, Quartz and the printing model in Mac OS X take full advantage of ColorSync.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG2"></A><H2>ColorSync and Quartz</H2><p>in Mac OS X, ColorSync has been assigned a new role encompassing more than just the standard application services. ColorSync is now used to provide color management to other system components. One of these components is Quartz, Apple's new graphics system based on the PDF imaging model. Quartz has created a new paradigm for color management, which offers alternative access to ColorSync functionality.</p><A NAME="TNTAG62"></A><H3>ColorSync And Quartz Color Management</H3><p>Our goals here were to integrate graphics and color management services, satisfying some basic requirements. First, Quartz needed the ability to composite different color spaces and opacity. To meet this requirement, ColorSync is used to convert data from many different color spaces into the one space selected by Quartz as a working space for a compositer.</p><p>A second requirement focused on the needs of the developer, and is based on the fact all applications using Quartz will have to work with color management. This also needed to be a scalable solution, which would serve the needs of a wide range of applications. On the one hand, the involvement of an application in color management can be very minimal, limited to the use of some predefined default settings provided by Quartz. On the other hand, an application can have the same full control over color management as it does when accessing ColorSync directly. Other requirements include color accuracy, performance and compatablilty with PDF.</p><p>In simple terms, Quartz color management can be described as being built around ColorSync, which is used as an engine to process PDF color data produced by Quartz.</p><p class="caption"><strong>Figure 2:</strong> Quartz Color Management.</p><p><img  src="images/tn2035_2.jpg" width="466" height="170" alt="Figure 2, Quartz Color Management."></p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG63"></A><H3>PDF Color Model</H3><p>To better understand its design, here's some of the basic concepts pertaining to color in PDF and ColorSync:</p><A NAME="TNTAG42"></A><H4>PDF Color Definition</H4><p>In PDF, color is defined by one of the known color spaces - Device, Calibrated or ICC based:</p><p class="smalltext"><strong>Table 1:</strong> Color Spaces in PDF.</p><table cellspacing="0" class="graybox"><tr><th>Color Spaces in PDF</th></tr><tr><td scope="row">/DeviceGray, /DeviceRGB, /DeviceCMYK</td></tr><tr><td scope="row">/CalGray, /CalRGB, /CalLab</td></tr><tr><td scope="row">/ICCBased</td></tr></table><p>This list essentially reflects the history of color management. Initially, only device color spaces were supported. Based on our perspective today, the device color spaces merely provided a specification for different process color models. Because the color appearance is device dependent, these spaces are actually the worst choice for faithful color reproduction across different devices.</p><p>Next, calibrated color was invented, along with the idea of color conversions through device independent color. The advantage of this method is a significant improvement in color matching across different devices. PDF follows by adding calibrated color spaces. Later on, calibrated color evolved into a standard form - the ICC profile. When color management based on ICC profiles gained its popularity and became the de-facto standard among color professionals, PDF added the ICC-based color space, which allows for embedding ICC profiles into PDF documents.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG77"></A><H4>PDF Color Conversion</H4><p>PDF color coversion can be described as a function of source color space, destination color space, and rendering intent. Please take note of the rendering intent values:</p><p class="caption"><strong>Figure 3:</strong> PDF Color Conversion.</p><p><img  src="images/tn2035_3.jpg" width="628" height="126" alt="Figure 3, PDF Color Conversion."></p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG66"></A><H3>ColorSync/ICC Color Model</H3><p>Now let's take a look at how ICC and ColorSync define color and color conversion.</p><A NAME="TNTAG67"></A><H4>ICC color definition</H4><p>Naturally, color is defined by an ICC profile. As mentioned previously, the ICC profile is the most general form of the color space description.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG68"></A><H4>ICC Color Conversions</H4><p>ICC color conversions are very similar to those in PDF. The differences are an option to insert an intermediate profile between the source and destination profiles:</p><p class="caption"><strong>Figure 4:</strong> ICC Color Conversions.</p><p><img  src="images/tn2035_4.jpg" width="636" height="222" alt="Figure 4, ICC Color Conversions."></p><p>These additional profiles are used for soft-proofing, color device simulation, applying special affects, etc. As we can now see, the rendering intent values in ICC color conversions are the same as those in PDF:</p><p>Rendering intent = {perceptual, relative colorimetric, saturation, absolute colorimetric}</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG71"></A><H2>Color Model in Quartz</H2><A NAME="TNTAG69"></A><H3>Integration of PDF and ICC color models</H3><p>The color model in Quartz was created by integrating the ICC and PDF color models. Here're some of the interesting features of this model. All PDF color spaces are expressed in Quartz as ICC profiles. Device color spaces are assigned default profiles as follows:</p><ul><li><p>/DeviceGray -&gt; Quartz Default Gray</p></li><li><p>/DeviceRGB -&gt; Quartz Default RGB</p></li><li><p>/DeviceCMYK -&gt; Quartz Default CMYK</p></li></ul><p>Calibrated color spaces contain the calibration record, which can be very easily re-packaged as the ICC profile. Finally, ICC-based color spaces provide their own ICC profiles.</p><A NAME="TNTAG70"></A><H4>PDF color space equivalence</H4><p>Another simple but very important concept that Quartz inherited from PDF is color space equivalence. An implied rule is that color conversions are necessary only if the source color space is different from the destination. Quartz takes advantage of this simple rule to properly organize the flow of color data through multiple rendering stages:</p><p class="caption"><strong>Figure 5:</strong> Color space equivalence</p><p><img  src="images/tn2035_5.jpg" width="543" height="249" alt="Figure 5, Color space equivalence"></p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG72"></A><H4>Color space is one or more ICC profiles</H4><p>As mentioned previously, all PDF color spaces are expressed in Quartz as an ICC profile in a manner which is seamless and transparent through all applications working in the PDF imaging model. But at the same time, we needed a provision in Quartz to create color transformations for more than two profiles. For that reason, we designed a color space which can consist of one or more ICC profiles. This way we are able to preserve the PDF concept of matching a single source to a single destination, but at the same time we are able to create those complex color transformations which are suitable for advanced color management. And if the need arises for such a color space to be embedded in PDF, the multiple profiles contained in such a color space can be concatenated by ColorSync into a single profile.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG73"></A><H3>Color in Quartz Drawing Model</H3><p>Let's now see how all the things just discussed come together to provide the desired color processing in the Quartz drawing model. From the top-level perspective, there are three main components involved in this model:</p><ul><li><p>An application generating the graphic contents</p></li><li><p>Quartz providing the rendering services</p></li><li><p>The destination for the rasterized data</p></li></ul><p>In terms of color processing, the application can request Quartz to render data in any of the PDF color spaces. To accomplish that, Quartz will convert all these into ICC profiles. Default profiles are selected by Quartz, but can be overridden by the application. Quartz will do all compositing in the working space, and ColorSync will be invoked to perform color transformations from any of the source color spaces to the working space. Finally, when compositing is completed, the rasterized data will be sent to the desired destination. Naturally, if the color space of the destination doesn't match the working space, and additional conversion must be done.</p><p>Let's see how convenient Quartz color management can be for some color operations. For example, applying special effects to all data can be very easily achieved simply by adding the abstract profile to the working space. As shown in the following diagram, all conversions to the working space will include the transformation defining the abstract profile:</p><p class="caption"><strong>Figure 6:</strong> Applying Special Effects with Abstract Profile.</p><p><img  src="images/tn2035_9.jpg" width="542" height="359" alt="Figure 6, Applying Special Effects with Abstract Profile."></p><p>Soft proofing is another task that is particularly suited for color management, By adding a printer profile to the working space, all color corrections that define the printer profile are reflected in the working space, and thus will be shown on the primary display.</p><p class="caption"><strong>Figure 7:</strong> Soft-proofing Printout on Primary Display.</p><p><img  src="images/tn2035_10.jpg" width="548" height="363" alt="Figure 7, Soft-proofing Printout on Primary Display."></p><p>The use of multi-profile color spaces is not limited to the Quartz internals. Applications can also use them. Here is an example of an application using a given color space to create a free-transform color space to produce certain color effects.</p><p class="caption"><strong>Figure 8:</strong> Free-transform color space used to produce color effects.</p><p><img  src="images/tn2035_11.jpg" width="548" height="369" alt="Figure 8, Free-transform color space used to produce color effects."></p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG74"></A><H3>Quartz Printing Front End</H3><p>To complete our story about color management in Quartz, let's look at how color is handled in printing from Quartz. So far we've talked about the main flow of color data from the source to the destination. But one more step is also possible here. The contents can be spooled in PDF form for printing, which will be handled by the print center. There is one very important fact about the spooled data. As was pointed out, all color data is tagged in spooled PDF. And profiles are assigned to the data in exactly the same way they are for ColorSync processing:</p><p class="caption"><strong>Figure 9:</strong> Color data is tagged in spooled PDF.</p><p><img  src="images/tn2035_12.jpg" width="543" height="363" alt="Figure 9, Color data is tagged in spooled PDF."></p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG75"></A><H3>Quartz Raster Printing Back End</H3><A NAME="TNTAG15"></A><H4>ColorSync Color Matching</H4><p>Quartz is also used to rasterize this spooled PDF at the printing back end. From the color management perspective, we have two options here. The first option is to use ColorSync for color matching. In this case, all color data from the spooled PDF is converted to the printer profile (Note: there is no device data in the spooled PDF).</p><p class="caption"><strong>Figure 10:</strong> Spooled PDF converted to printer profile.</p><p><img  src="images/tn2035_13.jpg" width="483" height="184" alt="Figure 10, Spooled PDF converted to printer profile."></p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG40"></A><H4>Custom Driver Color Matching</H4><p>Another option is custom driver color matching.The color data, by design, is going to be handed off in the color space of the default profile provided by the system. As a result, all data which is tagged with the same default profile will remain untouched. And obviously all other color data will be converted by ColorSync to the system profile.</p><p class="caption"><strong>Figure 11:</strong> Custom driver color matching.</p><p><img  src="images/tn2035_14.jpg" width="527" height="364" alt="Figure 11, Custom driver color matching."></p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG76"></A><H3>Quartz in PostScript Back End</H3><p>ColorSync is also involved in the PostScript back end. From the color management perspective, our goal here is to convert the color spaces contained in the spooled PDF to PostScript color space arrays (CSAs). Quartz has the internal capability to convert PDF calibrated color spaces directly to PostScript CSAs. All ICC profiles will be converted to PostScript CSAs using ColorSync.</p><p class="caption"><strong>Figure 12:</strong> ICC profiles converted to PostScript CSAs.</p><p><img  src="images/tn2035_15.jpg" width="509" height="366" alt="Figure 12, ICC profiles converted to PostScript CSAs."></p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG14"></A><H3>Printing Untagged Data</H3><p>Here's some general notes about behaviors you can expect from the printing system when printing untagged data:</p><A NAME="TNTAG92"></A><H4>PDF Display</H4><p>Untagged RGB data in PDF will be tagged with the Generic RGB profile, and as a result it will be color-matched to the screen.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG81"></A><H4>Printing Front End</H4><p>When passing source data to the print system, the printing front end spools the print job in the PDF format, and as described in the section above Quartz Printing Front End, all color data is tagged in the spooled PDF. Therefore, when passing untagged RGB source data to the print system for printing, ColorSync will tag the data with the Generic RGB profile (just as is done when displaying PDF data).</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG93"></A><H4>Printing Back End</H4><p>When printing in Mac OS X, ColorSync will match source data to whatever profile the printer driver provides. For this reason, printer drivers should register profiles for their devices using the Device APIs as discussed in this note.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG94"></A><H4>Raster Printing</H4><p>If a printer driver provides no profile, ColorSync will substitute the Generic RGB profile.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG95"></A><H4>PostScript Printing</H4><p>Originally untagged RGB data is ultimately converted to a CIEBasedABC color space based on the Generic RGB profile.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG83"></A><H2>Drawing to Multiple Screens</H2><p>As described in the section ColorSync and Quartz there is a wide variety of ICC-based color spaces provided by Quartz. This section focuses on those which allow you to access the ColorSync Device Integration database.</p><p>An example are the color spaces which allow for drawing directly to the screen. There's the Display RGB color space, which is essentially a wrapper around the primary display profile. Display Gray, composed of two profiles: a device-link profile converting Gray to RGB, which is then attached to the primary display profile. And for more advanced uses there's the Display with ID space, a wrapper for Display By AVID profiles:</p><p class="caption"><strong>Figure 13:</strong> Color spaces which allow for drawing directly to the screen.</p><p><img  src="images/tn2035_23.jpg" width="444" height="196" alt="Figure 13, Color spaces which allow for drawing directly to the screen."></p><p>Quartz in Mac OS X v10.3 &quot;Panther&quot; helps solve the problem of drawing to multiple screens. There are three basic choices an application can make, one which can be defined as the &quot;Simple model&quot;, another which can be defined as the &quot;Complete model&quot; or lastly an application can use a combination of these two techniques.</p><p>These can be characterized as follows:</p><p>Applications' choice</p><p>Simple model</p><ul><li><p>color-matched only to the main display</p></li><li><p>application makes no updates on screen/profile change</p></li></ul><p>Complete model</p><ul><li><p>color-matched to individual displays</p></li><li><p>application can register for device notifications on screen/profile change and make proper updates as necessary</p></li></ul><p>Some combination of the above</p><ul><li><p>application can use a combination of the above two techniques</p></li></ul><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG3"></A><H2>Profiles in Mac OS X</H2><p>On Mac OS 9, profiles are traditionally stored in the Profiles folder within the System folder. An application wanting to gain access to this folder would use the <code>CMGetColorSyncFolderSpec</code> API, passing in <code>kSystemDisk</code> for the <code>vRefNum</code> parameter as follows:</p><p><code>CMGetColorSyncFolderSpec</code>(<code>kSystemDisk</code>, ...);</p><p>You could also use the Mac OS <code>FindFolder</code> API as an equivalent technique. However, one of the key features of Mac OS X is it is designed to be fully network and multi-user savvy. For this reason, there is no longer just one location where profiles can be stored, but several. There is a special location within the Mac OS X System folder for profiles:</p><p>/System/Library/ColorSync/Profiles/</p><p>This is where ColorSync stores profiles it uses internally for critical operations, should others be mistakenly lost or damaged. This folder is locked and protected, but if you need to get access to this folder to be able to read these profiles you can again use the <code>CMGetColorSyncFolderSpec</code> API, passing the <code>kSystemDomain</code> constant for the <code>vRefNum</code> parameter as follows:</p><p><code>CMGetColorSyncFolderSpec</code>(<code>kSystemDomain</code>, ...);</p><p>ColorSync profiles are primary stored here:</p><p>/Library/ColorSync/Profiles/</p><p>This is where ColorSync stores the majority of its profiles. This is a read/writable folder. If you need to get access to this folder to be able to read these profiles use the <code>CMGetColorSyncFolderSpec</code> API, passing the <code>kLocalDomain</code> constant for the <code>vRefNum</code> parameter as follows:</p><p><code>CMGetColorSyncFolderSpec</code>(<code>kLocalDomain</code>, ...);</p><p>If you are in a network environment, and your network administrator has stored profiles on the network for network devices, these can be stored in:</p><p>/Network/Library/ColorSync/Profiles/</p><p>If you need to get access to this folder to be able to read these profiles use the <code>CMGetColorSyncFolderSpec</code> API, passing the <code>kNetworkDomain</code> constant for the <code>vRefNum</code> parameter as follows:</p><p><code>CMGetColorSyncFolderSpec</code>(<code>kNetworkDomain</code>, ...);</p><p>Lastly, users can store their own personal profiles in their home directory:</p><p>~/Library/ColorSync/Profiles/</p><p>If you need to get access to this folder to be able to read these profiles use the <code>CMGetColorSyncFolderSpec</code> API, passing the <code>kUserDomain</code> constant for the <code>vRefNum</code> parameter as follows:</p><p><code>CMGetColorSyncFolderSpec</code>(<code>kUserDomain</code>, ...);</p><p>As on Mac OS 9, ColorSync in Mac OS X supports looking in subfolders of all the above directories (one level deep), or aliases to these folders or profiles. In summary, there are a great many locations where profiles can be stored in Mac OS X. If your application would like to present a list of profiles to the user, we suggest you use the <code>CMIterateColorSyncFolder</code> API. This API will greatly simplify your code, as it searches all the above locations for profiles. In addition, it offers great performance benefits because it caches frequently used information.</p><p>One important note with respect to this API - if you have a Mac OS Classic system folder setup in addition to the Mac OS X system folder, ColorSync by default will not search this Mac OS Classic system folder for profiles. However, if your application wishes to access profiles in this location, use the <code>CMIterateColorSyncFolder</code> API passing <code>kClassicDomain</code> for the <code>vRefNum</code> parameter:</p><p><code>CMGetColorSyncFolderSpec</code>(<code>kClassicDomain</code>, ...);</p><p>In summary, an application should install profiles in:</p><p>/Library/ColorSync/Profiles/</p><p>or in a subfolder of it. Users can install personal profiles in:</p><p>~/Library/ColorSync/Profiles/</p><A NAME="TNTAG90"></A><H3>Profile prerequisites</H3><p>Traditionally, profiles were filtered based on their type and creator on Mac OS 9 (type '<code>prof</code>', creator '<code>sync</code>'). However, profiles may not have a type and creator, so ColorSync no longer checks the type and creator of profiles. Also, profiles need not have any suffix. However, if you do use one use '<code>.icc</code>'. By standardizing on one suffix it makes it easier for applications using the Cocoa <code>NSOpenPanel</code> APIs to filter profiles. Similarly, if you use a type and creator for your profile, use '<code>prof</code>' and ''<code>sync</code>'', as this will make it easier for the Carbon Navigation Services APIs to filter profiles. At its heart, ColorSync no longer cares about type, creator, or suffix.</p><p>What really distinguishes a ColorSync profile from any old file is if it is a valid ICC profile. ColorSync determines if a file is a valid ICC profile by looking for the signature bytes '<code>acsp</code>' (stands for &quot;a ColorSync profile&quot;) at an appropriate offset in its header block. ColorSync also imposes the additional restriction that the profile contain a valid description tag. Many applications will present lists of profiles to the user, and if a profile has a bad name in the description tag, it will show as garbage or not at all. In order to avoid these problems, we suggest you use the ColorSync Profile First Aid utility to make sure your profiles are free of common errors.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG91"></A><H3>New optional profile tags</H3><p>One of the key features of Mac OS X is it is a multilocalized operating system. ColorSync now provides this same functionality for ICC profiles. Currently, the ICC format defines a required tag 'desc' which stores ASCII, UniCode, and ScriptCode versions of the profile description for display purposes. However, this structure allows the profile to be localized for one language only through UniCode or ScriptCode. Profile vendors have to ship many localized versions to different countries. It also creates problems when a document with localized profiles embedded in it is shipped to a system using a different language. ColorSync has defined a new optional tag to remedy this situation:</p><p>- '<code><code>mluc</code></code>' multilocalized UniCode Tag</p><p>This tag contains a set of multilingual Unicode strings associated with a profile. We also provide a number of new APIs for easy access to this tag:</p><pre class="sourcecodebox">
CMError CMCopyProfileLocalizedStringDictionary
  (CMProfileRef prof, OSType tag, CFDictionaryRef* dict);
</pre><p>prof - profile to query</p><p>tag - tag type of profile to query</p><p>dict - returns dictionary</p><p>This API allows you to get a <code>CFDictionary</code> which contains the language locale and string for multiple localizations from a given tag. Similarly, there is a <code>CMSetProfileLocalizedStringDictionary</code> API to allow you to write a dictionary of localized strings to a given tag in a profile:</p><pre class="sourcecodebox">
CMError CMSetProfileLocalizedStringDictionary
  (CMProfileRef prof, OSType tag, CFDictionaryRef dict);
</pre><p>prof - profile to modify</p><p>tag - tag type of profile to modify</p><p>dict - dictionary to modify</p><p>However, most applications will simply want to get one specific string out of a profile. For this reason, we provide the <code>CMCopyProfileLocalizedString</code> function:</p><pre class="sourcecodebox">
CMError CMCopyProfileLocalizedString (CMProfileRef  prof,
                                      OSType        tag,
                                      CFStringRef   reqLocale,
                                      CFStringRef*  locale,
                                      CFStringRef*  str);
</pre><p>prof - profile to query</p><p>tag - tag type of profile to query</p><p><code>reqLocale</code> - requested locale (optional</p><p>locale - returns locale (optional)</p><p>dict - returns dictionary string (optional)</p><p>Here's a short example showing how to use this function. We pass in the optional tag '<code>dscm</code>' plus &quot;<code>enUS</code>&quot; for the <code>reqLocale</code> parameter, looking for a U.S. Enlish string. If a U.S. English string is not found, ColorSync will fall back to a reasonable default:</p><pre class="sourcecodebox">
err = CMCopyProfileLocalizedString (prof, 'dscm', CFSTR(&quot;enUS&quot;), nil, &amp;theStr);
</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG84"></A><H3>ICC4 Profiles</H3><p>The ICC has been working on a new format for profiles to provide for more flexibility and power. This new format is the ICC 4.0 profile format specification. Some of the highlights include:</p><ul><li><p>New version in header</p></li></ul><p>to distinguish from earlier versions</p><ul><li><p>New MD5 (message digest) checksum in header</p></li></ul><p>to tell if two profiles are identical , or if a profile has changed over time. You can access this new MD5 checksum directly in the profile header, or alternately there is a new ColorSync API <code>CMGetProfileMD5</code>. The ColorSync API has the advantage that it works with both ICC 4 profiles and earlier profiles.</p><ul><li><p>New tag data types ('<code><code>mluc</code></code>', '<code>mBA</code> ', '<code><code>mAB</code></code> ', '<code>para</code>')</p></li></ul><p>These new tags really demonstrate the new power and flexibility of the ICC 4 profiles. One important note is some of your existing tags may now contain these new data formats e.g., '<code>A2B0</code>' may contain '<code>mft1</code>' or '<code><code>mAB</code></code> ' data. The good news is ColorSync and the Apple CMM will be fully ICC4 savvy. This means if your application does not parse profiles, but simply uses profile references for color matching, everything will &quot;just work&quot;. However, if your application creates of modifies profiles, you need to be aware of these new tag types to make sure you handle these cases correctly.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG4"></A><H2>CMMs in Mac OS X</H2><p>As with profiles, CMMs can also be installed in multiple locations. Typically, applications would install CMMs in:</p><p>/Library/ColorSync/CMMs</p><p>Also, users may install personal CMMs (for example, for debugging) in:</p><p>~/Library/ColorSync/CMMs</p><p>If your application would like to present a list of CMMs to the user, use the <code>CMMIterateCMMInfo</code> API. See <A HREF="tn1160.html">Technical Note TN1160, 'What's New With ColorSync 2.6'</A> for more information. This will give you information about all the CMMs installed on the system, including the default CMM.</p><A NAME="TNTAG85"></A><H3>Building CMMs</H3><p>CMMs in Mac OS X are <code>CFBundle</code> based, whereas on Mac OS 9 they are Component Manager based. See the <code>CFBundle</code> documentation for details on using these APIs to build your CMM as a <code>CFBundle</code>.</p><p>CMMs in Mac OS X still contain all the familiar entry points that exist for CMMs on Mac OS 9 such as <code>CMMOpen</code>, <code>CMMConcat</code>, <code>CMMMatchBitmap</code>, <code>CMMClose</code>, etc. However, Mac OS X CMMs now have a <code>CFBundle</code> wrapper around these entry points instead of a Component Manager wrapper.</p><p>The Apple CMM has undergone a lot of work to make sure it is finely tuned and integrated fully with Quartz to handle all the various profile types and image color spaces correctly. If you are writing your own CMM, make sure and test it thoroughly, and under a wide variety of cases to ensure it works in this environment.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG5"></A><H2>ColorSync Preferences and Supporting APIs</H2><p>Under Classic Mac OS, applications performing color management generally do not have knowledge of the various devices on the system. Because of this, applications would find it necessary to present some kind of interface to obtain device color information from the user. Similarly, applications performing color management on data with no associated profile would need to understand what type of device the data originated from. Again, this would require the application present some kind of interface to allow the user to select a default profile for a color space or document. Over time, users were becoming confused by the great myriad of different interfaces being presented by applications performing color management. ColorSync in Mac OS X is now aware of system devices, and the ColorSync user interface has been redesigned to take advantage of this information.</p><A NAME="TNTAG88"></A><H3>Profiles for Standard Color Spaces</H3><p>Documents can of course contain many different types of data. With this menu users can specify profiles for documents for different color spaces. Of course if the document does have a profile, this will take precedence, but often times documents don't have profiles associated with them. Users can retrieve this preference via the <code>CMGetDefaultProfileBySpace</code> API as follows:</p><pre class="sourcecodebox">
enum {
        cmXYZData = 'XYZ ',
        cmLabData = 'Lab ',
        cmRGBData = 'RGB ',
        cmSRGBData = 'sRGB',
        ...
    };

CMGetDefaultProfileBySpace ( OSType space, CMProfileRef* prof );
</pre><p>space - the color space</p><p>prof - returns the default profile for the specified color space</p><p>Here's sample code demonstrating how an application might benefit from these APIs. The sample accepts an image reference as an input and attempts to obtain information or data from this reference. The first thing an application should do when managing color for a document is to determine whether or not any embedded profile exists for the document. Most of the modern image formats have containers for profiles, so there are known ways to get profiles for documents in these formats. However, if there is no profile associated with the document, we can conveniently use the <code>CMGetDefaultProfileBySpace</code> API (after first obtaining the image color space) to get a reasonable default source profile for the document.</p><p>Next, we obtain a destination profile for the document. We can use the <code>CMGetDefaultProfileByUse</code> to get a destination profile. With both a source and destination profile we are now able to perform our color management - in this example, we use <code>NCWNewColorWorld</code> and <code>CWMatchBitMap</code>.</p><p>One important note regarding this example is the code shown here is appropriate for a Mac OS Classic or Carbon application running on Mac OS 9. In Mac OS X, much of the destination color management is done for you, so you don't need this matching if your application uses Quartz. However, you need to at least be aware of where the data is coming from, and if no profile is associated with it you can tag it using the ColorSync APIs.</p><p>ColorSync Prefs Code Sample</p><pre class="sourcecodebox">
CMError myMatchImage (myImageRef image)
{
    CMProfileRef source, dest;
    CMWorldRef cw;
    CMBitMap bm;

    source = myGetEmbeddedProfile (image);
    if (source == nil)
    {
        space = myGetColorImageSpace (image);
        err = CMGetDefaultProfileBySpace (space, &amp;source);
    }

    err = CMGetDefaultProfileByUse (cmDisplayUse, &amp;dest);
    err = NCWNewColorWorld (&amp;cw, source, dest);
    bm = myGetImageBitMap (image);
    err = CWMatchBitMap (cw, &amp;bm, ..., ..., ...);
...
</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG89"></A><H3>ColorSync Preferences Tidbits</H3><p>As with ColorSync 3.0 on Mac OS 9, ColorSync applications in Mac OS X can also launch the ColorSync control panel to solicit color choices, including default profiles for devices and documents, as well as the preferred CMM. Users can also switch between named collections of color settings called workflows.</p><p>To launch the ColorSync control panel from your application, simply call the following function:</p><pre class="sourcecodebox">
pascal CMError CMLaunchControlPanel (UInt32 flags);
</pre><p>flags - You must pass a value of 0 for this parameter. Future versions of ColorSync may define constants for the flags parameter to specify how the ColorSync control panel is launched.</p><p>function result - A result code of type CMError.</p><p>When your application calls the <code>CMLaunchControlPanel</code> routine, any changes made by the user will not be available (through calls such as <code>CMGetDefaultProfileBySpace</code>) until the user closes the ColorSync control panel. There is currently no ColorSync API for determining if the ColorSync control panel has been closed, though on Mac OS 9 you can use the Process Manager API for this purpose.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG96"></A><H3>ColorSync Preferences Summary</H3><p>Since all data is color managed by Quartz in Mac OS X, your application can participate simply by making sure your source and destination data is associated with a profile. Most applications can use the ColorSync Preferences APIs for color management, to get user's preferences. And these profile accessor APIs are extensible, a bridge to future device and color-space support. Lastly, the ColorSync Preferences APIs offer great flexibility in that applications can manage color from both document-centric and device-centric perspectives.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG6"></A><H2>ColorSync Device Support</H2><p>Mac OS X contains new device managers for input, display, and printing. This provides an opportunity for developers to integrate with ColorSync and provide both awareness of devices and access to their profiles. This new device support has been implemented with the following services:</p><ul><li><p>Device registration</p></li><li><p>Profile registration</p></li><li><p>Default Device and Default Profile accessors</p></li><li><p>Notification</p></li></ul><p>Device and Profile Registration:</p><p>ColorSync relies on the Device Managers to detect the presence of devices and to discover or build device profiles. The following are new ColorSync APIs which you can use to capture device and profile information:</p><p><strong>CMRegisterColorDevice</strong></p><pre class="sourcecodebox">
CMError
CMRegisterColorDevice(
  CMDeviceClass          deviceClass,
  CMDeviceID             deviceID,
  CFDictionaryRef        deviceName,
  const CMDeviceScope *  deviceScope);
</pre><p><strong>Parameters</strong></p><p>deviceClass</p><p>The class of the device (e.g., 'scnr', 'cmra', 'prtr', 'mntr')</p><p>deviceID</p><p>Unique identifier per class (Class + ID uniquely id's device)</p><p>deviceName</p><p>Name of the device.</p><p>deviceScope</p><p>Structure defining the user and host scope this device pertains to.</p><p>For a device to be recognized by ColorSync (and possibly other parts of MacOSX) it needs to register itself via this API. If the device has ColorSync profiles associated with it, it should identify those via the <code>CMSetFactoryDeviceProfiles</code> API, after registering with this API. Once a device is registered, it can appear as an input, output, or proofing device in ColorSync controls, as long as it has profiles associated with it. Registration need only happen once, when the device is installed. Device drivers need not register their device each time they are loaded.</p><p><strong>CMUnregisterColorDevice</strong></p><pre class="sourcecodebox">
CMError CMUnregisterColorDevice
(
 CMDeviceClass    deviceClass,
 CMDeviceID    deviceID
);
</pre><p><strong>Parameters</strong></p><p>deviceClass</p><p>The class of the device (e.g., 'scnr', 'cmra', 'prtr', 'mntr')</p><p>deviceID</p><p>Unique identifier per class (Class + ID uniquely id's device)</p><p>When a device is no longer to be used on a system (as opposed to being offline), it should be unregistered. If a device is temporarily shut down or disconnected, it need not be un-registered unless the device driver: a) &quot;knows&quot; that it will not be used (being de-installed) b) cannot access the device profiles without the device. If either of these are true, the device should be un-registered.</p><p><strong>CMSetFactoryDeviceProfiles</strong></p><pre class="sourcecodebox">
CMError CMSetFactoryDeviceProfiles
(
 CMDeviceClass        deviceClass,
 CMDeviceID        deviceID,
 CMDeviceProfileID    defaultID,
 const CMDeviceProfileArray*    deviceProfiles
);
</pre><p><strong>Parameters</strong></p><p>deviceClass</p><p>The class of the device (e.g., 'scnr', 'cmra', 'prtr', 'mntr')</p><p>deviceID</p><p>Unique identifier per class (Class + ID uniquely id's device)</p><p>defaultID</p><p>The id of the default profile for this device.</p><p>deviceProfiles</p><p>Ptr to caller's storage containing the profile array.</p><p>This API establishes the profiles used by a given device. It should be called after device registration to notify ColorSync of the device's profiles. Note that a distinction is made in the API between the &quot;factory&quot; device profiles and the current device profiles, since the latter may contain modifications to the factory set.</p><p>Default Devices and Default Profiles:</p><p>These new APIs for profiles and standard devices provide access to defaults, not just any device profile. When profiles are registered for a device, one is identified as the default for that device. However, over time, the user may change their settings. When a user changes settings, the default device or default profile may change, and ColorSync is made aware of such changes by the Device Managers. The Device Managers keep track of which device is default.</p><p>Here are some new APIs to manage default devices and profiles:</p><p><strong>CMSetDefaultDevice</strong></p><pre class="sourcecodebox">
CMError CMSetDefaultDevice
(
 CMDeviceClass    deviceClass,
 CMDeviceID    deviceID
);
</pre><p><strong>Parameters</strong></p><p>deviceClass</p><p>The class of the device (e.g., 'scnr', 'cmra', 'prtr', 'mntr')</p><p>deviceID</p><p>Unique identifier per class (Class + ID uniquely id's device)</p><p>For each class of device, a device management layer may establish which of the registered devices is the default. This helps keep color management choices to a minimum and allows for some &quot;automatic&quot; features to be enabled, e.g., &quot;Default printer&quot; as an output profile selection. If no such device (as specified by deviceClass and deviceID) has been registered, an error is returned.</p><p><strong>CMSetDeviceDefaultProfileID </strong></p><pre class="sourcecodebox">
CMError CMSetDeviceDefaultProfileID
(
 CMDeviceClass        deviceClass,
 CMDeviceID        deviceID,
 CMDeviceProfileID    defaultID
);
</pre><p>The default profile ID for a given device is an important piece of information because of the <code>CMGetProfileByUse</code> API. This API will return the default profile for devices depending on the user's selection in the ColorSync Control Panel. Device drivers and host software can get and set the default profile for a given device with this API.</p><p><strong>Parameters</strong></p><p>deviceClass</p><p>The class of the device (e.g., 'scnr', 'cmra', 'prtr', 'mntr')</p><p>deviceID</p><p>Unique identifier per class (Class + ID uniquely id's device)</p><p>defaultID</p><p>The id of the default profile for this device.</p><p>Calibration Support:</p><p>These new Device Managers in Mac OS X now make if possible for ColorSync to provide support for calibration. This is made possible by the data ColorSync is given for a profile by the Device Managers. Profiles are registered with an ID and a &quot;mode&quot; name (e.g., &quot;plain paper&quot;). Profiles are referenced during processing by ID. Such profiles can be customized by an application. For example a calibration application can get the factory profile for a given calibration mode, and then set a new profile (by ID) to be used for that mode.</p><p>Here are some new APIs supporting profile customization:</p><p><strong>CMGetDeviceFactoryProfiles</strong></p><pre class="sourcecodebox">
CMError CMGetDeviceFactoryProfiles
(
 CMDeviceClass        deviceClass,
 CMDeviceID        deviceID,
 CMDeviceProfileID*    defaultID,
 UInt32*        arraySize,
 CMDeviceProfileArray*    deviceProfiles
);
</pre><p>This API allows the caller to retrieve the original profiles for a given device. These may differ from the actual profiles in use for that device, in the case where any factory profiles have been replaced (updated). To get the actual profiles in use, call <code>CMGetDeviceProfiles</code>.</p><p>Parameters</p><p>deviceClass</p><p>The class of the device (e.g., 'scnr', 'cmra', 'prtr', 'mntr')</p><p>deviceID</p><p>Unique identifier per class (Class + ID uniquely id's device)</p><p>defaultID</p><p>Ptr to storage for the id of the default profile for this device.</p><p>arraySize</p><p>Ptr to storage for the size of the array to be returned. The caller may first call this routine to get the size returned, then call it again with the size of the buffer to receive the array.</p><p>deviceProfiles</p><p>Ptr to callers storage to receive the profile array. The caller may first pass NIL in this parameter to receive the size of the array in the arraySize parameter. Then, once the appropriate amount of storage has been allocated, a pointer to it can be passed in this parameter to have the array copied to that storage.</p><p><strong>CMSetDeviceProfiles </strong></p><pre class="sourcecodebox">
CMError
CMSetDeviceProfiles(
  CMDeviceClass                 deviceClass,
  CMDeviceID                    deviceID,
  const CMDeviceProfileScope *  profileScope,
  const CMDeviceProfileArray *  deviceProfiles);
</pre><p>This API provides a way to change the profile(s) used by a given device. It can be called after device registration by calibration applications to reset a device's profile(s) from factory defaults to calibrated profiles. In order for this call to be made successfully, the caller must pass the <code>CMDeviceClass</code> and <code>CMDeviceID</code> device being calibrated. (Device selection and identification can be facilitated via the <code>CMIterateColorDevices</code>() API). If an invalid <code>CMDeviceClass</code> or <code>CMDeviceID</code> is passed, an error (<code>CMInvalidDeviceClass</code> or <code>CMInvalidDeviceID</code>) is returned.</p><p><strong>Parameters</strong></p><p>deviceClass</p><p>The class of the device (e.g., 'scnr', 'cmra', 'prtr', 'mntr')</p><p>deviceID</p><p>Unique identifier per class (Class + ID uniquely id's device)</p><p>profileScope</p><p>Structure defining the scope these profiles pertain to.</p><p>deviceProfiles</p><p>Ptr to caller's storage containing the profile array which contains replacements for the factory profiles. Not all the original profiles must be replaced with this call. Therefore the array can contain as few as 1 profile and as many as there were in the factory array if they are all to be replaced. Profiles are repaced by ID.</p><p><strong>CMSetDeviceProfile</strong></p><pre class="sourcecodebox">
CMError
CMSetDeviceProfile(
  CMDeviceClass                 deviceClass,
  CMDeviceID                    deviceID,
  const CMDeviceProfileScope *  profileScope,
  CMDeviceProfileID             profileID,
  const CMProfileLocation *     deviceProfLoc);
</pre><p>This API provides a way to change a profile used by a given device by ID. It can be called after device registration by calibration applications to reset a device's profile from factory defaults to calibrated profiles. In order for this call to be made successfully, the caller must pass the <code>CMDeviceClass</code> and <code>CMDeviceID</code> of the device being calibrated along with the CMDeviceProfileID of the profile to set. (Device selection and identification can be facilitated via the <code>CMIterateColorDevices</code>() API). If an invalid <code>CMDeviceClass</code> or <code>CMDeviceID</code> is passed, an error (<code>CMInvalidDeviceClass</code> or <code>CMInvalidDeviceID</code>() is returned.</p><p><strong>Parameters</strong></p><p>deviceClass</p><p>The class of the device (e.g., 'scnr', 'cmra', 'prtr', 'mntr')</p><p>deviceID</p><p>Unique identifier per class (Class + ID uniquely id's device)</p><p>profileScope</p><p>Structure defining the scope these profiles pertain to.</p><p>profileID</p><p>The id of the default profile for this device.</p><p>deviceProfLoc</p><p>Ptr to storage for the CMProfileLocation of the profile. Since this structure is a fixed length structure, the caller can simply pass a ptr to a stack-based structure or memory allocated for it.</p><A NAME="TNTAG99"></A><H3>Notifications</H3><p>Applications now can be made aware of changes to devices on their system. ColorSync will post notifications to a distributed notification center (check the Cocoa and Core Foundation documentation for additional details on distributed notification centers). Any process on the system which registers with a distributed center will receive these notifications. Here's some of the available notifications:</p><ul><li><p>Changes to the default device for a device class</p></li><li><p>Changes to a device's factory or custom profiles</p></li><li><p>Changes to a device's default profile</p></li><li><p>Device registration/un-registration</p></li><li><p>Changes to any of the settings in the ColorSync Preferences (for example, if the user changes the preferred CMM)</p></li></ul><p>There are no ColorSync APIs to register to receive the above notifications - ColorSync only posts these notifications to the distributed center. Instead, use the following Cocoa and Core Foundation APIs to receive the above notifications:</p><pre class="sourcecodebox">
CFNotificationCenterAddObserver
NSDistributedNotificationCenter
</pre><p>Here's the specific notification strings (from the ColorSync interface file CMDeviceIntegration.h) which you can use with the above functions:</p><pre class="sourcecodebox">
#define  kCMDeviceRegisteredNotification   CFSTR(&quot;CMDeviceRegisteredNotification&quot;)
#define  kCMDeviceUnregisteredNotification  CFSTR(&quot;CMDeviceUnregisteredNotification&quot;)
#define  kCMDeviceOnlineNotification  CFSTR(&quot;CMDeviceOnlineNotification&quot;)
#define  kCMDeviceOfflineNotification  CFSTR(&quot;CMDeviceOfflineNotification&quot;)
#define  kCMDeviceStateNotification   CFSTR(&quot;CMDeviceStateNotification&quot;)
#define  kCMDefaultDeviceNotification  CFSTR(&quot;CMDefaultDeviceNotification&quot;)
#define  kCMDeviceProfilesNotification  CFSTR(&quot;CMDeviceProfilesNotification&quot;)
#define  kCMDefaultDeviceProfileNotification
                            CFSTR(&quot;CMDefaultDeviceProfileNotification&quot;)
#define  kCMPrefsChangeDeviceNotification
                            CFSTR(&quot;AppleColorSyncPreferencesChangedNotification&quot;)
</pre><p>To demonstrate how the general notification mechanism works, here's a code snippet written in Cocoa showing how you can get notified when the display profile changes. First, register with the default distributed notification center to receive the necessary ColorSync device notifications. Then, when the notification is received, simply call <code>CMGetDefaultProfileByUse</code> to determine the current setting for the display profile:</p><pre class="sourcecodebox">
-(void)registerNotifications
{
    NSDistributedNotificationCenter *center;

    center = [NSDistributedNotificationCenter defaultCenter];

    [center addObserver:self
               selector:@selector(notification:)
                   name:kCMDeviceUnregisteredNotification
                 object:nil];
    [center addObserver:self
               selector:@selector(notification:)
                   name:kCMDefaultDeviceNotification
                 object:nil];
    [center addObserver:self
               selector:@selector(notification:)
                   name:kCMDeviceProfilesNotification
                 object:nil];
    [center addObserver:self
               selector:@selector(notification:)
                   name:kCMDefaultDeviceProfileNotification
                 object:nil];
}
-(void)notification:(NSNotification *)note
{
   CMError err = CMGetDefaultProfileByUse(cmDisplayUse, &amp;gProfRef);
}
</pre><p>Similar code to check for profile changes could be written using the Mac OS X Core Foundation distributed notifications (using NSDistributedNotificationCenter, etc.). Check the Mac OS X Core Foundation documentation for additional information.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG97"></A><H3>ColorSync Device Support Summary</H3><p>ColorSync is now integrated with Device Managers. Applications have access to the default profiles for standard devices (input, display, output) via the new ColorSync preferences APIs. Applications can get more specific profile information for registered devices from these APIs. Calibration is now supported in ColorSync plus new notification services are now provided.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG32"></A><H2>Color Management in Printing</H2><p>A very important aspect of color management in Mac OS X is color management in the printing system. Printing in Mac OS X consists of two main components: the front end and the back end. The main role of the front end is to choose the printer, get the necessary print options and spool the print job into PDF.</p><p>The main role of the back end is to convert the spooled PDF into an appropriate format for the printer.</p><p>If we take a closer look at the printing front end we notice all color data in the spooled PDF is tagged with profiles. By definition, no printer specific color conversions are done at the front end, but it's important to note the printing system will consult the ColorSync Device Integration database and extract the profile matching the current printing conditions.</p><p>What happens at the back end depends on the type of printer in use.</p><p>For raster printers, the spooled PDF is rasterized and the color data is converted into the printer profile. This is accomplished by extracting the printer profile from the print job. If none exist, the printing system will provide a default profile so matching can occur.</p><p>For PostScript printers, there are two options: the first is traditional color matching in the printer. For this option, all the profiles from the spooled PDF are converted into PostScript CSAs.</p><A NAME="TNTAG33"></A><H3>Color Matching On The Host by ColorSync</H3><p>There's an option for doing color matching on the computer using ColorSync. In this case, as with raster printing, profiles are retrieved from the print job. If none exist, the printing system will provide a default profile so color matching can occur.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG34"></A><H3>cupsICCProfile PPD Declaration Entry</H3><p>CUPS PostScript and raster drivers may use the <code>cupsICCProfile</code> keyword to specify the various modes for a device along with the profiles for each mode. The format for this entry is as follows:</p><p class="smalltext"><strong>Listing 1:</strong> New PPD declaration entry.</p><pre class="sourcecodebox">
*cupsICCProfile {mode specifier} {profile specifier}
</pre><p>where the mode specifier is the concatenation of three fields: color model, media type and resolution. Any of these fields can be omitted to signify any model/media/resolution. The profile specifier is the profile standard file path relative to /usr/share/cups/profiles/.</p><p>Here's an example showing a PostScript printer PPD file that is registering two modes: one for 600 X 600 dpi and one for 1200 X 1200 dpi, followed by the profile specifier:</p><p class="smalltext"><strong>Listing 2:</strong> Example PostScript PPD file registering two modes.</p><pre class="sourcecodebox">
*%========================
*% Device capabilities
*%========================


*ColorDevice: True


*DefaultColorSpace: CMYK


*cupsICCProfile ..600x600dpi &quot;cmykProfile600dpi.icc&quot;
*cupsICCProfile ..1200x1200dpi &quot;cmykProfile1200dpi.icc&quot;
</pre><p><A HREF="../../qa/qa2004/qa1352.html">Technical Q&amp;A QA1352, 'New PPD keywords available in Mac OS X version 10.3'</A> describes this new PPD keyword in detail as well.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG35"></A><H2>Quartz Filters</H2><p>Quartz filters are an optional component in the Quartz imaging and color-matching pipeline which allow you to associate a sequence of imaging or color correction operations with a single drawing. Filters may act on all drawing operations or only on a specified set. They can be configured to perform specialized imaging or color operations. They may be defined and saved in XML.</p><p>Here's a diagram showing how the Quartz filter component fits into the overall Quartz architecture:</p><p class="caption"><strong>Figure 14:</strong> Quartz Filter Component in the Quartz Architecture.</p><p><img  src="images/tn2035_27.jpg" width="420" height="316" alt="Figure 14, Quartz Filter Component in the Quartz Architecture."></p><p>Quartz filters are currently available only through the various Mac OS X system-built utilities and applications. However, a new set of API's will be forthcoming.</p><A NAME="TNTAG36"></A><H3>Demos of Quartz filters</H3><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG37"></A><H3>Soft-Proofing</H3><p>Soft-proofing via Quartz filters is possible from the print dialog. Simply click the &quot;Preview&quot; button in the print dialog and in the Preview window you'll now see a check box titled &quot;Soft Proof&quot; in the lower-left corner of the window. Here's how it looks:</p><p class="caption"><strong>Figure 15:</strong> Soft-proofing feature.</p><p><img  src="images/tn2035_28.jpg" width="681" height="582" alt="Figure 15, Soft-proofing feature."></p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG38"></A><H3>Print dialog</H3><p>Notice the above image is very dark. This can be corrected using the ColorSync printer dialog extension (PDE).</p><p>To access the ColorSync PDE, open the print dialog, click the &quot;Advanced&quot; button, then in the resulting dialog look for the item &quot;ColorSync&quot; in the popup menu list:</p><p class="caption"><strong>Figure 16:</strong> ColorSync PDE.</p><p><img  src="images/tn2035_29.jpg" width="638" height="504" alt="Figure 16, ColorSync PDE."></p><p>The ColorSync PDE allows PostScript printers to choose which color-matching option to use via the &quot;Color Conversion&quot; popup menu. Select either&quot;Standard&quot; or &quot;In Printer&quot;:</p><p class="caption"><strong>Figure 17:</strong> Color conversion selection.</p><p><img  src="images/tn2035_30.jpg" width="637" height="502" alt="Figure 17, Color conversion selection."></p><p>Using the Color Conversion options it's possible to perform color-matching on the computer using the printer profile (&quot;Standard&quot;), or fall-back to traditional color matching in the printing path (&quot;In Printer&quot;).</p><p>Finally, at the bottom of the &quot;Quartz Filter&quot; menu in the ColorSync PDE there is an option to add Quartz filters when printing,:</p><p class="caption"><strong>Figure 18:</strong> Quartz filters menu option.</p><p><img  src="images/tn2035_31.jpg" width="638" height="500" alt="Figure 18, Quartz filters menu option."></p><p>Select this option and the document is spooled to PDF and sent along with the &quot;open&quot; ('<code>oapp</code>') AppleEvent to the ColorSync Utility, which opens the document with the filter inspector window as shown below:</p><p class="caption"><strong>Figure 19:</strong> Filter inspector window.</p><p><img  src="images/tn2035_32.jpg" width="634" height="551" alt="Figure 19, Filter inspector window."></p><p>If you click any of the filters in the list and also click the &quot;Preview&quot; check box you can see the results of applying the selected filter. You can add and remove filters by clicking the &quot;New&quot; and &quot;Delete&quot; buttons.</p><p>For each filter there are a number of different options which you can manage. These are:</p><ul><li><p>Color - options for converting color</p></li><li><p>Default profiles</p></li><li><p>Image sampling/compression/convolution</p></li><li><p>Filter domain</p></li><li><p>PDF parameters</p></li></ul><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG39"></A><H2>ColorSync Utility</H2><A NAME="TNTAG43"></A><H3>ColorSync Preferences</H3><p>The ColorSync Preferences are part of ColorSync Utility (previously they were in the System Preferences). This makes ColorSync Utility the &quot;one-stop shopping&quot; center for all the ColorSync related settings.</p><p>It's well known many applications may provide a button in their program's user interface to send users to the ColorSync preferences. This is usually accomplished by calling the <code>CMLaunchColorSyncPreferences</code> function. Applications which use this function will continue to work. This function will simply launch the ColorSync Utility instead.</p><A NAME="TNTAG44"></A><H4>Quartz Filter Support</H4><p>Users can access Quartz filters from the ColorSync Utility. For more information on Quartz filters, see <A HREF="#TNTAG35">Quartz Filters</A>.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG45"></A><H3>Administration Features</H3><p>ColorSync Utility contains administration features which allow the system administrator user to specify the default profiles for other users on the same machine.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG46"></A><H3>3D View Options for Profile Viewer</H3><p>The 3D profile viewer in ColorSync Utility has a contextual menu to allow you to view the profile in a number of different color spaces such as Lab, Luv, Yxy and others. Here's how it looks:</p><p class="caption"><strong>Figure 20:</strong> 3D viewer contextual menu.</p><p><img  src="images/tn2035_33.jpg" width="599" height="503" alt="Figure 20, 3D viewer contextual menu."></p><p>You can also use the profile viewer to compare the gamut of two profiles. A contextual menu item &quot;Hold for comparison&quot; allows you to specify the first of a pair of profiles to use for comparison. Simply control-click on a profile in the viewer pane to bring up the contextual menu, then select &quot;Hold for comparison&quot;. The profile will lighten in color to indicated it has been selected as shown here:</p><p class="caption"><strong>Figure 21:</strong> Hold for comparison menu item.</p><p><img  src="images/tn2035_34.jpg" width="600" height="502" alt="Figure 21, Hold for comparison menu item."></p><p>Now select another profile from the list and the viewer pane will show both profiles together along with any overlap.</p><p class="caption"><strong>Figure 22:</strong> Comparing the gamut of two profiles.</p><p><img  src="images/tn2035_35.jpg" width="599" height="503" alt="Figure 22, Comparing the gamut of two profiles."></p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG47"></A><H2>ColorSync and OpenGL</H2><p>ColorSync and OpenGL can be used to perform real-time color correction and enhancement of video. In the past, this was only possible on very high-end hardware, but now it can be done on desktop machines due to the availability of high performance video cards.</p><p>Many modern video cards have support for per-pixel 3d texture lookup. This is currently available on the following video cards:</p><ul><li><p>nVidia GeoForce TI</p></li><li><p>ATI Radeon 9000 series</p></li></ul><p>By loading color correction transformations into these tables, you can accomplish real-time color correction. This is quite powerful, and it demonstrates the integration of all the graphics technologies available in Mac OS X. It combines the advantages and powers of ColorSync, OpenGL, QuickTime and Quartz.</p><p>The way this works is QuickTime content is played on a Quartz OpenGL surface, and attached to that surface is a 3D texture built from a ColorSync color world reference.</p><p>In order to make it easier for applications to do this, some APIs were added to ColorSync. The first is <code>CMMakeProfile</code>. This is a general purpose function which allows you to create a ColorSync profile given a <code>CFDictionary</code> of attributes. For example, you can use this API to create an abstract profile to perform hue rotation, set contrast, and so on. You can also use this API to create standard RGB profiles.</p><p>Here's the definition for the <code>CMMakeProfile</code> function:</p><p><strong><code>CMMakeProfile</code></strong></p><pre class="sourcecodebox">
CMMakeProfile

CMError CMMakeProfile(CMProfileRef prof,
                      CFDictionaryRef spec)
</pre><p><strong>Description</strong></p><p>Adds appropriate tags to a profile to make display or abstract profile based on an specification dictionary.</p><p><strong>Parameters</strong></p><p>prof(in/out)</p><p>the profile to modify</p><p>spec(in)</p><p>specification dictionary</p><p>One key in the specification dictionary must be &quot;<code><code>profileType</code></code>&quot; which must have a <code>CFString</code> value of &quot;<code>abstractLab</code>&quot;, &quot;<code>displayRGB</code>&quot; or &quot;<code>displayID</code>&quot;. It can also contain the keys/values:</p><p>&quot;<code>description</code>&quot; <code>CFString</code> (optional)</p><p>&quot;<code>copyright</code>&quot; <code>CFString</code> (optional)</p><p>For <code><code>profileType</code></code> of &quot;<code>abstractLab</code>&quot;, the dictionary should also contain the keys/values:</p><p>&quot;<code>gridPoints</code>&quot; <code>CFNumber</code>(<code>SInt32</code>) (should be odd)</p><p>&quot;<code>proc</code>&quot; <code>CFNumber</code>(SInt64)</p><p>(coerced from a <code>LabToLabProcPtr</code>)</p><p>&quot;<code>refcon</code>&quot; <code>CFNumber</code>(SInt64) (optional)</p><p>(coerced from a void)</p><p>For <code><code>profileType</code></code> of &quot;<code>displayRGB</code>&quot;, the dictionary should also contain the keys/values:</p><p>&quot;<code>targetGamma</code>&quot; <code>CFNumber</code>(<code>Float</code>) (e.g. 1.8) (optional)</p><p>&quot;<code>targetWhite</code>&quot; <code>CFNumber</code>(<code>SInt32</code>) (e.g. 6500) (optional)</p><p>&quot;<code>gammaR</code>&quot; <code>CFNumber</code>(<code>Float</code>) (e.g. 2.5)</p><p>&quot;<code>gammaG</code>&quot; <code>CFNumber</code>(<code>Float</code>) (e.g. 2.5)</p><p>&quot;<code>gammaB</code>&quot; <code>CFNumber</code>(<code>Float</code>) (e.g. 2.5)</p><p>&quot;<code>tableChans</code>&quot; <code>CFNumber</code>(<code>SInt32</code>) (1 or 3) (optional)</p><p>&quot;<code>tableEntries</code>&quot; <code>CFNumber</code>(<code>SInt32</code>) (e.g 16 or 255) (optional)</p><p>&quot;<code>tableEntrySize</code>&quot; <code>CFNumber</code>(<code>SInt32</code>) (1 or 2) (optional)</p><p>&quot;<code>tableData</code>&quot; <code><code>CFData</code></code> (lut in RRRGGGBBB order) (optional)</p><p>either</p><p>&quot;<code>phosphorRx</code>&quot; <code>CFNumber</code>(<code>Float</code>)</p><p>&quot;<code>phosphorRy</code>&quot; <code>CFNumber</code>(<code>Float</code>)</p><p>&quot;<code>phosphorGx</code>&quot; <code>CFNumber</code>(<code>Float</code>)</p><p>&quot;<code>phosphorGy</code>&quot; <code>CFNumber</code>(<code>Float</code>)</p><p>&quot;<code>phosphorBx</code>&quot; <code>CFNumber</code>(<code>Float</code>)</p><p>&quot;<code>phosphorBy</code>&quot; <code>CFNumber</code>(<code>Float</code>)</p><p>or</p><p>&quot;<code>phosphorSet</code>&quot; <code>CFString</code> (&quot;<code>WideRGB</code>&quot;, &quot;700/525/450nm&quot;,</p><p>&quot;<code>P22-EBU</code>&quot;, &quot;<code>HDTV</code>&quot;, &quot;<code>CCIR709</code>&quot;, &quot;<code>sRGB</code>&quot;,</p><p>&quot;<code>AdobeRGB98</code>&quot; or &quot;<code>Trinitron</code>&quot;)</p><p>either</p><p>&quot;<code>whitePointx</code>&quot; <code>CFNumber</code>(<code>Float</code>)</p><p>&quot;<code>whitePointy</code>&quot; <code>CFNumber</code>(<code>Float</code>)</p><p>or</p><p>&quot;<code>whiteTemp</code>&quot; <code>CFNumber</code>(<code>SInt32</code>) (e.g. 5000, 6500, 9300)</p><p>For <code><code>profileType</code></code> of &quot;<code>displayID</code>&quot;, the dictionary should also contain the keys/values:</p><p>&quot;<code>targetGamma</code>&quot; <code>CFNumber</code>(<code>Float</code>) (e.g. 1.8) (optional)</p><p>&quot;<code>targetWhite</code>&quot; <code>CFNumber</code>(<code>SInt32</code>) (e.g. 6500) (optional)</p><p>&quot;<code>displayID</code> <code>CFNumber</code>(<code>SInt32</code>)</p><p>Optionally, the keys/values for &quot;<code>displayRGB</code>&quot; can be provided to override the values from the display.</p><p>Here's a short code snippet showing how to use <code>CMMakeProfile</code> to make an abstract profile:</p><pre class="sourcecodebox">
void myLabToLabProc(float* L, float* a, float* b, void* refcon)
{
    float angle = *(float*)refcon;
    float aa = (*a), bb = (*b);
    *a = aa*cos(angle) - bb*sin(angle);
    *b = aa*sin(angle) + bb*cos(angle);
}

void makeAbstractWithAngle (CMProfileRef prof, float angle)
{
    CFDictionaryRef dict;
    SInt64 cb64, rc64;
    SInt32 gridPoints;
    CFStringRef keys[4];
    CFTypeRef vals[4];
    CMError cmErr;

    keys[0] = CFSTR(&quot;profileType&quot;);
    vals[0]= CFSTR(&quot;abstractLab&quot;);

    gridPoints = 33;
    keys[1] = CFSTR(&quot;gridPoints&quot;);
    vals[1]= CFNumberCreate(0, kCFNumberSInt32Type, &amp;gridPoints);

    cb64 = (SInt64) myLabToLabProc;
    keys[2] = CFSTR(&quot;proc&quot;);
    vals[2]= CFNumberCreate(0, kCFNumberSInt64Type, &amp;cb64);

    rc64 = (SInt64) &amp;angle;
    keys[3] = CFSTR(&quot;refcon&quot;);
    vals[3]= CFNumberCreate(0, kCFNumberSInt64Type, &amp;rc64);

    dict = CFDictionaryCreate(nil, keys, vals, 4,
                &amp;kCFTypeDictionaryKeyCallBacks,
                &amp;kCFTypeDictionaryValueCallBacks);

    cmErr = CMMakeProfile(prof, dict);

    CFRelease(vals[1]); CFRelease(vals[2]); CFRelease(vals[3]);
    CFRelease(dict);
}
</pre><p>The second API added to support the real-time color correction of video is <code>CWFillLookupTexture</code>. This API fills a 3D lookup texture from a colorworld. The resulting table is suitable for use in OpenGL to accelerate color management in hardware.</p><p>Here's the formal definition for <code>CWFillLookupTexture</code>:</p><p><code>CWFillLookupTexture</code></p><pre class="sourcecodebox">
CWFillLookupTexture

          CMError CWFillLookupTexture( CMWorldRef cw,
                                       UInt32 gridPoints,
                                       UInt32 format,
                                       UInt32 dataSize,
                                       void * data)
</pre><p><strong>Description</strong></p><p>This API fills a 3D lookup texture from a colorworld. The resulting table is suitable for use in OpenGL to accelerate color management in hardware.</p><p><strong>Parameters</strong></p><p>cw (in)</p><p>the colorworld to use</p><p><code>gridPoints</code> (in)</p><p>number of grid points per channel in the texture</p><p>format (in)</p><p>format of pixels in texture (e.g. <code>cmTextureRGBtoRGBX8</code>)</p><p>dataSize (in)</p><p>size in bytes of texture data to fill</p><p>data (in/out)</p><p>pointer to texture data to fill</p><p>Here's a short code snippet showing how to use <code>CWFillLookupTexture</code>:</p><pre class="sourcecodebox">
void* make_3d_texture(CMProfileRef src, CMProfileRef abs, CMProfileRef dst)
{
    UInt32 size, grid = 9, fmt = cmTextureRGBtoRGBX8;
    CMWorldRef cw;
    void* data;
    CMError err;

    cw = make_colorworld(src, abs, dst);
    err = CWFillLookupTexture(cw, grid, fmt, &amp;size, nil);
    data = malloc(size);
    err = CWFillLookupTexture(cw, grid, fmt, &amp;size, &amp;data);

    return data;
}
</pre><p>Also, sample code is available in the Mac OS X Developer Tools which demonstrates the use of the above-mentioned APIs to perform real-time color correction. Download and install the Mac OS X Developer Tools and look for the &quot;ColorWhirled&quot; sample here :</p><p>/Developer/Examples/ColorSync/ColorWhirled</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG31"></A><H2>ColorSync And QuickTime</H2><p>QuickTime 6.4 introduces new graphics importer functions such as <code>GraphicsImportSetDestinationColorSyncProfileRef</code> that provide support for ColorSync in Mac OS X. These functions make ColorSync matching the default behavior for native applications that use graphics importers, that is, for image files with embedded ColorSync profiles and for image files with CMYK image data, with or without embedded ColorSync profiles.</p><p>An opt-out flag is provided for applications that call ColorSync directly.</p><p>For a complete list of these new functions, see the <A HREF="../../documentation/QuickTime/WhatsNewQT6_4/index.html">What's New in QuickTime 6.4 document</A>.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG23"></A><H2>ColorSync And Image Capture</H2><p>By default, Image Capture will register a Generic camera profile for all devices, so all downloaded images will be assigned a profile. Optionally, you may specify a profile to be embedded in images you download or scan.  Use the <code>ICADownloadFile</code> function along with the <code>kEmbedColorSyncProfile</code> flag.</p><p>See the <A HREF="../../sdk/">Image Capture SDK</A> for more details.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG49"></A><H2>Display Calibration</H2><p>Display calibration gives the user the ability to automatically generate profiles for the display, and to calibrate the display in an easy to use fashion. Display calibration is performed by clicking the &quot;Calibrate&quot; button in the Display preferences (found in the System Preferences).</p><p>Normally, this button will simply launch the Apple calibrator. However, this architecture supports third-party calibrators as well.</p><p>There's a few simple modifications you'll need to make to your calibrator for it to be recognized by ColorSync. Here's a quick summary:</p><A NAME="TNTAG56"></A><H3>Support for your calibrator</H3><ul><li><p>Build your Carbon or Cocoa calibration application as you would normally</p></li><li><p>Add new <code>CSDisplayCalibrator</code> key to the Info.plist</p></li><li><p>Support a new optional property in the '<code>oapp</code>' AppleEvent</p></li><li><p>Install your calibrator (or a symlink to it) in /Library/ColorSync/Calibrators/</p></li></ul><p>To get you started, there's an example calibrator that's installed with the Developer Tools in:</p><p>/Developer/Examples/ColorSync/</p><p>Look for the project &quot;DemoCalibrator&quot;. This sample code demonstrates how to make the above modifications to a calibrator. Use this sample as a starting point for your calibrator.</p><p>To see how this works, build the demo calibrator and install the built executable into /Library/ColorSync/Calibrators/. Now go to the Display Preferences (in the System Preferences), click the &quot;Color&quot; tab and click the &quot;Calibrate&quot; button. This will bring up a new dialog that allows the user to choose which of the installed calibrators to use. Here's how the dialog looks:</p><p class="caption"><strong>Figure 23:</strong> Dialog for choosing a Calibrator.</p><p><img  src="images/tn2035_36.jpg" width="330" height="320" alt="Figure 23, Dialog for choosing a Calibrator."></p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG57"></A><H3>Apple Calibrator Expert Mode</H3><p>An expert mode is available for the Apple calibrator. To see this in action, go to the Display Preferences, click the &quot;Color&quot; tab, then click the &quot;Calibrate&quot; button and finally select the &quot;Display Calibrator&quot; (the Apple calibrator) in the list. Now click the &quot;Calibrate&quot; button and in the resulting window click the expert mode check box to turn on expert mode.</p><p>The Apple calibrator has the ability to show single-patch, and the ability to adjust the tint/brightness control, which allows for much finer control. This was necessary because it's very hard for users to adjust blue gamma as it is less visible to the human eye.</p><p>The Apple calibrator also allows for multiple steps. This means in addition to adjusting mid-tones, you can adjust highlights, shadows and dark shadows. This will result in good calibration on LCD displays, which have complex gamma curves.</p><p>The Apple calibrator also allows the calibration profile to be used by other users on the same machine.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG58"></A><H2>SIPS</H2><p>SIPS stands for: Scriptable Image Processing System. SIPS was created because it was determined there was a need for a tool which would perform many common operations on image files in a scriptable manner.</p><p>As it stands, there are a number of existing technologies which provide for manipulations of images. For example, ColorSync Scripting can perform many ColorSync operations such as color-matching of images, but it can't rotate, scale or convert formats. Image Capture Scripting can rotate and scale images, but it can't color match or convert formats. Finally, the Preview application can rotate, scale and covert formats, but it is not Apple-scriptable.</p><p>SIPS brings all these different technologies together to provide a single tool with which to perform common operations on images. The current feature set for SIPS includes:</p><ul><li><p>Read, write or convert different raster image formats</p></li><li><p>jpeg (Jfif &amp; Xiff), TIFF, GIF, PNG</p></li><li><p>Basic image operations</p></li><li><p>Rotate, flip, crop, pad, resample, change dpi</p></li><li><p>Color management operations</p></li><li><p>Embed, extract or match to profiles</p></li><li><p>Read or write known metadata tags</p></li><li><p>Preserve original content whenever possible</p></li></ul><p>Possible features for future releases of SIPS include:</p><ul><li><p>Support for complex formats</p></li><li><p>Multilayer, multipage or vector-based</p></li><li><p>Advanced image operations</p></li><li><p>Blur, sharpen, ehnance, etc.</p></li><li><p>Read or write any metadata tag (list of metadata tags is always increasing, contact dts@apple.com to suggest additional tags)</p></li></ul><p>SIPS is currently implemented as a simple compiled tool, which is installed in /usr/bin/sips. It links against CoreGraphics, QuickTime and ColorSync. It can operate on one or more file at a time. It can query or modify images or profiles. SIPS queries can return properties in simple text form or in XML form. Actions can modify files in-place or to an output directory.</p><p>Because SIPS is a simple command line tool there's lots of ways to use it. It can be invoked from the terminal shell, from AppleScript, from other scripting languages or from an application using C code (AppKit or Posix calls).</p><p>For example, open the Terminal and type <code>sips --help</code>. This will give the help page for SIPS (a standard man page will be forthcoming). Here's the output you'll see:</p><pre class="sourcecodebox">
$ sips --help

sips 1.0 - scriptable image processing system.
This tool is used to query or modify raster image files and ColorSync ICC profiles.
Its functionality can also be used through the &quot;Image Events&quot; AppleScript suite.
Usages:
sips [-h, --help]
sips [-H, --helpProperties]
sips [image query functions] imagefile(s)
sips [profile query functions] profile(s)
sips [image modification functions] imagefile(s)
[--out outimage | --out outdir]
sips [profile modification functions] profile(s)
[--out outprofile | --out outdir] Profile query functions:
-g, --getProperty key
-X, --extractTag tag tagFile
-v, --verify
Image query functions:
-g, --getProperty key
-x, --extractProfile profile
Profile modification functions:
-s, --setProperty key value
-d, --deleteProperty key
--deleteTag tag
--copyTag srcTag dstTag
--loadTag tag tagFile
--repair
Image modification functions:
-s, --setProperty key value
-d, --deleteProperty key
-e, --embedProfile profile
-E, --embedProfileIfNone profile
-m, --matchTo profile
-M, --matchToWithIntent profile intent
-r, --rotate degreesCW
-f, --flip horizontal|vertical
-c, --cropToHeightWidth pixelsH pixelsW
-p, --padToHeightWidth pixelsH pixelsW
-z, --resampleHeightWidth pixelsH pixelsW
--resampleWidth pixelsW
--resampleHeight pixelsH
-Z, --resampleHeightWidthMax pixelsWH
-i, --addIcon
</pre><p>Here's an example of a simple SIPS command to rotate an image 30 degrees:</p><pre class="sourcecodebox">
$sips -r 30 /Users/steve/image.JPG
</pre><p>Here's an example of a simple SIPS command to get an image property (the image height).</p><p>First, get a list of the available image properties with the <code>--helpProperties</code> command:</p><pre class="sourcecodebox">
$sips --helpProperties

  Special properties:
    all                  binary data
    allxml               binary data
  Image properties:
    dpiHeight            float
    dpiWidth             float
    pixelHeight          integer (read-only)
    pixelWidth           integer (read-only)
    format               string  jpeg | tiff | png | gif | jp2 | pict | bmp | qtif | psd
    formatOptions        string  default | [low|normal|high] | packbits
    space                string  (read-only)
    samplesPerPixel      integer (read-only)
    bitsPerSample        integer (read-only)
    creation             string  (read-only)
    make                 string
    model                string
    software             string  (read-only)
    description          string
    copyright            string
    artist               string
    profile              binary data
  Profile properties:
    description          utf8 string
    size                 integer (read-only)
    cmm                  string
    version              string
    class                string  (read-only)
    space                string  (read-only)
    pcs                  string  (read-only)
    creation             string
    platform             string
    quality              string  normal | draft | best
    deviceManufacturer   string
    deviceModel          integer
    deviceAttributes0    integer
    deviceAttributes1    integer
    renderingIntent      string  perceptual | relative | satuation | absolute
    creator              string
    copyright            string
    md5                  string  (read-only)
</pre><p>Then, issue the command using the image property qualifier:</p><pre class="sourcecodebox">
$ sips -g dpiHeight image.JPG

image.JPG
  dpiHeight: 216.000
</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG24"></A><H2>ColorSync changes for Mac OS X 10.4 Tiger</H2><A NAME="TNTAG30"></A><H3>Floating Point Support</H3><p>One of the goals of Tiger was to provide a new high fidelity, cinematic graphical environment. In order to achieve this, full floating point support was needed throughout the entire operating system, with ColorSync as one of the key components.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG48"></A><H3>New structure: CMFloatBitmap</H3><p>To provide for this new graphical environment, ColorSync has introduced a new bitmap structure <code>CMFloatBitmap</code> to support arbitrary bitmaps and floating point data. One of the design goals for this structure was to make it as flexible as possible so developers would not be required to re-pack the data before passing it to ColorSync.</p><p class="smalltext"><strong>Listing 3:</strong> CMFloatBitmap structure.</p><pre class="sourcecodebox">
/*
 *  CMFloatBitmap
 *
 *  Summary:
 *    A new structure that defines and arbitrary map of float color
 *    values.
 *
 *  Discussion:
 *    The structure defines a pixel array of dimensions
 *    [height][width][chans] where 'chans' is the number of channels in
 *    the colorspace plus an optional one for alpha. The actual memory
 *    pointed to by the structure can contain a variety of possible
 *    arrangements. The actual data values can be chunky or planar.
 *    The channels can by in any order.
 *
 *    Examples:
 *    a) float* p contains a 640w by 480h bitmap of chunky RGB data
 *        CMFloatBitmap map = { 0,         // version
 *                    {p, p+1, p+2},       // base addrs of R,G,B
 *                    480, 640,            // height, width
 *                    640*3,               // rowStride
 *                    3,                   // colStride
 *                    cmRGBData,
 *                    kCMFloatBitmapFlagsNone};
 *    b) float* p contains a 640w by 480h bitmap of chunky BGRA data
 *        CMFloatBitmap map = { 0,         // version
 *                    {p+2, p+1, p, p+3},  // base addrs of R,G,B,A
 *                    480, 640,            // height, width
 *                    640*4,               // rowStride
 *                    3,                   // colStride
 *                    cmRGBData,
 *                    kCMFloatBitmapFlagsAlpha};
 *    c) float* p contains a 640w by 480h bitmap of planar CMYK data
 *        CMFloatBitmap map = { 0,        // version
 *                    {p, p+640*480 , p+2*640*480 , p+3*640*480},
 *                    480, 640,           // height, width
 *                    640,                // rowStride
 *                    1,                  // colStride
 *                    cmCMYKData,
 *                    kCMFloatBitmapFlagsNone};
 */
struct CMFloatBitmap {

  /*
   * The version number of this structure to allow for future
   * expansion. Should contain 0 for now.
   */
  unsigned long       version;

  /*
   * The base address for each channel in canonical order. The
   * canonical order for RGB is R,G,B. CMYK is C,M,Y,K etc. A maximum
   * of sixteen channels is supported. Another way to think of this is
   * buffers[c] = &amp;(pixelArray[0][0][c])
   */
  float *             buffers[16];

  /*
   * The height (in pixels) of the bitmap.
   */
  size_t              height;

  /*
   * The width (in pixels) of the bitmap.
   */
  size_t              width;

  /*
   * The number of floats to skip to move from one row to the next.
   * This is typically (width*chans) for chunky pixel buffers or
   * (width) for planar. Can be negative if the image is vertically
   * flipped.
   */
  ptrdiff_t           rowStride;

  /*
   * The number of floats to skip to move from one column to the next.
   * This is typically (chans) for chunky pixel buffers or (1) for
   * planar. Can be negative if the image is horizontally flipped.
   */
  ptrdiff_t           colStride;

  /*
   * The colorspace of the data (e.g cmRGBdata cmCMYKData)
   */
  OSType              space;

  /*
   * Holds bits to specify the alpha type of the data. The remaining
   * bits are reserved for future use.
   */
  CMFloatBitmapFlags  flags;
};
typedef struct CMFloatBitmap            CMFloatBitmap;

</pre><p>This new <code>CMFloatBitmap</code> structure supports both planar and chunky arrangements of data. Each channel is permitted to have a different base address rather than a single base address for all pixel data. This allows channels to be in any arbitrary order. Also, if you require unusual packing between channels, or if your data needs to be scanned in reverse order the structure allows for both rowbytes and columnbytes to be specified.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG65"></A><H3>New APIs</H3><p>A number of new APIs have been introduced for working with the <code>CMFloatBitmap</code> structure. These are described below.</p><A NAME="TNTAG78"></A><H4>CMFloatBitmapMakeChunky</H4><p>Most developers will specify a buffer of chunky or interleaved data with the <code>CMFloatBitmap</code> structure, so there is a new utility function <code>CMFloatBitmapMakeChunky</code> which will fill in the structure appropriately. You simply supply a single base address. Here's how it looks:</p><p class="smalltext"><strong>Listing 4:</strong> CMFloatBitmapMakeChunky function.</p><pre class="sourcecodebox">
/*
 *  CMFloatBitmapMakeChunky()
 *
 *  Summary:
 *    A handy funtion to fill in a CMFloatBitmap.
 *
 *  Discussion:
 *    Returns a filled in CMFloatBitmap structure given a single buffer
 *    of chunky data with no alpha.
 *
 *  Parameters:
 *
 *    buffer:
 *      (in) address of interleaved data
 *
 *    height:
 *      (in) height of bitmap in pixels
 *
 *    width:
 *      (in) width of bitmap in pixels
 *
 *    space:
 *      (in) colorsapce of the data
 *
 *  Result:
 *    a filled in CMFloatBitmap
 *
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in ApplicationServices.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern CMFloatBitmap
CMFloatBitmapMakeChunky(
  float *  buffer,
  size_t   height,
  size_t   width,
  OSType   space)                                             AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;

</pre><p>Regardless of whether you fill the structure by hand or call the helper API, you can then use ColorSync to match the data defined by any floating point bitmap. There are three new functions to do this:</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG80"></A><H4>CMConvertXYZFloatBitmap</H4><p><code>CMConvertXYZFloatBitmap</code> will convert <code>CMFloatBitmap</code> structures across all the CIE related color spaces : XYZ, Yxy, Lab and Luv.</p><p class="smalltext"><strong>Listing 5:</strong> CMConvertXYZFloatBitmap function.</p><pre class="sourcecodebox">
/*
 *  CMConvertXYZFloatBitmap()
 *
 *  Summary:
 *    Used to convert CMFloatBitmaps between the related colorspaces
 *    XYZ, Yxy, Lab, and Luv.
 *
 *  Discussion:
 *    The buffer data from the source CMFloatBitmap is converted into
 *    the buffer data specified the destination CMFloatBitmap.
 *    Converion &quot;in-place&quot; is allowed.
 *
 *  Parameters:
 *
 *    src:
 *      (in) description of source data buffer to convert from
 *
 *    srcIlluminantXYZ:
 *      (in) required if src-&gt;space is XYZ or Yxy
 *
 *    dst:
 *      (in,out) description of destination data buffer to convert to
 *
 *    dstIlluminantXYZ:
 *      (in) required if dst-&gt;space is XYZ or Yxy
 *
 *    method:
 *      (in) the chromatic adaptation method to use
 *
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in ApplicationServices.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern CMError
CMConvertXYZFloatBitmap(
  const CMFloatBitmap *   src,
  const float             srcIlluminantXYZ[3],
  CMFloatBitmap *         dst,
  const float             dstIlluminantXYZ[3],
  CMChromaticAdaptation   method)                             AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG86"></A><H4>CMConvertRGBFloatBitmap</H4><p><code>CMConvertRGBFloatBitmap</code> will convert <code>CMFloatBitmap</code> structures across the RGB derived spaces : RGB, HSV and HLS.</p><p class="smalltext"><strong>Listing 6:</strong> CMConvertRGBFloatBitmap function.</p><pre class="sourcecodebox">
/*
 *  CMConvertRGBFloatBitmap()
 *
 *  Summary:
 *    Used to convert CMFloatBitmaps between the related colorspaces
 *    RGB, HSV, and HLS.
 *
 *  Discussion:
 *    The buffer data from the source CMFloatBitmap is converted into
 *    the buffer data specified the destination CMFloatBitmap.
 *    Converion &quot;in-place&quot; is allowed.
 *
 *  Parameters:
 *
 *    src:
 *      (in) description of source data buffer to convert from
 *
 *    dst:
 *      (in,out) description of destination data buffer to convert to
 *
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in ApplicationServices.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern CMError
CMConvertRGBFloatBitmap(
  const CMFloatBitmap *  src,
  CMFloatBitmap *        dst)                                 AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;

</pre><p>Both of these functions are based on well known textbook formulas, so there's no need to pass in a profile or colorworld to handle the transform. Instead, these functions will perform the mathematical calculations for you with floating point precision.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG100"></A><H4>CMMatchFloatBitmap</H4><p><code>CMMatchFloatBitmap</code> will color match floating point bitmaps. You may pass in a color world reference to perform the actual transformation. You can create the color world by concatenating one or more profiles. The data is then sent through the CMM, and if the CMM supports floating point data the transformation will be performed using full floating point precision.</p><p class="smalltext"><strong>Listing 7:</strong> CMMatchFloatBitmap function.</p><pre class="sourcecodebox">
/*
 *  CMMatchFloatBitmap()
 *
 *  Summary:
 *    Used to convert CMFloatBitmaps using a CMWorldRef.
 *
 *  Discussion:
 *    The buffer data from the source CMFloatBitmap is converted into
 *    the buffer data specified the destination CMFloatBitmap.
 *    Converion &quot;in-place&quot; is allowed.
 *
 *  Parameters:
 *
 *    cw:
 *      (in) the CMWorldRef to convert with
 *
 *    src:
 *      (in) description of source data buffer to convert from
 *
 *    dst:
 *      (in,out) description of destination data buffer to convert to
 *
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in ApplicationServices.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern CMError
CMMatchFloatBitmap(
  CMWorldRef             cw,
  const CMFloatBitmap *  src,
  CMFloatBitmap *        dst)                                 AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;

</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG102"></A><H3>Use of CFTypes</H3><A NAME="TNTAG103"></A><H4>CMProfileRef and CMWorldRef are now a CFType</H4><p>ColorSync is now more closely integrated with the Core Foundation types (<code>CFType</code> objects). The two common opaque ColorSync data types, <code>CMProfileRef</code> and <code>CMWorldRef</code>, are now <code>CFType</code> objects. This is very convenient because you can now use the Core Foundation functions such as <code>CFRetained</code> and <code>CFRelease</code> with these data types, and you can also add profiles or color worlds to <code>CFDictionaries</code> and <code>CFArrays</code>. This is handy if you are passing <code>CFDictionaries</code> and color worlds around in various parts of your code.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG104"></A><H4>CMProfileCopyICCData</H4><p>The <code>CMProfileCopyICCData</code> function lets you extract the data out of the profile. In the past, this was done by calling the <code>CMCopyProfile</code> or <code>CMFlattenProfile</code> functions and this was a bit more work. Now, the entire process is much easier. Just call <code>CMProfileCopyICCData</code> and it will return you all the data in the profile as one big <code><code>CFData</code></code> object.</p><p class="smalltext"><strong>Listing 8:</strong> CMProfileCopyICCData function.</p><pre class="sourcecodebox">
/*
 *  CMProfileCopyICCData()
 *
 *  Summary:
 *    Return a copy of the icc data specified by `prof'.
 *
 *  Parameters:
 *
 *    allocator:
 *      (in) The object to be used to allocate memory for the data
 *
 *    prof:
 *      (in) The profile to query
 *
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in ApplicationServices.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern CFDataRef
CMProfileCopyICCData(
  CFAllocatorRef   allocator,
  CMProfileRef     prof)                                      AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;

</pre><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG106"></A><H3>API Changes</H3><p>Below is a discussion of APIs changes for ColorSync in Mac OS X 10.4 Tiger.</p><A NAME="TNTAG107"></A><H4>Some of the ColorSync defaults/preferences APIs are to be deprecated</H4><p>Several years ago, one feature added to ColorSync at both the API and user-interface level was a set of <A HREF="#TNTAG5">ColorSync Preferences and Supporting APIs</A> to enable applications to specify default profiles based on usage and color space. The goal of these APIs was to simplify the user interface across a wide variety of applications. In practice, very few applications have used these APIs. In addition, developers have indicated they are confused with the user interface in Colorsync Utility, because any changes made in the settings don't seem to have any kind of noticable effect.</p><p>As a result, these APIs are being deprecated along with the user interface. However, existing applications that are using these APIs need to function correctly, so the behavior of the following functions has been changed:</p><p><code>CMGetDefaultProfileBySpace</code>/<code>SetDefaultProfileBySpace</code></p><p><code>CMGetDefaultProfileByUse</code>/<code>SetDefaultProfileByUse</code></p><p><code>CMGetPreferredCMM</code></p><p>These functions will now store their preferences in the domain:</p><p>Current Application / Current Host / Current User</p><p>instead of storing them as a setting that is global across the machine.</p><p>Again, these APIs will continue to work, but are now deprecated.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG108"></A><H3>Custom CMMs</H3><p>Listed below are changes for Custom CMM's in Mac OS X 10.4 Tiger.</p><A NAME="TNTAG109"></A><H4>Quartz and Printing Graphics Systems will now only use the Apple CMM</H4><p>New changes to Color Management in Mac OS X 10.4 Tiger have resulted in a tighter and more powerful integration between the Quartz and Printing graphics systems. However, in order for the Quartz and Printing graphics systems to work at peak performance and reliability it was necessary to restrict them to use only the Apple CMM.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG110"></A><H4>Applications can still request a custom CMM using NCWConcatColorWorld and explicitly match data</H4><p>ColorSync has for a long time now allowed developers to build their own CMM's, and it has also allowed applications to use these third-party CMM's in their applications. With Mac OS X 10.4 Tiger, applications may still call third party CMMs and explicity create color worlds using these CMMs. This can be done with the recommended API <code>NCWConcatColorWorld</code> which lets you specify a CMM identifier in the <code>NCMConcatProfileSet</code> structure.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG111"></A><H4>New CMMMatchFloatMap entry point</H4><p>Also, there's a new entry point for CMMs: <code>CMMMatchFloatMap</code>. If your CMM supports this it will give you full access to the new floating point support provided throughout the Quartz system. If you don't support this, your data will be truncated to 16-bit integer.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG112"></A><H3>Changes to ColorSync Utility</H3><p>This section discusses changes to ColorSync Utility.</p><A NAME="TNTAG113"></A><H4>Removal of Preferences Pane</H4><p>As described in <A HREF="#TNTAG106">API Changes</A>, we are deprecating the Preferences APIs for default profiles. As a result, we are removing the user interface for the Preferences pane in Colorsync Utility.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG114"></A><H4>New Color Calculator Pane</H4><p>We've added a new utility called Color Calculator. This utility lets you easily perform color space conversions with floating point precision. Here's a screenshot showing how it looks:</p><p><img src="images/tn2035_37.jpg" width="500" height="332" alt=""></p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG98"></A><H2>References</H2><ul><li><p><A HREF="../../documentation/GraphicsImaging/Reference/ColorSync_Manager/index.html">ColorSync Manager Reference</A></p></li><li><p><A HREF="../../documentation/GraphicsImaging/Conceptual/csintro/index.html">Introduction to Color and Color Management</A></p></li><li><p><A HREF="tn1160.html">Technical Note TN1160, 'What's New With ColorSync 2.6'</A></p></li><li><p><A HREF="../../qa/qa2004/qa1352.html">Technical Q&amp;A QA1352, 'New PPD keywords available in Mac OS X version 10.3'</A></p></li><li><p>ColorWhirled sample code (installed with the <A HREF="../../tools/macosxtools.html">Xcode Tools</A>) at /Developer/Examples/ColorSync/ColorWhirled</p></li></ul><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNT_HISTORY_TAG"></A><H2>Document Revision History</H2><table cellspacing="0" class="graybox" width="680"><tr><th width="100">Date</th><th width="580">Notes</th></tr><tr><td scope="row">2005-08-10</td><td>Describes ColorSync changes for Mac OS X 10.4 &quot;Tiger&quot;</td></tr><tr><td scope="row">2004-06-25</td><td>Miscellaneous formatting changes.</td></tr><tr><td scope="row">2004-06-16</td><td>Describes ColorSync changes for Mac OS X 10.3</td></tr><tr><td scope="row">2003-02-10</td><td>Describes ColorSync, which is fundamentally integrated into Mac OS X.</td></tr></table><p><b>Posted:</b> 2005-08-10</p>
<!-- END CONTENTS -->
</td></tr></table>
<!-- END WIDE COLUMN -->
<!-- END MAIN CONTENT -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn2035.html%3Fid%3DDTS10003071-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn2035.html%3Fid%3DDTS10003071-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn2035.html%3Fid%3DDTS10003071-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

<!-- START BOTTOM APPLE NAVIGATION -->
<!--#include virtual="/includes/footer"-->
<!-- END BOTTOM APPLE NAVIGATION -->
<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->
</body></html>