<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Summary of NBP(IM:N)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING83></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Networking-82.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-84.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Networking-2.html"><B>Networking</B></A> / <BR><DD><A HREF="Networking-61.html"><B>Chapter 3 - Name-Binding Protocol (NBP)</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING83-0></A>
<H1>Summary of NBP</H1>
<A NAME=HEADING83-1></A>
<H2>Pascal Summary</H2>
<A NAME=HEADING83-2></A>
<H3>Constants</H3>
<PRE>
CONST
   {.MPP driver unit and reference number}
   mppUnitNum     =     9;          {MPP driver unit number}
   mppRefNum      =   -10;          {MPP reference number}

   {csCodes for NBP}
   confirmName    =   250;          {confirm name}
   lookupName     =   251;          {lookup name}
   removeName     =   252;          {remove name from names table}
   registerName   =   253;          {register name in names table}
   killNBP        =   254;          {kill outstanding NBP request}
</PRE>
<A NAME=HEADING83-4></A>
<H3>Data Types</H3>
<A NAME=HEADING83-5></A>
<H4>Address Block Record</H4>
<PRE>
   AddrBlock = 
   PACKED RECORD
      aNet:       Integer;          {network number}
      aNode:      Byte;             {node ID}
      aSocket:    Byte;             {socket number}
   END;
</PRE>
<A NAME=HEADING83-7></A>
<H4>Names Table Entry Record</H4>
<PRE>
TYPE  NamesTableEntry =
   RECORD
      qLink:      QElemPtr;         {pointer to next NTE in names table}
      nteAddress: AddrBlock;        {pointer to this names table entry}
      nteData: PACKED ARRAY[1..100] OF Char; 
                                    {names table entry}
   END; 
</PRE>
<A NAME=HEADING83-9></A>
<H4>Entity Name Record</H4>
<PRE>
   EntityName = 
   RECORD
      objStr:        Str32;      {object name}
      typeStr:       Str32;      {type name}
      zoneStr:       Str32;      {zone name}
   END;
   EntityPtr = ^EntityName;
</PRE>
<A NAME=HEADING83-11></A>
<H4>MPP Parameter Block for NBP</H4>
<PRE>
MPPParmType    =     (...RegisterNameParm, LookupNameParm,
                        ConfirmNameParm,RemoveNameParm...);
TYPE MPPParamBlock = 
   PACKED RECORD
      qLink:               QElemPtr;      {reserved}
      qType:               Integer;       {reserved}
      ioTrap:              Integer;       {reserved}
      ioCmdAddr:           Ptr;           {reserved}
      ioCompletion:        ProcPtr;       {completion routine}
      ioResult:            OSErr;         {result code}
      ioNamePtr:           StringPtr;     {reserved}
      ioVRefNum:           Integer;       {reserved}
      ioRefNum:            Integer;       {driver reference number}
      csCode:              Integer;       {primary command code}
   CASE MPPParmType OF
      RegisterNameParm,
      LookupNameParm,
      ConfirmNameParm,
      RemoveNameParm:
         (interval:        Byte;          {retry interval}
         count:            Byte;          {retry count}
         entityPtr:        Ptr;           {pointer to entity name or }
                                          { names table entry}
         CASE MPPParmType OF
            RegisterNameParm:
               (verifyFlag:   Byte;       {verify uniqueness of name or not}
               filler3:       Byte;)
            LookupNameParm:
               (retBuffPtr:   Ptr;        {pointer to return buffer}
               retBuffSize:   Integer;    {return buffer size}
               maxToGet:      Integer;    {matches to get}
               numGotten:     Integer;)   {matches gotten}
            ConfirmNameParm:
               (confirmAddr:  AddrBlock;  {pointer to entity name}
               newSocket:     Byte;       {socket number}
               filler4:       Byte);
            )
      KillNBPParm:
         (nKillQEl:        Ptr;)       {pointer to queue element to cancel}
   END;
MPPPBPtr    =     ^MPPParamBlock;
</PRE>
<A NAME=HEADING83-14></A>
<H3>Routines</H3>
<A NAME=HEADING83-15></A>
<H4>Registering an Entity </H4>
<PRE>
PROCEDURE NBPSetNTE (ntePtr: Ptr; nbpObject,nbpType,nbpZone: Str32; 
socket: Integer);
FUNCTION PRegisterName(thePBptr: MPPPBPtr; async: Boolean): OSErr;
</PRE>
<A NAME=HEADING83-18></A>
<H4>Handling Name and Address Requests</H4>
<PRE>
PROCEDURE NBPSetEntity(buffer: Ptr; nbpObject,nbpType,nbpZone: Str32);
FUNCTION PLookupName(thePBptr: MPPPBPtr; async: Boolean): OSErr;
FUNCTION NBPExtract(theBuffer: Ptr; numInBuf: Integer; whichOne: 
Integer; VAR abEntity: EntityName; VAR address: 
AddrBlock): OSErr;
FUNCTION PConfirmName(thePBptr: MPPPBPtr; async: Boolean): OSErr;
FUNCTION PRemoveName(thePBptr: MPPPBPtr; async: Boolean): OSErr;
FUNCTION PKillNBP(thePBptr: MPPPBPtr; async: Boolean): OSErr;
</PRE>
<A NAME=HEADING83-25></A>
<H2>C Summary</H2>
<A NAME=HEADING83-26></A>
<H3>Constants</H3>
<PRE>
/*NBP parameter constants*/
#define MPPioCompletion MPP.ioCompletion
#define MPPioResult MPP.ioResult
#define MPPioRefNum MPP.ioRefNum
#define MPPcsCode MPP.csCode
#define NBPinterval NBP.interval
#define NBPcount NBP.count
#define NBPntQElPtr NBP.NBPPtrs.ntQElPtr
#define NBPentityPtr NBP.NBPPtrs.entityPtr
#define NBPverifyFlag NBP.parm.verifyFlag
#define NBPretBuffPtr NBP.parm.Lookup.retBuffPtr
#define NBPretBuffSize NBP.parm.Lookup.retBuffSize
#define NBPmaxToGet NBP.parm.Lookup.maxToGet
#define NBPnumGotten NBP.parm.Lookup.numGotten
#define NBPconfirmAddr NBP.parm.Confirm.confirmAddr
#define NBPnKillQEl NBPKILL.nKillQEl
#define NBPnewSocket NBP.parm.Confirm.newSocket 
enum {                                 /*.MPP driver unit and reference */
                                       /* number*/
   mppUnitNum     =     9,             /*.MPP driver unit number*/
   mppRefNum      =     -10};          /*MPP reference number*/

enum {                                 /*.MPP csCodes*/
   confirmName    =     250,           /*confirm name*/
   lookupName     =     251,           /*lookup name*/
   removeName     =     252,           /*remove name from names table*/
   registerName   =     253,           /*register name in names table*/    
   killNBP        =     254};          /*kill outstanding NBP request*/
</PRE>
<A NAME=HEADING83-29></A>
<H3>Data Types</H3>
<A NAME=HEADING83-30></A>
<H4>Address Block Record</H4>
<PRE>
struct AddrBlock {
   short             aNet;       /*network name*/
   unsigned char     aNode;      /*node name*/
   unsigned char     aSocket;    /*socket number*/
};

typedef struct AddrBlock AddrBlock;
</PRE>
<A NAME=HEADING83-32></A>
<H4>Names Table Entry Data Structure</H4>
<PRE>
struct {
   Ptr            qNext;            /*pointer to next names table element*/
   NTElement      nt;
}NamesTableEntry;
</PRE>
<A NAME=HEADING83-34></A>
<H4>Entity Name Record</H4>
<PRE>
struct EntityName {
   Str32          objStr;        /*object name*/
   char           pad1;          /*Str32's aligned on even word boundaries*/
   Str32          typeStr;       /*type name*/
   char           pad2;
   Str32          zoneStr;       /*zone name*/
   char           pad3;
};

typedef struct EntityName EntityName;
typedef EntityName *EntityPtr;
</PRE>
<A NAME=HEADING83-36></A>
<H4>MPP Parameter Block for NBP</H4>
<PRE>
#define MPPATPHeader \
   QElem          *qLink;        /*reserved*/\
   short          qType;         /*reserved*/\
   short          ioTrap;        /*reserved*/\
   Ptr            ioCmdAddr;     /*reserved*/\
   ProcPtr        ioCompletion;  /*completion routine*/\
   OSErr          ioResult;      /*result code*/\
   long           userData;      /*command result (ATP user bytes)*/\
   short          reqTID;        /*request transaction ID*/\
   short          ioRefNum;      /*driver reference number*/\
   short          csCode;        /*primary command code*/

typedef struct {
   MPPATPHeader 
}MPPparms;

typedef struct {
   MPPATPHeader
   char           interval;         /*retry interval*/
   char           count;            /*retry count*/
   union {
      Ptr            ntQElPtr;      /*pointer to queue element to cancel*/
      Ptr            entityPtr;   
                                    /*pointer to entity name or names */
                                    /* table entry*/
                                 
      } NBPPtrs;

   union {
      char           verifyFlag;    /*verify uniqueness of name or not*/
   struct {
      Ptr            retBuffPtr;    /*pointer to return buffer*/
      short          retBuffSize;   /*return buffer size*/
      short          maxToGet;      /*matches to get*/
      short          numGotten;     /*matches gotten*/
   } Lookup;
   struct {
         AddrBlock      confirmAddr; /*pointer to entity name*/
         char           newSocket;   /*socket number*/
      } Confirm;
   } parm;
}NBPparms;

struct {
   MPPATPHeader
   Ptr            nKillQEl;         
                                    /*pointer to queue element to cancel*/
}NBPKillparms;

union ParamBlockRec {
   MPPparms       MPP;              /*general MPP parms*/
   NBPparms       NBP;              /*NBP calls*/
   NBPKillparms   NBPKILL;          /*cancel call to NBP*/
};
typedef MPPParamBlock *MPPPBPtr;
</PRE>
<A NAME=HEADING83-39></A>
<H3>Routines</H3>
<A NAME=HEADING83-40></A>
<H4>Registering an Entity </H4>
<PRE>
pascal void NBPSetNTE(Ptr ntePtr, Ptr nbpObject, Ptr nbpType,
Ptr nbpZone, short socket);
pascal OSErr PRegisterName(MPPPBPtr thePBpt, Boolean async);
</PRE>
<A NAME=HEADING83-43></A>
<H4>Handling Name and Address Requests</H4>
<PRE>
pascal void NBPSetEntity (Ptr buffer, Ptr nbpObject, Ptr nbpType, 
Ptr nbpZone);
pascal OSErr PLookupName(MPPPBPtr thePBptr, Boolean async);
pascal OSErr NBPExtract (Ptr theBuffer, short numInBuf, short whichOne,
EntityName *abEntity, AddrBlock *address);
pascal OSErr PConfirmName (MPPPBPtr thePBptr, Boolean async);
pascal OSErr PRemoveName (MPPPBPtr thePBptr, Boolean async);
pascal OSErr PKillNBP(MPPPBPtr thePBptr, Boolean async);
</PRE>
<A NAME=HEADING83-50></A>
<H2>Assembly-Language Summary</H2>
<A NAME=HEADING83-51></A>
<H3>Constants</H3>
<A NAME=HEADING83-52></A>
<H4>Unit Number for the .MPP Driver</H4>
<PRE>
mppUnitNum        EQU   9           ;MPP unit number
</PRE>
<A NAME=HEADING83-54></A>
<H4>NBP Symbolic Characters</H4>
<PRE>
equals            EQU   '='         ;wildcard symbol
NBPWildCard       EQU   '[double tilde]'         ;wildcard symbol
star              EQU   '*'         ;&quot;This zone&quot; symbol
</PRE>
<A NAME=HEADING83-56></A>
<H4>NBP Command Codes</H4>
<PRE>
registerName      EQU   253         ;register name in names table
lookupReply       EQU   242         ;used internally
lookupName        EQU   251         ;look up an NBP name
confirmName       EQU   250         ;confirm name
removeName        EQU   252         ;remove name from names table
killNBP           EQU   254         ;kill outstanding NBP request
</PRE>
<A NAME=HEADING83-58></A>
<H4>NBP Packet</H4>
<PRE>
nbp               EQU   $02         ;DDP protocol type code for NBP
nbpControl        EQU   0           ;control code
nbpTCount         EQU   0           ;tuple count
nbpID             EQU   1           ;NBP ID
nbpTuple          EQU   2           ;start of the first tuple
</PRE>
<A NAME=HEADING83-60></A>
<H4>NBP Tuple Header Offsets</H4>
<PRE>
tupleNet          EQU   0           ;offset to network number (word)
tupleNode         EQU   2           ;offset to node ID (byte)
tupleSkt          EQU   3           ;offset to socket number (byte)
tupleEnum         EQU   4           ;offset to enumerator (byte)
tupleName         EQU   5           ;offset to name part of tuple (byte)
tupleAddrSz       EQU   5           ;tuple address field size
</PRE>
<A NAME=HEADING83-62></A>
<H4>NBP Packet Types</H4>
<PRE>
brRq              EQU   1           ;broadcast request
lkUp              EQU   2           ;lookup request
lkUpReply         EQU   3           ;lookup reply
</PRE>
<A NAME=HEADING83-64></A>
<H4>NBP Names Information Socket (NIS) Number</H4>
<PRE>
nis               EQU   2           ;NIS number
</PRE>
<A NAME=HEADING83-66></A>
<H4>Maximum Number of Tuples in NBP Packet, Maximum Size of a Tuple Name </H4>
<PRE>
tupleMax          EQU   15          ;maximum number of tuples returned from 
                                    ; a lookup request
NBPMaxTupleSize   EQU   32          ;maximum size of a tuple name
</PRE>
<A NAME=HEADING83-68></A>
<H3>Data Structures</H3>
<A NAME=HEADING83-69></A>
<H4>MPP Parameter Block Common Fields for NBP
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>qLink<TD>long<TD>reserved<TR>
<TD>4<TD>qType<TD>word<TD>reserved<TR>
<TD>6<TD>ioTrap<TD>word<TD>reserved<TR>
<TD>8<TD>ioCmdAddr<TD>long<TD>reserved<TR>
<TD>12<TD>ioCompletion<TD>long<TD>address of completion routine<TR>
<TD>16<TD>ioResult<TD>word<TD>result code<TR>
<TD>18<TD>ioNamePtr<TD>long<TD>reserved<TR>
<TD>22<TD>ioVRefNum<TD>word<TD>reserved<TR>
<TD>24<TD>ioRefNum<TD>word<TD>driver reference number</TABLE>
</H4>
<A NAME=HEADING83-70></A>
<H4><CODE>PRegisterName</CODE> Parameter Variant
<TABLE BORDER="0" CELLPADDING=3><TD>26<TD>csCode<TD>word<TD>command code; always <CODE>registerName</CODE><TR>
<TD>28<TD>interval<TD>byte<TD>retry interval<TR>
<TD>29<TD>count<TD>byte<TD>retry count<TR>
<TD>30<TD>entityPtr (ntQElPtr)<TD>long<TD>names table queue element pointer<TR>
<TD>34<TD>verifyFlag<TD>byte<TD>verify name flag<TR>
<TD>40<TD>filler<TD>byte<TD>reserved</TABLE>
 </H4>
<A NAME=HEADING83-71></A>
<H4>PLookupName Parameter Variant
<TABLE BORDER="0" CELLPADDING=3><TD>26<TD>csCode<TD>word<TD>command code; always <CODE>lookupName</CODE><TR>
<TD>28<TD>interval<TD>byte<TD>retry interval<TR>
<TD>29<TD>count<TD>byte<TD>retry count<TR>
<TD>30<TD>entityPtr<TD>long<TD>pointer to entity name<TR>
<TD>34<TD>retBuffPtr<TD>long<TD>pointer to return data buffer<TR>
<TD>38<TD>retBuffSize<TD>word<TD>size in bytes of return buffer <TR>
<TD>40<TD>maxToGet<TD>word<TD>maximum number of matches to get<TR>
<TD>42<TD>numGotten<TD>word<TD>number of matches returned</TABLE>
</H4>
<A NAME=HEADING83-72></A>
<H4>PConfirmName Parameter Variant
<TABLE BORDER="0" CELLPADDING=3><TD>26<TD>csCode<TD>word<TD>command code; always <CODE>confirmName</CODE><TR>
<TD>28<TD>interval<TD>byte<TD>retry interval<TR>
<TD>29<TD>count<TD>byte<TD>retry <CODE>count</CODE><TR>
<TD>30<TD>entityPtr<TD>long<TD>pointer to entity name<TR>
<TD>34<TD>confirmAddr<TD>long<TD>address of names table entry to confirm<TR>
<TD>38<TD>newSocket<TD>byte<TD>socket number, if different from specified one<TR>
<TD>39<TD>filler<TD>byte<TD>reserved</TABLE>
</H4>
<A NAME=HEADING83-73></A>
<H4>PRemoveName Parameter Variant
<TABLE BORDER="0" CELLPADDING=3><TD>26<TD>csCode<TD>word<TD>command code; always <CODE>removeName</CODE><TR>
<TD>28<TD>filler<TD>word<TD>reserved<TR>
<TD>30<TD>entityPtr<TD>long<TD>pointer to entity name</TABLE>
</H4>
<A NAME=HEADING83-74></A>
<H4>PKillNBP Parameter Variant
<TABLE BORDER="0" CELLPADDING=3><TD>26<TD>csCode<TD>word<TD>command code; always <CODE>killNBP</CODE><TR>
<TD>28<TD>nKillQEl<TD>long<TD>pointer to queue element to remove</TABLE>
</H4>
<A NAME=HEADING83-75></A>
<H2>Result Codes
<TABLE BORDER="0" CELLPADDING=3><TD>noErr<TD>0<TD>No error<TR>
<TD>nbpNoConfirm<TD>-1025<TD>Name not confirmed<TR>
<TD>nbpConfDiff<TD>-1026<TD>Name confirmed for different socket<TR>
<TD>nbpDuplicate<TD>-1027<TD>Name already exists<TR>
<TD>nbpNotFound<TD>-1028<TD>Name not found<TR>
<TD>tooManyReqs<TD>-1097<TD>Too many concurrent requests; wait a few minutes, then try the request again<TR>
<TD>cbNotFound<TD>-1102<TD>NBP queue element not found<TR>
<TD>reqAborted<TD>-1105<TD>Request canceled<TR>
<TD>extractErr<TD>-3104<TD>Can't find tuple in buffer<A NAME=MARKER-2-76></A></TABLE>
</H2>
 <P>
</BLOCKQUOTE><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="Networking-82.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-84.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Networking-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
