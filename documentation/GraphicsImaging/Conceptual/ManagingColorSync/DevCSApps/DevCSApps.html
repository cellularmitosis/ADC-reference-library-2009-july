<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Managing Colors With ColorSync in Mac OS 9 (Legacy): Developing ColorSync-Supportive Applications</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Developing ColorSync-Supportive Applications"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	<meta name="ROBOTS" content="NOINDEX"/>
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000278" title="Developing ColorSync-Supportive Applications"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../LegacyTechnologies/index.html#//apple_ref/doc/uid/TP30000440-TP30000470" target="_top">Legacy Documents</a> &gt; <a href="../../../../LegacyTechnologies/MacOS9Earlier-date.html#//apple_ref/doc/uid/TP30000440-TP30000470-TP30000540" target="_top">Mac OS 9 &amp; Earlier</a> &gt; <a href="../PrefaceCS/PrefaceCS.html#//apple_ref/doc/uid/TP30000249-DontLinkElementID_94">Managing Colors With ColorSync in Mac OS 9 (Legacy)</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../IntroCSMngr/IntroCSMngr.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../DevCSSDevDrvrs/DevCSSDevDrvrs.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        <script type="text/javascript" language="JavaScript">placeWatermark()</script>
<div id="legacyOuterWrapper"><div align="center" id="watermark">
<div class="legacybox">
<h1>Legacy Document<span class="closebutton"><a href="javascript:closeWatermark()"><img src="../../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>
        <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_4" title="Developing ColorSync-Supportive Applications"></a><h1><a name="//apple_ref/doc/uid/TP30000278-BBCJCBHD" title="Developing ColorSync-Supportive Applications"></a>Developing ColorSync-Supportive Applications</h1><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_182"></a>T<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_183"></a>his section describes how your application can use the ColorSync Manager to provide many color management services. For a complete list, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHIGJG">Developing Your ColorSync-Supportive Application</a></span>.</p><p>Before you read this section, you should read <span class="content_text"><a href="../IntroCSpaces/IntroCSpaces.html#//apple_ref/doc/uid/TP30000280-BBCBDGDD">Overview of Color and Color Management Systems</a></span> and <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCFGIBI">Overview of ColorSync</a></span>. These sections provide an overview of color theory and color management systems (CMSs), define key terms, and describe the ColorSync Manager.</p><p>If you are developing a device driver that supports ColorSync, you should read this section in addition to <span class="content_text"><a href="../DevCSSDevDrvrs/DevCSSDevDrvrs.html#//apple_ref/doc/uid/TP30000277-BCIHGGGI">Developing ColorSync-Supportive Device Drivers</a></span>.</p><p>If your application works with images created by other applications, you should at least read <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCDBJBJ">Providing Minimal ColorSync Support</a></span>, which explains how to preserve profiles embedded in images.</p><p>While reading this section, refer to <em>ColorSync Manager Reference</em> for more information about the functions, constants, and data types used here.</p><p><span class="content_text"><a href="../VersAndCompat/VersAndCompat.html#//apple_ref/doc/uid/TP30000275-BCIFHIID">ColorSync Version Information</a></span> describes the <code>Gestalt</code> information, shared library version numbers, CMM version numbers, and ColorSync header files you use with different versions of the ColorSync Manager. It also includes CPU and Mac OS system requirements.</p><p>The book Inside Macintosh: Imaging With QuickDraw describes how your application can use QuickDraw to create and display Macintosh graphics, and how to use the Printing Manager to print the images created with QuickDraw.</p><p><span class="content_text"><a href="../WhatsNew/WhatsNew.html#//apple_ref/doc/uid/TP30000274-BABJIDIF">What’s New</a></span> explains where to get information on the Color Picker Manager, which provides your application with a standard dialog box for soliciting a color choice from users.</p><p>You should read <span class="content_text"><a href="../PrefaceCS/PrefaceCS.html#//apple_ref/doc/uid/TP30000249-BBCCEHJE">Important Note on Code Listings</a></span> before working with the code in this chapter.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-TPXREF101">About ColorSync Application Development</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHIGJG">Developing Your ColorSync-Supportive Application</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFBAG">Matching Colors Using the General Purpose Functions</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJJGIG">Embedding Profiles and Profile Identifiers</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEAAFB">Extracting Profiles Embedded in Pictures</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCCHEAG">Performing Optimized Profile Searching</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCIIJBI">Searching for Specific Profiles Prior to ColorSync 2.5</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCCDIHG">Searching for a Profile That Matches a Profile Identifier</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEJHDC">Checking Colors Against a Destination Device’s Gamut</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHGAEE">Creating and Using Device Link Profiles</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-TPXREF123">Considerations</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEBCAB">Providing Soft Proofs</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCIECGE">Calibrating a Device</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEEHBI">Accessing a Resource-Based Profile With a Procedure</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBJEBF">Handling the Begin Access Command</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-TPXREF127">Handling the Create New Access Command</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGFDDA">Handling the Open Read Access Command</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-TPXREF128">Handling the Open Write Access Command</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-TPXREF129">Handling the Read Access Command</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-TPXREF130">Handling the Write Access Command</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-TPXREF131">Handling the Close Access Command</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-TPXREF132">Handling the Abort Write Access Command</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-TPXREF133">Handling the End Access Command</a>
				
			<br/>
			
        
			
			
				<a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJBHEB">Summary of the ColorSync Manager</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000278-TPXREF101" title="About ColorSync Application Development"></a><h2>About ColorSync Application Development</h2><p>ColorSync provides your application with color-matching capabilities that users can employ without the need for a proprietary environment. ColorSync provides the first system-level implementation of an industry-standard color-matching system. Because ColorSync supports the profile format defined by the International Color Consortium (ICC), a color image a user creates can be color matched, rendered, and modified by another user running another application on another platform that supports the format. Conversely, your application can modify and color match images created by other applications that support ColorSync or a CMS that includes support for the ICC profile format. For information on profile format version numbers, see <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCHHHGG">ColorSync and ICC Profile Format Version Numbers</a></span>.</p><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_184"></a><span class="content_text"><a href="../VersAndCompat/VersAndCompat.html#//apple_ref/doc/uid/TP30000275-BCIFHIID">ColorSync Version Information</a></span> describes the <code>Gestalt</code> information, shared library version numbers, CMM version numbers, and ColorSync header files you use with different versions of the ColorSync Manager. It also describes CPU and Mac OS system requirements.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF102" title="About the ColorSync Manager Programming Interface"></a><h3>About the ColorSync Manager Programming Interface</h3><p>The <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_185"></a>ColorSync Manager programming interface allows your application to handle tasks such as color matching, color conversion, profile management, profile searching and accessing, reading individual tagged elements within a profile, embedding profiles in documents, and modifying profiles.</p><p>The ColorSync API is summarized in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJBHEB">Summary of the ColorSync Manager</a></span>. You can find detailed information about individual functions, data types, and constants in <em>ColorSync Manager Reference</em>. The ColorSync Manager includes a number of interface files you may need for your development efforts. These files are described in <span class="content_text"><a href="../VersAndCompat/VersAndCompat.html#//apple_ref/doc/uid/TP30000275-TPXREF102">ColorSync Header Files</a></span>.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF103" title="What Should a ColorSync-Supportive Application Do?"></a><h3>What Should a ColorSync-Supportive Application Do?</h3><p>Your ColorSync-supportive application can provide a rich set of color-matching features. Your application can color match images, pixel maps, bitmaps, and even individual colors. In addition to color matching, you can handle such tasks as color conversion, color gamut checking, soft proofing of images, profile management, profile searching and accessing, reading individual tagged elements within a profile, embedding profiles and profile identifiers in documents, extracting embedded profiles and profile identifiers, and modifying profiles and profile identifiers.</p><p>Your application can provide an interface that offers pop-up menus or other user interface items allowing a user to choose which profile to associate with an image and how an image is rendered. It can show the user the colors of an image that are in or out of gamut for a particular device on which the image is to be produced and how ColorSync adjusts for colors that are out of gamut. This allows the user to preview differences that occur in the color-matching transition between gamuts and make corrections if necessary.</p><p>Most of the terms and operations mentioned in this section are defined in <span class="content_text"><a href="../IntroCSpaces/IntroCSpaces.html#//apple_ref/doc/uid/TP30000280-BBCBDGDD">Overview of Color and Color Management Systems</a></span> and <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCFGIBI">Overview of ColorSync</a></span>.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF104" title="At a Minimum"></a><h4>At a Minimum</h4><p>ColorSync <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_186"></a>allows your application to preserve high fidelity to the original colors of an image—whether the image was created using your application or another—by supporting the use of <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_187"></a>e<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_188"></a>mbedded profiles. Your application can take advantage of a profile embedded along with an image, matching the original colors of the device used to create the image to those of the destination display or printer. Even if your application doesn’t support some of the more advanced features that ColorSync affords, such as soft proofing, you should color match images using the source profile, if one is identified and available.</p><p>At a minimum, your application should preserve images tagged with a profile by not stripping out picture comments used to embed profiles or by leaving profiles in documents that use other methods to include them.</p><p>It is important for your application to tag an image with the profile for the device used to create the image and to preserve existing tagging because a picture that is not tagged assumes use of a default profile as described in <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCIEIEE">Setting Default Profiles</a></span>. If the picture is moved to a different system that uses a different default profile, the picture will display differently. <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCDBJBJ">Providing Minimal ColorSync Support</a></span> explains how to preserve embedded profiles, and <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJJGIG">Embedding Profiles and Profile Identifiers</a></span> explains how to tag an image. Some of these features are described in greater detail in the rest of this material.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF105" title="Storing and Handling Profiles"></a><h4>Storing and Handling Profiles</h4><p>Profiles for use with the ColorSync Manager are stored in the ColorSync Profiles folder. The precise location of this folder can vary for different versions of ColorSync, as described in <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCIEIEE">Setting Default Profiles</a></span>. When you install ColorSync, the ColorSync Profiles folder contains a selection of display profiles for all Apple color monitors, as well as default profiles for standard color spaces and profiles for several Apple printers.</p><p>Starting with ColorSync 2.5, a user can select a default profile for certain color spaces from the ColorSync control panel, as described in <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCIEIEE">Setting Default Profiles</a></span>. Also starting with version 2.5, the Monitors &amp; Sound control panel allows the user to select a separate profile for each monitor, as described in <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCFHBIJ">Monitor Calibration and Profiles</a></span>.</p><p>Your application specifies the profiles for color matching when the application calls a ColorSync Manager function. For most functions, the ColorSync Manager uses one of the default profiles if your application doesn’t specify a profile. Some functions require that you explicitly specify a profile by reference.</p><p>Device drivers for ColorSync-supportive input and output devices, such as scanners and printers, may install the profiles they use in the ColorSync Profiles folder, making them available to your application for color matching or gamut checking. If your application creates device link profiles, as described in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHGAEE">Creating and Using Device Link Profiles</a></span>, you should place those profiles in the ColorSync Profiles folder.</p><p>Your application can provide the interface to allow a user to choose a profile for a specific device. Using the ColorSync Manager functions described in <em>ColorSync Manager Reference</em>, your application can search the ColorSync Profiles folder and display information about available profiles.</p><p>See <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHIGJG">Developing Your ColorSync-Supportive Application</a></span> for a list of programming examples that demonstrate many of these features. As described in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCDBJBJ">Providing Minimal ColorSync Support</a></span>, your application should, at a minimum, leave profile information intact in the documents and pictures that it imports or copies into its own documents.</p><a name="//apple_ref/doc/uid/TP30000278-BBCBBFJD" title="How the ColorSync Manager Selects a CMM"></a><h3>How the ColorSync Manager Selects a CMM</h3><p>When a ColorSync function performs a color matching or color checking operation, it must determine which CMM to use. You typically pass source and destination profiles to a function, either directly or as part of a color world—an abstract private data structure you create by calling either the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/NCWNewColorWorld" target="_top">NCWNewColorWorld</a></code>, the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWConcatColorWorld" target="_top">CWConcatColorWorld</a></code>, or the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWNewLinkProfile" target="_top">CWNewLinkProfile</a></code> function. When you call one of the latter two functions to create a color world, you use the <code>CMConcatProfileSet</code> data structure to specify a series of one or more profiles for the color world.</p><p>A profile header contains a <code>CMMType</code> field that specifies a CMM for that profile. For example, Signature of ColorSync’s Default Color Manager describes a signature for the <code>CMMType</code> field that specifies ColorSync’s default CMM. When you set up a <code>CMConcatProfileSet</code> data structure to specify a series of profiles, you set the structure’s <code>keyIndex</code> field to specify the zero-based index of the profile within the array of profiles whose CMM (as indicated by its <code>CMMType</code> field) ColorSync should use. A CMM specified by this mechanism is called a key CMM.</p><p>As we have seen, an operation may use more than one profile and there are multiple factors that can affect the choice of a CMM. To deal with these factors, ColorSync uses the following algorithm to select a CMM:</p><ol class="ol"><li class="li"><p>Starting with version 2.5, a user can select a preferred CMM in the ColorSync control panel. If a user has chosen a preferred CMM, and if that CMM is available, ColorSync uses that CMM for all color checking and color matching operations the CMM can handle.</p><p>If the preferred CMM is not available or cannot handle an operation, ColorSync uses the default CMM, as described in step 4.</p></li><li class="li"><p>Prior to ColorSync 2.5, or if the user has not selected a preferred CMM with the ColorSync control panel, or has selected Automatic, and if the ColorSync function takes a color world reference and the user has initialized the color world with <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWConcatColorWorld" target="_top">CWConcatColorWorld</a></code> or <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWNewLinkProfile" target="_top">CWNewLinkProfile</a></code>, ColorSync uses the key CMM.</p><p>If the key CMM is not available or cannot handle an operation, ColorSync uses the default CMM, as described in step 4</p></li><li class="li"><p>Prior to ColorSync 2.5, or if the user has not selected a preferred CMM with the ColorSync control panel, or has selected Automatic, and if the ColorSync function takes a color world reference and the user has initialized the color world with <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/NCWNewColorWorld" target="_top">NCWNewColorWorld</a></code> (and therefore without a <code>CMConcatProfileSet</code> structure), ColorSync uses an arbitrated CMM or CMMs—a CMM or CMMs selected from the source and destination profiles as described in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBEGAC">Selecting a CMM by the Arbitration Algorithm</a></span>.</p><p>If an arbitrated CMM is not available or cannot handle an operation, ColorSync uses the default CMM, as described in step 4.</p></li><li class="li"><p>If a CMM is not specified by one of the previous three steps, or if a specified CMM is not available or cannot handle an operation, ColorSync uses the default CMM—the robust CMM that is installed as part of the ColorSync extension. The default CMM supports all the required and optional functions defined by the ColorSync Manager, and is therefore a suitable CMM of last resort. The signature for the default CMM is specified by the constant kDefaultCMMSignature.</p></li></ol><a name="//apple_ref/doc/uid/TP30000278-BBCBEGAC" title="Selecting a CMM by the Arbitration Algorithm"></a><h3>Selecting a CMM by the Arbitration Algorithm</h3><p>This section describes the arbitration algorithm, introduced in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBBFJD">How the ColorSync Manager Selects a CMM</a></span>, ColorSync uses to select one or more arbitrated CMMs for a color matching or color checking operation:</p><ul class="spaceabove"><li class="li"><p>If the source and destination profiles specify the same CMM and that CMM component is available and able to perform the matching, then the specified CMM maps the colors directly from the color space of the source profile to the color space of the destination profile. This is the simplest scenario, and <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCIAHDG">Figure 4-1</a></span> illustrates it.</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_5" title="Figure 4-1Colormatching when the source and destination profiles specify the same CMM"></a><p><a name="//apple_ref/doc/uid/TP30000278-BBCIAHDG" title="Figure 4-1Colormatching when the source and destination profiles specify the same CMM"></a><strong>Figure 4-1&nbsp;&nbsp;</strong>Colormatching when the source and destination profiles specify the same CMM</p><img src = "../art/csul18.gif" alt = "Colormatching when the source and destination profiles specify the same CMM" width="317" height="179"></div><br/><ul class="spaceabove"><li class="li"><p>If the source and destination profiles specify different CMMs, then the ColorSync Manager follows these steps to choose the CMM:</p><ol class="ol"><li class="li"><p>If the CMM specified by the destination profile is available, is able to perform the color matching using the two profiles, and is not the default CMM, then the ColorSync Manager uses this CMM. <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFAJII">Figure 4-2</a></span> shows this scenario.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_6" title="Figure 4-2Color matching using the destination profile&acirc;&#128;&#153;s CMM"></a><p><a name="//apple_ref/doc/uid/TP30000278-BBCFAJII" title="Figure 4-2Color matching using the destination profile&acirc;&#128;&#153;s CMM"></a><strong>Figure 4-2&nbsp;&nbsp;</strong>Color matching using the destination profile’s CMM</p><img src = "../art/csul19.gif" alt = "Color matching using the destination profile’s CMM" width="317" height="179"></div></li></ol><ol class="ol"><li class="li"><p>If the destination profile’s specified CMM is unavailable or unable to perform the color-matching request using the two profiles, then the ColorSync Manager looks for the CMM specified by the source profile. If the CMM specified by the source profile is available, is able to perform the color matching using the two profiles, and is not the default CMM, the ColorSync Manager uses this CMM. <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJJDHE">Figure 4-3</a></span> shows this scenario.</p></li></ol><div class="item_figure"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_7" title="Figure 4-3Color matching using the source profile&acirc;&#128;&#153;s CMM"></a><p><a name="//apple_ref/doc/uid/TP30000278-BBCJJDHE" title="Figure 4-3Color matching using the source profile&acirc;&#128;&#153;s CMM"></a><strong>Figure 4-3&nbsp;&nbsp;</strong>Color matching using the source profile’s CMM</p><img src = "../art/csul20.gif" alt = "Color matching using the source profile’s CMM" width="317" height="179"></div><ol class="ol"><li class="li"><p>If both the source-specified CMM and the destination-specified CMM are available, but neither is able to perform the match alone, the ColorSync Manager uses the source profile’s CMM to convert the colors of the source image from the source profile’s color space to an interchange color space using the XYZ color space profile as the destination profile. Next, the ColorSync Manager uses the CMM specified by the destination profile to convert the colors now specified in the interchange color space to colors expressed in the color space of the destination profile using the XYZ color space profile as the source profile. The color conversion and matching work this way if both profiles specify the same interchange color space. <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHHGEF">Figure 4-4</a></span> shows this scenario.</p></li></ol><div class="item_figure"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_8" title="Figure 4-4Color matching through an XYZ interchange space using both CMMs "></a><p><a name="//apple_ref/doc/uid/TP30000278-BBCHHGEF" title="Figure 4-4Color matching through an XYZ interchange space using both CMMs "></a><strong>Figure 4-4&nbsp;&nbsp;</strong>Color matching through an XYZ interchange space using both CMMs </p><img src = "../art/csul21.gif" alt = "Color matching through an XYZ interchange space using both CMMs" width="397" height="178"></div><ol class="ol"><li class="li"><p>If both the source-specified CMM and the destination-specified CMM are available, but neither is able to perform the match alone and both profiles specify different interchange color spaces, the ColorSync Manager uses the source profile’s CMM to convert the colors of the source image from the source profile’s color space to its interchange color space using the appropriate color space profile as the destination profile. The example shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCECDHD">Figure 4-5</a></span> uses the XYZ color space profile as the destination profile. Then the ColorSync Manager inserts a part into the process, itself converting colors from the source profile’s interchange color space to the destination profile’s interchange color space. Next, the ColorSync Manager uses the CMM specified by the destination profile to convert the colors now specified in the destination profile’s interchange color space to colors expressed in the destination profile’s color space using the appropriate color space profile as the source profile. The example shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCECDHD">Figure 4-5</a></span> uses the Lab color space profile as the source profile.</p></li></ol><div class="item_figure"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_9" title="Figure 4-5Matching using both CMMs and two interchange color spaces"></a><p><a name="//apple_ref/doc/uid/TP30000278-BBCECDHD" title="Figure 4-5Matching using both CMMs and two interchange color spaces"></a><strong>Figure 4-5&nbsp;&nbsp;</strong>Matching using both CMMs and two interchange color spaces</p><img src = "../art/csul17.gif" alt = "Matching using both CMMs and two interchange color spaces" width="452" height="184"></div></li></ul><ul class="spaceabove"><li class="li"><p>If neither the source nor the destination profile’s specified CMM is available or able to perform the color conversion and matching, then the ColorSync Manager uses the default CMM, which will always attempt to perform the match. <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGCFAF">Figure 4-6</a></span> shows this scenario.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_10" title="Figure 4-6Color matching using the default CMM"></a><p><a name="//apple_ref/doc/uid/TP30000278-BBCGCFAF" title="Figure 4-6Color matching using the default CMM"></a><strong>Figure 4-6&nbsp;&nbsp;</strong>Color matching using the default CMM</p><img src = "../art/csul23.gif" alt = "Color matching using the default CMM" width="317" height="185"></div></li></ul><a name="//apple_ref/doc/uid/TP30000278-BBCHIGJG" title="Developing Your ColorSync-Supportive Application"></a><h2>Developing Your ColorSync-Supportive Application</h2><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_189"></a>This section describes some of the tasks your application can perform to implement color-matching and color-checking features with the ColorSync Manager.</p><p>This section provides code samples for:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBDFDG">Determining If the ColorSync Manager Is Available</a></span>; revised for ColorSync 2.5</p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCDBJBJ">Providing Minimal ColorSync Support</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCICDIF">Opening a Profile and Obtaining a Reference to It</a></span>; revised for ColorSync 2.5</p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJJBEF">Identifying the Current System Profile</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJCDEE">Poor Man’s Exception Handling</a></span>; new for ColorSync 2.5</p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFEFGH">Getting the Profile for the Main Display</a></span>; revised for ColorSync 2.5</p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGGDII">Matching to Displays Using QuickDraw-Specific Operations</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCIAFAE">Creating a Color World to Use With the General Purpose Functions</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFBAG">Matching Colors Using the General Purpose Functions</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJJGIG">Embedding Profiles and Profile Identifiers</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEAAFB">Extracting Profiles Embedded in Pictures</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCCHEAG">Performing Optimized Profile Searching</a></span>; new for ColorSync 2.5</p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCIIJBI">Searching for Specific Profiles Prior to ColorSync 2.5</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCCDIHG">Searching for a Profile That Matches a Profile Identifier</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEJHDC">Checking Colors Against a Destination Device’s Gamut</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHGAEE">Creating and Using Device Link Profiles</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEBCAB">Providing Soft Proofs</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCIECGE">Calibrating a Device</a></span></p></li><li class="li"><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEEHBI">Accessing a Resource-Based Profile With a Procedure</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP30000278-BBCBDFDG" title="Determining If the ColorSync Manager Is Available"></a><h3>Determining If the ColorSync Manager Is Available</h3><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_190"></a>To<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_191"></a> determine whether version 2.5 of the ColorSync Manager is available on a 68K-based or a PowerPC-based Macintosh system, you use the <code>Gestalt</code> function with the <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_192"></a><code>gestaltColorMatchingVersion</code> selector. The function shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFIGJB">Listing 4-1</a></span> returns a Boolean value of <code>true</code> if version 2.5 or later of the ColorSync Manager is installed and <code>false</code> if not.</p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_11" title="Listing 4-1Determining if ColorSync 2.5 is available"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCFIGJB" title="Listing 4-1Determining if ColorSync 2.5 is available"></a><strong>Listing 4-1&nbsp;&nbsp;</strong>Determining if ColorSync 2.5 is available</p><div class="codesample"><table><tr><td scope="row"><pre>Boolean ColorSync25Available (void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean haveColorSync25 = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    long    version;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (Gestalt(gestaltColorMatchingVersion, &amp;version) == noErr)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (version >= gestaltColorSync25)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            haveColorSync25 = true;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return haveColorSync25;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If your application does not depend on features added for version 2.5 of the ColorSync Manager, use the ColorSync Gestalt selector for the ColorSync version you require. For example, you might substitute gestaltColorSync20 for gestaltColorSync25 in the previous function (and rename the function appropriately). To identify other versions of ColorSync, use any of the ColorSync Gestalt selector constants described in <em>ColorSync Manager Reference</em>. For related version information, see <span class="content_text"><a href="../VersAndCompat/VersAndCompat.html#//apple_ref/doc/uid/TP30000275-BCIFHIID">ColorSync Version Information</a></span>.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_193"></a></p><a name="//apple_ref/doc/uid/TP30000278-BBCDBJBJ" title="Providing Minimal ColorSync Support"></a><h3>Providing Minimal ColorSync Support</h3><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_194"></a><p>ColorSync supports the profile format defined by the International Color Consortium (ICC). The ICC format provides a single cross-platform standard for translating color data across devices. The ICC’s common profile format allows one user to electronically transfer a document containing a color image to another user with the assurance that the original image will be rendered faithfully according to the source profile for the image.</p><p>To ensure this, the application or driver used to create the image stores the profile for the source device in the document containing the color image. The application can do this automatically or allow the user to tag the image. If the source profile is embedded within the document, a user can move the document from one system to another without concern for whether the profile used to create the image is available.</p><p>To support ColorSync, your application should, at a minimum, leave profile information intact in the documents and pictures it imports or copies. That is, your application should not strip out profile information from documents or pictures created with other applications. Even if your application does not use the profile information, users may be able to take advantage of it when using the documents or pictures with other applications.</p><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_195"></a>For example, profiles and profile identifiers may be embedded in pictures that a user pastes into documents created by your application. A profile identifier is an abbreviated data structure that identifies, and possibly modifies, a profile in memory or on disk. For more information on profile identifiers, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCCDIHG">Searching for a Profile That Matches a Profile Identifier</a></span>. Profiles and profile identifiers can be embedded in formats such as PICT or TIFF files. For files of type <code>'PICT'</code>, the <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_196"></a>ColorSync Manager defines the following picture comments for embedding profiles and profile identifiers, and for performing color matching:</p><div class="codesample"><table><tr><td scope="row"><pre>/* PicComment IDs */<span></span></pre></td></tr><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    cmBeginProfile          = 220,  /* begin ColorSync 1.0 profile */<span></span></pre></td></tr><tr><td scope="row"><pre>    cmEndProfile            = 221,  /* end a ColorSync 2.x or 1.0<span></span></pre></td></tr><tr><td scope="row"><pre>                                        profile */<span></span></pre></td></tr><tr><td scope="row"><pre>    cmEnableMatching        = 222,  /* begin color matching for either<span></span></pre></td></tr><tr><td scope="row"><pre>                                        ColorSync 2.x or 1.0 */<span></span></pre></td></tr><tr><td scope="row"><pre>    cmDisableMatching       = 223,  /* end color matching for either<span></span></pre></td></tr><tr><td scope="row"><pre>                                        ColorSync 2.x or 1.0 */<span></span></pre></td></tr><tr><td scope="row"><pre>    cmComment               = 224   /* embedded ColorSync 2.x profile<span></span></pre></td></tr><tr><td scope="row"><pre>                                        information */<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>The picture comment <code>kind</code> value of cmComment is defined for embedded ColorSync Manager version 2.x profiles and profile identifiers. This picture comment is followed by a 4-byte selector that describes the type of data in the picture comment.</p><div class="codesample"><table><tr><td scope="row"><pre>/* PicComment selectors for cmComment */<span></span></pre></td></tr><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    cmBeginProfileSel       = 0,    /* begining of a ColorSync 2.x<span></span></pre></td></tr><tr><td scope="row"><pre>                                        profile; profile data to<span></span></pre></td></tr><tr><td scope="row"><pre>                                        follow */<span></span></pre></td></tr><tr><td scope="row"><pre>    cmContinueProfileSel    = 1,    /* continuation of a ColorSync<span></span></pre></td></tr><tr><td scope="row"><pre>                                        2.x profile; profile data to<span></span></pre></td></tr><tr><td scope="row"><pre>                                        follow */<span></span></pre></td></tr><tr><td scope="row"><pre>    cmEndProfileSel         = 2     /* end of ColorSync 2.x profile<span></span></pre></td></tr><tr><td scope="row"><pre>                                        data; no profile data follows */<span></span></pre></td></tr><tr><td scope="row"><pre>    cmProfileIdentifierSel  = 3     /* profile identifier information<span></span></pre></td></tr><tr><td scope="row"><pre>                                        follows; the matching profile<span></span></pre></td></tr><tr><td scope="row"><pre>                                        may be stored in the image or<span></span></pre></td></tr><tr><td scope="row"><pre>                                        on disk */<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>Your application should leave these comments and the embedded profile information they define intact. Similarly, if your application imports or converts file types defined by other applications, your application should maintain the profile information embedded in those files, too.</p><p>Your application can also embed picture comments and profiles in documents and pictures it creates or modifies. For information describing how to do this, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJJGIG">Embedding Profiles and Profile Identifiers</a></span>. Inside Macintosh: Imaging With QuickDraw describes picture comments in detail.</p><a name="//apple_ref/doc/uid/TP30000278-BBCJDHBI" title="Obtaining Profile References"></a><h3>Obtaining Profile References</h3><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_197"></a>Most of the ColorSync Manager functions require that your application identify the profile or profiles to use in carrying out the work of the function. For example, when your application calls functions to perform color matching or color gamut checking, you must identify the profiles to use for the session. For functions that use QuickDraw, you specify a source profile and a destination profile. For general purpose functions, you specify a color world containing source and destination profiles or a set of concatenated profiles. You can also create a device link profile, which is described in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHGAEE">Creating and Using Device Link Profiles</a></span>, but to do so your application must first obtain references to all the profiles that will comprise the device link profile.</p><p>The ColorSync Manager provides for multiple concurrent accesses to a single profile through use of a private data structure called a profile reference. A <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_198"></a>profile reference is a unique reference to a profile; it is the means by which your application identifies a profile and gains access to the contents of that <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_199"></a>profile. Many applications can use the same profile at the same time, each with its own reference to the profile. However, an application can only change a profile if it has the only reference to the profile.</p><a name="//apple_ref/doc/uid/TP30000278-BBCICDIF" title="Opening a Profile and Obtaining a Reference to It"></a><h4>Opening a Profile and Obtaining a Reference to It</h4><p>To open a <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_200"></a>profile and obtain a reference to it, you call the function <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMOpenProfile" target="_top">CMOpenProfile</a></code>. You can also obtain a profile reference from the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMCopyProfile" target="_top">CMCopyProfile</a></code>, <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWNewLinkProfile" target="_top">CWNewLinkProfile</a></code>, and <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMNewProfile" target="_top">CMNewProfile</a></code> functions. To identify a profile that is file based, memory based, or accessed through a procedure, you must give its location.</p><p>The ColorSync Manager defines the <code>CMProfileLocation</code> data type to specify a profile’s location:</p><div class="codesample"><table><tr><td scope="row"><pre>struct CMProfileLocation {<span></span></pre></td></tr><tr><td scope="row"><pre>    short        locType;   /* specifies the location type */<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfLoc    u;         /* structure for specified type */<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>The <code>CMProfileLocation</code> structure contains the u field of type <code>CMProfLoc</code>. The <code>CMProfLoc</code> type is a union that can provide access to any of the structures <code>CMFileLocation</code>, <code>CMHandleLocation</code>, <code>CMPtrLocation</code>, or <code>CMProcedureLocation</code>.</p><p>The data you specify in the u field indicates the actual location of the profile. In most cases, a ColorSync profile is stored in a disk file and you use the union for a file specification. <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_201"></a>However, a profile can also be located in memory, or in an arbitrary location (such as a resource) that is accessed through a procedure provided by your application. For more information on profile access, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEEHBI">Accessing a Resource-Based Profile With a Procedure</a></span>. In addition, you can specify that a profile is temporary, meaning that it will not persist in memory after your application uses it for a color session.</p><p>To identify the data type in the <code>u</code> field of the <code>CMProfileLocation</code> structure, you assign to the <code>CMProfileLocation.locType</code> field one of the constants or numeric equivalents defined by the following enumeration:</p><div class="codesample"><table><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    cmNoProfileBase         = 0,    /* the profile is temporary */<span></span></pre></td></tr><tr><td scope="row"><pre>    cmFileBasedProfile      = 1,    /* file-based profile */<span></span></pre></td></tr><tr><td scope="row"><pre>    cmHandleBasedProfile    = 2,    /* handle-based profile */<span></span></pre></td></tr><tr><td scope="row"><pre>    cmPtrBasedProfile       = 3     /* pointer-based profile */<span></span></pre></td></tr><tr><td scope="row"><pre>    cmProcedureBasedProfile = 4     /* procedure-based profile */<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>For example, for a file-based profile, the <code>u</code> field would hold a file specification and the <code>locType</code> field would hold the constant <code>cmFileBasedProfile</code>. Your application passes a <code>CMProfileLocation</code> structure when it calls the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMOpenProfile" target="_top">CMOpenProfile</a></code> function and the function returns a reference to the specified profile.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_12" title="Note"></a><p><strong>Note:</strong>&nbsp;If you already have a profile reference for a profile, you can call the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/NCMGetProfileLocation" target="_top">NCMGetProfileLocation</a></code> function (available starting in ColorSync 2.5) or the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMGetProfileLocation" target="_top">CMGetProfileLocation</a></code> function (for previous versions of ColorSync) to obtain the location for the profile.</p></div><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHGJIG">Listing 4-2</a></span> shows an application-defined function, <code>MyOpenProfileFSSpec</code>, that assigns the file specification for a profile file to the <code>profLoc</code> union and identifies the location type as file-based. It then calls the <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_202"></a><code>CMOpenProfile</code> function, passing to it the profile’s file specification and receiving in return a reference to the profile.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_203"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_13" title="Listing 4-2Opening a reference to a file-based profile"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCHGJIG" title="Listing 4-2Opening a reference to a file-based profile"></a><strong>Listing 4-2&nbsp;&nbsp;</strong>Opening a reference to a file-based profile</p><div class="codesample"><table><tr><td scope="row"><pre>CMError MyOpenProfileFSSpec (FSSpec spec, CMProfileRef *prof)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMError                 theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileLocation       profLoc;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    profLoc.u.fileLoc.spec = spec;<span></span></pre></td></tr><tr><td scope="row"><pre>    profLoc.locType = cmFileBasedProfile;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = CMOpenProfile(prof, &amp;profLoc);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF106" title="Reference Counts for Profile References"></a><h4>Reference Counts for Profile References</h4><p>The ColorSync Manager keeps an internal reference count for each profile reference returned from a call to the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMOpenProfile" target="_top">CMOpenProfile</a></code>, <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMCopyProfile" target="_top">CMCopyProfile</a></code>, <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMNewProfile" target="_top">CMNewProfile</a></code>, or <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWNewLinkProfile" target="_top">CWNewLinkProfile</a></code> functions. Calling the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMCloneProfileRef" target="_top">CMCloneProfileRef</a></code> function increments the count; calling the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMCloseProfile" target="_top">CMCloseProfile</a></code> function decrements it. When the count reaches 0, the ColorSync Manager releases all private memory, files, or resources allocated in association with that profile. The profile remains open as long as the reference count is greater than 0, indicating that at least one task retains a reference to the profile. You can determine the current reference count for a profile reference by calling the <code>CMGetProfileRefCount</code> function.</p><p>When your application passes a copy of a profile reference to an independent task, whether synchronous or asynchronous, the task should call CMCloneProfileRef to increment the reference count. Both the called task and the caller should call <code>CMCloseProfile</code> when finished with the profile reference. This ensures that the tasks can finish independently of each other.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_14" title="Important:"></a><p><strong>Important:</strong>&nbsp;You call CMCloneProfileRef after copying a profile reference but not after duplicating an entire profile (as with the CMCopyProfile function).</p><p></p></div><p>When your application passes a copy of a profile reference internally, it may not need to call CMCloneProfileRef, as long as the application calls <code>CMCloseProfile</code> once and only once for the profile.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_15" title="Important:"></a><p><strong>Important:</strong>&nbsp;In your application, make sure that <code>CMCloseProfile</code> is called once for each time a profile reference is created or cloned. Otherwise, the private memory and resources associated with the profile reference may not be properly freed, or a task may attempt to use a profile reference that is no longer valid.</p><p></p></div><a name="//apple_ref/doc/uid/TP30000278-BBCJCDEE" title="Poor Man&acirc;&#128;&#153;s Exception Handling"></a><h3>Poor Man’s Exception Handling</h3><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_204"></a><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHHHHF">Listing 4-3</a></span> shows a macro definition that is used in several subsequent code listings. In this macro, if <code>assertion</code> evaluates to <code>false</code>, execution continues at the location <code>exception</code>. Otherwise, execution continues at the next statement following the macro.</p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_16" title="Listing 4-3Poor man&acirc;&#128;&#153;s exception handling macro"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCHHHHF" title="Listing 4-3Poor man&acirc;&#128;&#153;s exception handling macro"></a><strong>Listing 4-3&nbsp;&nbsp;</strong>Poor man’s exception handling macro</p><div class="codesample"><table><tr><td scope="row"><pre>// Equivalent to  if ((assertion) == false) goto exception;<span></span></pre></td></tr><tr><td scope="row"><pre>#define require(assertion, exception)   \<span></span></pre></td></tr><tr><td scope="row"><pre>    do {                                \<span></span></pre></td></tr><tr><td scope="row"><pre>        if (assertion) ;                \<span></span></pre></td></tr><tr><td scope="row"><pre>        else { goto exception; }        \<span></span></pre></td></tr><tr><td scope="row"><pre>    } while (false)<span></span></pre></td></tr></table></div><p>You can find examples of how to use this macro in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJDBBB">Listing 4-4</a></span>, <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFJFBE">Listing 4-5</a></span> and others. While this style of poor man’s exception handling may not appeal to all developers, it does offer these advantages:</p><ul class="spaceabove"><li class="li"><p>It improves readability because it avoids pushing code off the page with multiple nested if then else clauses and by limiting the number of <code>return</code> statements in the code.</p></li><li class="li"><p>You can enhance the macro to provide debug messages that supply useful runtime information about the error or where it occurred.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_205"></a></p></li></ul><a name="//apple_ref/doc/uid/TP30000278-BBCJJBEF" title="Identifying the Current System Profile"></a><h3>Identifying the Current System Profile</h3><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_206"></a>For the functions <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/NCMBeginMatching" target="_top">NCMBeginMatching</a></code>, <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/NCMUseProfileComment" target="_top">NCMUseProfileComment</a></code>, and <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/NCWNewColorWorld" target="_top">NCWNewColorWorld</a></code>, your application can specify <code>NULL</code> to signify the system profile. For all other functions—for example, the <code>CMGetProfileElement</code> function, the <code>CMValidateProfile</code> function, and the <code>CMCopyProfile</code> function—for which you want to specify the system profile, you must give an explicit reference to the profile. You can use the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMGetSystemProfile" target="_top">CMGetSystemProfile</a></code> function to obtain a reference to the system profile.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_17" title="Important:"></a><p><strong>Important:</strong>&nbsp;Starting with ColorSync version 2.5, the system profile is used primarily for backward compatibility, as described in <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCIEIEE">Setting Default Profiles</a></span>. As a result, you should not use the system profile as a source or destination profile if you can determine a specific profile to use instead. For example, you may want to call <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMGetDefaultProfileBySpace" target="_top">CMGetDefaultProfileBySpace</a></code> to get the default profile for a specific color space or <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMGetProfileByAVID" target="_top">CMGetProfileByAVID</a></code> to get a profile for a specific display.</p><p></p></div><p>Each <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_207"></a>profile, including the profile configured as the system profile, has a name associated with it. If your application needs to display the name of the system profile to the user, it can call <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_208"></a>CMGetSystemProfile, as shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHHGEF">Figure 4-4</a></span>, to get the system profile, then call the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMGetScriptProfileDescription" target="_top">CMGetScriptProfileDescription</a></code> function to get the profile name and script code.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_209"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_210"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_211"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_212"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_213"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_214"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_18" title="Listing 4-4Identifying the current system profile"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCJDBBB" title="Listing 4-4Identifying the current system profile"></a><strong>Listing 4-4&nbsp;&nbsp;</strong>Identifying the current system profile</p><div class="codesample"><table><tr><td scope="row"><pre>CMError MyPrintSystemProfileName (void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMError         theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileRef    sysProf;<span></span></pre></td></tr><tr><td scope="row"><pre>    Str255          profName;<span></span></pre></td></tr><tr><td scope="row"><pre>    ScriptCode      profScript;<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = CMGetSystemProfile(&amp;sysProf);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = CMGetScriptProfileDescription(sysProf, profName,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                &amp;profScript);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre>    // … call Script Mgr to get correct font for script …<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    DrawString(profname);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Do any necessary cleanup. In this case, just return.<span></span></pre></td></tr><tr><td scope="row"><pre>cleanup:<span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-BBCFEFGH" title="Getting the Profile for the Main Display"></a><h3>Getting the Profile for the Main Display</h3><p>Starting with ColorSync version 2.5, a user can select a separate profile for each display, as described in <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCCGCHJ">Setting a Profile for Each Monitor</a></span>. In your code, you can determine the profile for any display for which you know the AVID by calling the function <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMGetProfileByAVID" target="_top">CMGetProfileByAVID</a></code>, which is also new in version 2.5. You can get more information about AVID values from the Display Manager SDK.</p><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFJFBE">Listing 4-5</a></span> shows how to get the profile for the main display (the one that contains the menu bar).<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_215"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_19" title="Listing 4-5Getting the profile for the main display"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCFJFBE" title="Listing 4-5Getting the profile for the main display"></a><strong>Listing 4-5&nbsp;&nbsp;</strong>Getting the profile for the main display</p><div class="codesample"><table><tr><td scope="row"><pre>CMError GetProfileForMainDisplay (CMProfileRef *prof)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMError     theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    AVIDType    theAVID;<span></span></pre></td></tr><tr><td scope="row"><pre>    GDHandle    theDevice;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the main GDevice.<span></span></pre></td></tr><tr><td scope="row"><pre>    theDevice = GetMainDevice();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the AVID for that device.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = DMGetDisplayIDByGDevice(theDevice, &amp;theAVID, true);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the profile for that AVID.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = GetProfileByAVID(theAVID, prof);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Do any necessary cleanup. In this case, just return.<span></span></pre></td></tr><tr><td scope="row"><pre>cleanup:<span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This code first gets a graphic device handle for the main display, then calls the Display Manager routine <code>DMGetDisplayIDByGDevice</code> to get an AVID for the device. It then passes the AVID to the ColorSync Manager routine <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMGetProfileByAVID" target="_top">CMGetProfileByAVID</a></code> to get a profile reference to the profile for the display.</p><a name="//apple_ref/doc/uid/TP30000278-BBCGGDII" title="Matching to Displays Using QuickDraw-Specific Operations"></a><h3>Matching to Displays Using QuickDraw-Specific Operations</h3><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_216"></a>To provide images and pictures showing consistent colors across displays, your application can use ColorSync to match the colors in a user’s pictures and documents with the colors available on the user’s current display. If a color cannot be reproduced on the system’s current display, ColorSync maps the color to the color gamut of the display according to the specifications defined by the profiles. <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCGJIJA">When Color Matching Occurs</a></span> describes both QuickDraw-specific and general purpose ColorSync functions for color matching.</p><p>The ColorSync Manager provides two QuickDraw-specific functions that your application can call to draw a color picture to the current display. The function <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/NCMDrawMatchedPicture" target="_top">NCMDrawMatchedPicture</a></code> matches the picture’s colors to the display’s gamut defined by the specified display profile. It uses the system profile as the initial source profile but switches to any embedded profiles as they are encountered. The function <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/NCMBeginMatching" target="_top">NCMBeginMatching</a></code> uses the source and destination profiles you specify to match the colors of the source image to the colors of the device for which it is destined.</p><p>The current display device’s profile is typically configured as the <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_217"></a>system profile. A user can do this with the ColorSync control panel. However, starting with ColorSync 2.5, a user can use the Monitors &amp; Sound control panel to set a separate profile for each display, as described in <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCCGCHJ">Setting a Profile for Each Monitor</a></span>. When a user sets a profile for a display, ColorSync makes that profile the current default system profile.</p><p>Because the ColorSync Manager assumes the system profile is that of the current display, you can pass a value of <code>NULL</code> to the QuickDraw-specific functions instead of supplying an explicit profile reference. Passing <code>NULL</code> for a profile reference directs the ColorSync Manager to use the system profile. Note however, that starting with ColorSync 2.5, if you know the primary display for the image, and you know the AVID for that display, you can call <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMGetProfileByAVID" target="_top">CMGetProfileByAVID</a></code> to get the profile for the specific display. For example, <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFJFBE">Listing 4-5</a></span> shows how to get the profile for the main display (the one with the menu bar).</p><p>The following sections describe how to use ColorSync’s QuickDraw-specific matching functions, which automatically perform color matching in a manner acceptable to most applications. However, if your application needs a finer level of control over color matching than is supplied by the QuickDraw-specific functions, you can use the general purpose functions described in<span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFBAG">Matching Colors Using the General Purpose Functions</a></span> to match the colors of a bitmap, a pixel map, or a list of colors.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF107" title="Matching Colors in a Picture Containing an Embedded Information"></a><h4>Matching Colors in a Picture Containing an Embedded Information</h4><p>If a user copies a picture that includes a profile or profile identifier into one of your application’s documents, your application can use the ColorSync Manager’s QuickDraw-specific function <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/NCMDrawMatchedPicture" target="_top">NCMDrawMatchedPicture</a></code> to match the colors in that picture to the display on which you draw it.</p><p>As the picture is drawn, the <code>NCMDrawMatchedPicture</code> function automatically matches all colors to the color gamut of the display device, using the destination profile passed in the <code>dst</code> parameter. To use this function, you need to supply only the profile for the destination display device. The function acknowledges color-matching picture comments embedded in the picture and uses embedded profiles and profile identifiers. The source profile for the device on which the image was created should be embedded in the QuickDraw picture whose handle you pass to the function; the <code>NCMDrawMatchedPicture</code> function uses the embedded source profile, if it exists. If the source profile is not embedded, the function uses the current system profile as the source profile.</p><p>A picture may have more than one profile embedded, and may embed profile identifiers that refer to, and possibly modify, embedded profiles or profiles on disk. If the profiles and profile identifiers are embedded correctly, the <code>NCMDrawMatchedPicture</code> function will use them successively, as they are encountered.</p><p>By specifying <code>NULL</code> as the destination profile when you use this function, you are assured that the system profile—typically set to the profile for the main screen—is used as the destination profile. Alternatively, your application can call the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMGetSystemProfile" target="_top">CMGetSystemProfile</a></code> function to obtain a reference to the profile and specify the system profile explicitly. Or, starting in ColorSync version 2.5, if you know the AVID for the display on which drawing takes place, you can call <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMGetProfileByAVID" target="_top">CMGetProfileByAVID</a></code> to get the profile for the display.</p><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCCHAGB">Listing 4-6</a></span> shows sample code that uses the QuickDraw-specific function <code>NCMDrawMatchedPicture</code> to perform color matching to a display. The code gets a profile for the destination display using an AVID if it is available; otherwise, it passes <code>NULL</code> to the <code>NCMDrawMatchedPicture</code> function to specify the system profile.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_218"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_219"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_20" title="Listing 4-6Matching a picture to a display"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCCHAGB" title="Listing 4-6Matching a picture to a display"></a><strong>Listing 4-6&nbsp;&nbsp;</strong>Matching a picture to a display</p><div class="codesample"><table><tr><td scope="row"><pre>// Matching a picture to a display<span></span></pre></td></tr><tr><td scope="row"><pre>CMError MyDrawPictureToADisplay (PicHandle thePict, AVIDType theAVID, Rect *destRect)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMError         theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileRef    destProf;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Init for error handling.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    destProf = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If caller supplied an AVID and CS 2.5 is running...<span></span></pre></td></tr><tr><td scope="row"><pre>    if (theAVID &amp;&amp; ColorSync25Available() )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = GetProfileByAVID(theAVID, &amp;destProf);<span></span></pre></td></tr><tr><td scope="row"><pre>        require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Use the System profile as the destination.<span></span></pre></td></tr><tr><td scope="row"><pre>        destProf = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // Draw the picture, with color matching.<span></span></pre></td></tr><tr><td scope="row"><pre>    NCMDrawMatchedPicture(thePict, destProf, destRect);<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = QDError();<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Do any necessary cleanup. If necessary, close the profile.<span></span></pre></td></tr><tr><td scope="row"><pre>cleanup:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (destProf)<span></span></pre></td></tr><tr><td scope="row"><pre>        CMCloseProfile(destProf);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF108" title="More on Embedded Information"></a><h4>More on Embedded Information</h4><p>For embedded profiles (and profile identifiers) to operate correctly, the currently effective profile must be terminated by a picture comment of <code>kind</code><code>cmEndProfile</code> after drawing operations using that profile are performed. If a picture comment was not specified to end the profile, the profile will remain in effect until the next embedded profile is encountered with a picture comment of <code>kind cmBeginProfile</code>. However, use of the next profile might not be the intended action. It is good practice to always pair use of the <code>cmBeginProfile</code> and <code>cmEndProfile</code> picture comments. When the ColorSync Manager encounters an <code>cmEndProfile</code> picture comment, it restores use of the system profile for matching until it encounters another <code>cmBeginProfile</code> picture comment.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_21" title="Note"></a><p><strong>Note:</strong>&nbsp;Profile identifiers are also stored with picture comments. For more information on profile identifiers, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJJGIG">Embedding Profiles and Profile Identifiers</a></span> and <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCCDIHG">Searching for a Profile That Matches a Profile Identifier</a></span>.</p></div><p>If your application allows a user to modify and save an image that you color matched using the function <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/NCMUseProfileComment" target="_top">NCMUseProfileComment</a></code>, your application should either embed the destination profile in the picture file or convert and match the colors of the modified image to the colors of the source profile. By doing this your application ensures the integrity of the image during future operations and display. The method you choose is specific to your application.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF109" title="Matching Colors as a User Draws a Picture"></a><h4>Matching Colors as a User Draws a Picture</h4><p>To use Color QuickDraw functions to draw a document with colors matched to a display, your application can simply use the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/NCMBeginMatching" target="_top">NCMBeginMatching</a></code> function before calling Color QuickDraw functions, then conclude its drawing with the <code>CMEndMatching</code> function. For example, you might want to do this to customize settings in the profile that affect the matching operation. For more information on Color QuickDraw drawing functions, see Inside Macintosh: Imaging With QuickDraw.</p><p>To use the <code>NCMBeginMatching</code> function, you must specify both the source and destination profiles. The <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/NCMBeginMatching" target="_top">NCMBeginMatching</a></code> function returns a reference to the color-matching session in its myRef parameter. You then pass the reference to the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMEndMatching" target="_top">CMEndMatching</a></code> function to terminate color matching. Code for performing this operation is not shown here.</p><a name="//apple_ref/doc/uid/TP30000278-BBCIAFAE" title="Creating a Color World to Use With the General Purpose Functions"></a><h3>Creating a Color World to Use With the General Purpose Functions</h3><p>A color world is a reference to a private ColorSync structure that represents a unique color-matching session. Although profiles can be large, a color world is a compact representation of the mapping needed to match between profiles. Conceptually, you can think of a color world as a sort of matrix multiplication of two or more profiles that distills all the information contained in the profiles into a fast, multidimensional lookup table.</p><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_220"></a>For the ColorSync Manager general purpose functions, a color world characterizes how the color-matching session will occur based on information contained in the profiles that you supply when your application sets up the color world. <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCGJIJA">When Color Matching Occurs</a></span> describes both general purpose and QuickDraw-specific ColorSync functions for color matching. Your application can define a color world for color transformations between a source profile and a destination profile, or it can define a color world for color transformations between a series of concatenated profiles.</p><p>For the general purpose ColorSync Manager functions, a color world is the equivalent of the ColorSync Manager QuickDraw-based functions’ source and destination profiles. From your application’s perspective, the difference in specifying profiles for the general purpose functions is that instead of calling a function and passing it references to the profiles for the session, first you must create a color world using those profile references and pass the color world to the function. This general purpose interface provides better performance during color-matching.</p><p>Your application calls the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/NCWNewColorWorld" target="_top">NCWNewColorWorld</a></code> function to set up a simple color world for color transformations involving two profiles—a source profile and a destination profile—and the function returns a reference to the color world it creates. Setting up a color world for color processing involving a series of <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_221"></a>concatenated <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_222"></a>profiles or a single device link profile, which contains a series of profiles, is slightly more complex. Here are the steps you take:</p><ol class="ol"><li class="li"><p>Obtain references to the profiles to use for the concatenated color world.</p><p>For information describing how to obtain references to the profiles for the color world, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJDHBI">Obtaining Profile References</a></span>.</p></li><li class="li"><p>Set up an array containing references to the profiles comprising the set.</p><p>Before your application calls the function <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWConcatColorWorld" target="_top">CWConcatColorWorld</a></code> to create the color world, you must establish the profile set. The ColorSync Manager defines the following data structure of type <code>CMConcatProfileSet</code> that you use to specify the profile set:</p><p><code>struct CMConcatProfileSet { unsigned shortkeyIndex; unsigned shortcount; CMProfileRefprofileSet[1]; };</code></p><p>Your application also uses the <code>CMConcatProfileSet</code> data structure to define a profile set for a device link profile. See <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHGAEE">Creating and Using Device Link Profiles</a></span> for more information.</p><p>Your application creates an array that contains references to the profiles for the color world, specifying these references in processing order. You specify the one-based number of profile references in the array by setting the value of the <code>CMConcatProfileSet.count</code> field. You assign the profile array to the <code>CMConcatProfileSet.profileSet</code> field.</p><p>The ColorSync Manager defines rules governing the types of profiles you can specify in a profile array. These rules differ depending on whether you are creating a profile set to create a device link profile or to create a concatenated color world. For a list of the rules defining the types of profiles you can use for these purposes, see <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWNewLinkProfile" target="_top">CWNewLinkProfile</a></code> and <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWConcatColorWorld" target="_top">CWConcatColorWorld</a></code>.</p></li><li class="li"><p>Identify the CMM for color processing.</p><p>Each of the profiles whose references you give identifies a CMM for color processing involving that profile. To perform color transformation using a series of profiles, the ColorSync Manager uses only one <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_223"></a>CMM. You use the <code>CMConcatProfileSet.keyIndex</code> field to identify the index into the array corresponding to the profile whose specified CMM is to be used. The array is zero based, so you must specify the <code>CMConcatProfileSet.keyIndex</code> value as a number in the range of 0 to <code>count</code> – 1, where <code>count</code> is the number of elements in the array.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_22" title="Important:"></a><p><strong>Important:</strong>&nbsp;See <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBBFJD">How the ColorSync Manager Selects a CMM</a></span> for a complete description of the ColorSync algorithm for selecting a CMM.</p><p></p></div></li><li class="li"><p>Call the CWConcatColorWorld function to set up the color world.</p><p>You pass the <code>CWConcatColorWorld</code> function a parameter of type <code>CMConcatProfileSet</code> to specify the profile array, and the function returns a <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_224"></a>color world reference. To perform color matching or gamut checking using the profiles comprising a color world, you call the general purpose function passing it the reference to the color world.</p><p>Using a device link profile for the general purpose functions entails additional steps, described in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHGAEE">Creating and Using Device Link Profiles</a></span>.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_225"></a></p></li></ol><a name="//apple_ref/doc/uid/TP30000278-BBCBFBAG" title="Matching Colors Using the General Purpose Functions"></a><h2>Matching Colors Using the General Purpose Functions</h2><p><span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCGJIJA">When Color Matching Occurs</a></span> describes both general purpose and QuickDraw-specific ColorSync functions for color matching. Using the general purpose functions <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWMatchPixMap" target="_top">CWMatchPixMap</a></code> or <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWMatchBitmap" target="_top">CWMatchBitmap</a></code>, your application can match the colors of a pixel image or a bitmap image to the display’s color gamut without relying on QuickDraw.</p><p>Color matching occurs relatively quickly, but for a session involving a large pixel image or bitmap image, the color-matching process may take some time. To keep the user informed, you can provide a progress-reporting function. For example, your function can display an indicator, such as a progress bar, to depict how much of the matching has been done and how much remains. Your function can also allow the user to interrupt the color-matching process.</p><p>When your application calls either the <code>CWMatchPixMap</code> function or the <code>CWMatchBitmap</code> function, you can pass the function a pointer to your callback progress-reporting function and a reference constant containing data, such as the progress bar dialog box’s window reference. When the CMM used to match the colors calls your progress-reporting function, it passes the reference constant to it. If you provide a progress-reporting function, here is how you should declare the function, assuming you name it <code>MyCMBitmapCallBackProc:</code></p><div class="codesample"><table><tr><td scope="row"><pre>pascal Boolean MyCMBitmapCallBackProc (long progress, void *refCon);<span></span></pre></td></tr></table></div><p>For a complete description of the progress-reporting function declaration, see <code><!--a-->MyCMBitmapCallBackProc<!--/a--></code>.</p><p>To use the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWMatchPixMap" target="_top">CWMatchPixMap</a></code> and <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWMatchBitmap" target="_top">CWMatchBitmap</a></code> functions, your application must first set up a color world that specifies the profiles involved in the color-matching session as described in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCIAFAE">Creating a Color World to Use With the General Purpose Functions</a></span>. The color world establishes how matching will take place between the profiles. <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGFDDI">Listing 4-7</a></span> shows how to match the colors of a bitmap using the general purpose functions that take a color world.</p><p>The ColorSync Manager uses the <code>PixMap</code> data type defined by Color QuickDraw. The ColorSync Manager defines and uses the <code>cmBitmap</code> data type, based on the classic QuickDraw <code>Bitmap</code> data type.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF110" title="Matching the Colors of a Pixel Map to the Display&acirc;&#128;&#153;s Color Gamut"></a><h3>Matching the Colors of a Pixel Map to the Display’s Color Gamut</h3><p>Your application can call the function <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWMatchPixMap" target="_top">CWMatchPixMap</a></code> to match the colors of a pixel <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_226"></a>image to the display’s color gamut. To use <code>CWMatchPixMap</code>, you first create a color world, as described in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCIAFAE">Creating a Color World to Use With the General Purpose Functions</a></span>. The color world is based on the source profile for the device used to create the pixel image and the destination profile for the display on which the image is shown.</p><p>To match the colors of a pixel image to the display’s color gamut, the source profile for the color world must specify a data color space of RGB as its <code>dataColorSpace</code> element value to correspond to the pixel map data type, which is implicitly RGB. If the source profile you specify for the color world is the original source profile used to create the pixel image, most likely these values match. However, if you want to verify that the source profile’s <code>dataColorSpace</code> element specifies RGB, you can use the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMGetProfileHeader" target="_top">CMGetProfileHeader</a></code> function to obtain the profile header. The profile header contains the <code>dataColorSpace</code> element field. For a pixel image, the display profile’s <code>dataColorSpace</code> element must also be set to RGB; this is the color space commonly used for displays.</p><p>If the source profile is embedded in the document containing the pixel map, your application can extract the profile and open a reference to it before you create the color world. For information on how to extract an embedded profile, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEAAFB">Extracting Profiles Embedded in Pictures</a></span>. If the source profile is installed in the ColorSync Profiles folder, your application can display a list of profiles to the user to allow the user to select the appropriate one.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF111" title="Matching the Colors of a Bitmap Image to the Display&acirc;&#128;&#153;s Color Gamut"></a><h3>Matching the Colors of a Bitmap Image to the Display’s Color Gamut</h3><p>Matching <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_227"></a>the colors of a bitmap image to the current system’s display is similar to the process of matching a pixel map’s colors, except that the data type of a bitmap image is explicitly stated in the <code>space</code> field of the bitmap. You can specify a bitmap image using any of the following data types: <code>cmGraySpace</code>, <code>cmGrayASpace</code>, <code>cmRGB16Space</code>, cmRGB24Space, <code>cmRGB32Space</code>, <code>cmARGB32Space</code>, <code>cmRGB48Space</code>, <code>cmCMYK32Space</code>, <code>cmCMYK64Space</code>, <code>cmHSV32Space</code>, <code>cmHLS32Space</code>, <code>cmYXY32Space</code>, <code>cmXYZ32Space</code>, <code>cmLUV32Space</code>, <code>cmLAB24Space</code>, <code>cmLab32Space</code>, <code>cmLAB48Space</code>, <code>cmNamedIndexed32Space</code>, <code>cmMCFive8Space</code>, <code>cmMCSix8Space</code>, <code>cmMCSeven8Space</code>, or <code>cmMCEight8Space</code>. The data type of the source bitmap image must correspond to the data color space specified by the color world’s source profile.</p><p>When you call the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWMatchBitmap" target="_top">CWMatchBitmap</a></code> function, you can pass it a pointer to a bitmap to hold the resulting image. In this case, you must allocate the pixel buffer pointed to by the <code>image</code> field of the <code>CMBitmap</code> structure. Because the <code>CWMatchBitmap</code> function allows you to specify a separate bitmap to hold the resulting color-matched image, you must ensure that the data type you specify in the <code>space</code> field of the resulting bitmap matches the destination’s color data space. On input, the color space of the source profile must match the color space of the bitmap. If you specify <code>NULL</code> for the destination bitmap, on successful output, ColorSync will change the <code>space</code> field of the source bitmap to reflect the bitmap space to which the source image was mapped.</p><p>Rather than create a bitmap for the color-matched image, you can match the bitmap in place. To do so, you specify <code>NULL</code> instead of passing a pointer to a resulting bitmap.</p><p>The <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_228"></a>code in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGFDDI">Listing 4-7</a></span> shows how to set up a bitmap for the resulting color-matched image before calling the <code>CWMatchBitmap</code> function to perform the color matching. The <code>MyMatchImage</code> function calls the <code><!--a-->MyGetImageProfile<!--/a--></code> function (not shown) to obtain an embedded profile from the image. If none is found, it calls the <code><!--a-->MyGetImageSpace<!--/a--></code> function (also not shown) to determine the color space for the profile, then calls the ColorSync routine <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMGetDefaultProfileBySpace" target="_top">CMGetDefaultProfileBySpace</a></code> to obtain the default profile for that space.</p><p>The <code><!--a-->MyMatchImage<!--/a--></code> function then calls <code><!--a-->GetProfileForMainDisplay<!--/a--></code>, shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFJFBE">Listing 4-5</a></span>, to get the destination profile. It uses the source and destination profiles to set up a color world by calling <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/NCWNewColorWorld" target="_top">NCWNewColorWorld</a></code>, then uses the resulting color world when it calls <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWMatchBitmap" target="_top">CWMatchBitmap</a></code> to match the colors to the display.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_229"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_23" title="Listing 4-7Matching the colors of a bitmap using a color world"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCGFDDI" title="Listing 4-7Matching the colors of a bitmap using a color world"></a><strong>Listing 4-7&nbsp;&nbsp;</strong>Matching the colors of a bitmap using a color world</p><div class="codesample"><table><tr><td scope="row"><pre>void MyMatchImage (FSSpec theImage)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMError         theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileRef    sourceProf;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileRef    destProf;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMWorldRef      cw;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMBitmap        bitmap;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSType          theSpace;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Init for error handling. If any error during process,<span></span></pre></td></tr><tr><td scope="row"><pre>        jump to cleanup area and quit trying. */<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    sourceProf = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    destProf = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    cw = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    bitmap.image = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Determine source profile.<span></span></pre></td></tr><tr><td scope="row"><pre>    // 1st - try to find an embedded profile<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = MyGetImageProfile(theImage, &amp;sourceProf);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (theErr == noErr)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // 2nd - use default profile for the image space<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = MyGetImageSpace(theSpace, &amp;sourceProf);<span></span></pre></td></tr><tr><td scope="row"><pre>        require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = CMGetDefaultProfileBySpace(theSpace, &amp;sourceProf);<span></span></pre></td></tr><tr><td scope="row"><pre>        require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Determine dest profile.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = GetProfileForMainDisplay(&amp;destProf);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set up a color world.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = NCWNewColorWorld(&amp;cw, sourceProf, destProf);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // close profiles after setting up color world.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (sourceProf)<span></span></pre></td></tr><tr><td scope="row"><pre>        CMCloseProfile(sourceProf);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (destProf)<span></span></pre></td></tr><tr><td scope="row"><pre>        CMCloseProfile(destProf);<span></span></pre></td></tr><tr><td scope="row"><pre>    sourceProf = destProf = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Read the image into the CMBitmap structure<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = MyGetImageBitmap(theImage, &amp;bitmap);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Match bitmap in place.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = CWMatchBitmap(cw, &amp;bitmap, nil, nil, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Render results here ... (code not shown)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Do any necessary cleanup:close profiles and dispose of<span></span></pre></td></tr><tr><td scope="row"><pre>    color world and bitmap. */<span></span></pre></td></tr><tr><td scope="row"><pre>cleanup:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (sourceProf)<span></span></pre></td></tr><tr><td scope="row"><pre>        CMCloseProfile(sourceProf);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (destProf)<span></span></pre></td></tr><tr><td scope="row"><pre>        CMCloseProfile(destProf);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (cw)<span></span></pre></td></tr><tr><td scope="row"><pre>        CWDisposeColorWorld(cw);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (bitmap.image)<span></span></pre></td></tr><tr><td scope="row"><pre>        DisposePtr(bitmap.image);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-BBCJJGIG" title="Embedding Profiles and Profile Identifiers"></a><h2>Embedding Profiles and Profile Identifiers</h2><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_230"></a>When the user creates and saves a document or picture containing a color image created or modified with your application, your application can provide for future color matching by saving—along with that document or picture—the profile for the device on which the image was created or modified. In addition to a profile—or instead of a profile—your application can save a profile identifier. A profile identifier is an abbreviated data structure that identifies, and possibly modifies, a profile in memory or on disk.</p><p>When embedding source profiles or profile identifiers in the documents created by your application, you can store them in any manner that you choose. For example, you may choose to have your application store, in the resource fork of the document file, one profile for an entire image, or a separate profile for every object in an image, or a separate profile identifier that points to a profile on disk for every device on which the user modified the image.</p><p>When embedding source profiles or profile identifiers in PICT file pictures, your application should use the <code>cmComment</code> picture comment, which has a <code>kind</code> value of 224 and is defined for embedded version 2.x profiles. This comment is followed by a 4-byte selector that describes the type of data in the comment. The following selectors are currently defined:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Selector</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Value</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>cmBeginProfileSel</code></p></td><td ><p>0</p></td><td ><p>Beginning of a version 2.x profile. Profile data to follow.</p></td></tr><tr><td  scope="row"><p><code>cmContinueProfileSel</code></p></td><td ><p>1</p></td><td ><p>Continuation of version 2.x profile data. Profile data to follow.</p></td></tr><tr><td  scope="row"><p><code>cmEndProfileSel</code></p></td><td ><p>2</p></td><td ><p>End of version 2.x profile data. No profile data follows.</p></td></tr><tr><td  scope="row"><p><code>cmProfileIdentifierSel</code></p></td><td ><p>3</p></td><td ><p>Profile identifier follows. A profile identifier identifies a profile that may reside in memory or on disk.</p></td></tr></table></div><p>Because the <code>dataSize</code> parameter of the <code>PicComment</code> procedure is a signed 16-bit value, the maximum amount of profile data that can be embedded in a single picture comment is 32,763 bytes (32,767 – 4 bytes for the selector).</p><p>You can embed a larger profile by using multiple picture comments of selector type <code>cmContinueProfileSel</code>, as shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGFDDI">Listing 4-7</a></span>. You must embed the profile data in consecutive order, and you must conclude the profile data by embedding a picture comment of selector type <code>cmEndProfileSel</code>. The ColorSync Manager provides the <code>NCMUseProfileComment</code> function to automate the process of embedding profile information.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF112" title="Embedded Profile Format"></a><h3>Embedded Profile Format</h3><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGFDDI">Listing 4-7</a></span> shows how profile data is embedded in a PICT file picture as a series of picture comments. The illustration shows two embedded profiles. The first profile contains less than 20K of data, so its data can be stored in one picture comment with selector type <code>cmBeginProfileSel</code>. Note, however, that a second comment of selector type <code>cmEndProfileSel</code>, containing no data, concludes the embedded profile.</p><p>The second embedded profile shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGFDDI">Listing 4-7</a></span> has more than 32K of data, so its data must be stored in two consecutive picture comments. The first comment has selector type <code>cmBeginProfileSel</code>, while the second has type <code>cmContinueProfileSel</code>. If the profile were larger and required additional picture comments, each additional comment would have selector type <code>cmContinueProfileSel</code>. As with all embedded profiles, the final picture comment has selector type <code>cmEndProfileSel</code>.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF113" title="Embedding Different Profile Versions"></a><h3>Embedding Different Profile Versions</h3><p>For version 1.0 of the ColorSync Manager, you use picture comment types <code>cmBeginProfile</code> and <code>cmEndProfile</code> to begin and end a picture comment. The <code>cmBeginProfile</code> comment is not supported for ColorSync version 2.x profiles; however, the you can use the <code>cmEndProfile</code> comment to end the current profile for both ColorSync 1.0 and 2.x. Following a <code>cmEndProfile</code> comment, the ColorSync Manager reverts to the system profile. You use the <code>cmEnableMatching</code> and <code>cmDisableMatching</code> picture comments to begin and end color matching in both ColorSync 1.0 and 2.x. See <em>Inside Macintosh: Imaging With QuickDraw</em> for more information about picture comments.</p><br/><div><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_24" title="Figure 4-7Embedding profile data in a PICT file picture"></a><p><a name="//apple_ref/doc/uid/TP30000278-TPXREF134" title="Figure 4-7Embedding profile data in a PICT file picture"></a><strong>Figure 4-7&nbsp;&nbsp;</strong>Embedding profile data in a PICT file picture</p><img src = "../art/csul33.gif" alt = "Embedding profile data in a PICT file picture" width="452" height="425"></div><br/><a name="//apple_ref/doc/uid/TP30000278-TPXREF114" title="The NCMUseProfileComment Function"></a><h3>The NCMUseProfileComment Function</h3><p>The ColorSync Manager provides the function <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/NCMUseProfileComment" target="_top">NCMUseProfileComment</a></code> to automate the process of embedding a profile or profile identifier. This function generates the picture comments required to embed the specified profile or identifier into the open picture. It calls the QuickDraw <code>PicComment</code> function with a picture comment <code>kind</code> value of <code>cmComment</code> and a 4-byte selector that describes the type of data in the picture comment: 0 to begin the profile, 1 to continue, and 2 to end the profile; or 3 for a profile identifier. For a profile, if the size in bytes of the profile and the 4-byte selector together exceed 32 KB, this function segments the profile data and embeds the multiple segments in consecutive order using selector 1 to embed each segment.</p><p>For embedded profiles or profile identifiers to work correctly, the currently effective profile must be terminated by a picture comment of <code>kind</code><code>cmEndProfile</code> after drawing operations using that profile are performed. If you do not specify a picture comment to end the profile, the profile will remain in effect until the next embedded profile is introduced with a picture comment of <code>kind</code><code>cmBeginProfile</code>. It is good practice to always pair use of the <code>cmBeginProfile</code> and <code>cmEndProfile</code> picture comments. When the ColorSync Manager encounters a <code>cmEndProfile</code> picture comment, it restores use of the system profile for matching until it encounters another <code>cmBeginProfile</code> picture comment.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_25" title="Important:"></a><p><strong>Important:</strong>&nbsp;The <code>NCMUseProfileComment</code> function does not automatically terminate the embedded profile or profile identifier with a <code>cmEndProfile</code> picture comment. You must add a picture comment of <code>kind cmEndProfile</code> when the drawing operations to which the profile applies are complete. Otherwise, the profile remains in effect until the next embedded profile with a picture comment of <code>kind cmBeginProfile</code> is encountered.</p><p></p></div><p>In addition to embedded profiles, an image may contain embedded profile identifiers, which are stored with the selector cmProfileIdentifierSel. For more information on profile identifiers, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCCDIHG">Searching for a Profile That Matches a Profile Identifier</a></span>, and <code>CMProfileIdentifier</code>.</p><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFGBJC">Listing 4-8</a></span> shows how to embed a profile in a picture file. The <code>MyPreprendProfileToPicHandle</code> function creates a new picture, embeds the profile for the device used to create the picture, then draws the picture. The caller passes a reference for the profile as the <code>prof</code> parameter. Note that after <code>MyPreprendProfileToPicHandle</code> calls the <code>NCMUseProfileComment</code> function to embed the profile, it calls its own <code>MyEndProfileComment</code> function to embed a comment of <code>kind</code><code>cmEndProfile</code>, ensuring that the profile is properly terminated.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_231"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_26" title="Listing 4-8Embedding a profile by prepending it before its associated picture"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCFGBJC" title="Listing 4-8Embedding a profile by prepending it before its associated picture"></a><strong>Listing 4-8&nbsp;&nbsp;</strong>Embedding a profile by prepending it before its associated picture</p><div class="codesample"><table><tr><td scope="row"><pre>CMError MyPrependProfileToPicHandle (<span></span></pre></td></tr><tr><td scope="row"><pre>                PicHandle pict,<span></span></pre></td></tr><tr><td scope="row"><pre>                PicHandle *pictNew,<span></span></pre></td></tr><tr><td scope="row"><pre>                CMProfileRef prof,<span></span></pre></td></tr><tr><td scope="row"><pre>                Boolean embedAsIdentifier)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr           theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGrafPtr        savePort;<span></span></pre></td></tr><tr><td scope="row"><pre>    GDHandle        saveGDev;<span></span></pre></td></tr><tr><td scope="row"><pre>    GWorldPtr       tempWorld;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect            pictRect;<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned long   flags;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Init for error handling.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    tempWorld = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Check parameters<span></span></pre></td></tr><tr><td scope="row"><pre>    if (prof == nil) theErr = paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Determine whether to embed as identifier or whole profile.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (embedAsIdentifier)<span></span></pre></td></tr><tr><td scope="row"><pre>        flags = cmEmbedProfileIdentifier;<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        flags = cmEmbedWholeProfile;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a temporary graphics world.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = NewSmallGWorld(&amp;tempWorld);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Save current world and switch to temporary.<span></span></pre></td></tr><tr><td scope="row"><pre>    GetGWorld(&amp;savePort, &amp;saveGDev);<span></span></pre></td></tr><tr><td scope="row"><pre>    SetGWorld(tempWorld, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>    pictRect = (**pict).picFrame;<span></span></pre></td></tr><tr><td scope="row"><pre>    ClipRect(&amp;pictRect);                // Important: set clipRgn.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a new picture.<span></span></pre></td></tr><tr><td scope="row"><pre>    *pictNew = OpenPicture(&amp;pictRect);  // Start recording.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = NCMUseProfileComment(prof,flags);<span></span></pre></td></tr><tr><td scope="row"><pre>    DrawPicture(pict, &amp;pictRect);<span></span></pre></td></tr><tr><td scope="row"><pre>    MyEndProfileComment();              // Routine shown below.<span></span></pre></td></tr><tr><td scope="row"><pre>    ClosePicture();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        KillPicture(*pictNew);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetGWorld(savePort, saveGDev);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Do any necessary cleanup:dispose of graphics world.<span></span></pre></td></tr><tr><td scope="row"><pre>cleanup:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (tempWorld)<span></span></pre></td></tr><tr><td scope="row"><pre>        DisposeGWorld(tempWorld);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is the application-defined <code>MyEndProfileComment</code> function called by <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_232"></a>MyPrependProfileToPicHandle to add the <code>cmEndProfile</code> picture comment to terminate the profile:<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_233"></a></p><div class="codesample"><table><tr><td scope="row"><pre>void MyEndProfileComment (void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    PicComment(cmEndProfile, 0, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-BBCEAAFB" title="Extracting Profiles Embedded in Pictures"></a><h2>Extracting Profiles Embedded in Pictures</h2><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_234"></a>To color match or gamut check a picture embedded in a document, your application should first check for embedded profiles in the document. If a profile is found, your application can then open a reference to the profile and use it as the source profile. This process requires you to locate and identify the profile for the image within the document and extract the profile data from the document file.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_27" title="Note"></a><p><strong>Note:</strong>&nbsp;If you use the QuickDraw-specific <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/NCMDrawMatchedPicture" target="_top">NCMDrawMatchedPicture</a></code> function, you do not need to extract the source profile from the PICT file.</p></div><p>To extract an embedded profile, your application can use the function <code><!--a-->CMUnflattenProfile<!--/a--></code>. This function takes a pointer to a low-level data-transfer function that your application supplies to transfer the profile data from the document containing it. This function assumes that your low-level data-transfer function is informed about the context of the profile. After all of the profile data has been transferred, the <code>CMUnflattenProfile</code> function returns the file specification for the profile.</p><p>Prior to ColorSync 2.5, when your application calls the <code>CMUnflattenProfile</code> function, the ColorSync Manager uses the Component Manager to pass the pointer to your low-level data-transfer function along with the reference constant your application can use as it desires. The CMM is determined by the selection process described in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBBFJD">How the ColorSync Manager Selects a CMM</a></span>. The CMM calls your low-level data-transfer function, directing it to open the file containing the profile, read segments of the profile data, and return the data to the CMM’s calling function.</p><p>The CMM communicates with your low-level data transfer-function using a command parameter to identify the operation to perform. To facilitate the transfer of profile data from the file to the CMM, the CMM passes to your function a pointer to a data buffer for data, the size in bytes of the profile data your function should return, and the reference constant passed from the calling application.</p><p>On return, your function passes to the CMM segments of the profile data and the number of bytes of profile data you actually return.</p><p>Starting with ColorSync 2.5, the ColorSync Manager calls your transfer function directly, without going through the preferred, or any, CMM. On return from <code>CMUnflattenProfile</code>, the value of <code>preferredCMMnotfound</code> is guaranteed to be <code>false</code>.</p><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHAGCB">Listing 4-9</a></span> and <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGEHIB">Listing 4-10</a></span> show portions of a sample application called CSDemo, available as part of the ColorSync SDK. You can find the complete sample application on the Developer CD series, or at the web site &lt;http://developer.apple.com/sdk>.</p><p>In these listings, all variables beginning with a lowercase letter g are global variables previously defined. The application uses global variables to pass data between functions that do not include reference constant parameters. <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHAGCB">Listing 4-9</a></span> counts the profiles in a PICT file, while <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGEHIB">Listing 4-10</a></span> extracts a profile, identified by an index number, from a PICT file.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF115" title="Counting the Profiles in the PICT File"></a><h3>Counting the Profiles in the PICT File</h3><p>Given a <code>picHandle</code> value to a picture containing an embedded profile, the sample code shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGEHIB">Listing 4-10</a></span> counts the number of profiles in the picture.</p><p>The <code>MyCountProfilesInPicHandle</code> function calls the Toolbox function SetStdCProcs to get the current QuickDraw drawing bottleneck procedures, then sets the bottlenecks to its own routines. It initializes its global counter, <code>gCount</code>, which holds a single count summing both ColorSync 1.0 profiles and version 2.x profiles, to zero. The <code>MyCountProfilesInPicHandle</code> function calls its own drawing function, <code>MyDrawPicHandleUsingBottleneck</code>, not shown here, to draw the picture. The drawing function sets up a port that uses the private bottleneck routines.</p><p>As the picture is drawn, the MyCountProfilesCommentProc bottleneck procedure counts the number of profiles encountered. <code>MyCountProfilesCommentProc</code> checks for both version 1.0 profiles and version 2.x profiles and increments the global count when it finds either type. You can easily modify this code to keep separate counts if necessary.</p><p><code>MyCountProfilesInPicHandle</code> doesn’t use any other QuickDraw bottlenecks, so it uses nonoperational routines (routines that do nothing but return) for all other bottlenecks. The prototype for a function to handle the <code>TextProc</code> bottleneck, for example, can be defined as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>static pascal void MyNoOpTextProc ( short byteCount,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    Ptr textAddr,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    Point numer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    Point denom);<span></span></pre></td></tr></table></div><p>For a general discussion of customizing QuickDraw’s bottleneck routines, see Customizing QuickDraw’s Text Handling in Inside Macintosh: Text.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_235"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_28" title="Listing 4-9Counting the number of profiles in a picture"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCHAGCB" title="Listing 4-9Counting the number of profiles in a picture"></a><strong>Listing 4-9&nbsp;&nbsp;</strong>Counting the number of profiles in a picture</p><div class="codesample"><table><tr><td scope="row"><pre>CMError MyCountProfilesInPicHandle (PicHandle pict, unsigned long *count)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr       theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    CQDProcs    procs;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Set up bottleneck for picComments so we can count the profiles. */<span></span></pre></td></tr><tr><td scope="row"><pre>    SetStdCProcs(&amp;procs);<span></span></pre></td></tr><tr><td scope="row"><pre>    procs.textProc    = NewQDTextProc (MyNoOpTextProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    procs.lineProc    = NewQDLineProc (MyNoOpLineProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    procs.rectProc    = NewQDRectProc (MyNoOpRectProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    procs.rRectProc   = NewQDRRectProc (MyNoOpRRectProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    procs.ovalProc    = NewQDOvalProc (MyNoOpOvalProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    procs.arcProc     = NewQDArcProc (MyNoOpArcProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    procs.polyProc    = NewQDPolyProc (MyNoOpPolyProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    procs.rgnProc     = NewQDRgnProc (MyNoOpRgnProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    procs.bitsProc    = NewQDBitsProc (MyNoOpBitsProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    procs.commentProc = NewQDCommentProc(MyCountProfilesCommentProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    procs.txMeasProc  = NewQDTxMeasProc (MyNoOpTxMeasProc);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Initialize the global counter to be incremented by the commentProc. */<span></span></pre></td></tr><tr><td scope="row"><pre>    gCount = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Draw the picture and count the profiles while drawing. */<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = MyDrawPicHandleUsingBottlenecks (pict, procs, nil);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Obtain the result from the count global variable. */<span></span></pre></td></tr><tr><td scope="row"><pre>    *count = gCount;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Clean up and return. */<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(procs.textProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(proc.lineProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(procs.rectProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(procs.rRectProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(procs.ovalProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(procs.arcProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(procs.polyProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(procs.rgnProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(procs.bitsProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(procs.commentProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(procs.txMeasProc);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal void MyCountProfilesCommentProc (short kind,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        short dataSize,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        Handle dataHandle)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    long    selector;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch (kind)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case cmBeginProfile<span></span></pre></td></tr><tr><td scope="row"><pre>            gCount ++;  // We found a ColorSync 1.0 profile; increment the count.<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case cmComment;<span></span></pre></td></tr><tr><td scope="row"><pre>            // Break if dataSize is too small to be a selector.<span></span></pre></td></tr><tr><td scope="row"><pre>            if (dataSize &lt;= 4) break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Since dataSize is >= 4, we can get a selector from the first long.<span></span></pre></td></tr><tr><td scope="row"><pre>            selector = *((long *)(*dataHandle));<span></span></pre></td></tr><tr><td scope="row"><pre>            if (selector == cmBeginProfileSel)<span></span></pre></td></tr><tr><td scope="row"><pre>                gCount ++;  // We found a ColorSync 2.xprofile; increment the count.<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF116" title="Extracting a Profile"></a><h3>Extracting a Profile</h3><p>Flattening refers to transferring a profile stored in an independent disk file to an external profile format that can be embedded in a graphics document. Unflattening refers to transferring from the embedded format to an independent disk file.</p><p>This part of the sample application identifies the profile to unflatten, unflattens the profile, creates a temporary profile, and disposes of the original. To perform these tasks, the code must again draw the picture using the bottleneck routines.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF117" title="Part A: Calling the Unflatten Function"></a><h4>Part A: Calling the Unflatten Function</h4><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGEHIB">Listing 4-10</a></span> shows the MyGetIndexedProfileFromPicHandle entry point function that drives the process of unflattening the profile. The function creates a universal procedure pointer (UPP), <code>MyflattenUPP</code>, that points to the low-level data-transfer procedure.</p><p>A PICT handle may contain more than one profile. To identify the profile to unflatten, the <code>MyGetIndexedProfileFromPicHandle</code> function contains an <code>index</code> parameter that specifies the profile’s index. The function stores the index in the global variable <code>gIndex</code> so that the value is accessible by the application’s other functions that check for the correct profile and extract it. Then, the function calls the <code>CMUnflattenProfile</code> function, passing it the <code>MyflattenUPP</code> pointer. This invokes the <code>MyUnflattenProc</code> function shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGBA">Listing 4-11</a></span>.</p><p>The function <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_236"></a>MyGetIndexedProfileFromPicHandle, shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGEHIB">Listing 4-10</a></span>, first calls <code><!--a-->CMUnflattenProfile<!--/a--></code> to create an independent file-based profile, then calls the function <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMOpenProfile" target="_top">CMOpenProfile</a></code> to open a temporary profile reference to the file-based profile. It then calls <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMCopyProfile" target="_top">CMCopyProfile</a></code> to create a copy of the profile reference. Finally, the function disposes of the original profile. The purpose for creating a temporary profile, copying it into the specified location, then deleting the temporary profile, is to adhere to the copyright protection for embedded profiles specified by the <code>flags</code> field in the profile header.</p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_29" title="Listing 4-10Calling the CMUnflattenProfile function to extract an embedded profile"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCGEHIB" title="Listing 4-10Calling the CMUnflattenProfile function to extract an embedded profile"></a><strong>Listing 4-10&nbsp;&nbsp;</strong>Calling the CMUnflattenProfile function to extract an embedded profile</p><div class="codesample"><table><tr><td scope="row"><pre>CMError MyGetIndexedProfileFromPicHandle (PicHandle pict,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            unsigned long index,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            CMProfileRef *prof,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            CMProfileLocation *profLoc)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMError             theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned long       refCon;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMFlattenUPP        myFlattenUPP;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean             preferredCMMNotFound;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean             tempCreated;<span></span></pre></td></tr><tr><td scope="row"><pre>    FSSpec              tempSpec;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileRef        tempProf;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileLocation   tempProfLoc;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Init for error handling.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    tempCreated = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    tempProf = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a universal procedure pointer for the<span></span></pre></td></tr><tr><td scope="row"><pre>    // unflatten procedure shown in Listing 3-11.<span></span></pre></td></tr><tr><td scope="row"><pre>    myFlattenUPP = NewCMFlattenProc(MyUnflattenProc);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Pass the pict as the refcon.<span></span></pre></td></tr><tr><td scope="row"><pre>    refCon = (unsigned long) pict;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set the global index variable to the index of the profile we’re looking for.<span></span></pre></td></tr><tr><td scope="row"><pre>    gIndex = index;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // The next call invokes the MyUnflattenProc shown in Listing 3-11.<span></span></pre></td></tr><tr><td scope="row"><pre>    //On return, tempSpec identifies the newly created profile on disk.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = CMUnflattenProfile(&amp;tempSpec, myFlattenUPP,(void*)&amp;refCon,<span></span></pre></td></tr><tr><td scope="row"><pre>                            &amp;preferredCMMNotFound);<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(myFlattenUPP);// Dispose of the procedure pointer.<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre>    tempCreated = true;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Open the newly created profile, create a temporary profile reference for it,<span></span></pre></td></tr><tr><td scope="row"><pre>    // copy the temporary reference, then close it and delete the profile file.<span></span></pre></td></tr><tr><td scope="row"><pre>    tempProfLoc.locType = cmFileBasedProfile;<span></span></pre></td></tr><tr><td scope="row"><pre>    tempProfLoc.u.fileLoc.spec = tempSpec;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = CMOpenProfile(&amp;tempProf, &amp;tempProfLoc);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = CMCopyProfile(prof, profLoc, tempProf);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Do any necessary cleanup:close profile and delete file spec.<span></span></pre></td></tr><tr><td scope="row"><pre>cleanup:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (tempProf)<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = CMCloseProfile(tempProf);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (tempCreated)<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = FSpDelete(&amp;tempSpec);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF118" title="Part B: Unflattening the Profile"></a><h4>Part B: Unflattening the Profile</h4><p>Prior to ColorSync 2.5, your transfer function is called by the CMM that handles the unflatten operation. Starting with ColorSync 2.5, however, the ColorSync Manager calls your transfer function directly, without going through the preferred, or any, CMM.</p><p>When the code in <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_237"></a>MyGetIndexedProfileFromPicHandle (<span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGEHIB">Listing 4-10</a></span>) calls the <code>CMUnflattenProc</code> function, passing it a pointer to the <code>MyUnflattenProc</code> function, the <code>MyUnflattenProc</code> function (<span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGBA">Listing 4-11</a></span>) is called by ColorSync or by the CMM (depending on the version of ColorSync) to perform the low-level profile data transfer from the document file.</p><p>When the <code>MyUnflattenProc</code> function is called with an open command, the function initializes global variables, creates a graphics world, and installs bottleneck procedures in the graphics world. The only bottleneck procedure actually used is <code>MyUnflattenProfilesCommentProc</code>, which checks the picture comments as the picture is drawn offscreen to identify the desired profile. For a general discussion of customizing QuickDraw’s bottleneck routines, see Customizing QuickDraw’s Text Handling in Inside Macintosh: Text.</p><p>When the <code>MyUnflattenProc</code> function is called with a read command, the function reads the appropriate segment of data from a chunk and returns it. To accomplish this, it calls the MyDrawPicHandleUsingBottlenecks function with the appropriate bottleneck procedure installed. In turn, this invokes the <code>MyUnflattenProfilesCommentProc</code> shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEIEBC">Listing 4-12</a></span>.</p><p>When the <code>MyUnflattenProc</code> function is called with a close command, the function releases any memory it allocated and disposes of the graphics world and bottlenecks.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_238"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_30" title="Listing 4-11The unflatten procedure"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCBFGBA" title="Listing 4-11The unflatten procedure"></a><strong>Listing 4-11&nbsp;&nbsp;</strong>The unflatten procedure</p><div class="codesample"><table><tr><td scope="row"><pre>pascal OSErr MyUnflattenProc (long command,<span></span></pre></td></tr><tr><td scope="row"><pre>                                long *sizePtr,<span></span></pre></td></tr><tr><td scope="row"><pre>                                void *dataPtr,<span></span></pre></td></tr><tr><td scope="row"><pre>                                void *refConPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr                   theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    static CQDProcs         procs;<span></span></pre></td></tr><tr><td scope="row"><pre>    static GWorldPtr        offscreen;<span></span></pre></td></tr><tr><td scope="row"><pre>    PicHandle               pict;<span></span></pre></td></tr><tr><td scope="row"><pre>    switch (command)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case cmOpenReadSpool:<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = NewSmallGWorld(&amp;offscreen);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>                return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            /* Replace the QuickDraw bottleneck routines, mostly with routines<span></span></pre></td></tr><tr><td scope="row"><pre>                that do nothing, but also with our unflatten comments routine,<span></span></pre></td></tr><tr><td scope="row"><pre>                so that we can intercept the comments we are interested in and<span></span></pre></td></tr><tr><td scope="row"><pre>                ignore everything else. */<span></span></pre></td></tr><tr><td scope="row"><pre>            SetStdCProcs(&amp;procs);<span></span></pre></td></tr><tr><td scope="row"><pre>            procs.textProc    = NewQDTextProc (MyNoOpTextProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            procs.lineProc    = NewQDLineProc (MyNoOpLineProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            procs.rectProc    = NewQDRectProc (MyNoOpRectProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            procs.rRectProc   = NewQDRRectPro (MyNoOpRRectProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            procs.ovalProc    = NewQDOvalProc (MyNoOpOvalProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            procs.arcProc     = NewQDArcProc (MyNoOpArcProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            procs.polyProc    = NewQDPolyProc (MyNoOpPolyProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            procs.rgnProc     = NewQDRgnProc (MyNoOpRgnProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            procs.bitsProc    = NewQDBitsProc(MyNoOpBitsProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            procs.commentProc = NewQDCommentProc (MyUnflattenProfilesCommentProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            procs.txMeasProc  = NewQDTxMeasProc (MyNoOpTxMeasProc);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            gChunkBaseHndl = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>            gChunkIndex = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>            gChunkOffset = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>            gChunkSize = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    case cmReadSpool:<span></span></pre></td></tr><tr><td scope="row"><pre>        if (gChunkOffset > gChunkSize)      /* If we overread the last chunk, */<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            return ioErr;                   /* use system I/O error value. */<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        if (gChunkOffset == gChunkSize)     /* If we used up the last chunk, */<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (gChunkBaseHndl !=nil)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                HUnlock(gChunkBaseHndl);    /* dispose of the previous chunk. */<span></span></pre></td></tr><tr><td scope="row"><pre>                DisposeHandle(gChunkBaseHndl);<span></span></pre></td></tr><tr><td scope="row"><pre>                gChunkBaseHndl = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            gChunkIndex++;              /* Read in a new chunk. */<span></span></pre></td></tr><tr><td scope="row"><pre>            gChunkOffset = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>            gCount = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>            gChunkCount = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>            pict = *((PicHandle *)refConPtr);<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = MyDrawPicHandleUsingBottlenecks (pict, procs, offscreen);<span></span></pre></td></tr><tr><td scope="row"><pre>            /* This invokes MyUnflattenProfilesCommentProc shown in Listing 3-12. */<span></span></pre></td></tr><tr><td scope="row"><pre>            if (gChunkBaseHndl==nil)    /* Check to see if we're overread. */<span></span></pre></td></tr><tr><td scope="row"><pre>                return ioErr;           /* If so, return system I/O error value. */<span></span></pre></td></tr><tr><td scope="row"><pre>            HLock(gChunkBaseHndl);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        if (gChunkOffset &lt; gChunkSize)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            *sizePtr = MIN(gChunkSize-gChunkOffset, *sizePtr);<span></span></pre></td></tr><tr><td scope="row"><pre>            BlockMove((Ptr)(&amp;((*gChunkBaseHndl)[gChunkOffset])),<span></span></pre></td></tr><tr><td scope="row"><pre>                (Ptr)dataPtr, *sizePtr);<span></span></pre></td></tr><tr><td scope="row"><pre>            gChunkOffset += (*sizePtr);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case cmCloseSpool:<span></span></pre></td></tr><tr><td scope="row"><pre>            if (gChunkBaseHndl != nil)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                HUnlock(gChunkBaseHndl);        /* Dispose of the previous chunk. */<span></span></pre></td></tr><tr><td scope="row"><pre>                DisposeHandle(gChunkBaseHndl);<span></span></pre></td></tr><tr><td scope="row"><pre>                gChunkBaseHndl = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            /* Dispose of our offscreen world and the routine descriptors<span></span></pre></td></tr><tr><td scope="row"><pre>                for our bottlenect routines. */<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeGWorld(offscreen);<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeRoutineDescriptor(procs.MyNoOpTextPrc);<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeRoutineDescriptor(procs.MyNoOpLinePrc);<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeRoutineDescriptor(procs.MyNoOpRectProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeRoutineDescriptor(procs.MyNoOpRRectPrc);<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeRoutineDescriptor(procs.MyNoOpOvalProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeRoutineDescriptor(procs.MyNoOpArcProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeRoutineDescriptor(procs.MyNoOpPolyPrc);<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeRoutineDescriptor(procs.MyNoOpRgnProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeRoutineDescriptor(procs.MyNoOpBitsProc);<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeRoutineDescriptor(procs.MyUnflattenProfilesCommentPrc);<span></span></pre></td></tr><tr><td scope="row"><pre>            DisposeRoutineDescriptor(procs.MyNoOpTxMeasPrc);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        default:<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF119" title="Part C: Calling the Comment Procedure"></a><h4>Part C: Calling the Comment Procedure</h4><p>When the <code>MyUnflattenProc</code> function’s <code>MyDrawPicHandleUsingBottlenecks </code>function calls the <code>MyUnflattenProfilesCommentProc</code> function, the function shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEIEBC">Listing 4-12</a></span> finds the profile identified by the index, finds the correct segment of data within the profile, and stores the data in the <code>gChunkBaseHndl</code> global variable.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_239"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_240"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_31" title="Listing 4-12The comment procedure"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCEIEBC" title="Listing 4-12The comment procedure"></a><strong>Listing 4-12&nbsp;&nbsp;</strong>The comment procedure</p><div class="codesample"><table><tr><td scope="row"><pre>pascal void MyUnflattenProfilesCommentProc (short kind,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            short dataSize,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            Handle dataHandle)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    long    selector;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr   theErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (gChunkBaseHndl != nil) return;<span></span></pre></td></tr><tr><td scope="row"><pre>                /* The handle is in use; this shouldn’t happen. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (gCount > gIndex) return;<span></span></pre></td></tr><tr><td scope="row"><pre>                /* We have already found the profile. */<span></span></pre></td></tr><tr><td scope="row"><pre>    switch (kind)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>    case cmBeginProfile:<span></span></pre></td></tr><tr><td scope="row"><pre>        gCount ++;          /* We found a version 1 profile. */<span></span></pre></td></tr><tr><td scope="row"><pre>        gChunkCount = 1;    /* v1 profiles should only have 1 chunk. */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (gCount != gIndex) break;<span></span></pre></td></tr><tr><td scope="row"><pre>                            /* This is not the profile we're looking for. */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (gChunkCount != gChunkIndex) break;<span></span></pre></td></tr><tr><td scope="row"><pre>                            /* This is not the chunk we're looking for. */<span></span></pre></td></tr><tr><td scope="row"><pre>        gChunkBaseHndl = dataHandle;<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = HandToHand(&amp;gChunkBaseHndl);<span></span></pre></td></tr><tr><td scope="row"><pre>        gChunkSize = dataSize;<span></span></pre></td></tr><tr><td scope="row"><pre>        gChunkOffset = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    case cmComment:<span></span></pre></td></tr><tr><td scope="row"><pre>        if (dataSize &lt;= 4) break;<span></span></pre></td></tr><tr><td scope="row"><pre>                            /* The dataSize too small for selector, so break. */<span></span></pre></td></tr><tr><td scope="row"><pre>        selector = *((long *)(*dataHandle));<span></span></pre></td></tr><tr><td scope="row"><pre>                            /* Get the selector from the first long in data. */<span></span></pre></td></tr><tr><td scope="row"><pre>        switch (selector)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            case cmBeginProfileSel:<span></span></pre></td></tr><tr><td scope="row"><pre>                gCount ++;              /* We found a version 2 profile. */<span></span></pre></td></tr><tr><td scope="row"><pre>                gChunkCount = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>                if (gCount != gIndex) break;<span></span></pre></td></tr><tr><td scope="row"><pre>                                    /* This is not the profile we're looking for. */<span></span></pre></td></tr><tr><td scope="row"><pre>                if (gChunkCount!=gChunkIndex) break;<span></span></pre></td></tr><tr><td scope="row"><pre>                                    /* This is not the chunk we're looking for. */<span></span></pre></td></tr><tr><td scope="row"><pre>                gChunkBaseHndl = dataHandle;<span></span></pre></td></tr><tr><td scope="row"><pre>                theErr = HandToHand(&amp;gChunkBaseHndl);<span></span></pre></td></tr><tr><td scope="row"><pre>                gChunkSize = dataSize;<span></span></pre></td></tr><tr><td scope="row"><pre>                gChunkOffset = 4;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            case cmContinueProfileSel:<span></span></pre></td></tr><tr><td scope="row"><pre>                gChunkCount ++;<span></span></pre></td></tr><tr><td scope="row"><pre>                if (gCount != gIndex) break;<span></span></pre></td></tr><tr><td scope="row"><pre>                                    /* This is not the profile we're looking for. */<span></span></pre></td></tr><tr><td scope="row"><pre>                if (gChunkCount!=gChunkIndex) break;<span></span></pre></td></tr><tr><td scope="row"><pre>                                    /* This is not the chunk we're looking for. */<span></span></pre></td></tr><tr><td scope="row"><pre>                gChunkBaseHndl = dataHandle;<span></span></pre></td></tr><tr><td scope="row"><pre>                theErr = HandToHand(&amp;gChunkBaseHndl);<span></span></pre></td></tr><tr><td scope="row"><pre>                gChunkSize = dataSize;<span></span></pre></td></tr><tr><td scope="row"><pre>                gChunkOffset = 4;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            case cmEndProfileSel:<span></span></pre></td></tr><tr><td scope="row"><pre>                                    /* Check to see if we're overreading. */<span></span></pre></td></tr><tr><td scope="row"><pre>                gChunkCount = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-BBCCHEAG" title="Performing Optimized Profile Searching"></a><h2>Performing Optimized Profile Searching</h2><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_241"></a><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_242"></a>Starting with version 2.5, <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_243"></a>ColorSync provides a profile cache and a new routine, <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMIterateColorSyncFolder" target="_top">CMIterateColorSyncFolder</a></code>, for optimized profile searching. The sample code shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFIDJC">Listing 4-13</a></span> through <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBIIFA">Listing 4-15</a></span> takes advantage of optimized searching if ColorSync version 2.5 is available; if not, it performs a search that is compatible with earlier versions of ColorSync. The compatible search may take some advantage of the profile cache, but cannot provide fully optimized results.</p><p>As background for the code samples in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFIDJC">Listing 4-13</a></span> to <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBIIFA">Listing 4-15</a></span>, you should be familiar with the topics described in the following sections:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCGDJAF">Profile Location</a></span></p></li><li class="li"><p><span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCBECGG">Profile Search Locations</a></span></p></li><li class="li"><p><span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCBBDGG">The Profile Cache and Optimized Searching</a></span></p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_32" title="Important:"></a><p><strong>Important:</strong>&nbsp;You cannot use the ColorSync Manager search functions to search for ColorSync 1.0 profiles.</p><p></p></div></li></ul><p>The <code>CMIterateColorSyncFolder</code> function uses ColorSync’s profile cache to supply your application with information about the profiles currently available in the ColorSync Profiles folder. The function calls your callback routine once for each available profile, supplying your routine with the profile header, script code, name, and location, stored in a structure of type <code>CMProfileIterateData</code>.</p><p>Even though there may be many profiles available, <code>CMIterateColorSyncFolder</code> can take advantage of ColorSync’s profile cache to return profile information quickly, and (if the cache is valid) without having to open any profiles. As a result, your routine may be able to perform its function, such as building a list of profiles to display in a pop-up menu, quickly and without having to open each file-based profile.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF120" title="An Iteration Function for Profile Searching With ColorSync 2.5"></a><h3>An Iteration Function for Profile Searching With ColorSync 2.5</h3><p>The CMIterateColorSyncFolderCompat function, shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBIIFA">Listing 4-15</a></span>, performs an optimized search using the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMIterateColorSyncFolder" target="_top">CMIterateColorSyncFolder</a></code> function if ColorSync version 2.5 is available. Otherwise, it calls <code><!--a-->theCMNewProfileSearch<!--/a--></code> function, which is available in earlier versions of ColorSync.</p><p>When you call the CMIterateColorSyncFolderCompat function, you pass a universal procedure pointer to a filter procedure in the <code>proc</code> parameter. CMIterateColorSyncFolderCompat uses that filter procedure when it performs an optimized search with <code>CMIterateColorSyncFolder</code>. <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFIDJC">Listing 4-13</a></span> provides a sample filter procedure called <code>MyIterateProc</code>.</p><p>The <code>MyIterateProc</code> function is called once for each available profile and merely stores the names of all non-display profiles (such as printer and scanner profiles) at an arbitrary position in a list. You would do something similar, for example, to display a list of profiles in a dialog.</p><p>Note that the CMIterateColorSyncFolderCompat function works in a similar way for ColorSync 2.5 and for earlier versions, although the search is much more efficient with version 2.5. CMIterateColorSyncFolderCompat either calls the <code>CMIterateColorSyncFolder</code> function, which calls the MyIterateProc function once for each available profile, or it calls the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMNewProfileSearch" target="_top">CMNewProfileSearch</a></code> function, which calls the ProfileSearchFilter function (<span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCDIFGA">Listing 4-14</a></span>) once for each available profile. The ProfileSearchFilter function in turn calls MyIterateProc, so similar processing occurs.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_244"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_33" title="Listing 4-13An iteration function for profile searching with ColorSync 2.5"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCFIDJC" title="Listing 4-13An iteration function for profile searching with ColorSync 2.5"></a><strong>Listing 4-13&nbsp;&nbsp;</strong>An iteration function for profile searching with ColorSync 2.5</p><div class="codesample"><table><tr><td scope="row"><pre>Pascal OSErr MyIterateProc(CMProfileIterateData* data, void* refcon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Cell theCell;<span></span></pre></td></tr><tr><td scope="row"><pre>    // Assume we can cast refCon to a ListHandle.<span></span></pre></td></tr><tr><td scope="row"><pre>    ListHandle list = (ListHandle)refcon;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Assume we’re interested only in non-display profiles, such as printer<span></span></pre></td></tr><tr><td scope="row"><pre>        and scanner profiles. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (data->header.profileClass != cmDisplayClass)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* This code adds the profile name at an arbitrary position<span></span></pre></td></tr><tr><td scope="row"><pre>            in a list. You could do something similar to display a<span></span></pre></td></tr><tr><td scope="row"><pre>            list of all available profiles. */<span></span></pre></td></tr><tr><td scope="row"><pre>        cell.v = LAddRow(1,999,list);<span></span></pre></td></tr><tr><td scope="row"><pre>        cell.h = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        // The name data in the iterate data structure is in Pascal format,<span></span></pre></td></tr><tr><td scope="row"><pre>            so we use the length byte to determine how many bytes to copy. */<span></span></pre></td></tr><tr><td scope="row"><pre>        LSetCell((Ptr)data->name+1, name[0], cell, list);<span></span></pre></td></tr><tr><td scope="row"><pre>        cell.h = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>        // Store the profile's location information with the cell.<span></span></pre></td></tr><tr><td scope="row"><pre>        LSetCell((Ptr)data->location, sizeof(cmProfileLocation), cell, list);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // A more complicated function might need to return an error here.<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF121" title="A Filter Function for Profile Searching Prior to ColorSync 2.5"></a><h3>A Filter Function for Profile Searching Prior to ColorSync 2.5</h3><p>To search for profiles prior to version 2.5 of the ColorSync Manager, you use the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMNewProfileSearch" target="_top">CMNewProfileSearch</a></code> function. You supply <code>CMNewProfileSearch</code> with a search record of type <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMSearchRecord" target="_top">CMSearchRecord</a></code> that identifies the search criteria. If you also provide a pointer to a filter function, <code>CMNewProfileSearch</code> uses the function to eliminate profiles from the search based on additional criteria not defined by the search record. The <code>ProfileSearchFilter</code> function shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCDIFGA">Listing 4-14</a></span> provides an example of a filter routine for searching with the <code>CMNewProfileSearch</code> function.</p><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCDIFGA">Listing 4-14</a></span> defines the IterateCompatPtr data type, a pointer to a structure that stores search information. When you call the CMIterateColorSyncFolderCompat function shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBIIFA">Listing 4-15</a></span>, you pass a reference to the MyIterateProc function (<span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFIDJC">Listing 4-13</a></span>) in the proc parameter. If ColorSync 2.5 is not available, the CMIterateColorSyncFolderCompat function calls the <code>CMNewProfileSearch</code> function. It passes the <code>ProfileSearchFilter</code> function (<span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFIDJC">Listing 4-13</a></span>) as the search filter and it passes an IterateCompatPtr pointer as the <code>refCon</code> parameter. It sets the <code>proc</code> field of the IterateCompatPtr pointer to the MyIterateProc function that you passed in the <code>proc</code> parameter.</p><p>The <code>CMNewProfileSearch</code> function calls the <code>ProfileSearchFilter</code> function (<span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFIDJC">Listing 4-13</a></span>) once for each profile. The <code>ProfileSearchFilter</code> function simply casts the passed <code>refCon</code> pointer to an IterateCompatPtr, then calls the function specified by the pointer’s proc field. As a result, the MyIterateProc function is called once for each profile, just as it is when CMIterateColorSyncFolderCompat calls CMIterateColorSyncFolder under ColorSync 2.5.</p><p>Note that <code>ProfileSearchFilter</code> always returns true, indicating the profile should be filtered out of the search result returned by <code>CMNewProfileSearch</code>, because we’ve already gotten all the information we need from it. Note also that <code>ProfileSearchFilter</code> uses the <code>require</code> macro, which is defined in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJCDEE">Poor Man’s Exception Handling</a></span>.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_245"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_34" title="Listing 4-14A filter function for profile searching prior to ColorSync 2.5"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCDIFGA" title="Listing 4-14A filter function for profile searching prior to ColorSync 2.5"></a><strong>Listing 4-14&nbsp;&nbsp;</strong>A filter function for profile searching prior to ColorSync 2.5</p><div class="codesample"><table><tr><td scope="row"><pre>// Declare a structure to use for searching with ColorSync versions prior to 2.5.<span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct IterateCompat<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileIterateUPP     proc;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr                   osErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    void*                   refCon;<span></span></pre></td></tr><tr><td scope="row"><pre>} IterateCompatRec, *IterateCompatPtr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static pascal Boolean ProfileSearchFilter (CMProfileRef prof, void *refCon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr                   theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    IterateCompatPtr        refConCompatPtr;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileIterateData    iterData;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Cast refcon to our type.<span></span></pre></td></tr><tr><td scope="row"><pre>    refConCompatPtr = (IterateCompatPtr)refCon;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If we had an error from an earlier profile, give up<span></span></pre></td></tr><tr><td scope="row"><pre>    //  by branching to cleanup location.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = refConCompatPtr->osErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Try to get the profile's location.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = CMGetProfileLocation(prof, &amp;iterData.location);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Try to get the profile's header.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = CMGetProfileHeader(prof, (CMAppleProfileHeader*)&amp;iterData.header);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Try to get the profile's name.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = CMGetScriptProfileDescription(prof, iterData.name, &amp;iterData.code);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    iterData.dataVersion = cmProfileIterateDataVersion1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Call the iterate callback routine.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = CallCMProfileIterateProc(refConCompatPtr->proc,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    &amp;iterData, refConCompatPtr->refCon);<span></span></pre></td></tr><tr><td scope="row"><pre>    require(theErr == noErr, cleanup);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>cleanup:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        refConCompatPtr->osErr = theErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return true;   // exclude the profile;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF122" title="A Compatible Function for Optimized Profile Searching"></a><h3>A Compatible Function for Optimized Profile Searching</h3><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBIIFA">Listing 4-15</a></span> provides sample code that performs an optimized profile search if ColorSync 2.5 is available, but provides a search that is compatible with previous versions if ColorSync 2.5 is not available.</p><p>When ColorSync 2.5 is available, CMIterateColorSyncFolderCompat simply calls the function <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMIterateColorSyncFolder" target="_top">CMIterateColorSyncFolder</a></code>, passing on the information it received through its parameters. As a result, <code>CMIterateColorSyncFolder</code> calls the MyIterateProc function, shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFIDJC">Listing 4-13</a></span>, once for each available profile. Your version of MyIterateProc can examine the passed information for each profile and perform any required operation on the profiles it is interested in.</p><p>When ColorSync 2.5 is not available, CMIterateColorSyncFolderCompat sets up a search with the function <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMNewProfileSearch" target="_top">CMNewProfileSearch</a></code>. As part of this setup, it initializes a structure of type IterateCompatRec, defined in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCDIFGA">Listing 4-14</a></span>, which it passes to <code>CMNewProfileSearch</code> for the <code>refCon</code> parameter. The <code>CMNewProfileSearch</code> function in turn passes a pointer to the IterateCompatRec structure as the <code>refCon</code> parameter to ProfileSearchFilter, which it calls once for each available profile.</p><p>ProfileSearchFilter calls the MyIterateProc function, which gets a chance to handle each profile, just as it does in the case where ColorSync 2.5 is available. The main drawback is that without the availability of the profile cache and the <code>CMIterateColorSyncFolder</code> function, searching through the profiles is likely to be a much more time-consuming task.</p><p>Note that CMIterateColorSyncFolderCompat uses the <code>require</code> macro, which is defined in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJCDEE">Poor Man’s Exception Handling</a></span>.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_246"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_247"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_35" title="Listing 4-15Optimized profile searching compatible with previous versions of ColorSync"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCBIIFA" title="Listing 4-15Optimized profile searching compatible with previous versions of ColorSync"></a><strong>Listing 4-15&nbsp;&nbsp;</strong>Optimized profile searching compatible with previous versions of ColorSync</p><div class="codesample"><table><tr><td scope="row"><pre>CMError CMIterateColorSyncFolderCompat (CMProfileIterateUPP proc,<span></span></pre></td></tr><tr><td scope="row"><pre>                                         unsigned long *seed,<span></span></pre></td></tr><tr><td scope="row"><pre>                                         unsigned long *count,<span></span></pre></td></tr><tr><td scope="row"><pre>                                         void *refCon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMError theErr = noErr ;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Presume the caller passed a pointer to MyIterateProc to this<span></span></pre></td></tr><tr><td scope="row"><pre>            function in the proc parameter. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( ColorSync25Available() )<span></span></pre></td></tr><tr><td scope="row"><pre>        return CMIterateColorSyncFolder(proc, seed, count, refCon);<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CMProfileSearchRef  searchResult;<span></span></pre></td></tr><tr><td scope="row"><pre>        CMSearchRecord      searchSpec;<span></span></pre></td></tr><tr><td scope="row"><pre>        unsigned long       count;<span></span></pre></td></tr><tr><td scope="row"><pre>        IterateCompatRec    refConCompat;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        searchSpec.filter = NewCMProfileFilterProc(ProfileSearchFilter);<span></span></pre></td></tr><tr><td scope="row"><pre>        searchSpec.searchMask = cmMatchAnyProfile;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* Set up our private data structure for compatible (pre-ColorSync 2.5)<span></span></pre></td></tr><tr><td scope="row"><pre>            profile searching.<span></span></pre></td></tr><tr><td scope="row"><pre>            Pass the pointer to the MyIterateProc function, which was<span></span></pre></td></tr><tr><td scope="row"><pre>                presumably passed to this function in the proc parameter,<span></span></pre></td></tr><tr><td scope="row"><pre>                on to our filter routine, ProfileSearchFilter,<span></span></pre></td></tr><tr><td scope="row"><pre>                in the refCon parameter, using an IterateCompatRec structure. */<span></span></pre></td></tr><tr><td scope="row"><pre>        refConCompat.proc = proc;<span></span></pre></td></tr><tr><td scope="row"><pre>        refConCompat.osErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>        refConCompat.refCon = refCon;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //  Start traditional search.<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = CMNewProfileSearch(&amp;searchSpec,<span></span></pre></td></tr><tr><td scope="row"><pre>                            (void*)&amp;refConCompat, &amp;count, &amp;searchResult);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (theErr == noErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            // We don’t use the result, but still must dispose of it.<span></span></pre></td></tr><tr><td scope="row"><pre>            CMDisposeProfileSearch(searchResult);<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = refConCompat.osErr;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        DisposeRoutineDescriptor(searchSpec.filter);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-BBCIIJBI" title="Searching for Specific Profiles Prior to ColorSync 2.5"></a><h2>Searching for Specific Profiles Prior to ColorSync 2.5</h2><p>Starting with version 2.5, you can do fast, optimized profile searching that takes advantage of the profile cache added in ColorSync 2.5. For an overview, see <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCBBDGG">The Profile Cache and Optimized Searching</a></span>. The sample code in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBIIFA">Listing 4-15</a></span> takes advantage of optimized searching if ColorSync version 2.5 is available; if not, it performs a search that is compatible with earlier versions of ColorSync. The compatible search may take some advantage of the profile cache, but cannot provide fully optimized results.</p><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHCCHD">Listing 4-16</a></span>, shown in this section, provides an additional example of the searching mechanism available prior to ColorSync version 2.5.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_36" title="Important:"></a><p><strong>Important:</strong>&nbsp;You cannot use the ColorSync Manager search functions to search for ColorSync 1.0 profiles.</p><p></p></div><p>Your application can use the ColorSync Manager search functions to obtain a list of profiles in the <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_248"></a>ColorSync Profiles folder that meet specifications you supply in a search record. For example, you can use these <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_249"></a>functions to find all profiles for printers that meet certain criteria defined in the profile. Your application can walk through the resulting list of profiles and obtain the name and script code of each profile corresponding to a specific index in the list. Your application can then display a selection menu showing the names of the profiles. <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHCCHD">Listing 4-16</a></span> shows sample code that takes an approach similar to the one this example describes.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_37" title="Note"></a><p><strong>Note:</strong>&nbsp;You can also search the ColorSync Profiles folder for profiles that match a profile identifier. For more information, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCCDIHG">Searching for a Profile That Matches a Profile Identifier</a></span>, and <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMProfileIdentifierFolderSearch" target="_top">CMProfileIdentifierFolderSearch</a></code>.</p></div><p>The <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_250"></a>MyProfileSearch function, shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHCCHD">Listing 4-16</a></span>, defines values for the search specification record fields, including the search mask, and assigns those values to the record’s fields after initializing the search result. Then <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_251"></a>MyProfileSearch calls the CMNewProfileSearch function to search the ColorSync Profiles folder for profiles that meet the search specification requirements. The <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMNewProfileSearch" target="_top">CMNewProfileSearch</a></code> function returns a one-based count of the profiles matching the search specification and a reference to the search result list of the matching profiles.</p><p>Next the <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_252"></a>MyProfileSearch function calls the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMSearchGetIndProfile" target="_top">CMSearchGetIndProfile</a></code> function to obtain a reference to a specific profile corresponding to a specific index into the search result list. Passing the profile reference returned by the <code>CMSearchGetIndProfile</code> function as the <code>foundProf</code> parameter, <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_253"></a>MyProfileSearch calls the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMGetScriptProfileDescription" target="_top">CMGetScriptProfileDescription</a></code> function to obtain the profile name and script code.</p><p>Finally, the <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_254"></a>MyProfileSearch function cleans up, calling the <code>CMCloseProfile</code> function to close the profile and the <code>CMDisposeProfileSearch</code> function to dispose of the search result list.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_255"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_256"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_257"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_258"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_259"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_260"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_261"></a></p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_38" title="Listing 4-16Searching for specific profiles in the ColorSync Profiles folder"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCHCCHD" title="Listing 4-16Searching for specific profiles in the ColorSync Profiles folder"></a><strong>Listing 4-16&nbsp;&nbsp;</strong>Searching for specific profiles in the ColorSync Profiles folder</p><div class="codesample"><table><tr><td scope="row"><pre>/* field definitions for search */<span></span></pre></td></tr><tr><td scope="row"><pre>#define kCMMType        'appl'              /* ColorSync default CMM */<span></span></pre></td></tr><tr><td scope="row"><pre>#define kProfileClass   cmDisplayClass      /* monitor */<span></span></pre></td></tr><tr><td scope="row"><pre>#define kAttr0          0x00000000<span></span></pre></td></tr><tr><td scope="row"><pre>#define kAttr1          0x00000002          /* Macintosh standard gamma */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Define mask to search for profiles that match on CMM type, profile class,<span></span></pre></td></tr><tr><td scope="row"><pre>        and attributes. */<span></span></pre></td></tr><tr><td scope="row"><pre>#define kSearchMask (cmMatchProfileCMMType + cmMatchProfileClass + cmMatchAttributes)<span></span></pre></td></tr><tr><td scope="row"><pre>void MyProfileSearch (void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMError             cmErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileRef        foundProf;<span></span></pre></td></tr><tr><td scope="row"><pre>    Str255              profName;<span></span></pre></td></tr><tr><td scope="row"><pre>    ScriptCode          profScript;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMSearchRecord      searchSpec;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileSearchRef  searchResult;<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned long       searchCount;<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned long       i;<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Init for error handling. */<span></span></pre></td></tr><tr><td scope="row"><pre>    searchResult = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Specify search. */<span></span></pre></td></tr><tr><td scope="row"><pre>    searchSpec.CMMType = kCMMType;<span></span></pre></td></tr><tr><td scope="row"><pre>    searchSpec.profileClass = kProfileClass;<span></span></pre></td></tr><tr><td scope="row"><pre>    searchSpec.deviceAttributes[0 ]= kAttr0;<span></span></pre></td></tr><tr><td scope="row"><pre>    searchSpec.deviceAttributes[1] = kAttr1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    searchSpec.searchMask = kSearchMask;<span></span></pre></td></tr><tr><td scope="row"><pre>    searchSpec.filter= NULL;                /* Filter proc is not used. */<span></span></pre></td></tr><tr><td scope="row"><pre>    cmErr = CMNewProfileSearch(&amp;searchSpec, NULL, &amp;searchCount, &amp;searchResult);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (cmErr == noErr)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        for (i = 1; i &lt;= searchCount; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (CMSearchGetIndProfile(searchResult, i, &amp;foundProf) != noErr)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            cmErr = CMGetScriptProfileDescription(foundProf, profName, &amp;profScript);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (cmErr == noErr)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                /* Assume profile name ScriptCode is smRoman. */<span></span></pre></td></tr><tr><td scope="row"><pre>                (void) printf("%s\n", p2cstr(profName));<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            (void) CMCloseProfile(foundProf);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if (searchResult != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CMDisposeProfileSearch(searchResult);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-BBCCDIHG" title="Searching for a Profile That Matches a Profile Identifier"></a><h2>Searching for a Profile That Matches a Profile Identifier</h2><p>Embedding a profile in an image guarantees that the image can be rendered correctly on a different system. However, profiles can be large—the largest can be more than several hundred kilobytes. The ColorSync Manager defines a profile identifier structure, <code>CMProfileIdentifier</code>, that can identify a profile but that takes up much less space than a large profile.</p><p>The profile identifier structure contains a profile header, an optional calibration date, a profile description string length, and a variable-length profile description string. Your application might use an embedded profile identifier, for example, to change just the rendering intent or flag values in an image without having to embed an entire copy of a profile. For more information on the profile identifier structure, including a description of how a match is determined between a profile reference and a profile identifier, see <code>CMProfileIdentifier</code>.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_39" title="Important:"></a><p><strong>Important:</strong>&nbsp;A document containing an embedded profile identifier can not necessarily be ported to different systems or platforms.</p><p></p></div><p>The ColorSync Manager provides the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/NCMUseProfileComment" target="_top">NCMUseProfileComment</a></code> routine to embed profiles and profile identifiers in an open picture file. For information on embedding, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJJGIG">Embedding Profiles and Profile Identifiers</a></span>. Your application can embed profile identifiers in place of entire profiles, or in addition to them. A profile identifier can refer to an embedded profile or to a profile on disk.</p><p>The ColorSync Manager provides the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMProfileIdentifierListSearch" target="_top">CMProfileIdentifierListSearch</a></code> routine for finding a profile identifier in a list of profile identifiers and the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMProfileIdentifierFolderSearch" target="_top">CMProfileIdentifierFolderSearch</a></code> routine for finding a profile identifier in the ColorSync Profiles folder.</p><p>When your application or device driver processes an image, it typically keeps a list of profile references for each profile it encounters in the image. Each time it encounters an embedded profile identifier, your application first calls the CMProfileIdentifierListSearch function to see if there is already a matching profile reference in its list. That function returns a list of profile references that match the profile identifier. Although the returned list would normally contain at most one reference, it is possible to have two or more matches. If the CMProfileIdentifierListSearch routine does not find a matching profile reference, your application calls the CMProfileIdentifierFolderSearch routine to see if a matching profile can be found in the ColorSync Profiles folder.</p><p><span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHEAJJ">Listing 4-17</a></span> demonstrates how your application can use the ColorSync Manager’s search routines to obtain a profile reference for an embedded profile identifier. It uses the following structure to store a list of profile identifiers, along with a count of the number of items in the list.</p><div class="codesample"><table><tr><td scope="row"><pre>typedef struct {<span></span></pre></td></tr><tr><td scope="row"><pre>    long count;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileRef profs[1];<span></span></pre></td></tr><tr><td scope="row"><pre>} ProfileCacheList, **ProfileCacheHandle;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_40" title="Listing 4-17Searching for a profile that matches a profile identifier"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCHEAJJ" title="Listing 4-17Searching for a profile that matches a profile identifier"></a><strong>Listing 4-17&nbsp;&nbsp;</strong>Searching for a profile that matches a profile identifier</p><div class="codesample"><table><tr><td scope="row"><pre>CMError MyFindAndOpenProfileByIdentifier(ProfileCacheHandle profCache,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        CMProfileIdentifierPtr unique,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        Boolean *pFoundInCache,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        CMProfileRef *pProf)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMError         theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileRef    prof = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    long            cacheCount = (**profCache).count;<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned long   foundCount = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    *pFoundInCache = false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* If there are any profile references in the cache (the list of profile<span></span></pre></td></tr><tr><td scope="row"><pre>        references for profiles or profile identifiers we have already<span></span></pre></td></tr><tr><td scope="row"><pre>        encountered) look there for a match with the passed profile identifier. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (cacheCount)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CMProfileRef *cacheList;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        cacheList = (**profCache).profs;<span></span></pre></td></tr><tr><td scope="row"><pre>        foundCount = 1; // return no more than one match<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = CMProfileIdentifierListSearch(unique, cacheList, cacheCount,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            &amp;foundCount, &amp;prof);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (foundCount &amp;&amp; !theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>            *pFoundInCache = true;<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>            prof = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* If we didn't find a match for the passed profile identifier in the list of<span></span></pre></td></tr><tr><td scope="row"><pre>        previously encountered profiles, look for a match on disk, in the<span></span></pre></td></tr><tr><td scope="row"><pre>        ColorSync Profiles folder */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!prof)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CMProfileSearchRef search = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>        foundCount = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = CMProfileIdentifierFolderSearch(unique, &amp;foundCount, &amp;search);<span></span></pre></td></tr><tr><td scope="row"><pre>        /* If we found one or more matches, obtain a profile reference for the<span></span></pre></td></tr><tr><td scope="row"><pre>            first matching profile; if no error, dispose of the search result. */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (foundCount)<span></span></pre></td></tr><tr><td scope="row"><pre>                theErr = CMSearchGetIndProfile(search, 1, &amp;prof);<span></span></pre></td></tr><tr><td scope="row"><pre>            CMDisposeProfileSearch(search);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* If we still didn't find a match for the passed profile identifier,<span></span></pre></td></tr><tr><td scope="row"><pre>        use the system profile. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!prof)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = CMGetSystemProfile(&amp;prof);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        prof = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    *pProf = prof;<span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Although typically there is at most one profile reference in your application’s list or one profile in the ColorSync Profiles folder that matches the searched-for profile identifier, it is possible that two or more profiles may qualify. It is not an error condition if either the CMProfileIdentifierListSearch or the CMProfileIdentifierFolderSearch routine finds no matching profile.<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_262"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_263"></a><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_264"></a></p><a name="//apple_ref/doc/uid/TP30000278-BBCEJHDC" title="Checking Colors Against a Destination Device&acirc;&#128;&#153;s Gamut"></a><h2>Checking Colors Against a Destination Device’s Gamut</h2><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_265"></a>Different imaging devices (scanners, displays, printers) work in different color spaces, and each can have a different gamut or range of colors that they can produce. The process of matching colors between devices entails adjusting the colors of an image from the color gamut of one device to the color gamut of another device so that the resulting image looks as similar as possible to the original image. Not all colors can be rendered on all devices. The rendering intent used in the color transformation process dictates how the colors are matched, strongly influencing the outcome. Your application can give a user some control over the outcome by allowing the user to select the rendering intent. However, some users might want to know in advance which colors are out of gamut for the destination device so that they can choose other appropriate colors within the gamut.</p><p>Using the ColorSync Manager general purpose color-checking functions, your application can check the colors of a pixel map (using the <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWCheckPixMap" target="_top">CWCheckPixMap</a></code> function), the colors of a bitmap (using the <code><!--a-->CWCheckBitMap<!--/a--></code> function), or a list of colors (using the <code>CWCheckColors</code> function) against the color gamut of the destination device and provide a warning when a color is out of gamut for that device.</p><p>There are a number of ways in which your application can provide gamut-checking services. For example, you can use gamut checking to see if a given color is reproducible on a particular printer. If the color is not directly reproducible—that is, if it is out of gamut—you could alert the user to that fact.</p><p>You can allow a user to specify a list of colors that fall within the gamut of a source device to see if they fit within the gamut of a destination device before the user color matches an image. Your application could display the results in a window, indicating which colors are in the gamut and which are out. This feature, too, gives the user the opportunity to test colors and select different ones for portions of an image whose colors fall out of gamut. To handle this feature, your application can call the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWCheckColors" target="_top">CWCheckColors</a></code> function.</p><p>In addition to providing features that allow a user to anticipate which colors are out of gamut for a particular device, your application can also show results. Your application can provide a print preview dialog box, showing which colors in a printed image, for example, are out of gamut for the image as it appears on the screen.</p><p>For an image that your application prepares, for example, your application can present a print preview dialog box that signifies those colors within the image that the printer cannot accurately reproduce. Your application can also allow users to choose whether and how to match colors in the image with those available on the printer.</p><p>You can provide a gamut-checking feature that marks the areas of a displayed image, showing the colors that do not fall within the destination device’s gamut. For example, your application can color check an image against a destination device and create a black-and-white version of the image drawn to the display using black to indicate the portions of the source image that are out of gamut. The CSDemo sample application takes this approach. <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_266"></a>For information on how to obtain the CSDemo application, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEAAFB">Extracting Profiles Embedded in Pictures</a></span>.</p><a name="//apple_ref/doc/uid/TP30000278-BBCHGAEE" title="Creating and Using Device Link Profiles"></a><h2>Creating and Using Device Link Profiles</h2><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_267"></a>To<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_268"></a> accommodate users who use a specific configuration requiring a combination of device profiles and possibly non-device profiles repeatedly over time, your application can create device link profiles. A device link profile offers a means of saving and storing a series of profiles corresponding to a specific configuration in a concatenated format. This feature provides an economy of effort for both your application and its user.</p><p>There are many uses for <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_269"></a>device link profiles. For example, a user might want to store multiple profiles, such as various device profiles and color space profiles associated with the creation and editing of an image.</p><p>Most users use the same device configuration to scan, view, and print graphics over a period of time, often soft proofing images before they print them. To enhance your application’s soft-proofing feature, you can allow users to store the contents of the profiles involved in the soft-proofing process in a device link profile. Your application can use the appropriate device link profile each time a user enacts the soft-proofing feature, instead of opening a profile reference to each of the profiles to create a color world to pass to the color-matching functions. For additional information about soft proofing, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEBCAB">Providing Soft Proofs</a></span>.</p><p>A device link profile is especially useful when a scanner application does not embed the source profile in the document containing the image it creates. By storing the scanner’s profile, your application eliminates the need to query the user for the appropriate source profile each time the user wants to soft proof using the configuration involving that scanner.</p><p>A user may want to see how a scanned image will look when printed using a specific printer. The user may want to look at many images captured on the same scanner at different times before printing the image. Because the same devices are involved in the process, if your application has offered the user the opportunity to create device link profiles, your application could display a list of device link profiles that the user had previously created for various configurations and allow the user to select the appropriate one for the current soft proofing.</p><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_270"></a>Here are the steps your application should take in creating a device link profile:</p><ol class="ol"><li class="li"><p>Open the profiles corresponding to the devices and transformations involved in the configuration and obtain references to them.</p><p>To create a device link profile, your application must first obtain references to the profiles involved in the configuration. If the profile for an input device, such as a scanner, is embedded in the document containing the image, you must first extract the profile. For a description of how to obtain a profile reference, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJDHBI">Obtaining Profile References</a></span>. For information describing how to extract a profile from a document, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEAAFB">Extracting Profiles Embedded in Pictures</a></span>.</p></li><li class="li"><p>Create an array containing references to the profiles, specifying the profile references in processing order.</p><p>You supply the profile references as an array of type <code>CMProfileRef</code> within a data structure of type <code>CMConcatProfileSet</code>. The order of the profiles must correspond to the order in which you want the colors of the image to be processed. For example, for soft proofing an image, you should specify the scanner profile reference first, followed by the printer profile reference, and then the display profile reference because the goal is to match the colors of the scanned image to the color gamut of the printer for which the image is destined and then display the results to the user.</p><p>In the <code>count</code> field, specify a one-based number identifying how many profiles the array holds. A device link profile represents a one-way link between devices.</p><p>Here is the <code>CMConcatProfileSet</code> data type:<code>struct CMConcatProfileSet { unsigned shortkeyIndex;/* zero-based */ unsigned shortcount;/* one-based */ CMProfileRefprofileSet[1]; };</code></p><p>You must adhere to the rules that govern the type of profiles you can specify in the array. For example, the first and last profiles must be device profiles. For a list of these rules, see <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMConcatProfileSet" target="_top">CMConcatProfileSet</a></code>.</p></li><li class="li"><p>Specify the index corresponding to the profile whose specified CMM is used to perform the processing.</p><p>The header of each profile specifies a CMM for that profile. Only one CMM is used for all transformations across the profiles of a device link profile. You identify the profile whose CMM is used by supplying the zero-based index of that profile in the <code>keyIndex</code> field of the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMConcatProfileSet" target="_top">CMConcatProfileSet</a></code> data type.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_41" title="Important:"></a><p><strong>Important:</strong>&nbsp;See <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBBFJD">How the ColorSync Manager Selects a CMM</a></span> for a complete description of the ColorSync algorithm for selecting a CMM.</p><p></p></div></li><li class="li"><p>Using the CMProfileLocation data type, provide a file specification for the new device link profile.</p><p>If the function <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWNewLinkProfile" target="_top">CWNewLinkProfile</a></code> is successful, the ColorSync Manager creates a device link profile in the location that you specify, opens a reference to the profile, and returns the profile reference to your application. To tell the ColorSync Manager where to create the new profile, your application must provide a file specification. The ColorSync Manager defines a data structure of type <code>CMProfileLocation</code> containing a <code>CMProfLoc</code> union that you use to give a file specification.See <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHGJIG">Listing 4-2</a></span>, which assigns values to a <code>CMProfileLocation</code> data structure.</p></li><li class="li"><p>Call the CWNewLinkProfile function to create the device link profile.</p><p>After you set up <code>CMConcatProfileSet</code> and <code>CMProfileLocation</code>, your application can call the function <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWNewLinkProfile" target="_top">CWNewLinkProfile</a></code>, passing these values to it. If the function completes successfully, it returns a reference to the newly created device link profile.</p><p>Note that you should not embed a device link profile into a document along with an image that uses it, as embedded profiles specify source device characteristics only.</p></li><li class="li"><p>Using the CWConcatColorWorld function, create a color world based on the device link profile.</p><p>You can use a device link profile with the general purpose ColorSync Manager functions only. To use a device link profile for a color-matching or color gamut-checking function, you must first create a color world using the <code>CWConcatColorWorld</code> function, passing to it a data structure of type <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMConcatProfileSet" target="_top">CMConcatProfileSet</a></code>. The <code>CMConcatProfileSet</code> data structure is the same data type that you used to specify the array of profiles when you created the new device link profile. To create the color world, however, you specify the device link profile as the only member of the <code>CMConcatProfileSet</code> array. If the <code>CWConcatColorWorld</code> function is successful, it returns a reference to a color world that your application can pass to other general purpose functions for color-matching and color gamut-checking sessions. A device link profile remains intact and available for use again after your application calls the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWDisposeColorWorld" target="_top">CWDisposeColorWorld</a></code> function to dispose of the concatenated color world.</p></li></ol><a name="//apple_ref/doc/uid/TP30000278-TPXREF123" title="Considerations"></a><h2>Considerations</h2><p>Here are some points to consider about how the ColorSync Manager uses information contained in the profiles comprising a device link profile:</p><ul class="ul"><li class="li"><p>When you use a device link profile, the quality flag setting—indicating normal mode, draft mode, or best mode—specified by the first profile prevails for the entire session; the quality flags of following profiles in the sequence are ignored. The quality flag setting is stored in the <code>flags</code> field of the profile header.</p></li><li class="li"><p>The ColorSync Manager uses the rendering intent specified by the first profile to color match to the second profile, the rendering intent specified by the second profile to color match to the third profile, and so on through the series of concatenated profiles.</p></li></ul><p>When your application is finished with the device link profile, it must close the profile with the <code>CMCloseProfile</code><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_271"></a>func<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_272"></a>tion<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_273"></a>.</p><a name="//apple_ref/doc/uid/TP30000278-BBCEBCAB" title="Providing Soft Proofs"></a><h2>Providing Soft Proofs</h2><p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_274"></a>Your application can use ColorSync to provide <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_275"></a>soft-proofing. Soft-proofing enables a user to preview the printed results of a color image on the system’s display or local printer without actually outputting the image to the printer that will produce the final image. The destination printer’s profile provides the ColorSync Manager with the information required to determine how the colors of the image will appear when printed. You can soft proof an image by showing on the system’s display the outcome a printer would produce because most displays support a wider color gamut than do printers. Therefore, a display will probably be able to show all the colors a printer could support.</p><p>Providing a feature that simulates the printed outcome for the user to preview can save users considerable time and cost by allowing them to intervene and adjust colors before sending the image to a printing shop. For example, without the ability to soft proof and correct the colors of an image using a color management system such as ColorSync, a graphics designer producing a poster to be printed by a printing press would require the services of a prepress shop to achieve the correct results before sending the image to the printing press. The graphics designer might print the image to a local desktop printer with a color gamut more limited than that of a printing press and then submit the output to the prepress to correct the colors, repeating this process until the results were satisfactory. Your application can eliminate the need for the intermediate steps by allowing the user to color match the image to the color gamut of the final printing press, display the image, and adjust the colors accordingly.</p><p>You can use the general purpose color-matching functions <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWMatchPixMap" target="_top">CWMatchPixMap</a></code> and <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWMatchBitmap" target="_top">CWMatchBitmap</a></code> to perform the color matching, or you can match a list of colors using the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWMatchColors" target="_top">CWMatchColors</a></code> function. To use these functions, your application must first define a color world that encompasses the profiles for the devices involved in the soft-proofing process.</p><p>For example, suppose a user intends to create a color image by drawing to the display, then color matching the image to the color gamut of the printing press and printing the image to a local desktop printer before delivering it to the printing press. The user intends to repeat this process until he or she is satisfied with the color rendering. To allow the user to do this, your application must build a color world using the profile for the display device, the profile for the printing press, and the profile for the local desktop printer; you must specify the profiles in processing order. Because the process involves three profiles, your application must use the function <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CWConcatColorWorld" target="_top">CWConcatColorWorld</a></code> to set up the color world. <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCIAFAE">Creating a Color World to Use With the General Purpose Functions</a></span> describes how to set up a color world.</p><p>You can preserve the series of profiles from a soft-proofing process for future use by creating a device link profile representing the configuration and passing the device link profile to the <code>CWConcatColorWorld</code> function to set up a color world. For information on how to create and use a device link profile to build a color world, see <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCHGAEE">Creating and Using Device Link Profiles</a></span>.</p><p>Your application can also use the QuickDraw-specific <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/NCMBeginMatching" target="_top">NCMBeginMatching</a></code> and <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CMEndMatching" target="_top">CMEndMatching</a></code> functions for soft proofing of a color image drawn to the display that a user wants to color match to the gamut of a printing press and print to a desktop printer.</p><p>The <code>NCMBeginMatching</code> function matches the colors using the two profiles that you specify, and the <code>CMEndMatching</code> function terminates the color-matching session. Because the <code>NCMBeginMatching</code> function takes two profiles only—a source profile and a destination profile—you must call sets of these functions to enact soft proofing.</p><p>QuickDraw matches to the most recently added profiles first. Therefore, to use the <code>NCMBeginMatching</code> and <code>CMEndMatching</code> pair to perform soft proofing from a displayed image to a printing press output image to a desktop printer image, you would first call the <code>NCMBeginMatching</code> function with the printing press to desktop printer profile references and then call <code>NCMBeginMatching</code> with the display to printing press profile references. QuickDraw will color match all drawing from display to printing press and then to the desktop printer.</p><p>To use the <code>NCMBeginMatching</code> function, you specify the source and destination profiles. Passing <code>NULL</code> as the source profile assures that the ColorSync Manager uses the system profile as the source profile. Similarly, passing <code>NULL</code> as the destination profile uses the system profile as the<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_276"></a> destinatio<a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_277"></a>n profile.</p><a name="//apple_ref/doc/uid/TP30000278-BBCIECGE" title="Calibrating a Device"></a><h2>Calibrating a Device</h2><p>A calibration application either creates a profile or tunes a profile to represent the current state of the device.</p><p>A profile contains two types of device information: the actual <a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_278"></a>calibration information describing how to perform the color match and the device settings at the time the match was made, for example, paper type, ink flow, or film exposure time. A device may have several profiles, each for a different setting, such as paper type or ink.</p><p>Your calibration program should first turn off matching on the device and generate its image. You should then perform the calibration and generate a profile. For related information, see <span class="content_text"><a href="../IntroCSMngr/IntroCSMngr.html#//apple_ref/doc/uid/TP30000279-BBCFHBIJ">Monitor Calibration and Profiles</a></span><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_279"></a></p><a name="//apple_ref/doc/uid/TP30000278-BBCEEHBI" title="Accessing a Resource-Based Profile With a Procedure"></a><h2>Accessing a Resource-Based Profile With a Procedure</h2><p>The ColorSync Manager provides for multiple concurrent accesses to a single profile through the use of a private data structure called a profile reference. When you call the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMOpenProfile" target="_top">CMOpenProfile</a></code> function to open a profile or the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMNewProfile" target="_top">CMNewProfile</a></code>, <code><a href="../../../Reference/ColorSync_Manager/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/CWNewLinkProfile" target="_top">CWNewLinkProfile</a></code>, or <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMCopyProfile" target="_top">CMCopyProfile</a></code> functions to create or copy a profile, you pass a profile location and the function returns a profile reference. To specify the profile location, you use a structure of type <code>CMProfileLocation</code>, as described in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCICDIF">Opening a Profile and Obtaining a Reference to It</a></span>.</p><p>A ColorSync profile that you open or create is typically stored in one of the following locations:</p><ul class="ul"><li class="li"><p>In a disk file. The <code>u</code> field (a union) of the <code>CMProfileLocation</code> data structure contains a file specification for a profile that is disk-file based. This is the most common way to store a ColorSync profile.</p></li><li class="li"><p>In relocatable memory. The <code>u</code> field of the profile location data structure contains a handle specification for a profile that is stored in a handle.</p></li><li class="li"><p>In nonrelocatable memory. The <code>u</code> field of the profile location data structure contains a pointer specification for a profile that is pointer based.</p></li><li class="li"><p>In an arbitrary location accessed by a procedure you provide. The <code>u</code> field of the profile location data structure contains a universal procedure pointer to your access procedure, as well a pointer that may point to data associated with your procedure.</p></li></ul><p>The sample code in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJBHGH">Listing 4-18</a></span> to <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGFACH">Listing 4-29</a></span> demonstrates how to use a profile access procedure to provide access to a resource-based profile.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_42" title="Note"></a><p><strong>Note:</strong>&nbsp;While the following sample code includes some error handling, more complete error handling is left as an exercise for the reader.</p></div><a name="//apple_ref/doc/uid/TP30000278-BBCFDJCI" title="Defining a Data Structure for a Resource-Based Profile"></a><h3>Defining a Data Structure for a Resource-Based Profile</h3><p>The sample code listings that follow use the application-defined MyResourceLocRec data structure. It stores information to describe a resource-based profile, including</p><ul class="spaceabove"><li class="li"><p>the resource file specification</p></li><li class="li"><p>the resource type</p></li><li class="li"><p>the resource ID</p></li><li class="li"><p>the resource file reference</p></li><li class="li"><p>the resource handle</p></li><li class="li"><p>the profile access procedure pointer</p></li><li class="li"><p>the resource name</p><div class="codesample"><table><tr><td scope="row"><pre>struct MyResourceLocRec {<span></span></pre></td></tr><tr><td scope="row"><pre>    FSSpec              resFileSpec;<span></span></pre></td></tr><tr><td scope="row"><pre>    ResType             resType;<span></span></pre></td></tr><tr><td scope="row"><pre>    short               resID;<span></span></pre></td></tr><tr><td scope="row"><pre>    short               resFileRef;<span></span></pre></td></tr><tr><td scope="row"><pre>    Handle              resHandle;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileAccessUPP  proc;<span></span></pre></td></tr><tr><td scope="row"><pre>    Str255              resName;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct MyResourceLocRec MyResourceLocRec, *MyResourceLocPtr;<span></span></pre></td></tr></table></div></li></ul><p>The ColorSync Manager defines the CMProfileAccessUPP type as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>typedef UniversalProcPtr CMProfileAccessUPP;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF124" title="Setting Up a Location Structure for Procedure Access to a Resource-Based Profile"></a><h3>Setting Up a Location Structure for Procedure Access to a Resource-Based Profile</h3><p>The MyCreateProcedureProfileAccess routine shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJBHGH">Listing 4-18</a></span> sets up a <code>CMProfileLocation</code> structure for procedure access to a resource-based profile. The MyDisposeProcedureProfileAccess routine, shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJHBHC">Listing 4-19</a></span>, disposes of memory allocated by MyCreateProcedureProfileAccess. Your application uses these routines (or similar ones that you write) in the following way:</p><ol class="ol"><li class="li"><p>Before calling a ColorSync Manager routine such as <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMCopyProfile" target="_top">CMCopyProfile</a></code>, you call the MyCreateProcedureProfileAccess routine to set up a CMProfileLocation structure that you can pass to the ColorSync Manager routine. The location structure specifies your profile-access procedure and may provide other information as well. A sample profile-access procedure is shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGDD">Listing 4-20</a></span>.</p></li><li class="li"><p>During the course of its operations, the ColorSync Manager may call your profile-access procedure many times.</p></li><li class="li"><p>After the ColorSync Manager routine has completed its operation, and if your application does not need to use the CMProfileLocation structure for another operation, you call the MyDisposeProcedureProfileAccess routine to dispose of memory allocated by MyCreateProcedureProfileAccess.</p></li></ol><p>For the sample MyCreateProcedureProfileAccess routine shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJBHGH">Listing 4-18</a></span>, you pass a pointer to a CMProfileLocation structure to fill in, a pointer to a file specification for the resource file containing the profile resource, the type of the resource, the ID for the resource, and optionally the name of the resource (stored as a Pascal string, where the first byte is a length byte for the string).</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_43" title="Note"></a><p><strong>Note:</strong>&nbsp;<span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJBHGH">Listing 4-18</a></span> assumes the profile access routine, MyCMProfileAccessProc, is within the scope of the MyCreateProcedureProfileAccess routine. Optionally, you could add a parameter to pass in a procedure pointer for the profile access routine.</p></div><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_44" title="Listing 4-18Setting up a location structure for procedure access to a resource-based profile"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCJBHGH" title="Listing 4-18Setting up a location structure for procedure access to a resource-based profile"></a><strong>Listing 4-18&nbsp;&nbsp;</strong>Setting up a location structure for procedure access to a resource-based profile</p><div class="codesample"><table><tr><td scope="row"><pre>OSErr MyCreateProcedureProfileAccess (<span></span></pre></td></tr><tr><td scope="row"><pre>                                    CMProfileLocation *profileLocation,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    FSSpec *resourceSpec,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    Str255 resourceName,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    OSType resourceType,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    short resourceID)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr               theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    MyResourceLocPtr    resourceInfo;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Allocate memory for our private resource info structure. */<span></span></pre></td></tr><tr><td scope="row"><pre>    resourceInfo = (MyResourceLocPtr) NewPtrClear(sizeof(MyResourceLocRec));<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!resourceInfo)<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = MemError();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Set up our private resource info structure. */<span></span></pre></td></tr><tr><td scope="row"><pre>        resourceInfo->resFileSpec = *resourceSpec;<span></span></pre></td></tr><tr><td scope="row"><pre>        resourceInfo->resType = resourceType;<span></span></pre></td></tr><tr><td scope="row"><pre>        resourceInfo->resID = resourceID;<span></span></pre></td></tr><tr><td scope="row"><pre>        resourceInfo->resFileRef = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        resourceInfo->resHandle = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        resourceInfo->proc = NewCMProfileAccessProc(MyCMProfileAccessProc);<span></span></pre></td></tr><tr><td scope="row"><pre>        /* If a resource name was passed in, copy it to the structure;<span></span></pre></td></tr><tr><td scope="row"><pre>            since it’s a Pascal string, first byte is length;<span></span></pre></td></tr><tr><td scope="row"><pre>            note that BlockMoveData is faster than BlockMove for a<span></span></pre></td></tr><tr><td scope="row"><pre>            move that involves data only. */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (resourceName)<span></span></pre></td></tr><tr><td scope="row"><pre>            BlockMoveData(resourceName, resourceInfo->resName,<span></span></pre></td></tr><tr><td scope="row"><pre>                            resourceName[0]+1);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* set up the profile location structure */<span></span></pre></td></tr><tr><td scope="row"><pre>        profileLocation->locType = cmProcedureBasedProfile;<span></span></pre></td></tr><tr><td scope="row"><pre>        profileLocation->u.procLoc.refCon = (void*) resourceInfo;<span></span></pre></td></tr><tr><td scope="row"><pre>        profileLocation->u.procLoc.proc = resourceInfo->proc;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If the MyCreateProcedureProfileAccess routine is able to set up the profile location pointer for procedure access to a resource-based profile, it returns a value of <code>noErr</code>.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF125" title="Disposing of a Resource-Based Profile Access Structure"></a><h3>Disposing of a Resource-Based Profile Access Structure</h3><p>Your application calls the MyDisposeProcedureProfileAccess routine (<span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJHBHC">Listing 4-19</a></span>) to dispose of any memory allocated by the MyCreateProcedureProfileAccess routine (<span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJBHGH">Listing 4-18</a></span>).</p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_45" title="Listing 4-19Disposing of a resource-based profile access structure"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCJHBHC" title="Listing 4-19Disposing of a resource-based profile access structure"></a><strong>Listing 4-19&nbsp;&nbsp;</strong>Disposing of a resource-based profile access structure</p><div class="codesample"><table><tr><td scope="row"><pre>void MyDisposeProcedureProfileAccess (CMProfileLocation *profileLocation)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRoutineDescriptor(profileLocation->u.procLoc.proc);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Dispose of our private resource info structure. */<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposePtr((Ptr)profileLocation->u.procLoc.refCon);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This routine first disposes of the universal procedure pointer to your profile access procedure, then disposes of the pointer used to store resource data in a MyResourceLocRec structure.</p><a name="//apple_ref/doc/uid/TP30000278-TPXREF126" title="Responding to a Procedure-Based Profile Command"></a><h3>Responding to a Procedure-Based Profile Command</h3><p>For information on the procedure declaration for a profile access procedure, see <code><!--a-->MyCMProfileAccessProc<!--/a--></code>. The ColorSync Manager calls your procedure when the profile is created, initialized, opened, read, updated, or closed, passing a command constant that specifies the current command. Your profile access procedure must be able to respond to each of the following command constants, which are described in <em>ColorSync Manager Reference</em>:</p><div class="codesample"><table><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    cmOpenReadAccess    = 1,<span></span></pre></td></tr><tr><td scope="row"><pre>    cmOpenWriteAccess   = 2,<span></span></pre></td></tr><tr><td scope="row"><pre>    cmReadAccess        = 3,<span></span></pre></td></tr><tr><td scope="row"><pre>    cmWriteAccess       = 4,<span></span></pre></td></tr><tr><td scope="row"><pre>    cmCloseAccess       = 5,<span></span></pre></td></tr><tr><td scope="row"><pre>    cmCreateNewAccess   = 6,<span></span></pre></td></tr><tr><td scope="row"><pre>    cmAbortWriteAccess  = 7,<span></span></pre></td></tr><tr><td scope="row"><pre>    cmBeginAccess       = 8,<span></span></pre></td></tr><tr><td scope="row"><pre>    cmEndAccess         = 9<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>The profile access procedure shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGDD">Listing 4-20</a></span>, <code>MyCMProfileAccessProc</code>, consists of a single switch statement, which calls the appropriate routine based on the value of the <code>command</code> parameter. Each of the nine routines called by <code>MyCMProfileAccessProc</code> is described and listed in the sections that follow <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGDD">Listing 4-20</a></span>, and each refers back to <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGDD">Listing 4-20</a></span>.</p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_46" title="Listing 4-20Responding to a procedure-based profile command"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCBFGDD" title="Listing 4-20Responding to a procedure-based profile command"></a><strong>Listing 4-20&nbsp;&nbsp;</strong>Responding to a procedure-based profile command</p><div class="codesample"><table><tr><td scope="row"><pre>pascal OSErr MyCMProfileAccessProc (long command,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    long offset,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    long *sizePtr,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    void *dataPtr,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    void *refConPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr   theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    switch (command)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case cmBeginAccess:<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = DoBeginAccess(refConPtr);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case cmCreateNewAccess:<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = DoCreateNewAccess(refConPtr);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case cmOpenReadAccess:<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = DoOpenReadAccess(refConPtr);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case cmOpenWriteAccess:<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = DoOpenWriteAccess(sizePtr, refConPtr);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case cmReadAccess:<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = DoReadAccess(offset, sizePtr, dataPtr, refConPtr);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case cmWriteAccess:<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = DoWriteAccess(offset, sizePtr, dataPtr, refConPtr);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case cmCloseAccess:<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = DoCloseAccess(refConPtr);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case cmAbortWriteAccess:<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = DoAbortWriteAccess(refConPtr);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case cmEndAccess:<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = DoEndAccess(refConPtr);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        default:<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Note that the MyCMProfileAccessProc routine passes its parameter data as necessary to the routines it calls. The parameters have the following values:</p><dl class="termdef">	<dt><i class="mono">command</em></dt><dd><p>A command value indicating the operation to perform. The possible values for command constants are shown elsewhere in this section.</p></dd><dt><i class="mono">offset</em></dt><dd><p>For read and write operations, the offset from the beginning of the profile at which to read or write data.</p></dd><dt><i class="mono">size</em></dt><dd><p>For the cmReadAccess and cmWriteAccess command constants, a pointer to a value indicating the number of bytes to read or write; for the cmOpenWriteAccess command, the total size of the profile. On output after reading or writing, the actual number of bytes read or written.</p></dd><dt><i class="mono">data</em></dt><dd><p>A pointer to a buffer containing data to read or write. On output, for a read operation, contains the data that was read.</p></dd><dt><i class="mono">refConPtr</em></dt><dd><p>A reference constant pointer that can store private data for the MyCMProfileAccessProc procedure. For example, <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJBHGH">Listing 4-18</a></span> shows how to set up a location structure for procedure access to a resource-based profile. That routine sets the location structure’s refCon field to a pointer to a MyResourceLocRec structure, which is described in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFDJCI">Defining a Data Structure for a Resource-Based Profile</a></span>. That same structure pointer is passed to the MyCMProfileAccessProc routine in the refConPtr parameter, and provides access to all the stored information about the resource location.</p></dd></dl><a name="//apple_ref/doc/uid/TP30000278-BBCBJEBF" title="Handling the Begin Access Command"></a><h2>Handling the Begin Access Command</h2><p>When your application calls the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMOpenProfile" target="_top">CMOpenProfile</a></code> routine, specifying as a location a procedure-based profile, the ColorSync Manager invokes your specified profile access procedure with the cmBeginAccess command. This gives your procedure an opportunity to perform any required initialization or validation tasks, such as determining whether the data pointed to by the <code>refcon</code> parameter is valid. If your procedure returns an error (any value except <code>noErr</code>), the ColorSync Manager will not call your profile access procedure again.</p><p>For the cmBeginAccess command, the sample profile access procedure shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGDD">Listing 4-20</a></span> calls the DoBeginAccess routine, shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGDJFI">Listing 4-21</a></span>. DoBeginAccess interprets the <code>refcon</code> parameter as a MyResourceLocPtr type. If the parameter does not have a resource type of kProcResourceType, DoBeginAccess returns an invalid profile error, which effectively cancels the procedure-based profile access.</p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_47" title="Listing 4-21Handling the begin access command"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCGDJFI" title="Listing 4-21Handling the begin access command"></a><strong>Listing 4-21&nbsp;&nbsp;</strong>Handling the begin access command</p><div class="codesample"><table><tr><td scope="row"><pre>static OSErr DoBeginAccess (void *refcon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr               theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    MyResourceLocPtr    resourceInfo = refcon;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    resourceInfo->resFileRef = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (resourceInfo->resType != kProcResourceType)<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = cmInvalidProfileLocation;<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF127" title="Handling the Create New Access Command"></a><h2>Handling the Create New Access Command</h2><p>When your application calls the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMCopyProfile" target="_top">CMCopyProfile</a></code> or <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMUpdateProfile" target="_top">CMUpdateProfile</a></code> routine, specifying as a location a procedure-based profile, the ColorSync Manager invokes the specified profile access procedure with the cmBeginAccess command, as described in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBJEBF">Handling the Begin Access Command</a></span>.</p><p>If your profile access procedure returns without error, ColorSync calls the procedure again with the cmCreateNewAccess command. Your procedure should create a new data stream for the actual physical location of the profile. The size of the profile is not known at this point.</p><p>For the cmCreateNewAccess command, the sample profile access procedure shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGDD">Listing 4-20</a></span> calls the DoCreateNewAccess routine. DoCreateNewAccess interprets the <code>refcon</code> parameter as a MyResourceLocPtr type, and calls the Toolbox routine FSpCreateResFile to create an empty resource fork based on the file specification provided by the MyResourceLocPtr type. If the resource fork does not already exist and cannot be created, DoCreateNewAccess returns an error.</p><p>Note that for this example, the file type for a resource-based profile was chosen arbitrarily to be <code>'rprf'</code>.</p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_48" title="Listing 4-22Handling the create new access command"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-TPXREF135" title="Listing 4-22Handling the create new access command"></a><strong>Listing 4-22&nbsp;&nbsp;</strong>Handling the create new access command</p><div class="codesample"><table><tr><td scope="row"><pre>OSErr DoCreateNewAccess (void *refcon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr               theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    MyResourceLocPtr    resourceInfo = refcon;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    FSpCreateResFile(&amp;(resourceInfo->resFileSpec), '????', 'rprf', 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre>    if (theErr == dupFNErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-BBCGFDDA" title="Handling the Open Read Access Command"></a><h2>Handling the Open Read Access Command</h2><p>When your application calls a ColorSync Manager routine to read information from a procedure-based profile, the ColorSync Manager first calls your profile access procedure with the cmOpenReadAccess command. Then it calls your profile access routine once for each read session. The sample profile access procedure shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGDD">Listing 4-20</a></span> calls the DoOpenReadAccess routine.</p><p>The DoOpenReadAccess routine shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCIHJBG">Listing 4-23</a></span> uses information from the refcon parameter, interpreted as type MyResourceLocPtr, to open the resource fork for the resource-based profile with read permission. If it can open the resource file, DoOpenReadAccess then attempts to load the profile resource.</p><p>The DoOpenReadAccess routine shows good citizenship by saving the current resource file before performing its operations and restoring the resource file afterward.</p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_49" title="Listing 4-23Handling the open read access command"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCIHJBG" title="Listing 4-23Handling the open read access command"></a><strong>Listing 4-23&nbsp;&nbsp;</strong>Handling the open read access command</p><div class="codesample"><table><tr><td scope="row"><pre>static OSErr DoOpenReadAccess (void *refcon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr               theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    MyResourceLocPtr    resourceInfo = refcon;<span></span></pre></td></tr><tr><td scope="row"><pre>    short               currentResFile;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Save current resource file. */<span></span></pre></td></tr><tr><td scope="row"><pre>    currentResFile = CurResFile();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Open the file's resource fork. */<span></span></pre></td></tr><tr><td scope="row"><pre>    resourceInfo->resFileRef = FSpOpenResFile(&amp;(resourceInfo->resFileSpec), fsRdPerm);<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Get the resource handle, but don’t force it to be loaded into memory. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        SetResLoad(false);<span></span></pre></td></tr><tr><td scope="row"><pre>        resourceInfo->resHandle = GetResource(resourceInfo->resType,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                resourceInfo->resID);<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre>        SetResLoad(true);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Restore previous resource file. */<span></span></pre></td></tr><tr><td scope="row"><pre>    UseResFile(currentResFile);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF128" title="Handling the Open Write Access Command"></a><h2>Handling the Open Write Access Command</h2><p>When your application calls the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMUpdateProfile" target="_top">CMUpdateProfile</a></code> routine to update a procedure-based profile or the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMCopyProfile" target="_top">CMCopyProfile</a></code> routine to copy a profile, the ColorSync Manager calls your profile access procedure with the cmOpenWriteAccess command. The sample profile access procedure shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCIHJBG">Listing 4-23</a></span> calls the DoOpenWriteAccess routine.</p><p>The DoOpenWriteAccess routine shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEFIDH">Listing 4-24</a></span> uses information from the refcon parameter, interpreted as type MyResourceLocPtr, to open the resource fork for the resource-based profile with read/write permission. If it can open the resource file, DoOpenWriteAccess then attempts to open the specified profile resource. If it can’t open the resource, DoOpenWriteAccess creates a new resource. It then sets the size of the resource based on the passed setProfileSize pointer value and updates the resource file.</p><p>The DoOpenWriteAccess routine shows good citizenship by saving the current resource file before performing its operations and restoring the resource file afterward.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_50" title="Note"></a><p><strong>Note:</strong>&nbsp;If the cmOpenWriteAccess command succeeds, the ColorSync Manager guarantees an eventual call to the profile access procedure with the cmCloseAccess command, possibly after multiple cmWriteAccess commands, and possibly after a cmAbortWriteAccess command.</p></div><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_51" title="Listing 4-24Handling the open write access command"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCEFIDH" title="Listing 4-24Handling the open write access command"></a><strong>Listing 4-24&nbsp;&nbsp;</strong>Handling the open write access command</p><div class="codesample"><table><tr><td scope="row"><pre>static OSErr DoOpenWriteAccess (long *setProfileSize, void *refcon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr               theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    MyResourceLocPtr    resourceInfo = refcon;<span></span></pre></td></tr><tr><td scope="row"><pre>    Size                resourceSize;<span></span></pre></td></tr><tr><td scope="row"><pre>    short               currentResFile;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Save current resource file. */<span></span></pre></td></tr><tr><td scope="row"><pre>    currentResFile = CurResFile();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Open the file's resource fork. */<span></span></pre></td></tr><tr><td scope="row"><pre>    resourceInfo->resFileRef = FSpOpenResFile(&amp;(resourceInfo->resFileSpec),<span></span></pre></td></tr><tr><td scope="row"><pre>                                                fsRdWrPerm);<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Get the resource handle, but don’t force it to be loaded into memory. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        SetResLoad(false);<span></span></pre></td></tr><tr><td scope="row"><pre>        resourceInfo->resHandle = GetResource(resourceInfo->resType,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                resourceInfo->resID);<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre>        SetResLoad(true);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Call GetResourceSizeOnDisk to see if resource is already there. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Get size of the resource. */<span></span></pre></td></tr><tr><td scope="row"><pre>        resourceSize = GetResourceSizeOnDisk(resourceInfo->resHandle);<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* If the above call to GetResourceSizeOnDisk returns resNotFound,<span></span></pre></td></tr><tr><td scope="row"><pre>        then we need to create a new resource */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (theErr == resNotFound)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Allocate a temporary handle just so that we can call AddResource. */<span></span></pre></td></tr><tr><td scope="row"><pre>        resourceInfo->resHandle = NewHandle(sizeof(long));<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = MemError();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* Add resource to the file and release the temp handle. */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            AddResource(resourceInfo->resHandle, resourceInfo->resType,<span></span></pre></td></tr><tr><td scope="row"><pre>                         resourceInfo->resID, resourceInfo->resName);<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre>            ReleaseResource(resourceInfo->resHandle);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Get the resource handle, but don’t force it to be loaded into memory. */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            SetResLoad(false);<span></span></pre></td></tr><tr><td scope="row"><pre>            resourceInfo->resHandle = GetResource(resourceInfo->resType,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    resourceInfo->resID);<span></span></pre></td></tr><tr><td scope="row"><pre>            theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre>            SetResLoad(true);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Change the resource size to fit the profile. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        SetResourceSize(resourceInfo->resHandle, *setProfileSize);<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Force an update of the resource file. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        UpdateResFile(resourceInfo->resFileRef);<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Restore previous resource file. */<span></span></pre></td></tr><tr><td scope="row"><pre>    UseResFile(currentResFile);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF129" title="Handling the Read Access Command"></a><h2>Handling the Read Access Command</h2><p>When your application calls a ColorSync Manager routine to read information from a procedure-based profile, the ColorSync Manager first calls your profile access procedure with the cmOpenReadAccess command, as described in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGFDDA">Handling the Open Read Access Command</a></span>. Your profile access routine can be called with the cmReadAccess command at any time after the cmOpenReadAccess command is called. When the sample profile access procedure shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGDD">Listing 4-20</a></span> receives the cmReadAccess command, it calls the DoReadAccess routine.</p><p>The DoReadAccess routine shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFCHGI">Listing 4-25</a></span> uses the refcon parameter, interpreted as type MyResourceLocPtr, to get a resource handle for the resource-based profile. From other parameters, it gets values for the offset at which to start reading, the number of bytes to read, and a pointer to a buffer in which to store the data that it reads. It then calls the Toolbox routine ReadPartialResource to do the actual reading.</p><p>If an error occurs while reading, DoReadAccess returns the error.</p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_52" title="Listing 4-25Handling the read access command"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCFCHGI" title="Listing 4-25Handling the read access command"></a><strong>Listing 4-25&nbsp;&nbsp;</strong>Handling the read access command</p><div class="codesample"><table><tr><td scope="row"><pre>static OSErr DoReadAccess ( long offset,<span></span></pre></td></tr><tr><td scope="row"><pre>                            long *sizePtr,<span></span></pre></td></tr><tr><td scope="row"><pre>                            void *dataPtr,<span></span></pre></td></tr><tr><td scope="row"><pre>                            void *refcon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr               theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    MyResourceLocPtr    resourceInfo = refcon;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ReadPartialResource(resourceInfo->resHandle,<span></span></pre></td></tr><tr><td scope="row"><pre>                            offset, dataPtr, *sizePtr);<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF130" title="Handling the Write Access Command"></a><h2>Handling the Write Access Command</h2><p>When your application calls the <code><a href="../../../Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/doc/c_ref/CMUpdateProfile" target="_top">CMUpdateProfile</a></code> routine to update a procedure-based profile, the ColorSync Manager first calls your profile access procedure with the cmOpenWriteAccess command. The DoOpenWriteAccess routine shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEFIDH">Listing 4-24</a></span> performs certain operations to prepare to write a resource-based profile.</p><p>Your profile access routine can be called with the cmWriteAccess command at any time after the cmOpenWriteAccess command is called. When the sample profile access procedure shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGDD">Listing 4-20</a></span> receives the cmWriteAccess command, it calls the DoWriteAccess routine.</p><p>The DoWriteAccess routine shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGCJBD">Listing 4-26</a></span> uses the refcon parameter, interpreted as type MyResourceLocPtr, to get a resource handle for the resource-based profile. From other parameters, it gets values for the offset at which to start writing, the number of bytes to write, and a pointer to a buffer from which to get the data that it writes. It then calls the Toolbox routine WritePartialResource to do the actual writing.</p><p>If an error occurs while writing, DoWriteAccess returns the error.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_53" title="Note"></a><p><strong>Note:</strong>&nbsp;After ColorSync calls the profile access procedure with the cmWriteAccess command, ColorSync is guaranteed to eventually call the profile access procedure with the cmCloseAccess command—possibly after additional calls with the cmWriteAccess command, and possibly after a call with the cmAbortWriteAccess command.</p></div><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_54" title="Listing 4-26Handling the write access command"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCGCJBD" title="Listing 4-26Handling the write access command"></a><strong>Listing 4-26&nbsp;&nbsp;</strong>Handling the write access command</p><div class="codesample"><table><tr><td scope="row"><pre>static OSErr DoWriteAccess (long offset,<span></span></pre></td></tr><tr><td scope="row"><pre>                            long *sizePtr,<span></span></pre></td></tr><tr><td scope="row"><pre>                            void *dataPtr,<span></span></pre></td></tr><tr><td scope="row"><pre>                            void *refcon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr               theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    MyResourceLocPtr    resourceInfo = refcon;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    WritePartialResource(resourceInfo->resHandle,<span></span></pre></td></tr><tr><td scope="row"><pre>                            offset, dataPtr, *sizePtr);<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF131" title="Handling the Close Access Command"></a><h2>Handling the Close Access Command</h2><p>The ColorSync Manager calls your profile access procedure with the cmCloseAccess command to indicate that reading or writing is finished for the moment. A cmCloseAccess command can be followed by a cmOpenReadAccess command to begin reading again, a cmOpenWriteAccess command to begin writing again, or a cmEndAccess command to terminate the procedure-based profile access.</p><p>The sample profile access procedure shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGDD">Listing 4-20</a></span> calls the DoCloseAccess routine.</p><p>The DoCloseAccess routine shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCFHBGG">Listing 4-27</a></span> uses information from the refcon parameter, interpreted as type MyResourceLocPtr, to close and update the resource file for the resource-based profile. If DoCloseAccess is unsuccessful, it returns an error value.</p><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_55" title="Listing 4-27Handling the close access command"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCFHBGG" title="Listing 4-27Handling the close access command"></a><strong>Listing 4-27&nbsp;&nbsp;</strong>Handling the close access command</p><div class="codesample"><table><tr><td scope="row"><pre>static OSErr DoCloseAccess (void *refcon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr               theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    MyResourceLocPtr    resourceInfo = refcon;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Close and update resource file. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (resourceInfo->resFileRef)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CloseResFile(resourceInfo->resFileRef);<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre>        resourceInfo->resFileRef = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else theErr = paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF132" title="Handling the Abort Write Access Command"></a><h2>Handling the Abort Write Access Command</h2><p>If an error occurs between a <code>cmOpenWriteAccess</code> command and a <code>cmCloseAccess</code> command, the ColorSync Manager calls your profile access procedure with the <code>cmAbortWriteAccess</code> command. This allows your access procedure to perform any cleanup necessary for the partially written profile.</p><p>For the <code>cmAbortWriteAccess</code> command, the sample profile access procedure shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGDD">Listing 4-20</a></span> calls the DoAbortWriteAccess routine.</p><p>The DoAbortWriteAccess routine shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCEHJFE">Listing 4-28</a></span> uses information from the refcon parameter, interpreted as type MyResourceLocPtr, to call the Toolbox routine RemoveResource to delete the partially written resource. If DoAbortWriteAccess is unsuccessful, it returns an error value.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_56" title="Note"></a><p><strong>Note:</strong>&nbsp;The ColorSync Manager will call your profile access procedure with the <code>cmCloseAccess</code> command after a <code>cmAbortWriteAccess</code> command.</p></div><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_57" title="Listing 4-28Handling the abort write access command"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCEHJFE" title="Listing 4-28Handling the abort write access command"></a><strong>Listing 4-28&nbsp;&nbsp;</strong>Handling the abort write access command</p><div class="codesample"><table><tr><td scope="row"><pre>static OSErr DoAbortWriteAccess (void *refcon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr               theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    MyResourceLocPtr    resourceInfo = refcon;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Delete the resource that we started. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (resourceInfo->resHandle)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        RemoveResource(resourceInfo->resHandle);<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = ResError();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else theErr = paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-TPXREF133" title="Handling the End Access Command"></a><h2>Handling the End Access Command</h2><p>When access to a procedure-based profile is complete, the ColorSync Manager calls your profile access procedure with the <code>cmEndAccess</code> command. This allows your procedure to do any final cleanup, such as freeing memory allocated by the procedure.</p><p>For the <code>cmEndAccess</code> command, the sample profile access procedure shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCBFGDD">Listing 4-20</a></span> calls the DoEndAccess routine. Because there is no additional memory to free or other cleanup to take care of, the DoEndAccess routine shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCGFACH">Listing 4-29</a></span> does nothing.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_58" title="Note"></a><p><strong>Note:</strong>&nbsp;The MyCreateProcedureProfileAccess routine, shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJBHGH">Listing 4-18</a></span>, does allocate memory, which is freed by a call to the MyDisposeProcedureProfileAccess routine, shown in <span class="content_text"><a href="DevCSApps.html#//apple_ref/doc/uid/TP30000278-BBCJHBHC">Listing 4-19</a></span>. Your application calls the MyCreateProcedureProfileAccess routine before calling a ColorSync Manager routine such as <code>CMCopyProfile</code> with a procedure-based profile. After the copy is complete, your application calls the MyDisposeProcedureProfileAccess routine to perform any necessary deallocation.</p></div><a name="//apple_ref/doc/uid/TP30000278-DontLinkElementID_59" title="Listing 4-29Handling the end access command"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30000278-BBCGFACH" title="Listing 4-29Handling the end access command"></a><strong>Listing 4-29&nbsp;&nbsp;</strong>Handling the end access command</p><div class="codesample"><table><tr><td scope="row"><pre>pascal OSErr DoEndAccess (void *refcon)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr   theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000278-BBCJBHEB" title="Summary of the ColorSync Manager"></a><h2>Summary of the ColorSync Manager</h2><p>This section provides a quick-reference summary of the functions, data types, and constants that make up the ColorSync Manager programming interface.</p><p></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../IntroCSMngr/IntroCSMngr.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../DevCSSDevDrvrs/DevCSSDevDrvrs.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 1999, 2003 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2003-02-01<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/ManagingColorSync/DevCSApps/DevCSApps.html%3Fid%3DTP40000896-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/ManagingColorSync/DevCSApps/DevCSApps.html%3Fid%3DTP40000896-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/ManagingColorSync/DevCSApps/DevCSApps.html%3Fid%3DTP40000896-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>