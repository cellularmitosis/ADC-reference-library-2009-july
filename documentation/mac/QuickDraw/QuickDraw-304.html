<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using Offscreen Graphics Worlds (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING304></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-303.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-305.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-302.html"><B>Chapter 6 - Offscreen Graphics Worlds</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING304-0></A>
<H1>Using Offscreen Graphics Worlds</H1>
 To use an offscreen graphics world, you generally<P>
<UL>
<LI>use the <CODE>NewGWorld</CODE> function to create an offscreen graphics world
<LI>use the <CODE>GetGWorld</CODE> procedure to save the onscreen graphics port for the active window
<LI>use the <CODE>SetGWorld</CODE> procedure to make the offscreen graphics world the current graphics port
<LI>use the <CODE>LockPixels</CODE> function to prevent the base address for the offscreen pixel image from moving while you draw into it or copy from it
<LI>use the <CODE>EraseRect</CODE> procedure to initialize the offscreen pixel image
<LI>use the basic QuickDraw and Color QuickDraw routines described elsewhere in this book to draw into the offscreen graphics world
<LI>use the <CODE>SetGWorld</CODE> procedure to restore the active window as the current graphics port
<LI>use the <CODE>CopyBits</CODE> procedure to copy the image from the offscreen graphics world into the active window
<LI>use the <CODE>UnlockPixels</CODE> procedure to allow the Memory Manager to move the base address for the offscreen pixel image
<LI>use the <CODE>DisposeGWorld</CODE> procedure to dispose of all the memory allocated for an offscreen graphics world when you no longer need its offscreen pixel image<P>
</UL>
 If you want to use the <CODE>CopyMask</CODE> or <CODE>CopyDeepMask</CODE> procedure, you can create another offscreen graphics world and draw your mask into that offscreen world.<P>
 These tasks are explained in greater detail in the rest of this chapter.<P>
 <A NAME=MARKER-9-230></A>Before using the routines described in this chapter, you must use the <CODE>InitGraf</CODE> procedure, described in the chapter "Basic QuickDraw," to initialize QuickDraw. You should also ensure the availability of these routines by checking for the existence of System 7 or Color QuickDraw. <P>
 You can make sure that offscreen graphics world routines are available on any computer--including one supporting only basic QuickDraw--by using the <CODE>Gestalt</CODE> function with the <CODE>gestaltSystemVersion</CODE> selector. Test the low-order word in the <CODE>response</CODE> parameter; if the value is $0700 or greater, then offscreen graphics worlds are supported.<P>
 You can also test for offscreen graphics world support by using the <CODE>Gestalt</CODE> function with the <CODE>gestaltQuickDrawVersion</CODE> selector. If the value returned in the <CODE>response</CODE> parameter is equal to or greater than the value of the constant <CODE>gestalt32BitQD</CODE>, then the system supports both Color QuickDraw and offscreen graphics worlds.<P>
 You can use the <CODE>Gestalt</CODE> function with the <CODE>gestaltQuickDrawVersion</CODE> selector to determine whether the user's system supports offscreen color pixel maps. If the bit indicated by the <CODE>gestaltHasDeepGWorlds</CODE> constant is set in the <CODE>response</CODE> parameter, then offscreen color pixel maps are available.<P>
 For more information about the <CODE>Gestalt</CODE> function, see the chapter "Gestalt Manager" in <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>.<A NAME=MARKER-2-24></A><P>
<A NAME=HEADING304-19></A>
<H2>Creating an Offscreen Graphics World</H2>
 <A NAME=MARKER-2-369></A><A NAME=MARKER-2-243></A>You create an offscreen graphics world with the <CODE>NewGWorld</CODE> function. It creates a new offscreen graphics port, a new offscreen pixel map, and (on computers that support Color QuickDraw) either a new offscreen <CODE>GDevice</CODE> record or a link to an existing one. It returns a data structure of type <CODE>GWorldPtr</CODE> by which your application refers to your new offscreen graphics world. <A HREF=#MARKER-9-27>Listing 6-1</A> illustrates how to create an offscreen graphics world.<P>
<A NAME=MARKER-9-27></A><B>Listing 6-1  Using a single offscreen graphics world and the <CODE>CopyBits</CODE> procedure</B><P>
<PRE>
PROCEDURE MyPaintRectsThruGWorld (wp: WindowPtr);
   VAR
      origPort:               GrafPtr;
      origDev:                GDHandle;
      myErr:                  QDErr;
      myOffGWorld:            GWorldPtr;
      offPixMapHandle:        PixMapHandle;
      good:                   Boolean;
      sourceRect, destRect:   Rect;
BEGIN
   GetGWorld(origPort, origDev);          {save window's graphics port}
   myErr := NewGWorld(myOffGWorld, 0,     {create offscreen graphics world, }
                     wp^.portRect,        { using window's port rectangle}
                     NIL, NIL, []);
   IF (myOffGWorld = NIL) OR (myErr &lt;&gt; noErr) THEN
      ; {handle error here}
   SetGWorld(myOffGWorld, NIL);  {make offscreen world the current port}
   offPixMapHandle := GetGWorldPixMap(myOffGWorld);   {get handle to }
   good := LockPixels(offPixMapHandle); { offscreen pixel image and lock it}
   IF NOT good THEN
      ; {handle error here}
   EraseRect(myOffGWorld^.portRect);         {initialize its pixel image}
   MyPaintAndFillColorRects; {paint a blue rectangle, fill a green rectangle}
   SetGWorld(origPort, origDev);          {make window the current port}
      {next, for CopyBits, create source and destination rectangles that }
      { exclude scroll bar areas}
   sourceRect := myOffGWorld^.portRect;   {use offscreen portRect for source}
   sourceRect.bottom := myOffGWorld^.portRect.bottom - 15;
   sourceRect.right := myOffGWorld^.portRect.right - 15;
   destRect := wp^.portRect;        {use window portRect for destination}
   destRect.bottom := wp^.portRect.bottom - 15;
   destRect.right := wp^.portRect.right - 15;
      {next, use CopyBits to transfer the offscreen image to the window}
   CopyBits(GrafPtr(myOffGWorld)^.portBits,  {coerce graphics world's }
                                             { PixMap to a BitMap}
            GrafPtr(wp)^.portBits,     {coerce window's PixMap to a BitMap}
            sourceRect, destRect, srcCopy, NIL);
   IF QDError &lt;&gt; noErr THEN
      ; {likely error is that there is insufficient memory}
   UnlockPixels(offPixMapHandle);         {unlock the pixel image}
   DisposeGWorld(myOffGWorld);            {dispose of offscreen world}
END;
</PRE>
 When you use <CODE>NewGWorld</CODE>, you can specify a pixel depth, a boundary rectangle (which also becomes the port rectangle), a color table, a <CODE>GDevice</CODE> record, and option flags for memory allocation for the offscreen graphics world. Typically, however, you pass 0 as the pixel depth, a window's port rectangle as the offscreen world's boundary rectangle, <CODE>NIL</CODE> for both the color table and <CODE>GDevice</CODE> record, and an empty set ([ ]) in your Pascal code or 0 in your C code for the option flags. This provides your application with the default behavior of <CODE>NewGWorld</CODE>, and it supports computers running only basic QuickDraw. This also allows QuickDraw to optimize the <CODE>CopyBits</CODE>, <CODE>CopyMask</CODE>, and <CODE>CopyDeepMask</CODE> procedures when your application copies the image you create in an offscreen graphics world into the window's port rectangle.<P>
 When creating an offscreen graphics world, if you specify 0 as the pixel depth, the port rectangle for a window as the boundary rectangle, and no option flags, the <CODE>NewGWorld</CODE> function<P>
<UL>
<LI>uses the pixel depth of the screen with the greatest pixel depth from among all screens intersected by the window
<LI>aligns the pixel image to the screen for optimum performance for the <CODE>CopyBits</CODE> procedure
<LI>uses the color table and <CODE>GDevice</CODE> record for the screen with the greatest pixel depth from among all screens intersected by the window
<LI>allocates an unpurgeable base address for the offscreen pixel image in your application heap
<LI>allows graphics accelerators to cache the offscreen pixel image<P>
</UL>
 The application-defined routine <CODE>MyPaintRectsThruGWorld</CODE> in <A HREF=#MARKER-9-27>Listing 6-1</A>, for example, specifies the default behavior for <CODE>NewGWorld</CODE>. The <CODE>MyPaintRectsThruGWorld</CODE> routine dereferences the window pointer passed in the <CODE>wp</CODE> parameter to obtain a window's port rectangle, which <CODE>MyPaintRectsThruGWorld</CODE> passes to <CODE>NewGWorld</CODE> as the boundary and port rectangle for the offscreen graphics world.<CODE></CODE><A NAME=MARKER-9-73></A><P>
<A NAME=HEADING304-31></A>
<H2>Setting the Graphics Port for an Offscreen Graphics World</H2>
 <A NAME=MARKER-2-255></A><A NAME=MARKER-2-397></A><A NAME=MARKER-2-249></A><A NAME=MARKER-9-335></A><A NAME=MARKER-2-34></A><A NAME=MARKER-2-41></A>Before drawing into the offscreen graphics port created in <A HREF=#MARKER-9-27>Listing 6-1 on page 6-5</A>, <CODE>MyPaintRectsThruGWorld</CODE> saves the graphics port for the front window by calling the <CODE>GetGWorld</CODE> procedure, which saves the current graphics port and its <CODE>GDevice</CODE> record. Then <CODE>MyPaintRectsThruGWorld</CODE> makes the offscreen graphics world the current port by calling the <CODE>SetGWorld</CODE> procedure. After drawing into the offscreen graphics world, <CODE>MyPaintRectsThruGWorld</CODE> also uses <CODE>SetGWorld</CODE> to restore the active window as the current graphics port.<P>
 Instead of using the <CODE>GetPort</CODE> and <CODE>SetPort</CODE> procedures for saving and restoring offscreen graphics worlds, you must use <CODE>GetGWorld</CODE> and <CODE>SetGWorld</CODE>; you can also use <CODE>GetGWorld</CODE> and <CODE>SetGWorld</CODE> for saving and restoring color and basic graphics ports.<A NAME=MARKER-2-132></A><A NAME=MARKER-2-130></A><A NAME=MARKER-2-253></A><A NAME=MARKER-2-256></A><A NAME=MARKER-2-414></A><A NAME=MARKER-2-61></A><P>
<A NAME=HEADING304-34></A>
<H2>Drawing Into an Offscreen Graphics World</H2>
 <A NAME=MARKER-2-218></A>You must call the <CODE>LockPixels</CODE> function before drawing to or copying from an offscreen graphics world. The <CODE>LockPixels</CODE> function prevents the base address for an offscreen pixel image from being moved while you draw into it or copy from it. <P>
 If the base address for an offscreen pixel image hasn't been purged by the Memory Manager or if its base address is not purgeable, <CODE>LockPixels</CODE> returns <CODE>TRUE</CODE> as its function result, and your application can draw into or copy from the offscreen pixel image. However, if the base address for an offscreen pixel image has been purged, <CODE>LockPixels</CODE> returns <CODE>FALSE</CODE> to indicate that you cannot draw into it or copy from it. (At that point, your application should either call the <CODE>UpdateGWorld</CODE> function to reallocate the offscreen pixel image and then reconstruct it, or draw directly into an onscreen graphics port.)<P>
 After setting the offscreen graphics world to the current graphics port, <CODE>MyPaintRectsThruGWorld</CODE> in <A HREF=#MARKER-9-27>Listing 6-1 on page 6-5</A> uses the <CODE>GetGWorldPixMap</CODE> function to get a handle to an offscreen pixel map. Passing this handle to the <CODE>LockPixels</CODE> function, <CODE>MyPaintRectsThruGWorld</CODE> locks the memory for the offscreen pixel image in preparation for drawing into its pixel map.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD><A NAME=MARKER-2-174></A>On a system running only basic QuickDraw, the <CODE>GetGWorldPixMap</CODE> function returns the handle to a 1-bit pixel map that your application can supply as a parameter to <CODE>LockPixels</CODE> and the other routines related to offscreen graphics worlds that are described in this chapter. On a basic QuickDraw system, however, your application should not supply this handle to Color QuickDraw routines.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The <CODE>MyPaintRectsThruGWorld</CODE> routine initializes the offscreen pixel image to all white by calling the <CODE>EraseRect</CODE> procedure, which is described in the chapter "Basic QuickDraw." The <CODE>MyPaintRectsThruGWorld</CODE> routine then calls another application-defined routine, <CODE>MyPaintAndFillColorRects</CODE>, to draw color rectangles into the pixel map for the offscreen graphics world.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>You cannot dereference the <CODE>GWorldPtr</CODE> data structure to get to the pixel map. The <CODE>baseAddr</CODE> field of the <CODE>PixMap</CODE> record for an offscreen graphics world contains a handle instead of a pointer, which is what the <CODE>baseAddr</CODE> field for an onscreen pixel map contains. You must use the <CODE>GetPixBaseAddr</CODE> function (described on <A HREF=QuickDraw-329.html#MARKER-9-229>page 6-38</A>) to obtain a pointer to the <CODE>PixMap</CODE> record for an offscreen graphics world.<EM></EM><A NAME=MARKER-2-137></A><A NAME=MARKER-2-179></A><A NAME=MARKER-2-186></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING304-41></A>
<H2>Copying an Offscreen Image Into a Window</H2>
 <A NAME=MARKER-2-96></A><A NAME=MARKER-2-191></A><A NAME=MARKER-2-49></A><A NAME=MARKER-2-50></A><A NAME=MARKER-2-207></A><A NAME=MARKER-9-415></A><A NAME=MARKER-9-46></A>After preparing an image in the offscreen graphics world, your application must use <CODE>SetGWorld</CODE> to restore the active window as the current graphics port, as illustrated in <A HREF=#MARKER-9-27>Listing 6-1 on page 6-5</A>.<P>
 To copy the image from an offscreen graphics world into a window, use the <CODE>CopyBits</CODE> procedure. Specify the offscreen graphics world as the source image for <CODE>CopyBits</CODE>, and specify the window as its destination. When using <CODE>CopyBits</CODE>, you must coerce the offscreen graphics world's <CODE>GWorldPtr</CODE> data type to a data structure of type <CODE>GrafPtr</CODE>. Similarly, whenever a color graphics port is your destination, you must coerce the window's <CODE>CGrafPtr</CODE> data type to a data structure of type <CODE>GrafPtr</CODE>. (The <CODE>CopyBits</CODE> procedure is described in the chapter "QuickDraw Drawing.")<A NAME=MARKER-2-189></A><P>
 As long as you're drawing into an offscreen graphics world or copying the image out of it, you must leave its pixel image locked. When you are finished drawing into and copying from an offscreen graphics world, use the <CODE>UnlockPixels</CODE> procedure. To help prevent heap fragmentation, the <CODE>UnlockPixels</CODE> procedure allows the Memory Manager to move the base address for the offscreen pixel image. (For more information about Macintosh memory management, see <I><A HREF="../Memory/Memory-2.html">Inside Macintosh: Memory</A></I>.)<P>
 Finally, call the <CODE>DisposeGWorld</CODE> procedure when your application no longer needs the pixel image associated with this offscreen graphics world, as illustrated in <A HREF=#MARKER-9-27>Listing 6-1</A>.<P>
<A NAME=HEADING304-46></A>
<H2>Updating an Offscreen Graphics World</H2>
 <A NAME=MARKER-2-175></A>When the user resizes or moves a window, changes the pixel depth of a screen that a window intersects, or modifies a color table, you can use the <CODE>UpdateGWorld</CODE> function to reflect the user's choices in the offscreen graphics world. The <CODE>UpdateGWorld</CODE> function, described on <A HREF=QuickDraw-314.html#MARKER-9-136>page 6-23</A>, allows you to change the pixel depth, boundary rectangle, or color table for an existing offscreen graphics world without recreating it and redrawing its contents. You should also call <CODE>UpdateGWorld</CODE> after every update event.<P>
 Calling <CODE>UpdateGWorld</CODE> and then <CODE>CopyBits</CODE> when the user makes these changes helps your application get the maximum refresh speed when updating the window. See the chapters "Event Manager" and "Window Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for more information about handling update events in windows and about resizing windows. <A NAME=MARKER-2-387></A><P>
<A NAME=HEADING304-49></A>
<H2>Creating a Mask and a Source Image in Offscreen Graphics Worlds</H2>
 <A NAME=MARKER-2-251></A><A NAME=MARKER-2-182></A>When you use the <CODE>CopyMask</CODE> or <CODE>CopyDeepMask</CODE> procedure (described in the chapter "QuickDraw Drawing"), you can create the source image and its mask in separate offscreen graphics worlds. Plates 3 and 4 at the front of this book illustrate how to use <CODE>CopyMask</CODE> in this way. The source image in  <A HREF="ColorPlate3.html">Plate 3</A> consists of graduated gray stripes; this image is created in an offscreen graphics world. The mask in  <A HREF="ColorPlate3.html">Plate 3</A> consists of a black rectangle alongside a red rectangle; this mask is created in a separate graphics world that shares the same coordinates as the source image.<P>
 When the <CODE>CopyMask</CODE> procedure copies the grayscale image through this mask, the result is the untitled window illustrated in the bottom half of  <A HREF="ColorPlate3.html">Plate 3</A>. The black pixels in the mask cause <CODE>CopyMask</CODE> to copy directly into the window those pixels from the source image that are masked by the black rectangle. The red pixels in the mask cause <CODE>CopyMask</CODE> to alter most of the source pixels masked by the red rectangle when copying them. That is, the source pixels that are completely black are changed to the mask's red when copied into the window. The source pixels that are completely white are left unaltered when copied into the window. The source pixels that are between black and white are given a graduated amount of the mask's red.<P>
 <A HREF=#MARKER-9-59>Listing 6-2</A> shows the code that produces the window shown in  <A HREF="ColorPlate3.html">Plate 3</A>. <P>
<B>Listing 6-2  <A NAME=MARKER-9-59></A>Using two offscreen graphics worlds and the <CODE>CopyMask</CODE> procedure</B><P>
<PRE>
PROCEDURE MyCopyBlackAndRedMasks (wp: WindowPtr);
   VAR
      origPort:                           GrafPtr;
      origDevice:                         GDHandle;
      myErr:                              QDErr;
      myOffScreen1, myOffScreen2:         GWorldPtr;
      theColor:                           RGBColor;
      i:                                  Integer;
      offPixMapHandle1, offPixMapHandle2: PixMapHandle;
      good:                               Boolean;
      myRect:                             Rect;
BEGIN
   GetGWorld(origPort, origDevice);       {save window's graphics port}
                        {create an offscreen world for building an image}
   myErr := NewGWorld(myOffScreen1, 0, wp^.portRect, NIL, NIL, []);
   IF (myOffScreen1 = NIL) OR (myErr &lt;&gt; noErr) THEN
      ; {handle error here}
                        {create another offscreen world for building a mask}
   myErr := NewGWorld(myOffScreen2, 0, wp^.portRect, NIL, NIL, []);
   IF (myOffScreen2 = NIL) OR (myErr &lt;&gt; noErr) THEN
      ; {handle error here}
   SetGWorld(myOffScreen1, NIL); {make first offscreen world the }
                                 { current port}
   offPixMapHandle1 := GetGWorldPixMap(myOffScreen1);
   good := LockPixels(offPixMapHandle1);  {lock its pixel image}
   IF NOT good THEN
      ; {handle error here}
   EraseRect(myOffScreen1^.portRect);     {initialize its pixel image}
   FOR i := 0 TO 9 DO      {draw graduated grayscale stripes for the image}
      BEGIN
         theColor.red := i * 7168; 
         theColor.green := i * 7168; 
         theColor.blue := i * 7168;
         RGBForeColor(theColor);
         SetRect(myRect, myOffScreen1^.portRect.left, i * 10,
                 myOffScreen1^.portRect.right, i * 10 + 10);
         PaintRect(myRect);
      END;
   SetGWorld(myOffScreen2, NIL); {make second offscreen world the }
                                 { current port}
   offPixMapHandle2 := GetGWorldPixMap(myOffScreen2);
   good := LockPixels(offPixMapHandle2);  {lock its pixel image}
   IF NOT good THEN
      ; {handle error here}
   EraseRect(myOffScreen2^.portRect);     {initialize its pixel image}
   SetRect(myRect, 20, 20, 80, 80);
   PaintRect(myRect);   {paint a black rectangle in the mask}
   SetRect(myRect, 100, 20, 160, 80);
   theColor.red := $FFFF;  theColor.green := $0000; theColor.blue := $0000;
   RGBForeColor(theColor);
   PaintRect(myRect);   {paint a red rectangle in the mask}
   SetGWorld(wp, GetMainDevice); {make window the current port}
   EraseRect(wp^.portRect);      {erase the window before using CopyMask}
   CopyMask(GrafPtr(myOffScreen1)^.portBits, {use gray image as source}
            GrafPtr(myOffScreen2)^.portBits, {use 2-rectangle image as mask}
            GrafPtr(wp)^.portBits,           {use window as destination}
            myOffScreen1^.portRect, 
            myOffScreen2^.portRect, 
            wp^.portRect);
   UnlockPixels(offPixMapHandle1);  UnlockPixels(offPixMapHandle2);
   DisposeGWorld(myOffScreen1);  DisposeGWorld(myOffScreen2);
   SetGWorld(origPort, origDevice);    {restore original graphics port}
END;
</PRE>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-303.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-305.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
