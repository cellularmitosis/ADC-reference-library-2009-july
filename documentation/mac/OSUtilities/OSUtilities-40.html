<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the Mathematical and Logical Utilities (IM: U)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING40></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="OSUtilities-39.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="OSUtilities-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="OSUtilities-222.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="OSUtilities-41.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="OSUtilities-2.html"><B>Operating System Utilities</B></A> / <BR><DD><A HREF="OSUtilities-38.html"><B>Chapter 3 - Mathematical and Logical Utilities</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING40-0></A>
<H1>Using the Mathematical and Logical Utilities</H1>
 This section describes how you can take advantage of the Mathematical and Logical Utilities supported by the Operating System, it describes how you can<P>
<UL>
<LI>test and set individual bits, perform logical operations on long words, divide a long word into its high word and low word, and set memory values directly.
<LI>use the <CODE>PackBits</CODE> and <CODE>UnpackBits</CODE> procedures to compress and decompress data.
<LI>seed the pseudo-random number generator and obtain random integers or long integers within a given range.
<LI>perform simple calculations involving fixed-point numbers and convert fixed-point numbers to other numeric types.<P>
</UL>
<A NAME=HEADING40-6></A>
<H2><A NAME=MARKER-9-55></A>Performing Low-Level Manipulation of Memory</H2>
 The Mathematical and Logical Utilities provide several routines to perform bit-level and byte-level manipulation of memory. These routines are provided primarily for Pascal programmers. C and assembly-language programmers can use these routines also; however, in general it is easier and more efficient to achieve the same effects as these routines by using built-in C or assembly constructs.<P>
<A NAME=HEADING40-8></A>
<H3><A NAME=MARKER-9-56></A>Testing and Manipulating Bits<A NAME=MARKER-9-76></A></H3>
 The <CODE>BitTst</CODE> function lets you test whether a given bit is set. The function requires that you specify a bit through an offset from a pointer. <A HREF=#MARKER-9-58>Listing 3-1</A> is an example of an application-defined function that tests a specified bit.<P>
<B>Listing 3-1  <A NAME=MARKER-9-58></A>Testing bits</B><P>
<PRE>
FUNCTION MyTestBit (bytePtr: Ptr; bitNum: LongInt): Boolean;
BEGIN
   MyTestBit := BitTst(bytePtr, bitNum);
END;
</PRE>
 The <CODE>bytePtr</CODE> parameter specifies a pointer to a byte in memory. The <CODE>bitNum</CODE> parameter specifies the number of the bit to be tested as an offset from <CODE>bytePtr</CODE>. For example, you can use the application-defined function <CODE>MyTestBit</CODE> to test specific bits of the word specified in <A HREF=#MARKER-9-59>Figure 3-8</A>.<P>
<B>Figure 3-8  <A NAME=MARKER-9-59></A>A sample word (in MC680x0 notation)</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MLU-L-08.jpg"><P>
 Using the word in <A HREF=#MARKER-9-59>Figure 3-8</A>, the call <CODE>BitTst(myPtr, 0)</CODE> returns <CODE>FALSE</CODE> because bit number 0 in the first byte is not set. But the call <CODE>BitTst(myPtr, 11)</CODE> returns <CODE>TRUE</CODE> because bit number 3 in the second byte is set. <P>
 When using the <CODE>BitTst</CODE> function, be sure to specify bits as positive offsets from the high-order bit rather than using the normal MC680x0 notation (see <A HREF=OSUtilities-39.html#MARKER-9-17>"Reversed Bit-Numbering" on page 3-7</A>). <A HREF=#MARKER-9-60>Listing 3-2</A> illustrates a use of the <CODE>BitTst</CODE> function in conjunction with a bit traditionally identified with MC680x0 notation.<P>
<B>Listing 3-2  <A NAME=MARKER-9-60></A>Determining whether a handle is purgeable using the <CODE>BitTst</CODE> function</B><P>
<PRE>
FUNCTION MyHandleIsPurgeable (myHandle: Handle): Boolean;
CONST
   kMyBitNum68000 = 6;
VAR
   propertiesByte: SignedByte;
BEGIN
   propertiesByte := HGetState(myHandle);
   MyHandleIsPurgeable := BitTst(@propertiesByte,
                                 7 - kMyBitNum68000);
END;
</PRE>
 The <CODE>MyHandleIsPurgeable</CODE> function defined in <A HREF=#MARKER-9-60>Listing 3-2</A> determines whether a handle references a relocatable block by examining the properties byte for that handle. The purgeable bit is, in MC680x0 notation, bit number 6 of the properties byte; because <CODE>BitTst</CODE> uses reverse numbering, so bit number 7 - 6 = 1 is tested.<P>
 <A NAME=MARKER-2-131></A>The <CODE>BitSet</CODE> and <CODE>BitClr</CODE> procedures require that you specify bits using the same scheme as with the <CODE>BitTst</CODE> procedure (see <A HREF=OSUtilities-39.html#MARKER-9-17>"Reversed Bit-Numbering" on page 3-7</A>). The <CODE>BitSet</CODE> procedure sets a bit (that is, sets its value to 1), while <CODE>BitClr</CODE> clears a bit (that is, sets its value to 0). For example, if you issue the following two calls to the <CODE>BitSet</CODE> procedure<P>
<PRE>
BitSet(bytePtr, 5);
BitClr(bytePtr, 7);
</PRE>
 bit 5 (using the reversed bit-numbering scheme) of the byte in memory pointed to by the <CODE>bytePtr</CODE> parameter is set to 1, and bit 7 (using reversed bit-numbering) of the same byte is cleared.<P>
<DL>
<DT><B>Note</B>
<DD>In C, you can test bits by using the <CODE>&amp;</CODE> operator. You can set and clear bits by using the <CODE>|=</CODE> and <CODE>&amp;=</CODE> operators, respectively. In all three cases, one operand should be the byte (or word or long word you wish to manipulate), and the other should be a value in which only the relevant bit is set or cleared. Many Pascal compilers also support built-in operations that accomplish these tasks efficiently. Note that C uses the MC680x0 bit-numbering scheme (normal bit-numbering).<EM></EM><A NAME=MARKER-9-67></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING40-24></A>
<H3><A NAME=MARKER-2-63></A><A NAME=MARKER-9-64></A><A NAME=MARKER-2-78></A>Performing Logical Operations on Long Words<A NAME=MARKER-2-92></A></H3>
 <A NAME=MARKER-2-116></A>The Macintosh Operating System provides routines that allow you to perform basic bitwise logical operations, including the <CODE>AND</CODE>, <CODE>OR</CODE>, and <CODE>XOR</CODE> operations on long words. Each of the functions takes two long integers as parameters and returns another long integer. You can use these functions on other 32-bit data types, as long as you cast values to <CODE>LongInt</CODE> as required by your compiler. The functions that perform the <CODE>AND</CODE>, <CODE>OR</CODE>, and <CODE>XOR</CODE> operations are <CODE>BitAnd</CODE>, <CODE>BitOr</CODE>, and <CODE>BitXor</CODE> respectively. <A HREF=#MARKER-9-69>Figure 3-9</A> illustrates these functions.<P>
<B>Figure 3-9  <A NAME=MARKER-2-68></A><A NAME=MARKER-9-69></A>The <CODE>BitAnd</CODE>, <CODE>BitOr</CODE>, and <CODE>BitXor</CODE> functions</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MLU-L-09.jpg"><P>
 As shown in <A HREF=#MARKER-9-69>Figure 3-9</A>, the <CODE>BitAnd</CODE> function returns a long word in which each bit is set if and only if the corresponding bit is set in both long words passed in. The <CODE>BitOr</CODE> function returns a long word in which each bit is set if and only if the corresponding bit is set in either long word passed in. The <CODE>BitXor</CODE> function returns a long word in which each bit is set if and only if one but not both of the corresponding bits in the long words passed in is set.<P>
<DL>
<DT><B>Note</B>
<DD>In C, you can achieve the same effects as the <CODE>BitAnd</CODE>, <CODE>BitOr</CODE>, and <CODE>BitXor</CODE> functions by using the <CODE>&amp;</CODE>, <CODE>|</CODE>, and <CODE>^</CODE> operators, respectively, in conjunction with the <CODE>=</CODE> assignment operator. Many Pascal compilers also support built-in operations that accomplish these tasks more efficiently.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 A common use of the <CODE>BitAnd</CODE> function is to mask out certain bytes within a long word (that is, clear all bits in those bytes). For example, to mask out the second byte of a long word stored in a variable <CODE>value</CODE>, you could write the following code:<P>
<PRE>
value := BitAnd(value, $FF00FFFF);
</PRE>
 <A NAME=MARKER-2-70></A><A NAME=MARKER-2-26></A><A NAME=MARKER-2-72></A>The Macintosh Operating System also offers two bit-manipulation routines that simulate unary operators, the <CODE>BitNot</CODE> and the <CODE>BitShift</CODE> functions, which perform the <CODE>NOT</CODE> operation and bit-shifting, respectively. You specify the long integer on which to perform the operation as a parameter to the <CODE>BitNot</CODE> and <CODE>BitShift</CODE> functions. In addition, you specify how to shift the bits as a parameter to the <CODE>BitShift</CODE> function.<A NAME=MARKER-2-2></A><P>
 <A HREF=OSUtilities-131.html#MARKER-9-29>Figure 3-10</A> illustrates <CODE>BitNot</CODE> and <CODE>BitShift</CODE>.<P>
<B>Figure 3-10  <A NAME=MARKER-9-29></A>The <CODE>BitNot</CODE> and <CODE>BitShift</CODE> functions</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MLU-L-10.jpg"><P>
 As shown in <A HREF=OSUtilities-131.html#MARKER-9-29>Figure 3-10</A>, the <CODE>BitNot</CODE> function returns a long word in which each bit is set if and only if the corresponding bit in the long word passed in is not set. The <CODE>BitShift</CODE> function shifts bits--to the left if the <CODE>count</CODE> parameter is greater than 0 and to the right if the <CODE>count</CODE> parameter is less than 0. (Shifting to the left means shifting towards the high-order bit.) When shifting <CODE>count</CODE> bits to the left, the <CODE>count</CODE> low-order bits are set to 0; when shifting <CODE>count</CODE> bits to the right, the <CODE>count</CODE> high-order bits are set to 0.<P>
<DL>
<DT><B>Note</B>
<DD>In C, you can achieve the same effect as the <CODE>BitNot</CODE> function more efficiently by using the <CODE>^</CODE> operator on the value whose bits are to be inverted and the value $FFFFFFFF. You can achieve the same effect as the <CODE>BitShift</CODE> function more efficiently by using the <CODE>&gt;&gt;</CODE> operator for shifting to the right and the <CODE>&lt;&lt;</CODE> operator for shifting to the left. Many Pascal compilers support built-in operations that accomplish these tasks efficiently.<EM></EM><A NAME=MARKER-2-1></A><A NAME=MARKER-2-140></A><A NAME=MARKER-2-67></A><A NAME=MARKER-2-79></A><A NAME=MARKER-2-80></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING40-38></A>
<H3><A NAME=MARKER-9-81></A>Extracting a Word From a Long Word</H3>
 Often a long word stored as a variable of type <CODE>LongInt</CODE> is used to hold two different pieces of information in its two different words. For example, when a disk-inserted event occurs, the <CODE>message</CODE> field of the event record contains the drive number in the low-order word and a result code in the high-order word. To access these two types of information, you can use the <CODE>HiWord</CODE> and <CODE>LoWord</CODE> functions. For example:<P>
<PRE>
VAR
   x: LongInt;
   high, low: Integer;
   high := HiWord(x);
   low := LoWord(x);
</PRE>
 The <CODE>HiWord</CODE> function returns the high-order word of the long word passed in, and the <CODE>LoWord</CODE> function returns the low-order word of the long word passed in. You can use these functions with types other than <CODE>LongInt</CODE> and <CODE>Integer</CODE>, as long as they are 4 bytes and 2 bytes, respectively, and, if you are using Pascal, you cast the quantities to the correct types.<A NAME=MARKER-2-80></A><P>
 The Operating System does not provide any routines that allow you to set the high-order or low-order words of a long integer. It might seem that you could set the low-order word by calling the <CODE>BitAnd</CODE> function with the original long integer and the low-order word as parameters, and set the high-order word by calling <CODE>BitAnd</CODE> with the original long integer and the high-order word shifted left 16 bytes as parameters. The problem with this approach is that when you pass an integer variable to <CODE>BitAnd</CODE>, the compiler automatically casts the variable to a long integer. But for both integers and long integers, it is the leftmost byte that indicates the sign of the number. So when a negative integer is cast to a long integer, the low-order word of the long integer is not equal to the original integer.<P>
 However, you can use the Memory Manager's <CODE>BlockMove</CODE> procedure to directly copy the bytes of a word to the high-order or low-order word of a long word. See <I><A HREF="../Memory/Memory-2.html">Inside Macintosh: Memory</A></I> for more information. Or, if you wish to set both the high-order word and the low-order word of a long integer at once, you can define the following type:<A NAME=MARKER-0-7></A><P>
<PRE>
TYPE MyLongWordType = 
PACKED RECORD
   myHiWord:      Integer;       {high-order word}
   myLoWord:      Integer;       {low-order word}
END;
</PRE>
 Then you can define a variable of this type and set the high-word and low-word fields. By casting a long integer to <CODE>MyLongWordType</CODE>, you could also extract a word from a long word more efficiently than you can using the <CODE>HiWord</CODE> and <CODE>LoWord</CODE> functions.<A NAME=MARKER-2-62></A><P>
<A NAME=HEADING40-46></A>
<H3><A NAME=MARKER-9-85></A>Hardcoding Byte Values<A NAME=MARKER-2-86></A><A NAME=MARKER-2-52></A></H3>
 Occasionally, you might need to set a group of bytes in memory to specific hexadecimal values. For example, suppose your application uses a data structure with a 16-byte flags field and you wish to initialize each of the bytes in the flags field to particular values. While there are a number of ways that you might do this, the <CODE>StuffHex</CODE> procedure provides a simple, though usually inefficient, option. <P>
 You provide a pointer to any data structure in memory, and a string of hexadecimal digits as parameters to the <CODE>StuffHex</CODE> procedure. For example:<P>
<PRE>
StuffHex(@x, 'D34E0F29');
</PRE>
 Of course, it would in this case be just as easy--and more efficient--to write the following code:<P>
<PRE>
x := $D34E0F29;
</PRE>
 The <CODE>StuffHex</CODE> procedure is perhaps most useful when you wish to assign a large or odd number of bytes or set the values of particular bytes within a variable. For example, to set the low-order word of a long integer <CODE>x</CODE> to $64B5, you could use the following code:<P>
<PRE>
StuffHex(Ptr(ORD4(@x) + 2), '64B5');
</PRE>
 You could use this code rather than use the techniques described in the previous section, <A HREF=#MARKER-9-81>"Extracting a Word From a Long Word."</A><P>
 Note that <CODE>Ptr</CODE> and <CODE>ORD4</CODE> are used here simply to satisfy Pascal type-casting rules.<P>
 The <CODE>StuffHex</CODE> procedure might also be useful if you are developing a calculator or other application that allows users to enter hexadecimal values directly.<A NAME=MARKER-9-100></A><A NAME=MARKER-2-89></A><P>
<A NAME=HEADING40-57></A>
<H2><A NAME=MARKER-9-90></A><A NAME=MARKER-9-91></A>Compressing Data<A NAME=MARKER-9-97></A></H2>
 <A NAME=MARKER-2-93></A>The <CODE>PackBits</CODE> and <CODE>UnpackBits</CODE> procedures, introduced in <A HREF=OSUtilities-39.html#MARKER-9-22>"Data Compression" on page 3-8</A>, allow you to compress (or decompress) data stored in RAM. Typically, you use <CODE>PackBits</CODE> before writing data to disk and <CODE>UnpackBits</CODE> immediately after writing data from disk.<P>
 Both procedures require that you pass in the <CODE>srcPtr</CODE> and <CODE>dstPtr</CODE> parameters values that point to the beginning of the source buffer and the destination buffer, respectively. The <CODE>PackBits</CODE> procedure compresses the data in the source buffer and stores the result in the destination buffer; the <CODE>UnpackBits</CODE> procedure decompresses the data in the source buffer and stores the result in the destination buffer. You must also pass to the <CODE>PackBits</CODE> procedure and the <CODE>UnpackBits</CODE> procedure a value that specifies the size of the original, uncompressed data. Because you must pass this information to <CODE>UnpackBits</CODE>, you typically use these procedures only to compress a data structure with a fixed size, so that this size can be passed as a parameter to <CODE>PackBits</CODE>.<P>
 Your application is responsible for allocating memory for both the source and the destination buffers. When <CODE>PackBits</CODE> and <CODE>UnpackBits</CODE> complete operation, the <CODE>srcPtr</CODE> and <CODE>dstPtr</CODE> parameter are incremented so that <CODE>srcPtr</CODE> points to the memory immediately following the source bytes, and <CODE>dstPtr</CODE> points to the data immediately following the destination bytes. This feature was originally designed to allow you to pack large buffers of data at once in chunks, although <CODE>PackBits</CODE> can automatically chunk large data buffers in versions of system software 6.0.2 and later. In any case, your application must store copies of <CODE>srcPtr</CODE> and <CODE>dstPtr</CODE> to access the start of the source or destination buffer after calling <CODE>PackBits</CODE> or <CODE>UnpackBits</CODE>.<P>
 One use of the compression routines might be to compress resources in your application's resource fork. Many types of resources can be made significantly smaller by compression. <A HREF=#MARKER-9-95>Listing 3-3</A> shows how you can pack data stored in a handle to a specified resource.<A NAME=MARKER-2-63></A><P>
<B>Listing 3-3  <A NAME=MARKER-9-95></A>Packing data to a resource</B><P>
<PRE>
PROCEDURE MyAddPackedResource (srcData: Handle; theType: ResType; 
                               theID: Integer; name: Str255);
VAR
   srcBytes:         Integer;                {bytes of unpacked data}
   maxDstBytes:      LongInt;                {maximum length of packed data}
   dstData:          Handle;                 {packed data}
   srcPtr:           Ptr;                    {pointer to unpacked data}
   dstPtr:           Ptr;                    {pointer to packed data}
   srcProperties:    SignedByte;             {properties of source handle}
BEGIN
   srcBytes := GetHandleSize(srcData);       {find size of source}
                                             {calculate maximum possible }
                                             { size of packed data}
   maxDstBytes := srcBytes + (srcBytes + 126) DIV 127;
   dstData := NewHandle(maxDstBytes + 2);    {allocate memory for source, }
                                             { plus length info}
   IF dstData &lt;&gt; NIL THEN                    {check for NIL handle}
   BEGIN
      BlockMove(@srcBytes, dstData^, 2);     {copy source into buffer}
      srcPtr := srcData^;                    {copy source pointer}
      dstPtr := Ptr(ORD4(dstData^) + 2);     {copy destination pointer}
      PackBits(srcPtr, dstPtr, srcBytes);    {pack source to destination}
                                             {shrink destination data}
      SetHandleSize(dstData, ORD4(dstPtr) - ORD4(dstData^));
      srcProperties := HGetState(srcData);   {get source handle properties}
      IF BitTst(@srcProperties, 2) THEN      {is source a real resource?}
         RemoveResource(srcData);            {remove current resource}
                                             {add to resource file}
      AddResource(dstData, theType, theID, name);
      WriteResource(dstData);                {write resource data}
      DetachResource(dstData);               {detach from resource map}
      DisposeHandle(dstData);                {dispose of destination data}
   END;
END;
</PRE>
 The <CODE>MyAddPackedResource</CODE> procedure declared in <A HREF=#MARKER-9-95>Listing 3-3</A> initially allocates a destination buffer to hold compressed data that is big enough to hold the compressed data in a worst-case scenario, plus 2 bytes to store information at the beginning of the resource about the size of the source data. Because <CODE>PackBits</CODE> does not move memory, the handle storing the destination buffer does not need to be locked. However, to prevent the <CODE>PackBits</CODE> procedure from changing the value of a master pointer, you should only pass copies of the dereferenced handle to the procedure. After <CODE>PackBits</CODE> returns, <CODE>MyAddPackedResource</CODE> determines how much memory the compressed data takes up by computing how much the <CODE>dstPtr</CODE> variable has changed. <CODE>MyAddPackedResource</CODE> then resizes the handle containing the compressed data to the appropriate size. Finally, <CODE>MyAddPackedResource</CODE> writes the new resource, after first removing the existing resource if the source handle is a handle to a resource. For more information on resources, see <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I>.<A NAME=MARKER-2-64></A><P>
 Having used the <CODE>MyAddPackedResource</CODE> procedure to compress resource data, your application needs to be able read the resource and decompress it using the <CODE>UnpackBits</CODE> procedure. <A HREF=#MARKER-9-98>Listing 3-4</A> shows how you might accomplish this.<A NAME=MARKER-2-97></A><P>
<B>Listing 3-4  <A NAME=MARKER-9-98></A>Decompressing data from a packed resource</B><P>
<PRE>
FUNCTION MyGetPackedResource (theType: ResType; theID: Integer): Handle;
VAR
   srcData:          Handle;                    {handle to packed data}
   dstData:          Handle;                    {handle to unpacked data}
   srcPtr:           Ptr;                       {pointer to packed data}
   dstPtr:           Ptr;                       {pointer to unpacked data}
   dstBytes:         Integer;                   {number of unpacked bytes}
BEGIN
   srcData := GetResource(theType, theID);      {get the resource}
   BlockMove(srcData^, @dstBytes, 2);           {read number of bytes of }
                                                { unpacked data}
   dstData := NewHandle(dstBytes);              {allocate memory for }
                                                { unpacked data}
   IF dstData &lt;&gt; NIL THEN
   BEGIN
      srcPtr := Ptr(ORD4(srcData^) + 2);        {copy source pointer}
      dstPtr := dstData^;                       {copy destination pointer}
      UnpackBits(srcPtr, dstPtr, dstBytes);     {unpack source to }
                                                { destination}
   END;
   IF srcData &lt;&gt; NIL THEN                       {if there was a resource}
   BEGIN
      DetachResource(srcData);                  {detach from resource map}
      DisposeHandle(srcData);                   {dispose the resource}
   END;
   MyGetPackedResource := dstData;              {return destination handle}
END;
</PRE>
 The <CODE>MyGetPackedResource</CODE> function reads in a resource that has previously been packed, determines the size of the unpacked data by copying the first 2 bytes of the resource data, and allocates a relocatable block of this size. The remainder of the data is unpacked using the <CODE>UnpackBits</CODE> procedure, and the original packed resource data is disposed of.<A NAME=MARKER-9-59></A><A NAME=MARKER-9-100></A><A NAME=MARKER-2-41></A><P>
<A NAME=HEADING40-69></A>
<H2><A NAME=MARKER-2-102></A><A NAME=MARKER-9-103></A><A NAME=MARKER-2-104></A>Obtaining Pseudorandom Numbers</H2>
 The <CODE>Random</CODE> function makes it easy to obtain pseudorandom numbers. Before you use <CODE>Random</CODE>, however, you should seed the pseudo-random number generator. <A HREF=#MARKER-9-105>Listing 3-5</A> shows a common technique for doing this.<P>
<B>Listing 3-5  <A NAME=MARKER-9-105></A>Seeding the pseudo-random number generator</B><P>
<PRE>
PROCEDURE MySeedGenerator;
BEGIN
   GetDateTime(randSeed);
END;
</PRE>
 The <CODE>MySeedGenerator</CODE> procedure defined in <A HREF=#MARKER-9-105>Listing 3-5</A> simply uses the Date and Time Utilities' <CODE>GetDateTime</CODE> procedure to copy the number of seconds since midnight, January 1, 1904, to the global variable <CODE>randSeed</CODE>. You might use some other volatile long-word value--such as the mouse location--to seed the pseudo-random number generator, or you might even take a word from one source and a word from another. However, just using <CODE>GetDateTime</CODE> is sufficient for most applications.<P>
 Sometimes you wish to obtain a pseudo-random integer from a large range of integers; for example, you might need a pseudo-random integer in the range of -20,000 to 20,000. <A HREF=#MARKER-9-106>Listing 3-6</A> shows how you might do this.<P>
<B>Listing 3-6  <BR>
<A NAME=MARKER-9-106></A>A simple way of obtaining a large random integer from a range<BR>of pseudo-random numbers</B><P>
<PRE>
FUNCTION MyRandomLargeRange (min, max: Integer): Integer;
VAR
   randInt:       Integer;
BEGIN
   REPEAT
      randInt := Random
   UNTIL (randInt &gt;= min) AND (randInt &lt;= max);
   MyRandomLargeRange := randInt;
END;
</PRE>
 The MyRandomLargeRange function defined in <A HREF=#MARKER-9-106>Listing 3-6</A> simply calls the <CODE>Random</CODE> function until it returns an acceptable value. This approach is efficient when you need a random integer from a range of integers that is wide, though not quite as wide as the range the <CODE>Random</CODE> function returns by default. However, if you need a random number from a small range--for example, a random number from 1 to 10--the MyRandomLargeRange function is inefficient. <A HREF=#MARKER-9-108>Listing 3-7</A> shows an alternative approach.<P>
<B>Listing 3-7  <A NAME=MARKER-2-107></A><A NAME=MARKER-9-108></A>Obtaining a pseudo random integer from a small range of numbers</B><P>
<PRE>
FUNCTION MyRandomRange (min, max: Integer): Integer;
CONST
   kMinRand = -32767.0;
   kMaxRand = 32767.0;
VAR
   myRand:     Integer;
   x:          Real;          {Random scaled to [0..1]}
BEGIN
   {find random number, and scale it to [0.0..1.0]}
   x := (Random - kMinRand) / (kMaxRand + 1.0 - kMinRand);
   {scale x to [min, max + 1.0], truncate, and return result}
   MyRandomRange := TRUNC(x * (max + 1.0 - min) + min);
END;
</PRE>
 The <CODE>MyRandomRange</CODE> function defined in <A HREF=#MARKER-9-108>Listing 3-7</A> first scales the integral value returned by the <CODE>Random</CODE> function to a floating-point value from 0 up to, but not including, 1. The function then scales the result to a real number greater than or equal to <CODE>min</CODE> but less than <CODE>max + 1</CODE>. By truncating extra decimal places, the correct result is achieved. Note that to force the compiler to perform floating-point calculations, all constants in the function are expressed as real numbers rather than as integers.<P>
 Sometimes an application might require a pseudo-random long integer. <A HREF=#MARKER-9-109>Listing 3-8</A> shows how you can do this.<P>
<B>Listing 3-8  <A NAME=MARKER-9-109></A>Obtaining a pseudo-random long integer</B><P>
<PRE>
FUNCTION MyRandomLongInt: LongInt;
TYPE
   MyLongWordType = PACKED RECORD
      myHiWord:   Integer;             {high-order word}
      myLoWord:   Integer;             {low-order word}
   END;
VAR
   myLongWord:    MyLongWordType;      {random long word}
BEGIN
   {obtain random high-order word}
   myLongWord.myHiWord := Random;
   {obtain random low-order word}
   myLongWord.myLoWord := Random;
   {cast and return result}
   MyRandomLongInt := LongInt(myLongWord);
END;
</PRE>
 The <CODE>MyRandomLongInt</CODE> function defined in <A HREF=#MARKER-9-109>Listing 3-8</A> uses a technique discussed in <A HREF=#MARKER-9-81>"Extracting a Word From a Long Word" on page 3-18</A> to stuff a pseudo-random number in the high-order word of a long integer and another pseudo-random number in the low-order word of the long integer. If you need to obtain a long integer within a specified range, you can define routines analogous to <A HREF=#MARKER-9-106>Listing 3-6</A> and <A HREF=#MARKER-9-108>Listing 3-7</A> but use the <CODE>MyRandomLongInt</CODE> function in place of the <CODE>Random</CODE> function.<A NAME=MARKER-2-110></A><A NAME=MARKER-2-19></A><P>
<A NAME=HEADING40-85></A>
<H2><A NAME=MARKER-9-112></A>Using Fixed-Point Data Types<A NAME=MARKER-2-113></A></H2>
 Most high-level language compilers include built-in support for the <CODE>Fixed</CODE> and <CODE>Fract</CODE> data types so that you can perform regular mathematical operations with fixed-point variables. Also, the algorithms for performing addition and subtraction on <CODE>Fixed</CODE> and <CODE>Fract</CODE> variables are the same as the algorithms for performing such operations on variables of type <CODE>LongInt</CODE>. <P>
 The Operating System, however, includes several routines that allow you to convert <CODE>Fixed</CODE> and <CODE>Fract</CODE> variables to other formats, including SANE's <CODE>Extended</CODE> data type, and allow you to perform some simple operations on <CODE>Fixed</CODE> and <CODE>Fract</CODE> variables. If you need more sophisticated numeric functions, consult the <I>Apple Numerics Manual</I>.<P>
 To perform multiplication and division of fixed-point numbers, you can use the <CODE>FixMul</CODE>, <CODE>FixDiv</CODE>, <CODE>FracMul</CODE>, and <CODE>FracDiv</CODE> functions, which allow you to multiply <CODE>Fixed</CODE> point numbers with each other or with other long integers.<P>
 You can multiply and divide 32-bit quantities of different types using these functions. The format of the result in this case depends on the particular function being used. See descriptions of the individual functions in <A HREF=OSUtilities-67.html#MARKER-9-185>"Multiplying and Dividing Fixed-Point Numbers" beginning on page 3-38</A> for more information.<P>
 Using the <CODE>FracSqrt</CODE>, <CODE>FracCos</CODE>, <CODE>FracSin</CODE>, and <CODE>FixATan2</CODE> functions, you can perform a few special arithmetic operations involving variables of type <CODE>Fixed</CODE> and <CODE>Fract</CODE>. <P>
 The <CODE>FracSqrt</CODE> function allows you to obtain the square root of a variable of type <CODE>Fract</CODE>, interpreting bit 0 as having weight 2 rather than -2. The <CODE>FracCos</CODE> and <CODE>FracSin</CODE> provide support for the trigonometric cosine and sine functions. The <CODE>FixATan2</CODE> function provides support for the arctangent function. The arguments to all of these functions should be expressed in radians, not in degrees. <P>
<DL>
<DT><B>Note</B>
<DD>To provide fast trigonometric approximations, these trigonometric functions use values of Pi correct only to 4 decimal places. You should thus use alternative SANE routines when you require better precision. <EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To convert among 32-bit numeric types, you can use the <CODE>Long2Fix</CODE>, <CODE>Fix2Long</CODE>, <CODE>Fix2Frac</CODE>, and <CODE>Frac2Fix</CODE> functions.<P>
 Each of the functions returns its parameter converted into the appropriate format.<P>
 You can also convert fixed-point values to and from the SANE <CODE>Extended</CODE> floating-point type using the <CODE>Fix2X</CODE>, <CODE>X2Fix</CODE>, <CODE>Frac2X</CODE>, and <CODE>X2Frac</CODE> functions.<P>
 Two additional functions, <CODE>FixRatio</CODE> and <CODE>FixRound</CODE>, allow you to perform special conversions on variables of type <CODE>Fixed</CODE>.<A NAME=MARKER-2-195></A><A NAME=MARKER-8-101></A><P>
 The <CODE>FixRatio</CODE> function returns the fixed-point quotient of the <CODE>numer</CODE> and <CODE>denom</CODE> parameters. The <CODE>FixRound</CODE> function rounds a variable of type <CODE>Fixed</CODE> to the nearest integer. If the value is halfway between two integers (0.5), it is rounded to the integer with the higher absolute value. To round a negative fixed-point number, negate it, round it, and then negate it again.<P>
<DL>
<DT><B>Note</B>
<DD>To convert a variable of type <CODE>Fixed</CODE> to a variable of type <CODE>Integer</CODE> simply use the <CODE>HiWord</CODE> function to extract the integral component of the fixed-point number.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The Operating System also provides the <CODE>LongMul</CODE> procedure that allows you to multiple two 32-bit quantities and obtain a 64-bit quantity.<P>
 <A HREF=#MARKER-9-117>Table 3-2</A> summaries the routines that perform operations on the <CODE>Fixed</CODE> and <CODE>Fract</CODE> data types.<A NAME=MARKER-2-116></A><P>
 <A NAME=MARKER-9-117></A><B>Table 3-2 Routines for fixed-point data types</B>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Routine<TH>Description<TR>
<TD>FixMul<TD>Multiply a variable of type <CODE>Fixed</CODE> with another variable of type <CODE>Fixed</CODE> or with a variable of type <CODE>Fract</CODE> or <CODE>LongInt</CODE><TR>
<TD>FixDiv<TD>Divide two variables of the same type (<CODE>Fixed</CODE>, <CODE>Fract</CODE>, or <CODE>LongInt</CODE>) or divide a <CODE>LongInt</CODE> or <CODE>Fract</CODE> number by a <CODE>Fixed</CODE> number<TR>
<TD>FracMul<TD>Multiply a variable of type <CODE>Fract</CODE> with another variable of type <CODE>Fract</CODE> or with a variable of type <CODE>Fixed</CODE> or <CODE>LongInt</CODE><TR>
<TD>FracDiv<TD>Divide two variables of the same type (<CODE>Fixed</CODE>, <CODE>Fract</CODE>, or <CODE>LongInt</CODE>) or divide a <CODE>LongInt</CODE> or <CODE>Fixed</CODE> number by a <CODE>Fract</CODE> number<TR>
<TD>FracSqrt<TD>Compute the square root of a variable of type <CODE>Fract</CODE><TR>
<TD>FracCos<TD>Obtain the cosine of a variable of type <CODE>Fixed</CODE><TR>
<TD>FracSin<TD>Obtain the sine of a variable of type <CODE>Fixed</CODE><TR>
<TD>FixATan2<TD>Obtain the arctangent of a variable of type <CODE>Fixed, Fract</CODE>, or <CODE>LongInt</CODE><TR>
<TD>Long2Fix<TD>Convert a variable of type <CODE>LongInt</CODE> to <CODE>Fixed</CODE><TR>
<TD>Fix2Long<TD>Convert a variable of type <CODE>Fixed</CODE> to <CODE>LongInt</CODE><TR>
<TD>Fix2Frac<TD>Convert a variable of type <CODE>Fixed</CODE> to <CODE>Fract</CODE><TR>
<TD>Frac2Fix<TD>Convert a variable of type <CODE>Fract</CODE> to <CODE>Fixed</CODE><TR>
<TD>Fix2X<TD>Convert a variable of type <CODE>Fixed</CODE> to <CODE>Extended</CODE><TR>
<TD>X2Fix<TD>Convert a variable of type <CODE>Extended</CODE> to <CODE>Fixed</CODE><TR>
<TD>Frac2X<TD>Convert a variable of type <CODE>Fract</CODE> to <CODE>Extended</CODE><TR>
<TD>X2Frac<TD>Convert a variable of type <CODE>Extended</CODE> to <CODE>Fract</CODE><TR>
<TD>FixRatio<TD>Obtain the <CODE>Fixed</CODE> equivalent of a fraction<TR>
<TD>FixRound<TD>Round a fixed-point number to the nearest integer<TR>
<TD>LongMul<TD>Multiply two 32-bit quantities and obtain a 64-bit quantity</TABLE>
</B><P>
 <A NAME=MARKER-2-118></A><A NAME=MARKER-2-119></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="OSUtilities-39.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="OSUtilities-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="OSUtilities-222.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="OSUtilities-41.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="OSUtilities-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
