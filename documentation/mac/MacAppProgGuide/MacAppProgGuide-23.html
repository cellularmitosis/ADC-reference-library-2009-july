<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Multiple Inheritance (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING23></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-22.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-24.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-21.html"><B>Part 1 - MacApp Theory and Architecture</B></A><BR><DD><A HREF="MacAppProgGuide-22.html"><B>Chapter 2 - Basic Operations</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING23-0></A>
<H1>Multiple Inheritance</H1>
 <B>Multiple inheritance</B> refers to the ability of a class to inherit behavior (fields and methods) from more than one parent class. A class that is added to the class hierarchy of another class through multiple inheritance is called a <I>mixin class</I>. Because MacApp is written in C++, it allows multiple inheritance. Several of MacApp's key classes use mixin classes in their definitions.<P>
 To help support multiple inheritance, MacApp<P>
<UL>
<LI>defines macros and functions for creating objects dynamically by signature, class ID, or class name
<LI>defines macros for efficient stripping of unused classes to create smaller applications
<LI>defines a macro for dynamic casting that works correctly with multiple inheritance
<LI>defines virtual destructor methods to support correct freeing when an object is deleted<P>
</UL>
 To take full advantage of MacApp's support for multiple inheritance, your classes must use MacApp's RTTI macros and define virtual destructor methods. MacApp itself uses the mixin classes <CODE>MScriptableObject</CODE> and <CODE>MDefaultScriptableObject</CODE> to help make other classes scriptable, and it uses the <CODE>MMailable</CODE> and <CODE>MMailing</CODE> classes to provide PowerTalk mailer support.<P>
<DL>
<DT><B>Note</B>
<DD>Multiple inheritance should be used carefully. Suppose you define a class, <CODE>T<I>YourShape</I></CODE>, that does <I>not</I> have its own <CODE>Draw</CODE> method, but that mixes in two classes, <CODE>TPrimitiveShape</CODE> and <CODE>TSimpleShape</CODE>, both of which <I>do</I> have a <CODE>Draw</CODE> method. If your class calls the <CODE>Draw</CODE> method, the compiler will complain about the ambiguous use of the <CODE>Draw</CODE> method.  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
<DD>Problems like this tend to occur in large projects, where many programmers contribute to the code base. Design reviews can be an effective countermeasure.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING23-10></A>
<H2><A NAME=MARKER-9-21></A><A NAME=MARKER-2-22></A>Runtime Type Information</H2>
 <B><A NAME=MARKER-2-23></A>Runtime type information (RTTI)</B> refers to runtime information, or metadata, about the class types and inheritance relationships of application objects. In MacApp, RTTI is based on macros--MacApp uses the macros in its class definitions, and you use them in any classes you define that need RTTI.<P>
 The main reasons you might use RTTI information are to<P>
<UL>
<LI>test whether an object is a member of a class for safe casting
<LI>use <CODE>Inherited</CODE> to call a parent-class version of a method (illustrated in <A HREF=MacAppProgGuide-42.html#MARKER-9-103>Figure 5-5 on page 111</A>)
<LI>create new objects by class name, ID, or signature<P>
</UL>
 MacApp's RTTI macros add overhead to an application. If you don't need to do any of these things with a class, you don't need to set up RTTI for the class.<P>
 The following sections describe how MacApp implements RTTI support and how you add RTTI information to your classes.<P>
<A NAME=HEADING23-18></A>
<H3>The ClassDesc Class</H3>
 <A NAME=MARKER-2-24></A>The <CODE><A NAME=MARKER-2-25></A>ClassDesc</CODE> class works together with MacApp's RTTI macros to provide RTTI support. The <CODE>ClassDesc</CODE> class contains static global fields that point to sorted dynamic arrays of class name and inheritance data. It also contains methods for accessing the stored data. During static initialization, which occurs before any other application code is executed, MacApp's RTTI macros store class hierarchy data in each class that uses the macros. Later, during initialization of MacApp's <CODE>TObject</CODE> class, the <CODE>ClassDesc</CODE> method <CODE>InitUClassDesc</CODE> uses the stored data to construct its arrays. To include RTTI information in your classes, you use the macros described in the next section.<P>
 The <CODE>ClassDesc</CODE> class also provides methods for creating new objects based on its stored class information. These methods are described in <A HREF=#MARKER-9-45>"Creating New Objects by Signature, Class ID, or Class Name," beginning on page 31</A>.<P>
<A NAME=HEADING23-21></A>
<H3><A NAME=MARKER-9-26></A>Inserting RTTI Information Into Your Classes</H3>
 <A NAME=MARKER-2-27></A>To insert RTTI information into your classes, you use the macros <CODE>MA_DECLARE_CLASS</CODE> and <CODE>MA_DEFINE_CLASS_M0</CODE> (or one of its variations). MacApp then makes that information available while the application is running. You use the <CODE>MA_DECLARE_CLASS</CODE> macro in your class definition, with code similar to the following:<P>
<PRE>
class TYourSubClass : public TParentClass
{
   MA_DECLARE_CLASS;
</PRE>
 The <CODE><A NAME=MARKER-9-110></A>MA_DECLARE_CLASS</CODE> macro should be the first line within the declaration of the class. This macro adds fields and methods for dealing with <CODE>ClassDesc</CODE> information. MacApp uses these fields and methods during program initialization to build sorted arrays of RTTI data and, at runtime, to supply information about your classes.<P>
 You use the <CODE><A NAME=MARKER-2-29></A><A NAME=MARKER-2-30></A>MA_DEFINE_CLASS_M1</CODE> macro (or one of its variants) in your class implementation, with code similar to the following:<P>
<PRE>
#undef Inherited
#define Inherited TParentClass
#pragma segment YourSegmentName
MA_DEFINE_CLASS_M1(TYourSubClass, Inherited);
</PRE>
 This code should be the first thing in the class implementation, appearing before the implementation of any methods.<P>
 MacApp provides four variations of the <CODE>MA_DEFINE_CLASS_M1</CODE> macro: <CODE>MA_DEFINE_CLASS_M0</CODE>, <CODE>MA_DEFINE_CLASS_M1</CODE>, <CODE>MA_DEFINE_CLASS_M2</CODE>, and <CODE>MA_DEFINE_CLASS_M3</CODE>. The <CODE>M0</CODE>, <CODE>M1</CODE>, <CODE>M2</CODE>, or <CODE>M3</CODE> variations indicate the number of classes from which the current class inherits. Since the definition of these macros is included in MacApp, you can extend these macros by creating a new macro based on those provided by MacApp. For example, if you have a class that inherits from six other classes, you can define your own <CODE>MA_DEFINE_CLASS_M6</CODE> macro.<P>
 Base classes such as <CODE>TObject</CODE> use <CODE>MA_DEFINE_CLASS_M0</CODE> because they inherit from no other classes. The <CODE>TDocument</CODE> class, which inherits from its both parent class <CODE>TCommandHandler</CODE> and from the multiple inheritance class <CODE>MScriptableObject</CODE>, uses <CODE>MA_DEFINE_CLASS_M2</CODE>:<P>
<PRE>
#undef Inherited
#define Inherited TCommandHandler
#pragma segment MAOpen
MA_DEFINE_CLASS_M2(TDocument, Inherited, MScriptableObject);
</PRE>
 When expanded, the <CODE>MA_DEFINE_CLASS_M1</CODE> macro (or any of its variants) stores class hierarchy information in the fields that were inserted by the declare class macro. The definition of <CODE>Inherited</CODE> allows you to use code like the following:<P>
<PRE>
void TYourSubClass::SomeMethod()
{
   // Do something.
   // Then let parent class do something.
   Inherited::SomeMethod(); // Calls TParentClass method.
}
</PRE>
<A NAME=HEADING23-33></A>
<H3><A NAME=MARKER-9-31></A>Initializing RTTI Information</H3>
 MacApp's RTTI fields are set to default or initial values during static initialization. Later, during initialization of MacApp, <CODE><A NAME=MARKER-2-74></A>InitUObject</CODE> calls<P>
<PRE>
ClassDesc::InitUClassDesc();
</PRE>
 The <CODE>InitUClassDesc</CODE> method builds sorted dynamic arrays of RTTI data. (For more information on <CODE>InitUObject</CODE>, see <A HREF=MacAppProgGuide-35.html#MARKER-9-42>"Performing Additional Required Initialization," beginning on page 91</A>.)<P>
 The structures built by <CODE>InitUClassDesc</CODE> include the following fields:<P>
<DL>
<DT><CODE><A NAME=MARKER-2-77></A>fgClassDescList</CODE>
<DD> Points to the head of a linked list of <CODE>ClassDesc</CODE> objects for all classes used in the application
<DT><CODE><A NAME=MARKER-2-34></A>fgClassDescListByName</CODE>
<DD> Points to a sorted dynamic array of <CODE>ClassDesc</CODE> objects sorted by class name
<DT><CODE><A NAME=MARKER-2-35></A>fgClassDescListByID</CODE>
<DD> Points to a sorted dynamic array of <CODE>ClassDesc</CODE> objects sorted by class ID
<DT><CODE><A NAME=MARKER-9-76></A>fgSignatures</CODE>
<DD> Points to a sorted dynamic array of <CODE>ClassDesc</CODE> objects containing object signatures and class IDs
</DL>
 These dynamic arrays can be searched to provide class metadata for all descendants of <CODE>TObject</CODE> that use the <CODE>MA_DECLARE_CLASS</CODE> and <CODE>MA_DEFINE_CLASS_M0</CODE> (or one of its variations) macros. The fields aren't intended for use by your application--in fact, most of them are private. Your application can generally access the <CODE>ClassDesc</CODE> information it needs through methods of <CODE>TObject</CODE> (see <A HREF=MacAppProgGuide-24.html#MARKER-9-62>"RTTI Fields and Methods," beginning on page 35</A>) or <CODE>ClassDesc</CODE> (<A HREF=#MARKER-9-45>"Creating New Objects by Signature, Class ID, or Class Name," beginning on page 31</A>), or by calling macros such as <CODE>MA_DYNAMIC_CAST</CODE> (<A HREF=#MARKER-9-51>"Dynamic Casting," beginning on page 32</A>).<P>
 The next section describes how your classes can take advantage of MacApp's RTTI support.<P>
<A NAME=HEADING23-44></A>
<H2><A NAME=MARKER-9-37></A> Registering Class Information</H2>
 <A NAME=MARKER-2-38></A>You register class information for a class so that you can create a new instance of the class by name, by class ID, or by class signature. MacApp provides two macros for this purpose, <CODE><A NAME=MARKER-9-27></A>M<A NAME=MARKER-2-40></A>A_REGISTER_CLASS</CODE> and <CODE><A NAME=MARKER-2-41></A><A NAME=MARKER-9-70></A>MA_REGISTER_SIGNATURE</CODE>.<P>
 You call the <CODE>MA_REGISTER_CLASS</CODE> macro, passing a class name, to register the class. Registering a class enables your application to create new objects of that class type by name or by class ID. For example, MacApp's <CODE>InitUAddorners</CODE> routine makes the following call:<P>
<PRE>
MA_REGISTER_CLASS(TAdornerList);
</PRE>
 The <CODE>MA_REGISTER_CLASS</CODE> macro expands to a call to the <CODE>CallRegisterClass</CODE> method of the <CODE>ClassDesc</CODE> field for the class:<P>
<PRE>
ClassDesc::CallRegisterClass(&amp;TAdornerList::fgClassDesc,
                     &amp;TAdornerList::_DefaultConstructor);
</PRE>
 The default constructor passed in this call creates an adorner by calling<P>
<PRE>
new TAdornerList;
</PRE>
<DL>
<DT><B>IMPORTANT</B>
<DD>If you try to create an instance of a class using the <CODE>NewByClassName</CODE> method without first calling the <CODE>MA_REGISTER_CLASS</CODE> macro for that class, MacApp will display an alert box indicating that the class is not registered.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 You call the <CODE>MA_REGISTER_SIGNATURE</CODE> macro, passing a class name and a class signature, to register the class so that your application can create new objects of that class type by signature, by name, or by class ID. For example, the <CODE>InitUAddorners</CODE> routine makes the following call:<P>
<PRE>
MA_REGISTER_SIGNATURE(TDimAdorner, kDimAdorner);
</PRE>
 A signature is a 4-byte variable of type <CODE>IDType</CODE>, which is based on <CODE>ResType</CODE>. The <CODE>MA_REGISTER_SIGNATURE</CODE> macro passes the class name on to the <CODE>MA_REGISTER_CLASS</CODE> macro, so you can also create objects of the registered type by name or class ID.<P>
 When you register a class, MacApp guarantees that the linker will include code for that class in your application, as described in the next section.<P>
<A NAME=HEADING23-57></A>
<H3><A NAME=MARKER-9-43></A>Including Code for a Class</H3>
 A linker is said to <A NAME=MARKER-2-44></A><B>dead strip</B> code when it removes code that appears to be unused. When a class is instantiated directly with the <CODE>new</CODE> call, the linker knows the class is used in the application. But MacApp uses resource templates to create views and windows, and most developers use resource templates to define and instantiate their own views as well. However, if a class is registered with the <CODE>MA_REGISTER_CLASS</CODE> or <CODE>MA_REGISTER_SIGNATURE</CODE> macro, the linker will have a reference to a function for creating an instance of the class and will always include the code for that class.<P>
 Your application must register all classes it uses that are not created by a specific <CODE>new</CODE> call. The following code fragment from the <CODE>DoInitUMacApp</CODE> routine shows how the <CODE>MA_REGISTER_CLASS</CODE> and <CODE>MA_REGISTER_SIGNATURE</CODE> macros are used to register MacApp classes:<P>
<PRE>
MA_REGISTER_CLASS(TDragDropBehavior);
MA_REGISTER_SIGNATURE(TView, kStdView);
</PRE>
<A NAME=HEADING23-61></A>
<H3><A NAME=MARKER-9-45></A>Creating New Objects by Signature, Class ID, or Class Name</H3>
 <A NAME=MARKER-2-46></A><A NAME=MARKER-2-47></A><A NAME=MARKER-2-48></A>The <CODE>ClassDesc</CODE> class provides methods for creating new objects by signature, by class ID, or by class name: <CODE>NewBySignature</CODE>, <CODE>NewByClassID</CODE>, and <CODE>NewByClassName</CODE>. MacApp defines the 4-byte IDType for signatures:<P>
<PRE>
typedef ResType IDType;
</PRE>
 Specific signatures are defined by your application or by MacApp. For example, MacApp defines the following signature for a default view type:<P>
<PRE>
const IDType kIDDefaultView = 'DFLT';// View ID of default view.
</PRE>
 Each class that descends from <CODE>TObject</CODE> has an <CODE>fClassID</CODE> field of type <CODE>ClassID</CODE>. MacApp defines the <CODE>ClassID</CODE> type as a <CODE>short</CODE>, and sets the <CODE>fClassID</CODE> field to a unique value in the <CODE>IObject</CODE> method.<P>
 MacApp defines the following type for storing classnames:<P>
<PRE>
typedef CStr255 ClassName;
</PRE>
 MacApp provides the <CODE>NewObjectBySignature</CODE> global routine to create objects by signature or by class name. If you pass a class name, <CODE>NewObjectBySignature</CODE> calls <CODE>ClassDesc::NewByClassName</CODE>; if you pass only a class signature, it calls <CODE>ClassDesc::NewBySignature</CODE>.<P>
  The <CODE>ClassDesc</CODE> class also provides methods for accessing signature, class ID, and class name information: <CODE>GetClassName</CODE>, <CODE>GetClassID</CODE>, and <CODE>GetSignature</CODE>.<P>
 And finally, the <CODE>ClassDesc</CODE> class provides methods for converting between one kind of class information and another: <CODE>GetClassDescFromClassID</CODE>, <CODE>GetClassDescFromClassName</CODE>, and <CODE>GetClassDescFromSignature</CODE>.<P>
 MacApp itself creates objects using each of the new methods listed above (<CODE>NewBySignature</CODE>, <CODE>NewByClassID</CODE>, and <CODE>NewByClassName</CODE>). For example, when you define a view hierarchy with a resource editor and create the hierarchy in your application by calling <CODE>NewTemplateWindow</CODE> (see <A HREF=MacAppProgGuide-105.html#MARKER-9-37>"Create a Window From the 'View' Resource," beginning on page 452</A>), MacApp creates the objects in the hierarchy either by signature or by class name.<P>
 Creating new objects by signature has distinct advantages over creating by class name or class ID. Four-byte signatures are smaller than most class names--they take up less space and contribute to faster lookup. And unlike class IDs, signatures don't change unless you change them. (Class IDs are generated in sequence each time the application is run, based on the order in which the application's objects are initialized. When you modify your application, the class ID numbers can change.)<A NAME=MARKER-2-49></A><P>
<A NAME=HEADING23-74></A>
<H2><A NAME=MARKER-2-50></A><A NAME=MARKER-9-51></A>Dynamic Casting</H2>
 In an object-oriented environment with multiple inheritance, casting can take several forms, including the <I>up cast</I>, the <I>down cast</I>, and the <I>side cast</I>. Consider the document class hierarchy shown in <A HREF=MacAppProgGuide-58.html#MARKER-9-24>Figure 7-1 on page 164</A>. The <CODE>TMailableDocument</CODE> class descends directly from <CODE>TFileBasedDocument</CODE>, <CODE>TDocument</CODE>, and other classes. It also inherits from two mixin classes, <CODE>MMailable</CODE> (mixed in by <CODE>TMailableDocument</CODE> itself) and <CODE>MScriptableObject</CODE> (mixed in by the <CODE>TDocument</CODE> class).<P>
<UL>
<LI>An <B><A NAME=MARKER-2-52></A>up cast</B> is a cast of an object to another class type higher in the object's class hierarchy. Casting an object of type <CODE>TMailableDocument</CODE> to type <CODE>TFileBasedDocument</CODE> is an <I>up cast</I>:<P>
<pre>theFileBasedDocument = (<CODE>TFileBasedDocument*</CODE>) aMailableDocument;</pre><P>
This is the most common and safest type of object cast. If the object reference aMailableDocument truly points to an instance of <CODE>TMailableDocument</CODE>, it can always be safely cast to an instance of <CODE>TFileBasedDocument</CODE>.
<LI>A <B><A NAME=MARKER-2-53></A>down cast</B> is a cast of an object to another class type lower in the object's class hierarchy. Casting an object of type <CODE>TFileBasedDocument</CODE> to type <CODE>TMailableDocument</CODE> is a <I>down cast</I>.<P>
<pre>theMailableDocument = (<CODE>TMailableDocument*</CODE>) aFileBasedDocument;</pre><P>
This type of cast is not necessarily safe--not every instance of <CODE>TFileBasedDocument</CODE> is also an instance of <CODE>TMailableDocument</CODE>.
<LI>A <B><A NAME=MARKER-2-54></A>side cast</B> is a cast of an object to another class type that may be mixed into the object's class hierarchy. Casting an object of type <CODE>MMailable</CODE> to type <CODE>TFileBasedDocument</CODE> is a <I>side cast</I>. <P>
<pre>theFileBasedDocument = (<CODE>TFileBasedDocument*</CODE>) aMailable;</pre><P>
As with a down cast, a side cast is not necessarily safe--not every instance of <CODE>MMailable</CODE> is also an instance of <CODE>TMailableDocument</CODE>.<P>
</UL>
 Casting can lead to subtle or not-so-subtle errors. A cast may coerce an object pointer to be interpreted as a pointer to a type that is not part of the object's class hierarchy. As a result, the code that follows the cast may call a method or attempt to access data that doesn't exist for the pointed-to object. The results may vary but can be assumed to be bad.<P>
 Fortunately, MacApp provides a mechanism to perform safe object casting for all types of casts:<P>
<UL>
<LI>A <B>dynamic cast </B>is performed at runtime and uses current information to determine whether an object can be safely cast to the desired class. <P>
</UL>
 The <CODE>MA_DYNAMIC_CAST</CODE> macro works together with MacApp's RTTI mechanism to provide safe dynamic casting based on current runtime class information. You pass <CODE>MA_DYNAMIC_CAST</CODE> a desired result type and an object reference. If the desired type exists in the object's class hierarchy, through either direct or multiple inheritance, <CODE>MA_DYNAMIC_CAST</CODE> casts the object to the desired type; otherwise, it returns <CODE>NULL</CODE>.<P>
 The <CODE>TFileBasedLetter::IFileBasedLetter</CODE> method provides an example of how to the use <CODE>MA_DYNAMIC_CAST</CODE> macro:<P>
<PRE>
void TFileBasedLetter::IFileBasedLetter(MMailable* mailDoc)
{
   ILetter(mailDoc);
   fFileBasedDocument = MA_DYNAMIC_CAST(TFileBasedDocument,
                                 mailDoc);
   FailNonObject(fFileBasedDocument);
}
</PRE>
 The <CODE>MA_DYNAMIC_CAST</CODE> macro expands into code that gets the <CODE>ClassDesc</CODE> record of the mailDoc object, and calls its <CODE>DynamicCast</CODE> method. If the class descends from <CODE>TFileBasedDocument</CODE>, MA_DYNAMIC_CAST casts the <CODE>MMailable</CODE> pointer into a pointer to the actual base class (<CODE>TMailableDocument</CODE>), and casts that into a pointer to the <CODE>TFileBasedDocument</CODE> portion in the <CODE>TMailableDocument</CODE> object; otherwise, MA_DYNAMIC_CAST returns <CODE>NULL</CODE>.<P>
 For objects that contain runtime type information, you can use MacApp's dynamic casting mechanism to safely perform up casts, down casts, or side casts.<A NAME=MARKER-2-55></A><P>
<A NAME=HEADING23-93></A>
<H2><A NAME=MARKER-2-56></A><A NAME=MARKER-9-57></A>Virtual Destructors</H2>
 When you use the <CODE>delete</CODE> operator to dispose of an object, the object's destructor method is called automatically. However, to ensure that all destructors in the object's class hierarchy are called, including those mixed in by multiple inheritance, the destructors should be declared using the keyword <CODE>virtual</CODE>.<P>
 Declaring a constructor as virtual creates a small amount of extra overhead, but it may help prevent obscure memory leaks due to objects not being freed completely. MacApp's <CODE>TObject</CODE> class and its descendants use virtual destructor methods to help guarantee proper object disposal.<P>
 For more information on freeing objects, see <A HREF=MacAppProgGuide-123.html#MARKER-9-44>"Creating and Deleting Objects," beginning on page 38</A>.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-22.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-24.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
