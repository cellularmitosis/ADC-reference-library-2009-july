<html><head><title>Mac OS X
 Manual Page For perlsyn(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/perlsyn" title="Mac OS X
 Manual Page for perlsyn(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/perlsyn"; name=perlsyn(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
PERLSYN(1)                            Perl Programmers Reference Guide                            PERLSYN(1)



<b>NAME</b>
       perlsyn - Perl syntax

<b>DESCRIPTION</b>
       A Perl program consists of a sequence of declarations and statements which run from the top to the
       bottom.  Loops, subroutines and other control structures allow you to jump around within the code.

       Perl is a <b>free-form</b> language, you can format and indent it however you like.  Whitespace mostly
       serves to separate tokens, unlike languages like Python where it is an important part of the syntax.

       Many of Perl's syntactic elements are <b>optional</b>.  Rather than requiring you to put parentheses around
       every function call and declare every variable, you can often leave such explicit elements off and
       Perl will figure out what you meant.  This is known as <b>Do</b> <b>What</b> <b>I</b> <b>Mean</b>, abbreviated <b>DWIM</b>.  It allows
       programmers to be <b>lazy</b> and to code in a style with which they are comfortable.

       Perl <b>borrows</b> <b>syntax</b> and concepts from many languages: awk, sed, C, Bourne Shell, Smalltalk, Lisp and
       even English.  Other languages have borrowed syntax from Perl, particularly its regular expression
       extensions.  So if you have programmed in another language you will see familiar pieces in Perl.
       They often work the same, but see perltrap for information about how they differ.

       <b>Declarations</b>

       The only things you need to declare in Perl are report formats and subroutines (and sometimes not
       even subroutines).  A variable holds the undefined value ("undef") until it has been assigned a
       defined value, which is anything other than "undef".  When used as a number, "undef" is treated as 0;
       when used as a string, it is treated as the empty string, ""; and when used as a reference that isn't
       being assigned to, it is treated as an error.  If you enable warnings, you'll be notified of an
       uninitialized value whenever you treat "undef" as a string or a number.  Well, usually.  Boolean con-<font color="#ffffff" class="whiteout">texts,&nbsp;contexts,</font>
       texts, such as:

           my $a;
           if ($a) {}

       are exempt from warnings (because they care about truth rather than definedness).  Operators such as
       "++", "--", "+=", "-=", and ".=", that operate on undefined left values such as:

           my $a;
           $a++;

       are also always exempt from such warnings.

       A declaration can be put anywhere a statement can, but has no effect on the execution of the primary
       sequence of statements--declarations all take effect at compile time.  Typically all the declarations
       are put at the beginning or the end of the script.  However, if you're using lexically-scoped private
       variables created with "my()", you'll have to make sure your format or subroutine definition is
       within the same block scope as the my if you expect to be able to access those private variables.

       Declaring a subroutine allows a subroutine name to be used as if it were a list operator from that
       point forward in the program.  You can declare a subroutine without defining it by saying "sub name",
       thus:

           sub myname;
           $me = myname $0             or die "can't get myname";

       Note that <u>myname()</u> functions as a list operator, not as a unary operator; so be careful to use "or"
       instead of "||" in this case.  However, if you were to declare the subroutine as "sub myname ($)",
       then "myname" would function as a unary operator, so either "or" or "||" would work.

       Subroutines declarations can also be loaded up with the "require" statement or both loaded and
       imported into your namespace with a "use" statement.  See perlmod for details on this.

       A statement sequence may contain declarations of lexically-scoped variables, but apart from declaring
       a variable name, the declaration acts like an ordinary statement, and is elaborated within the
       sequence of statements as if it were an ordinary statement.  That means it actually has both compile-<font color="#ffffff" class="whiteout">time&nbsp;compiletime</font>
       time and run-time effects.

       <b>Comments</b>

       Text from a "#" character until the end of the line is a comment, and is ignored.  Exceptions include
       "#" inside a string or regular expression.

       <b>Simple</b> <b>Statements</b>

       The only kind of simple statement is an expression evaluated for its side effects.  Every simple
       statement must be terminated with a semicolon, unless it is the final statement in a block, in which
       case the semicolon is optional.  (A semicolon is still encouraged if the block takes up more than one
       line, because you may eventually add another line.)  Note that there are some operators like "eval
       {}" and "do {}" that look like compound statements, but aren't (they're just TERMs in an expression),
       and thus need an explicit termination if used as the last item in a statement.

       <b>Truth</b> <b>and</b> <b>Falsehood</b>

       The number 0, the strings '0' and '', the empty list "()", and "undef" are all false in a boolean
       context. All other values are true.  Negation of a true value by "!" or "not" returns a special false
       value.  When evaluated as a string it is treated as '', but as a number, it is treated as 0.

       <b>Statement</b> <b>Modifiers</b>

       Any simple statement may optionally be followed by a <u>SINGLE</u> modifier, just before the terminating
       semicolon (or block ending).  The possible modifiers are:

           if EXPR
           unless EXPR
           while EXPR
           until EXPR
           foreach LIST

       The "EXPR" following the modifier is referred to as the "condition".  Its truth or falsehood deter-<font color="#ffffff" class="whiteout">mines&nbsp;determines</font>
       mines how the modifier will behave.

       "if" executes the statement once <u>if</u> and only if the condition is true.  "unless" is the opposite, it
       executes the statement <u>unless</u> the condition is true (i.e., if the condition is false).

           print "Basset hounds got long ears" if length $ear &gt;= 10;
           go_outside() and play() unless $is_raining;

       The "foreach" modifier is an iterator: it executes the statement once for each item in the LIST (with
       $_ aliased to each item in turn).

           print "Hello $_!\n" foreach qw(world Dolly nurse);

       "while" repeats the statement <u>while</u> the condition is true.  "until" does the opposite, it repeats the
       statement <u>until</u> the condition is true (or while the condition is false):

           # Both of these count from 0 to 10.
           print $i++ while $i &lt;= 10;
           print $j++ until $j &gt;  10;

       The "while" and "until" modifiers have the usual ""while" loop" semantics (conditional evaluated
       first), except when applied to a "do"-BLOCK (or to the deprecated "do"-SUBROUTINE statement), in
       which case the block executes once before the conditional is evaluated.  This is so that you can
       write loops like:

           do {
               $line = &lt;STDIN&gt;;
               ...
           } until $line  eq ".\n";

       See "do" in perlfunc.  Note also that the loop control statements described later will <u>NOT</u> work in
       this construct, because modifiers don't take loop labels.  Sorry.  You can always put another block
       inside of it (for "next") or around it (for "last") to do that sort of thing.  For "next", just dou-<font color="#ffffff" class="whiteout">ble&nbsp;double</font>
       ble the braces:

           do {{
               next if $x == $y;
               # do something here
           }} until $x++ &gt; $z;

       For "last", you have to be more elaborate:

           LOOP: {
                   do {
                       last if $x = $y**2;
                       # do something here
                   } while $x++ &lt;= $z;
           }

       <b>NOTE:</b> The behaviour of a "my" statement modified with a statement modifier conditional or loop con-
       struct (e.g. "my $x if ...") is <b>undefined</b>.  The value of the "my" variable may be "undef", any previ-<font color="#ffffff" class="whiteout">ously&nbsp;previously</font>
       ously assigned value, or possibly anything else.  Don't rely on it.  Future versions of perl might do
       something different from the version of perl you try it out on.  Here be dragons.

       <b>Compound</b> <b>Statements</b>

       In Perl, a sequence of statements that defines a scope is called a block.  Sometimes a block is
       delimited by the file containing it (in the case of a required file, or the program as a whole), and
       sometimes a block is delimited by the extent of a string (in the case of an eval).

       But generally, a block is delimited by curly brackets, also known as braces.  We will call this syn-<font color="#ffffff" class="whiteout">tactic&nbsp;syntactic</font>
       tactic construct a BLOCK.

       The following compound statements may be used to control flow:

           if (EXPR) BLOCK
           if (EXPR) BLOCK else BLOCK
           if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK
           LABEL while (EXPR) BLOCK
           LABEL while (EXPR) BLOCK continue BLOCK
           LABEL until (EXPR) BLOCK
           LABEL until (EXPR) BLOCK continue BLOCK
           LABEL for (EXPR; EXPR; EXPR) BLOCK
           LABEL foreach VAR (LIST) BLOCK
           LABEL foreach VAR (LIST) BLOCK continue BLOCK
           LABEL BLOCK continue BLOCK

       Note that, unlike C and Pascal, these are defined in terms of BLOCKs, not statements.  This means
       that the curly brackets are <u>required</u>--no dangling statements allowed.  If you want to write condi-<font color="#ffffff" class="whiteout">tionals&nbsp;conditionals</font>
       tionals without curly brackets there are several other ways to do it.  The following all do the same
       thing:

           if (!open(FOO)) { die "Can't open $FOO: $!"; }
           die "Can't open $FOO: $!" unless open(FOO);
           open(FOO) or die "Can't open $FOO: $!";     # FOO or bust!
           open(FOO) ? 'hi mom' : die "Can't open $FOO: $!";
                               # a bit exotic, that last one

       The "if" statement is straightforward.  Because BLOCKs are always bounded by curly brackets, there is
       never any ambiguity about which "if" an "else" goes with.  If you use "unless" in place of "if", the
       sense of the test is reversed.

       The "while" statement executes the block as long as the expression is true (does not evaluate to the
       null string "" or 0 or "0").  The "until" statement executes the block as long as the expression is
       false.  The LABEL is optional, and if present, consists of an identifier followed by a colon.  The
       LABEL identifies the loop for the loop control statements "next", "last", and "redo".  If the LABEL
       is omitted, the loop control statement refers to the innermost enclosing loop.  This may include
       dynamically looking back your call-stack at run time to find the LABEL.  Such desperate behavior
       triggers a warning if you use the "use warnings" pragma or the <b>-w</b> flag.

       If there is a "continue" BLOCK, it is always executed just before the conditional is about to be
       evaluated again.  Thus it can be used to increment a loop variable, even when the loop has been con-<font color="#ffffff" class="whiteout">tinued&nbsp;continued</font>
       tinued via the "next" statement.

       <b>Loop</b> <b>Control</b>

       The "next" command starts the next iteration of the loop:

           LINE: while (&lt;STDIN&gt;) {
               next LINE if /^#/;      # discard comments
               ...
           }

       The "last" command immediately exits the loop in question.  The "continue" block, if any, is not exe-<font color="#ffffff" class="whiteout">cuted:&nbsp;executed:</font>
       cuted:

           LINE: while (&lt;STDIN&gt;) {
               last LINE if /^$/;      # exit when done with header
               ...
           }

       The "redo" command restarts the loop block without evaluating the conditional again.  The "continue"
       block, if any, is <u>not</u> executed.  This command is normally used by programs that want to lie to them-<font color="#ffffff" class="whiteout">selves&nbsp;themselves</font>
       selves about what was just input.

       For example, when processing a file like <u>/etc/termcap</u>.  If your input lines might end in backslashes
       to indicate continuation, you want to skip ahead and get the next record.

           while (&lt;&gt;) {
               chomp;
               if (s/\\$//) {
                   $_ .= &lt;&gt;;
                   redo unless eof();
               }
               # now process $_
           }

       which is Perl short-hand for the more explicitly written version:

           LINE: while (defined($line = &lt;ARGV&gt;)) {
               chomp($line);
               if ($line =~ s/\\$//) {
                   $line .= &lt;ARGV&gt;;
                   redo LINE unless eof(); # not eof(ARGV)!
               }
               # now process $line
           }

       Note that if there were a "continue" block on the above code, it would get executed only on lines
       discarded by the regex (since redo skips the continue block). A continue block is often used to reset
       line counters or "?pat?" one-time matches:

           # inspired by :1,$g/fred/s//WILMA/
           while (&lt;&gt;) {
               ?(fred)?    &amp;&amp; s//WILMA $1 WILMA/;
               ?(barney)?  &amp;&amp; s//BETTY $1 BETTY/;
               ?(homer)?   &amp;&amp; s//MARGE $1 MARGE/;
           } continue {
               print "$ARGV $.: $_";
               close ARGV  if eof();           # reset $.
               reset       if eof();           # reset ?pat?
           }

       If the word "while" is replaced by the word "until", the sense of the test is reversed, but the con-<font color="#ffffff" class="whiteout">ditional&nbsp;conditional</font>
       ditional is still tested before the first iteration.

       The loop control statements don't work in an "if" or "unless", since they aren't loops.  You can dou-<font color="#ffffff" class="whiteout">ble&nbsp;double</font>
       ble the braces to make them such, though.

           if (/pattern/) {{
               last if /fred/;
               next if /barney/; # same effect as "last", but doesn't document as well
               # do something here
           }}

       This is caused by the fact that a block by itself acts as a loop that executes once, see "Basic
       BLOCKs and Switch Statements".

       The form "while/if BLOCK BLOCK", available in Perl 4, is no longer available.   Replace any occur-<font color="#ffffff" class="whiteout">rence&nbsp;occurrence</font>
       rence of "if BLOCK" by "if (do BLOCK)".

       <b>For</b> <b>Loops</b>

       Perl's C-style "for" loop works like the corresponding "while" loop; that means that this:

           for ($i = 1; $i &lt; 10; $i++) {
               ...
           }

       is the same as this:

           $i = 1;
           while ($i &lt; 10) {
               ...
           } continue {
               $i++;
           }

       There is one minor difference: if variables are declared with "my" in the initialization section of
       the "for", the lexical scope of those variables is exactly the "for" loop (the body of the loop and
       the control sections).

       Besides the normal array index looping, "for" can lend itself to many other interesting applications.
       Here's one that avoids the problem you get into if you explicitly test for end-of-file on an interac-
       tive file descriptor causing your program to appear to hang.

           $on_a_tty = -t STDIN &amp;&amp; -t STDOUT;
           sub prompt { print "yes? " if $on_a_tty }
           for ( prompt(); &lt;STDIN&gt;; prompt() ) {
               # do something
           }

       Using "readline" (or the operator form, "&lt;EXPR&gt;") as the conditional of a "for" loop is shorthand for
       the following.  This behaviour is the same as a "while" loop conditional.

           for ( prompt(); defined( $_ = &lt;STDIN&gt; ); prompt() ) {
               # do something
           }

       <b>Foreach</b> <b>Loops</b>

       The "foreach" loop iterates over a normal list value and sets the variable VAR to be each element of
       the list in turn.  If the variable is preceded with the keyword "my", then it is lexically scoped,
       and is therefore visible only within the loop.  Otherwise, the variable is implicitly local to the
       loop and regains its former value upon exiting the loop.  If the variable was previously declared
       with "my", it uses that variable instead of the global one, but it's still localized to the loop.
       This implicit localisation occurs <u>only</u> in a "foreach" loop.

       The "foreach" keyword is actually a synonym for the "for" keyword, so you can use "foreach" for read-<font color="#ffffff" class="whiteout">ability&nbsp;readability</font>
       ability or "for" for brevity.  (Or because the Bourne shell is more familiar to you than <u>csh</u>, so
       writing "for" comes more naturally.)  If VAR is omitted, $_ is set to each value.

       If any element of LIST is an lvalue, you can modify it by modifying VAR inside the loop.  Conversely,
       if any element of LIST is NOT an lvalue, any attempt to modify that element will fail.  In other
       words, the "foreach" loop index variable is an implicit alias for each item in the list that you're
       looping over.

       If any part of LIST is an array, "foreach" will get very confused if you add or remove elements
       within the loop body, for example with "splice".   So don't do that.

       "foreach" probably won't do what you expect if VAR is a tied or other special variable.   Don't do
       that either.

       Examples:

           for (@ary) { s/foo/bar/ }

           for my $elem (@elements) {
               $elem *= 2;
           }

           for $count (10,9,8,7,6,5,4,3,2,1,'BOOM') {
               print $count, "\n"; <a href="sleep.1.html#//apple_ref/doc/man/1/sleep">sleep(1)</a>;
           }

           for (1..15) { print "Merry Christmas\n"; }

           foreach $item (split(/:[\\\n:]*/, $ENV{TERMCAP})) {
               print "Item: $item\n";
           }

       Here's how a C programmer might code up a particular algorithm in Perl:

           for (my $i = 0; $i &lt; @ary1; $i++) {
               for (my $j = 0; $j &lt; @ary2; $j++) {
                   if ($ary1[$i] &gt; $ary2[$j]) {
                       last; # can't go to outer :-(
                   }
                   $ary1[$i] += $ary2[$j];
               }
               # this is where that last takes me
           }

       Whereas here's how a Perl programmer more comfortable with the idiom might do it:

           OUTER: for my $wid (@ary1) {
           INNER:   for my $jet (@ary2) {
                       next OUTER if $wid &gt; $jet;
                       $wid += $jet;
                    }
                 }

       See how much easier this is?  It's cleaner, safer, and faster.  It's cleaner because it's less noisy.
       It's safer because if code gets added between the inner and outer loops later on, the new code won't
       be accidentally executed.  The "next" explicitly iterates the other loop rather than merely terminat-<font color="#ffffff" class="whiteout">ing&nbsp;terminating</font>
       ing the inner one.  And it's faster because Perl executes a "foreach" statement more rapidly than it
       would the equivalent "for" loop.

       <b>Basic</b> <b>BLOCKs</b> <b>and</b> <b>Switch</b> <b>Statements</b>

       A BLOCK by itself (labeled or not) is semantically equivalent to a loop that executes once.  Thus you
       can use any of the loop control statements in it to leave or restart the block.  (Note that this is
       <u>NOT</u> true in "eval{}", "sub{}", or contrary to popular belief "do{}" blocks, which do <u>NOT</u> count as
       loops.)  The "continue" block is optional.

       The BLOCK construct is particularly nice for doing case structures.

           SWITCH: {
               if (/^abc/) { $abc = 1; last SWITCH; }
               if (/^def/) { $def = 1; last SWITCH; }
               if (/^xyz/) { $xyz = 1; last SWITCH; }
               $nothing = 1;
           }

       There is no official "switch" statement in Perl, because there are already several ways to write the
       equivalent.

       However, starting from Perl 5.8 to get switch and case one can use the Switch extension and say:

               use Switch;

       after which one has switch and case.  It is not as fast as it could be because it's not really part
       of the language (it's done using source filters) but it is available, and it's very flexible.

       In addition to the above BLOCK construct, you could write

           SWITCH: {
               $abc = 1, last SWITCH  if /^abc/;
               $def = 1, last SWITCH  if /^def/;
               $xyz = 1, last SWITCH  if /^xyz/;
               $nothing = 1;
           }

       (That's actually not as strange as it looks once you realize that you can use loop control "opera-<font color="#ffffff" class="whiteout">tors"&nbsp;"operators"</font>
       tors" within an expression.  That's just the binary comma operator in scalar context.  See "Comma
       Operator" in perlop.)

       or

           SWITCH: {
               /^abc/ &amp;&amp; do { $abc = 1; last SWITCH; };
               /^def/ &amp;&amp; do { $def = 1; last SWITCH; };
               /^xyz/ &amp;&amp; do { $xyz = 1; last SWITCH; };
               $nothing = 1;
           }

       or formatted so it stands out more as a "proper" "switch" statement:

           SWITCH: {
               /^abc/      &amp;&amp; do {
                                   $abc = 1;
                                   last SWITCH;
                              };

               /^def/      &amp;&amp; do {
                                   $def = 1;
                                   last SWITCH;
                              };

               /^xyz/      &amp;&amp; do {
                                   $xyz = 1;
                                   last SWITCH;
                               };
               $nothing = 1;
           }

       or

           SWITCH: {
               /^abc/ and $abc = 1, last SWITCH;
               /^def/ and $def = 1, last SWITCH;
               /^xyz/ and $xyz = 1, last SWITCH;
               $nothing = 1;
           }

       or even, horrors,

           if (/^abc/)
               { $abc = 1 }
           elsif (/^def/)
               { $def = 1 }
           elsif (/^xyz/)
               { $xyz = 1 }
           else
               { $nothing = 1 }

       A common idiom for a "switch" statement is to use "foreach"'s aliasing to make a temporary assignment
       to $_ for convenient matching:

           SWITCH: for ($where) {
                       /In Card Names/     &amp;&amp; do { push @flags, '-e'; last; };
                       /Anywhere/          &amp;&amp; do { push @flags, '-h'; last; };
                       /In Rulings/        &amp;&amp; do {                    last; };
                       die "unknown value for form variable where: `$where'";
                   }

       Another interesting approach to a switch statement is arrange for a "do" block to return the proper
       value:

           $amode = do {
               if     ($flag &amp; O_RDONLY) { "r" }       # XXX: isn't this 0?
               elsif  ($flag &amp; O_WRONLY) { ($flag &amp; O_APPEND) ? "a" : "w" }
               elsif  ($flag &amp; O_RDWR)   {
                   if ($flag &amp; O_CREAT)  { "w+" }
                   else                  { ($flag &amp; O_APPEND) ? "a+" : "r+" }
               }
           };

       Or

               print do {
                   ($flags &amp; O_WRONLY) ? "write-only"          :
                   ($flags &amp; O_RDWR)   ? "read-write"          :
                                         "read-only";
               };

       Or if you are certain that all the "&amp;&amp;" clauses are true, you can use something like this, which
       "switches" on the value of the "HTTP_USER_AGENT" environment variable.

           #!/usr/bin/perl
           # pick out jargon file page based on browser
           $dir = '<a href="http://www.wins.uva.nl/~mes/jargon">http://www.wins.uva.nl/~mes/jargon</a>';
           for ($ENV{HTTP_USER_AGENT}) {
               $page  =    /Mac/            &amp;&amp; 'm/Macintrash.html'
                        || /Win(dows )?NT/  &amp;&amp; 'e/evilandrude.html'
                        || /Win|MSIE|WebTV/ &amp;&amp; 'm/MicroslothWindows.html'
                        || /Linux/          &amp;&amp; 'l/Linux.html'
                        || /HP-UX/          &amp;&amp; 'h/HP-SUX.html'
                        || /SunOS/          &amp;&amp; 's/ScumOS.html'
                        ||                     'a/AppendixB.html';
           }
           print "Location: $dir/$page\015\012\015\012";

       That kind of switch statement only works when you know the "&amp;&amp;" clauses will be true.  If you don't,
       the previous "?:" example should be used.

       You might also consider writing a hash of subroutine references instead of synthesizing a "switch"
       statement.

       <b>Goto</b>

       Although not for the faint of heart, Perl does support a "goto" statement.  There are three forms:
       "goto"-LABEL, "goto"-EXPR, and "goto"-&amp;NAME.  A loop's LABEL is not actually a valid target for a
       "goto"; it's just the name of the loop.

       The "goto"-LABEL form finds the statement labeled with LABEL and resumes execution there.  It may not
       be used to go into any construct that requires initialization, such as a subroutine or a "foreach"
       loop.  It also can't be used to go into a construct that is optimized away.  It can be used to go
       almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better
       to use some other construct such as "last" or "die".  The author of Perl has never felt the need to
       use this form of "goto" (in Perl, that is--C is another matter).

       The "goto"-EXPR form expects a label name, whose scope will be resolved dynamically.  This allows for
       computed "goto"s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintain-
       ability:

           goto(("FOO", "BAR", "GLARCH")[$i]);

       The "goto"-&amp;NAME form is highly magical, and substitutes a call to the named subroutine for the cur-
       rently running subroutine.  This is used by "AUTOLOAD()" subroutines that wish to load another sub-
       routine and then pretend that the other subroutine had been called in the first place (except that
       any modifications to @_ in the current subroutine are propagated to the other subroutine.)  After the
       "goto", not even "caller()" will be able to tell that this routine was called first.

       In almost all cases like this, it's usually a far, far better idea to use the structured control flow
       mechanisms of "next", "last", or "redo" instead of resorting to a "goto".  For certain applications,
       the catch and throw pair of "eval{}" and <u>die()</u> for exception processing can also be a prudent
       approach.

       <b>PODs:</b> <b>Embedded</b> <b>Documentation</b>

       Perl has a mechanism for intermixing documentation with source code.  While it's expecting the begin-
       ning of a new statement, if the compiler encounters a line that begins with an equal sign and a word,
       like this

           =head1 Here There Be Pods!

       Then that text and all remaining text up through and including a line beginning with "=cut" will be
       ignored.  The format of the intervening text is described in perlpod.

       This allows you to intermix your source code and your documentation text freely, as in

           =item snazzle($)

           The snazzle() function will behave in the most spectacular
           form that you can possibly imagine, not even excepting
           cybernetic pyrotechnics.

           =cut back to the compiler, nuff of this pod stuff!

           sub snazzle($) {
               my $thingie = shift;
               .........
           }

       Note that pod translators should look at only paragraphs beginning with a pod directive (it makes
       parsing easier), whereas the compiler actually knows to look for pod escapes even in the middle of a
       paragraph.  This means that the following secret stuff will be ignored by both the compiler and the
       translators.

           $a=3;
           =secret stuff
            warn "Neither POD nor CODE!?"
           =cut back
           print "got $a\n";

       You probably shouldn't rely upon the "warn()" being podded out forever.  Not all pod translators are
       well-behaved in this regard, and perhaps the compiler will become pickier.

       One may also use pod directives to quickly comment out a section of code.

       <b>Plain</b> <b>Old</b> <b>Comments</b> <b>(Not!)</b>

       Perl can process line directives, much like the C preprocessor.  Using this, one can control Perl's
       idea of filenames and line numbers in error or warning messages (especially for strings that are pro-
       cessed with "eval()").  The syntax for this mechanism is the same as for most C preprocessors: it
       matches the regular expression

           # example: '# line 42 "new_filename.plx"'
           /^\#   \s*
             line \s+ (\d+)   \s*
             (?:\s("?)([^"]+)\2)? \s*
            $/x

       with $1 being the line number for the next line, and $3 being the optional filename (specified with
       or without quotes).

       There is a fairly obvious gotcha included with the line directive: Debuggers and profilers will only
       show the last source line to appear at a particular line number in a given file.  Care should be
       taken not to cause line number collisions in code you'd like to debug later.

       Here are some examples that you should be able to type into your command shell:

           % perl
           # line 200 "bzzzt"
           # the `#' on the previous line must be the first char on line
           die 'foo';
           __END__
           foo at bzzzt line 201.

           % perl
           # line 200 "bzzzt"
           eval qq[\n#line 2001 ""\ndie 'foo']; print $@;
           __END__
           foo at - line 2001.

           % perl
           eval qq[\n#line 200 "foo bar"\ndie 'foo']; print $@;
           __END__
           foo at foo bar line 200.

           % perl
           # line 345 "goop"
           eval "\n#line " . __LINE__ . ' "' . __FILE__ ."\"\ndie 'foo'";
           print $@;
           __END__
           foo at goop line 345.



perl v5.8.8                                      2006-01-07                                       PERLSYN(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/perlsyn.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/perlsyn.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/perlsyn.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
