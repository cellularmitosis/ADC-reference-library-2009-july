<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><!--Includes revisions to code listings--><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="Stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN2022: The Death of typeFSSpec: moving along to typeFileURL</title><meta name="keywords" content="have creator list relevant keywords here"><meta name="Description" content="Technical Note TN2022: have creator write a brief descriptionhere."><meta name="categories" content="Processes, Operating System, Interapplication Communication, Files and Overview"><meta name="week-posted" content="Jun 4, 2001 - Jun 8, 2001"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003059" title="The Death of typeFSSpec: moving along to typeFileURL"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxInterapplicationCommunication-date.html">Interapplication Communication</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN2022</div>
<div id="pageheadsub">The Death of typeFSSpec: moving along to typeFileURL</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                   <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->					<p id="menutext">                   <A HREF="#typeFileURL">typeFileURL Defined</A><BR>                  <BR>                  <A HREF="#whentouse">When to use typeFileURL</A><BR>                  <BR>                  <A HREF="#fromnav">Creating a typeFileURL from a Navigation Services reply</A><BR>                  <BR>                  <A HREF="#makingfile">Creating a file referenced by a typeFileURL</A><BR>                  <BR>                  <A HREF="#advanced">Advanced routines for using typeFileURL</A><BR>                  <BR>                  <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left>            <!-- begin_intro_text --><p id="introtext">This Technote describes the proposed <CODE>typeFileURL</CODE>data format and discusses how to use this data type to pass referencesto files between applications in Mac OS X.  This new data typeprovides a convenient way to pass references to files that have yetto be created between applications running in Mac OS X.</P><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Jun 07 2001]</h3><!-- end_date --></TD></TR></TABLE><!-- end_table_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><p>The <CODE>FSSpec</CODE> data type is not suitable for encodinginformation about files in Mac OS X.  Most importantly, <CODE>FSSpec</CODE>scannot encode long or Unicode file names such as those used in theMac OS X file system.  In addition, Directory ID numbers and volumereference numbers are application specific in Mac&nbsp;OS&nbsp;X.  This meansthat a directory ID number or volume reference number used in oneapplication will not have any meaning for another applications.  <CODE>FSSpec</CODE>records include volume reference numbers, directory ID numbers, anddo not contain sufficient space for long file names.  As a result,<CODE>FSSpec</CODE> do not provide suitable encoding for storing referencesto files or for passing references to files between applicationsin Mac&nbsp;OS&nbsp;X.</P><p>For the most part, <CODE>Alias</CODE> records encoded inApple events provide suitable remedy for the shortcomings of<CODE>FSSpec</CODE> records, except for one case - referencesto files that have yet to be created.  In these cases, theproposed <CODE>typeFileURL</CODE> is the best way to providea such a pre-determined file reference.</P><P>Users will expect to be able to use longer file names inMac&nbsp;OS&nbsp;X, and the new Navigation Services routineswill allow them to do this.  Most importantly, for the purposesof this document, it should be noted that calls to <CODE>NavPutFile</CODE>have been replaced with the <CODE>NavCreatePutFileDialog</CODE>/<CODE>NavDialogRun</CODE>calling sequence that allows a user to provide a longer, Unicode filename that is returned in a <CODE>CFString</CODE>.  This document discusseshow this information can be packaged up for transmission betweenapplications and transmission within Apple event factored applications.</P><BR><BR><A NAME=typeFileURL></A><H2>typeFileURL Defined</H2><P>In a nutshell, <CODE>typeFileURL</CODE> is a core-foundation URLencoded to a stream of bytes in UTF8 format.  This is the suggesteddata type to use when your application would like to create a referenceto a file that has yet to be created.  Furthermore, there are a number ofother good reasons to use this type; depending on your processingrequirements, you may wish to use this data type in a number of differentcircumstances.  Here are some properties and features of the<CODE>typeFileURL</CODE> data format:</P><UL>	<LI><CODE>typeAlias</CODE> and <CODE>typeFSRef</CODE> require deterministic	reference and cannot refer to files that have yet to be created.	<CODE>typeFileURL</CODE> uses the weak "by name" style reference provided	by URLs, and as such is quite capable of providing pre-determined	references to files.<BR><BR></LI>		<LI><CODE>typeFileURL</CODE> provides facilities encoding of special characters	in directory and file names including '/', ':', and Unicode characters.<BR><BR></LI>		<LI>It is the same data format as the <CODE>'furl'</CODE> Drag Flavor.  This flavor is attached	to drag references containing HFS flavors.  It is used internally by the Drag Manager	as follows:<BR><BR>			<OL>				<LI>In the sending application: when a HFS flavor is added to a drag item,		the drag manager encodes a <CODE>'furl'</CODE> flavor in the drag item referencing		the same file.<BR><BR></LI>				<LI>In the receiving application:  The <CODE>'furl'</CODE> flavor is decoded and used to		update the <CODE>FSSpec</CODE> record's fields in the HFS flavor before it is passed to		the receiving application.<BR><BR></LI>				</OL>			Here, there result is that an application can use the HFS flavors directly without	worrying about stale directory ID numbers of volume reference numbers.  But, as well,	an application that uses the <CODE>typeFileURL</CODE> data type may use the encoded	<CODE>'furl'</CODE> flavor directly, instead of using the HFS flavor.<BR><BR></LI>		<LI>URLs provided by Core Foundation encode mount-point information.  As such,	<CODE>typeFileURL</CODE> references are capable of distinguishing between volumes	with the same name.<BR><BR></LI>		<LI><CODE>typeFileURL</CODE> does not encode any process-specific information	such as volume reference numbers or directory ID numbers.  As such, it is valid	to pass this format from process to process.<BR><BR></LI>		<LI><CODE>typeFileURL</CODE> are static non persistent references.  That is,	if a <CODE>typeFileURL</CODE> is created that references a file and that file	is later moved, the <CODE>typeFileURL</CODE> will no longer reference that	file.  For this type of functionality, you should consider using the	<CODE>typeAlias</CODE> format.<BR><BR></LI></UL><P>The routines shown in listing 1 provide a functional definition for the<CODE>typeFileURL</CODE> format.  These routines can be used to convertApple event descriptor records containing <CODE>typeFileURL</CODE> datainto Core Foundation URLs.  Core Foundation URLs themselves provide clearreference to files that can be used by applications.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    /* encode -&gt; AEDesc    FURLDescFromCFURL encodes a Core Foundation URL into a    Apple event descriptor record and returns a pointer to    the descriptor record.  If an error occurs, NULL is    returned.  */AEDesc * FURLDescFromCFURL(AEDesc *furlDesc, CFURLRef url) {    CFDataRef theData;    OSStatus err;    AEDesc *furlResult;        /* set up locals to a known state */    furlResult = NULL;        /* encode the URL to a UTF8 data string */    theData = CFURLCreateData(nil, url, kCFStringEncodingUTF8, true);    if (theData != NULL) {            /* put the data into the descriptor */        err = AECreateDesc('furl', CFDataGetBytePtr(theData),            CFDataGetLength(theData), furlDesc);            /* if successful, set the result */        if (err == noErr) {            furlResult = furlDesc;        }            /* release the local buffer */        CFRelease(theData);    }        /* return a pointer to the furl descriptor */    return furlResult;}    /* decode -&gt; CFURL    FURLDescToCFURL decodes an Apple event descriptor record    containing a furl descriptor and returns a Core Foundation    URL.  If an error occurs, NULL is returned.  */CFURLRef FURLDescToCFURL(AEDesc *furlDesc) {    Ptr dataPtr;    Size bytecount;    CFURLRef url;    OSStatus err;        /* set up locals to a known state */    url = NULL;        /* verify the type is correct */    if (furlDesc-&gt;descriptorType == 'furl') {            /* count the bytes in the descriptor */        bytecount = AEGetDescDataSize(furlDesc);            /* allocate a local buffer for the bytes */        dataPtr = malloc(bytecount);        if (dataPtr != NULL) {                /* copy the bytes from the descriptor */            err = AEGetDescData(furlDesc, dataPtr, bytecount);            if (err == noErr) {                    /* create a Core Foundation URL */                url = CFURLCreateWithBytes(nil, dataPtr, bytecount,                    kCFStringEncodingUTF8, nil);            }                /* deallocate the local buffer */            free(dataPtr);        }    }        /* return the new URL */    return url;}</pre></TD></TR><TR><td align="left"><P><B>Listing 1.</B>  Routines illustrating how to encode and decode<CODE>'furl'</CODE> Apple event descriptor records.  These routinesprovide a functional definition for this data type.</P></TD></TR></TABLE></CENTER><BR><BR>                    <P>These are runtime data types used by applications for communications offile locations.  As such, a definition of the binary format for this typeis not provided in this document.  However, developers who are interestedin discovering the exact details of the binary encoding used for this data typeshould consult the Core Foundation documentation.</P><P><A HREF="#top">Back to top</A></P><A NAME=whentouse></A><H2>When to use typeFileURL</H2><P>The <CODE>typeFileURL</CODE> was specifically designed to allow reference to filesthat have yet to be created.  As such, its primary function is to allowfile naming and reference in "Save As..." style Apple events sent betweenand within applications.</P><P>In an application that has been factored and sends Apple events toitself for processing in response to user interface commands, the<CODE>typeFileURL</CODE> is a necessary encoding mechanism as thetraditional encoding schemes not sufficient for encoding referencesto files that have yet to be created in Mac OS X.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td align="left"><CENTER><img src="images/tn2022_001.gif" alt="" width=446 height=298></CENTER></TD></TR><TR><td align="left"><P><B>Figure 1.</B>  An illustration showing how the <CODE>typeFileURL</CODE>format is used to encode references to files in Apple events.  Note: in afactored application, both the sending application and the receivingapplication are one and the same.</P></TD></TR></TABLE></CENTER><BR><BR><P><A HREF="#top">Back to top</A></P><A NAME=fromnav></A><H2>Creating a typeFileURL from a Navigation Services reply</H2><P>Naturally, the first step in the process illustrated in Figure 1 is retrieving aCore Foundation URL from the Navigation Services reply that referencesthe file that should be created.  In Mac OS X, the Navigation Servicesreply record returned by a <CODE>NavCreatePutFileDialog</CODE>/<CODE>NavDialogRun</CODE> sequencewill contain a <CODE>FSRef</CODE>referring to the folder where the new file should be created in thefirst <CODE>AEDesc</CODE> record in <CODE>AEDescList</CODE> contained inthe <CODE>NavReplyRecord</CODE>'s <CODE>selection</CODE> field, and thename of the new file will contained in the <CODE>CFString</CODE> referred to bythe <CODE>saveFileName</CODE> field.  Listing 2 illustrates one way this canbe done.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    /* GetCFURLFromNavReply returns a URL referencing a file that    is yet to be created in response to a    NavCreatePutFileDialog/NavDialogRun sequence */CFURLRef GetCFURLFromNavReply(const NavReplyRecord * navReply) {    OSStatus err;    FSRef parentFSRef;    CFURLRef parentURLRef, fullURLRef;    AEKeyword theAEKeyword;    DescType typeCode;    Size actualSize;        /* ensure locals are in a known state */    fullURLRef = NULL;        /* get the FSRef referring to the parent directory */    err = AEGetNthPtr(&amp;navReply-&gt;selection, 1, typeFSRef,        &amp;theAEKeyword, &amp;typeCode, &amp;parentFSRef, sizeof(FSRef), &amp;actualSize);    if (err == noErr) {            /* convert the FSRef into a Core Foundation URL */        parentURLRef = CFURLCreateFromFSRef(NULL, &amp;parentFSRef);        if (parentURLRef != NULL) {                /* add the file name to the end of the url */            fullURLRef = CFURLCreateCopyAppendingPathComponent(NULL,                parentURLRef, navReply-&gt;saveFileName, false);                /* release the path to the parent */            CFRelease(parentURLRef);        }    }        /* return the reference to the new URL */    return fullURLRef;}</pre></TD></TR><TR><td align="left"><P><B>Listing 2.</B>  An example of how one could generate a CoreFoundation URL from a Navigation Services reply record returnedby a <CODE>NavCreatePutFileDialog</CODE>/<CODE>NavDialogRun</CODE> sequence.</P></TD></TR></TABLE></CENTER><BR><BR>                    <P>Once the file reference has been encoded as a CFURL, a routine such as<CODE>FURLDescFromCFURL</CODE> (see Listing 1) can be used to encode it into a Apple eventdescriptor record as an <CODE>'furl'</CODE> formatted descriptor.  Once it has beenconverted into this format, it is ready for transport in an Apple event.</P><P><A HREF="#top">Back to top</A></P><A NAME=makingfile></A><H2>Creating a file referenced by a typeFileURL</H2><P>For decoding an Apple event descriptor record containing a <CODE>typeFileURL</CODE>your application would use a technique similar to the one presented in the<CODE>FURLDescToCFURL</CODE> routine shown in Listing 1.  This will provide a CFURL referencing the file that is to be created, which in turn can be used to generate botha reference to the directory (where the file should be created), and the nameof the file to create.  These items can then be passed to<CODE>FSCreateFileUnicode</CODE>, shown in Listing 3, to perform the file creationoperation.  Once the file has been created, it can be referenced usinga <CODE>FSRef</CODE> record.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    /* CreateFileUsingCFURL creates the file referenced by    the CFURL using the supplied catalog parameters. */OSStatus CreateFileUsingCFURL(            FSRef *newFileReference,            CFURLRef url,            FSCatalogInfoBitmap whichInfo,            const FSCatalogInfo * catalogInfo) {    CFURLRef parentURL;    CFStringRef fileNameRef;    FSRef parentDirectory;    UniCharPtr nameStringPtr;    OSStatus err;        /* set locals to a known state */    err = coreFoundationUnknownErr;        /* get the url to the parent directory */    parentURL = CFURLCreateCopyDeletingLastPathComponent(NULL, url);    if (parentURL != NULL) {            /* convert the URL to a FSRef */        if (CFURLGetFSRef(parentURL, &amp;parentDirectory)) {                /* get the leaf name from the URL */            fileNameRef = CFURLCopyLastPathComponent(url);            if (fileNameRef != NULL) {                    /* get the leaf name from the URL */                nameStringPtr = CFStringGetCharactersPtr(fileNameRef);                if (nameStringPtr != NULL) {                        /* create the file */                    err = FSCreateFileUnicode(                        &amp;parentDirectory,                        CFStringGetLength(fileNameRef),                        nameStringPtr,                        whichInfo, catalogInfo,                        newFileReference, NULL);                }                    /* release the file name */                CFRelease(fileNameRef);            }        }            /* release the parent url */        CFRelease(parentURL);    }        /* return the status value */    return err;}</pre></TD></TR><TR><td align="left"><P><B>Listing 3.</B>  An example of how one could create a filereferenced by a CFURL using the <CODE>FSCreateFileUnicode</CODE> routine.</P></TD></TR></TABLE></CENTER><BR><BR><P><A HREF="#top">Back to top</A></P><A NAME=advanced></A><H2>Advanced routines for using typeFileURL</H2><P>Sample code presented in this document was chosen for illustrationand was designed to present ideas.  More advanced users may wish toconsult sample code listings provided in the attached download fileThese source files include examples showing how to:</P><UL><LI>Implement Apple event coercion handlers for automatic conversion to/from <CODE>typeFileURL</CODE><CODE>typeChar</CODE>, <CODE>typeStyledText</CODE>, <CODE>typeUnicodeText</CODE>, <CODE>cFile</CODE>, typeFSS, typeFSRef, typeAlias,and <CODE>typeObjectSpecifier</CODE><BR><BR></LI><LI>Utility routines for using typeFileURL records in Apple event records.<BR><BR></LI></UL><P><A HREF="#top">Back to top</A></P><A NAME=Downloads></A><H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (72K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn2022.pdf">Download</A></P>               </TD>            </TR>            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/bluebook.gif" width=22 height=23 align=bottom alt="Bluebook gif"></P>               </TD>               <td align="left">                  <P>Sample code listings (12K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="downloads/tn2022.hqx">Download</A></P>               </TD>            </TR>         </TABLE>         <BR>                  <P><A HREF="#top">Back to top</A></P>         </TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn2022.html%3Fid%3DDTS10003059-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn2022.html%3Fid%3DDTS10003059-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn2022.html%3Fid%3DDTS10003059-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>