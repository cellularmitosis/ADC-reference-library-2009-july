/***	File:			SampleFilterPanel.c****	Description: The functions in this file control the "Sample Filter Settings"**	panel UI for the SampleFilter.	****	Version:	1.0	****	Copyright 1999 Apple Computer. All rights reserved.****	You may incorporate this sample code into your applications without**	restriction, though the sample code has been provided "AS IS" and the**	responsibility for its operation is 100% yours.  However, what you are**	not permitted to do is to redistribute the source as "ABC Sample Code"**	after having made changes. If you're going to re-distribute the source,**	we require that you make it clear in the source that the code was**	descended from Apple Sample Code, but that you've made changes.***/#include <Sound.h>#include <Resources.h>#include <string.h>#include <Scrap.h>#include "PSOutputFilters.h"#include "DebugMisc.h"#include "Macros.h"#include "SampleFilterMain.h"#include "SampleFilterPanel.h"#include "SampleFilterResources.h"#include "SampleFilterHints.h"#define DELETEKEY 0x08#define LEFTKEY 0x1c#define RIGHTKEY 0x1d#define UPKEY 0x1e#define DOWNKEY 0x1f#define MAXDIGITS 50enum {	kForTextST = 1,	kForTextET,	kCustomHeaderCheckBox,	kPageCommentST,	kPagesCommentNone,	kPagesCommentFirstOnly,	kPagesCommentAll};typedef struct SampleData{	Collection jobHints;	kHintTextVar text;	Boolean doCustomHeaderComment;	PagesCommentMode pagesComment;	short fRef;}SampleData;const Byte sampleTextDefault[] = "\pSample";static OSStatus saveCustomData(Collection plugInPrInfo, SampleData *ourData);static OSStatus getSavedCustomData(Collection jobHints, Collection plugInPrInfo, SampleData *ourData);static Boolean isTextShortEnough(DialogPtr dp, short len, short maxLen);static OSStatus getJobHintsOrDefaults(Collection jobHints, Collection plugInDefaults, 										CollectionTag tag, long id, SInt32 *size, void *itemData);static OSStatus saveCustomData(Collection plugInPrInfo, SampleData *ourData){	OSStatus err = noErr;	ckAssert(plugInPrInfo != NULL);	if(plugInPrInfo){		// add our configuration hint data to the collection that is passed in.		err = AddCollectionItem(plugInPrInfo, kHintTextTag, kHintTextId, sizeof(kHintTextVar), ourData->text);		if(!err)err = AddCollectionItem(plugInPrInfo, kHintCustomHeaderTag, kHintCustomHeaderId, 												sizeof(kHintCustomHeaderVar), &ourData->doCustomHeaderComment);		if(!err)err = AddCollectionItem(plugInPrInfo, kHintPagesCommentTag, kHintPagesCommentId, 												sizeof(kHintPagesCommentVar), &ourData->pagesComment);	}		return err;}	static OSStatus getSavedCustomData(Collection jobHints, Collection plugInPrInfo, SampleData *ourData){	OSStatus err = noErr;	long size;	ckAssert(plugInPrInfo != NULL);		size = sizeof(kHintTextVar);		err = getJobHintsOrDefaults(jobHints, plugInPrInfo, kHintTextTag, kHintTextId, &size, ourData->text);	// if the hint does not exist in the job or prefs collection then we'll use our default	if(err == collectionItemNotFoundErr) {		err = noErr;		memcpy(ourData->text, sampleTextDefault, sampleTextDefault[0]+1);	}	if(!err){		size = sizeof(kHintCustomHeaderVar);		err = getJobHintsOrDefaults(jobHints, plugInPrInfo, kHintCustomHeaderTag, kHintCustomHeaderId, 										&size, &ourData->doCustomHeaderComment);		// if the hint does not exist in the job or prefs collection then we'll use our default		if(err == collectionItemNotFoundErr) {			err = noErr;			ourData->doCustomHeaderComment = kHintCustomHeaderDef;		}	}	if(!err){		size = sizeof(kHintPagesCommentVar);		err = getJobHintsOrDefaults(jobHints, plugInPrInfo, kHintPagesCommentTag, kHintPagesCommentId, 										&size, &ourData->pagesComment);		// if the hint does not exist in the job or prefs collection then we'll use our default		if(err == collectionItemNotFoundErr) {			err = noErr;			ourData->pagesComment = kHintPagesCommentDef;		}	}		return(err);}	static OSStatus getJobHintsOrDefaults(Collection jobHints, Collection plugInDefaults, 										CollectionTag tag, long id, SInt32 *size, void *itemData){	OSStatus err = noErr;	ckAssert(jobHints != NULL);	ckAssert(plugInDefaults != NULL);	ckAssert(size != NULL);	ckAssert(itemData != NULL);	// first try in job Collection	err = GetCollectionItem(jobHints, tag, id, size, itemData);	// if the collection item does not exist in the job hints then check the printer's default collection	if(err == collectionItemNotFoundErr){		err = GetCollectionItem(plugInDefaults, tag, id, size, itemData);	}	return err;}												OSStatus samplePrSpecificInitData(void *dataP, Collection plugInPrInfo){	OSStatus err = noErr;	SampleData *ourDataP = (SampleData *)dataP;		if(ourDataP != nil)				err = getSavedCustomData(ourDataP->jobHints, plugInPrInfo, ourDataP);	else		ckAssert(false);		// should not happen		return(err);}OSStatus samplePrSpecificCloseData(void *dataP, Boolean doIt){	OSStatus err = noErr;		Unused(dataP);	Unused(doIt);			return(err);}OSStatus sampleCloseData(void *dataP, Boolean doIt){	OSStatus err = noErr;	SampleData *ourDataP = (SampleData *)dataP;		/* 	This routine is called when our filter is being unloaded. doIt will		be true if the filter is being unloaded as part of the user selecting		OK or Save in the Print Dialog, otherwise it will be false. If doIt		is true we need to configure our private job collection so that it		reflects the current user settings.		*/	if(doIt && ourDataP){		err = saveCustomData(ourDataP->jobHints, ourDataP);	}			/*		This is the last panel specific routine that is called before our		filter is unloaded so we need to dispose of our private panel data.	*/		if(ourDataP)		DisposePtr((char *)ourDataP);			return(err);}OSStatus sampleInitData(void *dataP, Collection plugInHints){	SampleData *ourDataP = (SampleData *)dataP;		/*		Our filter is being loaded and we need to save off our private hints		collection corresponding to the current print job.	*/	ourDataP->jobHints = plugInHints;	return noErr;}OSStatus samplePrSpecificInit(void *dataP, DialogPtr dp, short offset){	OSStatus err = noErr;		/*		This routine is called when our panel becomes visible or the panel is		visible and the user changes printers. We need to set the controls in		our panel to reflect our current job settings.	*/	if(dataP) {		SampleData *ourDataP = (SampleData *)dataP;		setText(dp, kForTextET + offset, ourDataP->text);		SelectDialogItemText(dp, kForTextET + offset, 0, 0x7f);		setControl(dp, kCustomHeaderCheckBox + offset, ourDataP->doCustomHeaderComment);		setRadio(dp, kPagesCommentNone + offset, kPagesCommentAll + offset, 							kPagesCommentNone + offset + ourDataP->pagesComment);	}	return(err);}OSStatus samplePrSpecificClose(void *dataP, DialogPtr dp, short offset){	OSStatus err = noErr;		/*		This routine is called when our panel goes away or the user is		switching printers to a new printer. The panel can go away because		the user switches panels or dismisses the Print Dialog. This filter		has no need to do any cleanup or other work at this point.	*/	Unused(dataP);	Unused(dp);	Unused(offset);		return(err);}OSStatus sampleInit(void *dataP, DialogPtr dp, short offset){	OSStatus err = noErr;	Unused(dataP);	Unused(dp);	Unused(offset);		return(err);}OSStatus sampleClose(void *dataP, DialogPtr dp, short offset){	OSStatus err = noErr;	Unused(dataP);	Unused(dp);	Unused(offset);	/* 		The panel is going away because the user switched panels or		dismissed the dialog. This is the last opportunity to read		any data from the controls in this panel.				This filter has no need to read any data from the panel because		its settings data always reflects the panel UI. That is done in our		sampleItem procedure below. 	*/	return(err);}OSStatus sampleItem(void *dataP, DialogPtr dp, short item, short offset, short ctlVal){	OSStatus err = noErr;	SampleData *ourDataP = (SampleData *)dataP;	Unused(dp);	Unused(ctlVal);		if(ourDataP) {		/*			We must subtract offset from the item value passed in so that we can			compare to the DITL item numbers in our DITL		*/		switch(item - offset) {			case kForTextET:		 		getText(dp, kForTextET + offset, ourDataP->text);		 		if(ourDataP->text[0] > MAXDIGITS)		 			ourDataP->text[0] = MAXDIGITS;				break;						/*	For check boxes the control value passed is the check box state				as long since this filter has a 'desC' resource that corresponds				to the DITL. All we have to do is update our settings				to reflect the control state.			*/			case kCustomHeaderCheckBox:				ourDataP->doCustomHeaderComment = ctlVal;				break;							/*	For grouped radio buttons, LaserWriter 8 worries about setting				the radio control values to be current since since this filter has				a 'desC' resource that corresponds to the DITL. All we have to				do is update our settings to reflect the current radio hit.			*/			case kPagesCommentNone:				ourDataP->pagesComment = kPagesNone;				break;						case kPagesCommentFirstOnly:				ourDataP->pagesComment = kPagesFirst;				break;			case kPagesCommentAll:				ourDataP->pagesComment = kPagesAll;				break;							default:				break;		}	}		return(err);}OSStatus sampleFilter(void *dataP, DialogPtr dp, short offset, EventRecord *ep, short *itemP, Boolean *weHandledItP){	OSStatus err = noErr;	SampleData *ourDataP = (SampleData *)dataP;	Boolean result = false;	short len;	long lOffset;		Unused(offset);	Unused(itemP);		if(ourDataP) {		switch(ep->what) {		 case keyDown:		 case autoKey:			if(ep->modifiers & cmdKey){				Handle h;				switch(ep->message & 0xdf) {				 case 'V':					h = NewHandle(0L);					if(h) {						len = GetScrap(h, 'TEXT', &lOffset);						HLock(h);						result = isTextShortEnough(dp, len, MAXDIGITS);						DisposeHandle(h);					}					break;				 default:				 	result = true;				 	break;				}			} else {								unsigned char charCode = (unsigned char) (ep->message & charCodeMask);				switch(charCode) {				 case DELETEKEY:				 case LEFTKEY:				 case RIGHTKEY:				 case UPKEY:				 case DOWNKEY:				 	result = true;					break;				 default:					result = isTextShortEnough(dp, 1, MAXDIGITS);					break;				}			}			if(!result){				*weHandledItP = true;				SysBeep(5);			}			break;		}	}	return(err);}static Boolean isTextShortEnough(DialogPtr dp, short len, short maxLen){	Boolean result = true;	TEHandle textH = ((DialogPeek)dp)->textH;	TEPtr textP;	short selStart;		textP = *textH; //unlocked	selStart = textP->selStart;	if( (textP->teLength + textP->selStart - textP->selEnd + len) > maxLen ) {		result = false;	}	return(result);}OSStatus sampleCheckRange(void *dataP, DialogPtr dp, short offset, Boolean *doItP){	OSStatus err = noErr;	SampleData *ourDataP = (SampleData *)dataP;	Str255 text;	getText(dp, kForTextET + offset, text);	// make sure our resource fork is the current resource file before we get any resources	if(ourDataP->fRef != -1) {		short holdResFile = CurResFile();		UseResFile(ourDataP->fRef);				// we have an alert if there is no text and we are called		if(text[0] == 0){			StopAlert(kNeedTextALRT, nil);			*doItP = false;		}else{			// we also have an alert if there is too much text and we are called			if(text[0] > MAXDIGITS){				StopAlert(kTooMuchTextALRT, nil);				*doItP = false;			}		}		UseResFile(holdResFile);	}		return(err);}OSStatus sampleSaveButton(void *dataP, Collection plugInPrInfo){	OSStatus err = noErr;	SampleData *ourDataP = (SampleData *)dataP;		if(ourDataP != nil){		// we'll save our current settings into the prefs collection we are passed		err = saveCustomData(plugInPrInfo, ourDataP);	}	return(err);}OSStatus sampleAddMenu(void *dataP, StringPtr menuNameStr, unsigned long bufSize, Boolean *addItP){	OSStatus err = noErr;	SampleData *ourDataP = (SampleData *)dataP;		// make sure our resource fork is at the top of the resource chain	if(ourDataP->fRef != -1) {		Handle stringResH = NULL;		short holdResFile = CurResFile();				UseResFile(ourDataP->fRef);		stringResH = Get1Resource('STR ', kPanelMenuName);		if(stringResH) {			short bytesToMove = **stringResH + 1;			if(bytesToMove > bufSize){				bytesToMove = bufSize;				**stringResH = bytesToMove - 1;			}			BlockMove(*stringResH, (Ptr)menuNameStr, bytesToMove);			ReleaseResource(stringResH);		} else {			ckAssert(false);			err = ResError();			if(!err) {				err = resNotFound;			}		}		UseResFile(holdResFile);	}		*addItP = err ? false : true;		return(err);}OSStatus sampleRegisterPanel(short *ditlIDP, void **dataH, void *libDataP){	OSStatus err = noErr;	SampleData *ourDataP;		// allocate and initialize the private data for this panel	ourDataP = (SampleData *)NewPtrClear(sizeof(SampleData));	if(ourDataP) {		*ditlIDP = kFirstPanelDITL;		ourDataP->fRef = (short)libDataP;		// store the fRef data				*dataH = ourDataP;	} else {		err = MemError();		*dataH = NULL;	}		return(err);}