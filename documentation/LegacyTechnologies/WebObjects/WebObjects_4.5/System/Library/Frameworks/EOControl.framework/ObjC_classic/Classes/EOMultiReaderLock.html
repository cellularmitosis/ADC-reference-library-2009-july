<HTML>		<HEAD>		<TITLE>			EOMultiReaderLock		</TITLE>		</HEAD>	<body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOControl Reference</font><br><br><!--end of path --><a href="../EOControlTOC.html"><img src="../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> <BR><h1><FONT COLOR="#000066"><a name="//apple_ref/java/cl/EOMultiReaderLock">EOMultiReaderLock</a></FONT></h1><br><blockquote><dl><dt><b>Inheritsfrom: </b></dt><dd> NSObject</dd></dl></blockquote><blockquote><dl><dt><b>Package: </b></dt><dd>com.apple.yellow.eocontrol</dd></dl></blockquote><HR SIZE=4><br><h2>Class Description</h2><hr><p>The EOMultiReaderLock class provides EnterpriseObjects Framework with reader and writer locks.</p><br><table border = "0" BGCOLOR="#E6E6E6"><tr><td scope="row"><b>Note: </b>Thisclass doesn't exist in the Java Client package, com.apple.client.eocontrol.Multithreaded clients aren't yet supported. All the client-sidelocks in Java Client application's are no-ops.</td></tr></table><br><p>The locks are recursive; a single thread can request a lockmany times, but a lock is actually taken only on the first request.Likewise, when a thread indicates it's finished with a lock, ittakes an equal number of <b>unlock...</b> invocationsto return the lock.</p><p>There's no limit on the number of reader locks that a processcan take. However, there can only be one writer lock at a time,and a writer lock is not issued until all reader locks are returned.Reader locks aren't issued to new threads when there is a threadwaiting for a writer lock, but threads that already have a readerlock can increment their lock count.</p><p>Thread safety is maintained with mutex locks (binary semaphores),which ensure that no more than one critical section of code canbe processed at a time. The queuing order of requests for writerlocks is not managed by the class; the underlying implementationof mutex signaling manages the queue order.</p><p>EOMultiReaderLock correctly handles promotion of a readerlock to a writer lock, and the extension of a reader lock to thecurrent writer. This prevents a thread from deadlocking on itselfwhen requesting a combination of lock types.</p><p>EOMultiReaderLocks are slightly more time-expensive than NSRecursiveLocksbecause the recursion count has to be stored per-thread, causingeach request for a reader lock to incur a hash. Writer locks areeven more expensive because EOMultiReaderLock must poll the hashtableuntil all reader locks have been returned before the writer lockcan be taken.</p><br><BR><BR><h2>Instance Methods</h2><hr><a name = "CIEHGEGE"><BR><h3><a name="//apple_ref/java/instm/EOMultiReaderLock/lockForReading">lockForReading</a></h3></a><p><code>public void <b>lockForReading</b>()</code></p>Acquires a reader lock for the current thread.If the current thread doesn't already have a lock, the methodblocks if there are any waiting or active writer locks. If the currentthread already has a lock (reader or writer), the lock request countis incremented.<hr WIDTH=25% ALIGN=LEFT><a name = "CIEHIHGB"><BR><h3><a name="//apple_ref/java/instm/EOMultiReaderLock/lockForWriting">lockForWriting</a></h3></a><p><code>public void <b>lockForWriting</b>()</code></p>Gets a writer lock for the current thread. Ifthe current thread already has one, the lock request count is incremented,but a new lock is not taken. If the requesting thread has outstandingreader locks, they are temporarily dropped until the writer lockis returned. If other threads have outstanding reader locks, thismethod blocks until all reader locks have been freed.<hr WIDTH=25% ALIGN=LEFT><a name = "CIEIJGID"><BR><h3><a name="//apple_ref/java/instm/EOMultiReaderLock/tryLockForReading">tryLockForReading</a></h3></a><p><code>public boolean <b>tryLockForReading</b>()</code></p>Returns true if the current thread is able toimmediately obtain a reader lock. There are three ways this canhappen:<ol><li>There are no outstanding writer locks.</li><li>The writer lock is held by the current thread.</li><li>The current thread already has a reader lock.</li></ol><p>Thismethod implicitly calls <b>lockForReading</b>,so you must call <b>unlockForReading</b> if <b>tryLockForReading</b> returns true.</p><hr WIDTH=25% ALIGN=LEFT><BR><h3><a name="//apple_ref/java/instm/EOMultiReaderLock/tryLockForWriting">tryLockForWriting</a></h3><p><code>public boolean <b>tryLockForWriting</b>()</code></p>Returns true if the current thread is able toimmediately obtain a writer lock. Returns false if another threadalready has the lock or is queued to receive it. This method implicitlycalls <b>lockForWriting</b>, so you must call <b>unlockForWriting</b> if <b>tryLockForReading</b> returns true.<hr WIDTH=25% ALIGN=LEFT><a name = "CIEGIICE"><BR><h3><a name="//apple_ref/java/instm/EOMultiReaderLock/unlockForReading">unlockForReading</a></h3></a><p><code>public void <b>unlockForReading</b>()</code></p>Releases a reader lock for the current thread.Each <b>lockForReading</b> message must be pairedwith an <b>unlockForReading</b> message beforethe lock is actually released. Invoking this method when the lock countis zero does nothing.<hr WIDTH=25% ALIGN=LEFT><a name = "CIEEHHHJ"><BR><h3><a name="//apple_ref/java/instm/EOMultiReaderLock/unlockForWriting">unlockForWriting</a></h3></a><p><code>public void <b>unlockForWriting</b>()</code></p>Releases a writer lock for the current thread.Each <b>lockForWriting</b> message must be pairedwith an <b>unlockForWriting</b> message beforethe lock is actually released. When the writer lock is released,it checks to see if the thread previously had any reader locks.If so, the reader lock count is restored. Invoking this method whenthe lock count is zero does nothing.<hr WIDTH=25% ALIGN=LEFT><BR><br><a href="../EOControlTOC.html"><img src="../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> </BODY></HTML>