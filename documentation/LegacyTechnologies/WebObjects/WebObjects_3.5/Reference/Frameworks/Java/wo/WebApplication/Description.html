<html>

<body bgcolor="#FFFFFF">

<CENTER><H1>Class next.wo.WebApplication</H1></CENTER>

<a name="description"></a><CENTER><H2>CLASS DESCRIPTION</H2></CENTER>

<!-- extends:next.util.NextObject -->

<DL>

  <DT>

    <B>Extends:</B>

  <DD>

    next.util.NextObject

</DL>

<HR>

<A name="classAtAGlance"></A>

<CENTER>

  <H2>

    CLASS AT A GLANCE

  </H2>

</CENTER>

<P>
<h4>Purpose</h4>
<P>
A WebApplication object receives an HTTP request from an adaptor, manages the request-response loop that processes the request, and returns a response to the adaptor. It also manages sessions, caches component definitions and page instances, and offers localization, debugging, and error-handling support.
<H4>Principal Attributes</h4>
<UL>
<LI>Application bundle
<LI>Session store
<LI>Page and component-definition caches
<LI>Current adaptors
</UL>
<H4>Creation</H4>
Created in default application <B>main</B> (<B>WODefaultMain</B>)

<br>
WebApplication()
<H4>Commonly Used Methods</H4>
<TABLE><TR>
<TD> pageWithName </td>
<td>Returns a Component (page) instance identified by name.</td>
</TR><TR>
<TD>awake</td><TD>Allows custom application initializations during the start of a request-response cycle.</td>
</TR><TR>
<td>takeValuesFromRequest<BR>invokeAction<BR>appendToResponse</td><td>These three methods allow custom application logic during the value-extraction, action-invocation, and HTML-generation phases of the request-reponse loop.</td>
</TR><TR>
<td> setTimeOut </td><td>Sets the period of inactivity after which the application process stops executing.</td>
</TR><TR>
<td> setPageCacheSize </td><td>Sets the number of page instances cached in the session by the application.</td>
</TR><TR>
<td> setCachingEnabled</td><td>Controls whether the application caches component definitions.</td>
</TR>
</table>
<BR>
<hr>	
<BR>
<A name="description"></A>

<CENTER>

  <H2>

    CLASS DESCRIPTION

  </H2>

</CENTER>

<P>

The primary role of the WebApplication class is to coordinate the handling

of HTTP requests. Each application must have exactly one WebApplication object

(or, simply, <I>application object</I>). The application object receives client

requests from an HTTP server adaptor, manages the processing that generates

a response, and returns that response--typically an object representing a

web page--to the adaptor. The adaptor, in turn, forwards the response in

a suitable form to the HTTP server that originated the request.

<P>

In handling requests, an application object creates and manages one or more

sessions; a session (represented by a WebSession object) dedicates resources

to a period of access by a single user and stores persistent state during that period.
Conceptually, each cycle of the request-response loop (or <I>transaction</I>)

takes place within a session.

<P>

Besides acting as a facilitator between the adaptor and the rest of the

application during request handling, WebApplication performs many secondary

functions. It returns pages based on component name, caches page instances

and component definitions, provides

some facilities for error handling and script debugging, and furnishes a

variety of data, such as the base URL and the current Context object.

<P>

Typical deployment schemes balance the processing load by having multiple

application instances per server adaptor. A single application, in turn,

can interact with multiple adaptors; for example, an application can

simultaneously communicate with secure-socket and Distributed Object adaptors

as well as HTTP adaptors.

<P>

You can instantiate ready-made application objects from the WebApplication class or you can obtain the application object from a custom subclass of WebApplication. Custom WebApplication subclasses are common in WebObjects applications since there is often a need to override the <b>awake</b>, <b>sleep</b>, <b>init</b>, and request-handling methods. Compiled WebApplication subclasses can take any name, but if the name is anything other than "Application" you must implement your own <b>main</b> function to instantiate the application object from this class. However, if the class name is "Application," you don't need to modify <b>main</b>. In scripted
applications, the code in the <B>Application.wos</B> file becomes the
implementation logic of a WebApplication subclass automatically created at
run time; the application object is instantiated from this subclass. <BR>

<BR>

<H2>

  The Application Run Loop

</H2>

<P>

When a WebObjects application is launched from the command line, either manually

or automatically ("autostarting"), the <B>main</B> function is called. In

<B>main</B> the WebApplication subclass for the application is loaded. This

class sets up for request handling by:

<OL>

  <LI>

    Parsing the command-line arguments <BR>

  <LI>

    Creating and initializing an application instance <BR>

  <LI>

    Instantiating the adaptors with which the application will communicate <BR>

</OL>

<P>

The application instance then has its <B>run</B> method invoked; in this

method it registers its adaptors to receive run-loop events and then starts

a run loop. The application remains in this run loop until it either times

out, receives a <B>terminate</B> message, or has its process externally stopped.

<P>

The events that initiate each cycle of the run loop are not, as in a typical

non-web application, user actions such as mouse clicks or key presses. Instead

they are HTTP requests originating from client browsers. A browser sends

an HTTP request (according to the URL specified) to an HTTP server, which

then "talks" with a WebObjects adaptor customized for that server. The adaptor

packages the request in a Request object and invokes the application object's

<B>handleRequest</B> method. The receipt of this message initiates a cycle

of the <I>request-response loop</I>, a three-phase cycle that handles the

request and returns (in most cases) a response in the form of a Web page.

Each phase of the cycle centers around a message propagated from the application

object to all other "interested" objects in the application:

<UL>

  <LI>

    takeValuesFromRequest

  <LI>

    invokeAction

  <LI>

    appendToResponse

</UL>

<!--Need to provide links for the following chapters, or just to the DevGuide and Serving WO -->
<P>

For more on the request-response loop, see the <A HREF="../../../../../DevGuide/DevGuideTOC.html" target=_top><i>WebObjects Developers Guide</i></A>. For information on

valid command-line arguments for launching an application, see the "<a href="../../../../../ServingWebObjects/ManualStarting.html" target=_top>Manually

Starting WebObjects Applications</a>" section of the <i>Serving WebObjects</i> document.

<BR>

<BR>

<A name="Caching"></A>

<H2>

  <A name="Caching">Caching Strategies</A>

</H2>

<P>

The WebApplication object implements or controls three kinds of caching.

You turn caching off or on in each case for reasons ranging from performance

enhancement to page integrity or ease of debugging.

<DL>

  <DT>

    <B>Component-definition caching</B> <BR>

  <DD>

    Component definitions are compact programmatic descriptions of components

    (pages or subcomponents), and are used to create instances of those components.

    When a page of an application is requested the first time, an application

    parses the HTML, declaration (".wod"), and implementation files in the component

    directory (".wo"), creates an internal representation of the component (the

    component definition), and instantiates the Component object from it. If

    caching is enabled, it stores the component definition in memory. If not,

    the application must reparse the files in the component directory every time

    that page is revisited.

    <P>

    You turn component-definition caching off and on with the

    <B>setCachingEnabled</B> method. By default, it is disabled. The advantage

    of having this kind of caching disabled is that you can edit a scripted component

    without having to relaunch the application every time to check the results.

    However, you should always enable component-definition caching when you deploy

    an application since performance improves significantly when you do. You

    can also control caching of individual component definitions using an identically

    named Component method. Selective caching is an especially valuable technique

    for very large applications where only the most common components and pages

    should be cached. <BR>

    <BR>

  <DT>

    <B>Page-instance caching</B> <BR>

  <DD>

    In normal processing of requests, an application caches at least one page instance. It does this because the lifecycle of a page overlaps transaction boundaries: a page "begins" by having its HTML generated and "ends" when the user navigates to a new page, which replaces the previous page in the browser. Because the application caches the page instance that once represented the response page, it can easily make it the request page for the next transaction.
<P>
Page-instance caching also facilitates backtracking in the client browser. It

    works like this: At the end of a request-response cycle, the application

    object stores the Component instance representing the response page in the

    session. When the user backtracks to this page, the instance is restored

    from the session object, enabling the page to display things as they were

    when the user visited it the previous time. By default, page-instance caching

    is enabled, with a cache limit of 30 pages.

    <P>

    You turn page-instance caching off by sending <B>setPageCacheSize</B> to

    the application object with an argument of zero. In this case, when the user

    backtracks to a page, the page is not stored in the session and so must be

    re-created "from scratch"; it will show none of its previous state. This

    situation is sometimes what is appropriate for certain applications. If you

    wish, you can also turn this feature off and implement your own selective

    page-caching scheme. Because page storage uses up application memory, you

    should test for the optimum cache size before you deploy an application with

    page-instance caching turned on. <BR>

    <BR>

  <DT>

    <B>Client caching</B> <BR>

  <DD>

    Usually client browsers cache pages (as HTML code) so they can redisplay

    them when users backtrack to them. You can turn off client caching by setting

    the date and the expiration time in the response page's headers to the current

    date and time. The client, however, retains the URL for the page. When the

    user backtracks to the page, the client resends the URL to the server, which

    returns a page based on a restored component instance. 

    <P>

    WebObjects turns off client caching for you when you send the application

    object <B>setPageRefreshOnBacktrackEnabled</B> with an argument of

    <B>true</B>. This setting is valuable when you do not want the client to

    backtrack to a page that would be obsolete because of changes that might

    occur in the session. In particular, if you are using DisplayGroup's batch

    and selection-management functionality, you should turn off client caching.

</DL>

<P>

<BR>

<BR>

<H2>

  <A name="Localization">Localization</A>

</H2>

<P>

Localization in WebObjects depends on an array of languages stored (as String

objects) in the WebSession object using WebSession's <B>setLanguages</B>.

The order of languages in the array indicates the preferred order. The language

names in the array should map to "<I>Language</I>.lproj" subdirectories of

the ".woa" directory. Thus, if there is a "French" item in the array, there

should be a French.lproj subdirectory. The ".lproj" directories should contain

everything that has localized content: ".strings" tables, sounds, images,

and so on. Because the application first looks for resources in localized

".lproj" directories and then in a non-localized location, be sure there

are no files of the same name in localized locations when no localization

is supposed to occur.

<P>

The ".strings" file contains a simple property list that maps common keys

to words, phrases, or sentences in a particular language. For instance, a

Session.strings file in English.lproj might have the following content:<BR>

<PRE>{

    buttonTitle = "Submit your request";

}

</PRE>

<P>

<BR>

<P>

The Session.strings file in French.lproj would have the following:<BR>

<PRE>{

    buttonTitle = "Soumettez votre requete";

}

</PRE>

<P>
You might want to have localized versions of a component's HTML file as well. If you do this, you must place the file inside of an ".lproj" directory in the component. For example, you would have this directory structure:
<PRE>	English.lproj/
		MyApplicationWide.strings
	French.lproj/
		MyApplicationWide.strings
	Main.wo/
		English.lproj/
			Main.html
		French.lproj
			Main.html
</PRE>
<P>
<BR>

<P>

<B>Note</B>: You can determine the language of the request sender by getting

the value of the Request object's "accept-language" header. This returns

a two-character value ("en", "fr", and so on) that you can then map to the

language subdirectory.<BR>

<BR>

<BR>

<H2>

  Error Handling and Debugging

</H2>

<P>

WebApplication offers developers some assistance in the areas of debugging

and error handling.

<UL>

  <LI>

    You can invoke the <B>logString</B> method at critical points in your code

    to print debugging messages to the standard error device.<BR>

    <BR>

  <LI>

    For handling exceptions that arise during request handling, WebApplication

    gives the <B>handleException</B> method as well as methods for handling errors

    occurring at specific points in the request-response loop (for example,

    <B>handlePageRestorationError</B>). The default implementation of these methods

    prints debugging information on the browser page; you can override them to

    implement "friendlier" or more elaborate error handling.<BR>

    <BR>

  <LI>

    A WebObjects application can print diagnostic messages to the standard output

    device when it parses HTML code, (for example, when it encounters unbalanced

    containers). You can turn this feature off and on with the

    <B>setPrintsHTMLParserDiagnostics</B> method.

</UL>

<P>

<hr>

<!-- constructors -->

<a name="constructors"><CENTER><H2>CONSTRUCTORS</H2></CENTER></a>

<!-- consKey:WebApplication(public) cons:WebApplication descr:<TT>public  <B>WebApplication</B>()</TT> -->

<H3><a name="WebApplication(public)">WebApplication</a></H3>

   <TT>public  <B>WebApplication</B>()</TT>

<P>

Initializes and returns a WebApplication object.This constructor initializes

application attributes, and

initializes the adaptor or adaptors specified on the command line. If no

adaptor is specified, DefaultAdaptor is made the default adaptor. Some

of the more interesting attribute initializations are:

<UL>

  <LI>

    Session store is in the server.

  <LI>

    Page cache size is 30 pages.

  <LI>

    Client caching of pages is enabled (<B>isPageRefreshOnBacktrackEnabled</B>

    returns <B>false</B>).

  <LI>

    Component-definition caching is disabled (<B>isCachingEnabled</B> returns

    <B>false</B>).

</UL>

<P>

A exception is thrown if initialization does not succeed. 

<hr>

<!-- methods -->

<a name="methods"><CENTER><H2>METHODS</H2></CENTER></a>

<!-- methKey:activeSessionsCount(public) meth:activeSessionsCount descr:<TT>public int <B>activeSessionsCount</B>()</TT> -->

<H3><a name="activeSessionsCount(public)">activeSessionsCount</a></H3>

<TT>public int <B>activeSessionsCount</B>()</TT>

<P>

Returns the number of sessions that are currently active. (A session is active if it has not yet timed out.)
<P>
The number returned here is only accurate if the application stores state in memory in the server, which is the default. If you use a custom state-storage strategy, there may be no way to tell how many sessions are active for a given application instance.
<P>
<B>See Also: </B><B>minimumActiveSessionsCount</B>, <B>setMinimumActiveSessionsCount</B>
<hr>

<!-- methKey:adaptorWithName(public) meth:adaptorWithName descr:<TT>public next.wo.Adaptor <B>adaptorWithName</B>(java.lang.String <I>aString</I>, next.util.ImmutableVector <I>anImmutableVector</I>)</TT> -->

<H3><a name="adaptorWithName(public)">adaptorWithName</a></H3>

<TT>public next.wo.Adaptor <B>adaptorWithName</B>(java.lang.String <i>aName</i>, next.util.ImmutableVector <i>someArguments</i>)</TT>

<P>

Invoked in the constructor to create an adaptor. If you subclass Adaptor, you specify the Adaptor subclass you want the application to use with the <b>-a</b> option on the application's command line. When WebApplication encounters the <b>-a</b> option, it invokes this method. This method looks for a subclass of Adaptor with the name <i>aName</i> (which was supplied as the <b>-a</b> option's argument), and if such a class exists, a new instance is created. The <i>someArguments</i> array is populated with any adaptor-specific options (such as <b>-p</b> or <b>-q</b>) that follow the adaptor name on the command line. See the <a href="../Adaptor/Adaptor.html" target="_top">Adaptor</a> class for more information. 
<P>

<B>See Also: </B><b>adaptors</b>
<hr>

<!-- methKey:adaptors(public) meth:adaptors descr:<TT>public next.util.ImmutableVector <B>adaptors</B>()</TT> -->

<H3><a name="adaptors(public)">adaptors</a></H3>

<TT>public next.util.ImmutableVector <B>adaptors</B>()</TT>

<P>

Returns the current list of application adaptors. A WebApplication can have multiple adaptors. (To associate the WebApplication with multiple adaptors, you specify each adaptor on the application's command line using the <b>-a</b> option.) This allows you to design an application that can not only listen to a socket for incoming HTTP requests (using the DefaultAdaptor), but can also receive remote request messages using more advanced RPC mechanisms such as DO, CORBA, and DCOM.

<hr>

<!-- methKey:appendToResponse(public) meth:appendToResponse descr:<TT>public void <B>appendToResponse</B>(next.wo.Response <I>aResponse</I>, next.wo.Context <I>aContext</I>)</TT> -->

<H3><a name="appendToResponse(public)">appendToResponse</a></H3>

<TT>public void <B>appendToResponse</B>(next.wo.Response <I>aResponse</I>, next.wo.Context <I>aContext</I>)</TT>

<P>

The WebApplication object sends this message to itself to initiate the last

phase of request handling. This occurs right after the

<B>invokeAction</B> method has completed, typically with the return

a response page. In the append-to-response phase, the application objects

(particularly the response component itself) generate the HTML content of

the page. WebApplication's default implementation of this method forwards

the message to the session object.

<P>

<B>See Also: invokeAction</B>, <B>takeValuesFromRequest</B> 

<hr>

<!-- methKey:application(public) meth:application descr:<TT>public static next.wo.WebApplication <B>application</B>()</TT> -->

<H3><a name="application(public)">application</a></H3>

<TT>public static next.wo.WebApplication <B>application</B>()</TT>

<P>

Returns the WebApplication object for the current application. Since this

is a class method, it can be invoked from anywhere in an application:

<PRE>    WebApplication app = WebApplication.application()

</PRE>

<P>

This method is similar in purpose to WOApp, the global application object

in the Objective-C version of WebObjects. It may not be overridden.

<P>

<B>See Also: session</B>, <B>context</B> 

<hr>

<!-- methKey:awake(public) meth:awake descr:<TT>public void <B>awake</B>()</TT> -->

<H3><a name="awake(public)">awake</a></H3>

<TT>public void <B>awake</B>()</TT>

<P>

Invoked at the beginning of each cycle of the request-response loop, affording

the opportunity to perform initializations with application-wide scope. Since the

default implementation does nothing, overridden implementations do not have to call super().
<P>

<B>See Also: sleep</B> 

<hr>

<!-- methKey:baseURL(public) meth:baseURL descr:<TT>public java.lang.String <B>baseURL</B>()</TT> -->

<H3><a name="baseURL(public)">baseURL</a></H3>

<TT>public java.lang.String <B>baseURL</B>()</TT>

<P>

Returns the application URL relative to the server's document root, for example:

<B>/WebObjects/MyApp.woa</B>.

<P>

<B>See Also: name</B>, <B>path</B> 

<hr>

<!-- methKey:context(public) meth:context descr:<TT>public next.wo.Context <B>context</B>()</TT> -->

<H3><a name="context(public)">context</a></H3>

<TT>public next.wo.Context <B>context</B>()</TT>

<P>

Returns the application's current Context object. May not be overridden.

<P>

<B>See Also: </B><A href="../Context/Context.html" target=_top>Context</A>

class, <B>application</B>, <B>session</B> 

<hr>

<!-- methKey:createSession(public) meth:createSession descr:<TT>public next.wo.WebSession <B>createSession</B>()</TT> -->

<H3><a name="createSession(public)">createSession</a></H3>

<TT>public next.wo.WebSession <B>createSession</B>()</TT>

<P>

Creates and returns a WebSession object to manage a session for the application.

The method goes through several steps to locate the class to use for

instantiating this object:

<OL>

  <LI>

    First it looks for a compiled class of name "Session" that is a subclass

    of WebSession. 
<BR>

<BR>
  <LI>

    If such a class does not exist, it looks for a ".wos" script with the name

    of "Session" in the application wrapper (".woa" directory). 
<BR>

<BR>
  <LI>

    If the <B>Session.wos</B> script exists, the method parses the script and

    dynamically adds a scripted-class subclass of WebSession to the runtime.

</OL>

<P>

The method then returns an allocated and initialized (using the default

WebSession constructor) session instance of the selected class. It throws

an exception if it is unable to create a new session.

<P>

<B>Note: </B>An implication of the foregoing description is that the names

of compiled WebSession subclasses should be "Session"; if not, you will have

to override this method to use the proper class to create the session object.

<P>

<B>See Also: restoreSession</B>, <B>saveSession</B> 

<hr>

<!-- methKey:dynamicElementWithName(public) meth:dynamicElementWithName descr:<TT>public next.wo.DynamicElement <B>dynamicElementWithName</B>(java.lang.String <I>aString</I>, next.util.ImmutableHashtable <I>anImmutableHashtable</I>, next.wo.Element <I>anElement</I>)</TT> -->

<H3><a name="dynamicElementWithName(public)">dynamicElementWithName</a></H3>

<TT>public next.wo.DynamicElement <B>dynamicElementWithName</B>(java.lang.String <I>aName</I>, next.util.ImmutableHashtable <I>someAssociations</I>, next.wo.Element <I>anElement</I>)</TT>

<P>

Creates and returns a DynamicElement object based on the element's name, a dictionary of associations, and a template of elements. This method is invoked automatically to provide a DynamicElement object that represents a WEBOBJECT element in the HTML template. You don't ordinarily invoke <B>dynamicElementWithName</B>, but you might override it to substitute your own DynamicElement or reusable component for one of the built-in DynamicElements.
<P>The arguments <I>aName</I> and <I>someAssociations</I> are derived from a corresponding line in the declarations file. <I>aName</I> is a String that identifies the kind of element to create.  Generally <I>aName</I> specifies a built-in DynamicElement such as WOString, but it may also identify a reusable component. (For more information, see the chapter "<A HREF="../../../../../DevGuide/Reuse/ReuseTOC.html" target="_top">Using Reusable Components</A>" in the <i>WebObjects Developer's Guide</i>.) For example, in the <B>dynamicElementWithName</B> message for the following declaration:
<PRE>APP_STRING: WOString {value = applicationString;};
</PRE>
<P><I>aName</I> contains the string "WOString".
<P>The <I>someAssociations</I> dictionary contains an entry for each attribute specified in the corresponding declaration. For the declaration above, <I>someAssociations</I> contains a single entry for WOString's <B>value</B> attribute. The keys of <I>someAssociations</I> are the attribute names and the values are Association objects.
<P>WebApplication's implementation of <B>dynamicElementWithName</B> first searches for a DynamicElement named <I>aName</I>. If a DynamicElement is found, the method creates an instance and returns it. Otherwise, it searches for a component--either scripted or compiled--to return instead. If neither are found, this method returns <B>null</B>.

<hr>

<!-- methKey:handleException(public) meth:handleException descr:<TT>public next.wo.Response <B>handleException</B>(java.lang.Throwable <I>aThrowable</I>)</TT> -->

<H3><a name="handleException(public)">handleException</a></H3>

<TT>public next.wo.Response <B>handleException</B>(java.lang.Throwable <I>aThrowable</I>)</TT>

<P>

Invoked when an exception occurs within the request-response loop. The default

behavior displays a page with debugging information. You can override this

method to catch exceptions and display a "friendlier" error page.

<P>

<B>See Also: handlePageRestorationError</B>,

<B>handleSessionCreationError</B>, <B>handleSessionRestorationError</B> 

<hr>

<!-- methKey:handlePageRestorationError(public) meth:handlePageRestorationError descr:<TT>public next.wo.Response <B>handlePageRestorationError</B>()</TT> -->

<H3><a name="handlePageRestorationError(public)">handlePageRestorationError</a></H3>

<TT>public next.wo.Response <B>handlePageRestorationError</B>()</TT>

<P>

Called when a page (Component) instance cannot be restored, which typically

happens when a user backtracks too far. Specifically, this method is invoked

when the following occurs: the request is not the first of a session, page

restoration by context ID fails, and page re-creation is disabled. The default

behavior displays a page with debugging information. You can override this

method to display a "friendlier" error page.

<P>

<B>See Also: handleException</B>, <B>handleSessionCreationError</B>,

<B>handleSessionRestorationError</B> 

<hr>

<!-- methKey:handleRequest(public) meth:handleRequest descr:<TT>public next.wo.Response <B>handleRequest</B>(next.wo.Request <I>aRequest</I>)</TT> -->

<H3><a name="handleRequest(public)">handleRequest</a></H3>

<TT>public next.wo.Response <B>handleRequest</B>(next.wo.Request <I>aRequest</I>)</TT>

<P>

Prepares for and manages the handling of a request. The method

creates the Response and Context objects used in the request-response loop

and causes <B>awake</B> and <B>sleep</B> to be sent to application objects

at the appropriate times. This method is invoked by the HTTP server adaptor.

<hr>

<!-- methKey:handleSessionCreationError(public) meth:handleSessionCreationError descr:<TT>public next.wo.Response <B>handleSessionCreationError</B>()</TT> -->

<H3><a name="handleSessionCreationError(public)">handleSessionCreationError</a></H3>

<TT>public next.wo.Response <B>handleSessionCreationError</B>()</TT>

<P>

Called when a session (WebSession) instance cannot be created. The default

behavior displays a page with debugging information. You can override this

method to display a "friendlier" error page.

<P>

<B>See Also: handleException</B>, <B>handlePageRestorationError</B>,

<B>handleSessionRestorationError</B> 

<hr>

<!-- methKey:handleSessionRestorationError(public) meth:handleSessionRestorationError descr:<TT>public next.wo.Response <B>handleSessionRestorationError</B>()</TT> -->

<H3><a name="handleSessionRestorationError(public)">handleSessionRestorationError</a></H3>

<TT>public next.wo.Response <B>handleSessionRestorationError</B>()</TT>

<P>

Called when a session (WebSession) instance cannot be restored, which typically

happens when the session times out. The default behavior displays a page

with debugging information. You can override this method to display a

"friendlier" error page.

<P>

<B>See Also: handleException</B>, <B>handlePageRestorationError</B>,

<B>handleSessionCreationError</B> 

<hr>

<!-- methKey:invokeAction(public) meth:invokeAction descr:<TT>public next.wo.Element <B>invokeAction</B>(next.wo.Request <I>aRequest</I>, next.wo.Context <I>aContext</I>)</TT> -->

<H3><a name="invokeAction(public)">invokeAction</a></H3>

<TT>public next.wo.Element <B>invokeAction</B>(next.wo.Request <I>aRequest</I>, next.wo.Context <I>aContext</I>)</TT>

<P>

The WebApplication object sends this message to itself to initiate the middle

phase of request handling. In this phase, the message is propagated through

the objects of the application until the dynamic element that has received

the user action (for instance, a click on a button) responds to the message

by triggering the method in the request component that is bound to the action.

This phase occurs right after the <B>takeValuesFromRequest</B> method has

completed. The default WebApplication implementation of this method forwards

the message to the session object.

<P>

<B>See Also: appendToResponse</B>, <B>takeValuesFromRequest</B> 

<hr>

<!-- methKey:isBrowserLaunchingEnabled(public) meth:isBrowserLaunchingEnabled descr:<TT>public boolean <B>isBrowserLaunchingEnabled</B>()</TT> -->

<H3><a name="isBrowserLaunchingEnabled(public)">isBrowserLaunchingEnabled</a></H3>

<TT>public boolean <B>isBrowserLaunchingEnabled</B>()</TT>

<P>

Returns <B>true</B> if starting up the application also launches a web browser, and <B>false</B> otherwise. Browser launching is enabled by default as long as there is a WOAdaptorURL key in the file <I>NeXT_ROOT</I><B>/NextLibrary/WOAdaptors/Configuration/WebServerConfig.plist</B>.
<P>
<B>See Also: </B> <B>setBrowserLaunchingEnabled</B>
<hr>

<!-- methKey:isCachingEnabled(public) meth:isCachingEnabled descr:<TT>public boolean <B>isCachingEnabled</B>()</TT> -->

<H3><a name="isCachingEnabled(public)">isCachingEnabled</a></H3>

<TT>public boolean <B>isCachingEnabled</B>()</TT>

<P>

Returns whether component-definition caching is enabled. The default is <b>false</b>.

<P>

<B>See Also: setCachingEnabled</B> 

<hr>

<!-- methKey:isPageRefreshOnBacktrackEnabled(public) meth:isPageRefreshOnBacktrackEnabled descr:<TT>public boolean <B>isPageRefreshOnBacktrackEnabled</B>()</TT> -->

<H3><a name="isPageRefreshOnBacktrackEnabled(public)">isPageRefreshOnBacktrackEnabled</a></H3>

<TT>public boolean <B>isPageRefreshOnBacktrackEnabled</B>()</TT>

<P>

Returns whether caching of pages is disabled in the client. If so, the client

does not restore request pages from its cache but re-creates them "from scratch"

by resending the URL to the server. This flag is set to <B>false</B> by default.

<P>

<B>See Also: setPageRefreshOnBacktrackEnabled</B> 

<hr>

<!-- methKey:isRefusingNewSessions(public) meth:isRefusingNewSessions descr:<TT>public boolean <B>isRefusingNewSessions</B>()</TT> -->

<H3><a name="isRefusingNewSessions(public)">isRefusingNewSessions</a></H3>

<TT>public boolean <B>isRefusingNewSessions</B>()</TT>

<P>

Returns <B>true</B> if the application instance is refusing new sessions, and <B>false</B> otherwise. When the application instance refuses new sessions, the WebObjects adaptor tries to start the session in another instance of the same application. If no other instance is running and accepting new sessions, the user receives an error message. 
<P>
<B>See Also: </B><B>activeSessionsCount</B>, <B>minimumActiveSessionsCount</B>, <B>refuseNewSessions</B>
<hr>

<!-- methKey:isTerminating(public) meth:isTerminating descr:<TT>public boolean <B>isTerminating</B>()</TT> -->

<H3><a name="isTerminating(public)">isTerminating</a></H3>

<TT>public boolean <B>isTerminating</B>()</TT>

<P>

Returns whether the application will terminate at the end of the current

request-response loop.

<P>

<B>See Also: setTimeOut</B>, <B>terminate</B>, <B>terminateAfterTimeInterval</B>, <B>timeOut</B> 

<hr>

<!-- methKey:logString(public) meth:logString descr:<TT>public static void <B>logString</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="logString(public)">logString</a></H3>

<TT>public static void <B>logString</B>(java.lang.String <I>aString</I>)</TT>

<P>

Prints a message to the standard error device (stderr). The message can include

formatted variable data using String's concatenation feature, for example:

<PRE>    int i = 500;

    float f = 2.045;

    WebApplication.logString("Amount = " + i + ", Rate = " + f ", Total = " + i*f);

</PRE>

<P>

Note that <b>logString</b> is a static (class) method, so it can be invoked anywhere in a program, even if no reference to the application object is available. Also note that the equivalent
method in Objective-C is <B>logWithFormat:</B>. 

<hr>

<!-- methKey:logToMonitorString(public) meth:logToMonitorString descr:<TT>public void <B>logToMonitorString</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="logToMonitorString(public)">logToMonitorString</a></H3>

<TT>public void <B>logToMonitorString</B>(java.lang.String <I>aString</I>)</TT>

<P>

Same as <B>logString</B> but prints the string to the Monitor application's standard error. That is, the message is displayed in the command-shell window that was used to launch the Monitor application. 
<P>
You use this method to log messages about significant events when the application is ready to be deployed and you will use Monitor regularly to monitor the application. Otherwise, use <B>logString</B>. If the Monitor application is not running or if this application instance is not being monitored, this method does nothing. 
<hr>

<!-- methKey:minimumActiveSessionsCount(public) meth:minimumActiveSessionsCount descr:<TT>public int <B>minimumActiveSessionsCount</B>()</TT> -->

<H3><a name="minimumActiveSessionsCount(public)">minimumActiveSessionsCount</a></H3>

<TT>public int <B>minimumActiveSessionsCount</B>()</TT>

<P>

Returns the minimum number of active sessions allowed. If the number of active sessions is less than or equal to this number and <B>isRefusingNewSessions</B> is <B>true</B>, the application instance terminates. The default is 0.
<P>
<B>See Also: </B><B>activeSessionsCount</B>, <B>refuseNewSessions</B>, <B>setMinimumActiveSessionsCount</B>
<hr>

<!-- methKey:monitoringEnabled(public) meth:monitoringEnabled descr:<TT>public boolean <B>monitoringEnabled</B>()</TT> -->

<H3><a name="monitoringEnabled(public)">monitoringEnabled</a></H3>

<TT>public boolean <B>monitoringEnabled</B>()</TT>

<P>

Returns <B>true</B> if the application is "monitorable" by the Monitor application, and <B>false</B> otherwise. An application is "monitorable" if it was able to find a running Monitor upon startup and it is able to successfully communicate with that Monitor.
<P>
By default, all applications are monitorable if the Monitor application is running on the same machine as the application. You can specifically disable monitoring using the <B>-m OFF</B> option on the application command line. If you want the application to be monitorable and the Monitor is running on another host, you can start up the application through Monitor, or you can specify Monitor's host on the application command line this way:
<PRE>MyApp.exe -m ON -mhost <I>monitorHost</I> ...</PRE>
<P>
<B>See Also: </B><B>logToMonitorString</B>, the online document <A HREF="../../../../../ServingWebObjects/ServingWebObjectsTOC.html" target=_top><I>Serving WebObjects</I></A>
<hr>

<!-- methKey:name(public) meth:name descr:<TT>public java.lang.String <B>name</B>()</TT> -->

<H3><a name="name(public)">name</a></H3>

<TT>public java.lang.String <B>name</B>()</TT>

<P>

Returns the name of the application, which includes all directories under

<I>DOCUMENT_ROOT</I><B>/WebObjects</B> and is minus the ".woa" extension;

for example "HelloWorldJava" is a typical application name.

<P>

<B>See Also: baseURL</B>, <B>path</B> 

<hr>

<!-- methKey:number(public) meth:number descr:<TT>public java.lang.String <B>number</B>()</TT> -->

<H3><a name="number(public)">number</a></H3>

<TT>public java.lang.String <B>number</B>()</TT>

<P>

Returns the application's instance number. If this application instance was started through the Monitor application or if the instance number was explicitly specified on the command line (using the adaptor's <B>-n</B> option), that number is returned by this method. Otherwise, the application's instance number is undefined, and this method sends the message <B>applicationNumber</B> to the current <A HREF="../Request/Request.html" target=_top>Request</A> object to see if it has been assigned an instance number by the request. 
<hr>

<!-- methKey:pageCacheSize(public) meth:pageCacheSize descr:<TT>public int <B>pageCacheSize</B>()</TT> -->

<H3><a name="pageCacheSize(public)">pageCacheSize</a></H3>

<TT>public int <B>pageCacheSize</B>()</TT>

<P>

Returns the size of the internal cache for page instances. The default size

is 30 instances.

<P>

<B>See Also: setPageCacheSize</B> 

<hr>

<!-- methKey:pageWithName(public) meth:pageWithName descr:<TT>public next.wo.Component <B>pageWithName</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="pageWithName(public)">pageWithName</a></H3>

<TT>public next.wo.Component <B>pageWithName</B>(java.lang.String <I>aString</I>)</TT>

<P>

Returns a new page instance (a Component object) identified by <I>aName</I>.

If <I>aName</I> is <b>null</b>, the "Main" component is assumed. If the method cannot

create a valid page instance, it throws an exception.

<P>

<B>See Also: </B> <B>restorePageForContextID</B>, <B>savePage</B> 

<hr>

<!-- methKey:path(public) meth:path descr:<TT>public java.lang.String <B>path</B>()</TT> -->

<H3><a name="path(public)">path</a></H3>

<TT>public java.lang.String <B>path</B>()</TT>

<P>

Returns the file-system path of the application, which is an absolute path

and includes the ".woa" extension; for example

"C:\NeXT\NextLibrary\WOApps\MyApp.woa" is a typical

application path.

<P>

<B>See Also: baseURL</B>, <B>name</B> 

<hr>

<!-- methKey:pathForResource(public) meth:pathForResource descr:<TT>public java.lang.String <B>pathForResource</B>(java.lang.String <I>aString</I>, java.lang.String <I>aString</I>)</TT> -->

<H3><a name="pathForResource(public)">pathForResource</a></H3>

<TT>public java.lang.String <B>pathForResource</B>(java.lang.String <I>aString</I>, java.lang.String <I>aString</I>)</TT>

<P>

Returns the absolute path to the application resource having the name of

<I>aName</I> and an extension of <I>aType</I>. The method searches all localized

application ".lproj" directories before searching directly under the ".woa" wrapper.

<P>

This method is provided for backwards compatibility only. For WebObjects 3.5 and above, you should use the <A HREF="../ResourceManager/ResourceManager.html" target=_top>ResourceManager</A> API to retrieve resources. 
<P>

<B>See Also: </B> <B>stringForKeyInTable</B>
<hr>

<!-- methKey:printsHTMLParserDiagnostics(public) meth:printsHTMLParserDiagnostics descr:<TT>public boolean <B>printsHTMLParserDiagnostics</B>()</TT> -->

<H3><a name="printsHTMLParserDiagnostics(public)">printsHTMLParserDiagnostics</a></H3>

<TT>public boolean <B>printsHTMLParserDiagnostics</B>()</TT>

<P>

Returns whether the HTML parser prints warning messages to the standard output

device (stdout) if it encounters unbalanced container elements or other

syntactically incorrect HTML.

<P>

<B>See Also: setPrintsHTMLParserDiagnostics</B> 

<hr>

<!-- methKey:refuseNewSessions(public) meth:refuseNewSessions descr:<TT>public void <B>refuseNewSessions</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="refuseNewSessions(public)">refuseNewSessions</a></H3>

<TT>public void <B>refuseNewSessions</B>(boolean <I>flag</I>)</TT>

<P>

Controls whether this application instance will create a session when it receives an HTTP request from a new user. If <I>flag</I> is <B>true</B>, the application does not create new sessions; when it receives a request from a new user, it refuses that request, and the adaptor must try to find another application instance that can process the request. If <I>flag</I> is <B>false</B>, the application creates new sessions. <B>false</B> is the default.
<P>
You use this method with <B>setMinimumActiveSessionsCount</B> to gracefully shut down application instances. Use <B>setMinimumActiveSessionsCount</B> to set the active session minimum to a certain number. When number of active sessions reaches the number you set and <B>isRefusingNewSessions</B> returns <B>true</B>, the application terminates. 
<P>
<B>See Also: </B><B>activeSessionsCount</B>, <B>isRefusingNewSessions</B>, <B>minimumActiveSessionsCount</B>, <B>setMinimumActiveSessionsCount</B>
<hr>

<!-- methKey:resourceManager(public) meth:resourceManager descr:<TT>public next.wo.ResourceManager <B>resourceManager</B>()</TT> -->

<H3><a name="resourceManager(public)">resourceManager</a></H3>

<TT>public next.wo.ResourceManager <B>resourceManager</B>()</TT>

<P>

Returns the <A HREF="../ResourceManager/ResourceManager.html" target=_top>ResourceManager</A> object that the application uses to manage resources.
<P>
<B>See Also: </B><B>setResourceManager</B>
<hr>

<!-- methKey:restorePageForContextID(public) meth:restorePageForContextID descr:<TT>public next.wo.Component <B>restorePageForContextID</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="restorePageForContextID(public)">restorePageForContextID</a></H3>

<TT>public next.wo.Component <B>restorePageForContextID</B>(java.lang.String <I>aString</I>)</TT>

<P>

Returns a page instance stored the session page cache. The key to the stored

instance is the its context ID, which derives from the transaction's Context

or Request objects. This method returns <B>null</B> if restoration is impossible.

<P>

<B>See Also: savePage</B> 

<hr>

<!-- methKey:restoreSession(public) meth:restoreSession descr:<TT>public next.wo.WebSession <B>restoreSession</B>()</TT> -->

<H3><a name="restoreSession(public)">restoreSession</a></H3>

<TT>public next.wo.WebSession <B>restoreSession</B>()</TT>

<P>

Restores the WebSession object representing a session. In normal request

handling, this method is called at the start of a cycle of the request-response

loop. The default implementation simply invokes SessionStore's

<B>restoreSession</B> method, but throws an exception if the SessionStore

object is missing.

<P>

<B>See Also: createSession</B>, <B>saveSession</B>, 

<hr>

<!-- methKey:run(public) meth:run descr:<TT>public void <B>run</B>()</TT> -->

<H3><a name="run(public)">run</a></H3>

<TT>public void <B>run</B>()</TT>

<P>

Runs the application in a near-indefinite run loop in the default run-loop

mode. Before starting the run loop, the method sends <B>registerForEvents</B>

to the application's adaptors so that they can begin receiving run-loop events.

Normally, <b>run</b> is invoked in the <B>main</B> function.

<P>

<B>See Also: setTimeOut</B>, <B>terminate</B>, <B>terminateAfterTimeInterval</B>
<hr>

<!-- methKey:savePage(public) meth:savePage descr:<TT>public void <B>savePage</B>(next.wo.Component <I>aComponent</I>)</TT> -->

<H3><a name="savePage(public)">savePage</a></H3>

<TT>public void <B>savePage</B>(next.wo.Component <I>aComponent</I>)</TT>

<P>

Saves the page instance <I>aComponent</I> in the session page cache. The

context ID for the current transaction is made the key for obtaining this

instance in the cache using <B>restorePageForContextID</B>. 

<hr>

<!-- methKey:saveSession(public) meth:saveSession descr:<TT>public void <B>saveSession</B>(next.wo.WebSession <I>aWebSession</I>)</TT> -->

<H3><a name="saveSession(public)">saveSession</a></H3>

<TT>public void <B>saveSession</B>(next.wo.WebSession <I>aWebSession</I>)</TT>

<P>

Saves a WebSession object that represents a session. In normal request handling,

this method is called at the end of a cycle of the request-response loop.

The default implementation simply invokes SessionStore's <B>saveSession</B>

method, but throws an exception if the SessionStore object is missing.

<P>

<B>See Also: restoreSession</B> 

<hr>

<!-- methKey:scriptedClassNameWithPath(public) meth:scriptedClassNameWithPath descr:<TT>public java.lang.String <B>scriptedClassNameWithPath</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="scriptedClassNameWithPath(public)">scriptedClassNameWithPath</a></H3>

<TT>public java.lang.String <B>scriptedClassNameWithPath</B>(java.lang.String <i>aPath</i>)</TT>

<P>

Loads a scripted class with the pathname <i>aPath</i> into the application. The specified script is parsed assuming the default string encoding, and the class and categories found in the script file are dynamically added to the runtime.
<hr>

<!-- methKey:scriptedClassNameWithPathEncoding(public) meth:scriptedClassNameWithPathEncoding descr:<TT>public java.lang.String <B>scriptedClassNameWithPathEncoding</B>(java.lang.String <I>aString</I>, int <I>anInt</I>)</TT> -->

<H3><a name="scriptedClassNameWithPathEncoding(public)">scriptedClassNameWithPathEncoding</a></H3>

<TT>public java.lang.String <B>scriptedClassNameWithPathEncoding</B>(java.lang.String <i>aPath</i>, int <i>anEncoding</i>)</TT>

<P>

Loads a scripted class with the pathname <i>aPath</i> using the encoding <i>anEncoding</i>. The class and categories found in the script file are dynamically added to the runtime.
<hr>

<!-- methKey:session(public) meth:session descr:<TT>public next.wo.WebSession <B>session</B>()</TT> -->

<H3><a name="session(public)">session</a></H3>

<TT>public next.wo.WebSession <B>session</B>()</TT>

<P>

Returns the application's current WebSession object. May not be overridden.

<P>

<B>See Also: application</B>, <B>context</B> 

<hr>

<!-- methKey:sessionStore(public) meth:sessionStore descr:<TT>public next.wo.SessionStore <B>sessionStore</B>()</TT> -->

<H3><a name="sessionStore(public)">sessionStore</a></H3>

<TT>public next.wo.SessionStore <B>sessionStore</B>()</TT>

<P>

Returns the application's current SessionStore object (which, by default,

stores state in the server).

<P>

<B>See Also: setSessionStore</B> 

<hr>

<!-- methKey:setBrowserLaunchingEnabled(public) meth:setBrowserLaunchingEnabled descr:<TT>public void <B>setBrowserLaunchingEnabled</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="setBrowserLaunchingEnabled(public)">setBrowserLaunchingEnabled</a></H3>

<TT>public void <B>setBrowserLaunchingEnabled</B>(boolean <I>isEnabled</I>)</TT>

<P>

Controls whether starting up this application also launches a web browser. If <I>isEnabled</I> is <B>true</B>, the application launches the web browser. If <B>false</B>, the application does not launch the browser. Browser launching is enabled by default as long as there is a WOAdaptorURL key in the file <I>NeXT_ROOT</I><B>/NextLibrary/WOAdaptors/Configuration/WebServerConfig.plist</B>.
<P>
To disable web browser launching, you must send this message in your subclass's constructor.
<P>
<B>See Also: </B> <B>isBrowserLaunchingEnabled</B>
<hr>

<!-- methKey:setCachingEnabled(public) meth:setCachingEnabled descr:<TT>public void <B>setCachingEnabled</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="setCachingEnabled(public)">setCachingEnabled</a></H3>

<TT>public void <B>setCachingEnabled</B>(boolean <I>flag</I>)</TT>

<P>

Enables or disables the caching of component definitions. Component definitions

contain templates and other information about pages and subcomponents, and

are used to generate instances of those components. When this flag is enabled,

the application parses the script (or implementation) file, the HTML,

and the declaration (".wod") file of a component once and then stores the

resulting component definition. By default, this kind of caching is disabled

so that you can edit a scripted component without having to relaunch the

application every time to check the results.
You should always enable component-definition caching when you deploy an

application since performance improves significantly. 


<P>

Do not confuse this type of caching with <I>page-instance caching</I> (see

<B>setPageCacheSize</B>). <A href="#Caching">Caching Strategies</A> in the class description provides further details.

<P>

<B>See Also: isCachingEnabled</B> 

<hr>

<!-- methKey:setMinimumActiveSessionsCount(public) meth:setMinimumActiveSessionsCount descr:<TT>public void <B>setMinimumActiveSessionsCount</B>(int <I>anInt</I>)</TT> -->

<H3><a name="setMinimumActiveSessionsCount(public)">setMinimumActiveSessionsCount</a></H3>

<TT>public void <B>setMinimumActiveSessionsCount</B>(int <I>anInt</I>)</TT>

<P>

Sets the minimum number of active sessions to <I>anInt</I>. The default is 0.
<P>
You use this method to gracefully shut down application instances. If the active sessions count reaches this number and <B>isRefusingNewSessions</B> returns <B>true</B>, the application terminates. You might want to terminate application instances periodically for performance reasons; some applications leak a certain amount of memory per transaction, and shutting down and restarting instances of those applications can free up that memory.
<P>
<B>See Also: </B><B>activeSessionsCount</B>, <B>isRefusingNewSessions</B>, <B>minimumActiveSessionsCount</B>, <B>refuseNewSessions</B>
<hr>

<!-- methKey:setPageCacheSize(public) meth:setPageCacheSize descr:<TT>public void <B>setPageCacheSize</B>(int <I>anInt</I>)</TT> -->

<H3><a name="setPageCacheSize(public)">setPageCacheSize</a></H3>

<TT>public void <B>setPageCacheSize</B>(int <I>anInt</I>)</TT>

<P>

Sets whether caching of page instances will occur <I>and</I> the number of

pages the cache will hold. When page-instance caching is enabled, the application

stores the Component instance corresponding to the response page in the session.

When the page is backtracked to, it restores it from the session and makes

it the request page. The state of the page is retained. By default, page-instance

caching is enabled, with a cache limit of 30 pages.

<P>

You turn page-instance caching off by invoking this method with an argument

of zero. In this case, when the user backtracks to a page, the page is not

stored in the session and so must be re-created "from scratch." Do not confuse

this type of caching with <I>component-definition caching</I> (see

<B>setCachingEnabled</B>).

<P>

See <A href="#Caching">Caching Strategies</A> in the class description for

further details.

<P>

<B>See Also: pageCacheSize</B> 

<hr>

<!-- methKey:setPageRefreshOnBacktrackEnabled(public) meth:setPageRefreshOnBacktrackEnabled descr:<TT>public void <B>setPageRefreshOnBacktrackEnabled</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="setPageRefreshOnBacktrackEnabled(public)">setPageRefreshOnBacktrackEnabled</a></H3>

<TT>public void <B>setPageRefreshOnBacktrackEnabled</B>(boolean <I>flag</I>)</TT>

<P>

When <I>flag</I> is <B>true</B>, disables caching of pages by the client

by setting the page's expiration-time header to the current date and time.

(By default, this attribute is set to <B>false</B>.) Disabling of client

caching affects what happens during backtracking. With client caching turned

off, the browser resends the URL to the server for the page requested by

backtracking. The application must return a new page to the browser

(corresponding to a new Component instance). This behavior is desirable when

you do not want the user to backtrack to a page that might be obsolete because

of changes that have occurred in the session.

<P>

When this flag is turned on and a request corresponding to a client backtrack

occurs, the retrieved page will only be asked to regenerate its response.

The first two phases of a normal request-response loop (value extraction

from the request and action invocation) do not occur.

<P>

See <A href="#Caching">Caching Strategies</A> in the class description for

further details.

<P>

<B>See Also: isPageRefreshOnBacktrackEnabled</B> 

<hr>

<!-- methKey:setPrintsHTMLParserDiagnostics(public) meth:setPrintsHTMLParserDiagnostics descr:<TT>public void <B>setPrintsHTMLParserDiagnostics</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="setPrintsHTMLParserDiagnostics(public)">setPrintsHTMLParserDiagnostics</a></H3>

<TT>public void <B>setPrintsHTMLParserDiagnostics</B>(boolean <I>flag</I>)</TT>

<P>

Sets whether the HTML parser prints warning messages to the standard output

device (stdout) if it encounters unbalanced container elements or other

syntactically incorrect HTML.

<P>

<B>See Also: printsHTMLParserDiagnostics</B> 

<hr>

<!-- methKey:setResourceManager(public) meth:setResourceManager descr:<TT>public void <B>setResourceManager</B>(next.wo.ResourceManager <I>aResourceManager</I>)</TT> -->

<H3><a name="setResourceManager(public)">setResourceManager</a></H3>

<TT>public void <B>setResourceManager</B>(next.wo.ResourceManager <I>aResourceManager</I>)</TT>

<P>

Sets the <A HREF="../ResourceManager/ResourceManager.html" target=_top>ResourceManager</A> object to <I>aResourceManager</I>. ResourceManager objects search for and retrieve resources from the application directory and from shared framework directories.
<P>
<B>See Also: </B><B>resourceManager</B>
<hr>

<!-- methKey:setSessionStore(public) meth:setSessionStore descr:<TT>public void <B>setSessionStore</B>(next.wo.SessionStore <I>aSessionStore</I>)</TT> -->

<H3><a name="setSessionStore(public)">setSessionStore</a></H3>

<TT>public void <B>setSessionStore</B>(next.wo.SessionStore <I>aSessionStore</I>)</TT>

<P>

Set the session-store object for the application. By default, an object that

stores session state in process memory (that is, in the server) is used.

The session-store object specifies the state storage strategy for the whole

application. This object is responsible for making session objects persistent.

WebObjects supports state storage in the server, in the page, and in cookies.

You should set the session store object when the application starts up, before

the first request is handled.

<P>

<B>See Also: sessionStore</B> 

<hr>

<!-- methKey:setStatisticsStore(public) meth:setStatisticsStore descr:<TT>public void <B>setStatisticsStore</B>(next.wo.StatisticsStore <I>aStatisticsStore</I>)</TT> -->

<H3><a name="setStatisticsStore(public)">setStatisticsStore</a></H3>

<TT>public void <B>setStatisticsStore</B>(next.wo.StatisticsStore <I>aStatisticsStore</I>)</TT>

<P>

Sets the <A HREF="../StatisticsStore/StatisticsStore.html" target=_top>StatisticsStore</A> object to <I>aStatisticsStore</I>. StatisticsStore objects record application statistics while the application runs. 
<hr>

<!-- methKey:setTimeOut(public) meth:setTimeOut descr:<TT>public void <B>setTimeOut</B>(double <I>aDouble</I>)</TT> -->

<H3><a name="setTimeOut(public)">setTimeOut</a></H3>

<TT>public void <B>setTimeOut</B>(double <I>aDouble</I>)</TT>

<P>

Sets the number of seconds the application can experience inactivity (no

HTTP requests) before it terminates execution.

<P>
This method differs from <B>terminateAfterTimeInterval</B> in that with this method, the application must be idle
for <I>aTimeInterval</I> seconds for the application to terminate. <B>terminateAfterTimeInterval</B> terminates the application whether it is active or not.
<P>

<B>See Also: timeOut</B> 

<hr>

<!-- methKey:sleep(public) meth:sleep descr:<TT>public void <B>sleep</B>()</TT> -->

<H3><a name="sleep(public)">sleep</a></H3>

<TT>public void <B>sleep</B>()</TT>

<P>

Invoked at the conclusion of a request-handling cycle to give an application

the opportunity for deallocating objects created and initialized in its

<B>awake</B> method. The default implementation does nothing. 

<hr>

<!-- methKey:statistics(public) meth:statistics descr:<TT>public next.util.ImmutableHashtable <B>statistics</B>()</TT> -->

<H3><a name="statistics(public)">statistics</a></H3>

<TT>public next.util.ImmutableHashtable <B>statistics</B>()</TT>

<P>

Returns a copy of the dictionary containing the application statistics maintained by StatisticsStore. This method is used by the Monitor application to retrieve application statistics. If you need to access the statistics internally, use this message instead:
<PRE>WebApplication.application().statisticsStore().statistics()</PRE>
<P>
<B>See Also: </B><A HREF="../StatisticsStore/StatisticsStore.html" target=_top>StatisticsStore</A> class
<hr>

<!-- methKey:statisticsStore(public) meth:statisticsStore descr:<TT>public next.wo.StatisticsStore <B>statisticsStore</B>()</TT> -->

<H3><a name="statisticsStore(public)">statisticsStore</a></H3>

<TT>public next.wo.StatisticsStore <B>statisticsStore</B>()</TT>

<P>

Returns the <A HREF="../StatisticsStore/StatisticsStore.html" target=_top>StatisticsStore</A> object, which records statistics while the application runs.
<P>
<B>See Also: </B><B>setStatisticsStore</B>
<hr>

<!-- methKey:stringForKeyInTable(public) meth:stringForKeyInTable descr:<TT>public java.lang.String <B>stringForKeyInTable</B>(java.lang.String <I>aString</I>, java.lang.String <I>aString</I>, java.lang.String <I>aString</I>)</TT> -->

<H3><a name="stringForKeyInTable(public)">stringForKeyInTable</a></H3>

<TT>public java.lang.String <B>stringForKeyInTable</B>(java.lang.String <I>aString</I>, java.lang.String <I>aString</I>, java.lang.String <I>aString</I>)</TT>

<P>

Returns a localized string from string table "<I>aTable</I>.strings" using

<I>aKey</I> to look it up. If no string value for the key is found in the

table, <I>defaultValue</I> (optional) is returned. The method first searches

the "<I>aTable</I>.strings" file, if it exists, in each localized (".lproj")

subdirectories of the application wrapper; searching proceeds in the order

of the language list maintained by the WebSession object<!-- (for details, see

the <B>setLanguages</B> method of the

<A href="../WebSession/WebSession.html" target=_top> WebSession</A> class)-->.

If no string value matching the key is found, the search then continues to

the "<I>aTable</I>.strings" file (if it exists) directly under the application

wrapper (the directory with the "woa" extension).

<P>

See <A href="#Localization">Localization</A> in the class

description for further details.

<hr>

<!-- methKey:takeValuesFromRequest(public) meth:takeValuesFromRequest descr:<TT>public void <B>takeValuesFromRequest</B>(next.wo.Request <I>aRequest</I>, next.wo.Context <I>aContext</I>)</TT> -->

<H3><a name="takeValuesFromRequest(public)">takeValuesFromRequest</a></H3>

<TT>public void <B>takeValuesFromRequest</B>(next.wo.Request <I>aRequest</I>, next.wo.Context <I>aContext</I>)</TT>

<P>

The WebApplication object sends this message to itself to start the first

phase of request handling. In this phase, the message is propagated to the

session and component objects involved in the request as well as the request

page's dynamic elements. Each dynamic element acquires any entered data or

changed state (such as a check in a check box) associated with an attribute

and assigns the value to the variable bound to the attribute. The default

WebApplication implementation of this method forwards the message to the

session object.

<P>

<B>See Also: appendToResponse</B>, <B>invokeAction</B> 

<hr>

<!-- methKey:terminate(public) meth:terminate descr:<TT>public void <B>terminate</B>()</TT> -->

<H3><a name="terminate(public)">terminate</a></H3>

<TT>public void <B>terminate</B>()</TT>

<P>

Terminates the application process. Termination does not take place until

the handling of the current request has completed.

<P>

<B>See Also: isTerminating</B>, <B>setTimeOut</B> 

<hr>

<!-- methKey:terminateAfterTimeInterval(public) meth:terminateAfterTimeInterval descr:<TT>public void <B>terminateAfterTimeInterval</B>(double <I>aDouble</I>)</TT> -->

<H3><a name="terminateAfterTimeInterval(public)">terminateAfterTimeInterval</a></H3>

<TT>public void <B>terminateAfterTimeInterval</B>(double <I>aTimeInterval</I>)</TT>

<P>

Sets the application to terminate itself after <I>aTimeInterval</I> seconds has elapsed. After the specified time interval has elapsed, the application immediately stops all current processing. If any sessions are active, users may lose information. 
<P>
This method differs from <B>setTimeOut</B> in that it does not set idle time; <B>terminateAfterTimeInterval</B> shuts down the application regardless of if it is idle. 
<P>
<hr>

<!-- methKey:timeOut(public) meth:timeOut descr:<TT>public double <B>timeOut</B>()</TT> -->

<H3><a name="timeOut(public)">timeOut</a></H3>

<TT>public double <B>timeOut</B>()</TT>

<P>

Returns the application's time-out interval: a period (in seconds) of inactivity

before the application terminates execution. The default application time-out

interval is a very large number.

<P>

<B>See Also: setTimeOut</B> 

<hr>

<!-- methKey:trace(public) meth:trace descr:<TT>public void <B>trace</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="trace(public)">trace</a></H3>

<TT>public void <B>trace</B>(boolean <I>flag</I>)</TT>

<P>

If <i>flag</i> is <B>true</B>, prints all trace messages (messages for scripted messages, compiled messages, and all statements in the application) to the standard error device. If <i>flag</i> is <B>false</B>, stops printing all trace messages.

<P>

<B>See Also: </B><b>traceAssignments</B>, <b>traceObjectiveCMessages</B>, <b>traceScriptedMessages</B>, <b>traceStatements</B>
<hr>

<!-- methKey:traceAssignments(public) meth:traceAssignments descr:<TT>public void <B>traceAssignments</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="traceAssignments(public)">traceAssignments</a></H3>

<TT>public void <B>traceAssignments</B>(boolean <I>flag</I>)</TT>

<P>

If <i>flag</i> is <B>true</B>, prints a message to the standard error device every time an assignment statement is executed. If <i>flag</i> is <B>false</B>, stops printing trace assignment messages.

<P>

<B>See Also: </B><b>trace</B>, <b>traceObjectiveCMessages</B>, <b>traceScriptedMessages</B>, <b>traceStatements</B>
<hr>

<!-- methKey:traceObjectiveCMessages(public) meth:traceObjectiveCMessages descr:<TT>public void <B>traceObjectiveCMessages</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="traceObjectiveCMessages(public)">traceObjectiveCMessages</a></H3>

<TT>public void <B>traceObjectiveCMessages</B>(boolean <I>flag</I>)</TT>

<P>

If <i>flag</i> is <B>true</B>, prints a message to the standard error device every time a message is sent to a compiled class. If <i>flag</i> is <B>false</B>, stops printing these messages.

<P>

<B>See Also: </B><b>trace</B>, <b>traceAssignments</B>, <b>traceScriptedMessages</B>, <b>traceStatements</B>
<hr>

<!-- methKey:traceScriptedMessages(public) meth:traceScriptedMessages descr:<TT>public void <B>traceScriptedMessages</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="traceScriptedMessages(public)">traceScriptedMessages</a></H3>

<TT>public void <B>traceScriptedMessages</B>(boolean <I>flag</I>)</TT>

<P>

If <i>flag</i> is <B>true</B>, prints a message to the standard error device every time a message is sent to a scripted class. If <i>flag</i> is <B>false</B>, stops printing trace scripted method messages.

<P>

<B>See Also: </B><b>trace</B>, <b>traceAssignments</B>, <b>traceObjectiveCMessages</B>, <b>traceStatements</B>
<hr>

<!-- methKey:traceStatements(public) meth:traceStatements descr:<TT>public void <B>traceStatements</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="traceStatements(public)">traceStatements</a></H3>

<TT>public void <B>traceStatements</B>(boolean <I>flag</I>)</TT>

<P>

If <i>flag</i> is <B>true</B>, prints a message to the standard error device every time a statement in the application is executed. If <i>flag</i> is <B>false</B>, stops printing trace statement messages.

<P>

<B>See Also: </B><b>trace</B>, <b>traceAssignments</B>, <b>traceObjectiveCMessages</B>, <b>traceScriptedMessages</B>
<hr>

<!-- methKey:urlForResource(public) meth:urlForResource descr:<TT>public java.lang.String <B>urlForResource</B>(java.lang.String <I>aString</I>, java.lang.String <I>aString</I>)</TT> -->

<H3><a name="urlForResource(public)">urlForResource</a></H3>

<TT>public java.lang.String <B>urlForResource</B>(java.lang.String <I>aString</I>, java.lang.String <I>aString</I>)</TT>

<P>

Returns the URL associated with an application resource having a name of

<I>aName</I> and an extension of <I>aType</I>. The method searches all localized

application ".lproj" directories before searching directly under the ".woa"

wrapper for the resource.

<P>

This method is provided for backwards compatibility only. For WebObjects 3.5 and above, you should use the <A HREF="../ResourceManager/ResourceManager.html" target=_top>ResourceManager</A> API to retrieve resources. 
<P>

<B>See Also: stringForKeyInTable</B> 

<hr>

</body>

</html>