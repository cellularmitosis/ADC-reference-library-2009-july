<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>PCI Sound Input driver - /PCISoundInputDriver.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">PCI Sound Input driver</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/index.html" target="_blank">Reference Library > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">PCI Sound Input driver</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/PCISoundInputDriver.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/PCISoundInputDriver.c</option></select>
				</p>
				</form>
				<p><strong><a href="PCI_Sound_Input_driver.zip">Download Sample</a></strong> (&#147;PCI_Sound_Input_driver.zip&#148;, 71.1K)<BR>
<strong><a href="PCI_Sound_Input_driver.dmg">Download Sample</a></strong> (&#147;PCI_Sound_Input_driver.dmg&#148;, 138.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    PCISoundInputDriver.c    Contains:  Sample PCI sound input hardware driver  Author:    &lt;MC&gt;  Copyright:   &copy; Copyright 1996-2001 Apple Computer, Inc. All rights reserved.    Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your        use, installation, modification or redistribution of this Apple software        constitutes acceptance of these terms.  If you do not agree with these terms,        please do not use, install, modify or redistribute this Apple software.        In consideration of your agreement to abide by the following terms, and subject        to these terms, Apple grants you a personal, non-exclusive license, under Apple's        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,        reproduce, modify and redistribute the Apple Software, with or without        modifications, in source and/or binary forms; provided that if you redistribute        the Apple Software in its entirety and without modifications, you must retain        this notice and the following text and disclaimers in all such redistributions of        the Apple Software.  Neither the name, trademarks, service marks or logos of        Apple Computer, Inc. may be used to endorse or promote products derived from the        Apple Software without specific prior written permission from Apple.  Except as        expressly stated in this notice, no other rights or licenses, express or implied,        are granted by Apple herein, including but not limited to any patent rights that        may be infringed by your derivative works or by other works in which the Apple        Software may be incorporated.        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN        COMBINATION WITH YOUR PRODUCTS.        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.          Change History (most recent first):        05/02/01  JAS  Fixed problems in HWIntProc. Fixed bug in DriverStausCmd:siInputSourceNames                to return a copy of the handle to the input source names. Updated to CW Pro 6.        8/3/1999  KG  Updated for Metrowerks Codewarror Pro 2.1*/#include &lt;Aliases.h&gt;#include &lt;DriverServices.h&gt;#include &lt;DriverGestalt.h&gt;#include &lt;NameRegistry.h&gt;#include &lt;Resources.h&gt;#include &lt;Sound.h&gt;#include &lt;SoundInput.h&gt;#include &lt;TextUtils.h&gt;#include &lt;Timer.h&gt;#include &lt;stdio.h&gt;#include &lt;Strings.h&gt;// This is what our input parameter looks like#pragma options align=mac68kstruct SoundParam {  QElemPtr            qLink;  short              qType;  short              ioTrap;  Ptr                ioCmdAddr;  IOCompletionUPP          ioCompletion;  OSErr              ioResult;  StringPtr            ioNamePtr;  short              ioVRefNum;  short              ioCRefNum;  short              csCode;  short              csParam[11];};typedef struct SoundParam SoundParam, *SoundParamPtr;#pragma options align=reset// tell the OS all about usextern DriverDescription TheDriverDescription = {  kTheDescriptionSignature,  kInitialDriverDescriptor,  // DriverType  &quot;\pTestSoundInputDriver&quot;,  1, 0, developStage, 1,  // DriverOSRuntimeInfo  0  | (1 * kDriverIsLoadedUponDiscovery)    /* Loader runtime options */  | (1 * kDriverIsOpenedUponLoad)      /* Opened when loaded */  | (0 * kDriverIsUnderExpertControl)    /* No I/O expert to handle loads/opens */  | (0 * kDriverIsConcurrent)        /* Not concurrent yet */  | (0 * kDriverQueuesIOPB),        /* Not internally queued yet */  &quot;\p.TestSoundInputDriver&quot;,        /* Str31 driverName (OpenDriver param) */  0, 0, 0, 0, 0, 0, 0, 0,          /* UInt32 driverDescReserved[8] */  // DriverOSService  1,                    /* ServiceCount nServices */  // DriverServiceInfo  kServiceCategoryNdrvDriver,        /* OSType serviceCategory */  kNdrvTypeIsGeneric,            /* OSType serviceType */   1, 0, developStage, 1,          /* major, minor, stage, rev */};//For debugging information#define DEBUG    0#define DEBUG2    0#define FULLDEBUG  0#define kSamplesInBuffer  1024#define  kSilence      128#define  kAmplitude      75#define  kSquareSource    1#define  kSawSource      2#define  kSilenceSource    3#define kNumRates      3#define kNumSizes      2#define kNumCompressions  1typedef struct myTMTask {  TMTask    theTask;  ParmBlkPtr  pb;} myTMTask;//----------------------------------------------------------------------------------//                  Function Prototypes//----------------------------------------------------------------------------------pascal OSErr FragInit        (CFragInitBlockPtr initInfo);pascal void FragTerm        (void);static OSStatus DriverKillIOCmd   (ParmBlkPtr pb);extern OSErr DoDriverIO        (AddressSpaceID addressSpaceID, IOCommandID ioCommandID, IOCommandContents ioCommandContents, IOCommandCode ioCommandCode, IOCommandKind ioCommandKind);static pascal void HWIntProc    (QElemPtr passedPtr);static void MakeSquareWave      (long duration, long numberSamples, UnsignedFixed sampleRate, long frequency, short sampleSize, short numChannels);static void MakeSawWave        (long duration, long numberSamples, UnsignedFixed sampleRate, long frequency, short sampleSize, short numChannels);static OSErr DoOptionsDialog    (void);static void SetHardwareToDefault  (void);//----------------------------------------------------------------------------------//                  Globals//----------------------------------------------------------------------------------//Hardware specific globalsSInt16      gMaxAmplitude,        gContinuousOn,        gLevelMeterOn,        gTwosComplementOn,        gAGCOn,        gPlayThruVolume,        gVoxRecordingOn,        gVoxStoppingOn,        gPauseState,        gNumberChannels,        gSampleSize,        gVOXStartTrigger,        gVOXStopTrigger,        gVOXDelay,        gCompressionFactor,        gCurrentInputSource    = kSquareSource;SInt32      gActiveChannels;      //channels to record from 0x01 == only left, 0x02 == only right, 0x03 == both channelsUnsignedFixed  gSampleRate;Fixed      gInputGain,        gLeftInputGain,        gRightInputGain;OSType      gCompressionType,        gRecordingQuality;SIInterruptUPP  gUserInterruptProc    = nil;//Globals needed to simulate our hardwaremyTMTask    gSimulatedHWInterrupt;TimerUPP    gSimulatedHWIntProc    = nil;SInt32      gInterruptFreq      = 0,        gSamplesWritten      = 0;SInt16      gNextSaw16Sample    = -((kAmplitude * 0.01) * 32767);  //starting point for saw tooth waveSInt8      gNextSaw8Sample      = kSilence - kAmplitude;  //starting point for saw tooth wavePtr        gSoundBuffer      = nil;  //our hardware's internal buffer                        //Driver specific globalsBoolean      gStopRecording      = false;DriverRefNum  gDrvrRefNum;Handle      gDrvrIcon,        gInputSourceNames;AliasHandle    gAliasToDriver;StringHandle  gDriverName;//----------------------------------------------------------------------------------//                  CFM Init//----------------------------------------------------------------------------------pascal OSErr FragInit (CFragInitBlockPtr initInfo) {  Handle        iconHandle,            strHandle;  StringHandle    driverName;  SInt16        resRefNum;  OSErr        err      = noErr;  if (initInfo-&gt;fragLocator.where == kDataForkCFragLocator || initInfo-&gt;fragLocator.where == kResourceCFragLocator) {    resRefNum = FSpOpenResFile (initInfo-&gt;fragLocator.u.onDisk.fileSpec, fsRdPerm);    err = ResError();    if (err != noErr) {    #if DEBUG      SysDebugStr (&quot;\p!!Error returned from FSpOpenResFile!!&quot;);    #endif    }    if (resRefNum == -1) {    #if DEBUG      SysDebugStr (&quot;\p!!Error resRefNum is -1!!&quot;);    #endif    }  }  if (resRefNum != -1 &amp;&amp; err == noErr) {    iconHandle = Get1Resource ('ICN#', 128);    err = ResError ();    if (iconHandle == nil) {    #if DEBUG      SysDebugStr (&quot;\p!!iconHandle is nil!!&quot;);    #endif    }    if (err != noErr) {    #if DEBUG      SysDebugStr (&quot;\p!!Error from Get1Resource('ICN#', 128)!!&quot;);    #endif    }    if (iconHandle != nil) {      gDrvrIcon = NewHandleSys (GetHandleSize (iconHandle));      BlockMoveData (*iconHandle, *gDrvrIcon, GetHandleSize (iconHandle));      ReleaseResource (iconHandle);    } else if (err == noErr) {      err = resNotFound;    #if DEBUG      SysDebugStr (&quot;\p!!Error Get1Resource('ICN#', 128), resNotFound!!&quot;);    #endif    }    strHandle = Get1Resource ('STR#', 128);    err = ResError ();    if (strHandle == nil) {    #if DEBUG      SysDebugStr (&quot;\p!!strHandle is nil!!&quot;);    #endif    }    if (err != noErr) {    #if DEBUG      SysDebugStr (&quot;\p!!Error from Get1Resource('STR#', 128)!!&quot;);    #endif    }    if (strHandle != nil) {      gInputSourceNames = NewHandleSys (GetHandleSize (strHandle));      BlockMoveData (*strHandle, *gInputSourceNames, GetHandleSize (strHandle));      ReleaseResource (strHandle);    } else if (err == noErr) {      err = resNotFound;    #if DEBUG      SysDebugStr (&quot;\p!!Error Get1Resource('STR#', 128), resNotFound!!&quot;);    #endif    }    driverName = GetString (128);    err = ResError ();    if (driverName == nil) {    #if DEBUG      SysDebugStr (&quot;\p!!driverName is nil!!&quot;);    #endif    }    if (err != noErr) {    #if DEBUG      SysDebugStr (&quot;\p!!Error from GetString(128)!!&quot;);    #endif    }    if (driverName != nil) {      gDriverName = (StringHandle)NewHandleSys (GetHandleSize ((Handle)driverName));      BlockMoveData (*driverName, *gDriverName, GetHandleSize ((Handle)driverName));      ReleaseResource ((Handle)driverName);    } else if (err == noErr) {      err = resNotFound;    #if DEBUG      SysDebugStr (&quot;\p!!Error GetString(128), resNotFound!!&quot;);    #endif    }    CloseResFile (resRefNum);  }  if (err == noErr) {    //make an alias to ourselves so that we can open our driver later if needed    err = NewAlias (nil, initInfo-&gt;fragLocator.u.onDisk.fileSpec, &amp;gAliasToDriver);  }#if DEBUG  if (err != noErr) {    SysDebugStr (&quot;\p!!Error in FragInit!!&quot;);  }#endif  return (err);}pascal void FragTerm (void) {  if (gDrvrIcon != nil) {    DisposeHandle (gDrvrIcon);    gDrvrIcon = nil;  }  if (gInputSourceNames != nil) {    DisposeHandle (gInputSourceNames);    gInputSourceNames = nil;  }  if (gAliasToDriver != nil) {    DisposeHandle ((Handle)gAliasToDriver);    gAliasToDriver = nil;  }}//----------------------------------------------------------------------------------//                  Driver calls//----------------------------------------------------------------------------------/*  Always run at task level, can allocate and move memory.*/static OSStatus DriverInitializeCmd (AddressSpaceID addressSpaceID, DriverInitInfoPtr initialInfo) {#pragma unused (addressSpaceID, initialInfo)  OSStatus      err = noErr;#if DEBUG  SysDebugStr (&quot;\pin DriverInitializeCmd;g&quot;);#endif  gDrvrRefNum = initialInfo-&gt;refNum;#if DEBUG  if (err != noErr) {    SysDebugStr (&quot;\p!!Error in DriverInitializeCmd!!&quot;);  }#if FULLDEBUG  SysDebugStr (&quot;\pleaving DriverInitializeCmd;g&quot;);#endif#endif  return (err);}/*  Always run at task level, can allocate and move memory.*/static OSStatus DriverFinalizeCmd (DriverFinalInfoPtr finalInfo) {#pragma unused (finalInfo)  OSStatus      err = noErr;#if DEBUG  SysDebugStr (&quot;\pin DriverFinalizeCmd;g&quot;);#endif#if DEBUG  if (err != noErr) {    SysDebugStr (&quot;\p!!Error in DriverFinalizeCmd!!&quot;);  }#if FULLDEBUG  SysDebugStr (&quot;\pleaving DriverFinalizeCmd;g&quot;);#endif#endif  return (err);}/*  Always run at task level, can allocate and move memory.*/static OSStatus DriverSupersededCmd (DriverSupersededInfoPtr supersededInfo) {#pragma unused (supersededInfo)  OSErr      err = noErr;#if DEBUG  SysDebugStr (&quot;\pin DriverSupersededCmd;g&quot;);#endif#if DEBUG  if (err != noErr) {    SysDebugStr (&quot;\p!!Error in DriverSupersededCmd!!&quot;);  }#if FULLDEBUG  SysDebugStr (&quot;\pleaving DriverSupersededCmd;g&quot;);#endif#endif  return (err);}/*  Always run at task level, can allocate and move memory.*/static OSStatus DriverReplaceCmd (AddressSpaceID addressSpaceID, DriverReplaceInfoPtr replaceInfo) {#pragma unused (addressSpaceID, replaceInfo)  OSStatus      err = noErr;#if DEBUG  SysDebugStr (&quot;\pin DriverReplaceCmd;g&quot;);#endif#if DEBUG  if (err != noErr) {    SysDebugStr (&quot;\p!!Error in DriverReplaceCmd!!&quot;);  }#if FULLDEBUG  SysDebugStr (&quot;\pleaving DriverReplaceCmd;g&quot;);#endif#endif  return (err);}/*  Always run at task level, can allocate and move memory.*/static OSStatus DriverOpenCmd (AddressSpaceID addressSpaceID, ParmBlkPtr pb) {#pragma unused (addressSpaceID, pb)  OSStatus      err = noErr;#if DEBUG  SysDebugStr (&quot;\pin DriverOpenCmd;g&quot;);#endif  gSoundBuffer = NewPtrSys (kSamplesInBuffer * 4);  //room for 16 bit stereo samples  if (gSoundBuffer != nil) {    gSimulatedHWIntProc = NewTimerProc (HWIntProc);    SetHardwareToDefault ();    err = SPBSignInDevice (gDrvrRefNum, *gDriverName);  } else {  #if DEBUG    SysDebugStr (&quot;\p!!couldn't allocate memory for our buffer!!&quot;);  #endif    err = MemError ();  }#if DEBUG  if (err != noErr) {    SysDebugStr (&quot;\p!!Error in DriverOpenCmd!!&quot;);  }#if FULLDEBUG  SysDebugStr (&quot;\pleaving DriverOpenCmd;g&quot;);#endif#endif  return (err);}/*  Always run at task level, can allocate and move memory.*/static OSStatus DriverCloseCmd (ParmBlkPtr pb) {#pragma unused (pb)  OSStatus      err = noErr;#if DEBUG  SysDebugStr (&quot;\pin DriverCloseCmd;g&quot;);#endif  (void)SPBSignOutDevice (gDrvrRefNum);  DisposePtr (gSoundBuffer);  gSoundBuffer = nil;  DisposeRoutineDescriptor (gSimulatedHWIntProc);  gSimulatedHWIntProc = nil;#if FULLDEBUG  SysDebugStr (&quot;\pleaving DriverCloseCmd;g&quot;);#endif  return (err);}/*  May run at interrupt level, CANNOT allocate or move memory.*/static OSStatus DriverControlCmd (AddressSpaceID addressSpaceID, IOCommandID ioCommandID, IOCommandKind ioCommandKind, SoundParamPtr pb) {#pragma unused (addressSpaceID, ioCommandID, ioCommandKind)  OSStatus      err      = noErr;  OSType        selector  = 0;#if FULLDEBUG  SysDebugStr (&quot;\pin DriverControlCmd;g&quot;);#endif  // if they call SPBStopRecording, it comes to us as killIO  // so call our killIO routine  if (pb-&gt;csCode == killCode) {    err = DriverKillIOCmd ((ParmBlkPtr)pb);  }    else if (pb-&gt;csCode == 2) {      // indicates that sound input information selector is in first 4 bytes of csParam    selector = ((OSType*)pb-&gt;csParam)[0];  }  switch (selector) {    //Control calls that are required to be supported    case siCompressionType:      //Set the compression type. Some devices allow the incoming samples to be      //compressed before being placed in your application's input buffer. The      //infoData parameter points to a buffer of type OSType, which is the      //compression type.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siCompressionType&quot;);    #endif      if (((OSType*)pb-&gt;csParam)[1] != 'NONE') {        err = siInvalidCompression;  //we don't support compression      }      break;    case siContinuous:      //Set the state of continuous recording from this device. If recording      //is being turned off, the driver stops recording samples to its internal buffer.      //Only sound input device drivers that support asynchronous recording support      //continuous recording. The infoData parameter points to an integer, which is      //the state of continuous recording (0 is off, 1 is on).    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siContinuous&quot;);    #endif      if (((SInt16*)pb-&gt;csParam)[2] == 0 || ((SInt16*)pb-&gt;csParam)[2] == 1) {        gContinuousOn = ((SInt16*)pb-&gt;csParam)[2];      } else {        err = paramErr;      }      break;    case siLevelMeterOnOff:      //Set the current state of the level meter. For calls to set the level meter,      //the infoData parameter points to an integer that indicates whether the level meter      //is off (0) or on (1).    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siLevelMeterOnOff&quot;);    #endif      if (((SInt16*)pb-&gt;csParam)[2] == 0 || ((SInt16*)pb-&gt;csParam)[2] == 1) {        gLevelMeterOn = ((SInt16*)pb-&gt;csParam)[2];      } else {        err = paramErr;      }      break;    case siNumberChannels:      //Set the number of channels this device is to record. The infoData parameter points      //to an integer, which indicates the number of channels. Note that this selector      //determines the format of the data stream output by the driver. If the number of      //channels is 1, the driver should output monophonic data in response to a Read call.      //If the number of channels is 2, the driver should output interleaved stereo data.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siNumberChannels&quot;);    #endif      if (((SInt16*)pb-&gt;csParam)[2] &gt;= 1 &amp;&amp; ((SInt16*)pb-&gt;csParam)[2] &lt;= 2) {        gNumberChannels = ((SInt16*)pb-&gt;csParam)[2];      } else {        err = notEnoughHardwareErr;      }      break;    case siRecordingQuality:      //Set the current quality of recorded sound. The infoData parameter points to a buffer      //of type OSType, which is the recording quality. Currently foud qualities are supported,      //defined by these constants:      //      siCDQuality              = 'cd  ',        /*44.1kHz, stereo, 16 bit*/      //      siBestQuality            = 'best';        /*22kHz, mono, 8 bit*/      //      siBetterQuality            = 'betr';        /*22kHz, mono, MACE 3:1*/      //      siGoodQuality            = 'good';      //These qualities are defined by the sound input device driver. Usually best means      //monaural, 8-bit, 22 kHz, sound with no compression.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siRecordingQuality&quot;);    #endif      switch (((OSType*)pb-&gt;csParam)[1]) {        case siCDQuality:          gRecordingQuality = siCDQuality;          gSampleRate = rate44khz;          gSampleSize = 16;          gNumberChannels = 2;          gCompressionType = 'NONE';          break;        case siBestQuality:          gRecordingQuality = siBestQuality;          gSampleRate = rate22050hz;          gSampleSize = 8;          gNumberChannels = 1;          gCompressionType = 'NONE';          break;        case siBetterQuality:          gRecordingQuality = siBetterQuality;          gSampleRate = rate22050hz;          gSampleSize = 8;          gNumberChannels = 1;          gCompressionType = 'NONE';          break;        case siGoodQuality:          gRecordingQuality = siGoodQuality;          gSampleRate = rate11025hz;          gSampleSize = 8;          gNumberChannels = 1;          gCompressionType = 'NONE';          break;        default:          err = siUnknownQuality;      }      break;    case siSampleRate:      //Set the sample rate to be produced by this device. The sample rate must be in the      //range 0 to 65535.65535 Hz. The sample rate is declared as a Fixed data type. In      //order to accommodate sample rates greater than 32 kHz, the most significant bit is      //not treated as a sign bit; instead, that bit is interpreted as having the value 32,768.      //The infoData parameter points to a buffer of type Fixed, which is the sample rate.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siSampleRate&quot;);    #endif      if (((UnsignedFixed*)pb-&gt;csParam)[1] == rate44khz || ((UnsignedFixed*)pb-&gt;csParam)[1] == rate22050hz || ((UnsignedFixed*)pb-&gt;csParam)[1] == rate11025hz) {        gSampleRate = ((UnsignedFixed*)pb-&gt;csParam)[1];      } else {        err = siInvalidSampleRate;      }      break;    case siSampleSize:      //Set the sample size to be produced by this device. Because some compression formats      //require specific sample sizes, this selector might return an error when compression      //is used. The infoData parameter points to an integer, which is the sample size.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siSampleSize&quot;);    #endif      if (((SInt16*)pb-&gt;csParam)[2] == 8 || ((SInt16*)pb-&gt;csParam)[2] == 16) {        gSampleSize = ((SInt16*)pb-&gt;csParam)[2];      } else {        err = siInvalidSampleSize;      }      break;    case siTwosComplementOnOff:      //Set the current state of the two's complement feature. This selector only applies to      //8-bit data. (16-bit samples are always stored in two's complement format.) If on, the      //driver stores all samples in the application buffer as two's complement values      //(that is, \xD0128 to 127). Otherwise, the driver stores the samples as offset binary      //values (that is, 0 to 255). The infoData parameter points to an integer, which is the      //current state of the two's complement feature (1 if two's complement output is desired,      //0 otherwise).    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siTwosComplementOnOff&quot;);    #endif      if (((SInt16*)pb-&gt;csParam)[2] == 0 || ((SInt16*)pb-&gt;csParam)[2] == 1) {        gTwosComplementOn = ((SInt16*)pb-&gt;csParam)[2];      } else {        err = paramErr;      }      break;    //Sound Manager only calls    case siCloseDriver:      //The Sound Input Manager sends this selector when it closes a device previously      //opened with write permission. The sound input device driver should stop any      //recording in progress, deallocate the input hardware, and initialize local      //variables to default settings.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siCloseDriver&quot;);    #endif      //We will actually stop the hardware at the next hardware interrupt      gStopRecording = true;      break;    case siInitializeDriver:      //The Sound Input Manager sends this selector when it opens a sound input device      //with write permission. The sound input device driver initializes local variables      //and prepares to start recording. If possible, the driver initializes the device      //to a sampling rate of 22 kHz, a sample size of 8 bits, mono recording, no compression,      //automatic gain control on, and all other features off.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siInitializeDriver&quot;);    #endif      SetHardwareToDefault ();      break;    case siPauseRecording:      //The Sound Input Manager uses this selector to set the current pause state.      //The sound input device driver continues recording but does not store the sampled      //data in a buffer. The infoData parameter points to an integer, which indicates      //the state of pausing (0 is off, 1 is on).    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siPauseRecording&quot;);    #endif      gPauseState = ((SInt16*)pb-&gt;csParam)[2];      break;    case siUserInterruptProc:      //The Sound Input Manager sends this selector to specify the sound input interrupt      //routine that the sound input device driver should call. The infoData parameter      //points to a procedure pointer, which is the address of the sound input interrupt routine.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siUserInterruptProc&quot;);    #endif      gUserInterruptProc = ((SIInterruptUPP*)pb-&gt;csParam)[1];      break;    //Control calls that can be optionally supported    case siActiveChannels:      //Set the channels to record from. When setting the active channels, the data passed      //in is a long integer that is interpreted as a bitmap describing the channels to record      //from. For example, if bit 0 is set, then the first channel is made active. The samples      //for each active channel are interleaved in the application's buffer.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siActiveChannels&quot;);    #endif      if (((SInt32*)pb-&gt;csParam)[1] &gt;= 0x01 &amp;&amp; ((SInt32*)pb-&gt;csParam)[1] &lt;= 0x03) {        gActiveChannels = ((SInt32*)pb-&gt;csParam)[1];      } else {        err = notEnoughHardwareErr;      }      break;    case siAGCOnOff:      //Set the current state of the automatic gain control feature. The infoData parameter      //points to an integer, which is 0 if gain control is off and 1 if it is on.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siAGCOnOff&quot;);    #endif      if (((SInt16*)pb-&gt;csParam)[2] == 0 || ((SInt16*)pb-&gt;csParam)[2] == 1) {        gAGCOn = ((SInt16*)pb-&gt;csParam)[2];      } else {        err = paramErr;      }      break;    case siInputGain:      //Set the current sound input gain. If the available hardware allows adjustment of the      //recording gain, this selector lets you get and set the gain. In response to a Control      //call, a sound input driver sets the gain level used for all subsequent recording to the      //specified value. The infoData parameter points to a 4-byte value of type Fixed ranging      //from 0.5 to 1.5, where 1.5 specifies maximum gain.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siInputGain&quot;);    #endif      if (((Fixed*)pb-&gt;csParam)[1] &gt;= (Fixed)0.5 &amp;&amp; ((Fixed*)pb-&gt;csParam)[1] &lt;= (Fixed)1.5) {        gInputGain = ((Fixed*)pb-&gt;csParam)[1];      } else {        err = paramErr;      }      break;    case siInputSource:      //Set the current sound input source. If the available hardware allows recording from more      //than one source, this selector lets you get and set the source. In response to a Control      //call, a sound input driver sets the source of all subsequent recording to the value passed      //in. If the value is less than 1 or greater than the number of input sources, the driver      //returns paramErr; if the driver supports only one source, it returns siUnknownInfoType. The      //infoData parameter points to an integer, which is the index of the current sound input source.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siInputSource&quot;);    #endif      if (((SInt16*)pb-&gt;csParam)[2] &gt;= 1 &amp;&amp; ((SInt16*)pb-&gt;csParam)[2] &lt;= 3) {        gCurrentInputSource = ((SInt16*)pb-&gt;csParam)[2];      } else {        err = notEnoughHardwareErr;      }      break;    case siOptionsDialog:      //Cause the driver to display the Options dialog box (SPBSetDeviceInfo). This dialog box      //is designed to allow the user to configure device-specific features of the sound input      //hardware. With SPBSetDeviceInfo, the infoData parameter is unused.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siOptionsDialog&quot;);    #endif      err = DoOptionsDialog ();      break;    case siPlayThruOnOff:      //Set the current play-through state and volume. The infoData parameter points to an integer,      //which indicates the current play-through volume (1 to 7). If that integer is 0, then      //play-through is off.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siPlayThruOnOff&quot;);    #endif      err = notEnoughHardwareErr;      //  If our (fake) hardware actually did playthrough, this would be useful...    /*      if (((short*)pb-&gt;csParam)[2] &gt;= 0 || ((short*)pb-&gt;csParam)[2] &lt;= 7) {        gPlayThruVolume = ((short*)pb-&gt;csParam)[2];      } else {        err = notEnoughHardwareErr;      }    */      break;    case siStereoInputGain:      //Set the current stereo sound input gain. If the available hardware allows adjustment of      //the recording gain, this selector lets you get and set the gain for each of two channels      //(left or right). In response to a Status call, a sound input driver should return the      //current gain setting for the specified channel. In response to a Control call, a sound input      //driver should set the gain level used for all subsequent recording to the specified value.      //The infoData parameter points to two 4-byte values of type Fixed ranging from 0.5 to 1.5,      //where 1.5 specifies maximum gain. The first of these values is equivalent to the gain for      //the left channel and the second value is equivalent to the gain for the right channel.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siStereoInputGain&quot;);    #endif      if (((Fixed*)pb-&gt;csParam)[1] &lt;= 1.5 &amp;&amp; ((Fixed*)pb-&gt;csParam)[1] &gt;= 0.5 &amp;&amp; ((Fixed*)pb-&gt;csParam)[2] &lt;= 1.5 &amp;&amp; ((Fixed*)pb-&gt;csParam)[2] &gt;= 0.5) {        gLeftInputGain = ((Fixed*)pb-&gt;csParam)[1];        gRightInputGain = ((Fixed*)pb-&gt;csParam)[2];      } else {        err = paramErr;      }      break;    case siVoxRecordInfo:      //Set the current VOX recording parameters. The infoData parameter points to two integers.      //The first integer indicates whether VOX recording is on or off (0 if off, 1 if on). The      //second integer indicates the VOX record trigger value. Trigger values range from 0 to 255      //(0 is trigger immediately, 255 is trigger only on full volume).    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siVoxRecordInfo&quot;);    #endif      if (((SInt16*)pb-&gt;csParam)[2] == 0 || ((SInt16*)pb-&gt;csParam)[2] == 1) {        gVoxRecordingOn = ((SInt16*)pb-&gt;csParam)[2];      } else {        err = paramErr;      }      if (gVoxRecordingOn == 1 &amp;&amp; (((SInt16*)pb-&gt;csParam)[3] &lt;= 255 &amp;&amp; ((SInt16*)pb-&gt;csParam)[3] &gt;= 0)) {        gVOXStartTrigger = ((SInt16*)pb-&gt;csParam)[3];      } else {        err = paramErr;      }      break;    case siVoxStopInfo:      //Set the current VOX stopping parameters. The infoData parameter points to three integers.      //The first integer indicates whether VOX stopping is on or off (0 if off, 1 if on). The      //second integer indicates the VOX stop trigger value. Trigger values range from 0 to 255      //(255 is stop immediately, 0 is stop only on total silence). The third integer indicates      //how many milliseconds the trigger value must be continuously valid for recording to be stopped.      //Delay values range from 0 to 65,535.    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siVoxStopInfo&quot;);    #endif      if (((SInt16*)pb-&gt;csParam)[2] == 0 || ((SInt16*)pb-&gt;csParam)[2] == 1) {        gVoxStoppingOn = ((SInt16*)pb-&gt;csParam)[2];      } else {        err = paramErr;      }      if (gVoxStoppingOn == 1 &amp;&amp; (((SInt16*)pb-&gt;csParam)[3] &lt;= 255 &amp;&amp; ((SInt16*)pb-&gt;csParam)[3] &gt;= 0)) {        gVOXStopTrigger = ((SInt16*)pb-&gt;csParam)[3];        gVOXDelay = ((SInt16*)pb-&gt;csParam)[4];      } else {        err = paramErr;      }      break;    //Unknown or unsupported control call    default:    #if DEBUG      {        Str255  errString = &quot;\pcontrol: unknown selector -&gt; XXXX&quot;;        OSType*  typePtr;                typePtr = (OSType*)(&amp;errString[30]);        *typePtr = selector;        SysDebugStr ( errString );      }//      SysDebugStr (&quot;\pcontrol: unknown selector&quot;);    #endif      err = controlErr;  }#if DEBUG  if (err != noErr &amp;&amp; err != controlErr) {    unsigned char    errorcode[11];    sprintf ((char*)errorcode, &quot;0x%0.8X&quot;, err);    errorcode[0] = 10;    SysDebugStr (errorcode);    SysDebugStr (&quot;\p!!Error in DriverControlCmd!!&quot;);  }#if FULLDEBUG  SysDebugStr (&quot;\pleaving DriverControlCmd;g&quot;);#endif#endif  return (err);}/*  May run at interrupt level, CANNOT allocate or move memory.*/static OSStatus DriverStatusCmd (AddressSpaceID addressSpaceID, IOCommandID ioCommandID, IOCommandKind ioCommandKind, SoundParamPtr pb) {#pragma unused (addressSpaceID, ioCommandID, ioCommandKind)  OSStatus      err      = noErr;  OSType        selector  = 0;  Handle        iconHandle,            compressionAvailable,            sampleRateAvailable,            sampleSizeAvailable;  SoundInfoList    info;#if FULLDEBUG  SysDebugStr (&quot;\pin DriverStatusCmd;g&quot;);#endif  if (pb-&gt;csCode == 2) {    selector = ((OSType*)pb-&gt;csParam)[0];  }  switch (selector) {    //Status calls that are required to be supported    case siAsync:      //Determine whether the driver supports asynchronous recording functions. The infoData parameter      //points to an integer, which is 0 if the driver supports synchronous calls only and 1 otherwise.      //Some sound input drivers do not support asynchronous recording at all, and some might support      //asynchronous recording only on certain hardware configurations.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siAsync;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = 1;  //we can do async recording      break;    case siChannelAvailable:      //Get the maximum number of channels this device can record. The infoData parameter points to an      //integer, which is the number of available channels.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siChannelAvailable;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = 2;  //we can do stereo (note: Sound Manager doesn't currently work with more than 2 channels)      break;    case siCompressionAvailable:      //Get the number and list of compression types this device can produce. The infoData parameter      //points to an integer, which is the number of compression types, followed by a handle. The      //handle references a list of compression types, each of type OSType.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siCompressionAvailable;g&quot;);    #endif      compressionAvailable = NewHandle (sizeof (OSType) * kNumCompressions);      if (compressionAvailable != nil) {        ((OSType*)*compressionAvailable)[0] = 'NONE';        info.count = kNumCompressions;        info.infoHandle = compressionAvailable;        ((SInt32*)pb-&gt;csParam)[0] = sizeof (SoundInfoList);    //number of bytes being returned        *(SoundInfoList*)(pb-&gt;csParam+2) = info;      }      break;    case siCompressionFactor:      //Get the compression factor of the current compression type. For example, the compression factor      //for MACE 3:1 compression is 3. If a sound input device driver supports only compression type 'NONE',      //the returned compression type is 1. The infoData parameter points to an integer, which is the      //compression factor.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siCompressionFactor;g&quot;);    #endif      if (gCompressionType == 'NONE') {        ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned        ((SInt16*)pb-&gt;csParam)[2] = 1;  //no compression equals 1:1      }      break;    case siCompressionType:      //Get the compression type. Some devices allow the incoming samples to be compressed before being      //placed in your application's input buffer. The infoData parameter points to a buffer of type      //OSType, which is the compression type.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siCompressionType;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 4;  //number of bytes being returned      ((OSType*)pb-&gt;csParam)[1] = gCompressionType;      break;    case siContinuous:      //Get the state of continuous recording from this device. If recording is being turned off, the      //driver stops recording samples to its internal buffer. Only sound input device drivers that      //support asynchronous recording support continuous recording. The infoData parameter points to an      //integer, which is the state of continuous recording (0 is off, 1 is on).    #if DEBUG2      SysDebugStr (&quot;\pstatus: siContinuous;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = gContinuousOn;      break;    case siDeviceBufferInfo:      //Get the size of the device's internal buffer. This information can be useful when you want to      //modify sound input data at interrupt time. Note, however, that if a driver is recording continuously,      //then the size of the buffer passed to your sound input interrupt routine might be greater than the      //size this selector returns because data recorded between calls to SPBRecord as well as recorded      //during calls to SPBRecord will be sent to your interrupt routine. The infoData parameter points to      //a long integer, which is the size of the device's internal buffer.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siDeviceBufferInfo;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 4;  //number of bytes being returned      ((SInt32*)pb-&gt;csParam)[1] = kSamplesInBuffer * gNumberChannels * (gSampleSize / 8);      break;    case siDeviceConnected:      //Get the state of the device connection. The infoData parameter points to an integer, which is one      //of the following constants:      //      siDeviceIsConnected          = 1;      //      siDeviceNotConnected        = 0;      //      siDontKnowIfConnected        = -1;      //The siDeviceIsConnected constant indicates that the device is connected and ready. The      //siDeviceNotConnected constant indicates that the device is not connected. The siDontKnowIfConnected      //constant indicates that the Sound Input Manager cannot determine whether the device is connected.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siDeviceConnected;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = siDeviceIsConnected;      break;    case siDeviceIcon:      //Get the device's icon and icon mask. In response to a Status call, a sound input device driver      //should return, in the location specified by the infoData parameter, a handle to a block of memory      //that contains the icon and its mask in the format of an 'ICN#' resource. It is the driver's      //responsibility to allocate that block of memory, but it should not releasee it. The software issuing      //this selector is responsible for disposing of the handle. As a result, a device driver should detach      //any resource handles (by calling DetachResource) before returning them to the caller.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siDeviceIcon;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 4;  //number of bytes being returned      iconHandle = gDrvrIcon;      err = HandToHand (&amp;iconHandle);      if (err != noErr) {        SysDebugStr (&quot;\pHandToHand returned an error&quot;);      }      ((Handle*)pb-&gt;csParam)[1] = iconHandle;      break;    case siDeviceName:      //Get the name of the sound input device. Your application must pass a pointer to a buffer that will      //be filled in with the device's name. The buffer needs to be large enough to hold a Str255 data type.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siDeviceName;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 0;  //Sound Manager doesn't have to copy any data      BlockMoveData (gDriverName[0], ((Handle*)pb-&gt;csParam)[1], *gDriverName[0]+1);      break;    case siLevelMeterOnOff:      //Get the current state of the level meter. To get the level meter setting, the infoData parameter      //points to two integers; the first integer indicates the state of the level meter, and the second      //integer contains the level value of the meter. The level meter setting is an integer that ranges      //from 0 (no volume) to 255 (full volume).     #if DEBUG2      SysDebugStr (&quot;\pstatus: siLevelMeterOnOff;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 4;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = gLevelMeterOn;      ((SInt16*)pb-&gt;csParam)[3] = 0;      break;    case siNumberChannels:      //Get the number of channels this device is to record. The infoData parameter points to an integer,      //which indicates the number of channels. Note that this selector determines the format of the data      //stream output by the driver. If the number of channels is 1, the driver should output monophonic data      //in response to a Read call. If the number of channels is 2, the driver should output interleaved      //stereo data.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siNumberChannels;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = gNumberChannels;      break;    case siRecordingQuality:      //Get the current quality of recorded sound. The infoData parameter points to a buffer of type      //OSType, which is the recording quality. Currently four qualities are supported, defined by      //these constants:      //      siCDQuality              = 'cd  ',        /*44.1kHz, stereo, 16 bit*/      //      siBestQuality            = 'best';        /*22kHz, mono, 8 bit*/      //      siBetterQuality            = 'betr';        /*22kHz, mono, MACE 3:1*/      //      siGoodQuality            = 'good';      //These qualities are defined by the sound input device driver. Usually best means monaural,      //8-bit, 22 kHz, sound with no compression.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siRecordingQuality;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 4;  //number of bytes being returned      ((OSType*)pb-&gt;csParam)[1] = gRecordingQuality;      break;    case siSampleRate:      //Get the sample rate to be produced by this device. The sample rate must be in the range 0 to      //65535.65535 Hz. The sample rate is declared as a Fixed data type. In order to accommodate sample      //rates greater than 32 kHz, the most significant bit is not treated as a sign bit; instead, that      //bit is interpreted as having the value 32,768. The infoData parameter points to a buffer of type      //Fixed, which is the sample rate.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siSampleRate;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 4;  //number of bytes being returned      ((UnsignedFixed*)pb-&gt;csParam)[1] = gSampleRate;      break;    case siSampleRateAvailable:      //Get the range of sample rates this device can produce. The infoData parameter points to an integer,      //which is the number of sample rates the device supports, followed by a handle. The handle references      //a list of sample rates, each of type Fixed. If the device can record a range of sample rates, the      //number of sample rates is set to 0 and the handle contains two rates, the minimum and the maximum      //of the range of sample rates. Otherwise, a list is returned that contains the sample rates supported.      //In order to accommodate sample rates greater than 32 kHz, the most significant bit is not treated as      //a sign bit; instead, that bit is interpreted as having the value 32,768.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siSampleRateAvailable;g&quot;);    #endif      sampleRateAvailable = NewHandle (sizeof (UnsignedFixed) * kNumRates);      if (sampleRateAvailable != nil) {        ((UnsignedFixed*)*sampleRateAvailable)[0] = rate44khz;        ((UnsignedFixed*)*sampleRateAvailable)[1] = rate22050hz;        ((UnsignedFixed*)*sampleRateAvailable)[2] = rate11025hz;        info.count = kNumRates;        info.infoHandle = sampleRateAvailable;        ((SInt32*)pb-&gt;csParam)[0] = sizeof (SoundInfoList);    //number of bytes being returned        *(SoundInfoList*)(pb-&gt;csParam+2) = info;      }      break;    case siSampleSize:      //Get the sample size to be produced by this device. Because some compression formats require specific      //sample sizes, this selector might return an error when compression is used. The infoData parameter      //points to an integer, which is the sample size.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siSampleSize;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = gSampleSize;      break;    case siSampleSizeAvailable:      //Get the range of sample sizes this device can produce. The infoData parameter points to an integer,      //which is the number of sample sizes the device supports, followed by a handle. The handle references      //a list of sample sizes, each of type Integer.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siSampleSizeAvailable;g&quot;);    #endif      sampleSizeAvailable = NewHandle (sizeof (SInt16) * kNumSizes);      if (sampleSizeAvailable != nil) {        ((SInt16*)*sampleSizeAvailable)[0] = 8;        ((SInt16*)*sampleSizeAvailable)[1] = 16;        info.count = kNumSizes;        info.infoHandle = sampleSizeAvailable;        ((SInt32*)pb-&gt;csParam)[0] = sizeof (SoundInfoList);    //number of bytes being returned        *(SoundInfoList*)(pb-&gt;csParam+2) = info;      }      break;    case siTwosComplementOnOff:      //Get the current state of the two's complement feature. This selector only applies to 8-bit data.      //(16-bit samples are always stored in two's complement format.) If on, the driver stores all samples      //in the application buffer as two's complement values (that is, \xD0128 to 127). Otherwise, the driver      //stores the samples as offset binary values (that is, 0 to 255). The infoData parameter points to an      //integer, which is the current state of the two's complement feature (1 if two's complement output      //is desired, 0 otherwise).    #if DEBUG2      SysDebugStr (&quot;\pstatus: siTwosComplementOnOff;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = gTwosComplementOn;      break;    //Sound Manager only call    case siPauseRecording:      //The Sound Input Manager uses this selector to get the current pause state.      //The sound input device driver continues recording but does not store the sampled      //data in a buffer. The infoData parameter points to an integer, which indicates      //the state of pausing (0 is off, 1 is on).    #if DEBUG2      SysDebugStr (&quot;\pcontrol: siPauseRecording;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = gPauseState;      break;    //Status calls that can be optionally supported    case siActiveChannels:      //Get the channels to record from. When reading the active channels, the data returned is      //a bitmap of the active channels.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siActiveChannels;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 4;  //number of bytes being returned      ((SInt32*)pb-&gt;csParam)[1] = gActiveChannels;      break;    case siActiveLevels:      //Get the current signal level for each active channel. The infoData parameter points to an array      //of integers, the size of which depends on the number of active channels. You can determine how      //many channels are active by calling SPBGetDeviceInfo with the siNumberChannels selector.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siActiveLevels;g&quot;);    #endif      if (gNumberChannels == 1) {        ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned        ((SInt16*)pb-&gt;csParam)[2] = 0;      } else if (gNumberChannels == 2) {        ((SInt32*)pb-&gt;csParam)[0] = 4;  //number of bytes being returned        ((SInt16*)pb-&gt;csParam)[2] = 0;        ((SInt16*)pb-&gt;csParam)[3] = 0;      }      break;    case siAGCOnOff:      //Get the current state of the automatic gain control feature. The infoData parameter points to an      //integer, which is 0 if gain control is off and 1 if it is on.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siAGCOnOff;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = gAGCOn;      break;    case siCompressionHeader:      //Get a compressed sound header for the current recording settings. Your application passes in a      //pointer to a compressed sound header and the driver fills it in. Before calling SPBGetDeviceInfo      //with this selector, you should set the numFrames field of the compressed sound header to the number      //of bytes in the sound. When SPBGetDeviceInfo returns successfully, that field contains the number      //of sample frames in the sound. This selector is needed only by drivers that use compression types      //that are not directly supported by Apple. If you call this selector after recording a sound, your      //application can get enough information about the sound to play it or save it in a file. The infoData      //parameter points to a compressed sound header.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siCompressionHeader;g&quot;);    #endif      err = siUnknownInfoType;  //we don't support compression      break;    case siCompressionNames:      //Get a list of names of the compression types supported by the sound input device. In response to a      //Status call, a sound input device driver returns, in the location specified by the infoData parameter,      //a handle to a block of memory that contains the names of all compression types supported by the driver.      //It is the driver's responsibility to allocate that block of memory, but it should not release it. The      //software issuing this selector is responsible for disposing of the handle. As a result, a device driver      //must detach any resource handles (by calling DetachResource) before returning them to the caller. The      //data in the handle has the same format as an 'STR#' resource: a two-byte count of the strings in the      //resource, followed by the strings themselves. The strings should occur in the same order as the      //compression types returned by the siCompressionAvailable selector. If the driver does not support      //compression, it returns siUnknownInfoType. If the driver supports compression but for some reason not      //all compression types are currently selectable, it returns a list of all available compression types.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siCompressionNames;g&quot;);    #endif      err = siUnknownInfoType;  //we don't support compression      break;    case siInputGain:      //Get the current sound input gain. If the available hardware allows adjustment of the recording gain,      //this selector lets you get and set the gain. In response to a Status call, a sound input driver returns      //the current gain setting. The infoData parameter points to a 4-byte value of type Fixed ranging from      //0.5 to 1.5, where 1.5 specifies maximum gain.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siInputGain;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 4;  //number of bytes being returned      ((Fixed*)pb-&gt;csParam)[1] = gInputGain;      break;    case siInputSource:      //Get the current sound input source. If the available hardware allows recording from more than one      //source, this selector lets you get and set the source. In response to a Status call, a sound input      //driver returns the current source value; if the driver supports only one source, it returns      //siUnknownInfoType.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siInputSource;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = gCurrentInputSource;      break;    case siInputSourceNames:      //Get a list of the names of all the sound input sources supported by the sound input device. In      //response to a Status call, a sound input device driver returns, in the location specified by the      //infoData parameter, a handle to a block of memory that contains the names of all sound sources      //supported by the driver. It is the driver's responsibility to allocate that block of memory, but it      //should not release it. The software issuing this selector is responsible for disposing of the handle.      //As a result, a device driver must detach any resource handles (by calling DetachResource) before      //returning them to the caller. The data in the handle has the same format as an 'STR#' resource: a      //two-byte count of the strings in the resource, followed by the strings themselves. The strings should      //occur in the same order as the input sources returned by the siInputSource selector. If the driver      //supports only one source, it returns siUnknownInfoType. If the driver supports more than one source      //but for some reason not all of them are currently selectable, it returns a list of all available      //input sources.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siInputSourceNames;g&quot;);    #endif      {        Handle h;        OSErr  err;                h = gInputSourceNames;        // handle we want to copy        err = HandToHand( &amp;h );        // copy it                if( !err )        {          ((SInt32*)pb-&gt;csParam)[0] = 4;  //number of bytes being returned          ((Handle*)pb-&gt;csParam)[1] = h;  //handle to data        }        else        ((SInt32*)pb-&gt;csParam)[0] = 0;        }      break;    case siOptionsDialog:      //Determine whether the driver supports an Options dialog box (SPBGetDeviceInfo). This dialog box is      //designed to allow the user to configure device-specific features of the sound input hardware. With      //SPBGetDeviceInfo, the infoData parameter points to an integer, which indicates whether the driver      //supports an Options dialog box (1 if it supports it, 0 otherwise).    #if DEBUG2      SysDebugStr (&quot;\pstatus: siOptionsDialog;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = 1;  //we have a dialog      break;    case siPlayThruOnOff:      //Get the current play-through state and volume. The infoData parameter points to an integer,      //which indicates the current play-through volume (1 to 7). If that integer is 0, then      //play-through is off.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siPlayThruOnOff;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 2;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = gPlayThruVolume;      break;    case siStereoInputGain:      //Get the current stereo sound input gain. If the available hardware allows adjustment of the recording      //gain, this selector lets you get and set the gain for each of two channels (left or right). In response      //to a Status call, a sound input driver should return the current gain setting for the specified channel.      //The infoData parameter points to two 4-byte values of type Fixed ranging from 0.5 to 1.5, where 1.5      //specifies maximum gain. The first of these values is equivalent to the gain for the left channel and the      //second value is equivalent to the gain for the right channel.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siStereoInputGain;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 8;  //number of bytes being returned      ((Fixed*)pb-&gt;csParam)[1] = gLeftInputGain;      ((Fixed*)pb-&gt;csParam)[2] = gRightInputGain;      break;    case siVoxRecordInfo:      //Get the current VOX recording parameters. The infoData parameter points to two integers. The first      //integer indicates whether VOX recording is on or off (0 if off, 1 if on). The second integer indicates      //the VOX record trigger value. Trigger values range from 0 to 255 (0 is trigger immediately, 255 is      //trigger only on full volume).    #if DEBUG2      SysDebugStr (&quot;\pstatus: siVoxRecordInfo;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 4;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = gVoxRecordingOn;      ((SInt16*)pb-&gt;csParam)[3] = gVOXStartTrigger;      break;    case siVoxStopInfo:      //Get the current VOX stopping parameters. The infoData parameter points to three integers. The      //first integer indicates whether VOX stopping is on or off (0 if off, 1 if on). The second integer      //indicates the VOX stop trigger value. Trigger values range from 0 to 255 (255 is stop immediately, 0      //is stop only on total silence). The third integer indicates how many milliseconds the trigger value must      //be continuously valid for recording to be stopped. Delay values range from 0 to 65,535.    #if DEBUG2      SysDebugStr (&quot;\pstatus: siVoxStopInfo;g&quot;);    #endif      ((SInt32*)pb-&gt;csParam)[0] = 6;  //number of bytes being returned      ((SInt16*)pb-&gt;csParam)[2] = gVoxStoppingOn;      ((SInt16*)pb-&gt;csParam)[3] = gVOXStopTrigger;      ((SInt16*)pb-&gt;csParam)[4] = gVOXDelay;      break;    //Unknown or unsupported status call    default:    #if DEBUG      SysDebugStr (&quot;\pstatus: unknown selector;g&quot;);    #endif      err = statusErr;  }#if DEBUG  if (err != noErr &amp;&amp; err != statusErr &amp;&amp; err != siUnknownInfoType) {    SysDebugStr (&quot;\p!!Error in DriverStatusCmd!!&quot;);  }#if FULLDEBUG  SysDebugStr (&quot;\pleaving DriverStatusCmd;g&quot;);#endif#endif  return (err);}/*  May run at interrupt level, CANNOT allocate or move memory.*/static OSStatus DriverReadCmd (AddressSpaceID addressSpaceID, IOCommandID ioCommandID, IOCommandKind ioCommandKind, ParmBlkPtr pb) {#pragma unused (addressSpaceID, ioCommandID, ioCommandKind)  OSStatus      err = noErr;  double      samplesInBuffer = kSamplesInBuffer,temp, temp2;#if DEBUG  SysDebugStr (&quot;\pin DriverReadCmd;g&quot;);#endif  gSimulatedHWInterrupt.theTask.tmAddr = gSimulatedHWIntProc;  gSimulatedHWInterrupt.theTask.tmWakeUp = 0;  gSimulatedHWInterrupt.pb = pb;  temp = ((gSampleRate &gt;&gt; 16) / samplesInBuffer);  temp2 = -(1000000.0 / temp);  //calculate time in microseconds  gInterruptFreq = temp2;  InsXTime ((QElemPtr)&amp;gSimulatedHWInterrupt);  PrimeTime ((QElemPtr)&amp;gSimulatedHWInterrupt, gInterruptFreq);  //wait for the time it takes to &quot;record&quot; one buffer  err = ioInProgress;#if DEBUG  if (err != noErr &amp;&amp; err != ioInProgress) {    SysDebugStr (&quot;\p!!Error in DriverReadCmd!!&quot;);  }#if FULLDEBUG  SysDebugStr (&quot;\pleaving DriverReadCmd;g&quot;);#endif#endif  return (err);}/*  May run at interrupt level, CANNOT allocate or move memory.*/static OSStatus DriverWriteCmd (AddressSpaceID addressSpaceID, IOCommandID ioCommandID, IOCommandKind ioCommandKind, ParmBlkPtr pb) {#pragma unused (addressSpaceID, ioCommandID, ioCommandKind, pb)  OSStatus      err;#if DEBUG  SysDebugStr (&quot;\pin DriverWriteCmd;g&quot;);#endif  //Sound input drivers don't have a write command.  err = paramErr;#if DEBUG  if (err != noErr) {    SysDebugStr (&quot;\p!!Error in DriverWriteCmd!!&quot;);  }#if FULLDEBUG  SysDebugStr (&quot;\pleaving DriverWriteCmd;g&quot;);#endif#endif  return (err);}/*  May run at interrupt level, CANNOT allocate or move memory.*/static OSStatus DriverKillIOCmd (ParmBlkPtr pb) {#pragma unused (pb)  OSStatus      err = noErr;#if DEBUG  SysDebugStr (&quot;\pin DriverKillIOCmd&quot;);#endif  gStopRecording = true;  //when our next hardware &quot;interrupt&quot; fires we will stop the &quot;hardware&quot;  if (gSimulatedHWIntProc != nil) {    RmvTime ((QElemPtr)&amp;gSimulatedHWInterrupt);  }#if DEBUG  if (err != noErr) {    SysDebugStr (&quot;\p!!Error in DriverKillIOCmd!!&quot;);  }#if FULLDEBUG  SysDebugStr (&quot;\pleaving DriverKillIOCmd;g&quot;);#endif#endif  return (err);}/*  May run at interrupt level, CANNOT allocate or move memory.*/extern OSErr DoDriverIO(AddressSpaceID addressSpaceID, IOCommandID ioCommandID, IOCommandContents ioCommandContents, IOCommandCode ioCommandCode, IOCommandKind ioCommandKind) {    OSStatus    status;    OSErr      err    = noErr;#if FULLDEBUG  SysDebugStr (&quot;\pin DoDriverIO;g&quot;);#endif  /*    Note: Initialize, Open, KillIO, Close, and Finalize are either synchronous    or immediate. Read, Write, Control, and Status may be immediate,    synchronous, or asynchronous.  */  switch (ioCommandCode) {    case kInitializeCommand:    /* Always immediate */      status = DriverInitializeCmd (addressSpaceID, ioCommandContents.initialInfo);      break;    case kFinalizeCommand:      /* Always immediate */      status = DriverFinalizeCmd (ioCommandContents.finalInfo);      break;    case kSupersededCommand:    /* Always immediate */      status = DriverSupersededCmd (ioCommandContents.supersededInfo);      break;    case kReplaceCommand:      /* Always immediate, replace an old driver */      status = DriverReplaceCmd (addressSpaceID, ioCommandContents.replaceInfo);      break;    case kOpenCommand:        /* Always immediate */      status = DriverOpenCmd (addressSpaceID, ioCommandContents.pb);      break;    case kCloseCommand:        /* Always immediate */      status = DriverCloseCmd (ioCommandContents.pb);      break;    case kControlCommand:      status = DriverControlCmd (addressSpaceID, ioCommandID, ioCommandKind, (SoundParamPtr) ioCommandContents.pb);      break;    case kStatusCommand:      status = DriverStatusCmd (addressSpaceID, ioCommandID, ioCommandKind, (SoundParamPtr) ioCommandContents.pb);      break;    case kReadCommand:      status = DriverReadCmd (addressSpaceID, ioCommandID, ioCommandKind, ioCommandContents.pb);      break;    case kWriteCommand:      status = DriverWriteCmd (addressSpaceID, ioCommandID, ioCommandKind, ioCommandContents.pb);      break;    case kKillIOCommand:      /* Always immediate */      status = DriverKillIOCmd (ioCommandContents.pb);      break;    default:      status = paramErr;      break;  }    if ((ioCommandKind &amp; kImmediateIOCommandKind) != 0) {    /* Immediate commands return the operation status and don't call IOCommandIsComplete */  } else if (status == ioInProgress) {    /* Perform the action and call IOCommandIsComplete at some later time */    status = noErr;  } else {    err = status;    status = IOCommandIsComplete (ioCommandID, err);  }#if DEBUG  if (err == paramErr) {    SysDebugStr (&quot;\p!!Param Error in DoDriverIO!!&quot;);  }#if FULLDEBUG  SysDebugStr (&quot;\pleaving DoDriverIO;g&quot;);#endif#endif  return (status);}static pascal void HWIntProc (QElemPtr passedPtr) {  UInt32          numSamples,              numBytesLeftToRecord;  Boolean          recordingComplete  = false;  ParmBlkPtr        pb = ((myTMTask*)passedPtr)-&gt;pb;  OSErr          err;#if DEBUG  SysDebugStr (&quot;\pin HWIntProc&quot;);#endif  err = noErr;  if (gStopRecording == false) {      if (gContinuousOn == true) {  // If continuous recording is on...          if (pb-&gt;ioParam.ioBuffer != nil) {  // ...and we are given a buffer...        // ...if the buffer passed in is larger than the number of byte we record each hardware interrupt...        if (pb-&gt;ioParam.ioReqCount &gt;= kSamplesInBuffer * (gSampleSize / 8) * gNumberChannels) {          // ...calculate the number of bytes left to record.          numBytesLeftToRecord = pb-&gt;ioParam.ioReqCount - pb-&gt;ioParam.ioActCount;        }                else {          // Return an error since the continuous ring buffer will loop if you don't ask for at          // least a hardware size buffer for each record.          err = paramErr;        }      }             else {        // If they ask us to record into no buffer, they really just want a recording that goes on        // infinitely until they call SPBStopRecording (which comes to us as killIO).        // So setup to record a full hardware buffer        numSamples = kSamplesInBuffer;        numBytesLeftToRecord = kSamplesInBuffer * (gSampleSize / 8) * gNumberChannels;      }    }         else {  // If continuous recording is not on...          if (pb-&gt;ioParam.ioBuffer != nil) {  // ...and we are given a buffer        // ...calculate number of bytes to record.         numBytesLeftToRecord = pb-&gt;ioParam.ioReqCount - pb-&gt;ioParam.ioActCount;      }             else {  // ...and we are NOT given a buffer, that's an error        err = paramErr;      }    }    // If the number of bytes requested is larger than our buffer, return the max number of samples that will fit in our buffer    if (numBytesLeftToRecord &gt; (kSamplesInBuffer * gNumberChannels * (gSampleSize / 8))) {      numSamples = kSamplesInBuffer;    } else {      // otherwise figure out how many samples the requested number of bytes equals      numSamples = numBytesLeftToRecord / (gNumberChannels * (gSampleSize / 8));    }    switch (gCurrentInputSource) {      case 1:        // Make a square wave        MakeSquareWave (0, numSamples, gSampleRate, 1000, gSampleSize, gNumberChannels);        break;      case 2:        // Make a saw tooth wave        MakeSawWave (0, numSamples, gSampleRate, 1000, gSampleSize, gNumberChannels);        break;      case 3:        // Make silence        MakeSquareWave (0, numSamples, gSampleRate, 0, gSampleSize, gNumberChannels);        break;      default:      #if DEBUG        SysDebugStr (&quot;\punknown input source in HWIntProc&quot;);      #endif        break;  // null statement so when DEBUG is false this switch still compiles    }    if (gTwosComplementOn == true &amp;&amp; gSampleSize == 8) {      SInt32 i;      for (i = 0; i &lt; numSamples; i++) {        ((UInt32*)gSoundBuffer)[i] ^= 0x80808080;      }    }        // If we have a client interrupt proc and we're not paused, call the proc    if (gUserInterruptProc != nil &amp;&amp; gPauseState == 0) {      CallSIInterruptProc (gUserInterruptProc, pb-&gt;ioParam.ioMisc, gSoundBuffer, gMaxAmplitude, numSamples*(gSampleSize/8)*gNumberChannels);    }    //if we have a buffer and pausing is off, copy data to app's buffer    if (pb-&gt;ioParam.ioBuffer != nil &amp;&amp; gPauseState == 0) {      BlockMoveData (gSoundBuffer, pb-&gt;ioParam.ioBuffer+pb-&gt;ioParam.ioActCount, numSamples*(gSampleSize/8)*gNumberChannels);    }    //If we are not paused, update the number of samples we have made    if (gPauseState == 0) {      pb-&gt;ioParam.ioActCount += numSamples*(gSampleSize/8)*gNumberChannels;    }    // If we have a buffer and actual bytes == requested bytes, recording is complete    if (pb-&gt;ioParam.ioBuffer != nil &amp;&amp; pb-&gt;ioParam.ioActCount == pb-&gt;ioParam.ioReqCount) {      recordingComplete = true;    }  }    // if we got an error, stop recording  if (err != noErr) {    gStopRecording = true;  }  if (recordingComplete == false &amp;&amp; gStopRecording == false) {    PrimeTime ((QElemPtr)passedPtr, gInterruptFreq);  // more data to record  } else {    // Have recorded requested number of bytes, stop the hardware (if continuous recording is not on)    // Do a software interrupt so that we can call IOCommandIsComplete (which can only be called at    // task level and software interrupt level.    RmvTime ((QElemPtr)passedPtr);    if (gStopRecording == true) {      SetHardwareToDefault ();    } else if (gContinuousOn == false) {      gSamplesWritten = 0;    }    IOCommandIsComplete ((IOCommandID)pb-&gt;ioParam.ioCmdAddr, err);  }#if FULLDEBUG  SysDebugStr (&quot;\pleaving HWIntProc;g&quot;);#endif}//Makes a square wave of the specified frequency and duration//duration in 1/100 of a second, i.e. 500 for a five second tone//frequency in samples per second, i.e. 8000 for an 8000Hz square wave (requires 16kHz sampling rate)static void MakeSquareWave (SInt32 duration, SInt32 numberSamples, UnsignedFixed sampleRate, SInt32 frequency, SInt16 sampleSize, SInt16 numChannels) {  SInt32      numSamples  = 0;  if (duration != 0 &amp;&amp; numberSamples == 0) {    numSamples = (duration / 100.0) * (sampleRate &gt;&gt; 16);  } else if (duration == 0 &amp;&amp; numberSamples != 0) {    numSamples = numberSamples;  }  if (numSamples &gt; 0) {    if (frequency == 0) {      gMaxAmplitude = 0;      //Generate silence of requested length      if (sampleSize == 8) {        UInt8 *buffer8 = (UInt8*)gSoundBuffer;        UInt8 *end8 = buffer8 + (numSamples * numChannels);        while (buffer8 &lt; end8) {          *buffer8++ = kSilence;        }      } else if (sampleSize == 16) {        UInt16 *buffer16 = (UInt16*)gSoundBuffer;        UInt16 *end16 = buffer16 + (numSamples * numChannels);        while (buffer16 &lt; end16) {          *buffer16++ = 0;        }      } else {      #if DEBUG        SysDebugStr (&quot;\pbad sample size in MakeSquareWave (silence)&quot;);      #endif      }    } else if ((frequency * 2) &lt;= sampleRate) {      //Generate a square wave      SInt32  samplesBeforeReverse =   (((sampleRate &gt;&gt; 16) / frequency) / 2) * numChannels;      if (sampleSize == 8) {        UInt8 *buffer8 = (UInt8*)gSoundBuffer;        UInt8 *end8 = buffer8 + (numSamples * numChannels);        gMaxAmplitude = kSilence + kAmplitude;        while (buffer8 &lt; end8) {          if (gSamplesWritten &lt; samplesBeforeReverse) {            *buffer8++ = kSilence + kAmplitude;            gSamplesWritten++;          } else {            *buffer8++ = kSilence - kAmplitude;            if (gSamplesWritten == (samplesBeforeReverse * 2 - 1)) {              gSamplesWritten = 0;            } else {              gSamplesWritten++;            }          }        }      } else if (sampleSize == 16) {        UInt16 *buffer16 = (UInt16*)gSoundBuffer;        UInt16 *end16 = buffer16 + (numSamples * numChannels);        gMaxAmplitude = (kAmplitude * 0.01) * 32767;        while (buffer16 &lt; end16) {          if (gSamplesWritten &lt; samplesBeforeReverse) {            *buffer16++ = (kAmplitude * 0.01) * 32767;            gSamplesWritten++;          } else {            *buffer16++ = -((kAmplitude * 0.01) * 32767);            if (gSamplesWritten == (samplesBeforeReverse * 2 - 1)) {              gSamplesWritten = 0;            } else {              gSamplesWritten++;            }          }        }      } else {      #if DEBUG        SysDebugStr (&quot;\pbad sample size in MakeSquareWave (square wave)&quot;);      #endif      }    }  }}static void MakeSawWave (SInt32 duration, SInt32 numberSamples, UnsignedFixed sampleRate, SInt32 frequency, SInt16 sampleSize, SInt16 numChannels) {  SInt32      numSamples  = 0;  if (duration != 0 &amp;&amp; numberSamples == 0) {    numSamples = (duration / 100.0) * (sampleRate &gt;&gt; 16);  } else if (duration == 0 &amp;&amp; numberSamples != 0) {    numSamples = numberSamples;  }  if (numSamples &gt; 0) {    if ((frequency * 2) &lt;= sampleRate) {      //Generate a saw tooth wave      SInt32  samplesBeforeReverse =   (((sampleRate &gt;&gt; 16) / frequency) / 2);      if (sampleSize == 8) {        UInt8 *buffer8 = (UInt8*)gSoundBuffer;        UInt8 *end8 = buffer8 + (numSamples * numChannels);        UInt8 increment = (kAmplitude*2) / samplesBeforeReverse;        gMaxAmplitude = kSilence + kAmplitude;        while (buffer8 &lt; end8) {          if (gSamplesWritten &lt; samplesBeforeReverse) {            *buffer8++ = gNextSaw8Sample;            if (numChannels == 2) {              *buffer8++ = gNextSaw8Sample;            }            gNextSaw8Sample += increment;            gSamplesWritten++;          } else {            *buffer8++ = gNextSaw8Sample;            if (numChannels == 2) {              *buffer8++ = gNextSaw8Sample;            }            gNextSaw8Sample -= increment;            if (gSamplesWritten == (samplesBeforeReverse * 2 - 1)) {              gSamplesWritten = 0;            } else {              gSamplesWritten++;            }          }        }      } else if (sampleSize == 16) {        UInt16 *buffer16 = (UInt16*)gSoundBuffer;        UInt16 *end16 = buffer16 + (numSamples * numChannels);        UInt16 increment = (((kAmplitude * 0.01) * 32767)*2) / samplesBeforeReverse;        gMaxAmplitude = (kAmplitude * 0.01) * 32767;        while (buffer16 &lt; end16) {          if (gSamplesWritten &lt; samplesBeforeReverse) {            *buffer16++ = gNextSaw16Sample;            if (numChannels == 2) {              *buffer16++ = gNextSaw16Sample;            }            gNextSaw16Sample += increment;            gSamplesWritten++;          } else {            *buffer16++ = gNextSaw16Sample;            if (numChannels == 2) {              *buffer16++ = gNextSaw16Sample;            }            gNextSaw16Sample -= increment;            if (gSamplesWritten == (samplesBeforeReverse * 2 - 1)) {              gSamplesWritten = 0;            } else {              gSamplesWritten++;            }          }        }      } else {      #if DEBUG        SysDebugStr (&quot;\pbad sample size in MakeSawWave&quot;);      #endif      }    }  }}static OSErr    DoOptionsDialog  (void) {  FSSpec        driverFSSpec;  Rect        rect;  ControlHandle    item    = nil;  DialogRef      optionsDialog;  OSErr        err;  SInt16        itemHit    = 0,            itemType,            curRes,            resRef    = -1,            newInputSource = gCurrentInputSource;  Boolean        wasChanged,            done    = false;  curRes = CurResFile ();  err = ResolveAlias (nil, gAliasToDriver, &amp;driverFSSpec, &amp;wasChanged);  if (err == noErr) {    resRef = FSpOpenResFile (&amp;driverFSSpec, fsRdPerm);    if (resRef != -1) {      optionsDialog = GetNewDialog (128, nil, (GrafPtr)-1L);    } else {    #if DEBUG      SysDebugStr (&quot;\pFSpOpenResFile failed&quot;);    #endif    }  } else {  #if DEBUG    SysDebugStr (&quot;\pResolveAlias failed&quot;);  #endif  }  if (optionsDialog != nil) {    //gCurrentInputSource+5 is the item number of the corresponding radio buttons    //so itemHit-5 is the input source number    GetDialogItem (optionsDialog, gCurrentInputSource+5, &amp;itemType, &amp;(Handle)item, &amp;rect);    if (item != nil) {      SetControlValue (item, 1);      SetDialogDefaultItem (optionsDialog, 1);  //put the ring around the OK button    } else {    #if DEBUG      SysDebugStr (&quot;\pitem is nil!&quot;);    #endif    }    ShowWindow (optionsDialog);    do {      ModalDialog (nil, &amp;itemHit);      switch (itemHit) {        case 1:    //OK button          gCurrentInputSource = newInputSource;          done = true;          break;        case 2:    //Cancel button          done = true;          break;        case 6:    //Square wave        case 7:    //Saw wave        case 8:    //Silence          newInputSource = itemHit-5;          GetDialogItem (optionsDialog, 6, &amp;itemType, &amp;(Handle)item, &amp;rect);          SetControlValue (item, itemHit == 6);          GetDialogItem (optionsDialog, 7, &amp;itemType, &amp;(Handle)item, &amp;rect);          SetControlValue (item, itemHit == 7);          GetDialogItem (optionsDialog, 8, &amp;itemType, &amp;(Handle)item, &amp;rect);          SetControlValue (item, itemHit == 8);          break;      }    } while (!done);    DisposeDialog (optionsDialog);    optionsDialog = nil;  } else {  #if DEBUG    SysDebugStr (&quot;\poptionsDialog is nil!&quot;);  #endif  }  if (resRef != -1) {    CloseResFile (resRef);    UseResFile (curRes);  }  return err;}static void SetHardwareToDefault (void) {  gContinuousOn      = 0;  gLevelMeterOn      = 0;  gTwosComplementOn    = 0;  gAGCOn          = 0;  gPlayThruVolume      = 0;  gVoxRecordingOn      = 0;  gVoxStoppingOn      = 0;  gPauseState        = 0;  gNumberChannels      = 1;  gSampleSize        = 8;  gVOXStartTrigger    = 0;  gVOXStopTrigger      = 0;  gVOXDelay        = 0;  gCompressionFactor    = 1;//  gCurrentInputSource    = 1;  //don't change the current input source  gActiveChannels      = 0x00000001;  gSampleRate        = rate22050hz;  gInputGain        = 0x00010000;  gLeftInputGain      = 0x01000100;  gRightInputGain      = 0x01000100;  gCompressionType    = 'NONE';  gRecordingQuality    = siBestQuality;  gUserInterruptProc    = nil;  gSamplesWritten      = 0;  gNextSaw8Sample      = kSilence - kAmplitude;  gNextSaw16Sample    = -((kAmplitude * 0.01) * 32767);  gStopRecording      = false;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/PCI_Sound_Input_driver/listing1.html%3Fid%3DDTS10000366-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/PCI_Sound_Input_driver/listing1.html%3Fid%3DDTS10000366-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/PCI_Sound_Input_driver/listing1.html%3Fid%3DDTS10000366-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>