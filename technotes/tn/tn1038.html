<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1038: QuickDraw GX OffscreenLibrary.c in Detail: Description, Uses &amp; Limitations</title>    <meta name="keywords" content="Mac OS 8 QuickDraw GX OffscreenLibrary.c description ViewPortBuffer GetViewPortBufferViewPort">    <meta name="Description" content="Technical Note TN1038: This Technical Note discusses OffscreenLibrary.cfrom the QuickDraw GX Libraries. Included is a discussionof the ViewPortBuffer multiple Offscreen scheme."><meta name="categories" content="QuickDraw GX"><meta name="week-posted" content="Apr 1, 1996 - Apr 5, 1996"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002880" title="QuickDraw GX OffscreenLibrary.c in Detail: Description, Uses & Limitations"></a><A NAME="top"></A> <!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1038</div>
<div id="pageheadsub">QuickDraw GX OffscreenLibrary.c in Detail: Description, Uses &amp; Limitations</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td></tr><tr bgcolor="#e6e6e6">    <td background="images/tnmenubody.gif" width=300 align=left><span id="menutitle">    CONTENTS     <BR>    <BR></span>    </td></tr><tr bgcolor="#e6e6e6">    <td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><P id = "menutext"><A HREF = "#RTFToC1">About the GX Libraries</a><br><br><A HREF = "#RTFToC2">Using OffscreenLibrary.c</a><br><br><A HREF = "#RTFToC3">Summary</a><br><br><A HREF = "#References">References</a><br><br><A HREF="#Downloads">Downloadables</A></P>   <!-- end_toc -->  </td></tr><tr>    <td width=300 align=left scope="row"><img src="images/tnmenubottom.gif" alt="" width=300 height=16>    </td></tr>    </table></td><td width=300 valign="top" align=left><!-- begin_intro_text -->  <P id ="introtext">This Technote discusses OffscreenLibrary.c from the QuickDraw GX Libraries.</p><P id ="introtext">This Note is intended for Macintosh QuickDraw GX developers who implementflickerless drawing or double buffering using OffscreenLibrary.c or who areconsidering using it for their QuickDraw GX graphics applications.</p><TABLE BORDER="0"><TR>    <td bgcolor="#EEEEEE" align=left>        <P id = "introtext"><B>Important for all Apple Printing and Graphics Developers: </B></p><P id = "introtext">        The information in this Technote is still relevant up to and including        <A HREF = "tn1090.html">Mac OS 7.6</A>        with QuickDraw GX 1.1.5. Beginning with the release of Mac OS 8.0,        however, Apple plans to deliver a system which incorporates QuickDraw GX        graphics and typography <B>only</B>. QuickDraw GX printer drivers and GX printing        extensions will <B>not</B> be supported in Mac OS 8.0 or in future Mac OS releases. Apple's        goal is to simplify the user experience of printing by unifying the Macintosh        graphic and printing architectures and standardizing on the classic Printing        Manager. </P>            </TD></TR></TABLE><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Mar 1 1996]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR> <!-- begin_content --><a name="RTFToC1"></a><h2>About the GX Libraries</h2><P>For better or worse, the development of QuickDraw GX took seven years fromconception to initial release. During that time, there were many requests forfeature enhancements and interface improvements that, if implemented, mighthave taken seven more years to complete. As it turns out, some of theseenhancements could readily be built on existing services, but there was no timeto test or document these services with the rigor required to make them fullypart of the released system.</p><P>The GX Libraries fill this gap by providing services built on top of the restof GX in source form. This Technote and others document these services. SinceGX libraries are provided as source, it is reasonable for developers to modifythem to meet their specific needs. Care was taken for the libraries not todepend on the implementation details of GX, so that future versions of GXshould not invalidate them, in original or modified form.</p><P>The libraries are likely to evolve to take advantage of improved algorithms,new Macintosh or GX services; if you modify one for your application's specificneeds, it's worth occasionally reviewing the GX library provided by Apple tostay synchronized with any improvements.</p><h3>What are Offscreens?</h3><P>Slick graphics applications attempt to draw animations seamlessly to thescreen, without flashing or flickering. QuickDraw GX provides a number ofstrategies that change these distractions into attractions. The most popularmethod to eliminate flickering is double buffering; the application draws intoone bitmap while the computer displays a second bitmap. The bitmap receivingthe drawing that will be displayed momentarily is called an offscreen.</p><h3>What is in OffscreenLibrary.c?</h3><P>The GX Library, OffscreenLibrary.c, provides utility functions to implementdouble buffering; it creates bitmaps that in turn are imaged by GX Graphics. Itwas written primarily by Oliver Steele, with contributions from the rest of theGX Graphics team.</p><P>OffscreenLibrary.c has two distinct groups of functions. The simpler revolvesaround the offscreen struct, and provides a single bitmap for back buffering.The other set uses a <code>viewPortBuffer</code> to support multiple offscreens thatcorrespond to the portions of a window that spans multiple monitors ofdifferent depths.</p><a name="RTFToC2"></a><h2>Using OffscreenLibrary.c</h2><h3>The One-Shot Solution: Struct offscreen</h3><P>The meat of Offscreenlibrary.c is this struct: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>struct offscreen {    gxShape        draw;    /* a bitmap which, when drawn, transfers the                    offscreen to the display */    gxTransform    xform;    /* this causes shapes owning it to draw                    offscreen. */    gxViewDevice    device;    /* the offscreen device whose colorSpace,                    etc. you may change */    gxViewPort    port;    /* the offscreen port which may be put in                    any transform's viewPort list */    gxViewGroup    group;    /* the global space in which the viewPort                    and viewDevice exist */};</pre>	</TD></TR></TABLE></CENTER><P>and these functions: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    void CreateOffscreen(offscreen *target, gxShape bitmapShape);</pre>	</TD></TR></TABLE></CENTER><P>Use <code>CreateOffscreen</code> to fill in the offscreen struct, given the bitmap shape toback up.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    void DisposeOffscreen(offscreen *target);</pre>	</TD></TR></TABLE></CENTER><P>When you're through with the offscreen, use <code>DisposeOffscreen</code> to get rid of thepieces.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    void CopyToBitmaps(gxShape target, gxShape source);</pre>	</TD></TR></TABLE></CENTER><P>To copy one bitmap to another, use <code>CopyToBitmaps</code>.</p><P>GX makes it pretty darn easy to create an offscreen. For instance, you cancreate a bitmap that contains a diagonal line with these calls: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    gxLine aLine = {ff(20), ff(40), ff(60), ff(80)};    gxShape lineBits = GXNewLine(&amp;aLine);    GXSetShapeType(lineBits, gxBitmapType);</pre>	</TD></TR></TABLE></CENTER><P>Then, to create an offscreen from the line bitmap: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    offscreen offLine;    CreateOffscreen(offLine, lineBits);</pre>	</TD></TR></TABLE></CENTER><P>You can draw the line bitmap with: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    GXDrawShape(offLine.draw);</pre>	</TD></TR></TABLE></CENTER><P>To add a rectangle to the line bitmap, first create a rectangle: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    gxRectangle aRect = {ff(50), ff(50), ff(60), ff(60)};    gxShape rectToAdd = GXNewRectangle(&amp;aRect);</pre>	</TD></TR></TABLE></CENTER><P>Then change the rectangle to the transform in the offscreen: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    GXSetShapeTransform(rectToAdd, offLine.xform);    GXDrawShape(rectToAdd);</pre>	</TD></TR></TABLE></CENTER><P>Now, drawing the line bitmap will draw both the line and the rectangle: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>        GXDrawShape(lineBits);</pre>	</TD></TR></TABLE></CENTER><P>Once you're done, you can use <code>DisposeOffscreen</code> to get rid of it: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    DisposeOffscreen(&amp;offLine);</pre>	</TD></TR></TABLE></CENTER><P>The function <code>CopyToBitmaps</code> uses the offscreen structure internally to copy onebitmap onto another. The name is somewhat misleading, since the shape to becopied can be any shape type, not necessarily a bitmap. For instance, you canuse it to create a bitmap that has a specific bit depth from a picture: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    static gxShape Create8BitPicture(gxShape myPicture)    {        gxRectangle bounds;    // get the bounding box of the picture        GXGetShapeBounds(myPicture, 0, &amp;bounds);    // move the picture so that it's upper left corner is at (0, 0)        GXMoveShape(myPicture, -bounds.left, -bounds.top);    // create a bitmap big enough to hold the picture        gxShape bitmap = {nil, FixRound(bounds.right - bounds.left),            FixRound(bounds.bottom - bounds.top), 0, 8, nil, nil, nil};    // copy the picture to the bitmap        CopyToBItmaps(bitmap, myPicture);    // move the bitmap to the picture's original position        GXMoveShape(myPicture, bounds.left, bounds.top);    // restore the picture's original position        GXMoveShape(bitmap, bounds.left, bounds.top);        return bitmap;    }</pre>	</TD></TR></TABLE></CENTER><h3>The ViewPortBuffer Multiple Offscreen Scheme</h3><P>The Macintosh is relatively unique among computers in that it allows windows tostraddle two or more monitors at the same time. QuickDraw GX fully embracesthis capability, and takes it to the logical extreme; not only can viewPortscross multiple <code>viewDevices</code>, but the <code>viewDevices</code> themselves can overlap eachother.</p><P>This makes allocating an offscreen bitmap a challenge, since there may be nosingle best depth that allows drawing to contain the correct amount of colorand draw as quickly as possible. The solution provided by a <code>viewPortBuffer</code>creates a picture containing an array of offscreens that match the desiredmultiple <code>viewDevices</code>.</p><P>Here's the interface to viewPortBuffer.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    typedef struct viewPortBufferRecord **viewPortBuffer;</pre>	</TD></TR></TABLE></CENTER><P>The <code>viewPortBuffer</code> is a blind handle that points to the internals kept by theseroutines. It is never necessary to directly access the fields pointed to bythis handle.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    viewPortBuffer NewViewPortBuffer(gxViewPort originalPort);</pre>	</TD></TR></TABLE></CENTER><P>To create an offscreen for a window that may cross multiple monitors, call<code>NewViewPortBuffer</code>. It takes the window's <code>viewPort</code>, returns a reference to theinternal structure. The window's viewPort can be retrieved from<code>GXGetWindowViewPort</code>.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    void DisposeViewPortBuffer(viewPortBuffer target);</pre>	</TD></TR></TABLE></CENTER><P>When the window is closed, call <code>DisposeViewPortBuffer</code> to get deallocate theinternal objects allocated by the <code>viewPortBuffer</code>.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    gxViewPort GetViewPortBufferViewPort(viewPortBuffer source);</pre>	</TD></TR></TABLE></CENTER><P>To draw shapes into the offscreen, first call <code>GetViewPortBufferViewPort</code>.<code>GetViewPortBufferViewPort</code> returns a viewPort that references the multipleoffscreens. Drawing into this <code>viewPort</code> draws into as many offscreen bitmaps asis appropriate. To attach this <code>viewPort</code> to a single shape, use the libraryroutine <code>SetShapeViewPort</code>. To change all shapes of a given type, try<code>SetTransformViewPort( GXGetDefaultTransform( theType ));</code></p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    gxShape GetViewPortBufferShape(viewPortBuffer source);</pre>	</TD></TR></TABLE></CENTER><P>To draw the offscreens, call <code>GetViewPortBufferShape</code> to get the shape to draw.Drawing the returned shape transfers the offscreen bitmaps to the <code>viewDevices</code>pointed to by the original <code>viewPort</code>, typically the window's <code>viewPort</code>.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    Boolean ValidViewPortBuffer(viewPortBuffer target);</pre>	</TD></TR></TABLE></CENTER><P>The user may foul things up by changing the monitors depth or the window'sposition. After a window-altering event, call <code>ValidViewPortBuffer</code> to see if the<code>viewPortBuffer</code> needs to be recomputed.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    Boolean UpdateViewPortBuffer(viewPortBuffer target);</pre>	</TD></TR></TABLE></CENTER><P>If the <code>viewPortBuffer</code> is out of date, <code>UpdateViewPortBuffer</code> will put thingsright again. It returns true if the <code>viewPortBuffer</code> was already valid.</p><P>Here's a convoluted example that builds the offscreens and draws a shape.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static void BufferDraw(gxShape shape, WindowPtr window){// create the viewPortBuffer from the viewPort associated with the window    viewPortBuffer buffer =        NewViewPortBuffer(GXGetWindowViewPort(window));// retrieve the viewPort created that allows drawing into the offscreen    viewPort offscreenPort = GetViewPortBufferViewPort(buffer);// point the shape to that offscreen    SetShapeViewPort(shape, offscreenPort);// draw the shape into the offscreen    GXDrawShape(shape);// draw the offscreen into the window    GXDrawShape(GetViewPortBufferShape(buffer));// throw the offscreen away    DisposeViewPortBuffer(buffer);}</pre>	</TD></TR></TABLE></CENTER><h4>How the ViewPortBuffer Works</h4><P>Since the <code>viewPortBuffer</code> is implemented as a library, you can read the codeyourself; you'll find it is pretty straightforward.</p><P>The implementation is split into a few steps: </p><ol><li>Figure out which devices the window/viewPort crosses.</li><li>For each device, figure out the coordinates for the viewPort on thatdevice.</li><li>Create a bitmap that has the same pixel depth, color set, color profile andcolor space as the corresponding device.</li><li>Keep track of the allocations and object references so that closing thewindow (or disposing the device) doesn't leave any dangling references orpointers.</li></ol><a name="RTFToC3"></a><h2>Summary</h2><P>GX Libraries contain a wealth of information and show how to use QuickDraw GXto solve real problems. OffscreenLibrary.c shows how to use GX to constructflickerless drawing by implementing double buffering on a single device or onmultiple devices.</p><a name="References"></a><h2>References</h2><p>MacOS SDK CD, Development Kits (Disc 1): QuickDraw GX: Programming Stuff: GXLibraries: </p><p><i>Inside Macintosh: QuickDraw GX Objects</i></p><p><i>Inside Macintosh: QuickDraw GX Environment and Utilities</i></p><P><A HREF="#top">Back to top</A></P>          <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (64K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1038.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER>		<!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1038.html%3Fid%3DDTS10002880-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1038.html%3Fid%3DDTS10002880-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1038.html%3Fid%3DDTS10002880-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>