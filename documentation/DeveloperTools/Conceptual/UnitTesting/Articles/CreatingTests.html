<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Xcode Unit Testing Guide: Adding Unit Tests to Your Projects</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Adding Unit Tests to Your Projects"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002171" title="Adding Unit Tests to Your Projects"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../Xcode-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000557" target="_top">Xcode</a> &gt; <a href="../index.html" target="_top">Xcode Unit Testing Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../UnitTesting.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="UTGuidelines.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40002171-DontLinkElementID_2" title="Adding Unit Tests to Your Projects"></a><hr /><H1><a name="//apple_ref/doc/uid/TP40002171-BBCBGHCJ" title="Adding Unit Tests to Your Projects"></a>Adding Unit Tests to Your Projects</H1>

<p>Beginning with version 2.1, Xcode includes support for several open-source unit test modules. These add-on modules are shipped with the Xcode Tools and are installed automatically with Xcode. You can use these modules to add automated unit testing into your build process.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002171-DontLinkElementID_3" title="iPhone OS Unit Testing Support"></a><p><strong>iPhone OS Unit Testing Support:</strong>&nbsp;Unit tests are not supported for iPhone applications.</p></div>
<p>The following sections show you how to write unit tests and how to modify your projects to execute those tests.</p>

<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-119320">Configuring Your Xcode Project</a>
				
			<br/>
			
        
			
			
				<a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-CJBFBJAG">Creating Test Cases for Objective-C</a>
				
			<br/>
			
        
			
			
				<a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-CJBFJEIA">Creating Test Cases for C++</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002171-119320" title="Configuring Your Xcode Project"></a><h2>Configuring Your Xcode Project</h2>
<p>The first step in adding unit tests to your project is to create a new target in your project for building and running those tests. In Xcode, you create a build target of type “Unit Test Bundle”. When built, this target compiles your test code and executes a shell script to run your tests. Upon completion of your tests, the Xcode console reports all failed tests as errors.</p>
<p>When you configure your test target, you need to decide how you want that target to behave. The unit test bundles that come with Xcode can be integrated with your executable in one of two ways. One technique is to configure your test target as a separate entity that you build and run independent of your main executable. The other is to add dependencies to your target that automatically build your executable and run the tests each time you build. </p>
<a name="//apple_ref/doc/uid/TP40002171-119886" title="Dependent Versus Independent Targets"></a><h3>Dependent Versus Independent Targets</h3>
<p>When setting up your test code, you need to decide whether you want your test targets to be dependent or independent of your main executable. There are advantages and disadvantages to both techniques, which are listed in <span class="content_text">Table 1</span>.</p><a name="//apple_ref/doc/uid/TP40002171-DontLinkElementID_4" title="Table 1Pros and cons of target configurations"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><a name="//apple_ref/doc/uid/TP40002171-119928" title="Table 1Pros and cons of target configurations"></a><a name="//apple_ref/doc/uid/TP40002171-CJBEBEAI" title="Table 1Pros and cons of target configurations"></a><strong>Table 1&nbsp;&nbsp;</strong>Pros and cons of target configurations</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Target type</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Pros</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Cons</p></th>
</tr>


<tr>
<td  scope="row"><p>Independent</p></td>
<td ><p>Easier to set up. Run only when wanted.</p></td>
<td ><p>Must be run manually, which can lead to infrequent use.</p></td>
</tr>
<tr>
<td  scope="row"><p>Dependent</p></td>
<td ><p>Easier to run tests automatically. Still allows option to build main executable separately.</p></td>
<td ><p>Require some additional steps to set up.</p></td>
</tr>

</table></div>
<p>If you are writing an Objective-C program, the extra steps required to configure a dependent target are minimal. If you are writing a C or C++ program though, configuring a dependent target is a little more involved but still relatively straightforward. </p>
<p>The important decision to make is how often you want to run your test suite. If engineers are running the tests regularly, they are going to get a report of any errors with each build. If they build regularly, it can be easier to track down the changes that caused the problem. </p>
<p>Another decision to make is which tests you want to run during each build cycle. If you have several thousand tests, you might want to run them only at specific checkpoints, such as immediately before committing the changes to a repository, and not for every build. To specify which tests you want to run, you specify the name of the test suite in a command-line argument to the custom executable. For more information, see <span class="content_text"><a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-124933">“Running Your Tests.”</a></span></p>
<a name="//apple_ref/doc/uid/TP40002171-119735" title="Creating Your Test Target"></a><h3>Creating Your Test Target</h3>
<p>Regardless of whether you are configuring for dependent or independent targets, the initial set up process is identical:</p>
<ol class="ol"><li class="li"><p>Open your Xcode project.</p></li>
<li class="li"><p>Select Project > New Target to display the New Target assistant.</p></li>
<li class="li"><p>Select the desired target type:</p><ul class="ul"><li class="li"><p>If you are writing an Objective-C program, select the Cocoa > Unit Test Bundle target.</p></li>
<li class="li"><p>If you are writing a C/C++ program, select the Carbon > Unit Test Bundle target. You do not have to use the Carbon libraries to use this target. </p></li></ul></li>
<li class="li"><p>Specify a name for your target and click Finish.</p></li></ol>
<p>When you create the target, it is initially configured to be an independent target. If that is what you wanted, you can add your source code and test cases to the target and begin building. If you want to make it a dependent target, you must instead do the following:</p>
<ul class="spaceabove"><li class="li"><p>You must make your target dependent on the target for your main executable. (See <span class="content_text"><a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-125425">“Making Your Target Dependent on the Main Executable.”</a></span>) </p></li>
<li class="li"><p>If your program is written in C or C++, you must add code to initialize your tests from within your application. (See <span class="content_text"><a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-122120">“Executing Dependent Tests in C and C++.”</a></span>) You do not need to do this for Objective-C based tests.</p></li></ul>
<a name="//apple_ref/doc/uid/TP40002171-125425" title="Making Your Target Dependent on the Main Executable"></a><a name="//apple_ref/doc/uid/TP40002171-CJBIHGEI" title="Making Your Target Dependent on the Main Executable"></a><h4>Making Your Target Dependent on the Main Executable</h4>
<p>To make your target dependent on your main executable, you must establish the dependency in your Xcode project: </p>
<ol class="ol"><li class="li"><p>Select your Unit Test Bundle target.</p></li>
<li class="li"><p>Open an inspector for the target.</p></li>
<li class="li"><p>Select the General tab.</p></li>
<li class="li"><p>Click the + button at the bottom of the window.</p></li>
<li class="li"><p>From the dialog that appears, select the target representing your main executable and click Add Target.</p></li></ol>
<p>If you are building an application, you must also specify the path to your application’s executable file in both the Bundle Loader and Test Host build settings. For example, to set the path to the executable of <code>MyApp.app</code>, you would do the following:</p>
<ol class="ol"><li class="li"><p>Select your Unit Test Bundle target.</p></li>
<li class="li"><p>Open an inspector for the target.</p></li>
<li class="li"><p>Select the Build tab.</p></li>
<li class="li"><p>Select the Linking collection.</p></li>
<li class="li"><p>Assign the value<code>$(BUILT_PRODUCTS_DIR)/MyApp.app/Contents/MacOS/MyApp</code> to the Bundle Loader setting.</p></li>
<li class="li"><p>Select the Unit Testing collection.</p></li>
<li class="li"><p>Assign the value <code>$(BUILT_PRODUCTS_DIR)/MyApp.app/Contents/MacOS/MyApp</code> to the Test Host setting. Because they use the same value, you can also set the value of this setting to <code>$(BUNDLE_LOADER)</code>. </p></li></ol>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40002171-DontLinkElementID_5" title="Note"></a><p><strong>Note:</strong>&nbsp;If you are testing a framework or shared library, you would not specify a value for the Test Host setting.</p></div>
<p>By default, the Bundle Loader and Test Host settings have no values assigned to them. Setting the value for Bundle Loader tells the linker to treat the specified executable as an additional framework at link time. (Treating it this way helps prevent unresolved references to application classes when you build your test target.) Setting the value for Test Host tells the <code>RunUnitTests</code> script (executed during the final build phase) to launch the specified application and inject your test bundle into it. </p>
<p>After configuring your test target, you should make it the active target and add your test case source files to it. The next time you build, Xcode will examine the dependencies of your test target and build your main executable first, followed by your test target, and then run your tests. This process ensures that your main code is built and the corresponding tests are run. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002171-DontLinkElementID_6" title="Note"></a><p><strong>Note:</strong>&nbsp;For dependent test targets, add only your test case source files to the target. Do not add any source files from your main executable to the test target. When the tests are run, the test target bundle is injected into the main executable, where it accesses any source code required for the tests.</p></div>
<a name="//apple_ref/doc/uid/TP40002171-122120" title="Executing Dependent Tests in C and C++"></a><a name="//apple_ref/doc/uid/TP40002171-CJBHEGHG" title="Executing Dependent Tests in C and C++"></a><h4>Executing Dependent Tests in C and C++</h4>
<p>If you are using a dependent test target for C++ projects, there is some extra code you must add to your test project to run your tests. Because of the dynamic nature of Objective-C, the bundle for a dependent test target can be injected into an executable automatically. In C++, however, this is not possible. Instead, you must explicitly tell the CPlusTest framework when it is safe to run your test code. One way to do this in Carbon applications is to set up a timer whose handler initiates your test suite as soon as the application finishes launching and is capable of handling events. When the timer fires, the corresponding handler can then run the suite of tests that have already been registered, logging any output from the tests. (For information on how to register test cases, see <span class="content_text"><a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-123005">“Creating Test Cases for C++.”</a></span>) </p>
<p><span class="content_text">Listing 1</span> shows the definition of a class you can use to initiate a timer in a Carbon application. An instance of this class is constructed at initialization time (see <span class="content_text"><a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-122259">Listing 2</a></span>) with the express purpose of installing a timer. When the timer eventually fires, the <code>firedTimerBridge</code> and <code>firedTimer</code> methods are used to run the actual tests.</p>
<a name="//apple_ref/doc/uid/TP40002171-DontLinkElementID_7" title="Listing 1Interface for RunTestsInTimer.h"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40002171-120761" title="Listing 1Interface for RunTestsInTimer.h"></a><a name="//apple_ref/doc/uid/TP40002171-CJBDHAAF" title="Listing 1Interface for RunTestsInTimer.h"></a><strong>Listing 1&nbsp;&nbsp;</strong>Interface for RunTestsInTimer.h</p>
<div class="codesample"><table><tr><td scope="row"><pre>#include &lt;Carbon/Carbon.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>class RunTestsInTimer {<span></span></pre></td></tr><tr><td scope="row"><pre>protected:<span></span></pre></td></tr><tr><td scope="row"><pre>    EventLoopTimerUPP timerUPP;<span></span></pre></td></tr><tr><td scope="row"><pre>    EventLoopTimerRef timerRef;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    static void firedTimerBridge(EventLoopTimerRef inTimer, void *inUserData);<span></span></pre></td></tr><tr><td scope="row"><pre>    void firedTimer(EventLoopTimerRef inTimer);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>public:<span></span></pre></td></tr><tr><td scope="row"><pre>    RunTestsInTimer();<span></span></pre></td></tr><tr><td scope="row"><pre>    virtual ~RunTestsInTimer();<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div>
<p><span class="content_text">Listing 2</span> shows part of the implementation file for this class. At the top of the implementation file is code for creating a global instance of the class. Because it is not a pointer, the actual class instance is constructed at initialization time. During that time, the constructor installs a timer on the application’s main event loop. The fire delay and interval of the timer are set to 0 so that the timer is fired as soon as possible after the event loop is running and ready to process events.</p>
<a name="//apple_ref/doc/uid/TP40002171-DontLinkElementID_8" title="Listing 2Installing the timer"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40002171-122259" title="Listing 2Installing the timer"></a><a name="//apple_ref/doc/uid/TP40002171-CJBJCEID" title="Listing 2Installing the timer"></a><strong>Listing 2&nbsp;&nbsp;</strong>Installing the timer</p>
<div class="codesample"><table><tr><td scope="row"><pre>#include &lt;CPlusTest/CPlusTest.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include "RunTestsInTimer.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Create a local instance of the class at init time.<span></span></pre></td></tr><tr><td scope="row"><pre>RunTestsInTimer installTimer;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>RunTestsInTimer::RunTestsInTimer() : timerUPP(NULL), timerRef(NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the UPP for the static bridge method.<span></span></pre></td></tr><tr><td scope="row"><pre>    timerUPP = NewEventLoopTimerUPP(RunTestsInTimer::firedTimerBridge);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    (void) InstallEventLoopTimer(GetMainEventLoop(), 0, 0, timerUPP, this, &amp;timerRef);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Clean up the timer structures.<span></span></pre></td></tr><tr><td scope="row"><pre>RunTestsInTimer::~RunTestsInTimer()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (timerRef != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        RemoveEventLoopTimer(timerRef);<span></span></pre></td></tr><tr><td scope="row"><pre>        timerRef = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (timerUPP != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        DisposeEventLoopTimerUPP(timerUPP);<span></span></pre></td></tr><tr><td scope="row"><pre>        timerUPP = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p><span class="content_text">Listing 3</span> shows the code that is executed when the timer eventually fires. This is the code that runs the actual test suites. Test cases are usually registered automatically when they are created, so you do not have to register them with the <code>TestSuite</code> object directly. As a result, the following code simply retrieves the tests that have been registered and runs them. </p>
<a name="//apple_ref/doc/uid/TP40002171-DontLinkElementID_9" title="Listing 3Running the tests"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40002171-122423" title="Listing 3Running the tests"></a><a name="//apple_ref/doc/uid/TP40002171-CJBDJHFA" title="Listing 3Running the tests"></a><strong>Listing 3&nbsp;&nbsp;</strong>Running the tests</p>
<div class="codesample"><table><tr><td scope="row"><pre>// Static method to bridge the call to the local instance.<span></span></pre></td></tr><tr><td scope="row"><pre>void RunTestsInTimer::firedTimerBridge(EventLoopTimerRef inTimer, void *inUserData)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    RunTestsInTimer *self = (RunTestsInTimer *)inUserData;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    self->firedTimer(inTimer);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void RunTestsInTimer::firedTimer(EventLoopTimerRef inTimer)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (inTimer == timerRef)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        TestRun run;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Create a log for writing out test results<span></span></pre></td></tr><tr><td scope="row"><pre>        TestLog log(std::cerr);<span></span></pre></td></tr><tr><td scope="row"><pre>        run.addObserver(&amp;log);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Get all registered tests and run them.<span></span></pre></td></tr><tr><td scope="row"><pre>        TestSuite&amp; allTests = TestSuite::allTests();<span></span></pre></td></tr><tr><td scope="row"><pre>        allTests.run(run);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Log a final message.<span></span></pre></td></tr><tr><td scope="row"><pre>        std::cerr &lt;&lt; "Ran " &lt;&lt; run.runCount() &lt;&lt; " tests, " &lt;&lt; run.failureCount() &lt;&lt; " failed." &lt;&lt; std::endl;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Clean up.<span></span></pre></td></tr><tr><td scope="row"><pre>        RemoveEventLoopTimer(timerRef);<span></span></pre></td></tr><tr><td scope="row"><pre>        timerRef = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        QuitApplicationEventLoop();<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40002171-119811" title="Adding Test Cases to Your Target"></a><a name="//apple_ref/doc/uid/TP40002171-CJBFFGHD" title="Adding Test Cases to Your Target"></a><h3>Adding Test Cases to Your Target</h3>
<p>Once you have configured your new test target, you can begin adding test cases to that target. Test cases are small pieces of code that exercise pieces of code in your main executable and report the results. After executing the code, the test case analyzes the results returned by that code. If the results are what was expected, the test case succeeds; otherwise, it fails. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002171-DontLinkElementID_10" title="Note"></a><p><strong>Note:</strong>&nbsp;If your test target is independent of your main executable, you must also add the source code you want to test to your test target. To do this, drag the source files being tested to the compile sources build phase of your test target. You do not need to do this for dependent test targets.</p></div>
<p>For information on creating test files for Objective-C code, see <span class="content_text"><a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-122635">“Creating Test Cases for Objective-C.”</a></span> For information on creating test files for C or C++ code, see <span class="content_text"><a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-123005">“Creating Test Cases for C++.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40002171-124933" title="Running Your Tests"></a><a name="//apple_ref/doc/uid/TP40002171-CJBFIJIG" title="Running Your Tests"></a><h3>Running Your Tests</h3>
<p>As long as your target is configured appropriately, all you need to do to run your tests is build your test target. Regardless of whether your target is dependent or independent of your main executable, the final build phase of the test target runs a shell script to execute your tests. The shell script performs the required set up, runs the tests, and reports any errors back to Xcode.</p>
<p>If you want to run only a subset of your tests when you build your target, you must rewrite the build script that is executed by your test target. Test targets execute the <code>RunUnitTests</code> script by default. This script handles the execution of targets built against either the SenTestingKit or CPlusTest frameworks. To run a subset of tests, you must create your own custom script (based on the information in <code>RunUnitTests</code>) that calls the appropriate testing rig with the options you want. </p>
<p>For C++ test bundles, custom scripts must call the <code>CPlusTestRig</code> tool, located in the <code>/Developer/Tools</code> directory. The <code>-test</code> option for this tool lets you specify a specific test case or test suite. For more information on using this tool, see the man page for <code>CPlusTestRig</code>.</p>
<p>For Objective-C test bundles, your custom script must call the <code>otest</code> tool, located in the <code>/Developer/Tools</code> directory. The <code>-SenTest</code> option for this tool lets you specify a test suite (class), a specific test method, or all tests. For more information on using this tool, see the man page for <code>otest</code>. </p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40002171-DontLinkElementID_11" title="Note"></a><p><strong>Note:</strong>&nbsp;Creating custom execution scripts is beyond the scope of this document. See the <code>RunUnitTests</code> script and the man pages for the test rig you are using for information on their use. </p></div>
<a name="//apple_ref/doc/uid/TP40002171-122635" title="Creating Test Cases for Objective-C"></a><a name="//apple_ref/doc/uid/TP40002171-CJBFBJAG" title="Creating Test Cases for Objective-C"></a><h2>Creating Test Cases for Objective-C</h2>
<p>Support for Objective-C test cases is provided by the SenTestingKit framework. To create Objective-C tests, you create one or more test case classes and fill them with individual test methods. Each test method implements a simple test case you want to execute. Test methods can also implement more complex test cases or call other test methods to execute suites of tests. The following sections show you how to create test cases for Objective-C.</p>
<a name="//apple_ref/doc/uid/TP40002171-119175" title="Creating Your Test Case Class"></a><h3>Creating Your Test Case Class</h3>
<p>For Objective-C, your test case class is a subclass of SenTestCase. To create a new instance of this class in your Xcode project, do the following:</p>
<ol class="ol"><li class="li"><p>Select File > New File.</p></li>
<li class="li"><p>In the file type dialog, select Cocoa > Objective-C test case class and click Next.</p></li>
<li class="li"><p>Give your class a name and be sure to create the matching header file.</p></li>
<li class="li"><p>Add the class to your test target. Do not add it to the target for your main executable. </p></li>
<li class="li"><p>Click Finish.</p></li></ol>
<p>When you’re done, the header file for your new class should look similar to the following:</p>
<div class="codesample"><table><tr><td scope="row"><pre>#import &lt;SenTestingKit/SenTestingKit.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface MyTests : SenTestCase<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div>
<p>Your source file should simply contain the currently empty implementation for your class. You can now begin to add test cases to the implementation file.</p>
<a name="//apple_ref/doc/uid/TP40002171-118928" title="Writing Your Test Cases"></a><h3>Writing Your Test Cases</h3>
<p>The SenTestCase class provides a harness for calling the methods of your subclass automatically. As long as you follow some standard naming conventions for your test case methods, the only thing you have to do is write your tests. Your test case methods must follow these conventions:</p>
<ul class="spaceabove"><li class="li"><p>The name of the method must begin with the word <code>test</code>. For example, you could have methods called <code>testCase1</code>, <code>testMyBoundsChecking</code>, <code>testMyAlgorithm</code>. </p></li>
<li class="li"><p>The method must take no parameters.</p></li>
<li class="li"><p>The method must have a return type of <code>void</code>.</p></li></ul>
<p>Thus, using the preceding criteria, the method implementation for the <code>testCase1</code> method would look like the following:</p>
<div class="codesample"><table><tr><td scope="row"><pre>- (void) testCase1<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>Methods defined in this way are discovered dynamically and called automatically by the supporting test harness. You do not have to do anything to register your tests or call them explicitly. </p>
<p>In the body of your test case methods, you must construct any data structures you need to execute the test, run the test, and then release the data structures you created. If a test succeeds, the corresponding test case method should exit normally. If a test fails, you should report the failure using one of the macros defined by the SenTestingKit framework. For a list of basic macros, see <span class="content_text"><a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-119042">“Commonly-Used Macros.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40002171-122808" title="Managing Common Objective-C Structures"></a><h3>Managing Common Objective-C Structures</h3>
<p>If you have multiple test case methods that operate on the same basic data structures, there is no need to repeat the code for creating and destroying those data structures in each test case method. The SenTestCase class defines the <code>setUp</code> and <code>tearDown</code> methods for creating and destroying common data structures before and after each test case method is run. You can override these methods in your subclass and use them to create whatever data structures are used by your test methods. The basic implementation of these methods is as follows:</p>
<div class="codesample"><table><tr><td scope="row"><pre>- (void) setUp<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Create data structures here.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void) tearDown<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Release data structures here.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>At runtime, the <code>setUp</code> method is called immediately before each test case method. Similarly, the <code>tearDown</code> method is called immediately after to clean up the data structures. In your <code>tearDown</code> method, it is a good idea to reset the values of your data structures to a known initial state. For example, you might want to reset any object pointers to <code>nil</code> for safety. </p>
<a name="//apple_ref/doc/uid/TP40002171-119042" title="Commonly-Used Macros"></a><a name="//apple_ref/doc/uid/TP40002171-CJBIHHFC" title="Commonly-Used Macros"></a><h3>Commonly-Used Macros</h3>
<p>The SenTestingKit framework defines a number of assertion macros that you can use to determine the success or failure of a given test. These macros are defined in the <code>SenTestCase.h</code> header file of the framework. Some of the more commonly used macros are listed below:</p>
<div class="codesample"><table><tr><td scope="row"><pre>STAssertNotNil(a1, description, ...)<span></span></pre></td></tr><tr><td scope="row"><pre>STAssertTrue(expression, description, ...)<span></span></pre></td></tr><tr><td scope="row"><pre>STAssertFalse(expression, description, ...)<span></span></pre></td></tr><tr><td scope="row"><pre>STAssertEqualObjects(a1, a2, description, ...)<span></span></pre></td></tr><tr><td scope="row"><pre>STAssertEquals(a1, a2, description, ...)<span></span></pre></td></tr><tr><td scope="row"><pre>STAssertThrows(expression, description, ...)<span></span></pre></td></tr><tr><td scope="row"><pre>STAssertNoThrow(expression, description, ...)<span></span></pre></td></tr><tr><td scope="row"><pre>STFail(description, ...)<span></span></pre></td></tr></table></div>
<p>The <em>description</em> parameter of each macro lets you specify a human-readable string to be printed when the assertion fails. The string supports the same printf-style value substitution used by NSString, which you might use to print out the actual and expected values for the test. <span class="content_text">Listing 4</span> shows some examples of how to use some of these macros in your code. </p>
<a name="//apple_ref/doc/uid/TP40002171-DontLinkElementID_12" title="Listing 4Macro examples in Objective-C"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40002171-124054" title="Listing 4Macro examples in Objective-C"></a><a name="//apple_ref/doc/uid/TP40002171-CJBICBFG" title="Listing 4Macro examples in Objective-C"></a><strong>Listing 4&nbsp;&nbsp;</strong>Macro examples in Objective-C</p>
<div class="codesample"><table><tr><td scope="row"><pre>- (void) testObjectCreation<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    MyObject* theObj = [[MyObject alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    STAssertNotNil(theObj, @"Could not create instance of MyObject.");<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void) testObjectsAreEqual<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber* theObj = [NSNumber numberWithInt:1];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber* theObj2 = [NSNumber numberWithInt:1];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    STAssertEqualObjects(theObj, theObj2, @"Objects were not equal. Value 1: %d Value 2: %d", [theObj intValue], [theObj2 intValue]);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>For more information about these macros, see the documentation that comes with the SenTestingKit framework, which is located in the framework’s <code>Resources</code> directory. </p>
<a name="//apple_ref/doc/uid/TP40002171-123005" title="Creating Test Cases for C++"></a><a name="//apple_ref/doc/uid/TP40002171-CJBFJEIA" title="Creating Test Cases for C++"></a><h2>Creating Test Cases for C++</h2>
<p>Support for C and C++ test cases is provided by the CPlusTest framework. You can use this framework to test C or C++ code for everything from BSD to Carbon applications. To create a test case, you have to do the following:</p>
<ol class="ol"><li class="li"><p>Create a new subclass of TestCase.</p></li>
<li class="li"><p>Define the methods that comprise your tests.</p></li>
<li class="li"><p>In your implementation file, register your tests by creating a local instance of your class for each test. See <span class="content_text"><a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-118752">“Registering Your Tests.”</a></span> </p></li></ol>
<p>The following sections show you how to create test cases for your C and C++ code. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002171-DontLinkElementID_13" title="Note"></a><p><strong>Note:</strong>&nbsp;Although you can test C code, the tests themselves must still be written in C++ and use the CPlusTest framework infrastructure. </p></div>
<a name="//apple_ref/doc/uid/TP40002171-124103" title="Creating Your Test Case Class"></a><h3>Creating Your Test Case Class</h3>
<p>For C/C++, your test case class is a subclass of TestCase. To create a new instance of this class in your Xcode project, do the following:</p>
<ol class="ol"><li class="li"><p>Select File > New File.</p></li>
<li class="li"><p>In the file type dialog, select Carbon > C++ Test Case and click Next.</p></li>
<li class="li"><p>Give your class a name and be sure to create the matching header file.</p></li>
<li class="li"><p>Add the class to your test target. Do not add it to the target for your main executable. </p></li>
<li class="li"><p>Click Finish.</p></li></ol>
<p>When you’re done, the header file for your new class should look similar to the following:</p>
<div class="codesample"><table><tr><td scope="row"><pre>#include &lt;CPlusTest/CPlusTest.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>class MyTests : public TestCase<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>public:<span></span></pre></td></tr><tr><td scope="row"><pre>    MyTests(TestInvocation* invocation);<span></span></pre></td></tr><tr><td scope="row"><pre>    virtual ~MyTests();<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div>
<p>Your source file should contain default implementations for your constructor and destructor. You should not need to modify these implementations and should definitely not use them to create and destroy common data structures. Common data structures must be created using the <code>setUp</code> and <code>tearDown</code> methods; see <span class="content_text"><a href="CreatingTests.html#//apple_ref/doc/uid/TP40002171-124467">“Managing Common C++ Structures.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40002171-124114" title="Writing Your Test Cases"></a><h3>Writing Your Test Cases</h3>
<p>The TestCase class does not impose any naming conventions on your test case methods, although they must follow some calling conventions:</p>
<ul class="spaceabove"><li class="li"><p>The method must take no parameters.</p></li>
<li class="li"><p>The method must have a return type of <code>void</code>.</p></li></ul>
<p>Thus, using the preceding criteria, the method implementation for the <code>testCase1</code> method would look like the following:</p>
<div class="codesample"><table><tr><td scope="row"><pre>void MyTests::testCase1()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>In the body of your test case methods, you can construct any data structures you need to execute the test, run the test, and then release the data structures you created. If a test succeeds, the corresponding test case method should exit normally. If a test fails, you should report the failure using the <code>CPTAssert</code> macro. </p>
<a name="//apple_ref/doc/uid/TP40002171-124467" title="Managing Common C++ Structures"></a><a name="//apple_ref/doc/uid/TP40002171-CJBICEAD" title="Managing Common C++ Structures"></a><h3>Managing Common C++ Structures</h3>
<p>If you have multiple test case methods that operate on the same basic data structures, there is no need to repeat the code for creating and destroying those data structures in each test case method. The TestCase class defines the <code>setUp</code> and <code>tearDown</code> methods for creating and destroying common data structures before and after each test case method is run. You can override these methods in your subclass and use them to create whatever data structures are used by your test methods. The basic implementation of these methods is as follows:</p>
<div class="codesample"><table><tr><td scope="row"><pre>void MyTests::setUp()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Create data structures here.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyTests::tearDown()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Release data structures here.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>At runtime, the <code>setUp</code> method is called immediately before each test case method. Similarly, the <code>tearDown</code> method is called immediately after to clean up the data structures. In your <code>tearDown</code> method, it is a good idea to reset the values of your data structures to a known initial state. For example, you might want to reset any object pointers to <code>NULL</code> for safety. </p>
<a name="//apple_ref/doc/uid/TP40002171-118752" title="Registering Your Tests"></a><a name="//apple_ref/doc/uid/TP40002171-CJBDCGFC" title="Registering Your Tests"></a><h3>Registering Your Tests</h3>
<p>Unlike Objective-C tests, which are discovered dynamically, C++ tests must be registered explicitly if you want them to run. To register your tests with the CPlusTest framework, you must create a new instance of your test class for every test case you want to run. You create these instances in the global scope, that is, defined outside of the scope of any methods. </p>
<p>When you create a new instance of you test case class, you must pass an object parameter of type <code>TestInvocation</code>. This object contains the details of the test you want to run, including the class name and method. To create this object, you can use the <code>TEST_INVOCATION</code> macro, which takes the target class and method names as parameters. The following example creates two tests for the same test case class. The first test case executes the <code>MyFirstTest</code> method of the MyTests class while the second executes the <code>MySecondTest</code> method. </p>
<div class="codesample"><table><tr><td scope="row"><pre>MyTests test1(TEST_INVOCATION(MyTests, MyFirstTest));<span></span></pre></td></tr><tr><td scope="row"><pre>MyTests test2(TEST_INVOCATION(MyTests, MySecondTest));<span></span></pre></td></tr></table></div>
<p>Creating the objects actually executes code to register the specified invocation information with the CPlusTest framework. Because you create these objects in the global scope, they are created during the initialization phase of the test executable and are thus available later when the framework wants to run your tests. </p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../UnitTesting.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="UTGuidelines.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-05-02<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/UnitTesting/Articles/CreatingTests.html%3Fid%3DTP40002143-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/UnitTesting/Articles/CreatingTests.html%3Fid%3DTP40002143-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/UnitTesting/Articles/CreatingTests.html%3Fid%3DTP40002143-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
