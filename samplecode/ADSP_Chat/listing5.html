<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ADSP Chat - /Main.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">ADSP Chat</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ADSP Chat</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Main.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ADSP Chat.h</option>
<option value="listing2.html">/ADSP Chat.r</option>
<option value="listing3.html">/ADSP.c</option>
<option value="listing4.html">/Atalk.c</option>
<option value="listing5.html">/Main.c</option>
<option value="listing6.html">/PreCompletion.a</option></select>
				</p>
				</form>
				<p><strong><a href="ADSP_Chat.zip">Download Sample</a></strong> (&#147;ADSP_Chat.zip&#148;, 44.1K)<BR>
<strong><a href="ADSP_Chat.dmg">Download Sample</a></strong> (&#147;ADSP_Chat.dmg&#148;, 106.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*****************************************************************  Program:  &lt; ADSP Chat &gt;  File:    &lt; Main.c &gt;    Written by  Pete Helm, Scott Kuechle  of &lt;Apple Macintosh Developer Technical Support&gt;    modified by Scott Kuechle  10/92 SRK Converted from Pascal to C  8/94 SRK Modified to use a queue of parameter           blocks.  Copyright &copy; 1992, 1994 Apple Computer, Inc.  All rights reserved.  *****************************************************************//*****************************************************************//*  I N C L U D E S/*****************************************************************/#include  &quot;ADSP Chat.h&quot;/*****************************************************************//*  G L O B A L   V A R I A B L E   D E C L A R A T I O N S/*****************************************************************/DialogPtr myDialog;Boolean gHasWaitNextEvent,gInBackground,gGrowRect,gStopped,gStopRect,gGoRect,gHasSystem7;Boolean gMoofEntityFilter;MenuHandle ZoneMenu,ObjectMenu,TypeMenu;short LastZoneMenuChoice,LastTypeMenuChoice,LastObjectMenuChoice;SysEnvRec gMac;short gMenuItem;/*****************************************************************//*/* E X T E R N A L S/*/*****************************************************************/extern  myFillRoundRectAnimationRtn (Rect r, PatPtr pat);extern   void connectToPeer();extern   void removeADSP();extern   void initializeADSP();extern   removeMyName();extern   void ADSPLoop();extern   OSErr InitAppleTalk();extern   Boolean ATPZoneRequest (MenuHandle zoneMenu);extern   LookupNames (MenuHandle lookupMenu,Boolean doObjects);extern   GetZones();extern   GetOurZone();extern  void writeOutgoing(DSPPBPtr dspPBPtr,              short ccbRefNum,              Ptr dataPtr,              short reqCount);extern   void removeConnectionEnd();extern  void removeADSPBuffers();extern   Str255 gZoneString,gTypeStr,gObjStr;extern   Boolean gConnectionWasJustMade;extern  TRCCB gMyCCB;        /* our ccb */extern  QHdr  gAvailQueue,gReadQueue,gDoneQueue;extern  short   gCCBRefNum;      /* ccb reference number returned by adsp on a dspInit */extern  Ptr outgoingDataBuffer;extern  DSPPBPtr GetQElement(QHdrPtr qHdrPtr);#pragma segment Main// *****************************************************************// *  CopyPstr// *// *  copies a pascal string// *****************************************************************void CopyPstr(Ptr pSource, Ptr pDest){  BlockMove(pSource, pDest, pSource[0]+1);}// *****************************************************************// *  PStrCat// *// *  appends pascal string sourceStr, to pascal string destinationStr.// *  Overflow is checked, and the copy halts if the destination// *  string is filled.// *****************************************************************void PStrCat(Ptr sourceStr, Ptr destinationStr){  unsigned int  srcIndex, dstIndex;  unsigned int  bytesToCopy;    srcIndex = 1;  dstIndex = destinationStr[0] + 1;  bytesToCopy = sourceStr[0];    while(bytesToCopy &gt; 0 &amp;&amp; dstIndex &lt; 255)  {    destinationStr[dstIndex] = sourceStr[srcIndex];    dstIndex++;    srcIndex++;    bytesToCopy--;  }  destinationStr[0] = dstIndex - 1;}// *****************************************************************// *  DoActivate// *// * This is called when a window is activated or deactivated.// * In Sample, the Window Manager's handling of activate and// * deactivate events is sufficient. Other applications may have// * TextEdit records, controls, lists, etc., to activate/deactivate.// *****************************************************************void DoActivate (WindowPtr window, Boolean becomingActive){#pragma unused (window,becomingActive)} /*DoActivate*/// *****************************************************************// *  ShowError// *// * Our routine for displaying an error message in a dialog box.// *****************************************************************void ShowError(short index){short itemHit;  switch (index)  {    case atalkErr:      ParamText(&quot;\perror loading AppleTalk drivers!&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case memErr:      ParamText(&quot;\pmemory error.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case menuErr:      ParamText(&quot;\perror initializing menus.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case nbpErr:      ParamText(&quot;\pCouldn't register our name on the network (duplicate already exists).&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case noTargetErr:      ParamText(&quot;\pTarget not found.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case noConnErr:      ParamText(&quot;\pNo connection has been made.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case writeNotDoneErr:      ParamText(&quot;\pPrevious write has not completed yet.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case badROMsErr:      ParamText(&quot;\pYour machine does not have at least 128K ROMs.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case heapErr:      ParamText(&quot;\pNot enough heap space.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case noMemErr:      ParamText(&quot;\pNot enough memory available for our application.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case DrvrErr:      ParamText(&quot;\pFatal Device Manager error.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case ListenErr:      ParamText(&quot;\pCould not setup connection listener.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case dspInitErr:      ParamText(&quot;\pADSP Initialization failed.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case dspOpenErr:      ParamText(&quot;\pAttempt to open connection failed.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;    case dspRemoveErr:      ParamText(&quot;\pError returned while eliminating the connection end.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;        default:      ParamText(&quot;\pdefault error displayed here.&quot;,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);      break;  }    itemHit = Alert(rErrorDialog, nil);}// *****************************************************************// *  FatalError// *// * This is called when we detect that we cannot operate in the// * current environment.// *****************************************************************void FatalError(error)  short error;{  ShowError(error);  ExitToShell();}// *****************************************************************// *  IsAppWindow// *// *  Tells us whether or not a window is an application window// *// *****************************************************************Boolean IsAppWindow(window)  WindowPtr  window;{  short    windowKind;  if ( window == nil )    return false;  else {  /* application windows have windowKinds &gt;= userKind (8) or dialogKind (2) */    windowKind = ((WindowPeek) window)-&gt;windowKind;    return (windowKind &gt;= userKind) || (windowKind == dialogKind);  }} /* IsAppWindow */// *****************************************************************// *  DialogEditing// *// *  handles the standard editing operations (cut, copy, paste)// *  for our dialog.// *****************************************************************void DialogEditing (short menuItem){  /* handles Edit menu */  DialogPeek dp;  short ignore;  long evenBiggerIgnore;    dp = (DialogPeek)myDialog;    switch(menuItem)    {      case iCut:           evenBiggerIgnore = ZeroScrap(); /* you really shouldn't ignore this error.  see TESample for details */          TECut(dp-&gt;textH);          ignore = TEToScrap; /* you really shouldn't ignore this error.  see TESample for details */        break;      case iCopy:           evenBiggerIgnore = ZeroScrap(); /* you really shouldn't ignore this error.  see TESample for details */          TECopy(dp-&gt;textH);          ignore = TEToScrap; /* you really shouldn't ignore this error.  see TESample for details */        break;      case iPaste:             /* you really shouldn't ignore this either.                         */            /* one should be checking the length of the incoming scrap to see if it      */            /* will fit in our remaining text edit space.  but since we have a weenine 255  */            /* char dialog text edit item in any case we'll blow it off...see TESample for   */            /* details on &quot;doing the right thing&quot;                          */          ignore = TEFromScrap;          TEPaste(dp-&gt;textH);        break;      case iClear:         TEDelete(dp-&gt;textH);    }}// *****************************************************************// *  IsDAWindow// *// *  Check if a window belongs to a desk accessory.// *****************************************************************Boolean IsDAWindow(WindowPtr window){  if (window == nil)    return false;  else  /* DA windows have negative windowKinds */    return((((WindowPeek)window)-&gt;windowKind &lt; 0) ? true : false);} /*IsDAWindow*/// *****************************************************************// *  DoCloseWindow// *// * Close a window. This handles only desk accessory windows because we do not// * allow our window to be closed. TESample provides an example of how to handle// * the closing of application windows.// *****************************************************************void DoCloseWindow (WindowPtr window){/* Close a window. This handles only desk accessory windows because we do not*//* allow our window to be closed. TESample provides an example of how to handle*//* the closing of application windows.*/  if (IsDAWindow(window))    CloseDeskAcc(((WindowPeek)window)-&gt;windowKind);} /*DoCloseWindow*/// *****************************************************************// *  HiliteConnectButton// *// *  sets our connect button to the desired state (active or inactive)// *****************************************************************void HiliteConnectButton (short mode){  Rect r;  short kind;  Handle h;    GetDItem(myDialog, kConnectButtonID, &amp;kind, &amp;h, &amp;r);    HiliteControl((ControlHandle)h, mode);}// *****************************************************************// *  outlinePopUpMenus// *// *   this is a group routine for drawing the popup menu outlines// *   compleat with drop shadow. the menu title is draw to the left// *  of the popUp item itself by this routine.// *****************************************************************void outlinePopUpMenus (WindowPtr whichWindow, Rect r, Str255 itemString){  FrameRect(&amp;r);  MoveTo(r.left + 2, r.bottom);  LineTo(r.right, r.bottom);  MoveTo(r.right, r.bottom);  LineTo(r.right, r.top + 2);  InsetRect(&amp;r, 1, 1);  EraseRect(&amp;r);  InsetRect(&amp;r, -1, -1);  MoveTo(r.left + 5, r.top + 11);  TextFont(geneva);  TextSize(9);  DrawString(itemString);  drawPopUpTri(whichWindow, r);}// *****************************************************************// *  UpdateUserItems// *// *   update procedure for the user items in our dialog.// *****************************************************************pascal void UpdateUserItems (WindowPtr whichWindow,               short theItem){  GrafPtr savedPort;  Rect r;  short kind;  Handle h;    GetPort(&amp;savedPort);    SetPort(whichWindow);    GetDItem(whichWindow, theItem, &amp;kind, &amp;h, &amp;r);    switch(theItem)    {      case kzoneItemID:         outlinePopUpMenus(whichWindow, r, gZoneString);        break;              case ktypeItemID:         outlinePopUpMenus(whichWindow, r, gTypeStr);        break;      case kobjectItemID:         outlinePopUpMenus(whichWindow, r, gObjStr);        break;      case kRemoteMacsTimeBorderID:         UpdateItemBorder(theItem, r);        break;      case kIncomingMessageBorderID:         UpdateItemBorder(theItem, r);        break;      case kConnectStatusBorder:         UpdateItemBorder(theItem, r);        break;      case kPopupBorderID:         UpdateItemBorder(theItem, r);        break;    }        SetPort(savedPort);}// *****************************************************************// *  DoModeless// *// * this handles mouse clicks inside our main dialog// *****************************************************************void DoModeless (DialogPtr whichDialog, short whichItem){  Rect r;  short kind;  Handle h;  MenuHandle allPurposeMenu;  long menuResult;  Point pt;    if (whichDialog == myDialog)      {        GetDItem(whichDialog, whichItem, &amp;kind, &amp;h, &amp;r);        switch(whichItem)        {          case kQuitButtonID:             Terminate();              break;          case kzoneItemID:            pt.v = r.top;            pt.h = r.left + 1;            LocalToGlobal(&amp;pt);            SetCursor(*(GetCursor(watchCursor)));            allPurposeMenu = NewMenu(ZoneMenuID, &quot;&quot;);            InsertMenu(allPurposeMenu, -1);            GetZones(allPurposeMenu);            InitCursor();            menuResult = PopUpMenuSelect(allPurposeMenu, pt.v, pt.h, 1);            if (menuResult != 0)            {              GetItem(allPurposeMenu, LoWord(menuResult), gZoneString);              gMenuItem = LoWord(menuResult);              CopyPstr(&quot;\p&quot;, gObjStr);              InvalRect(&amp;r);                                }            InitCursor();            DeleteMenu(ZoneMenuID);            DisposeMenu(allPurposeMenu);              break;          case ktypeItemID:            if (gMoofEntityFilter == false)            {              pt.v = r.top - 2;              pt.h = r.left + 1;              LocalToGlobal(&amp;pt);              allPurposeMenu = NewMenu(TypeMenuID, &quot;&quot;);              InsertMenu(allPurposeMenu, -1);              SetCursor(*(GetCursor(watchCursor)));              LookupNames(allPurposeMenu, false);              InitCursor();              menuResult = PopUpMenuSelect(allPurposeMenu, pt.v, pt.h, 1);              if (menuResult != 0)              {                GetItem(allPurposeMenu, LoWord(menuResult), gTypeStr);                if (strcmp(gTypeStr,&quot;Moof&quot;) == 0)                  HiliteConnectButton(0);                else                  HiliteConnectButton(255);                gMenuItem = LoWord(menuResult);                InvalRect(&amp;r);              }                            DeleteMenu(TypeMenuID);              DisposeMenu(allPurposeMenu);            }            else              SysBeep(1);              break;          case kobjectItemID:            pt.v = r.top - 2;            pt.h = r.left + 1;            LocalToGlobal(&amp;pt);            allPurposeMenu = NewMenu(ObjectMenuID, &quot;&quot;);            InsertMenu(allPurposeMenu, -1);            SetCursor(*(GetCursor(watchCursor)));            LookupNames(allPurposeMenu, true);            InitCursor();            menuResult = PopUpMenuSelect(allPurposeMenu, pt.v, pt.h, 1);            if (menuResult != 0)            {              GetItem(allPurposeMenu, LoWord(menuResult), gObjStr);              gMenuItem = LoWord(menuResult);              InvalRect(&amp;r);            }            DeleteMenu(ObjectMenuID);            DisposeMenu(allPurposeMenu);              break;          case kConnectButtonID: /* connect button */              connectToPeer();              break;          case kMoofFilterCheckBox:             if (gMoofEntityFilter == false)            {              SetCtlValue((ControlHandle)h,1);              gMoofEntityFilter = true;              CopyPstr(&quot;\pMoof&quot;, gTypeStr);              HiliteConnectButton(0);            }            else            {              SetCtlValue((ControlHandle)h,0);              gMoofEntityFilter = false;              CopyPstr(&quot;\p&quot;, gTypeStr);              if (gMyCCB.state == sClosed)                HiliteConnectButton(255);                          }                        gObjStr[0] = 0;            InvalRect(&amp;myDialog-&gt;portRect);              break;  /* iMoofFilter */                    } /* of case */      }  }// *****************************************************************// *  setEachUserItem// *// *  sets the update routine for our dialogs user items// *****************************************************************void setEachUserItem (short item){  Rect r;  short kind;  Handle h;      GetDItem(myDialog, item, &amp;kind, &amp;h, &amp;r);    SetDItem(myDialog, item, userItem, (Handle)UpdateUserItems, &amp;r);}// *****************************************************************// *  DoMenuCommand// *// *This is called when an item is chosen from the menu bar (after calling// * MenuSelect or MenuKey). It performs the right operation for each command.// * It is good to have both the result of MenuSelect and MenuKey go to// * one routine like this to keep everything organized.// *****************************************************************void DoMenuCommand (long menuResult){  short menuID;    /*the resource ID of the selected menu*/  short menuItem;    /*the item number of the selected menu*/  short itemHit;  Str255 daName;  short daRefNum;  Boolean handledByDA;    menuID = HiWord(menuResult);  /* use built-ins (for efficiency)...*/    menuItem = LoWord(menuResult);  /*to get menu item number and menu number*/    switch (menuID)    {    case mApple:         switch(menuItem)        {          case iAbout:        /*bring up alert for About*/            itemHit = Alert(rAboutDialog, nil);            break;          default:              /*all non-About items in this menu are DAs*/            GetItem(GetMHandle(mApple), menuItem, daName);            daRefNum = OpenDeskAcc(daName);            break;        }      break;    case mFile:         switch(menuItem)        {          case iClose:             DoCloseWindow(FrontWindow());            break;          case iQuit:             Terminate();            break;        }      break;    case mEdit:            /*call SystemEdit for DA editing &amp; MultiFinder*/        {          if (IsDAWindow(FrontWindow()))            handledByDA = SystemEdit(menuItem - 1);          else            DialogEditing(menuItem);        }      break;    }        HiliteMenu(0);          /*unhighlight what MenuSelect (or MenuKey) hilited*/    } /*DoMenuCommand*/// *****************************************************************// *  AdjustMenus// *// * Enable and disable menus based on the current state.// * The user can only select enabled menu items. We set up all the menu items// * before calling MenuSelect or MenuKey, since these are the only times that// * a menu item can be selected. Note that MenuSelect is also the only time// * the user will see menu items. This approach to deciding what enable// * disable state a menu item has the advantage of concentrating all the decision-// * making in one routine, as opposed to being spread throughout the application.// * Other application designs may take a different approach that is just as valid.// *****************************************************************void AdjustMenus(){  WindowPtr window;  MenuHandle menu;    window = FrontWindow();    menu = GetMHandle(mFile);    if (IsDAWindow(window))        /*we can allow desk accessories to be closed from the menu*/      EnableItem(menu, iClose);    else      DisableItem(menu, iClose);      /*but not our traffic light window*/    menu = GetMHandle(mEdit);    if (IsDAWindow(window))    {              /*a desk accessory might need the undo item */      EnableItem(menu, iUndo);      EnableItem(menu, iCut);      EnableItem(menu, iCopy);      EnableItem(menu, iPaste);      EnableItem(menu, iClear);    }    else    {              /* but we do not support undo!!! */      DisableItem(menu, iUndo);      EnableItem(menu, iCut);      EnableItem(menu, iCopy);      EnableItem(menu, iPaste);      EnableItem(menu, iClear);    }} /*AdjustMenus*/// *****************************************************************// *  DisplayCurrentStatus// *// *  updates our connection status string.// *****************************************************************void DisplayCurrentStatus(Ptr displayStr){  Rect r;  short kind;  Handle h;    Str255 current;    GetDItem(myDialog, kConnectionStatusString, &amp;kind, &amp;h, &amp;r);    GetIText(h,&amp;current);    if (IUCompString(current,displayStr) != 0)      SetIText(h, displayStr);}// *****************************************************************// *  DisposeQueueMemory// *// *  deallocate the memory we used for our error queue// *****************************************************************void DisposeQueueMemory(QHdrPtr qHdrPtr){  QElemPtr QElem;  OSErr err;      /* if free queue has any items, dispose of them */    while (qHdrPtr-&gt;qHead != nil)    {      QElem = qHdrPtr-&gt;qHead;      err = Dequeue(QElem,qHdrPtr);      DisposePtr((Ptr)QElem);    }}// *****************************************************************// *  Terminate// *// *  if we need to quit the program, we remove the connection// *  end (if any), deallocate any memory we used, remove our// *  nbp name from the network and exit.// *****************************************************************void Terminate(){    /* did we establish a connection end? */  if (gCCBRefNum != 0)      /* do a dspRemove to close the connection end */    removeConnectionEnd(gCCBRefNum);    /* deallocate the memory we used for our adsp buffers */  removeADSPBuffers();    /* remove our nbp name &quot;moof&quot; */  removeMyName();    /* dispose of memory we allocated      for our queues */  DisposeQueueMemory(&amp;gAvailQueue);  DisposeQueueMemory(&amp;gDoneQueue);  DisposeQueueMemory(&amp;gReadQueue);    ExitToShell();}// *****************************************************************// *  Exit// *// *  this routine is called for fatal control call errors. We exit// *  the program in this situation.// *****************************************************************void Exit(short message){  ShowError(message);  Terminate();}// *****************************************************************// *  DoIdleProc// *// *  this routine is called each time through our event loop. We// *  process any adsp errors that were returned and check for connections// *  coming and going.// *****************************************************************void DoIdleProc(){  ADSPLoop();}// *****************************************************************// *  AdjustCursor// *// *Change the cursor's shape, depending on its position. This also calculates the region// * where the current cursor resides (for WaitNextEvent). If the mouse is ever outside of// * that region, an event would be generated, causing this routine to be called,// * allowing us to change the region to the region the mouse is currently in. If// * there is more to the event than just &quot;the mouse moved&quot;, we get called before the// * event is processed to make sure the cursor is the right one. In any (ahem) event,// * this is called again before we fall back into WNE.// *****************************************************************void AdjustCursor (Point mouse, RgnHandle region){  WindowPtr window;  RgnHandle arrowRgn;  RgnHandle ourRgn;  Rect globalPortRect;  Rect r;  short kind;  Handle h;    window = FrontWindow();  /*we only adjust the cursor when we are in front*/    if ((!gInBackground) &amp;&amp; (!IsDAWindow(window)))    {        /*calculate regions for different cursor shapes*/      arrowRgn = NewRgn();      ourRgn = NewRgn();        /*start with a big, big rectangular region*/      SetRectRgn(arrowRgn, extremeNeg, extremeNeg, extremePos, extremePos);        /*calculate ourRgn*/      if (IsAppWindow(window))      {        SetPort(window);      /*make a global version of the portRect*/        SetOrigin(-window-&gt;portBits.bounds.left, -window-&gt;portBits.bounds.top);        globalPortRect = window-&gt;portRect;        RectRgn(ourRgn, &amp;globalPortRect);        SectRgn(ourRgn, window-&gt;visRgn, ourRgn);        SetOrigin(0, 0);      }        /*subtract other regions from arrowRgn*/      DiffRgn(arrowRgn, ourRgn, arrowRgn);        /*change the cursor and the region parameter*/      if (PtInRgn(mouse, ourRgn))      {        GetDItem(myDialog, kOutgoingTextID, &amp;kind, &amp;h, &amp;r);        GlobalToLocal(&amp;mouse);        if (PtInRect(mouse, &amp;r))          SetCursor(*GetCursor(iBeamCursor));        else          SetCursor(&amp;qd.arrow);        CopyRgn(ourRgn, region);      }      else      {        SetCursor(&amp;qd.arrow);        CopyRgn(arrowRgn, region);      }        /*get rid of our local regions*/      DisposeRgn(arrowRgn);      DisposeRgn(ourRgn);    }} /*AdjustCursor*/// *****************************************************************// *  UpdateItemBorder// *// *  re-draws the borders around our items// *****************************************************************void UpdateItemBorder (short item, Rect r){  FontInfo fInfo;  Rect tRect;  Str255 theBorderString;    switch(item)    {      case kRemoteMacsTimeBorderID:          strcpy(&amp;theBorderString,&quot;Time from remote Mac&quot;);        break;      case kIncomingMessageBorderID:          strcpy(&amp;theBorderString,&quot;Incoming message&quot;);        break;      case kPopupBorderID:          strcpy(&amp;theBorderString,&quot;Select A Target Machine&quot;);        break;      case kOutgoingMessageBorderID:          strcpy(&amp;theBorderString,&quot;Outgoing message&quot;);        break;      case kConnectStatusBorder:          strcpy(&amp;theBorderString,&quot;Connection Status&quot;);        break;      default:        break;    }    c2pstr(theBorderString);    GetFontInfo(&amp;fInfo);    FrameRect(&amp;r);    MoveTo(r.left + 5, r.top + fInfo.ascent / 2 - 1);    tRect.left = r.left + 4;    tRect.right = tRect.left + StringWidth(theBorderString) + 1;    tRect.top = r.top;    tRect.bottom = r.top + 1;    EraseRect(&amp;tRect);    DrawString(&amp;theBorderString);}// *****************************************************************// *  PlotSICN// *// * this is the PlotSICN code stolen from Tech Note #// *****************************************************************void PlotSICN (Rect theRect,SICNHand theSICN, short theIndex){  SignedByte state;  /* we want a chance to restore original state */  BitMap srcBits;      /* built up around 'SICN' data so we can _CopyBits */    /* check the index for a valid value */    if ((GetHandleSize((Handle)theSICN) / sizeof(SICN)) &gt; theIndex)    {      /* store the resource's current locked/unlocked condition */      state = HGetState((Handle)theSICN);      /* lock the resource so it won't move during the _CopyBits call */      HLock((Handle)theSICN);      /* set up the small icon's bitmap */      /*$PUSH*/      /*$R-*/      /* turn off range checking */      srcBits.baseAddr = (Ptr)(&amp;(**theSICN[theIndex]));      /*$POP*/      srcBits.rowBytes = 2;      SetRect(&amp;srcBits.bounds, 0, 0, 16, 16);      /* draw the small icon in the current grafport */      CopyBits(&amp;srcBits, &amp;qd.thePort-&gt;portBits, &amp;srcBits.bounds, &amp;theRect, srcCopy, nil);      /* restore the resource's locked/unlocked condition */      HSetState((Handle)theSICN, state);    }}// *****************************************************************// *  drawPopUpTri// *// * this procedure draws the new &quot;standard&quot; SICN triangle now used// * in popup menus I guess the drop shadow was not enough of an// * indiciation to the users of the presence of the pop-up.// * standard in 7.0 and up systems // *****************************************************************void drawPopUpTri (WindowPtr whichWindow, Rect r){#pragma unused (whichWindow)  Handle popUpTri;  Rect popUpTriRect;    popUpTri = GetResource('SICN', kStandardTriSICN);    if (popUpTri)    {      popUpTriRect = r;      popUpTriRect.right = popUpTriRect.right - 1;      popUpTriRect.left = popUpTriRect.right - 16;      popUpTriRect.top = popUpTriRect.top + 1;      popUpTriRect.bottom = popUpTriRect.top + 16;      PlotSICN(popUpTriRect, (SICNHand)popUpTri, 0);      ReleaseResource(popUpTri);    }}// *****************************************************************// *  DoEvent// *// * Do the right thing for an event. Determine what kind of event it is, and call// * the appropriate routines.// *****************************************************************void DoEvent (EventRecord event){  short part;  char key;  WindowPtr whichWindow;  DialogPeek dp;  short teLength;  DSPPBPtr dspPBPtr;  whichWindow = FrontWindow();    switch(event.what)    {      case nullEvent:         break;      case mouseDown:         part = FindWindow(event.where, &amp;whichWindow);        if (part != 0)        {          switch(part)          {            case inMenuBar:               /*process the menu command*/                AdjustMenus();                DoMenuCommand(MenuSelect(event.where));              break;            case inSysWindow:        /*let the system handle the mouseDown*/              SystemClick(&amp;event, whichWindow);              break;            case inContent:               if (whichWindow != FrontWindow())                SelectWindow(whichWindow);              break;            case inDrag:            /*pass screenBits.bounds to get all gDevices*/              DragWindow(whichWindow, event.where, &amp;qd.screenBits.bounds);              break;                        case inGrow:               break;            case inZoomIn:            case inZoomOut:              break;          }        }        break;      case keyDown:      case autoKey:                /*check for menukey equivalents*/          key = (char)(event.message &amp; charCodeMask);          if ((event.modifiers &amp; cmdKey) != 0)  /*Command key down*/          {            if ((event.what == keyDown) || (event.what == autoKey))            {              AdjustMenus();      /*enable/disable/check menu items properly*/              DoMenuCommand(MenuKey(key));            }          }          else if (key == (char)kEnterKey) /* enter key */          {            if ( (gMyCCB.state == sClosed) ||                (gMyCCB.state == sPassive))              ShowError(noConnErr);            else            {              dp = (DialogPeek)myDialog;                          /* we'll take a maximum of 255 characters from the edit box */              teLength = ((**(*dp).textH).teLength &lt; 255) ? (**(*dp).textH).teLength : 255;                          /* grab the text from our edit text box */              BlockMove( *((**(*dp).textH).hText), outgoingDataBuffer, teLength);                              /* we'll make sure we get a parameter block                  so we can send our data */              do              {                  /* get QElement for the write call */                dspPBPtr = GetQElement(&amp;gAvailQueue);              }              while ( (dspPBPtr == NULL) );                            writeOutgoing(dspPBPtr,                      gCCBRefNum,                      outgoingDataBuffer,                      teLength);              /* Change selection to outgoing text TERecord */              SelIText(myDialog, kOutgoingTextID, 0, 32767);                        }                    }        break;                                /*call DoActivate with the window and...*/      case activateEvt:                        /*true for activate, false for deactivate*/        DoActivate((WindowPtr)event.message, (event.modifiers &amp; activeFlag) != 0);        break;      case updateEvt:         break;      case osEvent:         switch(event.message &gt;&gt; 24)  /*high byte of message*/        {          case suspendResumeMessage:              gInBackground = (event.message &amp; resumeMask) == 0;              DoActivate(FrontWindow(), !gInBackground);          break;        }    }  } /*DoEvent*/// *****************************************************************// *  EventLoop// *// * Get events forever, and handle them by calling DoEvent.// * Get the events by calling WaitNextEvent, if it's available, otherwise// * by calling GetNextEvent. Also call AdjustCursor each time through the loop.// *****************************************************************void EventLoop(){  RgnHandle cursorRgn;  Boolean gotEvent;  EventRecord event;  long sleepTime;  WindowPtr whichDialog;  short whichItem;        cursorRgn = NewRgn();      /*we'll pass WNE an empty region the 1st time thru*/    sleepTime = 2;    do    {      if (gHasWaitNextEvent)  /*put us 'asleep' forever under MultiFinder*/      {        gotEvent = WaitNextEvent(everyEvent, &amp;event, sleepTime, cursorRgn);      }      else      {        SystemTask();        /*must be called if using GetNextEvent*/        gotEvent = GetNextEvent(everyEvent, &amp;event);      }      DoIdleProc();      AdjustCursor(event.where, cursorRgn); /*make sure we have the right cursor*/      whichDialog = FrontWindow();              /* don't pass command keys or &lt;enter&gt; keys to our dialog */      if (!((event.what==keyDown)&amp;&amp;(event.modifiers &amp; cmdKey))       &amp;&amp; (IsDialogEvent(&amp;event))      &amp;&amp; !((event.what==keyDown)&amp;&amp;((event.message &amp; charCodeMask) == (char)kEnterKey)))          {        if (DialogSelect(&amp;event, &amp;whichDialog, &amp;whichItem))          DoModeless(whichDialog, whichItem);      }      else            DoEvent(event);    }    while (true);          /*loop forever; we quit through an ExitToShell*/}// *****************************************************************// *  TrapAvailable// *// * Check to see if a given trap is implemented. This is only used by the// * Initialize routine in this program, so we put it in the Initialize segment.// * The recommended approach to see if a trap is implemented is to see if// * the address of the trap routine is the same as the address of the// * Unimplemented trap.// *****************************************************************#pragma segment InitializeBoolean TrapAvailable(tNumber,tType)  short    tNumber;  TrapType  tType;{  if ( ( tType == ToolTrap ) &amp;&amp;    ( gMac.machineType &gt; envMachUnknown ) &amp;&amp;    ( gMac.machineType &lt; envMacII ) )  {    /* it's a 512KE, Plus, or SE */    tNumber = tNumber &amp; 0x03FF;    if ( tNumber &gt; 0x01FF )          /* which means the tool traps */      tNumber = _Unimplemented;      /* only go to 0x01FF */  }  return NGetTrapAddress(tNumber, tType) != GetTrapAddress(_Unimplemented);} /*TrapAvailable*/// *****************************************************************// *  zeroOutStrings// *// *  clears out the name, time and incoming text strings// *****************************************************************void zeroOutStrings(){/* this procedure emptys all connection oriented strings in the main dialog */  Rect r;  short kind;  Handle h;    GetDItem(myDialog, kRemoteMacsNameID, &amp;kind, &amp;h, &amp;r);    SetIText(h, &quot;\p&quot;);    GetDItem(myDialog, kRemoteMacsTimeID, &amp;kind, &amp;h, &amp;r);    SetIText(h, &quot;\p&quot;);    GetDItem(myDialog, kIncomingTextID, &amp;kind, &amp;h, &amp;r);    SetIText(h, &quot;\p&quot;);}// *****************************************************************// *  SetupUserItems// *// *****************************************************************void SetupUserItems(){  setEachUserItem(kzoneItemID);  setEachUserItem(ktypeItemID);  setEachUserItem(kobjectItemID);  setEachUserItem(kRemoteMacsTimeBorderID);  setEachUserItem(kIncomingMessageBorderID);  setEachUserItem(kConnectStatusBorder);  setEachUserItem(kPopupBorderID);/* set connect button to unhilited */  HiliteConnectButton(255);}// *****************************************************************// *  Initialize// *// *  program initialization// *****************************************************************void Initialize(){  Rect r;  short kind;  Handle h;  Handle menuBar;  DialogPeek dp;    gInBackground = false;    InitGraf(&amp;qd.thePort);    InitFonts();    InitWindows();    InitMenus();    TEInit();    InitDialogs(nil);    InitCursor();    if (InitAppleTalk() != noErr)      Exit(atalkErr);          gZoneString[0] = 0;gTypeStr[0] = 0;gObjStr[0] = 0;    GetOurZone();      /*  we will allocate our own window storage instead of letting the Window */      /*  Manager do it because GetNewWindow may load in temp. resources before */      /*  making the NewPtr call, and this can lead to heap fragmentation. */    myDialog = (DialogPtr)(NewPtr(sizeof(DialogRecord)));    if (myDialog == nil)      Exit(memErr);    myDialog = GetNewDialog(rDialog, (Ptr)myDialog, (DialogPtr)-1);    SetPort(myDialog);    dp = (DialogPeek)myDialog;    TextFont(geneva);    TextSize(9);    (**(dp-&gt;textH)).txFont = geneva;    (**(dp-&gt;textH)).txSize = 9;    SetWTitle(myDialog, &quot;\pADSP&quot;);    ShowWindow(myDialog);    LastZoneMenuChoice = 0;    LastTypeMenuChoice = 0;    LastObjectMenuChoice = 0;    SetupUserItems();      /* show blinking cursor in outgoing text box */    SelIText(myDialog, kOutgoingTextID, 0, 32767);      /* turn on &quot;Moof&quot; entity filter (check box) initially */    GetDItem(myDialog, kMoofFilterCheckBox, &amp;kind, &amp;h, &amp;r);    SetCtlValue((ControlHandle)h,1);    gMoofEntityFilter = true;    CopyPstr(&quot;\pMoof&quot;, gTypeStr);    gObjStr[0] = 0;    HiliteConnectButton(0);        menuBar = GetNewMBar(rMenuBar);    /*read menus into menu bar*/    if (menuBar == nil)      Exit(menuErr);    SetMenuBar(menuBar);          /*install menus*/    DisposHandle(menuBar);    AddResMenu(GetMHandle(mApple), 'DRVR');  /*add DA names to Apple menu*/    DrawMenuBar();    gStopped = true;    zeroOutStrings();        initializeADSP();    } /*Initialize*/// *****************************************************************// *  CheckEnvirons// *// *  check the current operating environment// *****************************************************************void CheckEnvirons(){  long  total, contig, response;  OSErr ignoreError;      /* ignore the error returned from SysEnvirons; even if an error occurred,*/    /* the SysEnvirons glue will fill in the SysEnvRec*/      ignoreError = SysEnvirons(sysEnvironsVersion, &amp;gMac);    /* Make sure that the machine has at least 128K ROMs. If it doesn't, exit. */    if (gMac.machineType &lt; 0) FatalError(9);    if ((long) GetApplLimit() - (long) ApplicZone() &lt; kMinHeap) FatalError(10);    PurgeSpace(&amp;total, &amp;contig);    if (total &lt; kMinSpace)      if (UnloadScrap() != noErr)        FatalError(11);      else      {        PurgeSpace(&amp;total, &amp;contig);        if (total &lt; kMinSpace)          FatalError(11);      }          /* verify if WaitNextEvent, Gestalt and PPCToolbox are available */    gHasWaitNextEvent = TrapAvailable(_WaitNextEvent, ToolTrap);    if (TrapAvailable(_Gestalt, ToolTrap))     {     /* verify if system 7.0 */      Gestalt(gestaltSystemVersion,&amp;response );      if (response &gt;= 0x0700)        gHasSystem7 = true;      else gHasSystem7 = false;    }    else    {      SysBeep(20);      gHasSystem7 = false;    }}// *****************************************************************// *  Main// *// *****************************************************************#pragma segment Mainmain(){  MaxApplZone();      /*expand the heap so code segments load at the top*/  CheckEnvirons();    /*check for some basic requirements; exits if not met*/  Initialize();      /*initialize the program*/  UnloadSeg(&amp;Initialize);  /*note that Initialize must not be in Main!*/  EventLoop();      /*call the main event loop*/}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ADSP_Chat/listing5.html%3Fid%3DDTS10000224-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ADSP_Chat/listing5.html%3Fid%3DDTS10000224-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ADSP_Chat/listing5.html%3Fid%3DDTS10000224-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>