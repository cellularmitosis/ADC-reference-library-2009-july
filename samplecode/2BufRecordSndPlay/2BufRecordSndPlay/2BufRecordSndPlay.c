#include	<Quickdraw.h>#include	<Windows.h>#include	<dialogs.h>#include	<OSEvents.h>#include	<Memory.h>#include	<Packages.h>#include	<Sound.h>#include	<SoundInput.h>#include	<OSUtils.h>#define	TRUE			0xFF#define	FALSE			0#define buffSize		0x10000typedef struct {	short		OnOff;	short	 	Level;} Level;pascal void MyRecComp (SPBPtr inParamPtr);#ifdef powerc   QDGlobals	qd;#endifmain(){	OSErr				err;	SPBPtr				RecordRec;	long				SoundRefNum;	Handle				Buffer, Buffer2;	SndChannelPtr		chan;	Level				myLevel;	short				headerlength, headerlength2, dummy;	Fixed				sampleRate;	SICompletionUPP     mySICompletionUPP;		InitGraf(&qd.thePort);	FlushEvents(everyEvent, 0);	InitWindows();	InitDialogs(nil);	InitCursor();		err = SPBOpenDevice (nil, siWritePermission, &SoundRefNum);	if (err != noErr)		Debugger();			myLevel.OnOff = 0;	myLevel.Level = 0;	err = SPBSetDeviceInfo (SoundRefNum,siPlayThruOnOff, (Ptr) &myLevel);	if (err != noErr)		Debugger();			myLevel.OnOff = 0;	myLevel.Level = 0;	err = SPBSetDeviceInfo (SoundRefNum,siTwosComplementOnOff, (Ptr) &myLevel);	if (err != noErr)		Debugger();			err = SPBGetDeviceInfo (SoundRefNum,siSampleRate, (Ptr) &sampleRate);	if (err != noErr)		Debugger();			RecordRec = (SPBPtr) NewPtr(sizeof (SPB));	if (MemError() != noErr || RecordRec == nil)		Debugger();	Buffer = NewHandle(buffSize);	if (MemError() != noErr || Buffer == nil)		Debugger();	HLock (Buffer);	err = SetupSndHeader (Buffer, 1, sampleRate, 8, 'NONE', 0x3C, 0, &headerlength);	if (err != noErr)		Debugger();	err = SetupSndHeader (Buffer, 1, sampleRate, 8, 'NONE', 0x3C, buffSize - headerlength, &dummy);	if (err != noErr)		Debugger();	Buffer2 = NewHandle(buffSize);	if (MemError() != noErr || Buffer2 == nil)		Debugger();	HLock (Buffer2);	err = SetupSndHeader (Buffer2, 1, sampleRate, 8, 'NONE', 0x3C, 0, &headerlength2);	if (err != noErr)		Debugger();			err = SetupSndHeader (Buffer2, 1, sampleRate, 8, 'NONE', 0x3C, buffSize - headerlength2, &dummy);	if (err != noErr)		Debugger();			/* create a SICompletionUPP */    mySICompletionUPP = NewSICompletionProc(MyRecComp);	RecordRec->inRefNum = SoundRefNum;	RecordRec->count = 0;	RecordRec->milliseconds = 15000;	RecordRec->bufferLength = buffSize - headerlength;	RecordRec->bufferPtr = (Ptr) ((*Buffer) + headerlength);	RecordRec->completionRoutine = mySICompletionUPP;	RecordRec->interruptRoutine = nil;	RecordRec->userLong = 0;	RecordRec->error = 0;	RecordRec->unused1 = 0;	chan = nil;	err = SndNewChannel (&chan, sampledSynth, 0, nil);	if (err != noErr)		Debugger();			do {		err = SPBRecord (RecordRec, TRUE);		if (err != noErr)			Debugger();					do {			} while (RecordRec->userLong == 0);				if (RecordRec->userLong == 10) {			if (RecordRec->bufferPtr == (Ptr) ((*Buffer) + headerlength)) {				RecordRec->bufferPtr = (Ptr) ((*Buffer2) + headerlength2);					err = SndPlay (chan, Buffer, TRUE);				if (err != noErr)					Debugger();									}			else {				RecordRec->bufferPtr = (Ptr) ((*Buffer) + headerlength);					err = SndPlay (chan, Buffer2, TRUE);				if (err != noErr)					Debugger();						}			RecordRec->userLong = 0;			} 		} while (RecordRec->userLong != 1);			err = SndDisposeChannel (chan,FALSE);	if (err != noErr)		Debugger();	SPBCloseDevice (SoundRefNum);			HUnlock (Buffer);	HUnlock (Buffer2);	DisposeHandle (Buffer);	DisposeHandle (Buffer2);	DisposePtr ((Ptr) RecordRec);		DisposeRoutineDescriptor(mySICompletionUPP);}/**********************************/pascal void MyRecComp (SPBPtr inParamPtr){	inParamPtr->userLong = 10;			if (Button())		inParamPtr->userLong = 1;			return;}/**********************************/