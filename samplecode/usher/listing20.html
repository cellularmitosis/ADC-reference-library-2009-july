<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>usher - /sources/UsherMinWindow.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">usher</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">usher</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/sources/UsherMinWindow.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/notes/usingusher.htm</option>
<option value="listing2.html">/sources/AppSupport.c</option>
<option value="listing3.html">/sources/AppSupport.h</option>
<option value="listing4.html">/sources/MovieSourcing.c</option>
<option value="listing5.html">/sources/MovieSourcing.h</option>
<option value="listing6.html">/sources/PresInfoWindow.c</option>
<option value="listing7.html">/sources/PresInfoWindow.h</option>
<option value="listing8.html">/sources/PresinfoWindow.r</option>
<option value="listing9.html">/sources/QTSSampleCodeUtils.c</option>
<option value="listing10.html">/sources/QTSSampleCodeUtils.h</option>
<option value="listing11.html">/sources/SimplePres.c</option>
<option value="listing12.html">/sources/SimplePres.h</option>
<option value="listing13.html">/sources/SourcingSupport.c</option>
<option value="listing14.html">/sources/SourcingSupport.h</option>
<option value="listing15.html">/sources/usher.r</option>
<option value="listing16.html">/sources/UsherBroadcast.c</option>
<option value="listing17.html">/sources/UsherBroadcast.h</option>
<option value="listing18.html">/sources/UsherCarbon.r</option>
<option value="listing19.html">/sources/UsherCommands.h</option>
<option value="listing20.html">/sources/UsherMinWindow.c</option>
<option value="listing21.html">/sources/UsherMinWindow.h</option>
<option value="listing22.html">/sources/UsherMinWindow.r</option>
<option value="listing23.html">/sources/UsherNew.c</option>
<option value="listing24.html">/sources/UsherNew.h</option>
<option value="listing25.html">/sources/usherRezDefines.h</option>
<option value="listing26.html">/sources/WindowSupport.c</option>
<option value="listing27.html">/sources/WindowSupport.h</option>
<option value="listing28.html">/UsherReleaseNotes.txt</option></select>
				</p>
				</form>
				<p><strong><a href="usher.zip">Download Sample</a></strong> (&#147;usher.zip&#148;, 212.3K)<BR>
<strong><a href="usher.dmg">Download Sample</a></strong> (&#147;usher.dmg&#148;, 293.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    UsherMinWindow.c  Copyright:  &copy; 2000-2001 by Apple Computer, Inc., all rights reserved.*/#include &lt;ConditionalMacros.h&gt;#include &lt;ControlDefinitions.h&gt;#include &lt;Resources.h&gt;#include &lt;TextUtils.h&gt;#include &lt;FixMath.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;QuicktimeComponents.h&gt;#include &lt;MoviesFormat.h&gt;#include &lt;Movies.h&gt;#include &lt;QuickTimeStreaming.h&gt;#include &lt;QTStreamingComponents.h&gt;#include &quot;AppSupport.h&quot;#include &quot;QTSSampleCodeUtils.h&quot;#include &quot;WindowSupport.h&quot;#include &quot;UsherBroadcast.h&quot;#include &quot;UsherCommands.h&quot;#include &quot;usherminwindow.h&quot;#include &quot;usherrezdefines.h&quot;#include &quot;PresInfoWindow.h&quot;  // ---------------------------------------------------------------------------//    D E F I N I T I O N S// ---------------------------------------------------------------------------struct UsherMinWindowRecord {  StandardWindowRecord    standard;  UsherBroadcast        *broadcast;  WindowPtr          infoWindow;  SInt32            updateFlags;    long            lastUpdateTime;    // in ticks  long            updateInterval;    // in ticks  UInt32            dataRate;  Str255            presStateString;  DateTimeRec          dateTimeRec;  UsherStoredMovieParams    storedMovieParams;  QTSSourcerTimingParams    movieTimingParams;  UnsignedFixed        frameRate;  SimplePresState        presState;  Handle            ditlHandle;  ControlRef          startButton;  Boolean            startButtonIsStop;  ControlRef          skipToNextButton;  SInt32            drawingCount;  GrafPtr            oldPort;  short            labelFont;  short            labelFontSize;  short            font;  short            fontSize;};typedef struct UsherMinWindowRecord UsherMinWindowRecord, *UsherMinWindPeek;// update flagsenum  {  kMinWindUpdateFlag_PresState  = 0x00000001,  kMinWindUpdateFlag_DataRate    = 0x00000002,  kMinWindUpdateFlag_Time      = 0x00000004,  kMinWindUpdateFlag_StoredMovie  = 0x00000008,  kMinWindUpdateFlag_MovieTiming  = 0x00000010,  kMinWindUpdateFlag_FrameRate  = 0x00000020};#define kUsherMinWindDefaultUpdateInterval    60  // in ticks#define kUsherMinWindNoDataRate    0xFFFFFFFF#define kUsherMinWindNoFrameRate  0xFFFFFFFF//#define kUsherMinWindDefaultLabelFont    systemFont#define kUsherMinWindDefaultLabelFont    applFont#define kUsherMinWindDefaultLabelFontSize  9#define kUsherMinWindDefaultFont      applFont#define kUsherMinWindDefaultFontSize    9enum  {  kUsherMinWindDrawingFlag_Erase    = 0x00000001};// ---------------------------------------------------------------------------//    P R O T O T Y P E S// ---------------------------------------------------------------------------static OSErr UsherMinWindPriv_LoadControls(UsherMinWindowRecord *inWindData);static void UsherMinWindPriv_Dispose(UsherMinWindowRecord *inWindData);static Boolean UsherMinWindPriv_GetWindData(WindowPtr inWindow, UsherMinWindowRecord **outWindData);static void UsherMinWindPriv_Update(UsherMinWindowRecord *inWindData, Boolean inDraw, SInt32 inFlags);static void UsherMinWindPriv_GetReadyToDraw(UsherMinWindowRecord *inWindData);static void UsherMinWindPriv_FinishedDrawing(UsherMinWindowRecord *inWindData);static void UsherMinWindPriv_DrawDataRate(UsherMinWindowRecord *inWindData, SInt32 inFlags);static void UsherMinWindPriv_DrawFrameRate(UsherMinWindowRecord *inWindData, SInt32 inFlags);static void UsherMinWindPriv_DrawStatus(UsherMinWindowRecord *inWindData, SInt32 inFlags);static void UsherMinWindPriv_DrawStaticItems(UsherMinWindowRecord *inWindData, SInt32 inFlags);static void UsherMinWindPriv_DrawState(UsherMinWindowRecord *inWindData, SInt32 inFlags);static void UsherMinWindPriv_DrawTime(UsherMinWindowRecord *inWindData, SInt32 inFlags);static void UsherMinWindPriv_DrawStoredMovie(UsherMinWindowRecord *inWindData, SInt32 inFlags);static void UsherMinWindPriv_DrawMovieTiming(UsherMinWindowRecord *inWindData, SInt32 inFlags);static void UsherMinWindPriv_DrawItemText(UsherMinWindowRecord *inWindData, DialogItemIndex inItemIndex,          const unsigned char *inText, UInt32 inTextLength, SInt32 inFlags);static void UsherMinWindPriv_UpdateIfNecessary(UsherMinWindowRecord *inWindData);static void UsherMinWindPriv_UpdateDataRate(UsherMinWindowRecord *inWindData);static void UsherMinWindPriv_UpdateFrameRate(UsherMinWindowRecord *inWindData);static void UsherMinWindPriv_UpdateTime(UsherMinWindowRecord *inWindData);static void UsherMinWindPriv_UpdateMovieTiming(UsherMinWindowRecord *inWindData);static void UserMinWindPriv_DoControlClicked(UsherMinWindowRecord *inWindData,                ControlRef inControl, short inPart);static void UsherMinWindPriv_SetStartButtonText(UsherMinWindowRecord *inWindData);static OSErr GetDataRateString(UInt32 inDataRate, unsigned char *outString);// ---------------------------------------------------------------------------//    UsherMinWind_New// ---------------------------------------------------------------------------OSErr UsherMinWind_New(Boolean inUseAlt, WindowPtr *outWindow){  OSErr          err = noErr;  WindowPtr        window = NULL;  DialogTHndl        dlogHandle;  Rect          windowBounds;  UsherMinWindowRecord  *windData = NULL;  Str255          tempString;  if (inUseAlt)  {    dlogHandle = (DialogTHndl)GetResource('DLOG', rDLOG_UsherMinWindowLarge);  }  else  {    dlogHandle = (DialogTHndl)GetResource('DLOG', rDLOG_UsherMinWindow);  }  if (dlogHandle == NULL)  {    DEBUGF((&quot;UsherMinWind_New - null dlog resource&quot;));    EXITERR( err = memFullErr );  }  windowBounds = (**dlogHandle).boundsRect;#if TARGET_API_MAC_CARBON  EXITIFERR( err = CreateNewWindow( kDocumentWindowClass,         kWindowCloseBoxAttribute /* + kWindowResizableAttribute, um */,         &amp;windowBounds,         &amp;window ) );#else  window = NewCWindow(nil, &amp;windowBounds, (StringPtr)&quot;&quot;,        false, documentProc, (WindowPtr)kFirstWindowOfClass, true, 0L);#endif  if (window == NULL)  {    DEBUGF((&quot;UsherMinWind_New - null window&quot;));    EXITERR( err = memFullErr );  }    windData = (UsherMinWindowRecord*)QTSNewPtrClear(sizeof(*windData));  EXITIFERR( err = MemError() );    WindowSupport_InitStandardRecord(&amp;windData-&gt;standard, kSignature_UsherMinWind, window);  SetWRefCon(window, (long)windData);    windData-&gt;updateInterval = kUsherMinWindDefaultUpdateInterval;  windData-&gt;labelFont = kUsherMinWindDefaultLabelFont;  windData-&gt;labelFontSize = kUsherMinWindDefaultLabelFontSize;  windData-&gt;font = kUsherMinWindDefaultFont;  windData-&gt;fontSize = kUsherMinWindDefaultFontSize;    if (inUseAlt)  {    windData-&gt;ditlHandle = GetResource('DITL', rDITL_UsherMinWindowLarge);   }  else  {    windData-&gt;ditlHandle = GetResource('DITL', rDITL_UsherMinWindow);   }  if (windData-&gt;ditlHandle == NULL)  {    DEBUGF((&quot;UsherMinWind_New - null ditlhandle&quot;));    EXITERR( err = memFullErr );  }  DetachResource(windData-&gt;ditlHandle);  EXITIFERR( err = UsherMinWindPriv_LoadControls(windData) );  GetIndString(tempString, rStringList_UsherMinWind, rUsherMinWindString_DefaultName);  SetWTitle(window, tempString);  //ShowWindow(window);  *outWindow = window;exit:  if (err != noErr)  {    if (windData != NULL)  {      UsherMinWind_Close(window);    }  else  {        }  }  return err;}// ---------------------------------------------------------------------------//    UsherMinWindPriv_LoadControls// ---------------------------------------------------------------------------static OSErr UsherMinWindPriv_LoadControls(UsherMinWindowRecord *inWindData){  OSErr      err = noErr;  WindowPtr    window;  Rect      bounds;    window = inWindData-&gt;standard.window;    DITLGetItemRect(inWindData-&gt;ditlHandle, rMinWindDITLItem_StartButton, &amp;bounds);  inWindData-&gt;startButton = NewControl(window, &amp;bounds, &quot;\pStart&quot;, true, 0, 0, 0, pushButProc, (long)inWindData);  if (inWindData-&gt;startButton == NULL)  {    DEBUGF((&quot; UsherMinWindPriv_LoadControls $%.8x-couldn't make start button&quot;));    EXITERR( err = resNotFound );  }      DITLGetItemRect(inWindData-&gt;ditlHandle, rMinWindDITLItem_SkipToNextButton, &amp;bounds);  inWindData-&gt;skipToNextButton = NewControl(window, &amp;bounds, &quot;\pSkip&quot;, true, 0, 0, 0, pushButProc, (long)inWindData);  if (inWindData-&gt;skipToNextButton == NULL)  {    DEBUGF((&quot; UsherMinWindPriv_LoadControls $%.8x-couldn't make skip button&quot;));    EXITERR( err = resNotFound );  }  exit:  return err;}// ---------------------------------------------------------------------------//    UsherMinWind_Close// ---------------------------------------------------------------------------void UsherMinWind_Close(WindowPtr inWindow){  UsherMinWindowRecord    *windData = NULL;  if (inWindow != NULL)  {    if (!UsherMinWindPriv_GetWindData(inWindow, &amp;windData))  {      DEBUGF((&quot;UsherMinWind_Close $%.8x - couldnt get wind data&quot;, inWindow));      goto exit;    }    if (windData-&gt;infoWindow != NULL)  {      PresInfoWind_Close(windData-&gt;infoWindow);    }    UsherMinWindPriv_Dispose(windData);  }  DisposeWindow(inWindow);  exit:  return;}// ---------------------------------------------------------------------------//    UsherMinWindPriv_Dispose// ---------------------------------------------------------------------------static void UsherMinWindPriv_Dispose(UsherMinWindowRecord *inWindData){  if (inWindData != NULL)  {    if ((inWindData-&gt;broadcast != NULL)  &amp;&amp;  (inWindData-&gt;standard.window != NULL))  {      // tell the presentation we went away...      UsherBroadcast_RemoveWindow(inWindData-&gt;broadcast, inWindData-&gt;standard.window);    }    DisposeHandle(inWindData-&gt;ditlHandle);    DisposePtr((Ptr)inWindData);  }}// ---------------------------------------------------------------------------//    UsherMinWindPriv_GetWindData// ---------------------------------------------------------------------------static Boolean UsherMinWindPriv_GetWindData(WindowPtr inWindow, UsherMinWindowRecord **outWindData){  *outWindData = NULL;  if (inWindow != NULL)  {    *outWindData = (UsherMinWindowRecord*)GetWRefCon(inWindow);    if (*outWindData != NULL)  {      if ((*outWindData)-&gt;standard.signature != kSignature_UsherMinWind)  {        DEBUGF((&quot;UsherMinWind_GetWindData $%.8x $%.8x bad signature '%.4s'&quot;, inWindow, *outWindData, &amp;(*outWindData)-&gt;standard.signature));        *outWindData = NULL;      }    }  }  return (*outWindData != NULL);}#pragma mark -// ---------------------------------------------------------------------------//    UsherMinWind_Idle// ---------------------------------------------------------------------------void UsherMinWind_Idle(WindowPtr inWindow){  UsherMinWindowRecord    *windData;  if (!UsherMinWindPriv_GetWindData(inWindow, &amp;windData))  {    DEBUGF((&quot;UsherMinWind_Idle $%.8x - couldnt get wind data&quot;, inWindow));    goto exit;  }    UsherMinWindPriv_UpdateIfNecessary(windData);  UsherMinWindPriv_Update(windData, true, kUsherMinWindDrawingFlag_Erase);  exit:  return;}// ---------------------------------------------------------------------------//    UsherMinWind_GetMenuCommand// ---------------------------------------------------------------------------long UsherMinWind_GetMenuCommand(WindowPtr inWindow, long inMenuResult, void **outCommandParams){#pragma unused(outCommandParams)  UsherMinWindowRecord    *windData;  short            menuID, menuItem;  SInt32            command = kCommand_Nothing;  if (!UsherMinWindPriv_GetWindData(inWindow, &amp;windData))  {    DEBUGF((&quot;UsherMinWind_GetMenuCommand $%.8x - couldnt get wind data&quot;, inWindow));    goto exit;  }  menuID = (short)MYHIWORD(inMenuResult);  menuItem = (short)MYLOWORD(inMenuResult);  switch (menuID)  {    case rMenu_Presentation:      switch (menuItem)  {        case rMenuItem_GetPresInfo:          command = kCommand_GetPresInfo;          break;        default:          break;      }      break;    default:      break;  }    if (command == kCommand_Nothing)  {    if (windData-&gt;broadcast != 0)  {      command = UsherBroadcast_GetMenuCommand(windData-&gt;broadcast, inMenuResult, outCommandParams);    }  }  exit:  return command;}// ---------------------------------------------------------------------------//    UsherMinWind_DoCommand// ---------------------------------------------------------------------------OSErr UsherMinWind_DoCommand(WindowPtr inWindow, long inCommand, void *inCommandParams){#pragma unused(inCommandParams)  UsherMinWindowRecord  *windData;  OSErr          err = noErr;  if (!UsherMinWindPriv_GetWindData(inWindow, &amp;windData))  {    DEBUGF((&quot;UsherMinWind_DoCommand $%.8x - couldnt get wind data&quot;, inWindow));    EXITERR( err = kErr_AppUnhandledCommand );  }    switch (inCommand)  {    case kCommand_GetPresInfo:      if (windData-&gt;infoWindow != NULL)  {        SelectWindow(windData-&gt;infoWindow);      }  else  {        Point    newLoc;        Rect    myWindowRect;        GrafPtr    oldPort;                GetPort(&amp;oldPort);        SetPortWindowPort(inWindow);                EXITIFERR( err = WindowSupport_NewWindowOfType(kSignature_PresInfoWind, false, &amp;windData-&gt;infoWindow) );        PresInfoWind_HandleMessage(windData-&gt;infoWindow, kMessage_SetUsherBroadcast, windData-&gt;broadcast);        PresInfoWind_HandleMessage(windData-&gt;infoWindow, kMessage_SetParentWindow, inWindow);        // move the window next to this one        CopyPortBounds(GetWindowPort(inWindow), &amp;myWindowRect);        newLoc.h = myWindowRect.right + 20;        newLoc.v = myWindowRect.top;        LocalToGlobal(&amp;newLoc);        MacSetPort(oldPort);        MacMoveWindow(windData-&gt;infoWindow, newLoc.h, newLoc.v, false);        MacShowWindow(windData-&gt;infoWindow);        SelectWindow(windData-&gt;infoWindow);      }      break;    default:      if (windData-&gt;broadcast != 0)  {        err = UsherBroadcast_DoCommand(windData-&gt;broadcast, inCommand, inCommandParams);      }  else  {        err = kErr_AppUnhandledCommand;      }      break;  }exit:  return err;}// ---------------------------------------------------------------------------//    UsherMinWind_GrowWindow// ---------------------------------------------------------------------------void UsherMinWind_GrowWindow(WindowPtr inWindow, EventRecord *inEvent){#pragma unused(inEvent)  UsherMinWindowRecord    *windData;  if (!UsherMinWindPriv_GetWindData(inWindow, &amp;windData))  {    DEBUGF((&quot;UserMinWind_GrowWindow $%.8x - couldnt get wind data&quot;, inWindow));    goto exit;  }  // nothing to do for now...exit:  return;}// ---------------------------------------------------------------------------//    UsherMinWind_DoContentClick// ---------------------------------------------------------------------------void UsherMinWind_DoContentClick(WindowPtr inWindow, EventRecord *inEvent){  UsherMinWindowRecord  *windData;  GrafPtr          oldPort;  short          partCode;  ControlRef        clickedControl;  Point          currentMouse;  if (!UsherMinWindPriv_GetWindData(inWindow, &amp;windData))  {    DEBUGF((&quot;UsherMinWind_DoContentClick $%.8x - couldnt get wind data&quot;, inWindow));    goto exit;  }  GetPort(&amp;oldPort);  SetPortWindowPort(inWindow);    currentMouse = inEvent-&gt;where;  GlobalToLocal(&amp;currentMouse);  partCode = FindControl(currentMouse, inWindow, &amp;clickedControl);  if (partCode != 0)  {    partCode = TrackControl(clickedControl, currentMouse, NULL);    if (partCode != 0)  {      UserMinWindPriv_DoControlClicked(windData, clickedControl, partCode);    }  }exit:  MacSetPort(oldPort);  return;}// ---------------------------------------------------------------------------//    UserMinWindPriv_DoControlClicked// ---------------------------------------------------------------------------static void UserMinWindPriv_DoControlClicked(UsherMinWindowRecord *inWindData,                ControlRef inControl, short inPart){#pragma unused(inPart)  OSErr      err = noErr;  if (inControl == inWindData-&gt;startButton)  {    if (inWindData-&gt;broadcast != NULL)  {      if (inWindData-&gt;presState &lt;= kSimplePresState_Idle)  {        UsherBroadcast_Start(inWindData-&gt;broadcast);      }  else  {        UsherBroadcast_Stop(inWindData-&gt;broadcast);      }    }  }  else if (inControl == inWindData-&gt;skipToNextButton)  {    if (inWindData-&gt;broadcast != NULL)  {      err = UsherBroadcast_DoCommand(inWindData-&gt;broadcast, kCommand_SkipToNextMovie, NULL);      if (err != noErr)  {        DEBUGF((&quot;kCommand_SkipToNextMovie returned err %ld&quot;, err));        SysBeep(0);      }    }  }}// ---------------------------------------------------------------------------//    UsherMinWind_ActivateWindow// ---------------------------------------------------------------------------void UsherMinWind_ActivateWindow(WindowPtr inWindow, Boolean inBecomingActive){#pragma unused(inBecomingActive)  UsherMinWindowRecord    *windData;  Rect            windowRect;  if (!UsherMinWindPriv_GetWindData(inWindow, &amp;windData))  {    DEBUGF((&quot;UsherMinWind_ActivateWindow $%.8x - couldnt get wind data&quot;, inWindow));    goto exit;  }    CopyPortBounds(GetWindowPort(inWindow), &amp;windowRect);  InvalWindowRect(inWindow, &amp;windowRect);    // draw any stuff that should be different in active/inactive mode  //UsherMinWind_Draw(inWindow);exit:  return;}// ---------------------------------------------------------------------------//    UsherMinWind_HandleMessage// ---------------------------------------------------------------------------OSErr UsherMinWind_HandleMessage(WindowPtr inWindow, long inMessage, void *inMessageParams){#pragma unused(inMessageParams)  UsherMinWindowRecord  *windData;  OSErr          err = noErr;  OSErr          tempErr;  if (!UsherMinWindPriv_GetWindData(inWindow, &amp;windData))  {    DEBUGF((&quot;UsherMinWind_HandleMessage $%.8x - couldnt get wind data&quot;, inWindow));    EXITERR( err = qtsBadSelectorErr );  }    switch (inMessage)  {    case kMessage_SetUsherBroadcast:      windData-&gt;broadcast = (UsherBroadcast*)inMessageParams;      if (windData-&gt;broadcast != 0)  {        UsherBroadcastStringParams  stringParams;        Str255          pname;                memset(&amp;stringParams, 0, sizeof(stringParams));        stringParams.ioString = (char*)pname;        stringParams.inMaxLength = sizeof(pname)-1;        tempErr = UsherBroadcast_DoCommand(windData-&gt;broadcast, kCommand_GetBroadcastName, &amp;stringParams);        if (tempErr == noErr)  {          if (stringParams.returnedStringLength &gt; 0)  {            CopyCToPStr((char*)pname, pname);            SetWTitle(windData-&gt;standard.window, pname);          }        }        windData-&gt;updateFlags |= kMinWindUpdateFlag_PresState;                tempErr = UsherBroadcast_DoCommand(windData-&gt;broadcast, kCommand_GetStoredMovieInfo, &amp;windData-&gt;storedMovieParams);        if (windData-&gt;skipToNextButton != 0)  {          if (windData-&gt;storedMovieParams.doingStoredMovies)  {            ShowControl(windData-&gt;skipToNextButton);          }  else  {            HideControl(windData-&gt;skipToNextButton);          }        }              }      break;    case kMessage_GetPresBox:    {      Rect    *presBox = (Rect*)inMessageParams;            DITLGetItemRect(windData-&gt;ditlHandle, rMinWindDITLItem_VideoArea, presBox);      break;    }    case kMessage_SendPresStatusChanged:    {      Rect    windowRect;      CopyPortBounds(GetWindowPort(inWindow), &amp;windowRect);      InvalWindowRect(inWindow, &amp;windowRect);        break;    }          case kMessage_WindowClosing:    {      WindowPtr    closingWindow = (WindowPtr)inMessageParams;            if (closingWindow == windData-&gt;infoWindow)  {        windData-&gt;infoWindow = NULL;      }      break;        }    case kMessage_SendPresStateChanged:      windData-&gt;updateFlags |= kMinWindUpdateFlag_PresState;      windData-&gt;presState = (SimplePresState)inMessageParams;      UsherMinWindPriv_SetStartButtonText(windData);      break;    case kMessage_UsherPresStoredMovieChanged:      windData-&gt;updateFlags |= kMinWindUpdateFlag_StoredMovie;      break;    default:      err = qtsBadSelectorErr;      break;  }exit:  return err;}#pragma mark -// ---------------------------------------------------------------------------//    UsherMinWind_Draw// ---------------------------------------------------------------------------void UsherMinWind_Draw(WindowPtr inWindow){  UsherMinWindowRecord    *windData;  Rect            tempRect;  if (!UsherMinWindPriv_GetWindData(inWindow, &amp;windData))  {    DEBUGF((&quot;UsherMinWind_Draw $%.8x - couldnt get wind data&quot;, inWindow));    goto exit;  }    UsherMinWindPriv_GetReadyToDraw(windData);  CopyPortBounds(GetWindowPort(inWindow), &amp;tempRect);  EraseRect(&amp;tempRect);    DrawControls(inWindow);      // ----- outline the video area  DITLGetItemRect(windData-&gt;ditlHandle, rMinWindDITLItem_VideoArea, &amp;tempRect);  PenNormal();  tempRect.left -= 1;  tempRect.top -= 1;  tempRect.right += 1;  tempRect.bottom += 1;  MacFrameRect(&amp;tempRect);  UsherMinWindPriv_DrawStaticItems(windData, 0L);  TextFont(windData-&gt;font);  TextSize(windData-&gt;fontSize);  TextFace(0);  UsherMinWindPriv_DrawStatus(windData, 0L);    UsherMinWindPriv_DrawDataRate(windData, 0L);  UsherMinWindPriv_DrawState(windData, 0L);  UsherMinWindPriv_DrawTime(windData, 0L);  UsherMinWindPriv_DrawFrameRate(windData, 0L);  if (windData-&gt;storedMovieParams.doingStoredMovies)  {    UsherMinWindPriv_DrawStoredMovie(windData, 0L);    UsherMinWindPriv_DrawMovieTiming(windData, 0L);  }      UsherMinWindPriv_FinishedDrawing(windData);exit:  return;}// ---------------------------------------------------------------------------//    UsherMinWindPriv_GetReadyToDraw// ---------------------------------------------------------------------------static void UsherMinWindPriv_GetReadyToDraw(UsherMinWindowRecord *inWindData){  if (inWindData-&gt;drawingCount &lt; 0)  {    DEBUGF((&quot;UsherMinWindPriv_GetReadyToDraw $%.8x-drawingcount&lt;0 $%.8x&quot;, inWindData, inWindData-&gt;drawingCount));  }  // if we're reentrant, we won't save the old port...i guess  if (inWindData-&gt;drawingCount == 0)  {    GetPort(&amp;inWindData-&gt;oldPort);  }  ++inWindData-&gt;drawingCount;  SetPortWindowPort(inWindData-&gt;standard.window);  TextFont(inWindData-&gt;font);  TextSize(inWindData-&gt;fontSize);}// ---------------------------------------------------------------------------//    UsherMinWindPriv_FinishedDrawing// ---------------------------------------------------------------------------static void UsherMinWindPriv_FinishedDrawing(UsherMinWindowRecord *inWindData){  --inWindData-&gt;drawingCount;  if (inWindData-&gt;drawingCount == 0)  {    MacSetPort(inWindData-&gt;oldPort);  }}// ---------------------------------------------------------------------------//    UsherMinWindPriv_Update// ---------------------------------------------------------------------------static void UsherMinWindPriv_Update(UsherMinWindowRecord *inWindData, Boolean inDraw, SInt32 inFlags){  OSErr          err = noErr;  UsherBroadcastStringParams  stringParams;  Str255          tempString;  if (inWindData-&gt;updateFlags != 0)  {    if (inDraw)  {      UsherMinWindPriv_GetReadyToDraw(inWindData);    }    if (inWindData-&gt;updateFlags &amp; kMinWindUpdateFlag_PresState)  {      // get the string from the presentation      if (inWindData-&gt;broadcast != 0)  {        memset(&amp;stringParams, 0, sizeof(stringParams));        stringParams.ioString = (char*)inWindData-&gt;presStateString;        stringParams.inMaxLength = sizeof(inWindData-&gt;presStateString)-1;        err = UsherBroadcast_DoCommand(inWindData-&gt;broadcast, kCommand_GetBroadcastStateString, &amp;stringParams);        CopyCToPStr((char*)inWindData-&gt;presStateString, inWindData-&gt;presStateString);      }  else  {        err = -776;      }      if (err != noErr)  {        DEBUGF((&quot;UsherMinWindPriv_Update $%.8x-err %ld from cmd GetPresStateString&quot;, inWindData, err));        GetIndString(tempString, rStringList_UsherMinWind, rUsherMinWindString_SPStateUnknownTemplate);        CopyPToCStr(tempString, (char*)tempString);        sprintf((char*)inWindData-&gt;presStateString, (char*)tempString, err);         CopyCToPStr((char*)inWindData-&gt;presStateString, inWindData-&gt;presStateString);      }      if (inDraw)  {        UsherMinWindPriv_DrawState(inWindData, inFlags);      }      inWindData-&gt;updateFlags &amp;= ~kMinWindUpdateFlag_PresState;    }        if (inWindData-&gt;updateFlags &amp; kMinWindUpdateFlag_DataRate)  {      inWindData-&gt;updateFlags &amp;= ~kMinWindUpdateFlag_DataRate;      if (inDraw)  {        UsherMinWindPriv_DrawDataRate(inWindData, inFlags);      }    }    if (inWindData-&gt;updateFlags &amp; kMinWindUpdateFlag_FrameRate)  {      inWindData-&gt;updateFlags &amp;= ~kMinWindUpdateFlag_FrameRate;      if (inDraw)  {        UsherMinWindPriv_DrawFrameRate(inWindData, inFlags);      }    }    if (inWindData-&gt;updateFlags &amp; kMinWindUpdateFlag_Time)  {      inWindData-&gt;updateFlags &amp;= ~kMinWindUpdateFlag_Time;      if (inDraw)  {        UsherMinWindPriv_DrawTime(inWindData, inFlags);      }    }    if (inWindData-&gt;updateFlags &amp; kMinWindUpdateFlag_StoredMovie)  {      inWindData-&gt;updateFlags &amp;= ~kMinWindUpdateFlag_StoredMovie;      memset(&amp;inWindData-&gt;storedMovieParams, 0, sizeof(inWindData-&gt;storedMovieParams));      if (inWindData-&gt;broadcast != 0)  {         UsherBroadcast_DoCommand(inWindData-&gt;broadcast, kCommand_GetStoredMovieInfo, &amp;inWindData-&gt;storedMovieParams);      }      if (inDraw)  {        UsherMinWindPriv_DrawStoredMovie(inWindData, inFlags);      }    }    if (inWindData-&gt;updateFlags &amp; kMinWindUpdateFlag_MovieTiming)  {      inWindData-&gt;updateFlags &amp;= ~kMinWindUpdateFlag_MovieTiming;      if (inDraw)  {        UsherMinWindPriv_DrawMovieTiming(inWindData, inFlags);      }    }    if (inDraw)  {      UsherMinWindPriv_FinishedDrawing(inWindData);    }  }}// ---------------------------------------------------------------------------//    UsherMinWindPriv_DrawState// ---------------------------------------------------------------------------static void UsherMinWindPriv_DrawState(UsherMinWindowRecord *inWindData, SInt32 inFlags){  UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_PresStateText,      &amp;inWindData-&gt;presStateString[1], inWindData-&gt;presStateString[0], inFlags);}// ---------------------------------------------------------------------------//    UsherMinWindPriv_DrawDataRate// ---------------------------------------------------------------------------static void UsherMinWindPriv_DrawDataRate(UsherMinWindowRecord *inWindData, SInt32 inFlags){  Str255    tempString;  // assumes the port, font, etc is already set  //if (inWindData-&gt;dataRate == kUsherMinWindNoDataRate)  {  if (0)  {  }  else  {    //NumToString(inWindData-&gt;dataRate, tempString);    GetDataRateString(inWindData-&gt;dataRate, tempString);  }  UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_DataRateText,            &amp;tempString[1], tempString[0], inFlags);}// ---------------------------------------------------------------------------//    UsherMinWindPriv_DrawFrameRate// ---------------------------------------------------------------------------static void UsherMinWindPriv_DrawFrameRate(UsherMinWindowRecord *inWindData, SInt32 inFlags){  Str255    tempString;  // assumes the port, font, etc is already set  if (inWindData-&gt;frameRate != kUsherMinWindNoFrameRate)  {    sprintf((char*)tempString, &quot;%0.1f frames/sec&quot;, Fix2X(inWindData-&gt;frameRate));    c2pstr((char*)tempString);  } else  {    pstrcpy(tempString, &quot;\punknown&quot;);  }  UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_FrameRateText,            &amp;tempString[1], tempString[0], inFlags);}// ---------------------------------------------------------------------------//    UsherMinWindPriv_DrawTime// ---------------------------------------------------------------------------static void UsherMinWindPriv_DrawTime(UsherMinWindowRecord *inWindData, SInt32 inFlags){  char    tempString[256];    DateTimeRecToString(&amp;inWindData-&gt;dateTimeRec, tempString);  UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_TimeText,            (unsigned char*)tempString, strlen(tempString), inFlags);}// ---------------------------------------------------------------------------//    UsherMinWindPriv_DrawStoredMovie// ---------------------------------------------------------------------------static void UsherMinWindPriv_DrawStoredMovie(UsherMinWindowRecord *inWindData, SInt32 inFlags){  UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_StoredMovieText,            (unsigned char*)&amp;(inWindData-&gt;storedMovieParams.currentMovieSpec.name[1]),            inWindData-&gt;storedMovieParams.currentMovieSpec.name[0], inFlags);}// ---------------------------------------------------------------------------//    UsherMinWindPriv_DrawMovieTiming// ---------------------------------------------------------------------------static void UsherMinWindPriv_DrawMovieTiming(UsherMinWindowRecord *inWindData, SInt32 inFlags){  char      tempString[256];  TimeValue64    temp64;    if (inWindData-&gt;movieTimingParams.timeScale != 0)  {      if (inWindData-&gt;movieTimingParams.localCurrentTime &lt; inWindData-&gt;movieTimingParams.localEndTime)  {      temp64 = inWindData-&gt;movieTimingParams.localEndTime - inWindData-&gt;movieTimingParams.localCurrentTime;    }  else  {      temp64 = 0;    }    TimeValue64ToString(&amp;temp64, inWindData-&gt;movieTimingParams.timeScale, tempString);    UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_TimeRemainingText,              (unsigned char*)tempString, strlen(tempString), inFlags);  }}// ---------------------------------------------------------------------------//    UsherMinWindPriv_DrawStatus// ---------------------------------------------------------------------------static void UsherMinWindPriv_DrawStatus(UsherMinWindowRecord *inWindData, SInt32 inFlags){  QTSStatusParams    *statusParams;  Str255        tempString;  // assumes the port, font, etc is already set  if (inWindData-&gt;broadcast != 0)  {    statusParams = UsherBroadcast_GetStatusParams(inWindData-&gt;broadcast);    if (statusParams != NULL)  {      if (statusParams-&gt;detailedStatusString != NULL)  {        MacDrawText(statusParams-&gt;detailedStatusString, 0, (short)strlen(statusParams-&gt;detailedStatusString));      }  else if (statusParams-&gt;statusString != NULL)  {        MacDrawText(statusParams-&gt;statusString, 0, (short)strlen(statusParams-&gt;statusString));      }  else  {        NumToString(statusParams-&gt;status, tempString);        UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_StatusText,            &amp;tempString[1], tempString[0], inFlags);      }    }  }  }// ---------------------------------------------------------------------------//    UsherMinWindPriv_DrawStaticItems// ---------------------------------------------------------------------------static void UsherMinWindPriv_DrawStaticItems(UsherMinWindowRecord *inWindData, SInt32 inFlags){  Str255        tempString;  TextFont(inWindData-&gt;labelFont);  TextSize(inWindData-&gt;labelFontSize);  TextFace(bold);  GetIndString(tempString, rStringList_UsherMinWind, rUsherMinWindString_StatusLabel);  UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_StatusLabel,            &amp;tempString[1], tempString[0], inFlags);  GetIndString(tempString, rStringList_UsherMinWind, rUsherMinWindString_DataRateLabel);  UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_DataRateLabel,            &amp;tempString[1], tempString[0], inFlags);  GetIndString(tempString, rStringList_UsherMinWind, rUsherMinWindString_FrameRateLabel);  UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_FrameRateLabel,            &amp;tempString[1], tempString[0], inFlags);  GetIndString(tempString, rStringList_UsherMinWind, rUsherMinWindString_SPStateLabel);  UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_PresStateLabel,            &amp;tempString[1], tempString[0], inFlags);  GetIndString(tempString, rStringList_UsherMinWind, rUsherMinWindString_TimeLabel);  UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_TimeLabel,            &amp;tempString[1], tempString[0], inFlags);  if (inWindData-&gt;storedMovieParams.doingStoredMovies)  {    GetIndString(tempString, rStringList_UsherMinWind, rUsherMinWindString_StoredMovieLabel);    UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_StoredMovieLabel,            &amp;tempString[1], tempString[0], inFlags);    GetIndString(tempString, rStringList_UsherMinWind, rUsherMinWindString_TimeRemainingLabel);    UsherMinWindPriv_DrawItemText(inWindData, rMinWindDITLItem_TimeRemainingLabel,            &amp;tempString[1], tempString[0], inFlags);  }}// ---------------------------------------------------------------------------//    UsherMinWindPriv_DrawItemText// ---------------------------------------------------------------------------static void UsherMinWindPriv_DrawItemText(UsherMinWindowRecord *inWindData, DialogItemIndex inItemIndex,          const unsigned char *inText, UInt32 inTextLength, SInt32 inFlags){  Rect    itemRect;  // assumes the port, font, etc is already set  DITLGetItemRect(inWindData-&gt;ditlHandle, inItemIndex, &amp;itemRect);  if (inFlags &amp; kUsherMinWindDrawingFlag_Erase)  {    EraseRect(&amp;itemRect);  }  MoveTo(itemRect.left, (short)(itemRect.bottom-3));  MacDrawText(inText, 0, (short)inTextLength);}#pragma mark -// ---------------------------------------------------------------------------//    UsherMinWindPriv_UpdateIfNecessary// ---------------------------------------------------------------------------static void UsherMinWindPriv_UpdateIfNecessary(UsherMinWindowRecord *inWindData){  if (inWindData-&gt;lastUpdateTime + inWindData-&gt;updateInterval &lt; (SInt32)TickCount())  {    UsherMinWindPriv_UpdateDataRate(inWindData);    UsherMinWindPriv_UpdateFrameRate(inWindData);    UsherMinWindPriv_UpdateTime(inWindData);    if (inWindData-&gt;storedMovieParams.doingStoredMovies)  {      inWindData-&gt;updateFlags |= kMinWindUpdateFlag_StoredMovie;    }    if (inWindData-&gt;storedMovieParams.doingStoredMovies)  {      UsherMinWindPriv_UpdateMovieTiming(inWindData);    }    inWindData-&gt;lastUpdateTime = TickCount();  }}// ---------------------------------------------------------------------------//    UsherMinWindPriv_UpdateDataRate// ---------------------------------------------------------------------------static void UsherMinWindPriv_UpdateDataRate(UsherMinWindowRecord *inWindData){  if (inWindData-&gt;broadcast != 0)  {    inWindData-&gt;dataRate = 0;    if (UsherBroadcast_GetInfo(inWindData-&gt;broadcast,            kQTSTotalDataRateOutInfo, &amp;inWindData-&gt;dataRate) != noErr)  {      inWindData-&gt;dataRate = kUsherMinWindNoDataRate;    }  }  else  {    inWindData-&gt;dataRate = kUsherMinWindNoDataRate;  }  inWindData-&gt;updateFlags |= kMinWindUpdateFlag_DataRate;}// ---------------------------------------------------------------------------//    UsherMinWindPriv_UpdateFrameRate// ---------------------------------------------------------------------------static void UsherMinWindPriv_UpdateFrameRate(UsherMinWindowRecord *inWindData){#pragma unused (inWindData)}// ---------------------------------------------------------------------------//    UsherMinWindPriv_UpdateTime// ---------------------------------------------------------------------------static void UsherMinWindPriv_UpdateTime(UsherMinWindowRecord *inWindData){  OSErr        err = noErr;  DateTimeRec      dateTimeRec;  UsherBroadcastTimeParams  timeParams;    memset(&amp;dateTimeRec, 0, sizeof(dateTimeRec));  memset(&amp;timeParams, 0, sizeof(timeParams));  if (inWindData-&gt;broadcast != 0)  {    EXITIFERR( err = UsherBroadcast_DoCommand(inWindData-&gt;broadcast,              kCommand_GetBroadcastTime, &amp;timeParams) );    TimeValue64ToDateTimeRec(&amp;timeParams.returnedTime, timeParams.timeScale, &amp;dateTimeRec);  }  else  {    memset(&amp;inWindData-&gt;dateTimeRec, 0, sizeof(inWindData-&gt;dateTimeRec));  }    if ( (dateTimeRec.day != inWindData-&gt;dateTimeRec.day)    ||     (dateTimeRec.hour != inWindData-&gt;dateTimeRec.hour)    ||     (dateTimeRec.minute != inWindData-&gt;dateTimeRec.minute)  ||     (dateTimeRec.second != inWindData-&gt;dateTimeRec.second) )  {    BlockMoveData(&amp;dateTimeRec, &amp;inWindData-&gt;dateTimeRec, sizeof(dateTimeRec));    inWindData-&gt;updateFlags |= kMinWindUpdateFlag_Time;  }exit:  if (err != noErr)  {    DEBUGF((&quot;UsherMinWindPriv_UpdateTime $%.8x-err %ld getting time from pres&quot;, inWindData, err));  }  return;}// ---------------------------------------------------------------------------//    UsherMinWindPriv_UpdateMovieTiming// ---------------------------------------------------------------------------static void UsherMinWindPriv_UpdateMovieTiming(UsherMinWindowRecord *inWindData){  if (inWindData-&gt;broadcast != 0)  {    memset(&amp;inWindData-&gt;movieTimingParams, 0, sizeof(inWindData-&gt;movieTimingParams));    // @@@ this is not quite right - what we want is the timing info of the movie,    // not just one sourcer    UsherBroadcast_GetInfo(inWindData-&gt;broadcast, kQTSInfo_SourcerTiming, &amp;inWindData-&gt;movieTimingParams);    inWindData-&gt;updateFlags |= kMinWindUpdateFlag_MovieTiming;  }}// ---------------------------------------------------------------------------//    UsherMinWindPriv_SetStartButtonText// ---------------------------------------------------------------------------static void UsherMinWindPriv_SetStartButtonText(UsherMinWindowRecord *inWindData){  if (inWindData-&gt;presState &lt;= kSimplePresState_Idle)  {     if (inWindData-&gt;startButtonIsStop)  {       SetControlTitle(inWindData-&gt;startButton, &quot;\pStart&quot;);      // currently, you can't start the presentation after you have stopped it      HiliteControl(inWindData-&gt;startButton, 255);       inWindData-&gt;startButtonIsStop = false;     }  }  else  {     if (!inWindData-&gt;startButtonIsStop)  {       SetControlTitle(inWindData-&gt;startButton, &quot;\pStop&quot;);       inWindData-&gt;startButtonIsStop = true;     }  }}// ---------------------------------------------------------------------------//    GetDataRateString// ---------------------------------------------------------------------------static OSErr GetDataRateString(UInt32 inDataRate, unsigned char *outString){  Fixed    adjRate;  OSErr    err = noErr;  char    tempString[256];#define kKiloBitsPerSecCutoffRate    (1024 * 2)#define kKiloBitsPerSecFixedDivisor    (1024 &lt;&lt; 16)#define kMegaBitsPerSecCutoffRate    (1024*1024)#define kMegaBitsPerSecFirstDivisor    (1024)#define kMegaBitsPerSecSecondDivisor  (1024)#define kMegaBitsPerSecSecondFixedDivisor  (kMegaBitsPerSecSecondDivisor &lt;&lt; 16)  tempString[0] = 0;  if (inDataRate &lt; kKiloBitsPerSecCutoffRate)  {    sprintf(tempString, &quot;%ld bits/sec&quot;, inDataRate);  }  else if (inDataRate &lt; kMegaBitsPerSecCutoffRate)  {    float    a;    a = (float)inDataRate / 1024;    sprintf(tempString, &quot;%.1f kbits/sec&quot;, a);  }  else  {    inDataRate = inDataRate / kMegaBitsPerSecFirstDivisor;    adjRate = FixDiv((Fixed)(inDataRate&lt;&lt;16), kMegaBitsPerSecSecondFixedDivisor);    sprintf(tempString, &quot;%.1f Mbits/sec&quot;, Fix2X(adjRate));  }  CopyCToPStr(tempString, outString);  return err;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/usher/listing20.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/usher/listing20.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/usher/listing20.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>