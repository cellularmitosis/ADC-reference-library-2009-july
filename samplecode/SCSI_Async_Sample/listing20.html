<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SCSI Async Sample - /Src/SCSIAsyncSampleMain.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">SCSI Async Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/idxSCSI-date.html" target="_blank">Hardware & Drivers > SCSI</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SCSI Async Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Src/SCSIAsyncSampleMain.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Src/AsyncSCSIPresent.c</option>
<option value="listing2.html">/Src/ContinueTesting.c</option>
<option value="listing3.html">/Src/DialogUtilities.c</option>
<option value="listing4.html">/Src/DialogUtilities.h</option>
<option value="listing5.html">/Src/DisplayTestParameters.c</option>
<option value="listing6.html">/Src/DisplayTestResults.c</option>
<option value="listing7.html">/Src/DoSCSISynchronousIO.c</option>
<option value="listing8.html">/Src/GetDevicesToTest.c</option>
<option value="listing9.html">/Src/GetSCSICDBLength.c</option>
<option value="listing10.html">/Src/LogManager.c</option>
<option value="listing11.html">/Src/LogManager.h</option>
<option value="listing12.html">/Src/MicrosecondDelta.c</option>
<option value="listing13.html">/Src/MicrosecondTrap.h</option>
<option value="listing14.html">/Src/MicrosecondTrapPresent.c</option>
<option value="listing15.html">/Src/NewSCSIManagerPresent.c</option>
<option value="listing16.html">/Src/NumericFilter.c</option>
<option value="listing17.html">/Src/scsi.h</option>
<option value="listing18.html">/Src/SCSIAsyncSample.h</option>
<option value="listing19.html">/Src/SCSIAsyncSample.r</option>
<option value="listing20.html">/Src/SCSIAsyncSampleMain.c</option>
<option value="listing21.html">/Src/SCSIBusInquiry.c</option>
<option value="listing22.html">/Src/SCSIDefinitions.h</option>
<option value="listing23.html">/Src/SpinCursor.c</option>
<option value="listing24.html">/Src/StringFormat.c</option>
<option value="listing25.html">/Src/WindowUtilities.c</option></select>
				</p>
				</form>
				<p><strong><a href="SCSI_Async_Sample.zip">Download Sample</a></strong> (&#147;SCSI_Async_Sample.zip&#148;, 105.5K)<BR>
<strong><a href="SCSI_Async_Sample.dmg">Download Sample</a></strong> (&#147;SCSI_Async_Sample.dmg&#148;, 169.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*                ScsiSimpleSample.c                *//* * ScsiSimpleSample.c * Copyright &copy; 1992-93 Apple Computer Inc. All Rights Reserved. * * Edit history: *  1.0    MM    First release *  1.0.1  MM    Added dialog for timeout and explicit display of &quot;asych&quot; *          No substantative changes. *  1.0.2  MM    Removed references to the message byte field as it is *          no longer returned by the asynchronous SCSI Manager. */#define EXTERN#include  &quot;SCSIAsyncSample.h&quot;#include  &lt;Packages.h&gt;#include  &lt;Desk.h&gt;#include  &lt;OSEvents.h&gt;#include  &lt;GestaltEqu.h&gt;#include  &lt;Errors.h&gt;#pragma segment MainCodevoid                main(void);void                EventLoop(void);void                DoMouseEvent(void);void                DoContentClick(    WindowPtr            theWindow  );void                DoCommand(    WindowPtr            theWindow,    long              menuChoice  );void                DoWindowKeyDown(    WindowPtr            theWindow  );void                SetupEverything(void);void                AdjustMenus(void);void                AdjustEditMenu(    Boolean              isDeskAccessory  );void                SetupMenus(void);void                BuildWindow(void);void                DecorateDisplay(    WindowPtr            theWindow,    Boolean              redraw  );void                DrawWindow(    WindowPtr            theWindow  );void                DoAbout(void);void                DoPageSetup(void);void                HexToString(    unsigned long          value,    short              hexDigits,    Str255              result  );Boolean                HexToNum(    ConstStr255Param        hexString,    unsigned long          *result  );void                SetupAnimatedCursor(    short              acurResID  );void                SpinCursor(void);Boolean                IsVirtualMemoryRunning(void);#define IsOurWindow(theWindow)  ((theWindow) == gMainWindow)voidmain(void){    void            *vmStackTop;    short            i;        SetupEverything();    if (AsyncSCSIPresent() == FALSE     || GetHostBusCount(&amp;gMaxHostBus) != noErr) {       InitCursor();      StopAlert(ALRT_NoNewSCSI, NULL);      ExitToShell();    }    else if (MicrosecondTrapPresent() == FALSE)      FatalError(unimpErr, &quot;\pNo timer support&quot;);    else {      GetDevicesToTest();      BuildWindow();      DisplayTestParameters();      SetupAnimatedCursor(ACUR_Animator);      if (gVirtualMemoryEnabled) {        gVMHoldRecord[kVMFunction].ptr = (void *) VMStartMarker;        gVMHoldRecord[kVMFunction].size =           ((unsigned long) VMEndMarker) - ((unsigned long) VMStartMarker);        gVMHoldRecord[kVMStack].ptr = (void *) &amp;vmStackTop;        gVMHoldRecord[kVMStack].size = kVMStackSize;        for (i = kVMFunction; i &lt;= kVMStack; i++) {          if (HoldMemory(gVMHoldRecord[i].ptr, gVMHoldRecord[i].size) != noErr)            gVMHoldRecord[i].ptr = NULL;        }      }      while (gQuitNow == FALSE) {        EventLoop();      }    }    /* KillActiveDevices */    for (i = kVMFunction; i &lt;= kVMStack; i++) {      if (gVMHoldRecord[i].ptr != NULL)        UnholdMemory(gVMHoldRecord[i].ptr, gVMHoldRecord[i].size);    }    /* Release memory */    ExitToShell();}voidBuildWindow(){    short          fontSize;    short          fontNumber;    Rect          viewRect;        fontSize = 10;    GetFNum(&quot;\pCourier&quot;, &amp;fontNumber);    if (RealFont(fontNumber, fontSize) == FALSE)      fontNumber = applFont;    viewRect = qd.screenBits.bounds;    viewRect.top += (GetMBarHeight() * 2);    viewRect.bottom -= 4;    viewRect.left += 4;    viewRect.right = (width(viewRect) / 2);    gMainWindow = NewWindow(            NULL,            &amp;viewRect,            &quot;\pSCSI Simple Sample&quot;,            TRUE,            zoomDocProc,            (WindowPtr) -1L,            TRUE,        /* Has GoAway box    */            0          /* No refCon      */          );    if (gMainWindow == NULL) {      SysBeep(10);      ExitToShell();    }    SetPort(gMainWindow);    viewRect = gMainWindow-&gt;portRect;    viewRect.right -= kScrollBarOffset;    viewRect.bottom -= kScrollBarOffset;    gLogListHandle = CreateLog(          &amp;viewRect,          fontNumber,          fontSize,          kLogLines        );    if (gLogListHandle == NULL) {      SysBeep(10);      ExitToShell();    }}voidEventLoop(void){    long              menuChoice;    register WindowPtr        theWindow;    GrafPtr              savePort;    Boolean              isActivating;    static Boolean          testingStarted = FALSE;        if (gUpdateMenusNeeded) {      gUpdateMenusNeeded = FALSE;      AdjustMenus();    }    WaitNextEvent(      everyEvent,      &amp;EVENT,      (gInForeground) ? 10L : 60L,      NULL    );    theWindow = FrontWindow();    switch (EVENT.what) {    case nullEvent:      break;    case keyDown:    case autoKey:      if ((EVENT.message &amp; charCodeMask) == '.'       &amp;&amp; (EVENT.modifiers &amp; cmdKey) != 0) {        FlushEvents(keyDown | autoKey, 0);        gStopNow = TRUE;      }      else if ((EVENT.modifiers &amp; cmdKey) != 0) {        if (EVENT.what == keyDown) {          menuChoice = MenuKey(EVENT.message &amp; charCodeMask);          if (HiWord(menuChoice) != 0)            DoCommand(theWindow, menuChoice);          else if (IsOurWindow(theWindow)) {            DoWindowKeyDown(theWindow);          }        }      }      else if (IsOurWindow(theWindow)) {        DoWindowKeyDown(theWindow);      }      break;    case mouseDown:      DoMouseEvent();      break;    case updateEvt:      theWindow = (WindowPtr) EVENT.message;      GetPort(&amp;savePort);      SetPort(theWindow);      BeginUpdate(theWindow);      EraseRect(&amp;theWindow-&gt;portRect);      DrawControls(theWindow);      DrawGrowIcon(theWindow);      if (IsOurWindow(theWindow))        DrawWindow(theWindow);      EndUpdate(theWindow);      SetPort(savePort);      break;    case activateEvt:      theWindow = (WindowPtr) EVENT.message;      isActivating = ((EVENT.modifiers &amp; activeFlag) != 0);      goto activateEvent;      break;    case osEvt:      switch (((unsigned long) EVENT.message) &gt;&gt; 24) {      case mouseMovedMessage:        break;      case suspendResumeMessage:        isActivating = ((EVENT.message &amp; 0x01) != 0);activateEvent:    if (isActivating) {          /*           * Activate this window. Activate events define theWindow           * from the event record, while suspend/resume uses the           * pre-set FrontWindow value.           */          SelectWindow(theWindow);          (void) TEFromScrap();        }        if (IsOurWindow(theWindow) &amp;&amp; gLogListHandle != NULL)          LActivate(isActivating, gLogListHandle);        else {          /* Desk accessory or what? */        }        gInForeground = isActivating;        gUpdateMenusNeeded = TRUE;        break;      }      break;    }    if (gStopNow == FALSE &amp;&amp; gQuitNow == FALSE) {      SpinCursor();      if (testingStarted)        ContinueTesting();      else {        testingStarted = TRUE;        StartTesting();      }    }}/* * DoMouseEvent * The user clicked on something. Handle application-wide processing here, or call * a Catalog Browser function for specific action. */voidDoMouseEvent(void){    WindowPtr    theWindow;    short      whichPart;        whichPart = FindWindow(EVENT.where, &amp;theWindow);    if (theWindow == NULL)      theWindow = FrontWindow();    if (whichPart == inMenuBar &amp;&amp; IsOurWindow(theWindow) == FALSE)      theWindow = FrontWindow();    switch (whichPart) {    case inDesk:      break;    case inMenuBar:      InitCursor();      DoCommand(theWindow, MenuSelect(EVENT.where));      break;    case inDrag:      DragWindow(theWindow, EVENT.where, &amp;qd.screenBits.bounds);      break;    case inGoAway:      if (TrackGoAway(theWindow, EVENT.where)) {        if (IsOurWindow(theWindow)) {          /*           * Not quite so simple: we need to handle open files, too.           */          gQuitNow = TRUE;        }      }      break;    case inZoomIn:    case inZoomOut:      if (IsOurWindow(theWindow)       &amp;&amp; TrackBox(theWindow, EVENT.where, whichPart)) {        DoZoomWindow(theWindow, whichPart);        goto resizeWindow;      }      break;    case inGrow:      if (IsOurWindow(theWindow)) {        if (DoGrowWindow(              theWindow,              EVENT.where,              kMinWindowWidth,              kMinWindowHeight            )) {resizeWindow:    DecorateDisplay(theWindow, TRUE);        }      }      break;    case inContent:      if (theWindow != FrontWindow())        SelectWindow(theWindow);      else if (IsOurWindow(theWindow)) {        DoContentClick(theWindow);      }      else {        /* Nothing happens here    */      }      break;    default:      break;            /* Might be for the SDP Panel  */    }    /*     * Do not touch theWindow here.     */}voidDoContentClick(    WindowPtr        theWindow  ){    if (0) {      theWindow;    }    DoClickInLog(gLogListHandle, &amp;EVENT);    /*     * More to follow.     */}voidDoWindowKeyDown(    WindowPtr            theWindow  ){    if (0) {      theWindow;    }    /* Nothing happens here */}voidDrawWindow(    WindowPtr            theWindow  ){    if (0) {      theWindow;    }    UpdateLog(gLogListHandle);}voidDecorateDisplay(    WindowPtr            theWindow,    Boolean              redraw  ){    Rect              viewRect;        if (0) {      redraw;    }    viewRect = theWindow-&gt;portRect;    viewRect.right -= kScrollBarOffset;    viewRect.bottom -= kScrollBarOffset;    if (gLogListHandle != NULL) {      MoveLog(gLogListHandle, viewRect.left, viewRect.top);      SizeLog(gLogListHandle, width(viewRect), height(viewRect));    }}voidDoCommand(    WindowPtr            theWindow,    long              menuChoice  ){    short              menuItem;    Str255              menuText;    GrafPtr              savePort;    OSErr              status;    menuItem = LoWord(menuChoice);    switch (HiWord(menuChoice)) {    case MENU_Apple:      if (menuItem == kAppleAbout)        DoAbout();      else {        GetItem(gAppleMenu, menuItem, menuText);        AdjustEditMenu(TRUE);        GetPort(&amp;savePort);        OpenDeskAcc(menuText);        SetPort(savePort);        AdjustEditMenu(IsOurWindow(theWindow) == FALSE);      }      break;    case MENU_File:      switch (menuItem) {      case kFileCreateLogFile:        status = SaveLogFile(              gLogListHandle,              &quot;\pSave Log&quot;,              &quot;\pSCSI Test Log&quot;,              'ttxt'            );        break;      case kFileCloseLogFile:        status = CloseLogFile(gLogListHandle);        break;      case kFilePageSetup:        DoPageSetup();        break;      case kFilePrint:        PrintLog(gLogListHandle, gPrintHandle);        break;      case kFileDebug:        Debugger();        break;      case kFileQuit:        gQuitNow = TRUE;        break;      }      break;    }    HiliteMenu(0);}voidSetupEverything(){    int          i;        MaxApplZone();    InitGraf(&amp;qd.thePort);    InitFonts();    InitWindows();    InitMenus();    TEInit();    InitDialogs(0);    for (i = 0; i &lt; 8; i++)      MoreMasters();    HNoPurge((Handle) GetCursor(watchCursor));    SetCursor(*GetCursor(watchCursor));    SetupMenus();    gVirtualMemoryEnabled = IsVirtualMemoryRunning();}voidSetupMenus(){    register Handle    menuBarHdl;    /*     * We ought to do some error checking here.     */    menuBarHdl = GetNewMBar(MBAR_MenuBar);    SetMenuBar(menuBarHdl);    gAppleMenu = GetMHandle(MENU_Apple);    AddResMenu(gAppleMenu, 'DRVR');    gFileMenu = GetMHandle(MENU_File);    gEditMenu = GetMHandle(MENU_Edit);    DrawMenuBar();    gUpdateMenusNeeded = TRUE;}voidAdjustMenus(void){    EnableItem(gFileMenu, kFileQuit);    EnableItem(gFileMenu, kFileDebug);    if (IsOurWindow(FrontWindow())) {      EnableItem(gFileMenu, kFilePageSetup);      EnableItem(gFileMenu, kFilePrint);      if (HasLogFile(gLogListHandle)) {        EnableItem(gFileMenu, kFileCloseLogFile);        DisableItem(gFileMenu, kFileCreateLogFile);      }      else {        EnableItem(gFileMenu, kFileCreateLogFile);        DisableItem(gFileMenu, kFileCloseLogFile);      }    }    AdjustEditMenu(IsOurWindow(FrontWindow()) == FALSE);}/* * AdjustEditMenu * Enable/disable Edit Menu options. */voidAdjustEditMenu(    Boolean        isDeskAcc  ){    if (isDeskAcc) {      EnableItem(gEditMenu, kEditUndo);      EnableItem(gEditMenu, kEditCut);      EnableItem(gEditMenu, kEditCopy);      EnableItem(gEditMenu, kEditPaste);      EnableItem(gEditMenu, kEditClear);    }    else {      DisableItem(gEditMenu, kEditUndo);      DisableItem(gEditMenu, kEditCut);      DisableItem(gEditMenu, kEditCopy);      DisableItem(gEditMenu, kEditPaste);      DisableItem(gEditMenu, kEditClear);    }}voidDoAbout(){    GrafPtr              savePort;    DialogPtr            dialog;    short              item;        GetPort(&amp;savePort);    dialog = GetNewDialog(DLOG_About, NULL, (WindowPtr) -1L);    ShowWindow(dialog);    SetPort(dialog);    ModalDialog(NULL, &amp;item);    DisposDialog(dialog);    SetPort(savePort);}voidHexToString(    unsigned long          value,    short              hexDigits,    Str255              result  ){    register unsigned short      digit;    register char          *text;        text = (char *) result;    text[0] = hexDigits;    for (; hexDigits &gt; 0; --hexDigits) {      digit = value &amp; 0xF;      if (digit &gt;= 10)        text[hexDigits] = digit - 10 + 'a';      else {        text[hexDigits] = digit + '0';      }      value &gt;&gt;= 4;    }}BooleanHexToNum(    ConstStr255Param        hexString,    unsigned long          *result  ){    register short          i;    register unsigned short      digit;        *result = 0;    for (i = 1; i &lt;= hexString[0]; i++) {      digit = hexString[i];      if (digit &gt;= '0' &amp;&amp; digit &lt;= '9')        digit -= '0';      else if (digit &gt;= 'a' &amp;&amp; digit &lt;= 'f')        digit = digit - 'a' + 10;      else if (digit &gt;= 'A' &amp;&amp; digit &lt;= 'F')        digit = digit - 'A' + 10;      else {        return (FALSE);      }      *result &lt;&lt;= 4;      *result |= digit;    }    return (TRUE);}voidDoPageSetup(void){    PrOpen();    if (PrError() == noErr) {      if (gPrintHandle == NULL) {        gPrintHandle = (THPrint) NewHandle(sizeof (TPrint));        if (gPrintHandle != NULL)          PrintDefault(gPrintHandle);      }      if (gPrintHandle != NULL)        (void) PrStlDialog(gPrintHandle);      PrClose();    }}voidNonFatalError(    OSErr          errorStatus,    ConstStr255Param    errorMsg  ){    Handle          errorTextHdl;    StringPtr        errorTextPtr;    Str15          errorStatusText;    short          userChoice;        NumToString(errorStatus, errorStatusText);    errorTextHdl = GetResource('Estr', errorStatus);    if (errorTextHdl != NULL) {      HLock(errorTextHdl);      errorTextPtr = (StringPtr) *errorTextHdl;    }    else {      errorTextPtr = &quot;\pSystem Error&quot;;    }    ParamText(errorStatusText, errorTextPtr, errorMsg, &quot;\p&quot;);    userChoice = StopAlert(ALRT_NonFatalError, NULL);    if (userChoice == 1)      ExitToShell();}voidFatalError(    OSErr        errorStatus,    ConstStr255Param  errorMsg  ){    Handle        errorTextHdl;    StringPtr      errorTextPtr;    Str15        errorStatusText;        NumToString(errorStatus, errorStatusText);    errorTextHdl = GetResource('Estr', errorStatus);    if (errorTextHdl != NULL) {      HLock(errorTextHdl);      errorTextPtr = (StringPtr) *errorTextHdl;    }    else {      errorTextPtr = &quot;\pSystem Error&quot;;    }    ParamText(errorStatusText, errorTextPtr, errorMsg, &quot;\p&quot;);    StopAlert(ALRT_FatalError, NULL);    ExitToShell();}BooleanIsVirtualMemoryRunning(void){    OSErr            status;    long            response;        status = Gestalt(gestaltVMAttr, &amp;response);    /*     * VM is active iff Gestalt succeeded and the response is appropriate.     */    return (status == noErr &amp;&amp; ((response &amp; (1 &lt;&lt; gestaltVMPresent)) != 0));}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SCSI_Async_Sample/listing20.html%3Fid%3DDTS10000022-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SCSI_Async_Sample/listing20.html%3Fid%3DDTS10000022-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SCSI_Async_Sample/listing20.html%3Fid%3DDTS10000022-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>