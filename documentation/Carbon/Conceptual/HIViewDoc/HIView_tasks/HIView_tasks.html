<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>HIView Programming Guide: HIView Tasks</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="HIView Tasks"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000923-CH205" title="HIView Tasks"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../UserExperience-date.html#//apple_ref/doc/uid/TP30000440-TP30000420-TP30000465" target="_top">User Experience</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP30000923-CH207-DontLinkElementID_24">HIView Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../HIView_concept/HIView_concept.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../HIView_apdx_a_history/HIView_apdx_a_history.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000923-CH205-SW1" title="HIView Tasks"></a><h1><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF101" title="HIView Tasks"></a>HIView Tasks</h1><p>This chapter contains instructions and sample code for implementing common tasks involving HIView, such as creating and embedding views, automating view layout, drawing in views, and implementing some new view-based controls. It also contains information about subclassing views to create your own custom user interface elements. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF102">Enabling Compositing in Windows</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF103">Creating a View</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-BAJDBFGE">Embedding Views</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF104">Positioning Views</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-BAJEFBGC">Automating View Layout</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-BAJGJCBF">Ordering Views</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF105">HIView Visibility</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF106">Changing Keyboard Focus</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF107">Translating Coordinates</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF108">Drawing in Views</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-BAJIDJDH">Manipulating Menu Views</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF109">Creating a Scroll View</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF115">Creating a Combo Box</a>
				
			<br/>
			
        
			
			
				<a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-CJBCFJCE">Creating Custom Views</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF102" title="Enabling Compositing in Windows"></a><h2>Enabling Compositing in Windows</h2><p>Windows that use HIView must have compositing turned on. Compositing means that HIView draws window content view by view, from back to front, allowing each view to draw only the portions of itself that are visible. That is, you don’t have to worry about inefficient drawing resulting from drawing on top of existing pixels. </p><p>Turn on compositing by setting the compositing window attribute. You can do so in the Info window in Interface Builder or by adding <code>kWindowCompositingAttribute</code> to the attribute list when you call <code>CreateNewWindow</code>. Note that older window creation functions don’t allow compositing. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_9" title="Important:"></a><p><strong>Important:</strong>&nbsp;You must set the compositing attribute when you create the window; you cannot set the attribute later by calling <code>ChangeWindowAttributes</code>.</p><p></p></div><p>Unless you really need specialized event handling, you should also specify using the standard window event handler when creating windows for HIView. </p><p>If you are porting older control code to HIView, you should know that once compositing is on, your code must accommodate these changes:</p><ul class="ul"><li class="li"><p>You should replace any calls that draw directly to the screen (<code>DrawControls</code>, <code>Draw1Control</code>) with the appropriate HIView invalidation call (<code>HIViewSetNeedsDisplay</code>).</p></li><li class="li"><p>You no longer need to erase behind controls, as the compositor keeps track of the background layers and can redraw them as necessary. </p></li></ul><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF103" title="Creating a View"></a><h2>Creating a View</h2><p>Creating views is straightforward. If your view is an older control, just use the Control Manager creation function (for example, <code>CreateCheckBoxControl</code>). For new views, use the appropriate HIView creation function shown in <span class="content_text">Table 2-1</span>.</p><a name="//apple_ref/doc/uid/TP30000923-CH205-BAJJAGGI" title="Table 2-1New view creation functions"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>New view creation functions</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>View</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function</p></th></tr><tr><td  scope="row"><p>Combo box</p></td><td ><p><code>HIComboBoxCreate</code></p></td></tr><tr><td  scope="row"><p>Image view</p></td><td ><p><code>HIImageViewCreate</code></p></td></tr><tr><td  scope="row"><p>Scroll view</p></td><td ><p><code>HIScrollViewCreate</code></p></td></tr><tr><td  scope="row"><p>Segmented View</p></td><td ><p><code>HISegmentedViewCreate</code></p></td></tr><tr><td  scope="row"><p>Search field</p></td><td ><p><code>HISearchFieldCreate</code></p></td></tr><tr><td  scope="row"><p>Text view</p></td><td ><p><code>HITextViewCreate</code></p></td></tr><tr><td  scope="row"><p>Web view</p></td><td ><p><code>HIWebViewCreate</code></p></td></tr><tr><td  scope="row"><p>HICocoaView</p></td><td ><p><code>HICocoaViewCreate</code></p></td></tr></table></div><p>Menus in Mac OS X v10.3 and later are automatically implemented as views, so you do not need to change your code to adopt view-based menus. </p><p>Note that when initially created, the new HIView views are not associated with a window, and some do not even have a physical size. To give the view physical dimensions, you must embed the view within a parent and then set its size and position by calling the function <code>HIViewSetFrame</code> or <code>HIViewPlaceInSuperviewAt</code>.</p><p>You can pass <code>NULL</code> for the window reference when calling older control creation functions if you want to create a control that is not initially associated with a window. </p><p>Views are invisible when first created. To make them visible, call <code>HIViewSetVisible</code> or the Control Manager function <code>ShowControl</code>. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-BAJDBFGE" title="Embedding Views"></a><h2>Embedding Views</h2><p>The HIView API provides a number of functions to add or remove views from a view hierarchy: </p><ul class="ul"><li class="li"><p>To embed a view within another view, call the <code>HIViewAddSubview</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewAddSubview (HIViewRef inParent, HIViewRef inChild);<span></span></pre></td></tr></table></div><p>Note that this function merely adds the view to the hierarchy; it does not physically place the view within its parent. To position the view, you should call the <code>HIViewSetFrame</code> function or <code>HIViewPlaceInSuperviewAt</code>. </p></li><li class="li"><p>To remove a view from its parent, call the <code>HIViewRemoveFromSuperview</code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewRemoveFromSuperview (HIViewRef inView);<span></span></pre></td></tr></table></div></li><li class="li"><p>To determine the parent of a view, call the <code>HIViewGetSuperview</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>HIViewRef HIViewGetSuperview (HIViewRef inView);<span></span></pre></td></tr></table></div></li><li class="li"><p>To obtain the root view for a window, call the <code>HIViewGetRoot</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>HIViewRef HIViewGetRoot (WindowRef inWindow);<span></span></pre></td></tr></table></div></li></ul><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF104" title="Positioning Views"></a><h2>Positioning Views</h2><p>You use the following functions to set or obtain the position of a view within its parent: </p><ul class="ul"><li class="li"><p>To obtain the local bounds of a view, call the <code>HIViewGetBounds</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewGetBounds (HIViewRef inView, HIRect *outRect);<span></span></pre></td></tr></table></div></li><li class="li"><p>To obtain the frame bounds of a view, call the <code>HIViewGetFrame</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewGetFrame (HIViewRef inView, HIRect *outRect);<span></span></pre></td></tr></table></div><p>This function is analogous to the older <code>GetControlBounds</code> function except that the coordinates are referenced to the view’s parent, not the window’s content region. </p></li><li class="li"><p>To set the frame bounds of a view, call the <code>HIViewSetFrame</code> function.</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewSetFrame (HIViewRef inView, const HIRect *inRect);<span></span></pre></td></tr></table></div><p>This function effectively moves the view within its parent. It also marks the view (as well anything that may have been exposed behind it) to be redrawn. </p></li><li class="li"><p>To move a view a certain amount within its parent, call the <code>HIViewMoveBy</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewMoveBy (HIViewRef inView, float inDX, float inDY);<span></span></pre></td></tr></table></div></li><li class="li"><p>To place a view at a certain point within its parent, call the <code>HIViewPlaceInSuperviewAt</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewPlaceInSuperviewAt (HIViewRef inView,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    float inX, float inY);<span></span></pre></td></tr></table></div></li></ul><a name="//apple_ref/doc/uid/TP30000923-CH205-BAJEFBGC" title="Automating View Layout"></a><h2>Automating View Layout</h2><p>In Mac OS X v10.3 and later, you can use special layout functions to bind the size or position of one view to another view. For example, the layout APIs make it easy to do any of the following:</p><ul class="ul"><li class="li"><p>Center views either horizontally or vertically (or both) in a window. </p></li><li class="li"><p>Specify that an OK button always keep its proper pixel distance from the bottom right corner of the window (as per the Aqua guidelines) even if the window is resized. </p></li><li class="li"><p>Create group boxes that automatically resize proportionally as the content view bounds change. </p></li></ul><p>You can specify the following different layout options:</p><ul class="ul"><li class="li"><p><em>Bind</em> a view so that it maintains its relative position to one or more edges of another view. For example, if you bind a button to the top edge of a group box, the button maintains its relative position to that edge if the group box moves. (Note, however, that you can move the button’s top edge independent of the group box.) See <span class="content_text"><a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF119">“The HIBinding Structure”</a></span> for more details. </p></li><li class="li"><p><em>Position</em> a view so that it is always aligned to the specified edge (or the center) of another view. For example, if you align a button’s top edge to the top edge of a group box, those edges will always share the same y-coordinate. You can also specify an alignment offset if desired. See <span class="content_text"><a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF121">“The HIPositioning Structure”</a></span> for more details. </p></li><li class="li"><p><em>Scale</em> a view so that it maintains a particular size ratio with another view. For example, you can specify that a group box’s width is always half that of the content view that contains it. See <span class="content_text"><a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF120">“The HIScaling Structure”</a></span> for more details. </p></li></ul><p>Note that these layout constraints are "one-way"; for example, if button A is constrained to scale as the size of button B changes, that doesn’t mean that button B will scale when button A changes size. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_10" title="Important:"></a><p><strong>Important:</strong>&nbsp;Due to the flexibility of these layout constraints, it is possible to specify circular relationships that can hang your application. For example, you can use the layout APIs to set view A to be twice the size of view B and simultaneously set view B to be twice the size of view A. Your application is responsible for avoiding such circular relationships. </p><p></p></div><p>You specify a view’s layout relationships by setting its <code>HILayoutInfo</code> structure:</p><div class="codesample"><table><tr><td scope="row"><pre>struct HILayoutInfo {<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 version;<span></span></pre></td></tr><tr><td scope="row"><pre>    HIBinding binding;<span></span></pre></td></tr><tr><td scope="row"><pre>    HIScaling scale;<span></span></pre></td></tr><tr><td scope="row"><pre>    HIPositioning position;<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr></table></div><p>The <code>version</code> field simply indicates the version of this data structure (in case it changes in the future); set this field to <code>kHILayoutInfoVersionZero</code>.</p><p>The <code>binding</code>, <code>scale</code>, and <code>position</code> fields each point to additional structures that indicate the specific layout constraints for this view. </p><p>You can use the view layout APIs to specify layout relationships between any two views (siblings, parents, and so on). The layouts are applied in the following order: binding, scaling, then positioning. Note that some layout information when applied may override previous constraints. For example, positioning constraints may override the bindings set in the <code>HIBinding</code> structure. </p><ul class="ul"><li class="li"><p>To set layout constraints, you must first call the <code>HIViewGetLayoutInfo</code> function to obtain the layout structure:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewGetLayoutInfo (HIViewRef inView,<span></span></pre></td></tr><tr><td scope="row"><pre>                                HILayoutInfo *outLayoutInfo);<span></span></pre></td></tr></table></div><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_11" title="Important:"></a><p><strong>Important:</strong>&nbsp;Before calling <code>HIViewGetLayoutInfo</code>, you must set the version field of the <code>HILayoutInfo</code> structure. Doing so ensures that you will always receive a structure whose contents are compatible with your code. Currently the only value you can supply is <code>kHILayoutInfoVersionZero</code>.</p><p></p></div><p>Then you can modify the fields of the structure to specify the layout constraints you want. </p></li><li class="li"><p>To set the layout relationships for a view, you use the <code>HIViewSetLayoutInfo</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewSetLayoutInfo (HIViewRef inView,<span></span></pre></td></tr><tr><td scope="row"><pre>                                const HILayoutInfo *inLayoutInfo);<span></span></pre></td></tr></table></div></li><li class="li"><p>If you set a layout that constrains view A to view B, the layouts do not get implemented until either view B moves or resizes, or you call the <code>HIViewApplyLayout</code> function on view A:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewApplyLayout (HIViewRef inView);<span></span></pre></td></tr></table></div></li><li class="li"><p>Layouts are active by default. To temporarily disable the layout constraints, call <code>HIViewSuspendLayout</code>. To resume the layout, call <code>HIViewResumeLayout</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewSuspendLayout (HIViewRef inView);<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus HIViewResumeLayout (HIView inView);<span></span></pre></td></tr></table></div></li><li class="li"><p>To determine if the layout is active or suspended, call the <code>HIViewIsLayoutActive</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>Boolean HIViewIsLayoutActive (HIViewRef inView);<span></span></pre></td></tr></table></div></li></ul><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF119" title="The HIBinding Structure"></a><h3>The HIBinding Structure</h3><p>The <code>HIBinding</code> structure specifies the layout bindings for all four sides of the view:</p><div class="codesample"><table><tr><td scope="row"><pre>struct HIBinding {<span></span></pre></td></tr><tr><td scope="row"><pre>    HISideBinding top;<span></span></pre></td></tr><tr><td scope="row"><pre>    HISideBinding left;<span></span></pre></td></tr><tr><td scope="row"><pre>    HISideBinding right;<span></span></pre></td></tr><tr><td scope="row"><pre>    HISideBinding bottom;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>The <code>HISideBinding</code> structure indicates the binding constraints for a specific side:</p><div class="codesample"><table><tr><td scope="row"><pre>struct HISideBinding {<span></span></pre></td></tr><tr><td scope="row"><pre>    HIViewRef toView;<span></span></pre></td></tr><tr><td scope="row"><pre>    HIBindingKind kind;<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr></table></div><p>The <code>toView</code> field indicates the view you want to bind to. The kind field specifies the side of the <code>inView</code> view to bind to. You can pass any of the following constants in the kind field: <code>kHILayoutBindLeft</code>, <code>kHILayoutBindRight</code>, <code>kHILayoutBindTop</code>, <code>kHILayoutBindBottom</code>. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_12" title="Note"></a><p><strong>Note:</strong>&nbsp;The specified layout constants are actually abstracted from constants that assume axis information: <code>kHILayoutBindRight</code> and <code>kHILayoutBindBottom</code> map to <code>kHILayoutBindMax</code> and <code>kHILayoutBindLeft</code> and <code>kHILayoutBindTop</code> map to <code>kHILayoutBindMin</code>. Therefore, specifying seemingly nonsensical bindings is still valid. For example, if you attempt to bind the top of a view to another view using <code>kHILayoutBindLeft</code>, you are actually specifying <code>kHILayoutBindMin</code>, meaning, that the top of your view binds to the minimum y-axis value (that is, the top edge) of the specified view. </p></div><p>For example, say you bind the top edge of view A to the top edge of view B as in <span class="content_text">Figure 2-1</span>. </p><p>You can move view A as you please, as binding seeks to preserve only the relative positioning between view A and B. </p><p>If view B moves (or resizes), view A must also move (or resize) to preserve the specified binding. In this case, that means to maintain the vertical distance between the top edges of view A and view B.</p><br/><div><a name="//apple_ref/doc/uid/TP30000923-CH205-CJBEDGBG" title="Figure 2-1A binding example"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>A binding example</p><img src = "../art/binding.gif" alt = "A binding example" width="261" height="296"></div><br/><p>You can bind all four edges of your view if you desire. Note that your view’s bounds may change if that is required to maintain the specified bindings. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF121" title="The HIPositioning Structure"></a><h3>The HIPositioning Structure</h3><p>The <code>HIPosition</code> structure specifies the position constraints for the view’s axes:</p><div class="codesample"><table><tr><td scope="row"><pre>struct HIPositioning {<span></span></pre></td></tr><tr><td scope="row"><pre>    HIAxisPosition x;<span></span></pre></td></tr><tr><td scope="row"><pre>    HIAxisPosition y;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>The <code>HIAxisPosition</code> structure contains the specific positioning constraints for each axis:</p><div class="codesample"><table><tr><td scope="row"><pre>struct HIAxisPosition {<span></span></pre></td></tr><tr><td scope="row"><pre>    HIViewRef toView;<span></span></pre></td></tr><tr><td scope="row"><pre>    HIPositionKind kind;<span></span></pre></td></tr><tr><td scope="row"><pre>    float offset;<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr></table></div><p>The <code>toView</code> field indicates the view that constrains your view. The kind field indicates along which line or side the two views are aligned. You can pass <code>kHILayoutPositionCenter</code>, <code>kHILayoutPositionLeft</code>, <code>kHILayoutPositionRight</code>, <code>kHILayoutPositionTop</code>, or <code>kHILayoutPositionBottom</code>. The offset field indicates any optional offset to include between <code>toView</code> and your view.</p><p>For example, say you position the y axis of view A to match the top edge of view B (that is, <code>positionKind</code> = <code>kHILayoutPositionTop</code>, <code>offset</code> = 0), as in <span class="content_text">Figure 2-2</span>.</p><p>View A cannot move up or down, as it is position-constrained to match the top edge of view B. </p><p>If view B moves or resizes, view A must move or resize to match any change in view B’s y coordinate. </p><br/><div><a name="//apple_ref/doc/uid/TP30000923-CH205-CJBFGHDB" title="Figure 2-2A positioning example"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>A positioning example</p><img src = "../art/positioning.gif" alt = "A positioning example" width="261" height="252"></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_13" title="Note"></a><p><strong>Note:</strong>&nbsp;Technically, you can move view A freely even when position-constrained to view B. However, the moment view B moves or resizes, or if you call <code>HIViewApplyLayout</code> on view A, view A automatically snaps to the constrained position specified by view B. </p></div><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF120" title="The HIScaling Structure"></a><h3>The HIScaling Structure</h3><p>The <code>HIScaling</code> structure specifies the scaling constraints for both axes of the view:</p><div class="codesample"><table><tr><td scope="row"><pre>struct HIScaling {<span></span></pre></td></tr><tr><td scope="row"><pre>    HIAxisScale x;<span></span></pre></td></tr><tr><td scope="row"><pre>    HIAxisScale y;<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr></table></div><p>The <code>HIAxisScale</code> structure indicates the scaling constraints for a specific axis:</p><div class="codesample"><table><tr><td scope="row"><pre>struct HIAxisScale {<span></span></pre></td></tr><tr><td scope="row"><pre>    HIViewRef toView;<span></span></pre></td></tr><tr><td scope="row"><pre>    HIScaleKind kind;<span></span></pre></td></tr><tr><td scope="row"><pre>    float ratio;<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr></table></div><p>The <code>toView</code> field indicates the view that will dictate the axial size of your view. The kind field specifies the type of scaling; currently you must pass <code>kHILayoutScaleAbsolute</code>. The ratio field specifies the scale ratio to maintain between your view and the constraining view. For example, if you want your view to always be half the width of <code>toView</code>, set <code>ratio</code> to 0.5. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-BAJGJCBF" title="Ordering Views"></a><h2>Ordering Views</h2><p>You can also set and manipulate the ordering of subviews within a parent view. This process is similar to ordering (sometimes called z-ordering) windows within an application, with views layered from top to bottom. </p><ul class="ul"><li class="li"><p>To order a view in front of or behind a sibling view, call the <code>HIViewSetZOrder</code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewSetZOrder (HIViewRef inView, HIViewZOrderOp inOp,<span></span></pre></td></tr><tr><td scope="row"><pre>                            HIViewRef inOther);<span></span></pre></td></tr></table></div><p>The <code>inOp</code> parameter (possible values: <code>kHIViewZOrderAbove</code> or <code>kHIViewZOrderBelow</code>) determines the position of <code>inView</code> with respect to <code>inOther</code>. </p></li><li class="li"><p>To obtain the first (that is, topmost) subview in a parent view, call the <code>HIViewGetFirstSubview</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>HIViewRef HIViewGetFirstSubview (HIViewRef inParentView);<span></span></pre></td></tr></table></div></li><li class="li"><p>To obtain the last (bottommost) subview in a parent view, call the <code>HIViewGetLastSubview</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>HIViewRef HIViewGetLastSubview (HIViewRef inParentView);<span></span></pre></td></tr></table></div></li><li class="li"><p>To obtain the next view after a specified one, call the <code>HIViewGetNextView</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>HIViewRef HIViewGetNextView (HIViewRef inView);<span></span></pre></td></tr></table></div></li><li class="li"><p>To obtain the previous view before a specified one, call the <code>HIViewGetPreviousView</code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>HIViewRef HIViewGetPreviousView (HIViewRef inView);<span></span></pre></td></tr></table></div></li></ul><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF105" title="HIView Visibility"></a><h2>HIView Visibility</h2><p>Just like controls, you can set or test for the visibility of views. </p><ul class="ul"><li class="li"><p>To set the visibility of a view, call the <code>HIViewSetVisible</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewSetVisible (HIViewRef inView, Boolean inVisible);<span></span></pre></td></tr></table></div><p>This function is analogous to the older <code>SetControlVisibility</code> function. Hiding a view also hides any embedded subviews. </p></li><li class="li"><p>To determine whether a view is visible, call the <code>HIViewIsVisible</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>Boolean HIViewIsVisible (HIViewRef inView);<span></span></pre></td></tr></table></div></li></ul><p>Note that you can also use the Control Manager functions <code>SetControlVisibility</code> and <code>IsControlVisible</code> on views. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF106" title="Changing Keyboard Focus"></a><h2>Changing Keyboard Focus</h2><p>In Mac OS X v10.2 and later, most views can acquire keyboard focus. This feature allows a user to select a checkbox, enter text, or click a button entirely through the keyboard. The user presses the Tab key to advance the focus and Shift-Tab to move it backwards. Pressing the Space bar activates the view with focus.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_14" title="Note"></a><p><strong>Note:</strong>&nbsp;For menus, the user can also use the cursor (arrow) keys to switch focus between menus and menu items. </p></div><p>Your application should allow the user to advance focus and activate focused views. HIView provides several functions to change keyboard focus:</p><ul class="ul"><li class="li"><p>To advance the focus to the next appropriate view, call the <code>HIViewAdvanceFocus</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewAdvanceFocus (HIViewRef inRootForFocus,<span></span></pre></td></tr><tr><td scope="row"><pre>                                EventModifiers inModifiers);<span></span></pre></td></tr></table></div><p>You pass in the root of the subtree in which to confine the focus. That is, if you pass in a content view as the root, the focus is confined to the subviews within the content view. You must also pass in the event modifiers parameter of the keyboard event that resulted in the call to <code>HIViewAdvanceFocus</code>. </p><p><code>HIViewAdvanceFocus</code> sends a <code>kEventControlSetFocusPart</code> event whenever a view is requested to gain, advance, or lose keyboard focus. </p><p>Note that if your window uses the standard event handler, the basic focus-shifting work (acquiring the raw keyboard input, calling <code>HIViewAdvanceFocus</code> and so on) is handled for you, and the standard views support the <code>kEventControlSetFocusPart</code> event. However, if you are creating a custom view, you may need to handle the <code>kEventControlSetFocusPart</code> event yourself. </p><p>Menus and menu items automatically gain keyboard focus support, independent of any standard event handlers. </p></li><li class="li"><p><code>HIViewAdvanceFocus</code> uses its own algorithm to determine the next view to acquire focus, generally attempting to move the focus from left to right, top to bottom, taking groups of views into account. However, if you want to explicitly specify which view should follow a given view in the focus chain, call the <code>HIViewSetNextFocus</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewSetNextFocus (HIViewRef inView,<span></span></pre></td></tr><tr><td scope="row"><pre>                                HIViewRef inNextFocus);<span></span></pre></td></tr></table></div></li></ul><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF107" title="Translating Coordinates"></a><h2>Translating Coordinates</h2><p>Although HIView simplifies most operations by adopting a view-relative coordinate system, at times you may need to know the coordinates of a object relative to a different view. The HIView API provides several functions to simplify these translations:</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_15" title="Note"></a><p><strong>Note:</strong>&nbsp;These conversion functions assume that both views have a common parent (that is, they must both be associated with the same window).</p></div><ul class="ul"><li class="li"><p>To translate the coordinates of a point from one view to another, call the <code>HIViewConvertPoint</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewConvertPoint (HIPoint *inPoint, HIViewRef inSourceView,<span></span></pre></td></tr><tr><td scope="row"><pre>                                HIViewRef inDestView);<span></span></pre></td></tr></table></div></li><li class="li"><p>To translate an <code>HIRect</code> structure from one view to another, call the <code>HIViewConvertRect</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewConvertRect (HIRect *ioRect, HIViewRef inSourceView,<span></span></pre></td></tr><tr><td scope="row"><pre>                                HIViewRef inDestView);<span></span></pre></td></tr></table></div></li><li class="li"><p>To translate a region from one view to another, call the <code>HIViewConvertRegion</code> function: </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewConvertRegion (RgnHandle ioRgn, HIViewRef inSourceView,<span></span></pre></td></tr><tr><td scope="row"><pre>                                HIViewRef inDestView);<span></span></pre></td></tr></table></div></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_16" title="Note"></a><p><strong>Note:</strong>&nbsp;Note that with all three functions you can pass <code>NULL</code> for a view parameter to convert to or from window-relative coordinates. That is, the <code>NULL</code> parameter is equivalent to the <code>HIViewRef</code> of the root view. </p></div><p>For example, if you wanted to obtain the global coordinates of a point within a view, (to be used in, say, a call to <code>WaitMouseUp</code>), you can call <code>HIViewConvertPoint</code> to obtain the window-relative coordinates. You can then get to global coordinates by calling <code>GetWindowBounds</code>, specifying the structure region, and add the top left global point of the window to the window-relative point. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF108" title="Drawing in Views"></a><h2>Drawing in Views</h2><p>You can use any of the usual Quartz functions to draw in your views. However, because HIView flips the Core Graphics context it passes to you, you draw using the QuickDraw coordinate system by default. If you need to draw images, you can use the <code>HIViewDrawCGImage</code> function, which flips the Core Graphics context (<code>CGContext</code>) back to the Quartz coordinate system, draws the image, and then flips the context back:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewDrawCGImage (CGContextRef inContext,<span></span></pre></td></tr><tr><td scope="row"><pre>                                const HIRect *inBounds,<span></span></pre></td></tr><tr><td scope="row"><pre>                                CGImageRef inImage);<span></span></pre></td></tr></table></div><p>This function is essentially identical to the Quartz function <code>CGContextDrawImage</code> except that it reverses the direction of the y-coordinate axis.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_17" title="Note"></a><p><strong>Note:</strong>&nbsp;The HIView system still supports drawing using QuickDraw. </p></div><p>If you prefer to draw in your view using the Quartz coordinate system, you can translate the context you receive in your drawing handler</p><div class="codesample"><table><tr><td scope="row"><pre>HIViewGetBounds (view, &amp;bounds);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextTranslateCTM (theContext, 0, bounds.size.height);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextScaleCTM (theContext, 1.0, -1.0);<span></span></pre></td></tr></table></div><p>The <code>CGContextTranslateCTM</code> shifts the origin of the y-axis by the height of the view bounds, while the <code>CGContextScaleCTM</code> call invert the y-axis. </p><p>Note that unlike in older system software, you should never draw your views outside of a <code>kEventControlDraw</code> handler; do not use the Control Manager functions <code>UpdateControls</code>, <code>DrawControls</code>, or <code>Draw1Control</code> to draw to the screen. Instead, you must let the system know that a view, or a portion thereof, needs to be updated. This process is analogous to the older method of adding dirty areas to an update region. </p><p>To mark a view as dirty and needing to be redrawn, call the <code>HIViewSetNeedsDisplay</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewSetNeedsDisplay (HIViewRef inView,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    Boolean inNeedsDisplay);<span></span></pre></td></tr></table></div><p>Pass <code>true</code> for the <code>inNeedsDisplay</code> parameter if you want the view updated. You should make this call wherever you would have previously called <code>DrawControls</code>. </p><p>If you need to update only a portion of a view, you can call the <code>HIViewSetNeedsDisplayInRegion</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewSetNeedsDisplayInRegion (HIViewRef inView, RgnHandle inRgn,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            Boolean inNeedsDisplay);<span></span></pre></td></tr></table></div><p>In Mac OS X v10.4 and later you can also use the <code>HIViewSetNeedsDisplayInRect</code> and <code>HIViewSetNeedsDisplayInShape</code> functions:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewSetNeedsDisplayInRect( HIViewRef inView,<span></span></pre></td></tr><tr><td scope="row"><pre>                const HIRect *  inRect, Boolean inNeedsDisplay);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus HIViewSetNeedsDisplayInShape( HIViewRef inView,<span></span></pre></td></tr><tr><td scope="row"><pre>                HIShapeRef   inArea, Boolean inNeedsDisplay)<span></span></pre></td></tr></table></div><p>At the appropriate time, the system copies the updated regions to the screen (or calls your drawing routines). </p><p>In rare cases where you want to redraw your view immediately, you can call the <code>HIViewRender</code> function in Mac OS X v10.3 and later. Doing so allows you to bypass firing Carbon event timers or any other actions that may occur when cycling through the event loop. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_18" title="Important:"></a><p><strong>Important:</strong>&nbsp;You should never pass <code>false</code> for the <code>inNeedsDisplay</code> parameter. If you do so, you may suppress updates for views or regions that intersect the area you specified. </p><p></p></div><p>You can turn off drawing related to a view by calling the <code>HIViewSetDrawingEnabled</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIViewSetDrawingEnabled (HIViewRef inView, Boolean inEnabled);<span></span></pre></td></tr></table></div><p>Turning off drawing in a view also affects any subviews embedded within it. </p><p>When drawing is turned off, the view is not drawn or updated (that is, calls to <code>HIViewSetNeedsDisplay</code> or even <code>Draw1Control</code> have no effect). </p><p>To determine whether drawing is allowed for a view, call the <code>HIViewIsDrawingEnabled</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>Boolean HIViewIsDrawingEnabled (HIViewRef inView);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000923-CH205-BAJIDJDH" title="Manipulating Menu Views"></a><h2>Manipulating Menu Views</h2><p>Beginning in Mac OS X v10.3, all menus are implemented as views. This feature allows additional flexibility in creating or modifying menus. The actual menu content views are created lazily, as needed. That is, the Menu Manager does not create the menu content view, or even the owning window/root view/content view hierarchy that holds it, until the user first clicks on a menu title in the menu bar. </p><p><span class="content_text">Listing 2-1</span> gives an example of how you can manipulate a menu as a view. This example allows you to install an event handler on the menu content view. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-BAJBDJBJ" title="Listing 2-1Creating a menu with an embedded image"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Creating a menu with an embedded image</p><div class="codesample"><table><tr><td scope="row"><pre>IBNibRef nibRef;<span></span></pre></td></tr><tr><td scope="row"><pre>MenuRef myMenuRef;<span></span></pre></td></tr><tr><td scope="row"><pre>HIViewRef theView;<span></span></pre></td></tr><tr><td scope="row"><pre>EventTypeSpec myEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>…<span></span></pre></td></tr><tr><td scope="row"><pre>CreateMenuFromNib (nibRef, CFSTR ("myMenu"),&amp;myMenuRef);<span></span></pre></td></tr><tr><td scope="row"><pre>InsertMenu (myMenuRef, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIMenuGetContentView (myMenuRef, kThemeMenuTypePullDown, &amp;theView);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>myEvent.eventClass = kEventClassControl;<span></span></pre></td></tr><tr><td scope="row"><pre>myEvent.eventKind = kEventControlOwningWindowChanged;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>InstallControlEventHandler (theView, myPictureHandler, 2, &amp;myEvent,0, NULL);<span></span></pre></td></tr></table></div><p>Here is how the code works:</p><ol class="ol"><li class="li"><p>First create the menu. The easiest way is to load it from a nib file, but you can use older Menu Manager functions to do so as well. After creating the menu, use <code>InsertMenu</code> to install it into the menu bar. At this point, none of the menu content views or owning windows have been created. </p></li><li class="li"><p>Call <code>HIMenuGetContentView</code> on your menu reference to obtain the menu content view associated with it. This is the view that displays the menu items. Note that making this call forces an instantiation of the menu content view before it actually needs to be displayed.</p></li><li class="li"><p>Install an event handler for the <code>kEventControlOwningWindowChanged</code> event on the menu content view. This event is sent when the menu content view is attached to a window content view for display (which occurs the first time the user clicks the menu title to display the menu).</p></li></ol><p><span class="content_text">Listing 2-2</span> shows a possible implementation for the event handler installed in <span class="content_text">Listing 2-1</span>. This example installs an image view in your menu content view so that it appears behind the menu items. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_19" title="Note"></a><p><strong>Note:</strong>&nbsp;Placing an image behind a menu violates the Aqua human interface guidelines, so you should not actually do this in your application. This example is for illustrative purposes only. </p></div><a name="//apple_ref/doc/uid/TP30000923-CH205-BAJDEHAA" title="Listing 2-2Adding an image view to a menu"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Adding an image view to a menu</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus PictureHandler( EventHandlerCallRef caller, EventRef event,<span></span></pre></td></tr><tr><td scope="row"><pre>                            void* refcon )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus    err = eventNotHandledErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowRef   owner;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    GetEventParameter( event, kEventParamControlCurrentOwningWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>                     typeWindowRef, NULL, sizeof( owner ), NULL, &amp;owner );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( owner != NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // find the content view<span></span></pre></td></tr><tr><td scope="row"><pre>        HIViewRef content;<span></span></pre></td></tr><tr><td scope="row"><pre>        HIViewFindByID( HIViewGetRoot( owner ), kHIViewWindowContentID,<span></span></pre></td></tr><tr><td scope="row"><pre>                         &amp;content );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // create a data provider for our image<span></span></pre></td></tr><tr><td scope="row"><pre>        CFURLRef url = CFBundleCopyResourceURL( CFBundleGetMainBundle(),<span></span></pre></td></tr><tr><td scope="row"><pre>                            CFSTR("GoldenGate"), CFSTR("jpg"), NULL );<span></span></pre></td></tr><tr><td scope="row"><pre>        CGDataProviderRef data = CGDataProviderCreateWithURL( url );<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease( url );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // create our image<span></span></pre></td></tr><tr><td scope="row"><pre>        CGImageRef image = CGImageCreateWithJPEGDataProvider( data, NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     true, kCGRenderingIntentDefault );<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease( data );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // create our image view<span></span></pre></td></tr><tr><td scope="row"><pre>        HIViewRef imageView;<span></span></pre></td></tr><tr><td scope="row"><pre>        HIImageViewCreate( image, &amp;imageView );<span></span></pre></td></tr><tr><td scope="row"><pre>        HIImageViewSetOpaque( imageView, false );<span></span></pre></td></tr><tr><td scope="row"><pre>        HIImageViewSetAlpha( imageView, 0.3 );<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease( image );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // position our image view below the content view's children<span></span></pre></td></tr><tr><td scope="row"><pre>        HIViewAddSubview( content, imageView );<span></span></pre></td></tr><tr><td scope="row"><pre>        HIViewSetZOrder( imageView, kHIViewZOrderBelow, NULL );<span></span></pre></td></tr><tr><td scope="row"><pre>        HIViewSetVisible( imageView, true );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // size our image view to match the content view<span></span></pre></td></tr><tr><td scope="row"><pre>        HIRect bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>        HIViewGetBounds( content, &amp;bounds );<span></span></pre></td></tr><tr><td scope="row"><pre>        HIViewSetFrame( imageView, &amp;bounds );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is how the code works:</p><ol class="ol"><li class="li"><p>Call <code>GetEventParameter</code> to obtain a reference to the window that owns this menu. Note that each menu has its own separate owning window (including submenus).</p></li><li class="li"><p>Call <code>HIViewFindByID</code> to obtain the content view for the window. This is the view that contains the menu content view, and also the one in which the image view will be embedded. </p></li><li class="li"><p>Create a data provider for the image you want to display. First, call the Core Foundation function <code>CFBundleCopyResourceURL</code> to get the URL to the image in the bundle, then call the Core Graphics function <code>CGDataProviderCreateWithURL</code> to obtain a data provider. After creating the data provider, you can release the URL by calling <code>CFRelease</code>. </p></li><li class="li"><p>Next, create a Core Graphics image from the data provider by calling <code>CGImageCreateWithJPEGDataProvider</code>. After creating the image, you can release the data provider. </p></li><li class="li"><p>Call <code>HIImageViewCreate</code> to create an image view from the Core Graphics image. After creating the image view, you can dispose of the Core Graphics image by calling <code>CFRelease</code>. </p></li><li class="li"><p>Passing <code>false</code> to <code>HIImageViewSetOpaque</code> specifies that the image view is not opaque.</p></li><li class="li"><p>Set the transparency of the image view by calling <code>HIViewSetAlpha</code>. Making the image translucent allows the background of the window content view (that is, the light gray striping) to show through. The alpha range can vary from 0 (transparent) to 1 (opaque). </p></li><li class="li"><p>Call <code>HIViewAddSubview</code> to add the image view to the window content view. </p></li><li class="li"><p>Call <code>HIViewSetZOrder</code> to place the image view behind the menu content view. </p></li><li class="li"><p>Call <code>HIViewSetVisible</code> to make the image view visible. </p></li><li class="li"><p>Lastly, set the bounds of the image view to be the same as that of the window content view. Doing so ensures that the image covers the entire background of the menu. <code>HIViewGetBounds</code> obtains the bounds of the window content view, and <code>HIViewSetFrame</code> sets the bounds of the image view to match those of the content view. </p></li></ol><p>View-based menus allow you even more flexibility when creating custom menu items. For example, you can draw into your menus using Quartz, embed controls within the menu, and so on. Instead of creating custom MDEFs for your menus, you simply create a custom view, and implement Carbon events to handle any required messaging. See <span class="content_text"><a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-BAJHJCBC">“Creating Custom Menus”</a></span> for more information.</p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF109" title="Creating a Scroll View"></a><h2>Creating a Scroll View</h2><p>The HIView scroll view provides an easy way to display a scrollable image. For example, you can simply embed an image view within the scroll view and the scroll view automatically handles the scrolling of the image; you don’t need to worry about installing live feedback handlers, adjusting scroller positions and sizes, or moving pixels. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_20" title="Note"></a><p><strong>Note:</strong>&nbsp;If you want to create custom views that can be embedded in scroll views, your view must support the <code>kEventClassScrollable</code> class of Carbon events. </p></div><p><span class="content_text">Listing 2-3</span> shows a simple example of displaying a scrollable JPEG image in a document window. This example assumes that the image you want to display is a JPEG file installed in your application bundle (in the Resources folder).</p><a name="//apple_ref/doc/uid/TP30000923-CH205-BAJCEJCJ" title="Listing 2-3Creating a scroll view with an embedded image"></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>Creating a scroll view with an embedded image</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef scrollWindow;<span></span></pre></td></tr><tr><td scope="row"><pre>Rect windowBounds = {100, 100, 500, 550};<span></span></pre></td></tr><tr><td scope="row"><pre>HIRect myViewRect;<span></span></pre></td></tr><tr><td scope="row"><pre>HIViewRef myImageView, myScrollView, myContentView;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGImageRef myImage;<span></span></pre></td></tr><tr><td scope="row"><pre>CGDataProviderRef myProvider;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFBundleRef theAppBundle;<span></span></pre></td></tr><tr><td scope="row"><pre>CFStringRef filename;<span></span></pre></td></tr><tr><td scope="row"><pre>CFURLRef theURL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CreateNewWindow (kDocumentWindowClass, kWindowStandardHandlerAttribute |<span></span></pre></td></tr><tr><td scope="row"><pre>             kWindowCompositingAttribute, &amp;windowBounds,&amp;scrollWindow);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Get the JPEG image from a file. */<span></span></pre></td></tr><tr><td scope="row"><pre>theAppBundle = CFBundleGetMainBundle();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>filename = CFStringCreateWithCString(NULL, "CowPuppy.jpg",<span></span></pre></td></tr><tr><td scope="row"><pre>                kCFStringEncodingASCII);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>theURL = CFBundleCopyResourceURL (theAppBundle, filename, NULL, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Quartz stuff to put the JPEG image into an image view */<span></span></pre></td></tr><tr><td scope="row"><pre>myProvider = CGDataProviderCreateWithURL(theURL);<span></span></pre></td></tr><tr><td scope="row"><pre>myImage = CGImageCreateWithJPEGDataProvider (myProvider, NULL, false,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     kCGRenderingIntentDefault);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGDataProviderRelease (myProvider);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease(filename);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Now create the scroll view and image view. */<span></span></pre></td></tr><tr><td scope="row"><pre>HIScrollViewCreate (kHIScrollViewOptionsVertScroll |<span></span></pre></td></tr><tr><td scope="row"><pre>                     kHIScrollViewOptionsHorizScroll, &amp;myScrollView);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIViewSetVisible (myScrollView, true);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIViewFindByID(HIViewGetRoot(scrollWindow), kHIViewWindowContentID,<span></span></pre></td></tr><tr><td scope="row"><pre>                 &amp;myContentView);<span></span></pre></td></tr><tr><td scope="row"><pre>HIViewAddSubview (myContentView, myScrollView);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>myViewRect.origin.x = 50.0;<span></span></pre></td></tr><tr><td scope="row"><pre>myViewRect.origin.y = 10.0;<span></span></pre></td></tr><tr><td scope="row"><pre>myViewRect.size.width = 300.0;<span></span></pre></td></tr><tr><td scope="row"><pre>myViewRect.size.height = 300.0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIViewSetFrame (myScrollView, &amp;myViewRect);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIImageViewCreate (myImage, &amp;myImageView);<span></span></pre></td></tr><tr><td scope="row"><pre>CGImageRelease (myImage);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIViewSetVisible (myImageView, true);<span></span></pre></td></tr><tr><td scope="row"><pre>HIViewAddSubview (myScrollView, myImageView);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ShowWindow (scrollWindow);<span></span></pre></td></tr></table></div><p>Here is how the code works:</p><ol class="ol"><li class="li"><p>Call <code>CreateNewWindow</code> to create a new document window. Note that you must set the <code>kWindowCompositingAttribute</code> attribute if you want to use HIView objects in the window. Use of the standard window handler is also highly recommended. </p><p>If you are creating a window from a nib file, you must set the Compositing checkbox for the window from the Info window in Interface Builder. </p></li><li class="li"><p>Call the Core Foundation CFBundle function <code>CFBundleGetMainBundle</code> to find the main application bundle. </p></li><li class="li"><p>Create a CFString of the name of the image file using the Core Foundation function <code>CFStringCreateWithCString</code>. </p></li><li class="li"><p>Call the Core Foundation function <code>CFBundleCopyResourceURL</code> to build a URL path to the image file in the application bundle.</p></li><li class="li"><p>Use the Core Graphics function <code>CGDataProviderCreateWithURL</code> to create a data provider. In Quartz, you need to create data providers before creating a <code>CGImage</code> object. </p></li><li class="li"><p>Call the Core Graphics function <code>CGImageCreateWithJPEGDataProvider</code> to create a <code>CGImage</code> object from the JPEG file. </p></li><li class="li"><p>After creating the <code>CGImage</code> object, you can release the data provider and the <code>CFString</code> filename object by calling <code>CGDataProviderRelease</code> and <code>CFRelease</code> respectively. </p></li><li class="li"><p>To create the scroll view, call the <code>HIScrollViewCreate</code> function. This example passes in options specifying both horizontal and vertical scroll bars. </p></li><li class="li"><p>Call <code>HIViewSetVisible</code> to make the scroll view visible. </p></li><li class="li"><p>In order to embed the scroll view properly, you need to obtain the content view of the window. You do so by calling the <code>HIViewFindByID</code> function, specifying that you want to find the content view. Note that this function requires the root view as its first parameter. To obtain the root view for this window, you must call <code>HIViewGetRoot</code>. </p><p>Note that to obtain the content view, you could also call the Control Manager function <code>GetRootControl</code>. </p></li><li class="li"><p>To embed the scroll view in the content view, call the <code>HIViewAddSubview</code> function. Note that at this point, although the scroll view is embedded in the content view, it has no bounds (that is, it has no physical location or size).</p></li><li class="li"><p>To set the bounds of the scroll view, you fill in an <code>HIRect</code> structure. Note that this structure has a format different from that of the QuickDraw <code>Rect</code> structure. This example creates a 300 pixel square scroll view located at (50,10) in the local coordinates of the content view. </p></li><li class="li"><p>Once you specify the bounds in <code>myViewRect</code>, you pass them into the <code>HIViewSetFrame</code> function to set the frame bounds of the scroll view (that is, the coordinates of the scroll view relative to the content view). </p><p>If you want the scroll view to occupy the entire content view, you can call <code>HIViewGetBounds</code> (not <code>HIViewGetFrame</code>) on the content view and pass the resulting <code>HIRect</code> into <code>HIViewSetFrame</code> for the scroll view. </p></li><li class="li"><p>To create the image view, you call <code>HIImageViewCreate</code>, passing in the <code>CGImage</code> object you obtained from <code>CGImageCreateWithJPEGDataProvider</code>.</p></li><li class="li"><p>After creating the image view, you can dispose of the <code>CGImage</code> object by calling the Core Graphics function <code>CGImageRelease</code>. </p></li><li class="li"><p>Call <code>HIViewSetVisible</code> to make the image view visible.</p></li><li class="li"><p>Call <code>HIViewAddSubview</code> to embed the image view within the scroll view. The image view will appear with the top-left corner aligned with the scroll view’s origin. </p></li><li class="li"><p>Call the Window Manager function <code>ShowWindow</code> to display the window with the scroll view. </p></li></ol><p>If you create your scroll view to be resizable, by passing <code>true</code> to the <code>HIScrollViewSetScrollBarAutoHide</code> function, you can specify that the scroll bars be hidden if the scroll view is enlarged to the point that the entire image is visible. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF115" title="Creating a Combo Box"></a><h2>Creating a Combo Box</h2><p>HIView lets you create a combo box control using simple function calls. All of the basic pop-up behavior and item selection is handled for you automatically. In addition, HIView combo boxes also support the following optional features, which you set by specifying attributes during creation:</p><ul class="ul"><li class="li"><p>auto-completion in the editable text field (<code>kHIComboBoxAutoCompletionAttribute</code>)</p></li><li class="li"><p>automatic disclosure of list items when the user enters text (<code>kHIComboBoxAutoDisclosureAttribute</code>)</p></li><li class="li"><p>alphabetical sorting of list items (<code>kHIComboBoxAutoSortAttribute</code>)</p></li><li class="li"><p>automatic resizing of the list to conform to the Aqua human interface guidelines (<code>kHIComboBoxAutoSizeListAttribute</code>). Note that if you do not specify this attribute, you must size the list yourself using Control Manager <code>SetControlData</code> tags. Otherwise the size of the list is undefined. See <code>HIView.h</code> for a listing of available combo box data tags. </p></li></ul><p><span class="content_text">Listing 2-4</span> shows a code fragment that creates the simple combo box in <span class="content_text"><a href="../HIView_concept/HIView_concept.html#//apple_ref/doc/uid/TP30000923-CH204-BCIHEJEI">Figure 1-7</a></span>.</p><a name="//apple_ref/doc/uid/TP30000923-CH205-CJBDCGBG" title="Listing 2-4Creating a simple combo box"></a><p class="codesample"><strong>Listing 2-4&nbsp;&nbsp;</strong>Creating a simple combo box</p><div class="codesample"><table><tr><td scope="row"><pre>WindowRef myPrefsWindow;<span></span></pre></td></tr><tr><td scope="row"><pre>HIViewRef myCombo, myContentView;<span></span></pre></td></tr><tr><td scope="row"><pre>HIRect hiRect;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Rect myBounds = {100, 100, 500, 500};<span></span></pre></td></tr><tr><td scope="row"><pre>Rect ComboRect = {0, 0, 20, 100};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CreateNewWindow (kMovableModalWindowClass, kWindowStandardHandlerAttribute|<span></span></pre></td></tr><tr><td scope="row"><pre>                kWindowCompositingAttribute, &amp;myBounds,&amp;myPrefsWindow);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>hiRect.origin.x = ComboRect.left;<span></span></pre></td></tr><tr><td scope="row"><pre>hiRect.origin.y = ComboRect.top;<span></span></pre></td></tr><tr><td scope="row"><pre>hiRect.size.width = ComboRect.right-ComboRect.left;<span></span></pre></td></tr><tr><td scope="row"><pre>hiRect.size.height = ComboRect.bottom-ComboRect.top;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIComboBoxCreate (&amp;hiRect, CFSTR ("Hobbes"), NULL, NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kHIComboBoxStandardAttributes, &amp;myCombo);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIViewSetVisible (myCombo, true);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIViewFindByID (HIViewGetRoot(myPrefsWindow),kHIViewWindowContentID,<span></span></pre></td></tr><tr><td scope="row"><pre>                 &amp;myContentView);<span></span></pre></td></tr><tr><td scope="row"><pre>HIViewAddSubview (myContentView, myCombo);<span></span></pre></td></tr><tr><td scope="row"><pre>HIViewPlaceInSuperviewAt (myCombo, 25.0, 25.0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>HIComboBoxAppendTextItem (myCombo, CFSTR ("Hobbes"), NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>HIComboBoxAppendTextItem (myCombo, CFSTR ("Plato"), NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>HIComboBoxAppendTextItem (myCombo, CFSTR ("Heidegger"), NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>HIComboBoxAppendTextItem (myCombo, CFSTR ("Aristotle"), NULL);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ShowWindow (myPrefsWindow);<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>This example places the combo box in a movable modal window created using <code>CreateNewWindow</code>. Note that you must specify the <code>kWindowCompositingAttribute</code> attribute. </p></li><li class="li"><p>This example originally specifies the bounds of the combo box as a QuickDraw <code>Rect</code> structure and then translates those coordinates into a Quartz-compatible <code>HIRect</code> structure. </p></li><li class="li"><p>To create the combo box, call the <code>HIComboBoxCreate</code> function. You specify the following parameters:</p><ul class="ul"><li class="li"><p>The bounds of the combo box, as an <code>HIRect</code> structure.</p></li><li class="li"><p>The initial text in the editable text field as a Core Foundation <code>CFString</code>. This text could indicate the kind of item the user should enter, or the default item selection. </p></li><li class="li"><p>A pointer to a Control Manager <code>ControlFontStyleRec</code> structure indicating the font style to use for this combo box. Pass <code>NULL</code> (as in this example) if you want to use the default system font. </p></li><li class="li"><p>A Core Foundation <code>CFArray</code> containing the items you want to display in the item list. You can also pass <code>NULL</code> (as in this example) and add items on-the-fly later. </p></li><li class="li"><p>The attributes you want for this combo box. Specifying <code>kHIComboBoxStandardAttributes</code> gives you the automatic sizing, list disclosure, and text completion features.</p></li></ul><p>On return, <code>myCombo</code> contains the new combo box. </p></li><li class="li"><p>As usual, the new HIView is initially hidden, so call <code>HIViewSetVisible</code> to make it visible. </p></li><li class="li"><p>To embed the combo box in the movable modal window’s content view, you can call <code>HIViewFindByID</code> and <code>HIViewAddSubview</code>, just as in <span class="content_text"><a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-BAJCEJCJ">Listing 2-3</a></span>. However, as an alternative to using <code>HIViewSetFrame</code> to position the combo box in the view, you can call the <code>HIViewPlaceInSuperviewAt</code> function. You can do this because the combo box already has a size; you now need to specify only a position. The coordinates you specify indicate the top-left corner of the view’s bounds. </p></li><li class="li"><p>You can add items to the combo box list by simply calling the <code>HIComboBoxAppendTextItem</code> function. This example adds four items. </p></li></ol><a name="//apple_ref/doc/uid/TP30000923-CH205-CJBCFJCE" title="Creating Custom Views"></a><h2>Creating Custom Views</h2><p>One of the advantages of HIView is that you can subclass an existing view when creating a custom view. In object-oriented fashion, a view is essentially a class defined by Carbon event handlers (essentially methods) and instance data. To create a custom view, you must create a subclass of HIView and add your custom functionality by overriding event handlers. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF116" title="Registering an HIObject Subclass"></a><h3>Registering an HIObject Subclass</h3><p>You register your subview much like you register a custom window or control when you call <code>RegisterToolboxObjectClass</code>, but there are some parameter differences. </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIObjectRegisterSubclass (CFStringRef inClassID,<span></span></pre></td></tr><tr><td scope="row"><pre>                                CFStringRef inBaseClassID,<span></span></pre></td></tr><tr><td scope="row"><pre>                                OptionBits inOptions,<span></span></pre></td></tr><tr><td scope="row"><pre>                                EventHandlerUPP inConstructProc,<span></span></pre></td></tr><tr><td scope="row"><pre>                                UInt32 inNumEvents,<span></span></pre></td></tr><tr><td scope="row"><pre>                                const EventTypeSpec *inEventList,<span></span></pre></td></tr><tr><td scope="row"><pre>                                void* inConstructData,<span></span></pre></td></tr><tr><td scope="row"><pre>                                HIObjectClassRef *outClassRef);<span></span></pre></td></tr></table></div><ol class="ol"><li class="li"><p>The <code>inClassID</code> parameter represents the ID of the class you want to register. This ID must be a Core Foundation string, preferably in the form <em>com.CompanyName.Application.ClassName</em>.</p></li><li class="li"><p>The <code>inBaseClassID</code> parameter represents the class you want to subclass. For the base HIView class, you pass the constant <code>kHIViewClassID</code>. </p></li><li class="li"><p>Pass any options in the <code>inOptions</code> parameter. Currently there are no options (pass <code>0</code>). </p></li><li class="li"><p>The <code>inConstructProc</code> is a universal procedure pointer (UPP) to the event handler for your view class. </p></li><li class="li"><p>The <code>inNumEvents</code> parameter indicates the number of events you want to register for this view class. </p></li><li class="li"><p>The <code>inEventList</code> array contains the events to register for this class. You define these just as you would for registering any Carbon Event handler. </p></li><li class="li"><p>The <code>inConstructData</code> parameter points to any initialization data (that is, constructor data) you want to pass to your class. </p></li><li class="li"><p>On return, <code>outClassRef</code> holds the class reference for your registered subclass. You pass this value to <code>HIObjectCreate</code> when creating an instance of your class. </p></li></ol><p><span class="content_text">Listing 2-5</span> shows a function that registers a custom view. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-BABEDGBH" title="Listing 2-5Registering a custom view"></a><p class="codesample"><strong>Listing 2-5&nbsp;&nbsp;</strong>Registering a custom view</p><div class="codesample"><table><tr><td scope="row"><pre>#define kMyCustomViewClassID CFSTR("com.myCorp.myApp.myView")<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus myCustomViewRegister()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus                err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    static HIObjectClassRef sMyViewClassRef = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( sMyViewClassRef == NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        EventTypeSpec       eventList[] = {<span></span></pre></td></tr><tr><td scope="row"><pre>            { kEventClassHIObject, kEventHIObjectConstruct },<span></span></pre></td></tr><tr><td scope="row"><pre>            { kEventClassHIObject, kEventHIObjectInitialize },<span></span></pre></td></tr><tr><td scope="row"><pre>            { kEventClassHIObject, kEventHIObjectDestruct },<span></span></pre></td></tr><tr><td scope="row"><pre>            { kEventClassControl, kEventControlInitialize },<span></span></pre></td></tr><tr><td scope="row"><pre>            { kEventClassControl, kEventControlDraw },<span></span></pre></td></tr><tr><td scope="row"><pre>            { kEventClassControl, kEventControlHitTest },<span></span></pre></td></tr><tr><td scope="row"><pre>            { kEventClassControl, kEventControlGetPartRegion } };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        err = HIObjectRegisterSubclass(<span></span></pre></td></tr><tr><td scope="row"><pre>            kMyCustomViewClassID,       // class ID<span></span></pre></td></tr><tr><td scope="row"><pre>            kHIViewClassID,             // base class ID<span></span></pre></td></tr><tr><td scope="row"><pre>            NULL,                       // option bits<span></span></pre></td></tr><tr><td scope="row"><pre>            myCustomViewHandler,        // construct proc<span></span></pre></td></tr><tr><td scope="row"><pre>            GetEventTypeCount( eventList ),<span></span></pre></td></tr><tr><td scope="row"><pre>            eventList,<span></span></pre></td></tr><tr><td scope="row"><pre>            NULL,                       // construct data,<span></span></pre></td></tr><tr><td scope="row"><pre>            &amp;sMyViewClassRef );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This example stores the resulting <code>HIObjectClassRef</code> value as a static variable, so you can skip the registration call if your class has already been registered. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF117" title="Handling View Events"></a><h3>Handling View Events</h3><p>You specify an event handler for your view when you call <code>HIObjectRegisterSubclass</code>, just as you would for any custom control. <span class="content_text">Listing 2-6</span> shows an event handler to correspond with the class registered in <span class="content_text">Listing 2-5</span>.</p><a name="//apple_ref/doc/uid/TP30000923-CH205-BABDGECJ" title="Listing 2-6A custom view event handler"></a><p class="codesample"><strong>Listing 2-6&nbsp;&nbsp;</strong>A custom view event handler</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus myCustomViewHandler(<span></span></pre></td></tr><tr><td scope="row"><pre>    EventHandlerCallRef     inCallRef,<span></span></pre></td></tr><tr><td scope="row"><pre>    EventRef                inEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>    void*                   inUserData )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus                err = eventNotHandledErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                  eventClass = GetEventClass( inEvent );<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                  eventKind = GetEventKind( inEvent );<span></span></pre></td></tr><tr><td scope="row"><pre>    myCustomViewData*       data = (myCustomViewData*) inUserData;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch ( eventClass )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventClassHIObject:<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            switch ( eventKind )<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventHIObjectConstruct:<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = myCustomViewConstruct( inEvent );<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventHIObjectInitialize:<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = myCustomViewInitialize( inCallRef, inEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    data );<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventHIObjectDestruct:<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = myCustomViewDestruct( inEvent, data );<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventClassControl:<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            switch ( eventKind )<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventControlInitialize:<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventControlDraw:<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = myCustomViewDraw( inEvent, data );<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventControlHitTest:<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = myCustomViewHitTest( inEvent, data );<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventControlGetPartRegion:<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = myCustomViewGetRegion( inEvent, data );<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Note that this handler uses special HIObject class events. The sections that follow describe HIObject events, as well as other basic events your custom view may want to handle. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-BABECHDD" title="Handling HIObject Events"></a><h4>Handling HIObject Events</h4><p>All custom views must support the following Carbon events of class <code>kEventClassHIObject</code> (as defined in <code>HIObject.h</code>). These events correspond to object-oriented constructor and destructor methods:</p><ul class="spaceabove"><li class="li"><p><code>kEventHIObjectConstruct</code>: you use this event to allocate memory for your instance data. Typically you want to allocate enough space to store the <code>HIViewRef</code> (or <code>ControlRef</code>) as well as any other view-specific instance data. You must return a pointer to this allocated memory in the <code>kEventParamHIObjectInstance</code> parameter (type <code>typeVoidPtr</code>).</p></li><li class="li"><p><code>kEventHIObjectDestruct</code>: your view receives this event when its reference count has dropped to zero (that is, when the object should be destroyed). You should use this event to dispose of anything you may have allocated for your view. </p></li></ul><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_21" title="Important:"></a><p><strong>Important:</strong>&nbsp;The HIObject constructor and destructor events are sent directly to your event handler, so there is no handler stack associated with the event. Therefore, your handler must not call any functions that assume the presence of an event handler stack (such as <code>CallNextEventHandler</code>). </p><p></p></div><p><span class="content_text">Listing 2-7</span> shows a sample handler for the <code>kEventHIObjectConstruct</code> event.</p><a name="//apple_ref/doc/uid/TP30000923-CH205-BABJEEFA" title="Listing 2-7A kEventHIObjectConstruct handler"></a><p class="codesample"><strong>Listing 2-7&nbsp;&nbsp;</strong>A kEventHIObjectConstruct handler</p><div class="codesample"><table><tr><td scope="row"><pre>typedef struct<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ControlRef control;<span></span></pre></td></tr><tr><td scope="row"><pre>} myCustomViewData;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus myCustomViewConstruct (EventRef inEvent)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus                err;<span></span></pre></td></tr><tr><td scope="row"><pre>    myCustomViewData*       data;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    data = malloc( sizeof( myCustomViewData ) );<span></span></pre></td></tr><tr><td scope="row"><pre>    require_action( data != NULL, CantMalloc, err = memFullErr );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = GetEventParameter( inEvent, kEventParamHIObjectInstance,<span></span></pre></td></tr><tr><td scope="row"><pre>                            typeHIObjectRef, NULL, sizeof( HIObjectRef ),<span></span></pre></td></tr><tr><td scope="row"><pre>                            NULL, (HIObjectRef*) &amp;data->control );<span></span></pre></td></tr><tr><td scope="row"><pre>    require_noerr( err, ParameterMissing );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set the userData to be used with all subsequent eventHandler calls<span></span></pre></td></tr><tr><td scope="row"><pre>    err = SetEventParameter( inEvent, kEventParamHIObjectInstance,<span></span></pre></td></tr><tr><td scope="row"><pre>                            typeVoidPtr, sizeof( myCustomViewData* ),<span></span></pre></td></tr><tr><td scope="row"><pre>                            &amp;data );<span></span></pre></td></tr><tr><td scope="row"><pre>ParameterMissing:<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( err != noErr )<span></span></pre></td></tr><tr><td scope="row"><pre>        free( data );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CantMalloc:<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>The <code>myCustomViewData</code> structure defines the instance data to associated with the class. In this case, the only data required is the control reference. Note that you could also have defined this as an <code>HIViewRef</code> type or an <code>HIObjectRef</code> type, as they are identical. </p></li><li class="li"><p>Use <code>malloc</code> to allocate space for your instance data. </p></li><li class="li"><p>This code example and others in this section use Apple-defined error-checking macros. For more information about using these macros, see the header <code>AssertMacros.h</code>.</p></li><li class="li"><p>Use the Carbon Event Manager function <code>GetEventParameter</code> to obtain the default instance data for this class (which is just the <code>HIViewRef</code>). You store this data in the <code>control</code> field of your instance data. </p></li><li class="li"><p>Now, use <code>SetEventParameter</code> to set your instance data to be the instance data for this class. Because this example only has one field, you are passing back the same data that you received. However, this procedure allows you to specify additional instance data if you desire. The data you specify for the <code>kEventParamHIObjectInstance</code> parameter is then passed to your HIObject event handler in the <code>userData</code> parameter when subsequent events occur. </p></li></ol><p>Your <code>kEventHIObjectDestruct</code> handler should dispose of anything allocated for your view (such as user data allocated during the initialize event and instance data) Do not dispose of the view reference. <span class="content_text">Listing 2-8</span> shows a very simple destruct handler that simply frees the instance data you allocated in the construct handler. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-BAJGAACJ" title="Listing 2-8A kEventHIObjectDestruct handler"></a><p class="codesample"><strong>Listing 2-8&nbsp;&nbsp;</strong>A kEventHIObjectDestruct handler</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus myCustomViewDestruct (EventRef inEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                                myCustomViewData* inData)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    free (inData);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In addition, your view will usually want to support the <code>kEventHIObjectInitialize</code> event. This handler provides a simple mechanism to perform any needed initialization tasks. As a rule, your handler should first pass the event to its superclass by calling <code>CallNextEventHandler</code>. This gives the superclass the opportunity to perform any initializations. </p><p>You can also use this event to pass initialization data to your view when you call <code>HIObjectCreate</code>. For example, you may want to pass initial bounds (size and position) information to your view using this event. </p><p><span class="content_text">Listing 2-9</span> shows an example of an initialization event handler. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-BABCEFFE" title="Listing 2-9A kEventHIObjectInitialize handler"></a><p class="codesample"><strong>Listing 2-9&nbsp;&nbsp;</strong>A kEventHIObjectInitialize handler</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus myCustomViewInitialize (EventHandlerCallRef inCallRef,<span></span></pre></td></tr><tr><td scope="row"><pre>                            EventRef inEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                            myCustomViewData* inData)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus err;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect bounds;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Let any parent classes have a chance at initialization<span></span></pre></td></tr><tr><td scope="row"><pre>    err = CallNextEventHandler( inCallRef, inEvent );<span></span></pre></td></tr><tr><td scope="row"><pre>    require_noerr( err, TroubleInSuperClass );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Extract the bounds from the initialization event<span></span></pre></td></tr><tr><td scope="row"><pre>    err = GetEventParameter( inEvent, 'Boun', typeQDRectangle,<span></span></pre></td></tr><tr><td scope="row"><pre>            NULL, sizeof( Rect ), NULL, &amp;bounds );<span></span></pre></td></tr><tr><td scope="row"><pre>    require_noerr( err, ParameterMissing );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Resize the view<span></span></pre></td></tr><tr><td scope="row"><pre>    SetControlBounds( inData->control, &amp;bounds );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ParameterMissing:<span></span></pre></td></tr><tr><td scope="row"><pre>TroubleInSuperClass:<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>First, call the Carbon Event Manager function <code>CallNextEventHandler</code> to give the view’s superclasses a chance to perform any initialization. </p></li><li class="li"><p>Any further initialization is entirely up to the application. Note that before you call <code>HIObjectCreate</code>, you can store initialization data as parameters in the <code>kEventHIObjectInitialize</code> event. In this example, the initial bounds were stored in the event, so you call <code>GetEventParameter</code> to obtain it. The parameter identifier (<code>'Boun'</code> in this example) is entirely arbitrary (as long as it’s a four-character code), as it is used only in this event. </p></li><li class="li"><p>After obtaining the bounds of the view, you call the Control Manager function <code>SetControlBounds</code> to set them. Note that you could also have used the <code>HIViewSetFrame</code> function to set the bounds of the view, but you must make sure you passed an <code>HIRect</code> type in the initialize event. </p></li></ol><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF111" title="Handling Hit-Test Events"></a><h4>Handling Hit-Test Events</h4><p>When a hit-test event (<code>kEventControlHitTest</code>) occurs, your custom view must indicate what part of itself was hit. The system can then send draw events to your view if that is required for tracking or selecting. </p><p>Note that while the Control Manager defines several part codes, you are also free to define your own values within the range 1 through 127. All negative value part codes are defined by Apple; your application can respond to these negative values (for example, when asked to shift focus), but it should never return them from a <code>kEventControlHitTest</code> handler. </p><p>You can use <code>GetEventParameter</code> to obtain the mouse location parameter, and then use <code>SetEventParameter</code> to pass back the part code that was hit in the control part parameter. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF112" title="Handling Draw Events"></a><h4>Handling Draw Events</h4><p>When the draw event (kEventControlDraw) occurs, you must draw your view or portion thereof. </p><p>If you are using Quartz, you must obtain the <code>kEventParamCGContextRef</code> parameter, which holds the Core Graphics context you should draw into. You must use the context that is passed to you rather than creating your own in the drawing handler. This context is already transformed, so you simply draw. </p><p>If you are using QuickDraw, you can obtain the current graphics port from the <code>kEventParamGrafPort</code> parameter. </p><p>In addition, whether you use QuickDraw or Quartz, the <code>kEventControlDraw</code> event also contains a <code>kEventParamRgnHandle</code> parameter. This region defines the visible portion of the view, and in most cases you should restrict your drawing to this area; any part of the view outside this area is presumably covered by another view and will be overwritten. The HIView compositor determines the size of this region.</p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF113" title="Handling Region Calculation Events"></a><h4>Handling Region Calculation Events</h4><p>At times the system may need to obtain region information about your view; it sends a <code>kEventControlGetPartRegion</code> event to do so. The most important regions are the structure region and the opaque region. The event reference indicates the desired region in the <code>kEventParamPartCode</code> parameter. You should use <code>SetEventParameter</code> to return the requested region handle in the <code>kEventParamControlRegion</code> parameter.</p><p>The structure region is essentially the area onscreen taken up by the view. In many cases this area is identical to the view’s bounds, but not always. For example, focus rings are considered part of the structure region, even though they appear outside the view bounds. If you choose not to return a structure region (or you choose not to handle this event), the system assumes that the view’s bounds are the structure region. </p><p>If your view’s structure region changes, you should inform the system by calling the <code>HIViewReshapeStructure</code> function. Doing so lets the system recalculate visible areas and redraw as appropriate. For example, if your view gains or loses a focus ring, the structure changes size and you should inform the system. </p><p>The opaque region is the part of your view that is opaque. Knowledge of a view’s opaque region simplifies drawing because the HIView compositor knows that it does not have to render anything underneath the opaque parts. If you do not return an opaque region (or if you don’t handle this event) the compositor assumes the view is transparent.</p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF114" title="Handling Drag and Drop Events"></a><h4>Handling Drag and Drop Events</h4><p>If your view supports drag and drop, you should support the following Carbon events:</p><ul class="spaceabove"><li class="li"><p><code>kEventControlDragEnter</code>: sent when the drag item enters your view. Typically you should check to see if your view accepts the type of drag item, and if so, highlight the view. If your view accepts the drag item, you must return a Boolean parameter (<code>kEventParamControlLikesDrag</code>, <code>typeBoolean</code>) in the drag-enter event. </p></li><li class="li"><p><code>kEventControlDragWithin</code>: sent while the user drags within your view (but not within a subview).</p></li><li class="li"><p><code>kEventControlDragLeave</code>: sent when the drag item leaves your view. </p></li><li class="li"><p><code>kEventControlDragReceive</code>: sent when the user drops an item in your view. If your window accepts the item, it can take appropriate action (for example, paste dragged text into the window).</p></li></ul><p>To enable drag-and-drop, your code should also take the following steps:</p><ul class="spaceabove"><li class="li"><p>Set the <code>kControlSupportsDragAndDrop</code> bit in the <code>kEventParamControlFeatures</code> parameter of the <code>kEventControlInitialize</code> event. You should set these bits before calling <code>CallNextEventHandler</code>. </p></li><li class="li"><p> Call <code>SetControlDragTrackingEnabled</code> (with the Boolean parameter set to <code>True</code>) for the view. </p></li><li class="li"><p>Turn on drag-tracking for the window using the <code>SetAutomaticControlDragTrackingEnabledForWindow</code> function.</p></li></ul><p>To streamline the event handling, if your view does not handle the <code>kEventControlDragEnter</code> event, then it never receives any other drag events. If you think you may want the drag item, return <code>noErr</code> from your drag-entered handler.</p><p>Note that only views that can receive keyboard focus can receive drag-within or drag-received events. </p><p>For more detailed information about how your application should behave in response to drag-and-drop actions, see the document <em><a href="../../../../UserExperience/Conceptual/AppleHIGuidelines/index.html#//apple_ref/doc/uid/20000957" target="_top">Apple Human Interface Guidelines</a></em>.</p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF118" title="Creating a View Instance"></a><h3>Creating a View Instance</h3><p>To create an instance of a view, you call the <code>HIObjectCreate</code> function. </p><p><span class="content_text">Listing 2-10</span> gives an example of a function to create a view instance. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-CJBDGGIA" title="Listing 2-10A view instance creation function"></a><p class="codesample"><strong>Listing 2-10&nbsp;&nbsp;</strong>A view instance creation function</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus CreateMyCustomView ( WindowRef inWindow, const Rect*inBounds,<span></span></pre></td></tr><tr><td scope="row"><pre>                                ControlRef* outControl )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus            err;<span></span></pre></td></tr><tr><td scope="row"><pre>    ControlRef          root;<span></span></pre></td></tr><tr><td scope="row"><pre>    EventRef            event;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Register this class<span></span></pre></td></tr><tr><td scope="row"><pre>    err = myCustomViewRegister();<span></span></pre></td></tr><tr><td scope="row"><pre>    require_noerr( err, CantRegister );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Make an initialization event<span></span></pre></td></tr><tr><td scope="row"><pre>    err = CreateEvent( NULL, kEventClassHIObject, kEventHIObjectInitialize,<span></span></pre></td></tr><tr><td scope="row"><pre>                        GetCurrentEventTime(), 0, &amp;event );<span></span></pre></td></tr><tr><td scope="row"><pre>    require_noerr( err, CantCreateEvent );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If bounds were specified, push the them into the initialization event<span></span></pre></td></tr><tr><td scope="row"><pre>    // so that they can be used in the initialization handler.<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( inBounds != NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        err = SetEventParameter( event, 'Boun', typeQDRectangle,<span></span></pre></td></tr><tr><td scope="row"><pre>                sizeof( Rect ), inBounds );<span></span></pre></td></tr><tr><td scope="row"><pre>        require_noerr( err, CantSetParameter );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = HIObjectCreate( kMyCustomViewClassID, event, (HIObjectRef*)<span></span></pre></td></tr><tr><td scope="row"><pre>                            outControl );<span></span></pre></td></tr><tr><td scope="row"><pre>    require_noerr( err, CantCreate );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If a parent window was specified, place the new view into the<span></span></pre></td></tr><tr><td scope="row"><pre>    // parent window.<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( inWindow != NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        err = GetRootControl( inWindow, &amp;root );<span></span></pre></td></tr><tr><td scope="row"><pre>        require_noerr( err, CantGetRootControl );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        err = HIViewAddSubview( root, *outControl );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CantCreate:<span></span></pre></td></tr><tr><td scope="row"><pre>CantGetRootControl:<span></span></pre></td></tr><tr><td scope="row"><pre>CantSetParameter:<span></span></pre></td></tr><tr><td scope="row"><pre>CantCreateEvent:<span></span></pre></td></tr><tr><td scope="row"><pre>    ReleaseEvent( event );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CantRegister:<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ol class="ol"><li class="li"><p>The <code>CreateMyCustomView</code> function mimics an older Control Manager creation function in that you can specify the desired bounds of the view as well as the owning window in its input parameters.</p></li><li class="li"><p>Register your custom class if you have not already done so. Note that you can register your subclass multiple times with no adverse effects. </p></li><li class="li"><p>As mentioned in <span class="content_text"><a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-BABECHDD">“Handling HIObject Events,”</a></span> the <code>HIObjectCreate</code> function requires you to pass it a <code>kEventHIObjectInitialize</code> event. You must create this event by calling the Carbon Event Manager function <code>CreateEvent</code>, specifying the event class and kind.</p></li><li class="li"><p>If the <code>CreateMyCustomView</code> function received a valid bounds parameter, you should attach it to the initialization event by calling <code>SetEventParameter</code>. The parameter name is four-character code that can be completely arbitrary as long as your initialization event handler recognizes it. </p></li><li class="li"><p>To create the instance, call <code>HIObjectCreate</code>, passing the class of view to create and the initialization event. On return, <code>outControl</code> contains a reference to the new view. </p></li><li class="li"><p>If the <code>CreateMyCustomView</code> function received a valid owning window reference, you can add it to the window’s view hierarchy by calling <code>HIViewAddSubview</code>. This example adds the view to the content view (by calling the Control Manager function <code>GetRootControl</code>), but you can add it to the root view or any other arbitrary view if you desire. </p></li></ol><a name="//apple_ref/doc/uid/TP30000923-CH205-BAJHJCBC" title="Creating Custom Menus"></a><h3>Creating Custom Menus</h3><p>In Mac OS X v10.3 and later, if you want to create a custom menu, you should create one as an HIView subclass rather than using an old-style menu definition <code>MDEF</code>. Doing so generally requires less work on your part, as you can inherit a lot of functionality from the menu content view class. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_22" title="Note"></a><p><strong>Note:</strong>&nbsp;If you have an existing MDEF, you can convert it to a view-based menu definition by translating the MDEF messages to specific Carbon events. See <span class="content_text"><a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-CJBDHFCC">“Menu Definition Events Versus Older MDEF Messages”</a></span> for details.</p></div><p>A custom menu is a view typically subclassed from the <code>HIMenuView</code> or <code>HIStandardMenuView</code> classes. </p><ul class="spaceabove"><li class="li"><p><code>HIMenuView</code> is the base class for menu views. It sets or implements the following functionality:</p><ul class="nested"><li class="nested li"><p>The view is marked to be ignored for accessibility, so assistive applications do not think it is a standard window/view hierarchy. </p></li><li class="nested li"><p>Sets the <code>kHIViewDoesNotUseSpecialParts</code> and <code>kHIViewAllowsSubviews</code> feature bits. </p></li><li class="nested li"><p>Implements default handlers for <code>kEventMenuCreateFrameView</code>, <code>kEventMenuGetFrameBounds</code>, <code>kEventControlSetFocusPart</code>, <code>kEventMenuBecomeScrollable</code> , <code>kEventMenuCeaseToBeScrollable</code><code>kEventScrollableScrollTo</code> and <code>kEventControlSimulateHit</code>. See <span class="content_text"><a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-TPXREF128">“Optional Menu Definition Events”</a></span> for more details. </p></li><li class="nested li"><p>Handles <code>kEventControlClick</code> by returning <code>paramErr</code>. Doing so prevents clicks in the menu view from invoking the Control Manager’s default tracking. The Menu Manager handles all menu tracking instead. </p></li><li class="nested li"><p>Handles <code>kEventControlHit</code> by returning <code>paramErr</code>. Doing so prevents <code>kEventControlHit</code> events generated by clicks in the menu from being sent to the application.</p></li></ul><p>You should subclass from the base class if your menu contains unusual items (such as buttons, sliders, and so on) or requires specialized tracking.</p></li><li class="li"><p><code>HIStandardMenuView</code> is the class for the standard Aqua-compliant menu. That is, it assumes that you are displaying conventional menu items. It provides handlers for standard menu display, tracking, and selection. </p></li></ul><p>Use the <code>HIObjectRegisterSubclass</code> function to register your custom subclasses. </p><p>You create your custom menus by calling <code>CreateCustomMenu</code>, just as if you were creating an MDEF-based menu. However, instead of providing a pointer to your menu definition, you must specify a class ID and an (optional) initialization event for your custom menu in the menu definition specification. </p><div class="codesample"><table><tr><td scope="row"><pre>enum {kMenuDefClassID = 1};<span></span></pre></td></tr><tr><td scope="row"><pre>struct MenuDefSpec<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    MenuDefType defType;<span></span></pre></td></tr><tr><td scope="row"><pre>    union<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        MenuDefUPP defProc;<span></span></pre></td></tr><tr><td scope="row"><pre>        struct<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            CFStringRef classID;<span></span></pre></td></tr><tr><td scope="row"><pre>            EventRef initEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>            }view;<span></span></pre></td></tr><tr><td scope="row"><pre>        }u;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>When it comes time to display the menu, the system calls <code>HIObjectCreate</code>, passing in the class ID and the initialization event you specified in the menu definition specification. </p><p>As with any custom view, you must register your view subclass before use, assigning it a unique class ID and specifying the events that your view will handle.</p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF122" title="Required Menu Definition Events"></a><h4>Required Menu Definition Events</h4><p>All view-based menus must handle a number of different events. Note, however, that the hit-test, draw, and get part events may be handled by views embedded within the menu content view rather than the view itself. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF123" title="kEventControlGetOptimalBounds"></a><h5>kEventControlGetOptimalBounds</h5><p>The Menu Manager sends this event to determine the size of your menu content view. Your view should return its dimensions in the <code>kEventParamControlOptimalBounds</code> parameter. Note that the optimal bounds may differ from the view bounds you receive from <code>HIViewGetBounds</code>. The latter may display only part of the complete menu, requiring the user to scroll up or down to view all the contents. For efficiency, you may want to store this size in the view’s instance data so it can quickly respond to other queries (such as <code>kEventScrollableGetInfo</code>). </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF124" title="kEventScrollableGetInfo"></a><h5>kEventScrollableGetInfo</h5><p>Your menu should return the following information:</p><ul class="spaceabove"><li class="li"><p>The total image size of the menu, as determined in response to the <code>kEventControlGetOptimalBounds</code> event. </p></li><li class="li"><p>The menu’s view size, which is the bounds returned by <code>HIViewGetBounds</code>. You can think of this as the visible part of the total menu. If the entire menu cannot fit onscreen, the user must scroll to see the rest of it. </p></li><li class="li"><p>Its scrolling line size, which should be the size of an individual menu item.</p></li><li class="li"><p>Its bounds origin, which you can determine from <code>HIViewGetBounds</code>. </p></li></ul><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF125" title="kEventControlDraw"></a><h5>kEventControlDraw</h5><p>Your menu should draw its menu items when receiving this event. The event supplies a Core Graphics context (<code>CGContext</code>) in which to draw, as well as an invalid region, which you should use to determine what parts need to be redrawn. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF126" title="kEventControlHitTest"></a><h5>kEventControlHitTest</h5><p>The Menu Manager sends this event during menu tracking to determine which item is currently underneath the mouse cursor. Your menu should return the index of the menu item under the specified point in the part code parameter. If no menu item is underneath the point, return 0. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF127" title="kEventControlGetPartRegion"></a><h5>kEventControlGetPartRegion</h5><p>The Menu Manager sends this event to determine the bounds of a menu item. Your menu should update the region parameter to include the bounds of the menu item specified by the part code parameter. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF128" title="Optional Menu Definition Events"></a><h4>Optional Menu Definition Events</h4><p>If you subclass your custom menu from the HIMenuView class, you do not need to implement these events unless you want to override the default behavior. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF129" title="kEventMenuCreateFrameView"></a><h5>kEventMenuCreateFrameView</h5><p>The Menu Manager sends this event when it needs to create a menu (typically just before it is shown for the first time). You should return the HIView reference of the window that is to contain the menu content view. Note that your window must also contain a content view within which the Menu Manager will embed the menu content view. </p><p>The default handler returns the HIView reference for a standard window frame view for menus. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF130" title="kEventMenuGetFrameBounds"></a><h5>kEventMenuGetFrameBounds</h5><p>The Menu Manager sends this event when it is ready to display the menu. you should calculate the appropriate bounds for your menu and return it in the <code>kEventParamBounds</code> parameter.</p><p>The default handler calculates and returns an appropriate bounding rectangle based on the menu bounds, the available screen space, and the frame metrics of the menu window’s content view. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF131" title="kEventMenuBecomeScrollable"></a><h5>kEventMenuBecomeScrollable</h5><p>The Menu Manager sends this event to the most recently-opened menu in the menu hierarchy to indicate that this menu should become scrollable. You should install the appropriate event handlers on the menu content view, content view, or frame view, to implement scrolling support. </p><p>The default handler installs event handlers to provide automatic scrolling for view-based menus. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF132" title="kEventMenuCeaseToBeScrollable"></a><h5>kEventMenuCeaseToBeScrollable</h5><p>The Menu Manager sends this event when a menu is no longer the most recently-opened menu, and therefore should not allow scrolling. This occurs when a menu is closed, or if the user selects a submenu of the menu. You should remove whatever handlers you installed to enable scrolling for that menu. </p><p>The default handler removes the event handlers that implement automatic scrolling for view-based menus. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF133" title="kEventScrollableScrollTo"></a><h5>kEventScrollableScrollTo</h5><p>The Menu Manager sends this event to indicate that the menu needs to be scrolled. You should implement any customized scrolling. Note that you can also use this event if you need to keep track of the origin of the view bounds.</p><p>The default handler changes the origin of the view bounds and then invalidates the entire menu content view. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF134" title="kEventControlSetFocusPart"></a><h5>kEventControlSetFocusPart</h5><p>The Menu Manager sends this event during menu tracking to highlight a menu item as the mouse enters its bounds and unhighlight it as it leaves. Your handler should determine the area of the part gaining or losing focus (that is, the invalid region). Then the handler should call <code>HIViewSetNeedsDisplayInRegion</code>, passing the invalid region. The Control Manager then sends a <code>kEventControlDraw</code> event to your view with the invalid region stored in the <code>kEventParamRgnHandle</code> parameter. Your drawing handler can then update the focus area appropriately. </p><p>The default handler calls <code>GetControlRegion</code> to determine the region of the item gaining or losing focus, and then calls <code>HIViewSetNeedsDisplayInRegion</code> with the total invalid region. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF135" title="kEventControlSimulateHit"></a><h5>kEventControlSimulateHit</h5><p>The Menu Manager sends this event when the user selects a menu item. Your handler should display some sort of feedback to acknowledge the selection. </p><p>The default handler flashes the selected menu item off and on. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-CJBDHFCC" title="Menu Definition Events Versus Older MDEF Messages"></a><h4>Menu Definition Events Versus Older MDEF Messages</h4><p>If you have older custom menu code that uses MDEF messages, you should convert them to use Carbon events instead. <span class="content_text">Table 2-2</span> shows the correspondence between MDEF messages and their Carbon event equivalents.</p><a name="//apple_ref/doc/uid/TP30000923-CH205-CJBBJAFG" title="Table 2-2Carbon events versus MDEF messages"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-2&nbsp;&nbsp;</strong>Carbon events versus MDEF messages</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>MDEF Message</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Carbon Event</p></th></tr><tr><td  scope="row"><p><code>kMenuInitMsg</code></p></td><td ><p><code>kEventControlInitialize</code></p></td></tr><tr><td  scope="row"><p><code>kMenuDisposeMsg</code></p></td><td ><p><code>kEventControlDispose</code></p></td></tr><tr><td  scope="row"><p><code>kMenuFindItemMsg</code></p></td><td ><p><code>kEventControlHitTest</code></p></td></tr><tr><td  scope="row"><p><code>kMenuHiliteItemMsg</code></p></td><td ><p><code>kEventControlSetFocusPart</code></p></td></tr><tr><td  scope="row"><p><code>kMenuDrawItemsMsg</code></p></td><td ><p><code>kEventControlDraw</code></p></td></tr><tr><td  scope="row"><p><code>kMenuDrawMsg</code></p></td><td ><p><code>kEventControlDraw</code></p></td></tr><tr><td  scope="row"><p><code>kMenuSizeMsg</code></p></td><td ><p><code>kEventControlGetOptimalBounds</code>, <code>kEventScrollableGetInfo</code></p></td></tr><tr><td  scope="row"><p><code>kMenuPopUpMsg</code></p></td><td ><p><code>kEventMenuGetFrameBounds</code></p></td></tr><tr><td  scope="row"><p><code>kMenuCalcItemMsg</code></p></td><td ><p><code>kEventControlGetPartRegion</code></p></td></tr><tr><td  scope="row"><p><code>kMenuThemeSavvyMsg</code></p></td><td ><p>No equivalent</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000923-CH205-TPXREF136" title="A Custom Menu View Example"></a><h4>A Custom Menu View Example</h4><p>As custom menu view is an HIView, you can conceivably put anything into the menu that you could put into a window content view, even standard controls. This example creates a menu view that contains a standard push button.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000923-CH205-DontLinkElementID_23" title="Note"></a><p><strong>Note:</strong>&nbsp;Placing controls in menus violates the current Aqua human interface guidelines; this example is for illustrative purposes only. You should consult the Aqua guidelines before adding any custom user interface elements to your application. </p></div><p><span class="content_text">Listing 2-11</span> shows the event handers that make up the menu definition. </p><a name="//apple_ref/doc/uid/TP30000923-CH205-BAJCCIHC" title="Listing 2-11Menu view event handlers"></a><p class="codesample"><strong>Listing 2-11&nbsp;&nbsp;</strong>Menu view event handlers</p><div class="codesample"><table><tr><td scope="row"><pre>typedef struct<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    HIViewRef           view;<span></span></pre></td></tr><tr><td scope="row"><pre>    HIViewRef           button;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>MyMenuData;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static const EventTypeSpec  kMyMenuEvents[] =<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    { kEventClassHIObject, kEventHIObjectConstruct },<span></span></pre></td></tr><tr><td scope="row"><pre>    { kEventClassHIObject, kEventHIObjectDestruct },<span></span></pre></td></tr><tr><td scope="row"><pre>    { kEventClassControl, kEventControlInitialize },<span></span></pre></td></tr><tr><td scope="row"><pre>    { kEventClassControl, kEventControlBoundsChanged },<span></span></pre></td></tr><tr><td scope="row"><pre>    { kEventClassControl, kEventControlGetOptimalBounds },<span></span></pre></td></tr><tr><td scope="row"><pre>    { kEventClassScrollable, kEventScrollableGetInfo }<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static pascal OSStatus MyMenuHandler( EventHandlerCallRef inCaller,<span></span></pre></td></tr><tr><td scope="row"><pre>                        EventRef inEvent, void* inRefcon )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus    err = eventNotHandledErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    MyMenuData* data = (MyMenuData*) inRefcon;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch ( GetEventClass( inEvent ) )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventClassHIObject:<span></span></pre></td></tr><tr><td scope="row"><pre>            switch ( GetEventKind( inEvent ) )<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventHIObjectConstruct:<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    data = (MyMenuData*) calloc( 1, sizeof( MyMenuData ) );<span></span></pre></td></tr><tr><td scope="row"><pre>                    require_action( data != NULL, CouldntAllocData,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    err = memFullErr );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                    GetEventParameter(inEvent,kEventParamHIObjectInstance,<span></span></pre></td></tr><tr><td scope="row"><pre>                            typeHIObjectRef, NULL, sizeof( data->view ),<span></span></pre></td></tr><tr><td scope="row"><pre>                            NULL, &amp;data->view );<span></span></pre></td></tr><tr><td scope="row"><pre>                    SetEventParameter(inEvent,kEventParamHIObjectInstance,<span></span></pre></td></tr><tr><td scope="row"><pre>                             typeVoidPtr, sizeof( data ), &amp;data );<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventHIObjectDestruct:<span></span></pre></td></tr><tr><td scope="row"><pre>                    free( (void*) data );<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventClassControl:<span></span></pre></td></tr><tr><td scope="row"><pre>            switch ( GetEventKind( inEvent ) )<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventControlInitialize:<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    Rect        bounds = { 0, 0, 0, 0 };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                    err = CreatePushButtonControl( NULL, &amp;bounds,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     CFSTR("Beep!"), &amp;data->button );<span></span></pre></td></tr><tr><td scope="row"><pre>                    require_noerr( err, CouldntCreateButton );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                    HIViewAddSubview( data->view, data->button);<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventControlGetOptimalBounds:<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    HIRect bounds = { { 0, 0 }, { 90, 100} };<span></span></pre></td></tr><tr><td scope="row"><pre>                    SetEventParameter( inEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 kEventParamControlOptimalBounds,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 typeHIRect, sizeof( bounds ), &amp;bounds );<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventControlBoundsChanged:<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    HIRect bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>                    HIViewGetBounds( data->view, &amp;bounds );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                    HIRect frame;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                    frame.origin.x = 10;<span></span></pre></td></tr><tr><td scope="row"><pre>                    frame.origin.y = bounds.size.height/2 - 10;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                    frame.size.height = 20;<span></span></pre></td></tr><tr><td scope="row"><pre>                    frame.size.width = bounds.size.width - 20;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                    HIViewSetFrame( data->button, &amp;frame );<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kEventClassScrollable:<span></span></pre></td></tr><tr><td scope="row"><pre>            switch ( GetEventKind( inEvent ) )<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                case kEventScrollableGetInfo:<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    HIRect bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>                    HIPoint origin = { 0, 0 };<span></span></pre></td></tr><tr><td scope="row"><pre>                    HIViewGetBounds( data->view, &amp;bounds );<span></span></pre></td></tr><tr><td scope="row"><pre>                    SetEventParameter( inEvent, kEventParamImageSize,<span></span></pre></td></tr><tr><td scope="row"><pre>                         typeHISize, sizeof( bounds.size ), &amp;bounds.size );<span></span></pre></td></tr><tr><td scope="row"><pre>                    SetEventParameter( inEvent, kEventParamViewSize,<span></span></pre></td></tr><tr><td scope="row"><pre>                         typeHISize, sizeof( bounds.size ), &amp;bounds.size );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                    bounds.size.height = 20;    // arbitrary<span></span></pre></td></tr><tr><td scope="row"><pre>                    SetEventParameter( inEvent, kEventParamLineSize,<span></span></pre></td></tr><tr><td scope="row"><pre>                         typeHISize, sizeof( bounds.size ), &amp;bounds.size );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                    SetEventParameter( inEvent, kEventParamOrigin,<span></span></pre></td></tr><tr><td scope="row"><pre>                         typeHIPoint, sizeof( origin ), &amp;origin );<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CouldntCreateButton:<span></span></pre></td></tr><tr><td scope="row"><pre>CouldntAllocData:<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is how the code works:</p><ol class="ol"><li class="li"><p>The custom menu code must define its instance data in a structure. In this example, the only instance data that we need to store are the HIView references for the custom menu and the button embedded within it.</p></li><li class="li"><p>This custom menu event handler handles the usual HIObject construct and destruct events as well as most of the events required for view-based menus. Note that it does not implement handlers for <code>kEventControlDraw</code>, <code>kEventControlHitTest</code>, or <code>kEventControlGetPartRegion</code>, as these events are handled by the push button control’s handlers.</p></li><li class="li"><p>The instance data is passed to your handler in the <code>refCon</code> parameter. </p></li><li class="li"><p>The construct event allocates enough memory to hold the menu’s instance data. As is typical, you call <code>GetEventParameter</code> to obtain the default instance data for the HIObject, which you store in the view field of your actual instance data. Then call <code>SetEventParameter</code> to set the instance data to be the entire data structure you allocated. This data is passed to your event handler for subsequent events. </p></li><li class="li"><p>The destruct event handler simply frees the instance data associated with the custom menu. You do not need to dispose of the actual views, as this occurs automatically when the view hierarchy is released. </p></li><li class="li"><p>When it comes time to create the custom menu view, you can choose to add additional initialization steps by creating a <code>kEventControlInitialize</code> handler. The control in this case is the menu content view. This example creates a push button control to embed in the menu content view. The HIView reference of the button is stored as part of the custom menu’s instance data. The <code>HIViewAddSubview</code> function does the actual embedding.</p><p>Note that at this point, neither the menu content view nor the button have size or relative position (that is, bounds). The menu content view’s bounds are set when the Menu Manager is ready to display it. </p><p>Instead of using <code>kEventControlInitialize</code>, you could also handle this initialization in a <code>kEventHIObjectInitialize</code> event. </p></li><li class="li"><p>When the Menu Manager is ready to display the custom menu, it sends the <code>kEventControlGetOptimalBounds</code> event to the menu content view to determine its proper size. The event handler uses <code>SetEventParameter</code> to return the bounds in the <code>kEventParamControlOptimalBounds</code> parameter. Note that these bounds are of type <code>HIRect</code>, which uses different fields than the older <code>Rect</code> type. </p><p>Note that the baseline offset, which you can also return for this event, does not apply for menus. </p></li><li class="li"><p>When the bounds change in response to what is returned for the <code>kEventControlGetOptimalBounds</code> event, the Menu Manager sends the <code>kEventControlBoundsChanged</code> event to the menu content view. You can use this event to position any additional views that are embedded within the content view. This example calls <code>HIViewGetBounds</code> to obtain the bounds of the menu content view. It uses these bounds to calculate a position and width for the embedded push button (centered within the menu and sized to leave 10 pixel borders to either side of the button). Calling <code>HIViewSetFrame</code> sets the frame coordinates for the button. </p></li><li class="li"><p>The Menu Manager sends the <code>kEventScrollableGetInfo</code> event when it needs to lay out a menu or scroll an existing one. This example sets the following values:</p><ul class="ul"><li class="li"><p>The image size is the total size of the menu, set in the <code>kEventParamImageSize</code> parameter. </p></li><li class="li"><p>The view size is the bounds of the currently visible portion of the menu, set in the <code>kEventParamViewSize</code> parameter. Because this menu is not designed to be scrollable, the view bounds and the image bounds are identical.</p></li><li class="li"><p>The line size is the size of an individual menu item, set in the <code>kEventParamLineSize</code> parameter. Because this menu doesn’t have individual menu items, the line size doesn’t matter.</p></li><li class="li"><p>The origin, set in the <code>kEventParamOrigin</code> parameter. Because the image size and the view size are identical, the origin for this menu content view is always at 0,0. If the image and view sizes were different (that is, the menu can be scrolled) then the origin reflects the frame coordinates of the top left corner of the currently visible portion of the menu).</p></li></ul><p>Note that the size values passed are of type <code>HISize</code>, not <code>HIRect</code>. </p></li></ol><p>You could use the function in <span class="content_text">Listing 2-12</span> to register, instantiate, and insert your custom menu:</p><a name="//apple_ref/doc/uid/TP30000923-CH205-BAJHIBIJ" title="Listing 2-12Creating a custom menu"></a><p class="codesample"><strong>Listing 2-12&nbsp;&nbsp;</strong>Creating a custom menu</p><div class="codesample"><table><tr><td scope="row"><pre>#define kMyCustomMenuViewClassID CFSTR("com.apple.sample.kMyCustomMenuClassID")<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus MyCreateCustomMenu (MenuID theID)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    MenuDefSpec     defSpec;<span></span></pre></td></tr><tr><td scope="row"><pre>    MenuRef         theMenu;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    HIObjectClassRef theClassIDRef;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus        err;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    HIObjectRegisterSubclass( kMyCustomMenuViewClassID,<span></span></pre></td></tr><tr><td scope="row"><pre>                        kHIMenuViewClassID, kNilOptions, MyMenuHandler,<span></span></pre></td></tr><tr><td scope="row"><pre>                        GetEventTypeCount( kMyMenuEvents ), kMyMenuEvents,<span></span></pre></td></tr><tr><td scope="row"><pre>                        NULL, &amp;theClassIDRef );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    defSpec.defType = kMenuDefClassID;<span></span></pre></td></tr><tr><td scope="row"><pre>    defSpec.u.view.classID = kMyCustomMenuViewClassID;<span></span></pre></td></tr><tr><td scope="row"><pre>    defSpec.u.view.initEvent = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    err = CreateCustomMenu( &amp;defSpec, 0, 0, &amp;theMenu );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( err == noErr ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        SetMenuTitleWithCFString( theMenu, CFSTR("Button") );<span></span></pre></td></tr><tr><td scope="row"><pre>        InsertMenu( theMenu, theID );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is how the code works:</p><ol class="ol"><li class="li"><p>The class ID of your custom menu must be a unique CFString. </p></li><li class="li"><p>Call <code>HIObjectRegisterSubclass</code> to register your custom menu, just as you would for any HIObject. This custom menu is subclassed from the base HIMenuView class (<code>kHIMenuViewClassID</code>). The event handler is the function described in <span class="content_text"><a href="HIView_tasks.html#//apple_ref/doc/uid/TP30000923-CH205-BAJCCIHC">Listing 2-11</a></span>.</p></li><li class="li"><p>Specify <code>kMenuDefClassID</code> in the menu definition specification structure to indicate that this is an HIObject-based custom menu. </p></li><li class="li"><p><code>kMyCustomMenuViewClassID</code>, the class of menu to instantiate, is the class registered in step 2. </p></li><li class="li"><p>This custom menu has no HIObject initialization event, so set this field in the menu definition specification to <code>NULL</code>.</p></li><li class="li"><p>Create an instance of the custom menu by calling <code>CreateCustomMenu</code> with the specified menu definition specification. </p></li><li class="li"><p>Call <code>SetMenuTitleWithCFString</code> to assign a title to the menu. If you don’t assign a title, the corresponding space in the menu bar appears blank (although clicking in the appropriate region still activates the menu). </p></li><li class="li"><p>Call <code>InsertMenu</code> to insert the custom menu into the current menu list.</p></li></ol>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../HIView_concept/HIView_concept.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../HIView_apdx_a_history/HIView_apdx_a_history.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-10-31<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/HIViewDoc/HIView_tasks/HIView_tasks.html%3Fid%3DTP30000923-2.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/HIViewDoc/HIView_tasks/HIView_tasks.html%3Fid%3DTP30000923-2.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/HIViewDoc/HIView_tasks/HIView_tasks.html%3Fid%3DTP30000923-2.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>