/*	File:		windows.c	Contains:		Written by: Jason Hodges-Harris					Copyright:	Copyright © 1995-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/28/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				*/// Mac Toolbox headers#ifndef __DESK__#include <Desk.h>#endif#ifndef __DIALOGS__#include <Dialogs.h>#endif#ifndef __MEMORY__#include <Memory.h>#endif#ifndef __MOVIES__#include <Movies.h>#endif#ifndef __TEXTUTILS__#include <TextUtils.h>#endif#ifndef __WINDOWS__#include <Windows.h>#endif// Program headers#ifndef __CHROMAPPHEADER__#include "ChromaKeyMovie.h"#endif//	Global Variablesextern Boolean			gDone;extern Boolean			gMovieOpen;extern GWorldPtr		gOffscreenPort,						gBackGroundPort,						gBackGroundPicture;extern PixMapHandle		gMoviePixmap,						gBackGndPixmap,						gBackGndPictPM; /* The DisplayAlert() function is a generic modal dialog display function    which uses GetStdFilterProc() and SetDialogDefaultItem() to    automatically get the standard filter and outline the default DITL item.    These 'undocumented' functions are available in system 7.0 or later. */  #pragma segment Windowslong DisplayAlert (short dialogID,short errStrID,short StrIDindex){	GrafPtr			savePort = nil;	DialogPtr		myDialog = nil;	ModalFilterUPP	theFilter = nil;	Str255			theTextStr;	short			alertResponse;		myDialog = GetNewDialog(dialogID,nil,((WindowPtr)-1L));	// get dialog resource	GetPort(&savePort);	SetPort	(myDialog);	if (GetStdFilterProc(&theFilter) !=noErr)		DebugStr("\pFailed to get standard dialog filter.");	SetDialogDefaultItem(myDialog,1);	/* If the errStrID variable contains 0, the dialog doesn't	   require any text from a STR# resource */	if (errStrID!=0)		// get STR# resource text	{		GetIndString(theTextStr,errStrID,StrIDindex);		ParamText(theTextStr,"\p","\p","\p");	}	do{		ModalDialog(theFilter,&alertResponse);	} while (alertResponse==0);	DisposeDialog(myDialog);//	dispose dialog mem allocation	SetPort(savePort);			return alertResponse;	// return dialog return value}// Drag the window from the position passed in the mouseLoc parameter #pragma segment Windowsvoid DragSelWind(WindowPtr window,Point mouseLoc){	Rect	dragBounds;		dragBounds=(**GetGrayRgn()).rgnBBox;	DragWindow(window,mouseLoc,&dragBounds);}// Close the active window which had it's close box selected#pragma segment Windowsvoid DoGoAwayWind(WindowPtr window,Point mouseLoc){	if(TrackGoAway(window,mouseLoc))	{		if (window!=nil)		{			// Test for a dialog window and hide if selected			if ((((WindowPeek)window)->windowKind)==2) 				HideWindow(window);			// Test for a Desk Accessory window and Close.			else if ((((WindowPeek)window)->windowKind)<0) 				CloseDeskAcc(((WindowPeek)window)->windowKind);			// Test for an application window.			else if ((((WindowPeek)window)->windowKind)==8)				{				DisposeWindowDocs (window);			}		}	}}// Close an application window#pragma segment Windowsvoid DisposeWindowDocs (WindowPtr window){	MovieDocHndl		myRefcon;	// check if the window to close is a valid Document window	if ((myRefcon=(MovieDocHndl)GetWRefCon(window)) ==		(MovieDocHndl)(((WindowPeek)window)->refCon))	{		// dispose of the window document structure		DisposeMovie((**myRefcon).theMovie);		DisposeHandle((Handle)myRefcon);		DisposeWindow(window);		// Unlock and Dispose the offscreen GWorlds		if (gOffscreenPort)		{			UnlockPixels(gMoviePixmap);			UnlockPixels(gBackGndPixmap);			UnlockPixels(gBackGndPictPM);			DisposeGWorld(gOffscreenPort);			DisposeGWorld(gBackGroundPort);			DisposeGWorld(gBackGroundPicture);			gBackGroundPicture = gBackGroundPort = gOffscreenPort = nil;			DoAdjustFileMenu();		}	}}// Update "dirty" open window#pragma segment Windowsvoid	DoWindUpdate(WindowPtr theWindow){	MovieDocHndl		myRefcon = nil;	PixMapHandle		updatePixMapH = nil;	WindowPtr			oldPort;		GetPort(&oldPort);				// get old window port	SetPort(theWindow);				// set to port with update event request	BeginUpdate(theWindow);			// start update process 	// update the current window's movie 	UpdateMovie((**(MovieDocHndl)GetWRefCon(theWindow)).theMovie);	EndUpdate(theWindow);			// end update process	SetPort (oldPort);				// reset active window port}// Open a Movie window, allocate the document structure and place into the window's refCon field.#pragma segment WindowsCWindowPtr	OpenCWindow(void){	CWindowPtr			theWindow;	MovieDocHndl		theDocHndl;	Rect				theRect = {0,0,100,100};		theDocHndl = (MovieDocHndl)NewHandle(sizeof(MovieDoc));	if (theDocHndl == nil)			DisplayAlert (rGenAlert,rErrMessages,3);	else	{		theWindow = (CWindowPtr)GetNewCWindow(rGenWindow,nil,(WindowPtr)-1L);		SetWRefCon((WindowPtr)theWindow,(long)theDocHndl);	// set refcon to doc handle	}	return theWindow;}