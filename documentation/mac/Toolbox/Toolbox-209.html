<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Zooming a Window(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING209></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-208.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-210.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-188.html"><B>Chapter 4 - Window Manager</B></A> / <A HREF="Toolbox-201.html"><B>Using the Window Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING209-0></A>
<H2><A NAME=MARKER-9-225></A>Zooming a Window</H2>
 <A NAME=MARKER-2-81></A>The zoom box allows the user to alternate quickly between two window positions and sizes: the <DFN>user state</DFN> and the <DFN>standard state.</DFN><P>
 The <B>user state</B> is the window size and location established by the user. If your application does not supply an initial user state, the user state is simply the size and location of the window when it was created, until the user resizes it.<A NAME=MARKER-2-424></A><P>
 The <B>standard state</B> is the window size and location that your application considers most convenient, considering the function of the document and the screen space available. In a word-processing application, for example, a standard-state window might show a <BR>full page, if possible, or a page of full width and as much length as fits on the screen. <BR>If the user changes the page size through Page Setup, the application might adjust the standard state to reflect the new page size. If your application does not define a standard state, the Window Manager automatically sets the standard state to the entire gray region on the main screen, minus a three-pixel border on all sides. (See Macintosh Human Interface Guidelines for a detailed description of how your application determines where to open and zoom windows.) The user cannot change a window's standard state<A NAME=MARKER-2-228></A>.<P>
 The user and standard states are stored in a record whose handle appears in the <CODE>dataHandle</CODE> field of the window record.<P>
<PRE>
TYPE WStateData = 
   RECORD
      userState:  Rect;    {size and location established by user}
      stdState:   Rect;    {size and location established by }
                           { application}
   END;
</PRE>
 The Window Manager sets the initial values of the <CODE>userState</CODE> and <CODE>stdState</CODE> fields when it fills in the window record, and it updates the <CODE>userState</CODE> field whenever the user resizes the window. You typically compute the standard state every time the user zooms to the standard state, to ensure that you're zooming to an appropriate location.<P>
 When the user presses the mouse button with the cursor in the zoom box, the <CODE>FindWindow</CODE> function specifies whether the window is in the user state or the standard state: when the window is in the standard state, <CODE>FindWindow</CODE> returns <CODE>inZoomIn</CODE> (meaning that the window is to be zoomed "in" to the user state); when the window is in the user state, <CODE>FindWindow</CODE> returns <CODE>inZoomOut</CODE> (meaning that the window is to be zoomed "out" to the standard state).<P>
 When <CODE>FindWindow</CODE> returns either <CODE>inZoomIn</CODE> or <CODE>inZoomOut</CODE>, your application can call the <CODE>TrackBox</CODE> function to handle the highlighting of the zoom box and to determine whether the cursor is inside or outside the box when the button is released. If <CODE>TrackBox</CODE> returns <CODE>TRUE</CODE>, your application can call the <CODE>ZoomWindow</CODE> procedure to resize the window (after computing a new standard state). If <CODE>TrackBox</CODE> returns <CODE>FALSE</CODE>, your application doesn't need to do anything. <A HREF=Toolbox-207.html#MARKER-9-200>Listing 4-9</A> on <A HREF=Toolbox-207.html#MARKER-9-200>page 4-39</A> illustrates the use of <CODE>TrackBox</CODE> in an event-handling routine.<P>
 <A HREF=#MARKER-9-231>Listing 4-12</A> illustrates an application-defined procedure, <CODE>DoZoomWindow</CODE>, which an application might call when<DFN> <CODE>TrackBox</CODE></DFN> returns <CODE>TRUE</CODE> after <CODE>FindWindow</CODE> returns either <CODE>inZoomIn</CODE> or <CODE>inZoomOut</CODE>. Because the user might have moved the window to a different screen since it was last zoomed, the procedure first determines which screen contains the largest area of the window and then calculates the ideal window size for that screen before zooming the window.<A NAME=MARKER-9-220></A> <P>
 The screen calculations in the <CODE>DoZoomWindow</CODE> procedure depend on the routines for handling graphics devices that were introduced at the same time as Color QuickDraw. Therefore, <CODE>DoZoomWindow</CODE> checks for the presence of Color QuickDraw before comparing the window to be zoomed with the graphics devices in the device list. If Color QuickDraw is not available, <CODE>DoZoomWindow</CODE> assumes that it's running on a computer with a single screen.<A NAME=MARKER-2-138></A><P>
<B>Listing 4-12  <A NAME=MARKER-9-231></A>Zooming a window</B><P>
<PRE>
PROCEDURE DoZoomWindow (thisWindow: windowPtr; zoomInOrOut: Integer);
VAR
   gdNthDevice, gdZoomOnThisDevice: GDHandle;
   savePort:                        GrafPtr;
   windRect, zoomRect, theSect:     Rect;
   sectArea, greatestArea:          LongInt;
   wTitleHeight:                    Integer;
   sectFlag:                        Boolean;
BEGIN
   GetPort(savePort);
   SetPort(thisWindow);
   EraseRect(thisWindow^.portRect);    {erase to avoid flicker}
   IF zoomInOrOut = inZoomOut THEN     {zooming to standard state}
   BEGIN
      IF NOT gColorQDAvailable THEN    {assume a single screen and }
      BEGIN                            { set standard state to full screen}
         zoomRect := screenBits.bounds;
         InsetRect(zoomRect, 4, 4);
         WStateDataHandle(WindowPeek(thisWindow)^.dataHandle)^^.stdState
                                                               := zoomRect;
      END
      ELSE                    {locate window on available graphics devices}
      BEGIN
         windRect := thisWindow^.portRect;
         LocalToGlobal(windRect.topLeft);    {convert to global coordinates}
         LocalToGlobal(windRect.botRight);
         {calculate height of window's title bar}
         wTitleHeight := windRect.top - 1 -
                      WindowPeek(thisWindow)^.strucRgn^^.rgnBBox.top;
         windRect.top := windRect.top - wTitleHeight;
         gdNthDevice := GetDeviceList;
         greatestArea := 0;         {initialize to 0}
         {check window against all gdRects in gDevice list and remember }
         { which gdRect contains largest area of window}
         WHILE gdNthDevice &lt;&gt; NIL DO
         IF TestDeviceAttribute(gdNthDevice, screenDevice) THEN
            IF TestDeviceAttribute(gdNthDevice, screenActive) THEN
            BEGIN
               {The SectRect routine calculates the intersection }
               { of the window rectangle and this gDevice }
               { rectangle and returns TRUE if the rectangles intersect, }
               { FALSE if they don't.}
               sectFlag := SectRect(windRect, gdNthDevice^^.gdRect,
                                     theSect);
               {determine which screen holds greatest window area}
               {first, calculate area of rectangle on current device}
               WITH theSect DO   
                  sectArea := LongInt(right - left) * (bottom - top);
               IF sectArea &gt; greatestArea THEN
               BEGIN
                  greatestArea := sectArea;  {set greatest area so far}
                  gdZoomOnThisDevice := gdNthDevice;  {set zoom device}
               END;
               gdNthDevice := GetNextDevice(gdNthDevice);
            END;  {of WHILE}
         {if gdZoomOnThisDevice is on main device, allow for menu bar height}
         IF gdZoomOnThisDevice = GetMainDevice THEN
            wTitleHeight := wTitleHeight + GetMBarHeight;
         WITH gdZoomOnThisDevice^^.gdRect DO    {create the zoom rectangle}
         BEGIN
            {set the zoom rectangle to the full screen, minus window title }
            { height (and menu bar height if necessary), inset by 3 pixels}
            SetRect(zoomRect, left + 3, top + wTitleHeight + 3,
                   right - 3, bottom - 3);
            {If your application has a different &quot;most useful&quot; standard }
            { state, then size the zoom window accordingly.}
            {set up the WStateData record for this window}
            WStateDataHandle(WindowPeek(thisWindow)^.dataHandle)^^.stdState
                                                                := zoomRect;
         END;
      END;
   END; {of inZoomOut}
   {if zoomInOrOut = inZoomIn, just let ZoomWindow zoom to user state}
   {zoom the window frame}
   ZoomWindow(thisWindow, zoomInOrOut, (thisWindow = FrontWindow));
   MyResizeWindow(thisWindow);   {application-defined window-sizing routine}
   SetPort(savePort);
END; (of DoZoomWindow)
</PRE>
 If the user is zooming the window to the standard state, <CODE>DoZoomWindow</CODE> calculates a new standard size and location based on the application's own considerations, the current location of the window, and the available screens. The <CODE>DoZoomWindow</CODE> procedure always places the standard state on the screen where the window is currently displayed or, if the window spans screens, on the screen containing the largest area <BR>of the window.<P>
 The bulk of the code in <A HREF=#MARKER-9-231>Listing 4-12</A> is devoted to determining which screen should display the window in the standard state.<A NAME=MARKER-2-571></A> The sample code shown here establishes <BR>a standard state that simply occupies the gray area on the chosen screen, minus <BR>three pixels on all sides. Your application should establish a standard state appropriate <BR>to its own documents. When calculating the standard state, move the window as little <BR>as possible from the user state. If possible, anchor one corner of the standard state rectangle to one corner of the user state rectangle.<P>
 If the user is zooming the window to the user state, <CODE>DoZoomWindow</CODE> doesn't have to perform any calculations, because the user state rectangle stored in the state data record should represent a valid screen location.<P>
 After calculating the standard state, if necessary, <CODE>DoZoomWindow</CODE> calls the <CODE>ZoomWindow</CODE> procedure to redraw the window frame in the new size and location and then calls the application-defined procedure <CODE>MyResizeWindow</CODE> to redraw the window's content region. <A HREF=Toolbox-210.html#MARKER-9-239>Listing 4-14</A> on <A HREF=Toolbox-210.html#MARKER-9-239>page 4-53</A> shows the <CODE>MyResizeWindow</CODE> procedure.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-208.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-210.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
