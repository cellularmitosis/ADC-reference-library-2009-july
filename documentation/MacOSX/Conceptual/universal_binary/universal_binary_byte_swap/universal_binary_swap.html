<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Universal Binary Programming Guidelines, Second Edition: Swapping Bytes</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Swapping Bytes"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002217-CH243" title="Swapping Bytes"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index-date.html#//apple_ref/doc/uid/TP30000440-TP30000471" target="_top">Mac OS X</a> &gt; <a href="../universal_binary_intro/universal_binary_intro.html#//apple_ref/doc/uid/TP40002217-CH204-TPXREF101">Universal Binary Programming Guidelines, Second Edition</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../universal_binary_diffs/universal_binary_diffs.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../universal_binary_tips/universal_binary_tips.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40002217-CH243-TPXREF101" title="Swapping Bytes"></a><h1>Swapping Bytes</h1>
<p>Two primary byte-ordering methods (or <strong>endian formats</strong>) exist in the world of computing. An endian format specifies how to store the individual bytes of multibyte numerical data in memory. <strong>Big-endian byte ordering</strong> specifies to store multibyte data with its most significant byte first. <strong>Little-endian byte ordering</strong> specifies to store multibyte data with its least significant byte first. The PowerPC processor uses big-endian byte ordering. The x86 processor family uses little-endian byte ordering. By convention, multibyte data sent over the network uses big-endian byte ordering.</p>
<p>If your application assumes that data is in one endian format, but the data is actually in another, then it will interpret the data incorrectly. You will want to analyze your code for routines that read multibyte data (16 bits, 32 bits, or 64 bits) from, or write multibyte data to, disk or to the network, as these routines are sensitive to byte-ordering format. There are two general approaches for handling byte ordering differences: swap bytes when necessary or use XML or another byte-order-independent data format such as those offered by Core Foundation (CFPreferences, CFPropertyList, CFXMLParser).</p>
<p>Whether you should swap bytes or use a byte-order-independent data format depends on how you use the data in your application. If you have an existing file format to support, the binary-compatible solution is to accept the big-endian file format you have been using in your application, and write code that swaps bytes when the file is read or written on an Intel-based Macintosh. If you don’t have legacy files to support, you could consider redesigning your file format to use XML (extensible markup language), XDR (external data representation), or NSCoding (Objective C) to represent data.</p>
<p>This chapter describes why byte ordering matters, gives guidelines for swapping bytes, describes the byte-swapping APIs available in Mac OS X, and provides solutions for most of the situations where byte ordering matters.</p>

<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-284985">Why Byte Ordering Matters</a>
				
			<br/>
			
        
			
			
				<a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-CJBBHCFG">Guidelines for Swapping Bytes</a>
				
			<br/>
			
        
			
			
				<a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-CJBDABGA">Byte-Swapping Routines</a>
				
			<br/>
			
        
			
			
				<a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-290781">Byte-Swapping Strategies</a>
				
			<br/>
			
        
			
			
				<a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-CJBCCJAG">Writing a Callback to Swap Data Bytes</a>
				
			<br/>
			
        
			
			
				<a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-282106">See Also</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002217-CH243-284985" title="Why Byte Ordering Matters"></a><h2>Why Byte Ordering Matters</h2>
<p>The example in this section is designed to show you why byte ordering matters. Take a look at the C data structure defined in <span class="content_text">Listing 3-1</span>. It contains a four-byte integer, a character string, and a two-byte integer. The listing also initializes the structure.</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-289881" title="Listing 3-1A data structure that contains multibyte and single-byte data"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-BCIJCBIB" title="Listing 3-1A data structure that contains multibyte and single-byte data"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>A data structure that contains multibyte and single-byte data</p><div class="codesample"><table><tr><td scope="row"><pre>typedef struct {<span></span></pre></td></tr><tr><td scope="row"><pre>    uint32_t myOptions;<span></span></pre></td></tr><tr><td scope="row"><pre>    char     myStringArray [7];<span></span></pre></td></tr><tr><td scope="row"><pre>    short    myVariable;<span></span></pre></td></tr><tr><td scope="row"><pre>} myDataStructure;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>myDataStructure aStruct;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>aStruct.myOptions = 0xfeedface;<span></span></pre></td></tr><tr><td scope="row"><pre>strcpy(aStruct.myStringArray, "safari");<span></span></pre></td></tr><tr><td scope="row"><pre>aStruct.myVariable = 0x1234;<span></span></pre></td></tr></table></div>
<p><span class="content_text">Figure 3-1</span> compares how this data structure is stored in memory on big-endian and little-endian systems. In a big-endian system, memory is organized with the address of each data byte increasing from most significant to least significant. In a little-endian system, memory is organized with the address of each data byte increasing from the least significant to the most significant.</p>
<br/><div><a name="//apple_ref/doc/uid/TP40002217-CH243-289958" title="Figure 3-1Big-endian byte ordering compared to little-endian byte ordering"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-BCIBFFAD" title="Figure 3-1Big-endian byte ordering compared to little-endian byte ordering"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>Big-endian byte ordering compared to little-endian byte ordering</p><img src = "../art/byte_order.gif" alt = "Big-endian byte ordering compared to little-endian byte ordering" width="422" height="425"></div><br/>
<p>As you look at <span class="content_text">Figure 3-1</span>, note the following:</p>
<ul class="ul"><li class="li"><p>Multibyte data, such as the 32-bit and 16-bit variables shown in the figure, are stored differently between big-endian and little-endian systems. As you can see in the figure, big-endian systems store data in memory so that the most significant byte of the data is stored in the address with the lowest value. Little-endian systems store data in memory so that the most significant byte of the data is in the address with the highest value. Hence, the least significant byte of the <code>myOptions</code> variable (<code>0xce</code>) is stored in memory location <code>0x00000003</code> on the big-endian system while it is stored in memory location <code>0x00000000</code> on the little-endian system.</p></li>
<li class="li"><p>Single-byte data, such as the <code>char</code> values in the <code>myStringArray</code> character array, are stored in the same memory location on either system regardless of the byte ordering format of the system.</p></li>
<li class="li"><p>Each system pads bytes to maintain four-byte data alignment. Padded bytes in the figure are designated by a shaded box that contains an asterisk.</p></li></ul>
<p>The byte ordering of multibyte data in memory matters if you are reading data written on one architecture from a system that uses a different architecture and you access the data on a byte-by-byte basis. For example, if your application is written to access the second byte of the <code>myOptions</code> variable, then when you read the data from a system that uses the opposite byte ordering scheme, you’ll end up retrieving the first byte of the <code>myOptions</code> variable instead of the second one.</p>
<p>Suppose the example data values that are initialized by the code shown in <span class="content_text">Listing 3-1</span> are generated on a little-endian system and saved to disk. Assume that the data is written to disk in byte-address order. When read from disk by a big-endian system, the data is again laid out in memory as shown in <span class="content_text">Figure 3-1</span>. The problem is that the data is still in little-endian byte order even though it is interpreted on a big-endian system. This difference causes the values to be evaluated incorrectly. In this example, the value of the field <code>myOptions</code> should be <code>0xfeedface</code>, but because of the incorrect byte ordering it is evaluated as <code>0xcefaedfe</code>.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40002217-CH243-SW1" title="Note"></a><p><strong>Note:</strong>&nbsp;The terms <em>big-endian</em> and <em>little-endian</em> come from Jonathan Swift’s eighteenth-century satire <em>Gulliver’s Travels</em>. The subjects of the empire of Blefuscu were divided into two factions: those who ate eggs starting from the big end and those who ate eggs starting from the little end.</p></div>
<a name="//apple_ref/doc/uid/TP40002217-CH243-284571" title="Guidelines for Swapping Bytes"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-CJBBHCFG" title="Guidelines for Swapping Bytes"></a><h2>Guidelines for Swapping Bytes</h2>
<p>The following guidelines, along with the strategies provided later in this chapter, will help ensure optimal byte-swapping code in your application.</p>
<ul class="ul"><li class="li"><p>Keep data structures in native byte-order while in memory. Only swap bytes when you read data from disk or write it to disk. </p></li>
<li class="li"><p>When possible, let the compiler do the work for you. For example, when you use function calls such as the Core Foundation function <code><a href="../../../../CoreFoundation/Reference/CFByteOrderUtils/Reference/reference.html#//apple_ref/doc/c_ref/CFSwapInt16BigToHost" target="_top">CFSwapInt16BigToHost</a></code>, the compiler determines whether the function call does something for the processor you are targeting. If the code does nothing, the compiler won’t call the function. Letting the compiler do the work is more efficient than using <code>#ifdef</code> statements.</p></li>
<li class="li"><p>If you must access a large file, consider arranging the data in a way that limits the byte swapping that you must perform. For example, you can arrange the most frequently accessed data contiguously in the file. Then, you need to read and swap bytes only for that chunk of data instead of for the entire data file.</p></li>
<li class="li"><p>Use the <code>__BIG_ENDIAN__</code> and <code>__LITTLE_ENDIAN__</code> macros only if you must. Do not use macros that check for a specific processor type, such as <code>__i386__</code> and <code>__ppc__</code>.</p></li>
<li class="li"><p>Choose a consistent byte-order approach and stick with it. That is, if you are reading and writing data from disk on a regular basis, choose the endian format you want to use. This eliminates the need for you to check the byte ordering of the data, and then to possibly have to swap the byte order.</p></li>
<li class="li"><p>Be aware of which functions return big-endian data, and use them appropriately. These include the BSD Sockets networking functions, the <code>DNSServiceDiscovery</code> functions (for example, TCP and UDP ports are specified in network byte order), and the ColorSync profile functions (for which all data is big-endian). The <code><!--a-->IconFamilyElement<!--/a--></code> and <code>IconFamilyResource</code> data types (which also include the data types <code>IconFamilyPtr</code> and <code>IconFamilyHandle</code>) are always big-endian. There may be other functions and data types that are not listed here. Consult the appropriate API reference for information on data returned by a function. For more information see <span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-291436">“Network-Related Data.”</a></span></p></li>
<li class="li"><p>Keep in mind that swapping bytes comes at a performance cost so swap them only when absolutely necessary. </p></li></ul>
<a name="//apple_ref/doc/uid/TP40002217-CH243-281206" title="Byte-Swapping Routines"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-CJBDABGA" title="Byte-Swapping Routines"></a><h2>Byte-Swapping Routines</h2>
<p>The APIs that provide byte-swapping routines are listed below. For most situations it’s best to use the routines that match the framework you’re programming in. The Core Foundation and Foundation APIs have functions for swapping floating-point values, while the other APIs listed do not.</p>
<ul class="ul"><li class="li"><p>POSIX (Portable Operating System Interface) byte ordering functions (<code>ntohl</code>, <code>htonl</code>, <code>ntohs</code>, and <code>htons</code>) are documented in <em><a href="../../../../Darwin/Reference/ManPages/index.html#//apple_ref/doc/uid/TP40000894" target="_top">Mac OS X Man Pages</a></em>.</p></li>
<li class="li"><p>Darwin byte ordering functions and macros are defined in the header file <code>libkern/OSByteOrder.h</code>. Even though this header is in the kernel framework, it is acceptable to use it from high-level applications.</p></li>
<li class="li"><p>Core Foundation byte-order functions are defined in the header file <code>CoreFoundation/CFByteOrder.h</code> and described in the <em><a href="../../../../CoreFoundation/Reference/CFByteOrderUtils/index.html#//apple_ref/doc/uid/20001449" target="_top">Byte-Order Utilities Reference</a></em>. For details on using these functions, see the <span class="content_text"><a href="../../../../CoreFoundation/Conceptual/CFMemoryMgmt/Tasks/ByteSwapping.html#//apple_ref/doc/uid/20001155" target="_top">Byte Swapping</a></span> article in <em><a href="../../../../CoreFoundation/Conceptual/CFMemoryMgmt/index.html#//apple_ref/doc/uid/10000127i" target="_top">Memory Management Programming Guide for Core Foundation</a></em>.</p></li>
<li class="li"><p>Foundation byte-order functions are defined in the header file <code>Foundation/NSByteOrder.h</code> and described in <em><a href="../../../../Cocoa/Reference/Foundation/ObjC_classic/index.html#//apple_ref/doc/uid/20001091" target="_top">Foundation Framework Reference</a></em>.</p></li>
<li class="li"><p> The Core Endian API is defined in the header file <code>CarbonCore/Endian.h</code> and described in <em><a href="../../../../Carbon/Reference/CoreEndianReference/index.html#//apple_ref/doc/uid/TP40002223" target="_top">Core Endian Reference</a></em>.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002217-CH243-SW2" title="Note"></a><p><strong>Note:</strong>&nbsp;When you use byte-swapping routines, the compiler optimizes your code so that the routines are executed only if they are needed for the architecture on which your code is running.</p></div>
<a name="//apple_ref/doc/uid/TP40002217-CH243-290781" title="Byte-Swapping Strategies"></a><h2>Byte-Swapping Strategies</h2>
<p>The strategy for swapping bytes depends on the format of the data; there is no universal routine that can take care of all byte ordering differences. Any program that needs to swap data must know the data type, the source data endian order, and the host endian order.</p>
<p>This section lists byte-swapping strategies, organized alphabetically, for the following data:</p>
<ul class="ul"><li class="li"><p><span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-290795">“Constants”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-290830">“Custom Apple Event Data”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-290895">“Custom Resource Data”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-291016">“Floating-Point Values”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-291292">“Integers”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-291436">“Network-Related Data”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-291523">“OSType-to-String Conversions”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-291648">“Unicode Text Files”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-297775">“Values in an Array”</a></span></p></li></ul>
<a name="//apple_ref/doc/uid/TP40002217-CH243-290795" title="Constants"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-CJBCFEBH" title="Constants"></a><h3>Constants</h3>
<p>Constants that are part of a compiled executable are in host byte order. You need to swap bytes for a constant only if it is part of data that is not maintained natively or if the constant travels between hosts. In most cases you can either swap bytes ahead of time or let the preprocessor perform any needed math by using shifts or other simple operators.</p>
<p>If you are defining and populating a structure that must use data of a specific endian format in memory, use the <code>OSSwapConst</code> macros and the <code>OSSwap*Const</code> variants defined in the <code>libkern/OSByteOrder.h</code> header file. These macros can be used from high-level applications.</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-290830" title="Custom Apple Event Data"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-BCIDEFIJ" title="Custom Apple Event Data"></a><h3>Custom Apple Event Data</h3>
<p>An Apple event is a high-level event that conforms to the Apple Event Interprocess Messaging Protocol. The Apple Event Manager sends Apple events between applications on the same computer or between applications on remote computers. You can define your own Apple event data types, and send and receive Apple events using the Apple Event Manager API.</p>
<p>Mac OS X manages system-defined Apple event data types for you, handling them appropriately for the currently executing code. You don't need to perform any special tasks. When the data that your application extracts from an Apple event is system-defined, the system swaps the data for you before giving the event to your application to process. You will want to treat system-defined data types from Apple events as native endian. Similarly, if you put native-endian data into an Apple event that you are sending, and it is a system-defined data type, the receiver will be able to interpret the data in its own native endian format. </p>
<p>However, you must account for byte-ordering differences for the custom Apple event data types that you define. You can accomplish this in one of the following ways:</p>
<ul class="spaceabove"><li class="li"><p>Write a byte-swapping callback routine (also known as a flipper) and provide it to the system. Whenever the system determines that your Apple event data needs to be byte swapped it invokes your flipper to ensure that the recipient of the data gets the data in the correct endian format. For details, see <span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-285471">“Writing a Callback to Swap Data Bytes.”</a></span></p></li>
<li class="li"><p>Choose one endian format to use, regardless of architecture. Then, when you read or write your custom Apple event data, use big-to-host and host-to-big routines, such as the Core Foundation Byte Order Utilities functions <code><a href="../../../../CoreFoundation/Reference/CFByteOrderUtils/Reference/reference.html#//apple_ref/c/func/CFSwapInt16BigToHost" target="_top">CFSwapInt16BigToHost</a></code> and <code><a href="../../../../CoreFoundation/Reference/CFByteOrderUtils/Reference/reference.html#//apple_ref/c/func/CFSwapInt16HostToBig" target="_top">CFSwapInt16HostToBig</a></code>.</p></li></ul>
<a name="//apple_ref/doc/uid/TP40002217-CH243-290895" title="Custom Resource Data"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-CJBDIIDF" title="Custom Resource Data"></a><h3>Custom Resource Data</h3>
<p>In Mac OS X, the preferred way to supply resources is to provide files in your application bundle that define resources such as image files, sounds, localized text, and archived user-interface definitions. The resource data types discussed in this section are those defined in Resource Manager-style files supported by Carbon. The Resource Manager was created prior to Mac OS X. If your application uses Resource Manager-style resource files, you should consider moving towards Mac OS X–style resources in your application bundle instead.</p>
<p>Resources typically include data that describes menus, windows, controls, dialogs, sounds, fonts, and icons. Although the system defines a number of standard resource types (such as <code>'moov'</code>, used to specify a QuickTime movie, and <code>'MENU'</code>, used to define menus) you can also create your own private resource types for use in your application. You use the Resource Manager API to define resource data types and to get and set resource data.</p>
<p>Mac OS X keeps track of resources in memory and allows your application to read or write resources. Applications and system software interpret the data for a resource according to its resource type. Although you'll typically let the operating system read resources (such as your application icon) for you, you can also call Resource Manager functions directly to read and write resources.</p>
<p>Mac OS X manages the system-defined resources for you, handling them appropriately for the currently executing code. That is, if your application runs on an Intel-based Macintosh, Mac OS X swaps bytes so that your application icon, menus, and other standard resources appear correctly. You don't need to perform any special tasks. But if you define your own private resource data types for use in your application, you need to account for byte-ordering differences between architectures when you read or write resource data from disk.</p>
<p>You can use either of the following strategies to handle custom Resource Manager-style resource data. Notice that these are the same strategies used to handle custom Apple event data: </p>
<ul class="spaceabove"><li class="li"><p>Provide a byte-swapping callback routine for the system to invoke whenever the system determines your resource data must be byte swapped. For details, see <span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-285471">“Writing a Callback to Swap Data Bytes.”</a></span></p></li>
<li class="li"><p>Always write your data using the same endian format, regardless of the architecture. Then, when you read or write your custom resource data, use big-to-host and host-to-big routines, such as the Core Foundation Byte Order Utilities <code><a href="../../../../CoreFoundation/Reference/CFByteOrderUtils/Reference/reference.html#//apple_ref/c/func/CFSwapInt16BigToHost" target="_top">CFSwapInt16BigToHost</a></code> and <code><a href="../../../../CoreFoundation/Reference/CFByteOrderUtils/Reference/reference.html#//apple_ref/c/func/CFSwapInt16HostToBig" target="_top">CFSwapInt16HostToBig</a></code>.</p></li></ul>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40002217-CH243-SW3" title="Note"></a><p><strong>Note:</strong>&nbsp;If you are revising old code that marks resources with a preload bit, you should remove the  preload bit from any resources that must be byte swapped. In Mac OS X, the preload bit is almost always unnecessary. If you cannot remove the preload bit, you should swap the resource data after you read the resource. You will not be able to use a flipper callback to swap bytes automatically because in Mac OS X a preload bit causes the resources to be read before any of the application code runs.</p></div>
<a name="//apple_ref/doc/uid/TP40002217-CH243-291016" title="Floating-Point Values"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-CJBJFBBJ" title="Floating-Point Values"></a><h3>Floating-Point Values</h3>
<p>Core Foundation defines a set of functions and two special data types to help you work with floating-point values. These functions allow you to encode 32- and 64-bit floating-point values in such a way that they can later be decoded and byte swapped if necessary. <span class="content_text">Listing 3-2</span> shows you how to encode a 64-bit floating-point number and <span class="content_text">Listing 3-3</span> shows how to decode it.</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-291037" title="Listing 3-2Encoding a 64-bit floating-point value"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-BABHJJCB" title="Listing 3-2Encoding a 64-bit floating-point value"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>Encoding a 64-bit floating-point value</p><div class="codesample"><table><tr><td scope="row"><pre>double d = 3.0;<span></span></pre></td></tr><tr><td scope="row"><pre>CFSwappedFloat64 swappedDouble;<span></span></pre></td></tr><tr><td scope="row"><pre>// Encode the floating-point value.<span></span></pre></td></tr><tr><td scope="row"><pre>swappedDouble = CFConvertFloat64HostToSwapped(d);<span></span></pre></td></tr><tr><td scope="row"><pre>// Call the appropriate routine to write swappedDouble to disk,<span></span></pre></td></tr><tr><td scope="row"><pre>// send it to another process, etc.<span></span></pre></td></tr><tr><td scope="row"><pre>write(myFile, &amp;swappedDouble, sizeof(swappedDouble));<span></span></pre></td></tr></table></div>
<p>The data types <code>CFSwappedFloat32</code> and <code>CFSwappedFloat64</code> contain floating-point values in a canonical representation. A <code>CFSwappedFloat</code> data type is not itself a floating-point value, and should not be directly used as one. You can however send one to another process, save it to disk, or send it over a network. Because the format is converted to and from the canonical format by the conversion functions, there is no need for explicit swapping. Bytes are swapped for you during the format conversion if necessary.</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-291083" title="Listing 3-3Decoding a 32-bit floating-point value"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-BABFABBI" title="Listing 3-3Decoding a 32-bit floating-point value"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>Decoding a 32-bit floating-point value</p><div class="codesample"><table><tr><td scope="row"><pre>float f;<span></span></pre></td></tr><tr><td scope="row"><pre>CFSwappedFloat32 swappedFloat;<span></span></pre></td></tr><tr><td scope="row"><pre>// Call the appropriate routine to read swappedFloat from disk,<span></span></pre></td></tr><tr><td scope="row"><pre>// receive it from another process, etc.<span></span></pre></td></tr><tr><td scope="row"><pre>read(myFile, &amp;swappedFloat, sizeof(swappedFloat));<span></span></pre></td></tr><tr><td scope="row"><pre>f = CFConvertFloat32SwappedToHost(swappedFloat)<span></span></pre></td></tr></table></div>
<p>The <code>NSByteOrder.h</code> header file defines functions that are comparable to the Core Foundation functions discussed here.</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-291292" title="Integers"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-CJBDJAHC" title="Integers"></a><h3>Integers</h3>
<p>The system library byte-access functions, such as <code>OSReadLittleInt16</code> and <code>OSWriteLittleInt16</code>, provide generic byte swapping. These functions swap bytes if the native endian format is different from the endian format of the destination. They are defined in the <code>libkern/OSByteOrder.h</code> header file.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002217-CH243-SW4" title="Note"></a><p><strong>Note:</strong>&nbsp; The <code>OSReadXXX</code> and <code>OSWriteXXX</code> functions provide higher performance than the <code>OSSwapXXX</code> functions or any other functions in the higher-level frameworks.</p></div>
<p>Core Foundation provides three optimized primitive functions for swapping bytes— <code><a href="../../../../CoreFoundation/Reference/CFByteOrderUtils/Reference/reference.html#//apple_ref/c/func/CFSwapInt16" target="_top">CFSwapInt16</a></code>, <code><a href="../../../../CoreFoundation/Reference/CFByteOrderUtils/Reference/reference.html#//apple_ref/c/func/CFSwapInt32" target="_top">CFSwapInt32</a></code>, and <code><a href="../../../../CoreFoundation/Reference/CFByteOrderUtils/Reference/reference.html#//apple_ref/c/func/CFSwapInt64" target="_top">CFSwapInt64</a></code>. All of the other swapping functions use these primitives to accomplish their work. In general you don’t need to use these primitives directly.</p>
<p>Although the primitive swapping functions swap unconditionally, the higher-level swapping functions are defined in such a way that they do nothing when swapping bytes is not required—in other words, when the source and host byte orders are the same. For the integer types, these functions take the forms <code>CFSwapXXXBigToHost</code>, <code>CFSwapXXXLittleToHost</code>, <code>CFSwapXXXHostToBig</code>, and <code>CFSwapXXXHostToLittle</code>, where <code>XXX</code> is a data type such as <code>Int32</code>. For example, on a little-endian machine you use the function <code><a href="../../../../CoreFoundation/Reference/CFByteOrderUtils/Reference/reference.html#//apple_ref/doc/c_ref/CFSwapInt16BigToHost" target="_top">CFSwapInt16BigToHost</a></code> to read a 16-bit integer value from a network whose data is in network byte order (big-endian). <span class="content_text">Listing 3-4</span> demonstrates this process.</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-291343" title="Listing 3-4Swapping a 16-bit integer from big-endian to host-endian"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-BABBAGEI" title="Listing 3-4Swapping a 16-bit integer from big-endian to host-endian"></a><p class="codesample"><strong>Listing 3-4&nbsp;&nbsp;</strong>Swapping a 16-bit integer from big-endian to host-endian</p><div class="codesample"><table><tr><td scope="row"><pre>SInt16  bigEndian16;<span></span></pre></td></tr><tr><td scope="row"><pre>SInt16  swapped16;<span></span></pre></td></tr><tr><td scope="row"><pre>// Swap a 16-bit value read from the network.<span></span></pre></td></tr><tr><td scope="row"><pre>swapped16 = CFSwapInt16BigToHost(bigEndian16);<span></span></pre></td></tr></table></div>
<p>Suppose the integers are in the fields of a data structure. <span class="content_text">Listing 3-5</span> demonstrates how to swap bytes.</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-291385" title="Listing 3-5Swapping integers from little-endian to host-endian"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-BABJBCDA" title="Listing 3-5Swapping integers from little-endian to host-endian"></a><p class="codesample"><strong>Listing 3-5&nbsp;&nbsp;</strong>Swapping integers from little-endian to host-endian</p><div class="codesample"><table><tr><td scope="row"><pre>// Swap the bytes of the values if necessary.<span></span></pre></td></tr><tr><td scope="row"><pre>aStruct.int1 = CFSwapInt32LittleToHost(aStruct.int1)<span></span></pre></td></tr><tr><td scope="row"><pre>aStruct.int2 = CFSwapInt32LittleToHost(aStruct.int2)<span></span></pre></td></tr></table></div>
<p>The code swaps bytes only if necessary. If the host is a big-endian architecture, the functions used in the code sample swap the bytes in each field. The code does nothing when run on a little-endian machine—the compiler ignores the code.</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-291436" title="Network-Related Data"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-CJBEBIEF" title="Network-Related Data"></a><h3>Network-Related Data</h3>
<p>Network-related data typically uses big-endian format (also known as <strong>network byte order</strong>), so you may need to swap bytes when communicating between the network and an Intel-based Macintosh computer. You probably never had to adjust your PowerPC code when you transmitted data to, or received data from, the network. On an Intel-based Macintosh computer you must look closely at your networking code and ensure that you always send network-related data in the appropriate byte order. You must also handle data received from the network appropriately, swapping the bytes of values to the endian format appropriate to the host microprocessor.</p>
<p>You can use the following POSIX functions to convert between network byte order and host byte order. (Other byte-swapping functions, such as those defined in the <code>OSByteOrder.h</code> and <code>CFByteOrder.h</code> header files, can also be useful for handling network data.)</p>
<ul class="spaceabove"><li class="li"><p>network to host:</p><p><code>uint32_t ntohl (uint32_t netlong);</code></p><p><code>uint16_t ntohs (uint16_t netshort);</code></p></li>
<li class="li"><p>host to network:</p><p><code>uint32_t htonl (uint32_t hostlong);</code></p><p><code>uint16_t htons (uint16_t hostshort);</code></p></li></ul>
<p>These functions are documented in <em><a href="../../../../Darwin/Reference/ManPages/index.html#//apple_ref/doc/uid/TP40000894" target="_top">Mac OS X Man Pages</a></em>. </p>
<p>The <code>sin_saddr.s_addr</code> and <code>sin_port</code> fields of a <code>sockaddr_in</code> structure should always be in network byte order. You can find out the appropriate endian format of any argument to a BSD networking function by reading the man page documentation.</p><p>When advertising a service on the network, you use <code>getsockname</code>  to get the local TCP or UDP port that your socket is bound to, and then pass <code>my_sockaddr.sin_port</code> unchanged, without any byte swapping, to the <code><a href="../../../../Networking/Reference/DNSServiceDiscovery_CRef/dns_sd/CompositePage.html#//apple_ref/c/func/DNSServiceRegister" target="_top">DNSServiceRegister</a></code> function.</p><p>In CoreFoundation code, you can use the same approach. Use the <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/Reference/reference.html#//apple_ref/c/func/CFSocketCopyAddress" target="_top">CFSocketCopyAddress</a></code>  function as shown below, and then  pass <code>my_sockaddr.sin_port</code> unchanged, without any byte swapping, to the <code><a href="../../../../Networking/Reference/DNSServiceDiscovery_CRef/dns_sd/CompositePage.html#//apple_ref/c/func/DNSServiceRegister" target="_top">DNSServiceRegister</a></code> function.</p><div class="codesample"><table><tr><td scope="row"><pre>CFDataRef addr = CFSocketCopyAddress(myCFSocketRef);<span></span></pre></td></tr><tr><td scope="row"><pre>struct sockaddr_in my_sockaddr;<span></span></pre></td></tr><tr><td scope="row"><pre>memmove(&amp;my_sockaddr, CFDataGetBytePtr(addr), sizeof(my_sockaddr));<span></span></pre></td></tr><tr><td scope="row"><pre>DNSServiceRegister( ... , my_sockaddr.sin_port, ...);<span></span></pre></td></tr></table></div><p>When browsing and resolving, the process is similar. The <code>DNSServiceResolve</code> function and the BSD Sockets calls such as <code>gethostbyname</code> and <code>getaddrinfo</code> all return IP addresses and ports already in the correct byte order so that you can assign them directly to your <code>struct sockaddr_in</code> and call <code>connect</code> to open a TCP connection. If you byte-swap the address or port, then your program will not work.</p><p>The important point is that when you use the DNSServiceDiscovery API with the BSD Sockets networking APIs, you do not need to swap anything. Your code will work correctly on both PowerPC and Intel-based Macintosh computers as well as on Linux, Solaris, and Windows.</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-291523" title="OSType-to-String Conversions"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-CJBBDIIG" title="OSType-to-String Conversions"></a><h3>OSType-to-String Conversions</h3>
<p>You can use the functions <code><!--a-->UTCreateStringForOSType<!--/a--></code> and <code><!--a-->UTGetOSTypeFromString<!--/a--></code> to convert an <code>OSType</code> data type to or from a <code>CFString</code> object (<code>CFStringRef</code> data type). These functions are discussed in <em><a href="../../../../Carbon/Conceptual/understanding_utis/index.html#//apple_ref/doc/uid/TP40001319" target="_top">Uniform Type Identifiers Overview</a></em> and defined in the <code>UTType.h</code> header file, which is part of the Launch Services framework.</p>
<p>When you use four-character literals, keep in mind that <code>"abcd" != 'abcd'</code>. Rather <code>'abcd' == 0x61626364</code>. You must treat <code>'abcd'</code> as an integer and not string data, as <code>'abcd'</code> is a shortcut for a 32-bit integer. (A <code>FourCharCode</code> data type is a <code>UInt32</code> data type.) The compiler does not swap this for you. You can use the shift operator if you need to deal with individual characters.</p>
<p>For example, if you currently print an <code>OSType</code> or <code>FourCharCode</code> type using the standard C <code>printf</code>-style semantics, use</p>
<div class="codesample"><table><tr><td scope="row"><pre>printf("%c%c%c%c", (char) (val >> 24), (char) (val  >> 16),<span></span></pre></td></tr><tr><td scope="row"><pre>                    (char) (val >> 8), (char) val)<span></span></pre></td></tr></table></div>
<p>instead of the following:</p>
<div class="codesample"><table><tr><td scope="row"><pre>printf("%4.4s", (const char*) &amp;val)<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40002217-CH243-291648" title="Unicode Text Files"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-BCIDIBAG" title="Unicode Text Files"></a><h3>Unicode Text Files</h3>
<p>Mac OS X often uses UTF-16 to encode Unicode; a <code>UniChar</code> data type is a double-byte value. As with any multibyte data, Unicode characters are sensitive to the byte ordering method used by the microprocessor. A byte order mark written to the beginning of a file informs the program reading the data which byte ordering method was used to write the data. The Unicode standard states that in the absence of a byte order mark (BOM) the data in a Unicode data file is to be taken as big-endian. Although a BOM is not mandatory, you should make use of it to ensure that a file written on one architecture can be read from the other architecture. The program can then act accordingly to make sure the byte ordering of the Unicode text is compatible with the host.</p>
<p><span class="content_text">Table 3-1</span> lists the standard byte order marks for UTF-8, UTF-16, and UTF-32. (Note that the UTF-8 BOM is not used for endian issues, but only as a tag to indicate that the file is UTF-8.)</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-291683" title="Table 3-1Byte order marks"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-CJBHDJJC" title="Table 3-1Byte order marks"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 3-1&nbsp;&nbsp;</strong>Byte order marks</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Byte order mark</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Encoding form</p></th>
</tr>


<tr>
<td  scope="row"><p><code>EF BB BF</code></p></td>
<td ><p>UTF-8</p></td>
</tr>
<tr>
<td  scope="row"><p><code>FF FE</code> </p></td>
<td ><p>UTF-16/UCS-2, little endian</p></td>
</tr>
<tr>
<td  scope="row"><p><code>FE FF</code> </p></td>
<td ><p>UTF-16/UCS-2, big endian </p></td>
</tr>
<tr>
<td  scope="row"><p><code>FF FE 00 00</code> </p></td>
<td ><p>UTF-32/UCS-4, little endian </p></td>
</tr>
<tr>
<td  scope="row"><p><code>00 00 FE FF</code> </p></td>
<td ><p>UTF-32/UCS-4, big endian </p></td>
</tr>

</table></div>
<p>In practice, when your application reads a file, it does not need to look for a byte order mark nor does it need to swap bytes as long as you follow these steps to read a file:</p>
<ol class="ol"><li class="li"><p>Map the file using <code>mmap</code> to get a pointer to the contents of the file (or string). </p><p>Reading the entire file into memory ensures the best performance and is a prerequisite for the next step.</p></li>
<li class="li"><p>Generate a <code>CFString</code> object by calling the function <code>CFStringCreateWithBytes</code> with the <code>isExternalRepresentation</code> parameter set to <code>true</code>, or call the function <code>CFStringCreateWithExternalRepresentation</code> to generate a <code>CFString</code>, passing in an encoding of <code>kCFStringEncodingUnicode</code> (for UTF-16) or <code>kCFStringEncodingUTF8</code> (for UTF-8).</p><p>Either function interprets a BOM swaps bytes as necessary. Note that a BOM should not be used in memory; its use is solely for data transmission (files, pasteboard, and so forth).</p></li></ol>
<p>In summary, with respect to Unicode files, your application performs best when you follow these guidelines:</p>
<ul class="spaceabove"><li class="li"><p>Accept the BOM when taking UTF-16 or UTF-8 encoded files from outside the application.</p></li>
<li class="li"><p>Use native-endian <code>UniChar</code> data types internally.</p></li>
<li class="li"><p>Generate a BOM when writing UTF-16 to a file. Ideally, you only need to generate a BOM for an architecture that uses little-endian format, but it is also acceptable to generate a BOM for an architecture that uses big-endian format.</p></li>
<li class="li"><p>When you put data on the Clipboard, make sure that <code>'utxt'</code> data does not have a BOM. Only <code>'ut16'</code> data should have a BOM. If you use Cocoa to put an <code>NSString</code> object on the pasteboard, you don’t need to concern yourself with a BOM.</p></li></ul>
<p>For more information, see “UTF &amp; BOM,” available from the Unicode website:</p>
<p><span class="content_text"><a href="http://www.unicode.org/faq/utf_bom.html" target="_blank">http://www.unicode.org/faq/utf_bom.html</a></span></p>
<p>The Apple Event Manager provides text constants that you can use to specify the type of your data. As of Mac OS X v10.4, only two text constants are recommended:</p>
<ul class="spaceabove"><li class="li"><p><code>typeUTF16ExternalRepresentation</code>, which specifies Unicode text in 16-bit external representation with optional byte order mark (BOM). The presence of this constant guarantees that either there is a BOM or the data is in UTF-16 big-endian format.</p></li>
<li class="li"><p><code>typeUTF8Text</code>, which specifies 8-bit Unicode (UTF-8 encoding).</p></li></ul>
<p>The constant <code>typeUnicodeText</code> indicates <code>utxt</code> text data, in native byte ordering format, with an optional BOM. This constant does not specify an explicit Unicode encoding or byte order definition.</p>
<p>The Scrap Manager provides the flavor type constant <code>kScrapFlavorTypeUTF16External</code> which specifies Unicode text in 16-bit external representation with optional byte order mark (BOM).</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-297775" title="Values in an Array"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-CJBIBIHD" title="Values in an Array"></a><h3>Values in an Array</h3>
<p>The routine in <span class="content_text">Listing 3-6</span> shows an approach that you can use to swap the bytes of values in an array. On a big-endian system, the compiler optimizes away the entire function; you don’t need to use <code>#ifdef</code> statements to swap these sorts of arrays.</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-297792" title="Listing 3-6A routine for swapping the bytes of the values in an array"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-CJBBFDDE" title="Listing 3-6A routine for swapping the bytes of the values in an array"></a><p class="codesample"><strong>Listing 3-6&nbsp;&nbsp;</strong>A routine for swapping the bytes of the values in an array</p><div class="codesample"><table><tr><td scope="row"><pre>static inline void SwapUInt32ArrayBigToHost(UInt32 *array, UInt32  count) {<span></span></pre></td></tr><tr><td scope="row"><pre>    int i;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    for(i = 0; i &lt; count; i++) {<span></span></pre></td></tr><tr><td scope="row"><pre>        array[i] = CFSwapInt32BigToHost(array[i]);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40002217-CH243-285471" title="Writing a Callback to Swap Data Bytes"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-CJBCCJAG" title="Writing a Callback to Swap Data Bytes"></a><h2>Writing a Callback to Swap Data Bytes</h2>
<p>You can provide a byte-swapping callback routine, also referred to as a <strong>flipper</strong>, to the system for custom resource data, custom pasteboard data, and custom Apple event data. When you install a byte-swapping callback, you specify which domain that the data type belongs to. There are two data domains—Apple event and resource. The resource data domain specifies custom pasteboard data or custom resource data. If the callback can be applied to either domain (Apple event and resource), you can specify that as well. </p>
<p>The Core Endian API defines a callback that you provide to swap bytes for custom resource and Apple event data. You must provide one callback for each type of data you want to swap bytes. The prototype for the <code>CoreEndianFlipProc</code> callback is:</p>
<div class="codesample"><table><tr><td scope="row"><pre>typedef CALLBACK_API (OSStatus, CoreEndianFlipProc)<span></span></pre></td></tr><tr><td scope="row"><pre>    (OSType dataDomain,<span></span></pre></td></tr><tr><td scope="row"><pre>    OSType dataType,<span></span></pre></td></tr><tr><td scope="row"><pre>    short id,<span></span></pre></td></tr><tr><td scope="row"><pre>    void *dataPtr,<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 dataSize,<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean currentlyNative,<span></span></pre></td></tr><tr><td scope="row"><pre>    void *refcon<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div>
<p>The callback takes the following parameters:</p>
<ul class="ul"><li class="li"><p><code>dataDomain</code>—An <code>OSType</code> value that specifies the domain to which the flipper callback applies. The value <code>kCoreEndianResourceManagerDomain</code>  signifies that the domain is resource or pasteboard data. The value <code>kCoreEndianAppleEventManagerDomain</code> signifies that the domain is Apple event data.</p></li>
<li class="li"><p><code>dataType</code>—The type of data that needs the callback to swap bytes for. This is the four-character code of the resource type, pasteboard type, or Apple event.</p></li>
<li class="li"><p><code>id</code>—The resource id of the data type. This field is ignored if the <code>dataDomain</code> parameter is not <code>kCoreEndianResourceManagerDomain</code>.</p></li>
<li class="li"><p><code>dataPtr</code>—On input, points to the data to be flipped. On output, points to the byte swapped data.</p></li>
<li class="li"><p><code>dataSize</code>—The size of the data pointed to by the <code>dataPtr</code> parameter.</p></li>
<li class="li"><p><code>currentlyNative</code>—A Boolean value that indicates the direction to swap bytes. The value <code>true</code> specifies the data pointed to by the <code>dataPtr</code> parameter uses the byte ordering of the currently executing code. On a PowerPC Macintosh, <code>true</code> specifies that the data is in big-endian format. On an Intel-based Macintosh, <code>true</code> specifies that the data is in little-endian format.</p></li>
<li class="li"><p><code>refcon</code>—A 32-bit value that contains, or refers to, data needed by the callback.</p></li></ul>
<p>The callback returns a result code that indicates whether bytes are swapped successfully. Your callback should return <code>noErr</code> if the data is byte swapped without error and the appropriate result code to indicate an error condition—<code>errCoreEndianDataTooShortForFormat</code>, <code>errCoreEndianDataTooLongForFormat</code>, or <code>errCoreEndianDataDoesNotMatchFormat</code>. The result code you return is propagated through the appropriate manager (Resource Manager (<code>ResError</code>) or Apple Event Manager) to the caller.</p>
<p>You do not need to swap bytes for quantities that are not numerical (such as strings, byte streams, and so forth). You need to provide a callback only to swap bytes data types for which the order of bytes in a word or long word are important. (For the preferred way to handle Unicode strings, see <span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-291648">“Unicode Text Files.”</a></span>) </p>
<p>Your callback should traverse the data structure that contains the data and swap bytes for:</p>
<ul class="ul"><li class="li"><p>All counts and lengths so that array indexes are associated with the appropriate value</p></li>
<li class="li"><p>All integers and longs so that when you read them into variables of a compatible type, you can operate correctly on the values (such as numerical, offset, and shift operations)</p></li></ul>
<p>The Core Endian API provides these functions for working with your callback:</p>
<ul class="ul"><li class="li"><p><code><a href="../../../../Carbon/Reference/CoreEndianReference/Reference/reference.html#//apple_ref/c/func/CoreEndianInstallFlipper" target="_top">CoreEndianInstallFlipper</a></code> registers your callback for the specified data type (custom resource or custom Apple Event). After you register a byte-swapping callback for an application-defined resource data type, then any time you call a Resource Manager function that operates on that resource type, the system invokes your callback if it is appropriate to do so. (If your callback operates on pasteboard data, the system also invokes the callback at the appropriate time.) Similarly, if you specify Apple event as the domain for your callback, then any time you call an Apple Event Manager function that operates on that data type, your callback is invoked when it is appropriate to do so. </p></li>
<li class="li"><p><code><a href="../../../../Carbon/Reference/CoreEndianReference/Reference/reference.html#//apple_ref/c/func/CoreEndianGetFlipper" target="_top">CoreEndianGetFlipper</a></code> obtains the callback that is registered for the specified data type. You can call this function to determine whether a flipper is available for a given data type.</p></li>
<li class="li"><p><code><a href="../../../../Carbon/Reference/CoreEndianReference/Reference/reference.html#//apple_ref/c/func/CoreEndianFlipData" target="_top">CoreEndianFlipData</a></code> invokes the callback associated with the specified data type. You shouldn’t need to call this function, because the system invokes your callback whenever it’s needed.</p></li></ul>
<p>As an example, look at a callback for the custom resource type (<code>'PREF'</code>) defined in <span class="content_text">Listing 3-7</span>. The <code>MyPreferences</code> structure is used to store preferences data on disk. The structure contains a number of values and includes two instances of the <code>RGBColor</code> data type and an array of <code>RGBColor</code> values. </p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-285581" title="Listing 3-7A declaration for a custom resource"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-BCIICHHF" title="Listing 3-7A declaration for a custom resource"></a><p class="codesample"><strong>Listing 3-7&nbsp;&nbsp;</strong>A declaration for a custom resource</p><div class="codesample"><table><tr><td scope="row"><pre>#define kMyPreferencesType      'PREF'<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>struct MyPreferences {<span></span></pre></td></tr><tr><td scope="row"><pre>                SInt32          fPrefsVersion;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                Boolean         fHighlightLinks;<span></span></pre></td></tr><tr><td scope="row"><pre>                Boolean         fUnderlineLinks;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                RGBColor        fHighlightColor;<span></span></pre></td></tr><tr><td scope="row"><pre>                RGBColor        fUnderlineColor;<span></span></pre></td></tr><tr><td scope="row"><pre>                SInt16          fZoomValue;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                char            fCString[32];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                SInt16          fCount;<span></span></pre></td></tr><tr><td scope="row"><pre>                RGBColor        fPalette[];<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div>
<p>You can handle the <code>RGBColor</code> data type by writing a function that swaps bytes in an <code>RGBColor</code> data structure, such as the function <code><!--a-->MyRGBSwap<!--/a--></code>, shown in <span class="content_text">Listing 3-8</span>. This function calls the Core Endian macro <code><!--a-->EndianS16_Swap<!--/a--></code> to swap bytes for each of the values in the <code>RGBColor</code> data structure. The function doesn’t need to check for the currently executing system because the function is never called unless the values in the <code>RGBColor</code> data type need to have their bytes swapped. The <code><!--a-->MyRGBSwap<!--/a--></code> function is called by the byte-swapping callback routine (shown in <span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-285784">Listing 3-9</a></span>) that’s provided to handle the custom <code>'PREF'</code> resource (that is defined in <span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-285581">Listing 3-7</a></span>). </p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-285728" title="Listing 3-8A flipper function for RGBColor data"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-BCIDBEDD" title="Listing 3-8A flipper function for RGBColor data"></a><p class="codesample"><strong>Listing 3-8&nbsp;&nbsp;</strong>A flipper function for RGBColor data</p><div class="codesample"><table><tr><td scope="row"><pre>static void MyRGBSwap (RGBColor *p)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    p->red = Endian16_Swap(p->red);<span></span></pre></td></tr><tr><td scope="row"><pre>    p->blue = Endian16_Swap(p->blue);<span></span></pre></td></tr><tr><td scope="row"><pre>    p->green = Endian16_Swap(p->green);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p><span class="content_text">Listing 3-9</span> shows a byte-swapping callback for the custom <code>'PREF'</code> resource. An explanation for each numbered line of code appears following the listing. Note that the flipper checks for data that is malformed or is of an unexpected length. If the data passed into the flipper routine is a shorter length than the flipped type is normally, or (for example) contains garbage data instead of an array count, the flipper must be careful not to read or write data beyond the end of the passed-in data. Instead, the routine returns an error.</p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-285784" title="Listing 3-9A flipper for the custom &#39;PREF&#39; resource"></a><a name="//apple_ref/doc/uid/TP40002217-CH243-BCIIEAJJ" title="Listing 3-9A flipper for the custom &#39;PREF&#39; resource"></a><p class="codesample"><strong>Listing 3-9&nbsp;&nbsp;</strong>A flipper for the custom 'PREF' resource</p><div class="codesample"><table><tr><td scope="row"><pre>#define kCurrentVersion    0x00010400<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static OSStatus MyFlipPreferences (OSType dataDomain,  <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>                    OSType dataType,   <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                    short id,   <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>                    void * dataPtr,   <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>                    UInt32 dataSize,   <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>                    Boolean currentlyNative,  <span>// 6</span></pre></td></tr><tr><td scope="row"><pre>                    void* refcon)  <span>// 7</span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32  versionNumber;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    MyPreferences* toFlip = (MyPreferences*) dataPtr;       <span>// 8</span></pre></td></tr><tr><td scope="row"><pre>    int count, i;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (dataSize &lt; sizeof(MyPreferences))<span></span></pre></td></tr><tr><td scope="row"><pre>        return errCoreEndianDataTooShortForFormat;  <span>// 9</span></pre></td></tr><tr><td scope="row"><pre>    if (currentlyNative)   <span>// 10</span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        count = toFlip->fCount;<span></span></pre></td></tr><tr><td scope="row"><pre>        versionNumber = toFlip->fPrefsVersion;<span></span></pre></td></tr><tr><td scope="row"><pre>        toFlip->fPrefsVersion = Endian32_Swap (toFlip->fPrefsVersion);<span></span></pre></td></tr><tr><td scope="row"><pre>        toFlip->fCount = Endian16_Swap (toFlip->fCount);<span></span></pre></td></tr><tr><td scope="row"><pre>        toFlip->fZoomValue = Endian16_Swap (toFlip->fZoomValue);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else   <span>// 11</span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        toFlip->fPrefsVersion = Endian32_Swap (toFlip->fPrefsVersion);<span></span></pre></td></tr><tr><td scope="row"><pre>        versionNumber = toFlip->fPrefsVersion;<span></span></pre></td></tr><tr><td scope="row"><pre>        toFlip->fCount = Endian16_Swap (toFlip->fCount);<span></span></pre></td></tr><tr><td scope="row"><pre>        toFlip->fZoomValue = Endian16_Swap (toFlip->fZoomValue);<span></span></pre></td></tr><tr><td scope="row"><pre>        count = toFlip->fCount;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if (versionNumber != kCurrentVersion)  <span>// 12</span></pre></td></tr><tr><td scope="row"><pre>                return errCoreEndianDataDoesNotMatchFormat;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    MyRGBSwap (&amp;toFlip->fHighlightColor);  <span>// 13</span></pre></td></tr><tr><td scope="row"><pre>    MyRGBSwap (&amp;toFlip->fUnderlineColor);  <span>// 14</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (dataSize &lt; sizeof(MyPreferences) + count * sizeof(RGBColor))<span></span></pre></td></tr><tr><td scope="row"><pre>        return errCoreEndianDataTooShortForFormat;   <span>// 15</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    for(i = 0; i &lt; count; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        MyRGBSwap (&amp;toFlip->fPalette[i]);  <span>// 16</span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return status;     <span>// 17</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>Here’s what the code does:</p>
<ol class="ol"><li class="li"><p>The system passes to your callback the domain to which the callback applies. You define the domain when you register the callback using the function <code><a href="../../../../Carbon/Reference/CoreEndianReference/Reference/reference.html#//apple_ref/doc/c_ref/CoreEndianInstallFlipper" target="_top">CoreEndianInstallFlipper</a></code>.</p></li>
<li class="li"><p>The system passes to your callback the resource type you defined for the data. In this example, the resource type is <code>'PREF'</code>.</p></li>
<li class="li"><p>The system passes to your callback the resource ID of the data type. If the data is not a resource, this value is <code>0</code>.</p></li>
<li class="li"><p>The system passes to your callback a pointer to the resource data that needs to have its bytes swapped. In this case, the pointer refers to a <code>MyPreferences</code> data structure.</p></li>
<li class="li"><p>The system passes to your callback the size of the data pointed to by the pointer described in the previous step. </p></li>
<li class="li"><p>The system passes to your callback <code>true</code> if the data in the buffer passed to the callback is in the byte ordering of the currently executing code. On a PowerPC Macintosh, when <code>currentlyNative</code> is <code>true</code>, the data is in big-endian order. On a Macintosh that uses an Intel microprocessor, when <code>currentlyNative</code> is <code>true</code>, the data is in little-endian order. Your callback needs to know this value, because if your callback uses a value in the data buffer to decide how to process other data in the buffer (for example, the <code>count</code> variable shown in the code), you must know whether that value needs to be flipped before the value can be used by the callback.</p></li>
<li class="li"><p>The system passes to your callback a pointer that refers to application-specific data. In this example, the callback doesn’t require any application-specific data.</p></li>
<li class="li"><p>Defines a variable for the <code>MyPreferences</code> data type and assigns the contents of the data pointer to the newly-defined <code>toFlip</code> variable.</p></li>
<li class="li"><p>Checks the static-length portion of the structure. If the size is less than it should be, the routine returns the error <code>errCoreEndianDataTooLongForFormat</code>.</p></li>
<li class="li"><p>If <code>currentlyNative</code> is <code>true</code>, saves the count value to a local variable and then swaps the bytes for the other values in the <code>MyPreferences</code> data structure. You must save the count value before you swap because you need it for an iteration later in the function. The fact that <code>currentlyNative</code> is <code>true</code> indicates that the value does not need to be byte swapped if it is used in the currently executing code. However, the value does need to be swapped to be stored to disk. </p><p>The values are swapped using the appropriate Core Endian macros. </p></li>
<li class="li"><p>If <code>currentlyNative</code> is <code>false</code>, flips the values in the <code>MyPreferences</code> data structure before it saves the count value to a local variable. The fact that <code>currentlyNative</code> is <code>false</code> indicates that the count value needs to have its bytes swapped before it can be used in the callback. </p></li>
<li class="li"><p>Checks to make sure the version of the data structure is supported by the application. If the version is not supported, then your callback would not swap bytes for the data and would return the result <code>errCoreEndianDataDoesNotMatchFormat</code>.</p></li>
<li class="li"><p>Calls the <code><!--a-->MyRGBSwap<!--/a--></code> function (shown in <span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-285728">Listing 3-8</a></span>) to swap the bytes of the <code>fHighlightColor</code> field of the data structure.</p></li>
<li class="li"><p>Calls the <code><!--a-->MyRGBSwap<!--/a--></code> function to swap the bytes of the <code>fUnderlineColor</code> field of the data structure.</p></li>
<li class="li"><p>Checks the data size to make sure that it is less than it should be. If not, the routine returns the error <code>errCoreEndianDataTooLongForFormat</code>.</p></li>
<li class="li"><p>Iterates through the elements in the <code>fPalette</code> array, calling the <code><!--a-->MyRGBSwap<!--/a--></code> function to swap the bytes of the data in the array.</p></li>
<li class="li"><p>Returns <code>noErr</code> to indicate that the data is flipped without error.</p></li></ol>
<p>Although the sample performs some error checking, it does not include all the error-handling code that it could. When you write a flipper you may want to include such code.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002217-CH243-SW5" title="Note"></a><p><strong>Note:</strong>&nbsp;The callback does not flip any of the Boolean values in the <code>MyPreferences</code> data structure because these are single character values. The callback also ignores the C string.</p></div>
<p>You register a byte-swapping callback routine by calling the function <code><a href="../../../../Carbon/Reference/CoreEndianReference/Reference/reference.html#//apple_ref/doc/c_ref/CoreEndianInstallFlipper" target="_top">CoreEndianInstallFlipper</a></code>. You should register the callback when your application calls its initialization routine or when you open your resources. For example, you would register the flipper callback shown in <span class="content_text"><a href="universal_binary_swap.html#//apple_ref/doc/uid/TP40002217-CH243-285784">Listing 3-9</a></span> using the following code:</p>
<div class="codesample"><table><tr><td scope="row"><pre>OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>status = CoreEndianInstallFlipper (kCoreEndianResourceManagerDomain,<span></span></pre></td></tr><tr><td scope="row"><pre>                        kMyPreferencesType,<span></span></pre></td></tr><tr><td scope="row"><pre>                        MyFlipPreferences,<span></span></pre></td></tr><tr><td scope="row"><pre>                        NULL);<span></span></pre></td></tr></table></div>
<p>The system invokes the callback for the specified resource type and data domain when <code>currentlyNative</code> is <code>false</code> at the time a resource is loaded and <code>true</code> at the time the resource is set to be written. For example, the sample byte-swapping callback gets invoked any time the following line of code is executed in your application:</p>
<div class="codesample"><table><tr><td scope="row"><pre>MyPreferences** hPrefs = (MyPreferences**) GetResource ('PREF',  128);<span></span></pre></td></tr></table></div>
<p>After swapping the bytes of the data, you can modify it as much as you’d like. </p>
<p>When the Resource Manager reads a resource from disk, it looks up the resource type (for example, <code>'PREF'</code>) in a table of byte-swapping routines. If a callback is installed for that resource type, the Resource Manager invokes the callback if it is appropriate to do so. Similar actions are taken when the Resource Manager writes a resource to disk. It finds the appropriate routine and invokes the callback to swap the bytes of the resource if it is appropriate to do so. </p>
<p>When you copy or drag custom data from an application that has a callback installed for pasteboard data, the system invokes your callback at the appropriate time. If you copy or drag custom data to a native application, the data callback is not invoked. If you copy or drag custom data to a nonnative application, the system invokes your callback to swap the bytes of the custom data. If you paste or drop custom data into your application from a nonnative application, and a callback exists for that custom data, the system invokes the callback at the time of the paste or drop. If the custom data is copied or dragged from another native application, the callback is not invoked.</p>
<p>Note that different pasteboard APIs use different type specifiers. The Scrap Manager and Drag Manager use <code>OSType</code> data types. The Pasteboard Manager uses Uniform Type Identifiers (UTI), and the <code>NSPasteboard</code> class uses its own type mechanism. In each case, the type is converted by the system to an <code>OSType</code> data type to discover if there is a byte-swapping callback for that type.</p>
<p>Apple event data types are typically swapped to network byte order when sent over a network. The callback you install is called only if a custom data type that you define is sent to another machine, or if another machine sends Apple event data to your application. The byte ordering of Apple events on the network is big-endian.</p>
<p>For cases in which the system would not normally invoke your byte-swapping callback, you can call the function <code>CoreEndianFlipData</code> to invoke the callback function installed for the specified data type and domain. </p>
<a name="//apple_ref/doc/uid/TP40002217-CH243-282106" title="See Also"></a><h2>See Also</h2>
<p>The following resources are available in the ADC Reference Library:</p>
<ul class="ul"><li class="li"><p><em><a href="../../../../CoreFoundation/Reference/CFByteOrderUtils/index.html#//apple_ref/doc/uid/20001449" target="_top">Byte-Order Utilities Reference</a></em> describes the Core Foundation byte order utilities API.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../CoreFoundation/Conceptual/CFMemoryMgmt/Tasks/ByteSwapping.html#//apple_ref/doc/uid/20001155-CJBEHAAG" target="_top">Byte Swapping</a></span>, in Core Foundation Memory Management, shows how to swap integers and floating-point values using Core Foundation byte-order utilities.</p></li>
<li class="li"><p><em><a href="../../../../Performance/Conceptual/FileSystem/index.html#//apple_ref/doc/uid/10000161i" target="_top">File-System Performance Guidelines</a></em> provides information useful for mapping Unicode files to memory.</p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../universal_binary_diffs/universal_binary_diffs.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../universal_binary_tips/universal_binary_tips.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/MacOSX/Conceptual/universal_binary/universal_binary_byte_swap/universal_binary_swap.html%3Fid%3DTP40002217-6.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/MacOSX/Conceptual/universal_binary/universal_binary_byte_swap/universal_binary_swap.html%3Fid%3DTP40002217-6.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/MacOSX/Conceptual/universal_binary/universal_binary_byte_swap/universal_binary_swap.html%3Fid%3DTP40002217-6.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>