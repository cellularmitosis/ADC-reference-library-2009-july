<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Failure-Handling Overview (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING125></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-124.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-126.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-122.html"><B>Chapter 24 - Working With Memory and Failure Handling</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING125-0></A>
<H1><A NAME=MARKER-9-59></A><A NAME=MARKER-2-60></A>Failure-Handling Overview</H1>
 MacApp provides a failure-handling mechanism that allows your application to clean up after errors. This mechanism is described in detail in <A HREF=MacAppProgGuide-28.html#MARKER-9-77>"Failure Handling," beginning on page 54</A>. Your application can install failure handlers at multiple points. MacApp links the failure handlers together in a linked list, shown in <A HREF=MacAppProgGuide-28.html#MARKER-9-79>Figure 3-2</A>. You install a failure handler in the list with the <CODE>Try</CODE> macro, as shown in the following code fragment: <P>
<PRE>
// Declare a failure handler.
FailInfo fi;

// Link the failure handler to the global list.
Try(fi)
{  // Code that may cause a failure.
   . . .

   // If no failure occurs, remove the failure handler from the list.
   fi.Success();
}
else
{  // Code to recover if an error occurs.
   .
   .
   .
   // In this case, pass error on to next handler.
   fi.ReSignal();
}
</PRE>
 The <CODE>Try</CODE> block of code is executed first. <CODE>Try</CODE> is implemented as a macro rather than as a method of the <CODE>FailInfo</CODE> class, because the failure-handling code <I>must</I> be inline to properly save the current machine state. The <CODE>Try</CODE> macro links the failure handler to the list of failure handlers and calls <CODE>setjmp</CODE> to save the current machine state in the failure handler's buffer.<P>
<UL>
<LI>If an error occurs, the failure handler is invoked and causes execution to continue with the <CODE>else</CODE> block of code--otherwise, the <CODE>else</CODE> block is never executed. Optionally, the failure handler may call a specific cleanup routine.
<LI>If no error occurs, the call to <CODE>Success</CODE> removes the failure handler from the list.<P>
</UL>
 Note that the call to <CODE>ReSignal</CODE>, which invokes the next failure handler in the list, is not always necessary--the error code from the first handler may handle the error condition completely. <CODE>ReSignal</CODE> is a convenience routine that just calls <CODE>Failure</CODE>, passing the same message and error number values from the previous call. The <CODE>Failure</CODE> routine is described beginning on <A HREF=#MARKER-9-68>page 563</A>.<P>
 <A HREF=#MARKER-9-61>Figure 24-2</A> shows the classes, methods, and routines used by MacApp and your application to handle failures and display error messages.<P>
<B>Figure 24-2  <A NAME=MARKER-9-61></A>Failure-handling and error-message classes, methods, and routines</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-088.gif"><P>
<A NAME=HEADING125-10></A>
<H2><A NAME=MARKER-2-62></A><A NAME=MARKER-9-63></A>MacApp Error-Checking Routines</H2>
 MacApp supplies the following global routines to check for common error conditions:<P>
<DL>
<DT><CODE>FailMemError<B></B></CODE>
<DD> The <CODE>FailMemError</CODE> routine calls the Toolbox routine <CODE>MemError</CODE> to check whether the last memory operation caused an error. You call <CODE>FailMemError</CODE> after making a Toolbox call that affects memory, such as <CODE>SetPtrSize</CODE> or <CODE>SetHandleSize</CODE>.
<DT><CODE>FailNIL<B></B></CODE>
<DD> The <CODE>FailNIL</CODE> routine tests whether the passed <CODE>void *</CODE> value is <CODE>NULL</CODE>. The most common value passed to <CODE>FailNIL</CODE> is a newly created object reference, pointer, or handle. <CODE>FailNIL</CODE> fails with <CODE>memFullErr</CODE> as the error message. This results in an error message of "Unable to &lt;x&gt; because there is not enough memory." &lt;x&gt; is a string that describes the current operation, such as "open a new document".
<DT><CODE>FailNILResource<B></B></CODE>
<DD> The <CODE>FailNILResource</CODE> routine checks whether the handle returned by a Resource Manager call is <CODE>NULL</CODE>. You pass <CODE>FailNILResource</CODE> the handle returned by a Resource Manager call such as <CODE>GetResource</CODE>.
<DT><CODE>FailNonObject</CODE>
<DD> The <CODE>FailNonObject</CODE> routine attempts to determine whether the passed pointer references an object, and generates a failure if it doesn't. The checking is more robust when the application is built with MacApp's debugging support.
<DT>
<DD> You use <CODE>FailNonObject</CODE> to check whether an object pointer is valid when you really expect it to be valid. If the value passed is <CODE>NULL</CODE> or does not point to something that looks like an object, <CODE>FailNonObject</CODE> fails with <CODE>minErr</CODE> as the error message: "Unable to &lt;x&gt; because there is not enough memory."
<DT><CODE>FailNoReserve<B></B></CODE>
<DD> The <CODE>FailNoReserve</CODE> routine checks whether the application's temporary reserve is low. Calling <CODE>FailNoReserve</CODE> causes MacApp to rebuild its memory reserves, so use it sparingly, such as when you <I>must</I> be sure that some reserve space is available.
<DT><CODE>FailOSErr<B></B></CODE>
<DD> The <CODE>FailOSErr</CODE> routine tests whether the passed <CODE>OSErr</CODE> value is not equal to <CODE>noErr</CODE>. The most common value passed to <CODE>FailOSErr</CODE> is the result of a Toolbox call, such as <CODE>FSWrite</CODE>.
<DT><CODE>FailResError<B></B></CODE>
<DD> The <CODE>FailResError</CODE> routine calls the Toolbox routine <CODE>ResError</CODE> to check whether there was an error caused by the last resource operation. You call <CODE>FailResError</CODE> after making a Resource Manager call that does not return a handle to the resource.
<DT><CODE>FailSpaceIsLow<B></B></CODE>
<DD> The <CODE>FailSpaceIsLow</CODE> routine checks whether the low-space reserve is missing. <CODE>FailSpaceIsLow</CODE> causes MacApp to rebuild its memory reserves, so it should not be called indiscriminately.
</DL>
 You can read more about these error-checking routines in the <I>MacApp Class and Method Reference</I>. The temporary and low-space reserves are described in <A HREF=MacAppProgGuide-30.html#MARKER-9-104>"Dynamic Memory Allocation," beginning on page 62</A>.<P>
 You call an error-checking routine with code like the following:<P>
<PRE>
fDataHandle = (Handle)GetPixPat(fRsrcID);
FailNILResource(fDataHandle);
</PRE>
 This code calls the Toolbox routine <A NAME=MARKER-2-64></A>GetPixPat to get a <CODE>'<A NAME=MARKER-2-65></A>ppat'</CODE> resource. It then calls FailNILResource to determine whether the call succeeded and to generate a failure and display an error message if it did not.<A NAME=MARKER-2-46></A><P>
<A NAME=HEADING125-25></A>
<H2><A NAME=MARKER-2-67></A><A NAME=MARKER-9-68></A>The Failure Routine</H2>
 When an error-checking routine is called but no error occurs, it simply returns. When an error does occur, the error-checking routine calls MacApp's <CODE>Failure</CODE> routine to process the error. The interface to <CODE>Failure</CODE> is defined as follows:<P>
<PRE>
void Failure(OSErr error, long message)
</PRE>
 The parameters to <CODE>Failure</CODE> are discussed in the following section. The <CODE>Failure</CODE> routine starts the process of handling an error by retrieving the most recent failure handler from the linked list and restoring the machine state stored by the handler. Routines called after the handler was initialized are skipped, and execution continues in the failure handler's error-recovery code branch. The error-recovery code performs its cleanup, then optionally calls <CODE>ReSignal</CODE> to invoke the next failure handler to continue the process.<P>
 The next section describes MacApp's mechanism for displaying failure-related errors.<P>
<A NAME=HEADING125-30></A>
<H2><A NAME=MARKER-9-69></A>How Error Messages Are Displayed</H2>
 If each failure handler calls ReSignal to invoke the next failure handler in the list, the handler installed by the application object's <CODE><A NAME=MARKER-2-70></A>PollEvent</CODE> method is eventually reached. Its error-recovery code calls the application's <CODE><A NAME=MARKER-2-38></A>ShowError</CODE> method, passing the same error and message parameters that were passed to the <CODE>Failure</CODE> routine. <CODE><A NAME=MARKER-2-72></A>ShowError</CODE> passes these parameters on to the <CODE>ErrorAlert</CODE> routine to display an alert box.<P>
 <A NAME=MARKER-2-73></A>MacApp supplies several <CODE>'ALRT'</CODE> resources to display error message strings to the user. These resources each have placeholders, denoted as ^0, ^1, and ^2. The MacApp constants for these alert resources, and the message strings they contain, are as follows:<P>
<DL>
<DT><CODE><A NAME=MARKER-2-74></A>phGenError</CODE>
<DD> Could not ^2, because ^0. ^1.
<DT><CODE><A NAME=MARKER-2-75></A>phCommandError</CODE>
<DD> Could not complete the ^2 command because ^0. ^1.
<DT><CODE><A NAME=MARKER-2-76></A>phUnknownErr</CODE>
<DD> Could not complete your request because ^0. ^1.
</DL>
 The placeholder ^2 is called the operation (the command or operation that caused the error), ^0 is called the reason (why the operation could not be completed), and ^1 is called the recovery (what the user can do to recover from the error).<P>
 The <CODE>ErrorAlert</CODE> routine chooses an alert resource and fills in the placeholders based on the <CODE>error</CODE> and <CODE>message</CODE> values passed to it. <CODE>ErrorAlert</CODE> uses the Toolbox routine <CODE><A NAME=MARKER-2-77></A>ParamText</CODE> to set the alert text. The placeholders are filled in as follows:<P>
<UL>
<LI>^0: <CODE>ErrorAlert</CODE> uses the <CODE>error</CODE> parameter passed to <CODE>Failure</CODE> to look up a string that describes the kind of error that occurred.
<LI>^1: Depending on the <CODE>error</CODE> parameter passed to <CODE>Failure</CODE>, it may or may not be appropriate to use the ^1 placeholder. When appropriate, <CODE>ErrorAlert</CODE> uses the <CODE>error</CODE> parameter to specify a string that suggests a recovery strategy.
<LI>^2: <CODE>ErrorAlert</CODE> treats the <CODE>message</CODE> parameter, a long integer, as a pair of numbers. The high word of <CODE>message</CODE> determines how the low word is interpreted. There are five possibilities:<P>
<UL>
<LI>high word = <CODE>messageCommandError<BR></CODE>The low word is the command number. <CODE>ErrorAlert</CODE> translates that command number into a command name and substitutes it for ^2. The <CODE>phCommandError</CODE> alert is used.
<LI>high word = <CODE>messageAlert<BR></CODE>The low word is an alert number (that is, a resource number). This is generally an alert that you have defined. That alert is displayed. In this case, <CODE>ErrorAlert</CODE> does not call <CODE>ParamText</CODE>, and does nothing to set replacement text for the placeholders.
<LI>high word = <CODE>messageLookup<BR></CODE>The low word is a positive integer index into a message table in the resource file. <CODE>ErrorAlert</CODE> retrieves a string to replace ^2 that describes the operation.
<LI>high word = none of above<BR>The high word is a resource ID for a string list, and the low word is an index into that list. <CODE>ErrorAlert</CODE> substitutes the specified string for ^2. <CODE>ErrorAlert</CODE> uses the <CODE>phGenError</CODE> alert.
<LI>message = 0<BR><CODE>ErrorAlert</CODE> uses the <CODE>phUnknownErr</CODE> alert.<P>
</UL>
</UL>
<DL>
<DT><B>Note</B>
<DD>Placeholders are convenient for English language applications, but it is easier to internationalize (or localize)  applications that use only complete error strings.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING125-47></A>
<H3><A NAME=MARKER-2-78></A>Setting the Error Message in a Failure Handler</H3>
 After you have dealt with an error in your failure-handling code, you can either return normally by doing nothing or propagate the error by calling <CODE>ReSignal</CODE>. The <CODE>FailInfo::<A NAME=MARKER-2-79></A>ReSigna</CODE>l method just calls <CODE>Failure</CODE> to execute the next failure handler in the list, passing the same <CODE>error</CODE> and <CODE>message</CODE> values that were passed to your failure handler.<P>
 If the message parameter was already set to a nonzero value, you don't usually want to change it in your failure handler. A failure handler should generally assume that the routine that called <CODE>Failure</CODE> has more specific knowledge about the error, so the values it supplied for <CODE>error</CODE> and <CODE>message</CODE> are the most appropriate values.<P>
 To set the <CODE>message</CODE> value only if it hasn't been set already, you can call the <CODE><A NAME=MARKER-2-80></A>FailNewMessage</CODE> global routine instead of calling <CODE>ReSignal</CODE>. The <CODE>FailNewMessage</CODE> routine has three parameters: <CODE>error</CODE>, <CODE>oldMessage</CODE>, and <CODE>newMessage</CODE>. You pass the <CODE>error</CODE> value, the previous <CODE>message</CODE> value, and a <CODE>newMessage</CODE> value to use if the previous value is 0. <CODE>FailNewMessage</CODE> calls <CODE>Failure</CODE>, passing the old message if it isn't 0, and otherwise the new message.<P>
<A NAME=HEADING125-51></A>
<H3><A NAME=MARKER-2-81></A><A NAME=MARKER-9-82></A>Calling the Failure Routine Directly</H3>
 Instead of calling one of the error-checking routines supplied by MacApp, your application can check for errors itself, then call MacApp's <CODE>Failure</CODE> routine if it detects an error. When you call <CODE>Failure</CODE> directly, you supply error and message parameters as described in <A HREF=#MARKER-9-69>"How Error Messages Are Displayed," beginning on page 564</A>. You can either pass <CODE>error</CODE> and <CODE>message</CODE> values that are defined by MacApp, or you can define your own special messages. The following example shows how to fail with a program error instead of an out-of-memory error:<P>
<PRE>
fDataHandle = YourGetDataHandleRoutine(); // Returns a data handle.
if (fDataHandle == NULL)
   Failure(minErr, 0);
</PRE>
 In this code fragment, you expect to get the YourGetDataHandleRoutine routine to return a handle. If you call <CODE>FailNIL</CODE> on the returned value and the value is NULL, the error message would be "Unable to &lt;x&gt; because there is not enough memory." By calling <CODE>Failure</CODE> directly and passing <CODE>minErr</CODE> as the error value, the error message becomes "Unable to &lt;x&gt; because of a program error."<P>
<DL>
<DT><B>Note</B>
<DD><A NAME=MARKER-2-83></A>When you call <CODE>Failure</CODE> directly, you can effectively create a "silent failure" (no message is displayed) with a call like the following:  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<PRE>
Failure(noErr, 0);// Silent failure. u
</PRE>
 You can also override the <CODE>ShowError</CODE> method in your application class to change the way error alerts are displayed.<P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-124.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-126.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
