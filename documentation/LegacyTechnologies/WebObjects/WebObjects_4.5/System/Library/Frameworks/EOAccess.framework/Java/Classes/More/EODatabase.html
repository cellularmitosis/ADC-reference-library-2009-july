<HTML>		<HEAD>		<TITLE>					</TITLE>		</HEAD>	<body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../../webobjects.html" target="_top">WebObjects 4.5 Documentation</a> <b>&gt;</b>EOAdaptor Reference</font><br><br><!--end of path --><a href="../../EOAccessTOC.html"><img src="../../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> <a name = "EODatabase"><h1><FONT COLOR=\"#000066\"><a name="//apple_ref/java/cl/EODatabase">EODatabase</a></FONT></h1><br></a><br><a name = "DAEDDFEF"><h2>The Database Level</h2></a><p>The EODatabase, EODatabaseContext, and EODatabaseChannel classesform the database level of the Enterprise Objects Framework. Thedatabase level is a client of the <b>adaptor level</b>,which is defined by the adaptor classes: EOAdaptor, EOAdaptorContext,and EOAdaptorChannel. Together, the database and adaptor levelsmake up the <b>access layer</b> of the Enterprise ObjectsFramework.</p><center><p><b>The Access Layer</b></p><img src = "../Art/AdDb.GIF" alt = "[image: ../Art/AdDb.gif]"></center><p>The database level acts as an intermediary between the adaptorlevel and the <b>control layer</b>, which includes anEOObjectStoreCoordinator and an EOEditingContext ( <a frame= "conv" href="#CIDDJEBF">Figure 0-2</a>). Thecontrol layer operates in terms of enterprise objects, while theadaptor level operates in terms of database rows packaged as NSDictionaries.It's the job of the database level to perform the necessary object-to-relationaltranslation between the two. </p><p>There's little need for your code to interact directly withan EODatabase object. An EOEditingContext creates its own databaselevel objects, which create their own corresponding adaptor levelobjects. Once the network of objects is in place, your code mightinteract with an EODatabase to access its corresponding EOAdaptorobject, but additional programmatic interaction is usually unnecessary.</p><center><a name = "CIDDJEBF"><p><b>The EODatabaseLevel as an Intermediary Between the Adaptor Level and the ControlLayer</b></p></a><img src = "../Art/AdDbEc.GIF" alt = "[image: ../Art/AdDbEc.GIF]"></center><br><a name = "DAEDJCCB"><h2>Snapshots</h2></a><p>EODatabase's most significant responsibility is to record <b>snapshots</b> forits EODatabaseContexts. A snapshot is a dictionary whose keys areattribute names and whose values are the corresponding, last-knowndatabase values. Enterprise Objects Framework records snapshotsas it successfully fetches, inserts and updates enterprise objects.Snapshot information is used when changes to enterprise objects aresaved back out to the database to ensure that row data has not beenchanged by someone else since it was last recorded by the application.</p><p>A snapshot contains entries for a row's primary key, classproperties, foreign keys for class property relationships, and attributesused for locking. They are recorded under the globalIDs of theirenterprise objects. (EOGlobalIDs are based on an object's primarykey and its associated entity; see the class specification for EOGlobalIDin the EOControl framework for more information.)</p><p>EODatabase also records snapshots for to-many relationships.These snapshots consist of an NSDictionary of NSDictionaries, inwhich the top-level dictionary has as its key the globalID of the enterpriseobject for which to-many relationships are being recorded. The key'svalue is a dictionary whose keys are the names of the enterpriseobject's to-many relationships. Each of these keys in turn hasas its value an array of globalIDs that identify the objects atthe destination of the relationship.</p><p>The snapshots made by an EODatabase form the global view ofdata for nearly every other part of the application, representingthe current view of data in the server as far as the applicationis concerned (though other applications may have made changes).This global view is temporarily overridden locally by EODatabaseContexts,which form their own snapshots as they make changes during a transaction.When an EODatabaseContext commits its top-level transaction, itreconciles all changed snapshots with the global view of the databaseobject, so that other database contexts (except those with opentransactions) immediately use the new snapshots as well. EODatabaseContextsautomatically use their EODatabase to record snapshots, so there'sno need for your application to intervene in an EODatabase's snapshottingmechanism.</p><p>For more information on snapshots and how they relate to anapplication's update strategy, see the EODatabaseContext classspecification.</p><br><h2>Entity Caching</h2><p>An EODatabase object also performs the function of cachingenterprise objects for entities that cache their objects (see theEOEntity class specification). An EODatabase's entity cache storesthe globalIDs of enterprise objects for entities that cache theirobjects. The first time you perform a fetch against such an entity,all of its objects are fetched, regardless of the fetch specificationused. The globalIDs of the resulting objects are stored in the EODatabase'sentity cache by entity name. Whenever possible, subsequent fetchesare performed against the cache (in memory) rather than againstthe database. With a globalID, Enterprise Objects Framework canlook up the values for the corresponding object in its snapshotusing EODatabase's or EODatabaseContext's snapshotForGlobalID: method.</p><p>As an example, suppose that you have an entity named Ratingthat contains all the valid ratings for Movies (G, PG, R, and soon). Rather than store a Movie's rating directly in the Movieas an attribute, Movie maintains a relationship to a Rating. Tospecify a rating for a movie, users select the rating from a pop-uplist of the possible values. Since the ratings in the Rating entitynever change, the Rating entity should cache its objects. The valuesthat populate the rating pop-up list are only fetched once, and there'sno need to fetch them again; the relationships between Movies andRatings can be maintained without subsequent fetches.</p><p>The entity cache is managed automatically; you shouldn'thave to manipulate it explicitly. However, if you need to accessor alter the cache, EODatabase provides several methods for interactingwith it.</p><dd></dd><br><a href="../../EOAccessTOC.html"><img src="../../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> </BODY></HTML>