<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Handling Request Codes</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING87></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="ACI-86.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ACI-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ACI-122.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ACI-88.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="ACI-2.html"><B>Advanced Color Imaging on the Mac OS</B></A> / <BR><DD><A HREF="ACI-79.html"><B>Chapter 5 - Developing Color Management Modules </B></A> / <A HREF="ACI-81.html"><B>Creating a Color Management Module </B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING87-0></A>
<H2>Handling Request Codes</H2>
 When your <A NAME=MARKER-2-43></A>component receives a request, it should examine the <CODE>what</CODE> field of the component parameters data structure to determine the nature of the request, perform the appropriate processing, set an error code if necessary, and return an appropriate function result to the Component Manager.<P>
 Your entry point routine can call a separate subroutine to handle each type of request. <A HREF=#nonexistent-marker>Chapter 4, "ColorSync Manager Reference for Color Management Modules,"</A> in <I>Advanced Color Imaging Reference</I> describes the prototypes for functions your CMM must supply to handle the corresponding ColorSync Manager request codes. The entry routine itself can unpack the parameters from the params parameter to pass to its subroutines, or it can call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> routine or <CODE>CallComponentFunction</CODE> routine to perform these services.<P>
 The <CODE>CallComponentFunctionWithStorage</CODE> function is useful if your CMM uses private storage. When you call this function, you pass it a handle to the storage for this component instance, the component parameters data structure, and the address of your subroutine handler. Each time it calls your entry point function, the Component Manager passes to your function the storage handle along with the component parameters data structure. For a description of how you associate private storage with a component instance, see <A HREF=#MARKER-9-46>"Establishing the Environment for a New Component Instance" (page 5-21)</A>. The Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function extracts the calling application's parameters from the component parameters data structure and invokes your function, passing to it the extracted parameters and the private storage handle. <P>
 <A HREF=#MARKER-9-44>Listing 5-2</A> shows sample code that illustrates how to respond to the required Component Manager and ColorSync Manager requests. For a complete listing of the sample code on which this listing is based, see the Apple technical note QT05, "Component Manager Version 3.0." This technical note shows how to create a fat component, which is a single component usable for both 68K-based and PowerPC-based systems. The portion of sample code in <A HREF=#MARKER-9-44>Listing 5-2</A> for PowerPC-based systems uses a parameter block data structure to pass parameters. The data structure for this parameter block is generated from a macro in the <CODE>MixedMode.h</CODE> header file. <P>
<B>Listing 5-2  <A NAME=MARKER-9-44></A>A CMM component shell </B><P>
<PRE>
#include &lt;Types.h&gt;
#include &lt;Quickdraw.h&gt;
#include &lt;Memory.h&gt;
#include &lt;Gestalt.h&gt;
#include &lt;Components.h&gt;
#include &lt;CMMComponent.h&gt;
#if GENERATING68K
#include &lt;A4Stuff.h&gt;
#endif
#define DEBUG 0
#ifndef DEBUG
#define DEBUG 0
#endif
/* component version */
#define CMCodeVersion0
#defineCMVersion  ((CMMInterfaceVersion &lt;&lt; 16) | CMCodeVersion)

/* component storage */
struct CMMStorageRecord {ComponentInstanceci;};
typedef struct CMMStorageRecordCMMStorageRecord, **CMMStorageHandle;
#if GENERATINGPOWERPC
   #define CallComponentFunctionWithStorageUniv(storage, params, funcName) \
      CallComponentFunctionWithStorage(storage, params, &amp;funcName##RD)
   #define CallComponentFunctionUniv(params, funcName) \
      CallComponentFunction(params, &amp;funcName##RD)
   #define INSTANTIATE_ROUTINE_DESCRIPTOR(funcName) RoutineDescriptor funcName##RD = \
      BUILD_ROUTINE_DESCRIPTOR (upp##funcName##ProcInfo, funcName)
#else
   #define CallComponentFunctionWithStorageUniv(storage, params, funcName) \
      CallComponentFunctionWithStorage(storage, params,
                                 (ComponentFunctionUPP)funcName)
   #define CallComponentFunctionUniv(params, funcName) \
      CallComponentFunction(params, (ComponentFunctionUPP)funcName)
#endif
enum{
   uppDoComponentOpenProcInfo = kPascalStackBased
      | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))
      | STACK_ROUTINE_PARAMETER(1,SIZE_CODE(sizeof(ComponentInstance)))
};
enum {
   uppDoComponentCloseProcInfo = kPascalStackBased
      | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))
      | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Handle)))
      | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(ComponentInstance)))
};
enum {
   uppDoComponentCanDoProcInfo = kPascalStackBased
      | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult))) 
      | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))
};
enum {
   uppDoComponentVersionProcInfo = kPascalStackBased
      | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))
};
enum {
   uppDoComponentRegisterProcInfo = kPascalStackBased
      | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))
};
enum {
   uppDoCMInitProcInfo = kPascalStackBased
      | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))
      | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Handle)))
      | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(CMProfileHandle)))
      | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(CMProfileHandle)))
};
enum {
   uppDoNCMInitProcInfo = kPascalStackBased
      | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))
      | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Handle)))
      | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(CMProfileRef)))
      | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(CMProfileRef)))
};
enum {
   uppDoCMMatchColorsProcInfo = kPascalStackBased
      | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))
      | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Handle)))
      | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(CMColor*)))
      | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(unsigned long)))
};
enum {
   uppDoCMCheckColorsProcInfo = kPascalStackBased
      | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))
      | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Handle)))
      | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(CMColor*)))
      | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(unsigned long)))
      | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long*))
};
/* function prototypes */
pascal ComponentResult main(ComponentParameters *params, Handle storage);
pascal ComponentResult DoComponentOpen(ComponentInstance self);
pascal ComponentResult DoComponentClose(CMMStorageHandle storage, 
                                 ComponentInstance self);
pascal ComponentResult DoComponentCanDo(short selector);
pascal ComponentResult DoComponentVersion(void);
pascal ComponentResult DoComponentRegister(void);
pascalComponentResult DoCMInit(CMMStorageHandle storage, CMProfileHandle srcProfile,
                        CMProfileHandle dstProfile);
pascalComponentResult DoNCMInit(CMMStorageHandle storage, CMProfileRef srcProfile, 
                        CMProfileRef dstProfile);
pascalComponentResult DoCMMatchColors(CMMStorageHandle storage, CMColor *colorBuf, 
                              unsigned long count);
pascal ComponentResult DoCMCheckColors(CMMStorageHandle storage, CMColor *colorBuf, 
                              unsigned long count, long *gamutResult);
#if GENERATINGPOWERPC
   /* Routine descriptors for component functions */
   INSTANTIATE_ROUTINE_DESCRIPTOR(DoComponentOpen);
   INSTANTIATE_ROUTINE_DESCRIPTOR(DoComponentClose);
   INSTANTIATE_ROUTINE_DESCRIPTOR(DoComponentCanDo);
   INSTANTIATE_ROUTINE_DESCRIPTOR(DoComponentVersion);
   INSTANTIATE_ROUTINE_DESCRIPTOR(DoComponentRegister);
   INSTANTIATE_ROUTINE_DESCRIPTOR(DoCMInit);
   INSTANTIATE_ROUTINE_DESCRIPTOR(DoNCMInit);
   INSTANTIATE_ROUTINE_DESCRIPTOR(DoCMMatchColors);
   INSTANTIATE_ROUTINE_DESCRIPTOR(DoCMCheckColors);
/* PowerPC main component entry point */
   RoutineDescriptor MainRD = BUILD_ROUTINE_DESCRIPTOR(uppComponentRoutineProcInfo,
                                             main);

   ProcInfoType __procinfo = uppComponentRoutineProcInfo;
#endif
pascal ComponentResult main(ComponentParameters *params, Handle storage);
/* Abstract:
      main entry point to CMM Component
   Params:
      params(in) Parameters in form used by Component Manager
      storage(in) Handle to memory to be used by CMM
   Return:
      noErr If successful
         Otherwise System or ColorSync result code
*/
/* This main function must run on all Macs. */
pascalComponentResult main(ComponentParameters *params, Handle storage)
{
   ComponentResultresult;
   short       message;

   #if GENERATING68K
   long     oldA4;
   oldA4 = SetCurrentA4();
   #endif
   message = (*params).what;

   /* selectors &lt; 0 for Component Manager functions */ 
   if (message &lt; 0)
   {
      switch (message)
      {
         case kComponentOpenSelect :
            result = CallComponentFunctionUniv (params, DoComponentOpen);
            break; 
         
         case kComponentCloseSelect :
            result = CallComponentFunctionWithStorageUniv(storage, params,
                                                DoComponentClose);
            break;
         case kComponentCanDoSelect :
            result = CallComponentFunctionUniv(params, DoComponentCanDo);
            break;

         case kComponentVersionSelect :
            result = CallComponentFunctionUniv(params, DoComponentVersion);
            break;

         case kComponentRegisterSelect :
            result = CallComponentFunctionUniv(params, DoComponentRegister);
            break;

         default :
            result = noErr;
            break;
      }
   }
/* selectors &gt;= 0 for CMM functions */ 
   else
   {
      switch (message)
      { 
         case kCMMInit :
            result = CallComponentFunctionWithStorageUniv(storage, params,
                                                DoCMInit);
            break;

         case kNCMMInit :
            result = CallComponentFunctionWithStorageUniv(storage, params,
                                                DoNCMInit);
            break;

         case kCMMMatchColors :
            result = CallComponentFunctionWithStorageUniv(storage, params,
                                                DoCMMatchColors);
            break;

         case kCMMCheckColors :
            result = CallComponentFunctionWithStorageUniv(storage, params, 
                                                DoCMCheckColors);
            break;

         default :
            result = unimpErr;
            break;
      }
   }
   #if GENERATING68K
      SetA4(oldA4);
   #endif
   return result;
}
</PRE>
 For more information describing how your CMM component should respond to request code calls from the Component Manager, see "Creating Components" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I>. <P>
<A NAME=HEADING87-45></A>
<H3>Responding to <A NAME=MARKER-2-45></A>Required Component Manager Request Codes</H3>
 This section describes some of the processes your CMM can perform in response to the following Component Manager requests that it must handle: <P>
<UL>
<LI><A HREF=#MARKER-9-46>"Establishing the Environment for a New Component Instance" (page 5-21)</A> describes how to handle a <CODE>kComponentOpenSelect</CODE> request.
<LI><A HREF=#MARKER-9-48>"Releasing Private Storage and Closing the Component Instance" (page 5-21)</A> describes how to handle a <CODE>kComponentCloseSelect</CODE> request.
<LI><A HREF=#MARKER-9-50>"Determining Whether Your CMM Supports a Request" (page 5-21)</A> describes how to handle a <CODE>kComponentCanDoSelect</CODE> request.
<LI><A HREF=#MARKER-9-52>"Providing Your CMM Version Number" (page 5-22)</A> describes how to handle a <CODE>kComponentVersionSelect</CODE> request.<P>
</UL>
<A NAME=HEADING87-51></A>
<H4><A NAME=MARKER-9-46></A>Esta<A NAME=MARKER-2-47></A>blishing the Environment for a New Component Instance</H4>
 When a ColorSync-supportive application or device driver first calls a function that requires the services of your CMM, the Component Manager calls your CMM with a <CODE>kComponentOpenSelect</CODE> request to open and establish an instance of your component for the calling program. The component instance defines a unique connection between the calling program and your CMM.<P>
 In response to this request, you should allocate memory for any private data you require for the connection. You should allocate memory from the current heap zone. It that attempt fails, you should allocate memory from the system heap or the temporary heap. You can use the <CODE>SetComponentInstanceStorage</CODE> function to associate the allocated memory with the component instance. <P>
 For more information on how to respond to this request and open connections to other components, see "Creating Components" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I>. <P>
<A NAME=HEADING87-55></A>
<H4><A NAME=MARKER-9-48></A>Releasing Private Storage and Closing the Component Instance</H4>
 To call your CMM with a <A NAME=MARKER-2-49></A>close request, the Component Manager sets the <CODE>what</CODE> field of the component parameters data structure to <CODE>kComponentCloseSelect</CODE>. In response to this request code, your CMM should dispose of the storage memory associated with the connection. <P>
<A NAME=HEADING87-57></A>
<H4><A NAME=MARKER-9-50></A>Determining Whether Your CMM Supports a Request</H4>
 Before t<A NAME=MARKER-2-51></A>he ColorSync Manager calls your CMM with a request code on behalf of a ColorSync-supportive application or driver that called the corresponding function, the Component Manager calls your CMM with a can do request to determine if your CMM implements support for the request.<P>
 To call your CMM with a can do request, the Component Manager sets the <CODE>what</CODE> field of the component parameters data structure to the value <CODE>kComponentCanDoSelect</CODE>. In response, you should set your CMM entry point function's result to 1 if your CMM supports the request and 0 if it doesn't. <P>
<A NAME=HEADING87-60></A>
<H4><A NAME=MARKER-9-52></A>Providing Your CMM Version Number</H4>
 To call your CMM requesting its version number, the Component Manager sets the <CODE>what</CODE> field of the component parameters data structure to the value <CODE>kComponentVersionSelect</CODE>. <A NAME=MARKER-2-53></A>In response, you should set your CMM entry point function's result to the CMM version number. Use the high-order 16 bits to represent the major version and the low-order 16 bits to represent the minor version. The major version should represent the component specification level; the minor version should represent your implementation's version number. <P>
 If your CMM supports the ColorSync Manager version 2.x, your CMM should return the constant for the major version defined by the following enumeration when the Component Manager calls your CMM with the <CODE>kComponentVersionSelect</CODE> request code: <P>
<PRE>
enum {
   CMMInterfaceVersion = 1
   };
</PRE>
<A NAME=HEADING87-64></A>
<H3><A NAME=MARKER-2-54></A>Responding to ColorSync Manager Required Request Codes</H3>
 This section describes some of the processes your CMM can perform in response to the following ColorSync Manager requests that it must handle:<P>
<UL>
<LI><A HREF=#MARKER-9-55>"Initializing the Current Component Instance for a Session Involving Two Profiles" (page 5-22)</A> describes how to handle a <CODE>kNCMMInit</CODE> request.
<LI><A HREF=#MARKER-9-59>"Matching a List of Colors to the Destination Profile's Color Space" (page 5-23)</A> describes how to handle a <CODE>kCMMMatchColors</CODE> request.
<LI><A HREF=#MARKER-9-62>"Checking a List of Colors" (page 5-24)</A> describes how to handle a <CODE>kCMMCheckColors</CODE> request.<P>
</UL>
<A NAME=HEADING87-69></A>
<H4><A NAME=MARKER-9-55></A>Initializing the Current Component Instance for a Session Involving Two Profiles</H4>
 The Component Manager calls your CMM with an initialization request, setting the <CODE>what</CODE> field of the component parameters data structure to <CODE>kNCMMInit</CODE>. In most cases the Component Manager calls your CMM with an <A NAME=MARKER-2-57></A>initialization request before it calls your <A NAME=MARKER-2-58></A>CMM with any other ColorSync Manager requests. <P>
 In response to this request, your CMM should call its <CODE>MyNCMInit</CODE> initialization subroutine. For a description of the function prototype your initialization subroutine must adhere to, see MyNCMInit <A HREF=#nonexistent-marker>(page 4-10)</A> in <I>Advanced Color Imaging Reference</I>.<P>
 Using the private storage you allocated in response to the open request, your initialization subroutine should instantiate any private data it needs for the component instance. Before your entry point function returns a function result to the Component Manager, your subroutine should store any profile information it requires. In addition to the standard profile information, you should store the profile header's quality flags setting, the profile size, and the rendering intent. After you return control to the Component Manager, you cannot use the profile references again. <P>
 The <CODE>kNCMMInit</CODE> request gives you the opportunity to examine the profile contents before storing them. If you do not support some aspect of the profile, then you should return an unimplemented error in response to this request. For example, if your CMM does not implement multichannel color support, you should return an "unimplemented" error at this point.<P>
 The Component Manager may call your CMM with the <CODE>kNCMMInit</CODE> request code multiple times after it calls your CMM with a request to open the CMM. For example, it may call your CMM with an initialization request once with one pair of profiles and then again with another pair of profiles. For each call, you need to reinitialize the storage based on the content of the current profiles. <P>
 Your CMM should support all seven classes of profiles defined by the ICC. For information on the seven classes of profiles, see <A HREF=#nonexistent-marker>"Profile Classes" (page 3-13)</A> in <I>Advanced Color Imaging Reference</I>.<P>
<A NAME=HEADING87-76></A>
<H4><A NAME=MARKER-9-59></A>Matching a List of Colors to the Destination Profile's Color Space</H4>
 <A NAME=MARKER-2-60></A>When a ColorSync-supportive application or device driver calls the <CODE>CWMatchColors</CODE> function for your CMM to handle, the Component Manager calls your CMM with a color-matching session request, setting the <CODE>what</CODE> field of the component parameters data structure to <CODE>kCMMMatchColors</CODE> and passing you a list of colors to match<A NAME=MARKER-2-61></A>. The Component Manager may also call your CMM with this request code to handle other cases, for example, when a ColorSync-supportive program calls the <CODE>CWMatchPixMap</CODE> function.<P>
 Before it calls your CMM with this request, the Component Manager calls your CMM with one of the initialization requests--<CODE>kCMMInit    </CODE>, <CODE> kNCMMInit</CODE>, or   <CODE>kCMMConcatInit</CODE>    --passing to your CMM in the <CODE>params</CODE> field of the component parameters data structure the profiles for the color-matching session. <P>
 In response to the <CODE>kCMMMatchColors</CODE> request, your CMM should call its <CODE>MyCMMatchColors</CODE> subroutine by calling the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function and passing it a handle to the storage for this component instance, the component parameters data structure, and the address of your <CODE>MyCMMatchColors</CODE> subroutine. For a description of the function prototype to which your subroutine must adhere, see MyCMMatchColors <A HREF=#nonexistent-marker>(page 4-12)</A> in <I>Advanced Color Imaging Reference</I>.<P>
 The parameters passed to your CMM for this request include an array of type <CODE>CMColor</CODE> containing the list of colors to match and a one-based count of the number of colors in the list.<P>
 To handle this request, your CMM must match the source colors in the list to the color gamut of the destination profile, replacing the color value specifications in the <CODE>myColors</CODE> array with the matched colors specified in the destination profile's data color space. You should use the rendering intent and the quality flag setting of the source profile in matching the colors. For a description of the color list array data structure, see the section <A HREF=#nonexistent-marker>"The Color Union" (page 3-59)</A> in <I>Advanced Color Imaging Reference</I>. <P>
<A NAME=HEADING87-82></A>
<H4><A NAME=MARKER-9-62></A>Checking a List of Colors </H4>
 When a ColorSync-supportive application or device driver calls the <CODE>CWCheckColors</CODE> function for your<A NAME=MARKER-2-63></A> CMM to handle, the Component Manager calls your CMM with a color gamut-checking session request, setting the <CODE>what</CODE> field of the component parameters data structure to <CODE>kCMMCheckColors</CODE> and passing you a list of colors to check. <P>
 Before the Component Manager calls your CMM with the <CODE>kCMMCheckColors</CODE> request, it calls your CMM with one of the initialization requests--<CODE>kCMMInit    </CODE>, <CODE> kNCMMInit</CODE>, or   <CODE>kCMMConcatInit</CODE>    --passing to your CMM in the <CODE>params</CODE> field of the component parameters data structure the profiles for the color gamut-checking session. <P>
 I<A NAME=MARKER-2-64></A>n response to the <CODE>kCMMCheckColors</CODE> request, your CMM should call its <CODE>MyCMCheckColors</CODE> subroutine. For example, if you use the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function, you pass it a handle to the storage for this component instance, the component parameters data structure, and the address of your <CODE>MyCMCheckColors</CODE> subroutine. For a description of the function prototype to which your subroutine must adhere, see MyCMCheckColors <A HREF=#nonexistent-marker>(page 4-14)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 In addition to the handle to the private storage containing the profile data, the <CODE>CallComponentFunctionWithStorage</CODE> function passes to your <CODE>MyCMCheckColors</CODE> subroutine an array of type <CODE>CMColor</CODE> containing the list of colors to gamut check, a one-based count of the number of colors in the list, and an array of longs. <P>
 To handle this request, your CMM should test the given list of colors against the gamut specified by the destination profile to determine whether the colors fall within a destination device's color gamut. For each source color in the list that is out of gamut, you must set the corresponding bit in the result array to 1. <A NAME=MARKER-2-65></A><P>
<A NAME=HEADING87-88></A>
<H3>Responding to ColorSync Manager Optional Request Codes</H3>
 <A NAME=MARKER-2-66></A>This section describes some of the processes your CMM can perform in response to the optional ColorSync Manager requests if your CMM supports them. Before the Component Manager calls your CMM with any of these requests, it first calls your CMM with a can do request to determine if you support the specific optional request code. This section includes the following: <P>
<UL>
<LI><A HREF=#MARKER-9-67>"Validating That a Profile Meets the Base Content Requirements" (page 5-26)</A> describes how to handle a <CODE>kCMMValidateProfile</CODE> request.
<LI><A HREF=#MARKER-9-70>"Matching the Colors of a Bitmap" (page 5-27)</A> describes how to handle a <CODE>kCMMMatchBitmap</CODE> request.
<LI><A HREF=#MARKER-9-73>"Checking the Colors of a Bitmap" (page 5-28)</A> describes how to handle a <CODE>kCMMCheckBitmap</CODE> request.
<LI><A HREF=#MARKER-9-76>"Matching the Colors of a Pixel Map Image" (page 5-29)</A> describes how to handle the <CODE>kCMMMatchPixMap</CODE> request.
<LI><A HREF=#MARKER-9-79>"Checking the Colors of a Pixel Map Image" (page 5-30)</A> describes how to handle the <CODE>kCMMCheckPixMap</CODE> request.
<LI><A HREF=#MARKER-9-82>"Initializing the Component Instance for a Session Using Concatenated Profiles" (page 5-31)</A> describes how to handle a <CODE>kCMMConcatInit</CODE> request.
<LI><A HREF=#MARKER-9-83>"Creating a Device-Linked Profile and Opening a Reference to It" (page 5-32)</A> describes how to handle a <CODE>kCMMNewLinkProfile</CODE> request.
<LI><A HREF=#MARKER-9-86>"Obtaining PostScript-Related Data From a Profile" (page 5-33)</A> describes how to handle the <CODE>kCMMGetPS2ColorSpace</CODE>, <CODE>kCMMGetPS2ColorRenderingIntent</CODE>, and <CODE>kCMMGetPS2ColorRendering </CODE>requests.
<LI><A HREF=#MARKER-9-91>"Obtaining the Size of the Color Rendering Dictionary for PostScript Printers" (page 5-34)</A> describes how to handle a <CODE>kCMMGetPS2ColorRenderingVMSize</CODE> request.
<LI><A HREF=#MARKER-9-94>"Flattening a Profile for Embedding in a Graphics File" (page 5-35)</A> describes how to handle a <CODE>kCMMFlattenProfile</CODE> request.
<LI><A HREF=#MARKER-9-97>"Unflattening a Profile" (page 5-36)</A> describes how to handle a <CODE>kCMMUnflattenProfile</CODE> request.
<LI><A HREF=#MARKER-9-102>"Supplying Named Color Space Information" (page 5-37)</A> describes how to handle the kCMMGetNamedColorInfo, kCMMGetNamedColorValue, kCMMGetIndNamedColorValue, kCMMGetNamedColorIndex, and kCMMGetNamedColorName requests.<P>
</UL>
<A NAME=HEADING87-102></A>
<H4><A NAME=MARKER-9-67></A>Validating That a Profile Meets the Base Content Requirements</H4>
 When a C<A NAME=MARKER-2-68></A>olorSync-supportive application or device-driver calls the <CODE>CMValidateProfile</CODE> function for your CMM to handle, the Component Manager calls your CMM with the <CODE>what</CODE> field of the component parameters data structure set to  <CODE>kCMMValidateProfile</CODE> if your CMM supports the request. <P>
 <A NAME=MARKER-2-69></A>In response to this request code, your CMM should call its <CODE>MyCMMValidateProfile </CODE>subroutine. One way to do this, for example, is by calling the Component Manager's <CODE>CallComponentFunction</CODE> function, passing it the component parameters data structure and the address of your <CODE>MyCMMValidateProfile</CODE> subroutine. To handle this request, you don't need private storage for ColorSync profile information, because the profile reference is passed to your function. However, if your CMM uses private storage for other purposes, you should call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function. For a description of the function prototype to which your subroutine must adhere, see MyCMMValidateProfile <A HREF=#nonexistent-marker>(page 4-17)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 The <CODE>CallComponentFunction</CODE> function passes to your <CODE>MyCMMValidateProfile</CODE> subroutine a reference to the profile whose contents you must check and a flag whose value you must set to report the results.<P>
 To handle this request, your CMM should test the profile contents against the baseline profile elements requirements for a profile of this type as specified by the International Color Consortium. It should determine if the profile contains the minimum set of elements required for its type and set the response flag to <CODE>true</CODE> if the profile contains the required elements and <CODE>false</CODE> if it doesn't.<P>
 To obtain a copy of the <I>International Color Consortium Profile Format Specification</I>, version 2.x, visit the ICC Web site at the following location:<P>
<PRE>
<a href="http://www.color.org/">http://www.color.org/</a>
</PRE>
 The ICC also defines optional tags, which may be included in a profile. Your CMM might use these optional elements to optimize or improve its processing. Additionally, a profile might include private tags defined to provide your CMM with processing capability it uses. The profile developer can define these private tags, register the tag signatures with the ICC, and include the tags in a profile. <P>
 If your CMM is dependent on optional or private tags, your <CODE>MyCMMValidateProfile</CODE> function should check for the existence of these tags also. <P>
 Instead of itself checking the profile for the minimum profile elements requirements for the profile type, your <CODE>MyCMMValidateProfile</CODE> function may use the Component Manager functions to call the default Apple-supplied CMM and have it perform the minimum defaults requirements validation. <P>
 To call the Apple-supplied CMM when responding to a <CODE>kCMMValidateProfile</CODE> request from an application, your CMM can use the standard mechanisms applications use to call a component. For information on these mechanisms, see the chapter "Component Manager" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I>. <P>
<A NAME=HEADING87-113></A>
<H4><A NAME=MARKER-9-70></A>Matching the Colors of a Bitmap</H4>
 Whe<A NAME=MARKER-2-71></A>n a C<A NAME=MARKER-2-72></A>olorSync-supportive application or device driver calls the <CODE>CWMatchBitMap</CODE> function for your CMM to handle, the Component Manager calls your CMM with the <CODE>what</CODE> field of the component parameters data structure set to  <CODE>kCMMMatchBitmap</CODE> if your CMM supports the request. If your CMM supports this request code, your CMM should be prepared to receive any of the bitmap types defined by the ColorSync Manager.<P>
 In response to this request code, your CMM should call its <CODE>MyCMMatchBitmap</CODE> subroutine. For example, to do this, your CMM may call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function, passing it the storage handle for this component instance, the component parameters data structure, and the address of your <CODE>MyCMMatchBitmap</CODE> subroutine. For a description of the function prototype to which your subroutine must adhere, see MyCMMatchBitmap <A HREF=#nonexistent-marker>(page 4-18)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 In addition to the storage handle for private storage for this component instance, the <CODE>CallComponentFunctionWithStorage</CODE> function passes to your <CODE>MyCMMatchBitmap</CODE> subroutine a pointer to the bitmap containing the source image data whose colors your function must match,  a pointer to a callback function supplied by the calling program, a reference constant your subroutine must pass to the callback function when you invoke it, and a pointer to a bitmap in which your function stores the resulting color-matched image. <P>
 The callback function supplied by the calling function monitors the color-matching progress as your function matches the bitmap colors. You should call this function at regular intervals. Your <CODE>MyCMMatchBitmap</CODE> function should monitor the progress function for a returned value of <CODE>true</CODE>, which indicates that the user interrupted the color-matching process. In this case, you should terminate the color-matching process. <P>
 To handle this request, your <CODE>MyCMMatchBitmap</CODE> function must match the colors of the source image bitmap to the color gamut of the destination profile using the profiles specified by a previous <CODE>kNCMInit</CODE>, <CODE>kCMMInit</CODE>, or <CODE>kCMMConcatInit</CODE> request to your CMM for this component instance. You must store the color-matched image in the bitmap result parameter passed to your subroutine. If you are passed a <CODE>NULL </CODE>parameter, you must match the bitmap in place. <P>
 For a description of the prototype of the callback function supplied by the calling program, see MyCMBitmapCallBackProc <A HREF=#nonexistent-marker>(page 3-170)</A> in <I>Advanced Color Imaging Reference</I> <P>
<A NAME=HEADING87-120></A>
<H4><A NAME=MARKER-9-73></A>Checking the Colors of a Bitmap </H4>
 <A NAME=MARKER-2-74></A>When a <A NAME=MARKER-2-75></A>ColorSync-supportive application or device driver calls the <CODE>CWCheckBitMap</CODE> function for your CMM to handle, the Component Manager calls your CMM with the <CODE>what</CODE> field of the component parameters data structure set to  <CODE>kCMMCheckBitmap</CODE> if your CMM supports the request. If your CMM supports this request code, your CMM should be prepared to receive any of the bitmap types defined by the ColorSync Manager.<P>
 In response to this request code, your CMM should call its <CODE>MyCMCheckBitmap</CODE> subroutine. For example, to do this, your CMM may call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function, passing it the storage handle for this component instance, the component parameters data structure, and the address of your <CODE>MyCMCheckBitmap</CODE> subroutine. For a description of the function prototype to which your subroutine must adhere, see MyCMCheckBitmap <A HREF=ACI-76.html#MARKER-9-173>(page 4-22)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 In addition to the storage handle for private storage for this component instance, the <CODE>CallComponentFunctionWithStorage</CODE> function passes to your <CODE>MyCMCheckBitmap</CODE> subroutine a pointer to the bitmap containing the source image data whose colors your function must check,  a pointer to a callback progress-reporting function supplied by the calling program, a reference constant your subroutine must pass to the callback function when you invoke it, and a pointer to a resulting bitmap whose pixels your subroutine must set to show if the corresponding source color is in or out of gamut. <P>
 The callback function supplied by the calling function monitors the color gamut-checking progress. You should call this function at regular intervals. Your <CODE>MyCMCheckBitmap</CODE> function should monitor the progress function for a returned value of <CODE>true</CODE>, which indicates that the user interrupted the color gamut-checking process. In this case, you should terminate the process. <P>
 For a description of the prototype of the callback function supplied by the calling program, see MyCMBitmapCallBackProc <A HREF=#nonexistent-marker>(page 3-170)</A> in <I>Advanced Color Imaging Reference</I> <P>
 Using the content of the profiles that you stored at initialization time for this component instance, your <CODE>MyCMCheckBitmap</CODE> subroutine must check the colors of the source image bitmap against the color gamut of the destination profile. If a pixel is out of gamut, your function must set the corresponding pixel in the result image bitmap to 1. The ColorSync Manager returns the resulting bitmap to the calling application or driver to report the outcome of the check. <P>
 For complete details on the <CODE>MyCMCheckBitmap</CODE> subroutine parameters and how your <CODE>MyCMCheckBitmap</CODE> subroutine communicates with the callback function, see MyCMCheckBitmap <A HREF=ACI-76.html#MARKER-9-173>(page 4-22)</A> in <I>Advanced Color Imaging Reference</I>. <P>
<A NAME=HEADING87-128></A>
<H4><A NAME=MARKER-9-76></A>Matching the Colors of a Pixel Map Image</H4>
 When a ColorSync<A NAME=MARKER-2-77></A>-supportive <A NAME=MARKER-2-78></A>application or device driver calls the <CODE>CWMatchPixMap</CODE> function for your CMM to handle, the Component Manager calls your CMM with the <CODE>what</CODE> field of the component parameters data structure set to  <CODE>kCMMMatchPixMap</CODE> if your CMM supports the request. If your CMM supports this request code, your <CODE>MyCMMatchPixMap</CODE> function should be prepared to receive any of the pixel map types defined by QuickDraw.<P>
 In response to this request code, your CMM should call its <CODE>MyCMMatchPixMap</CODE> subroutine. For example, to do this, your CMM may call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function, passing it the storage handle for this component instance, the component parameters data structure, and the address of your <CODE>MyCMMatchPixMap</CODE> subroutine. For a description of the function prototype to which your subroutine must adhere, see MyCMMatchPixMap <A HREF=#nonexistent-marker>(page 4-27)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 In addition to the storage handle for private storage for this component instance, the <CODE>CallComponentFunctionWithStorage</CODE> function passes to your <CODE>MyCMMatchPixMap</CODE> subroutine a pointer to the pixel map containing the source image to match,  a pointer to a callback progress-reporting function supplied by the calling program, and a reference constant your subroutine must pass to the callback function when you invoke it.<P>
 To handle this request, your <CODE>MyCMMatchPixMap</CODE> subroutine must match the colors of the source pixel map image to the color gamut of the destination profile, replacing the original pixel colors of the source image with their corresponding colors expressed in the data color space of the destination profile. The ColorSync Manager returns the resulting color-matched pixel map to the calling application or driver. <P>
 The callback function supplied by the calling function monitors the color-matching progress. You should call this function at regular intervals. Your <CODE>MyCMMatchPixMap</CODE> function should monitor the progress function for a returned value of <CODE>true</CODE>, which indicates that the user interrupted the color-matching process. In this case, you should terminate the process. <P>
 For a description of the prototype of the callback function supplied by the calling program, see MyCMBitmapCallBackProc <A HREF=#nonexistent-marker>(page 3-170)</A> in <I>Advanced Color Imaging Reference</I>.<P>
<A NAME=HEADING87-135></A>
<H4><A NAME=MARKER-9-79></A>Checking the Colors of a Pixel Map Image</H4>
 When a ColorSync-supportive application or device-driver calls the <CODE>CWCheckPixMap</CODE> function f<A NAME=MARKER-2-80></A>or your CMM to handle, the Component Manager calls your CMM with the <CODE>what</CODE> field of the component parameters data stru<A NAME=MARKER-2-81></A>cture set to  <CODE>kCMMCheckPixMap</CODE> if your CMM supports the request. <P>
 In response to this request code, your CMM should call its <CODE>MyCMCheckPixMap</CODE> subroutine. For example, to do this, your CMM may call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function, passing it the storage handle for this component instance, the component parameters data structure, and the address of your <CODE>MyCMCheckPixMap</CODE> subroutine. For a description of the function prototype to which your subroutine must adhere, see MyCMCheckPixMap <A HREF=#nonexistent-marker>(page 4-30)</A> in <I>Advanced Color Imaging Reference</I>.<P>
 In addition to the storage handle for private storage for this component instance, the <CODE>CallComponentFunctionWithStorage</CODE> function passes to your <CODE>MyCMCheckPixMap</CODE> subroutine a pointer to the pixel map containing the source image to check, a QuickDraw bitmap in which to report the color gamut-checking results,  a pointer to a callback progress-reporting function supplied by the calling program, and a reference constant your subroutine must pass to the callback function when you invoke it.<P>
 Using the content of the profiles passed to you at initialization time, your <CODE>MyCMCheckPixMap</CODE> subroutine must check the colors of the source pixel map image against the color gamut of the destination profile to determine if the pixel colors are within the gamut. If a pixel is out of gamut, your subroutine must set to 1 the corresponding pixel of the result bitmap. The ColorSync Manager returns the bitmap showing the color gamut-checking results to the calling application or device driver. <P>
<A NAME=HEADING87-140></A>
<H4><A NAME=MARKER-9-82></A>Initializing the Component Instance for a Session Using Concatenated Profiles</H4>
 When a ColorSync-supportive application or device driver calls the <CODE>CWConcatColorWorld</CODE> function for your CMM to handle, the Component Manager calls your CMM with the <CODE>what</CODE> field of the component parameters data structure set to  <CODE>kCMMConcatInit</CODE> if your CMM supports the request. <P>
 In response to this request code, your CMM should call its <CODE>MyCMConcatInit</CODE> subroutine. For example, to do this, your CMM may call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function, passing it the storage handle for this component instance, the component parameters data structure, and the address of your <CODE>MyCMConcatInit</CODE> subroutine. For a description of the function prototype to which your subroutine must adhere, see MyCMConcatInit <A HREF=#nonexistent-marker>(page 4-25)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 In addition to the storage handle for private storage for this component instance, the <CODE>CallComponentFunctionWithStorage</CODE> function passes to your <CODE>MyCMConcatInit</CODE> subroutine a pointer to a data structure of type <CODE>CMConcatProfileSet</CODE> containing an array of profiles to use in a subsequent color-matching or color gamut-checking session. The profiles in the array are in processing order--source through destination. The <CODE>profileSet</CODE> field of the data structure contains the array. If the profile array contains only one profile, that profile is a device-linked profile. For a description of the <CODE>CMConcatProfileSet</CODE> data structure, see <A HREF=#nonexistent-marker>"Concatenated Profile Set Structure" (page 3-49)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 Using the storage passed to your entry point function in the <CODE>CMSession </CODE>parameter, your <CODE>MyCMConcatInit</CODE> function should initialize any private data your CMM will need for a subsequent color session involving the set of profiles. Before your function returns control to the Component Manager, your subroutine should store any profile information it requires. In addition to the standard profile information, you should store the profile header's quality flags setting, the profile size, and the rendering intent. After you return control to the Component Manager, you cannot use the profile references again. <P>
 A color-matching or color gamut-checking session for a set of profiles entails various color transformations among devices in a sequence for which your CMM is responsible. Your CMM may use Component Manager functions to call other CMMs if necessary. <P>
 There are special guidelines your CMM must follow in using a set of concatenated profiles for subsequent color-matching or gamut-checking sessions. For more information on these guidelines, see MyCMConcatInit <A HREF=#nonexistent-marker>(page 4-25)</A> in <I>Advanced Color Imaging Reference</I>. <P>
<A NAME=HEADING87-147></A>
<H4><A NAME=MARKER-9-83></A>Creating a Device-Linked Profile and Opening a Reference to It</H4>
 When a<A NAME=MARKER-2-84></A><A NAME=MARKER-2-85></A> ColorSync-supportive application or device driver calls the <CODE>CWNewLinkProfile</CODE> function for your CMM to handle, the Component Manager calls your CMM with the <CODE>what</CODE> field of the component parameters data structure set to  <CODE>kCMMNewLinkProfile</CODE> if your CMM supports the request. <P>
 In response to this request code, your CMM should call its <CODE>MyCMNewLinkProfile</CODE> subroutine. For example, to do this, your CMM may call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function, passing it the storage handle for this component instance, the component parameters data structure, and the address of your <CODE>MyCMNewLinkProfile</CODE> subroutine. For a description of the function prototype to which your subroutine must adhere, see MyCMNewLinkProfile <A HREF=#nonexistent-marker>(page 4-33)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 In addition to the storage handle for private storage for this component instance, the <CODE>CallComponentFunctionWithStorage</CODE> function passes to your <CODE>MyCMNewLinkProfile</CODE> subroutine a pointer to a data structure of type <CODE>CMConcatProfileSet</CODE> containing the array of profiles that will make up the device-linked profile. <P>
 To handle this request, your subroutine must create a single device-linked profile of type <CODE>DeviceLink</CODE> that includes the profiles passed to you in the array pointed to by the <CODE>profileSet</CODE> parameter. Your CMM must create a file specification for the device-linked profile. A device-linked profile cannot be a temporary profile: that is, you cannot specify a location type of <CODE>cmNoProfileBase</CODE> for a device-linked profile. For information on how to specify the file location, see <A HREF=#nonexistent-marker>"Constants for Profile Location Type" (page 3-10)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 The profiles in the array are in the processing order--source through destination--which you must preserve. After your CMM creates the device-linked profile, it must open a reference to the profile and return the profile reference along with the location specification. <P>
<A NAME=HEADING87-153></A>
<H4><A NAME=MARKER-9-86></A>Obtaining PostScript-Related Data From a Profile</H4>
 There are three very similar PostScript-related request codes that your CMM may support. Each of the<A NAME=MARKER-9-26></A>se codes requests that your CMM obtain or derive information required by a PostScript printer from the specified profile and pass that information to a function supplied by the calling program. <P>
 When a ColorSync-supportive application or device driver calls the high-level function corresponding to the request code and your CMM is specified to handle it, the Component Manager calls your CMM with the <CODE>what</CODE> field of the component parameters data structure set to the corresponding request code if your CMM supports it. Here are the three high-level functions and their corresponding request codes:<P>
<UL>
<LI>When the application or device drive<A NAME=MARKER-2-88></A>r calls the <CODE>CMGetPS2ColorSpace</CODE> function, the Component Manager calls your CMM with a <CODE>kCMMGetPS2ColorSpace</CODE> request code. To respond to this request, your CMM must obtain the color space data from a source profile and pass the data to a low-level data-transfer function supplied by the calling application or device driver. 
<LI>When the application or device driver calls the <CODE>CMGetPS2ColorRenderingIntent</CODE> function, the Component Manager calls your CMM with a <CODE>kCMMGetPS2ColorRenderingIntent</CODE> <A NAME=MARKER-2-89></A>request code. To respond to this request, your CMM must obtain the color rendering intent from the source profile and pass the data to a low-level data-transfer function supplied by the calling application or device driver. 
<LI>When the application or device driver calls the <CODE>CMGetPS2ColorRendering</CODE> function, the Component Manager calls your CMM with a <CODE>kCMMGetPS2ColorRendering</CODE> request code. <A NAME=MARKER-2-90></A>To respond to this request, your CMM must obtain the rendering intent from the source profile's header. Then your CMM must obtain or derive the color rendering dictionary for that rendering intent from the destination profile and pass the CRD data to a low-level data-transfer function supplied by the calling application or device driver.<P>
</UL>
 In response to each of these request codes, your CMM should call its subroutine that handles the request. For example, to do this, your CMM may call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function, passing it the storage handle for this component instance, the component parameters data structure, and the address of your subroutine handler. <P>
 For a description of the function prototypes to which your subroutine must adhere for each of these requests, see <A HREF=#nonexistent-marker>"ColorSync Manager Reference for Color Management Modules" (page 4-3)</A> in <I>Advanced Color Imaging Reference:</I> <P>
<UL>
<LI>For <CODE>kCMMGetPS2ColorSpace</CODE>, see MyCMMGetPS2ColorSpace <A HREF=#nonexistent-marker>(page 4-34)</A>.
<LI>For <CODE>kCMMGetPS2ColorRenderingIntent</CODE>, see MyCMMGetPS2ColorRenderingIntent <A HREF=#nonexistent-marker>(page 4-37)</A>.
<LI>For <CODE>kCMMGetPS2ColorRendering</CODE>, see MyCMMGetPS2ColorRendering <A HREF=#nonexistent-marker>(page 4-39)</A>. <P>
</UL>
 In addition to the storage handle for private storage for this component instance, the <CODE>CallComponentFunctionWithStorage</CODE> function passes to your subroutine a reference to the source profile containing the data you must obtain or derive, a pointer to the function supplied by the calling program, and a reference constant that you must pass to the supplied function each time your CMM calls it. For <CODE> kCMMGetPS2ColorRendering</CODE>, your CMM is also passed a reference to the destination profile. <P>
 To handle each of these requests, your subroutine must allocate a <CODE>data</CODE> buffer in which to pass the particular PostScript-related data to the function supplied by the calling application or driver. Your subroutine must call the supplied function repeatedly until you have passed all the data to it. For a description of the prototype of the application or driver-supplied function, see MyColorSyncDataTransfer <A HREF=#nonexistent-marker>(page 3-167)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 For a description of how each of your subroutines must interact with the calling program's supplied function, see the descriptions of the prototypes for the subroutines in <A HREF=#nonexistent-marker>"Application-Defined Functions for the ColorSync Manager" (page 3-166)</A> in <I>Advanced Color Imaging Reference</I>. <P>
<A NAME=HEADING87-167></A>
<H4><A NAME=MARKER-9-91></A>Obtaining the Size of the Color Rendering Dictionary for PostScript Printers</H4>
 When a ColorSync-supportive application or device driver calls the <CODE>CMGetPS2ColorRenderingVMSize</CODE> function for your CMM to handle, the Component Manager calls your CMM with the <CODE>what</CODE> field of the component parameters data structure set to  <CODE> kCMMGetPS2ColorRenderingVMSize</CODE> if your CMM supports the request. <P>
 In response to this request code, your CMM should call its <CODE>MyCMMGetPS2ColorRenderingVMSize</CODE> subroutine. For example, to do this, your CMM may call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function, passing it the storage handle for this component instance, the component parameters data structure, and the address of your <CODE>MyCMMGetPS2ColorRenderingVMSize</CODE> subroutine. For a description of the function prototype to which your subroutine must adhere, see <A HREF=#nonexistent-marker>"ColorSync Manager Reference for Color Management Modules" (page 4-3)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 In addition to the storage handle for global data for this component instance, the <CODE>CallComponentFunctionWithStorage</CODE> function passes to your <CODE>MyCMMGetPS2ColorRenderingVMSize</CODE> subroutine a reference to the source profile identifying the rendering intent and a reference to the destination profile containing the color rendering dictionary (CRD) for the specified rendering intent. <P>
 To handle this request, your CMM must obtain or assess and return the maximum VM size for the CRD of the specified rendering intent. <P>
 If the destination profile contains the Apple-defined private tag <CODE>'psvm'</CODE>, described in the next paragraph, then your CMM may read the tag and return the CRD VM size data supplied by this tag for the specified rendering intent. If the destination profile does not contain this tag, then you must assess the VM size of the CRD. <P>
 The <CODE>CMPS2CRDVMSizeType</CODE> data type defines the Apple-defined <CODE>'psvm'</CODE> optional tag that a printer profile may contain to identify the maximum VM size of a CRD for different rendering intents. <P>
 This tag's element data includes an array containing one entry for each rendering intent and its virtual memory size. For a description of the data structures that define the tag's element data, see <A HREF=#nonexistent-marker>"PostScript CRD Virtual Memory Size Tag Structure" (page 3-67)</A> in <I>Advanced Color Imaging Reference.<A NAME=MARKER-2-93></A></I> <P>
<A NAME=HEADING87-175></A>
<H4><A NAME=MARKER-9-94></A>Flattening a Profile for Embedding in a Graphics File </H4>
 When a ColorSync-supportive application or device driver calls the <CODE>CMFlattenProfile</CODE> function for your CMM to handle, the Component Manager calls your CMM with the <CODE>what</CODE> field of the component parameters data structure set to  <CODE>kCMMFlattenProfile</CODE> if your CMM supports the request. <P>
 In <A NAME=MARKER-2-96></A>response to this request code, your CMM should call its <CODE>MyCMMFlattenProfile</CODE> subroutine. For example, to do this, your CMM may call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function, passing it the storage handle for this component instance, the component parameters data structure, and the address of your <CODE>MyCMMFlattenProfile</CODE> subroutine. For a description of the function prototype to which your subroutine must adhere, see MyCMMFlattenProfile <A HREF=#nonexistent-marker>(page 4-45)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 In addition to the storage handle for private storage for this component instance, the <CODE>CallComponentFunctionWithStorage</CODE> function passes to your <CODE>MyCMMFlattenProfile</CODE> subroutine a reference to the profile to be flattened, a pointer to a function supplied by the calling program, and a reference constant your subroutine must pass to the calling program's function when you invoke it. <P>
 To handle this request, your subroutine must extract the profile data from the profile, allocate a buffer in which to pass the profile data to the supplied function, and pass the profile data to the function, keeping track of the amount of data remaining to pass. <P>
 For a description of the prototype of the function supplied by the calling program, see <CODE>MyColorSyncDataTransfer</CODE> <A HREF=#nonexistent-marker>(page 3-167)</A> in <I>Advanced Color Imaging Reference</I>. In the same book, see the <CODE>MyCMMFlattenProfile</CODE> function <A HREF=#nonexistent-marker>(page 4-47)</A> for information on how your subroutine communicates with the function supplied by the calling program.<P>
<A NAME=HEADING87-181></A>
<H4><A NAME=MARKER-9-97></A>Unflattening a Profile</H4>
 <A NAME=MARKER-2-98></A>When a ColorSync-supportive application or device driver calls the <A NAME=MARKER-2-99></A><CODE>CMUnflattenProfile</CODE> function, the Component Manager calls your CMM with the <CODE>what</CODE> field of the component parameters data structure set to  <CODE>kCMMUnflattenProfile</CODE>, if your CMM supports that request code. <P>
 In re<A NAME=MARKER-2-100></A>sponse to the <CODE>kCMMUnflattenProfile</CODE> request code, your CMM should call its <CODE>MyCMMUnflattenProfile</CODE> function. To do this, your CMM can call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function, passing it the storage handle for this component instance, the component parameters data structure, and the address of your <CODE>MyCMMUnflattenProfile</CODE> function. For more information, see <CODE>MyCMMFlattenProfile</CODE> <A HREF=#nonexistent-marker>(page 4-47)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 In addition to the storage handle for private storage for this component instance, the <CODE>CallComponentFunctionWithStorage</CODE> function passes to your <CODE>MyCMMUnflattenProfile</CODE> function a pointer to a function supplied by the calling program and a reference constant. Your function passes the reference constant to the calling program's function when you invoke it. The calling program's function obtains the profile data and returns it to your subroutine. For more information on the data transfer function, see <CODE>MyColorSyncDataTransfer</CODE> <A HREF=#nonexistent-marker>(page 3-167)</A> in <I>Advanced Color Imaging Reference</I>. <A NAME=MARKER-2-101></A><P>
 To handle this request, your subroutine must create a file in which to store the profile data. You should create the file in the temporary items folder. Your <CODE>MyCMMUnflattenProfile</CODE> subroutine must call the supplied <CODE>MyColorSyncDataTransfer</CODE> function repeatedly to obtain the profile data. Before calling the <CODE>MyColorSyncDataTransfer</CODE> function, your <CODE>MyCMMUnflattenProfile</CODE> function must allocate a buffer to hold the returned profile data. <P>
 Your <CODE>MyCMMUnflattenProfile</CODE> function must identify the profile size and maintain a counter to track the amount of data transferred and the amount of data remaining. This information allows you to determine when to call the <CODE>MyColorSyncDataTransfer</CODE> function for the final time. <P>
<A NAME=HEADING87-187></A>
<H4><A NAME=MARKER-9-102></A>Supplying Named Color Space Information</H4>
 <A NAME=MARKER-2-103></A>When a ColorSync-supportive application or device driver calls the <CODE>CMGetNamedColorInfo</CODE> function for your CMM to handle, the Component Manager calls your CMM with the <CODE>what</CODE> field of the component parameters data structure set to  <CODE> </CODE>kCMMGetNamedColorInfo if your CMM supports the request. <A NAME=MARKER-2-104></A><P>
 In response to this request code, your CMM should call its MyCMMGetNamedColorInfo subroutine. To do this, your CMM might call the Component Manager's <CODE>CallComponentFunctionWithStorage</CODE> function, passing it the storage handle for this component instance, the component parameters data structure, and the address of your MyCMMGetNamedColorInfo subroutine. <P>
 The MyCMMGetNamedColorInfo function returns information about a named color space from its profile reference. For a description of the function prototype to which your subroutine must adhere, see MyCMMGetNamedColorInfo <A HREF=#nonexistent-marker>(page 4-50)</A> in <I>Advanced Color Imaging Reference</I>. <P>
 A named color profile has a value of <CODE>'nmcl'</CODE> in the Profile/Device class field of its header. If the source profile passed to your MyCMMGetNamedColorInfo subroutine is a named color profile, you can extract the necessary information to return in the parameters of the MyCMMGetNamedColorInfo routine.<P>
 Your CMM can obtain named color information as well as profile header information by reading the <CODE>namedColor2Tag</CODE> tag (signature <CODE>'ncl2'</CODE>). This tag's element data includes a count of named colors, the number of device channels, and a prefix and suffix for each named color name. The data also includes the named color names themselves, along with profile coordinate space (PCS) and device color information for each named color. For information on the format of the <CODE>namedColor2Tag</CODE> tag, see the <I>International Color Consortium Profile Format Specification</I>.<P>
 Your CMM responds similarly for other named color requests:<P>
<UL>
<LI>The <CODE>CMGetNamedColorValue</CODE> routine generates a kCMMGetNamedColorValue request, which you respond to in your MyCMMGetNamedColorValue routine. The MyCMMGetNamedColorValue routine returns device and PCS color values from a named color space profile for a specific color name.
<LI>The <CODE>CMGetIndNamedColorValue</CODE> routine generates a kCMMGetIndNamedColorValue request, which you respond to in your MyCMMGetIndNamedColorValue routine. The MyCMMGetIndNamedColorValue routine returns device and PCS color values from a named color space profile for a specific named color index.
<LI>The <CODE>CMGetNamedColorIndex</CODE> routine generates a kCMMGetNamedColorIndex request, which you respond to in your MyCMMGetNamedColorIndex routine. The MyCMMGetNamedColorIndex routine returns a named color index from a named color space profile for a specific color name.
<LI>The <CODE>CMGetNamedColorName</CODE> routine generates a kCMMGetNamedColorName request, which you respond to in your MyCMMGetNamedColorName routine. The MyCMMGetNamedColorName routine returns a named color name from a named color space profile for a specific named color index.<A NAME=MARKER-2-105></A><P>
</UL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="ACI-86.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ACI-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ACI-122.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ACI-88.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="ACI-3.html">&copy; Apple Computer, Inc.</A><br>13 NOV 1996<P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML> 
