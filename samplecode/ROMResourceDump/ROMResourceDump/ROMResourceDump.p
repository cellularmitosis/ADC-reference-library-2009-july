{	File:		ROMResourceDump.p	Contains:	This little utility copies all of the resources in the Macintosh’s ROM into a file called     				“ROM Resource Dump File”.  This is useful for the insanely curious, those with a professional     				“need to know” (like DTS engineers), and as a trivial Resource Manager sample.    				The supplied source code compiles with Metrowerks Pascal from CodeWarrior 9.    				Some notes:    				1. When you run this program on some older machines it will create a resource file that         			ResEdit reports as corrupt.  This is not my fault!  ResEdit is complaining because         			the file contains two resources with the same type and ID.  The program does this         			because both resources exist in the ROM on that machine.  *sigh*    				2. The program makes heavy use of Metrowerks Pascal’s console and the ostrich error checking         			algorithm.  Call me slack (–:   					3. Efficiency was not the goal of this program.  I call UpdateResFile religiously while        	 			creating the output file, which doesn’t make it any faster.	Written by: 		Copyright:	Copyright © 1984-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				8/9/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				}program ROMResourceDump;	uses		Types,		Memory,		LowMem,		Files,		Resources;		procedure CopyROMResource(romResourceH : Handle; destRefnum : integer);			(*	This routine copies a specific ROM resource into the resource file					denoted by destRefnum.  Any error conditions get written to					the console.					The main complications are:												1.	Have to call LMSetROMMapInsert even for GetResInfo.														2.	Have to copy the resources from out of the ROM before								adding them into the destination resource file.														3.	Have to deal with memory issues, ie we don't want to fill								up our application heap with resources and then run out of								memory.								*)			var				err : OSStatus;				err2 : OSStatus;				romResourceType : ResType;				romResourceID : integer;				romResourceName : Str255;				romResourceSize : longint;		begin			(*	Get lots of information about the resource.  You have to set ROMMapInsert,					even for a simple call like GetResInfo.  If you don't do this, things just					don't work properly.			*)			LMSetROMMapInsert(-1);			GetResInfo(romResourceH, romResourceID, romResourceType, romResourceName);			romResourceSize := GetHandleSize(romResourceH);			writeln('    Resource ''', romResourceType, ''' ID=', romResourceID:1, ' size = ', romResourceSize:1, 							' "', romResourceName, '"');						err := HandToHand(romResourceH);			if err = noErr then begin				UseResFile(destRefnum);								AddResource(romResourceH, romResourceType, romResourceID, romResourceName);				err := ResError;								(* Have to call UpdateResFile before calling ReleaseResource.  This allows					the Resource Manager to actually dispose of the memory used by the resource					because it's already been written to a file.  If you do this the other					way, the Resource Manager hangs on to the new resource pending a call					to UpdateResFile, but then doesn't remember to release it when it gets					one.				*)				UpdateResFile(destRefnum);				err2 := ResError;				if err = noErr then begin					err := err2;				end; (* if *)								ReleaseResource(romResourceH);								UseResFile(0);			end; (* if *)			if err <> noErr then begin				writeln('    ••• error writing resource ', err:1);			end; (* if *)	end; (* CopyROMResource *)	function DumpROMResourcesToResourceFile(destRefnum : integer) : OSStatus;		(* This routine dumps all of the resources in the ROM into the resource file				whose reference number is destRefnum.  The basic implementation				is a standard:									for type = 1 to count of types						for index = 1 to count of resources in this type							get indexed resource								put it our file								This technique normally works for normal resource files but, as long				as you set ROMMapInsert before calling the Resource Manager, the				technique works equally well for ROM resources.								This routine doesn't deal with errors particularly well, especially				out of memory errors.		*)		var			saveResFile : integer;						typeCount : integer;			typeIndex : integer;			thisType : ResType;			resourceCount : integer;			resourceIndex : integer;						foundResourceH : Handle;	begin		saveResFile := CurResFile;		UseResFile(0);		(* Count the number of resource types in the ROM. *)					LMSetROMMapInsert(-1);		typeCount := Count1Types;		writeln('Number of types = ', typeCount:1);				(* Iterate through each of the types. *)		for typeIndex := 1 to typeCount do begin			(* Get the information for this type. *)			LMSetROMMapInsert(-1);			Get1IndType(thisType, typeIndex);									(* Count the number of resources of this type in the ROM. *)						LMSetROMMapInsert(-1);			resourceCount := Count1Resources(thisType);			writeln('  Number of resources for type ''', thisType, ''' = ', resourceCount:1);			(* Iterate through each of the resources. *)			for resourceIndex := 1 to resourceCount do begin								(* Get this resource. *)				LMSetROMMapInsert(-1);				LMSetTmpResLoad(-1);				foundResourceH := Get1IndResource(thisType, resourceIndex);								if foundResourceH = nil then begin					writeln('   ••• Could not get resource ''', thisType, ''' index ', resourceIndex:1);				end else begin					(* Copy the resource into the destination resource file. *)					CopyROMResource(foundResourceH, destRefnum);				end; (* if *)			end; (* for *)		end; (* for *)				UseResFile(saveResFile);				DumpROMResourcesToResourceFile := noErr;	end; (* DumpROMResourcesToResourceFile *)			(*	The main line simply opens a unique destination resource file			and then calls DumpROMResourcesToResourceFile to copy the ROM			resources into it.	*)		const		kOutputFileName = 'ROM Resource Dump File';			var		err : OSStatus;		junk : OSStatus;		fcbPBlock : FCBPBRec;		retryCount : integer;		dumpFileSpec : FSSpec;		dumpFileRefnum : integer;begin	writeln('ROMResourceDump');		fcbPBlock.ioRefNum := CurResFile;	err := PBGetFCBInfoSync(@fcbPBlock);	if err = noErr then begin		junk := FSMakeFSSpec(fcbPBlock.ioVRefNum, fcbPBlock.ioFCBParID, kOutputFileName, dumpFileSpec);		retryCount := 0;		repeat			FSpCreateResFile(dumpFileSpec, 'RSED', 'rsrc', 0);			err := ResError;			if err <> noErr then begin				retryCount := retryCount + 1;				junk := FSMakeFSSpec(fcbPBlock.ioVRefNum, fcbPBlock.ioFCBParID, stringof(kOutputFileName, ' ', retryCount:1), dumpFileSpec);			end; (* if *)		until (err = noErr) or (retryCount > 10);	end; (* if *)		if err = noErr then begin		dumpFileRefnum := FSpOpenResFile(dumpFileSpec, fsRdWrPerm);		err := ResError;	end; (* if *)		if err = noErr then begin		err := DumpROMResourcesToResourceFile(dumpFileRefnum);		CloseResFile(dumpFileRefnum);	end; (* if *)		writeln('Done. Press command-Q to Quit.');end. (* ROMResourceDump *)