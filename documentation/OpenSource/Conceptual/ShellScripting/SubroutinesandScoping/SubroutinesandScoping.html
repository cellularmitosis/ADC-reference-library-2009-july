<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Shell Scripting Primer: Result Codes, Subroutines, Scoping, and Sourcing</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Result Codes, Subroutines, Scoping, and Sourcing"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40004268-TP40003513" title="Result Codes, Subroutines, Scoping, and Sourcing"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP40003594" target="_top">Open Source</a> &gt; <a href="../../../Scripting-date.html#//apple_ref/doc/uid/TP30000440-TP40003594-TP30000569" target="_top">Scripting &amp; Automation</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40004268-TP40003516-SW1">Shell Scripting Primer</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../shell_scripts/shell_scripts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../PaintbyNumbers/PaintbyNumbers.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW1" title="Result Codes, Subroutines, Scoping, and Sourcing"></a><h1>Result Codes, Subroutines, Scoping, and Sourcing</h1><p>No procedural programming language would be complete without some notion of subroutines, functions, or other such constructs. The Bourne shell is no exception.</p><p>In the Bourne shell, there are two basic ways to approach subroutines. The first is through executing outside tools (which may include a script executing itself recursively). This was described briefly in <span class="content_text"><a href="../shell_scripts/shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW5">“Basic Control Statements.”</a></span> However, there are other techniques for obtaining result code information from external scripts. These are described in <span class="content_text"><a href="SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW3">“Working with Result Codes.”</a></span> You can also make execution of one command be conditional upon the result code returned by another command as described in <span class="content_text"><a href="SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW8">“Chaining Execution.”</a></span></p><p>The second way to approach subroutines (and one which generally results in better performance) is through the use of actual subroutines. These are described in <span class="content_text"><a href="SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW4">“Subroutine Basics.”</a></span> You can also write short, simple subroutines inline as described in <span class="content_text"><a href="SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW6">“Anonymous Subroutines.”</a></span></p><p>The scoping rules for shell subroutines differ from the scoping rules for most other programming languages. Shell script variable scoping is explained in <span class="content_text"><a href="SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW2">“Variable Scoping.”</a></span></p><p>You may find it useful to include one entire shell script inside another. This subject is covered in <span class="content_text"><a href="SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW5">“Including One Shell Script Inside Another (Sourcing).”</a></span></p><p>Finally, you may find it useful to execute outside scripts in the background and check their status at a later time. You can learn about this in <span class="content_text"><a href="SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW7">“Background Jobs and Job Control.”</a></span></p><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW3" title="Working with Result Codes"></a><h2>Working with Result Codes</h2><p><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_375"></a>Result codes, also known as <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_376"></a>return values, <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_377"></a>exit statuses, and probably several other names, are one of the more critical features of shell scripting, as they play a role in almost every aspect of script execution.</p><p>Whenever a command executes (including the open bracket shell builtin used as part of the <code>if</code> and <code>while</code> statements), a result code is generated. If the command exits successfully, the result is usually zero (<code>0</code>). If the command exits with an error, the result code will vary according to the tool. (See the documentation for the tool in question for a list of result codes.) The possible range of result codes is 0-255.</p><p>There are three ways of testing to see if a script executes correctly. The first is with an immediate test using the if statement. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>if ls mysillyfilename ; then<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "File exists."<span></span></pre></td></tr><tr><td scope="row"><pre>fi<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW9" title="Note"></a><p><strong>Note:</strong>&nbsp;This example is not the best way of testing whether a file exists. It is only intended as an example of a tool that returns a different exit status depending on whether it was successful at performing a task.</p>For more information about how to test for file existence using the if statement, see <span class="content_text"><a href="../shell_scripts/shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW4">“The test Command and Bracket Notation.”</a></span></p></div><p>The second way is by testing the last exit status returned. The exit status is stored in the shell variable <code><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_378"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_379"></a>$?</code>. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>ls mysillyfilename<span></span></pre></td></tr><tr><td scope="row"><pre>if [ $? = 0 ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "File exists."<span></span></pre></td></tr><tr><td scope="row"><pre>fi<span></span></pre></td></tr></table></div><p>The third way is by taking advantage of the <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_380"></a>“and” operator:</p><div class="codesample"><table><tr><td scope="row"><pre>ls mysillyfilename &amp;&amp; echo "File exists."<span></span></pre></td></tr></table></div><p>These three code examples should generate the same output. The third technique is explained further in <span class="content_text"><a href="SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW8">“Chaining Execution.”</a></span></p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW10" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;The C shell supports the exit status variable (with different syntax described in <span class="content_text"><a href="../shell_scripts/shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW6">“The if Statement”</a></span>) and the chaining method.</p></div><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW8" title="Chaining Execution"></a><h2>Chaining Execution</h2><p><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_381"></a>The shell provides three operators for chaining execution:and (<a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_382"></a><code>&amp;&amp;</code>), or (<a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_383"></a><code>||</code>) and not (<a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_384"></a><code>!</code>).</p><dl class="termdef">	<dt><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_385"></a>And (<code>&amp;&amp;</code>)</dt><dd><p>If the command to the left succeeds (has a zero exit status), the command to the right executes. Otherwise, it does not. The result code returned by this operation is success (zero) only if both commands return zero. Otherwise, its result code is whatever was returned by whichever command failed.</p></dd><dt><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_386"></a>Or (<code>||</code>)</dt><dd><p>If the command to the left succeeds (has a zero exit status), the command to the right does not execute. If the command to the left fails, the command to the right does execute. If the leftmost command succeeds, the exit status returned by this operator is zero. Otherwise, the exit status returned is the exit status of the command to the right of the operator.</p></dd><dt><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_387"></a>Not (<code>!</code>)</dt><dd><p>Executes the command to the right of the operator. If the command returns a zero exit status, the operator returns a nonzero exit status. If the command returns a nonzero exit status, the operator returns a zero exit status.</p></dd></dl><p>The three operators are shown in the following snippet:</p><div class="codesample"><table><tr><td scope="row"><pre>ls / || ! ls mysillyfilename &amp;&amp; echo "Whatever."<span></span></pre></td></tr></table></div><p>The <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_388"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_389"></a>operator precedence rules in Bourne shell scripts are very different from those in C. Parentheses are evaluated first, as they can be used to override grouping of operators. After that, however, evaluation of operators occurs in order from left to right.</p><p>For example, the following line lists all of the files in the root directory, then echoes “It’s a boy”:</p><div class="codesample"><table><tr><td scope="row"><pre> ls / || ls /xy &amp;&amp; echo "It's a boy"<span></span></pre></td></tr></table></div><p>The <code>||</code> operator takes precedence over the <code>&amp;&amp;</code> operator because of left-to-right evaluation rules. The shell shortcuts evaluation of the <code>||</code> operator. Thus, because <code>ls /</code> always succeeds, the <code>||</code> operator causes the second <code>ls</code> to be skipped entirely, and the statement up to the <code>&amp;&amp;</code> operator evaluates to <code>true</code> (<code>0</code>). This value is then combined with the echo statement after it by the <code>&amp;&amp;</code> operator. Thus, the echo statement executes afterwards.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW11" title="Note"></a><p><strong>Note:</strong>&nbsp;These rules are very different from the rules in C or most other programming languages. If you substitute function calls in C with the same return values (<code>true</code>, <code>false</code>, and <code>true</code>), the resulting statement behaves very differently. Consider the following statement:</p><div class="codesample"><table><tr><td scope="row"><pre>if (a() || b() &amp;&amp; c()) { ... }<span></span></pre></td></tr></table></div>	If functions <code>a</code> and <code>c</code> return <code>true</code> and function <code>b</code> returns <code>false</code>, the <code>&amp;&amp;</code> operator takes precedence over the <code>||</code> operator. Thus, when the first function call (<code>a</code>) executes and returns true, the <code>||</code> operator shortcuts the rest of the statement. However, the expression as a whole still evaluates to <code>true</code> in this case. The reason for this is easier to see if you rewrite the statement with parentheses to show the operator precedence like this:</p><div class="codesample"><table><tr><td scope="row"><pre>if  (a() ||<span></span></pre></td></tr><tr><td scope="row"><pre>        (b() &amp;&amp; c())<span></span></pre></td></tr><tr><td scope="row"><pre>    ) { ... }<span></span></pre></td></tr></table></div></div><p>You can modify the order of operations (or clarify it to avoid confusing people who are not used to languages without operator precedence) by adding parentheses, as shown in the next snippet:</p><div class="codesample"><table><tr><td scope="row"><pre>ls / || ( ls /nonexistentfile &amp;&amp; echo "file exists" )<span></span></pre></td></tr></table></div><p>In this case, because the first <code>ls</code> statement is successful, the remainder of the statement is skipped. If you replace the <code>ls /</code> with <code>false</code>, the failed listing of <code>nonexistentfile</code> generates an error message and a nonzero exit status, which in turn causes the <code>echo</code> statement to still be skipped.</p><p>Of course, the existence of these operators also means that you could write an <code>if</code> statement without actually using the <code>if</code> keyword, as shown in the following snippet:</p><div class="codesample"><table><tr><td scope="row"><pre>FOO=3<span></span></pre></td></tr><tr><td scope="row"><pre>[ $FOO -eq 3 ] &amp;&amp; echo "three"<span></span></pre></td></tr></table></div><p>Because this decreases readability, however, this syntax is not recommended. This form is presented here only to help with comprehension of existing scripts.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW12" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;The C shell syntax for chaining is identical to the Bourne shell syntax. However, you should be aware that <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_390"></a>some versions of the C shell have subtle bugs in their logic behavior. If you run into these bugs, adding parentheses around single statements can sometimes help.<a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_391"></a></p></div><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW4" title="Subroutine Basics"></a><h2>Subroutine Basics</h2><p><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_392"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_393"></a>Subroutines in the Bourne shell look very much like C functions without the argument list. You call these subroutines just like you run a program, and subroutines can be used anywhere that you can use an executable.</p><p>Here is a simple example that prints "Arg 1: This is an arg" using a shell subroutine:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>mysub()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>        echo "Arg 1: $1"<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>mysub "This is an arg"<span></span></pre></td></tr></table></div><p>Just as shell script arguments are stored in shell-local variables named $1, $2, and so on, so too are the arguments to shell subroutines. In fact, in most ways, shell subroutines behave exactly like executing an external script. One place where they behave differently is in variable scoping. See <span class="content_text"><a href="SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW2">“Variable Scoping”</a></span> for more information.</p><p>In general, a subroutine can do anything that a shell script can do. It can even return an <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_394"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_395"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_396"></a>exit status to the calling part of the shell script. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>mysub()<span></span></pre></td></tr><tr><td scope="row"><pre><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_397"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_398"></a>{<span></span></pre></td></tr><tr><td scope="row"><pre>        <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_399"></a>return 3<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>mysub "This is an arg"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "Subroutine returned $?"<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW13" title="Note"></a><p><strong>Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_400"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_401"></a>Be careful <em>not</em> to use <code>exit</code> in the subroutine. If you do, the entire script will exit, not just the subroutine. This is one way in which subroutines behave differently than separate scripts behave.</p></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW14" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_402"></a>The C shell does not support subroutines. You can, however, use additional external scripts to simulate them. For very simple subroutines, you can also approximate the functionality with aliases as described in <span class="content_text"><a href="../shell_scripts/shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW27">“The alias Builtin.”</a></span></p></div><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW6" title="Anonymous Subroutines"></a><h2>Anonymous Subroutines</h2><p>The Bourne shell allows you to group more than one command together and treat them both as a separate command. In effect, you are creating an <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_403"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_404"></a>anonymous subroutine inline.</p><p>For example, if you want to copy a large number of files from one place to another, you could use <code><a href="../../../../Darwin/Reference/ManPages/man1/cp.1.html#//apple_ref/doc/man/1/cp" target="_top">cp</a></code>, but this may not be semantically ideal for any number of reasons. Another option is to use <code><a href="../../../../Darwin/Reference/ManPages/man1/tar.1.html#//apple_ref/doc/man/1/tar" target="_top">tar</a></code> to create an archive on standard output, then pipe that to a second instance of <code>tar</code> that extracts the archive.</p><p>The basic commands needed are show below. The first command in this example archives the listed files and prints the archive contents to standard output. The second command takes an archive form standard output and extracts the files.</p><div class="codesample"><table><tr><td scope="row"><pre>tar -cf - file1 file2 file3 ...<span></span></pre></td></tr><tr><td scope="row"><pre>tar -xf -<span></span></pre></td></tr></table></div><p>Thus, to copy files from one place to another, you could pipe the first <code>tar</code> command to the second one. However, there’s a problem with that: because the second <code>tar</code> is running in the same directory, you are extracting the files on top of themselves. If you’re lucky, nothing happens at all. In the worst case scenario, you could lose files this way.</p><p>Thus, you need run two commands on the right side of the pipe: a <code><a href="../../../../Darwin/Reference/ManPages/man1/cd.1.html#//apple_ref/doc/man/1/cd" target="_top">cd</a></code> command to change directories before extracting the archive and the <code>tar</code> command itself. You can do this with an anonymous subroutine.</p><p>Here is a simple example:</p><div class="codesample"><table><tr><td scope="row"><pre>tar -cf - file1 file2 file3 | \<span></span></pre></td></tr><tr><td scope="row"><pre>    <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_405"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_406"></a>{ cd "/destination" ; tar -xf - ; }<span></span></pre></td></tr></table></div><p>Notice the semicolon before the close curly brace. This semicolon is required. Also notice the space after the opening curly brace. This space is also required. Forgetting either of these results in a syntax error.</p><p>Of course, as written, there is still some risk involved in using this code. If the destination directory does not exist, the <code>cd</code> command fails, and the <code>tar</code> command executes in the wrong directory. To solve this problem, you should check the exit status of the first command before running the second one.</p><p>For example:</p><div class="codesample"><table><tr><td scope="row"><pre>tar -cf - file1 file2 file3 | \<span></span></pre></td></tr><tr><td scope="row"><pre>    { if cd "/destination" ; then tar -xf - ; fi; }<span></span></pre></td></tr></table></div><p>This version will execute the <code>cd</code> command, then execute the second <code>tar</code> command <em>only</em> if the <code>cd</code> command was successful.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW15" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_407"></a>The C shell does not support anonymous subroutines. You can, however, use additional external scripts to simulate them. You can also roughly approximate this functionality through careful use of chaining as described in <span class="content_text"><a href="SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW8">“Chaining Execution.”</a></span> For example:</p><div class="codesample"><table><tr><td scope="row"><pre>( cd / &amp;&amp; ls ) | more<span></span></pre></td></tr></table></div>Unfortunately, if you need the second command to execute even if the first command fails, you can quickly end up with very unreadable code.</p><div class="codesample"><table><tr><td scope="row"><pre>((ls /boguslocation || true) &amp;&amp; (ls || true)) | more<span></span></pre></td></tr></table></div></div><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW2" title="Variable Scoping"></a><h2>Variable Scoping</h2><p>Subroutines execute within the same shell instance as the main shell script. As a result, all shell variables are, by default, shared between the subroutines and the main program body. This creates a bit of a problem when writing recursive code.</p><p>Fortunately, variables do not have to remain global. To declare a <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_408"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_409"></a>variable <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_410"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_411"></a>local to a given subroutine, use the <code><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_412"></a>local</code> statement.</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>mysub()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>        local MYVAR<span></span></pre></td></tr><tr><td scope="row"><pre>        MYVAR=3<span></span></pre></td></tr><tr><td scope="row"><pre>        echo "SUBROUTINE: MYVAR IS $MYVAR";<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>MYVAR=4<span></span></pre></td></tr><tr><td scope="row"><pre>echo "MYVAR INITIALLY $MYVAR"<span></span></pre></td></tr><tr><td scope="row"><pre>mysub "This is an arg"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "MYVAR STILL $MYVAR"<span></span></pre></td></tr></table></div><p>This script will tell you that the initial value is 4, the value was changed to 3 in the subroutine, and remains 4 when the subroutine returns. Were it not for a <code>local</code> declaration of <code>MYVAR</code> in the subroutine, the subsequent change to <code>MYVAR</code> would have propagated back to the main body of the script.</p><p>Much like the <code>export</code> statement, the <code>local</code> statement can be used at the beginning of an assignment statement as well. For example, the previous subroutine could have contained the following line instead:</p><div class="codesample"><table><tr><td scope="row"><pre>local MYVAR=3<span></span></pre></td></tr></table></div><p>In either case, any subsequent changes to the variable <code>MYVAR</code> remain local to the subroutine. If the subroutine calls itself recursively, a new copy of <code>MYVAR</code> will be created for each call to the subroutine, resulting in a call stack much like local variables in C or other languages.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_24" title="Important:"></a><p><strong>Important:</strong>&nbsp;Changes to this variable in other subroutines without a <code>local</code> declaration of <code>MYVAR</code> will still result in modifications to the global copy of <code>MYVAR</code>.</p><p></p></div><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW5" title="Including One Shell Script Inside Another (Sourcing)"></a><h2>Including One Shell Script Inside Another (Sourcing)</h2><p><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_413"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_414"></a>As with any programming language that includes subroutines, it is often useful to build up a library of common functions that your scripts can use. To avoid duplicating this content, the Bourne shell scripting language supports a mechanism to include one shell script inside another by reference. This process is referred to as sourcing.</p><p>For example, create a file containing the subroutine <code>mysub</code> from <span class="content_text"><a href="SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW2">“Variable Scoping.”</a></span> Call it <code>mysub.sh</code>. To use this subroutine in another script, you can do the following:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre>MYVAR=4<span></span></pre></td></tr><tr><td scope="row"><pre><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_415"></a>source /path/to/mysub.sh<span></span></pre></td></tr><tr><td scope="row"><pre>echo "MYVAR INITIALLY $MYVAR"<span></span></pre></td></tr><tr><td scope="row"><pre>mysub "This is an arg"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "MYVAR STILL $MYVAR"<span></span></pre></td></tr></table></div><p>This script will do exactly the same thing as the script in the previous section. The only difference is that the subroutine used is in a different file.</p><p>There is another, shorter, way to write the same thing using the period (<code><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_416"></a>.</code>) character. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre>MYVAR=4<span></span></pre></td></tr><tr><td scope="row"><pre>. /path/to/mysub.sh<span></span></pre></td></tr><tr><td scope="row"><pre>echo "MYVAR INITIALLY $MYVAR"<span></span></pre></td></tr><tr><td scope="row"><pre>mysub "This is an arg"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "MYVAR STILL $MYVAR"<span></span></pre></td></tr></table></div><p>This code does exactly the same thing as the previous example. The <code>source</code> builtin is more popular among former C shell programmers, while the period (<code>.</code>) version is more popular among Bourne shell purists. Both versions are perfectly cromulent, however.</p><p>These examples are not as straightforward as they seem, however. While this works very well for including subroutines, you cannot always use this in place of executing an outside script, as execution and sourcing behave very differently with respect to <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_417"></a>variables. The following example demonstrates this:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre># Save as sourcetest1.sh<span></span></pre></td></tr><tr><td scope="row"><pre>MYVAR=3<span></span></pre></td></tr><tr><td scope="row"><pre>source sourcetest2.sh<span></span></pre></td></tr><tr><td scope="row"><pre>echo "MYVAR IS $MYVAR"<span></span></pre></td></tr></table></div><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre># Save as sourcetest2.sh<span></span></pre></td></tr><tr><td scope="row"><pre>MYVAR=4<span></span></pre></td></tr></table></div><p>You will notice that the second script changed the value of a variable that was local to the first script. Unlike executing a script as a normal shell command, executing a script with the <code>source</code> builtin results in the second script executing within the same overall context as the first script. Any variables that are modified by the second script will be seen by the calling script. While this can be very powerful, it is easy to clobber variables if you aren't careful.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW16" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;The C shell supports the <code>source</code> builtin, but does not support the period form (<code>.</code>).<a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_418"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_419"></a></p></div><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW7" title="Background Jobs and Job Control"></a><h2>Background Jobs and Job Control</h2><p>For end-user convenience in the days of text terminals before the advent of tools like <code><a href="../../../../Darwin/Reference/ManPages/man1/screen.1.html#//apple_ref/doc/man/1/screen" target="_top">screen</a></code>, the C shell contains <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_420"></a>job control features that allow you to start a process in the background, then go off and work on other things, bringing these background tasks into the foreground, suspending foreground tasks to complete them later, and continuing these suspended tasks as background tasks.</p><p>Over the years, many modern Bourne shell variants including <code><a href="../../../../Darwin/Reference/ManPages/man1/bash.1.html#//apple_ref/doc/man/1/bash" target="_top">bash</a></code> and <code><a href="../../../../Darwin/Reference/ManPages/man1/zsh.1.html#//apple_ref/doc/man/1/zsh" target="_top">zsh</a></code> have added similar support. The details of using these commands from the command line is beyond the scope of this document, but in brief, control-Z suspends the foreground process, <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_421"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/fg.1.html#//apple_ref/doc/man/1/fg" target="_top">fg</a></code> brings a suspended or background job to the foreground, and <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_422"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/bg.1.html#//apple_ref/doc/man/1/bg" target="_top">bg</a></code> causes a job to begin executing in the background.</p><p>Up until this point, all of the scripts have involved a single process operating in the foreground. Indeed, most shell scripts operate in this fashion. Sometimes, though, parallelism can improve performance, particularly if the shell script is spawning a processor-hungry task. For this reason, this section describes programmatic ways to take advantage of background jobs in shell scripts.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW17" title="Note"></a><p><strong>Note:</strong>&nbsp;All Bourne shell variants support running a command in the background. However, the information obtained about these jobs varies from shell to shell, and pure Bourne shell implementations do not provide this information at all. Thus, when writing scripts that use this functionality, you should be aware that you are significantly limiting the portability of your script when you use BASH-specific or ZSH-specific builtins.</p>Also note that these examples are specific to BASH. For ZSH, there are subtle differences in the formatting of job status that will require changes to various bits of code. Making this code work in other shells is left as an exercise for the reader.</p></div><p>To start a process running in the background, add an ampersand at the end of the statement. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>sleep 10 <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_423"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_424"></a>&amp;<span></span></pre></td></tr></table></div><p>This will start a sleep process running in the background and will immediately return you to the command line. Ten seconds later, the command will finish executing, and the next time you hit return after that, you will see its exit status. Depending on your shell, it will look something like this:</p><div class="codesample"><table><tr><td scope="row"><pre>[1]+  Done                    sleep 10<span></span></pre></td></tr></table></div><p>This indicates that the sleep command completed execution. A related feature is the <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_425"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_426"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/wait.1.html#//apple_ref/doc/man/1/wait" target="_top">wait</a></code> builtin. This command causes the shell to wait for a specified background job to complete. If no job is specified, it will wait until all background jobs have finished.</p><p>The next example starts several commands in the background and waits for them to finish.</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/bash<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>function delayprint()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    local TIME;<span></span></pre></td></tr><tr><td scope="row"><pre>    TIME=$1<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Sleeping for $TIME seconds."<span></span></pre></td></tr><tr><td scope="row"><pre>    sleep $TIME<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Done sleeping for $TIME seconds."<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>delayprint 3 &amp;<span></span></pre></td></tr><tr><td scope="row"><pre>delayprint 5 &amp;<span></span></pre></td></tr><tr><td scope="row"><pre>delayprint 7 &amp;<span></span></pre></td></tr><tr><td scope="row"><pre>wait<span></span></pre></td></tr></table></div><p>This script is a relatively simple example. It executes three commands at once, then waits until all of them have completed. This may be sufficient for some uses, but it leaves something to be desired, particularly if you care about whether the commands succeed or fail.</p><p>The following example is a bit more complex. It shows two different techniques for waiting for jobs. You should generally use the process ID when waiting for a child process. You can obtain the process ID of the last command using the <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_427"></a><code>$!</code> shell variable.</p><p>If, however, you need to inspect a job using the <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_428"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_429"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/jobs.1.html#//apple_ref/doc/man/1/jobs" target="_top">jobs</a></code> builtin, you must use the job ID. It can be somewhat clumsy to obtain a job ID because the job control mechanism in most Bourne shell variants was designed primarily for interactive use rather than programmatic use. Fortunately, there are few things that a well-written regular expression can’t fix.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW18" title="Note"></a><p><strong>Note:</strong>&nbsp;Regular expressions are described in <span class="content_text"><a href="../RegularExpressionsUnfettered/RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW7">“Regular Expressions Unfettered.”</a></span> For the purposes of this example, it is sufficient to understand that the function <code>jobidfromstring</code> takes a job string like the one shown previously and prints out the first single digit or multidigit number by itself.</p></div><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/bash<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>function jobidfromstring()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>        local STRING;<span></span></pre></td></tr><tr><td scope="row"><pre>        local RET;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        STRING=$1;<span></span></pre></td></tr><tr><td scope="row"><pre>        RET="$(echo $STRING | sed 's/^[^0-9]*//' | sed 's/[^0-9].*$//')"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        echo $RET;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>function delayprint()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>        local TIME;<span></span></pre></td></tr><tr><td scope="row"><pre>        TIME=$1<span></span></pre></td></tr><tr><td scope="row"><pre>        echo "Sleeping for $TIME seconds."<span></span></pre></td></tr><tr><td scope="row"><pre>        sleep $TIME<span></span></pre></td></tr><tr><td scope="row"><pre>        echo "Done sleeping for $TIME seconds."<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Use the job ID for this one.<span></span></pre></td></tr><tr><td scope="row"><pre>delayprint 3 &amp;<span></span></pre></td></tr><tr><td scope="row"><pre>DP3=`jobidfromstring $(jobs %%)`<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Use the process ID this time.<span></span></pre></td></tr><tr><td scope="row"><pre>delayprint 5 &amp;<span></span></pre></td></tr><tr><td scope="row"><pre>DP5=$!<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>delayprint 7 &amp;<span></span></pre></td></tr><tr><td scope="row"><pre>DP7=`jobidfromstring $(jobs %%)`<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>echo "Waiting for job $DP3";<span></span></pre></td></tr><tr><td scope="row"><pre>wait %$DP3<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>echo "Waiting for process ID $DP5";<span></span></pre></td></tr><tr><td scope="row"><pre># No percent because it is a process ID<span></span></pre></td></tr><tr><td scope="row"><pre>wait $DP5<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>echo "Waiting for job $DP7";<span></span></pre></td></tr><tr><td scope="row"><pre>wait %$DP7<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>echo "Done."<span></span></pre></td></tr></table></div><p>This example passes a job number or process ID argument to the <code><a href="../../../../Darwin/Reference/ManPages/man1/jobs.1.html#//apple_ref/doc/man/1/jobs" target="_top">jobs</a></code> builtin to tell it which job you want to find out information about. <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_430"></a>Job numbers begin with a percent (%) sign and are normally followed by a number.</p><p>In the case, however, a second percent sign is used. The <code>%%</code> job is one of a number of special job “numbers” that the shell provides. It tells the <code>jobs</code> builtin to output information about the last command that was executed in the background. The result of this <code>jobs</code> command is a status string like the one shown earlier. This string is passed as a series of arguments to the <code>jobidfromstring</code> subroutine, which then prints the job ID by itself. The output of this subroutine, in turn, is stored into either the variable <code>DP3</code> or <code>DP7</code>.</p><p>This example also demonstrates how to wait for a job based on process ID using a special shell variable, <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_431"></a><code>$!</code>, which contains the process ID of the last command executed. This value is stored into the variable <code>DP5</code>. Process IDs are generally preferred over job IDs when using the <code>jobs</code> command in scripts (as opposed to hand-entered use of the <code>jobs</code> command).</p><p>Finally, the script ends with a series of <code>wait</code> commands. Like the <code>jobs</code> command, these commands can take a job ID. This job ID consists of a percent sign followed by the job number (obtained from either the variable <code>DP3</code> or <code>DP7</code>). These commands can also take a process ID (which is just the number itself).</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW19" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_432"></a>The C shell does not allow you to query the last job or wait for a single job or process ID. You can, however, wait for all outstanding jobs to finish by running the <code>wait</code> builtin with no arguments.</p></div><p>The final example shows how to execute a limited number of concurrent <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_433"></a><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_434"></a>jobs in which the order of job completion is not important.</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/bash<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>MAXJOBS=3<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>function spawnjob()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    echo $1 | bash<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>function clearToSpawn<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    local JOBCOUNT="$(jobs -r | grep -c .)"<span></span></pre></td></tr><tr><td scope="row"><pre>    if [ $JOBCOUNT -lt $MAXJOBS ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>        echo 1;<span></span></pre></td></tr><tr><td scope="row"><pre>        return 1;<span></span></pre></td></tr><tr><td scope="row"><pre>    fi<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    echo 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>JOBLIST=""<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>COMMANDLIST='ls<span></span></pre></td></tr><tr><td scope="row"><pre>echo "sleep 3"; sleep 3; echo "sleep 3 done"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "sleep 10"; sleep 10 ; echo "sleep 10 done"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "sleep 1"; sleep 1; echo "sleep 1 done"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "sleep 5"; sleep 5; echo "sleep 5 done"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "sleep 7"; sleep 7; echo "sleep 7 done"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "sleep 2"; sleep 2; echo "sleep 2 done"<span></span></pre></td></tr><tr><td scope="row"><pre>'<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IFS="<span></span></pre></td></tr><tr><td scope="row"><pre>"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>for COMMAND in $COMMANDLIST ; do<span></span></pre></td></tr><tr><td scope="row"><pre>    while [ `clearToSpawn` -ne 1 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>        sleep 1<span></span></pre></td></tr><tr><td scope="row"><pre>    done<span></span></pre></td></tr><tr><td scope="row"><pre>    spawnjob $COMMAND &amp;<span></span></pre></td></tr><tr><td scope="row"><pre>    LASTJOB=$!<span></span></pre></td></tr><tr><td scope="row"><pre>    JOBLIST="$JOBLIST $LASTJOB"<span></span></pre></td></tr><tr><td scope="row"><pre>done<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IFS=" "<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>for JOB in $JOBLIST ; do<span></span></pre></td></tr><tr><td scope="row"><pre>    wait $JOB<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Job $JOB exited with status $?"<span></span></pre></td></tr><tr><td scope="row"><pre>done<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>echo "Done."<span></span></pre></td></tr></table></div><p>Most of the code here is straightforward. It is worth noting, however, that in the function <code>clearToSpawn</code>, the <code>-r</code> flag must be passed to the <code>jobs</code> builtin to restrict output to currently running jobs. Without this flag, the <code>jobs</code> builtin would otherwise return a list that included completed jobs, thus making the count of running jobs incorrect.</p><div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_25" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;While it is tempting to put the while loop inside the <code>clearToSpawn</code> subroutine, if you do so, the program will wait forever. The status of jobs does not get updated by the shell until script execution returns to the main body of the program.</p><p></p><div class="clear"></div></div><p>The <code>-c</code> flag to <code><a href="../../../../Darwin/Reference/ManPages/man1/grep.1.html#//apple_ref/doc/man/1/grep" target="_top">grep</a></code> causes it to return the number of <a name="//apple_ref/doc/uid/TP40004268-TP40003513-DontLinkElementID_435"></a>matching lines rather than the lines themselves, and the period causes it to match on any nonblank lines (those containing at least one character). Thus, the <code>JOBCOUNT</code> variable contains the number of currently running jobs, which is, in turn, compared to the value <code>MAXJOBS</code> to determine whether it is appropriate to start another job or not.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-TP40003513-SW20" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;A C shell version of this script is included in the accompanying Companion Files download. To obtain this archive, see the web version of this document at <span class="content_text"><a href="http://developer.apple.com/" target="_top">http://developer.apple.com/</a></span>.</p></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../shell_scripts/shell_scripts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../PaintbyNumbers/PaintbyNumbers.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-04-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/OpenSource/Conceptual/ShellScripting/SubroutinesandScoping/SubroutinesandScoping.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/OpenSource/Conceptual/ShellScripting/SubroutinesandScoping/SubroutinesandScoping.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/OpenSource/Conceptual/ShellScripting/SubroutinesandScoping/SubroutinesandScoping.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>