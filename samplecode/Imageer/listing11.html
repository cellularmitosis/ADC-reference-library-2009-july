<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Imageer - /source/offscrnGraphics.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Imageer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Imageer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/source/offscrnGraphics.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/source/doevent.c</option>
<option value="listing2.html">/source/eventloop.c</option>
<option value="listing3.html">/source/fileCache.c</option>
<option value="listing4.html">/source/fileIO.c</option>
<option value="listing5.html">/source/gxGraphics.c</option>
<option value="listing6.html">/source/Imageer.app.h</option>
<option value="listing7.html">/source/Imageer.protos.h</option>
<option value="listing8.html">/source/Imageer.r</option>
<option value="listing9.html">/source/imageFilter.c</option>
<option value="listing10.html">/source/menu.c</option>
<option value="listing11.html">/source/offscrnGraphics.c</option>
<option value="listing12.html">/source/PreCompiledHeaders.c</option>
<option value="listing13.html">/source/start.c</option>
<option value="listing14.html">/source/windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="Imageer.zip">Download Sample</a></strong> (&#147;Imageer.zip&#148;, 161.4K)<BR>
<strong><a href="Imageer.dmg">Download Sample</a></strong> (&#147;Imageer.dmg&#148;, 243.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/****************************************************//*                          *//*  File:    offscrnGraphics.c          *//*                          *//*  Program:  Imageer                *//*                          *//*  By:      Jason Hodges-Harris          *//*                          *//*  Created:  26/10/95  00:00:00 AM        *//*                          *//*  Version:  1.0.0d3                *//*                          *//*  Copyright:  &copy; 1995-96 Apple Computer, Inc.,    */ /*          all rights reserved.      */    /*                          *//****************************************************//**** Macintosh Toolbox Headers *****/#ifndef __PALETTES__#include &lt;Palettes.h&gt;#endif#ifndef __QDOFFSCREEN__#include &lt;QDOffscreen.h&gt;#endif#ifndef __TYPES__#include &lt;Types.h&gt;#endif/****   Application headers and prototypes   ****/#ifndef __IMAGEERAPPHEADER__#include &quot;Imageer.app.h&quot;#endif#ifndef __IMAGEERPROTOSHEADER__#include &quot;Imageer.protos.h&quot;#endif/****  Default RGB Colors  ****/static const RGBColor   kRGBBlack = {0x0000, 0x0000, 0x0000};static const RGBColor  kRGBWhite = {0xFFFF, 0xFFFF, 0xFFFF};/**** Create GWorld attached to the image window document structure  ****/#pragma segment ImageWorldGWorldPtr  CreateOffscreen (CTabHandle theCTabHndl, short theXsize, short theYsize, short theBitDepth,GWorldFlags theFlags){  GWorldPtr  theGWorldPtr = nil;  QDErr    theError;  Rect    theRect;    SetRect(&amp;theRect,0,0,theXsize,theYsize);  theError = NewGWorld (&amp;theGWorldPtr,theBitDepth,&amp;theRect,theCTabHndl,nil,theFlags);  if (theError)  {    DisplayAlert (rGenAlert,rQDMessages,iFailGWorldAlloc);    return nil;  }  return theGWorldPtr;}/**** Draw image palette colors  ****/#pragma segment ImageWorldOSErr    DrawImageColors(WindowPtr  theWindow){  ImageDocHndl  theColorsDocHndl = nil,          theFrontDocHndl = nil;  PaletteHandle  windowPalette;  WindowPtr    frontWindow,          theNextWindow;  RGBColor    oldForeColor,          newForeColor;  Rect      colorRect;  short      countX,          countY,          colorIndex = 0,          numberColors;  OSErr      error = noErr;  Boolean      isImageWindow = false;    GetForeColor (&amp;oldForeColor);  frontWindow = FrontWindow();  while (!isImageWindow &amp;&amp; frontWindow)  {    theFrontDocHndl = (ImageDocHndl)GetWRefCon(theWindow);    if (!(**theFrontDocHndl).isColorsWindow)    {      isImageWindow = true;    }    else    {      theNextWindow = &amp;((WindowPeek)frontWindow)-&gt;nextWindow-&gt;port;      frontWindow = theNextWindow;    }  }  theColorsDocHndl = (ImageDocHndl)GetWRefCon(theWindow);  if (theColorsDocHndl)  {    switch ((**theColorsDocHndl).theImageDepth)    {      case  1:        DisplayAlert (rGenWarning,rErrMessages,iNotImplemented);      break;      case  2:      windowPalette = (**theColorsDocHndl).theColorsPalette;      numberColors = (**windowPalette).pmEntries;      for (countX = 0;countX&lt;128;countX+=32)      {        GetEntryColor (windowPalette, colorIndex, &amp;newForeColor);        SetRect(&amp;colorRect,16+ countX,16,countX+20,52);        RGBForeColor(&amp;newForeColor);        PaintRect(&amp;colorRect);        colorIndex++;      }      RGBForeColor(&amp;oldForeColor);      return error;      break;      case  4:        windowPalette = (**theColorsDocHndl).theColorsPalette;        numberColors = (**windowPalette).pmEntries;        for (countY = 0;countY&lt;32;countY+=16)        {          for (countX = 0;countX&lt;128;countX+=32)          {            GetEntryColor (windowPalette, colorIndex, &amp;newForeColor);            SetRect(&amp;colorRect,16+ countX,16+countY,countX+20,32+countY);            RGBForeColor(&amp;newForeColor);            PaintRect(&amp;colorRect);            colorIndex++;          }        }        RGBForeColor(&amp;oldForeColor);        return error;      break;      case  8:        windowPalette = (**theColorsDocHndl).theColorsPalette;        numberColors = (**windowPalette).pmEntries;        for (countY = 0;countY&lt;32;countY+=4)        {          for (countX = 0;countX&lt;128;countX+=4)          {            GetEntryColor (windowPalette, colorIndex, &amp;newForeColor);            SetRect(&amp;colorRect,16+ countX,16+ countY,countX+20,countY+20);            RGBForeColor(&amp;newForeColor);            PaintRect(&amp;colorRect);            colorIndex++;          }        }        RGBForeColor(&amp;oldForeColor);        return error;      break;      case  16:      case  32:        for (countY = 0;countY&lt;4;countY++)        {          for (countX = 0;countX&lt;128;countX+=2)          {            SetRect(&amp;colorRect,16+ countX,16+(countY*8),countX+18,24+(countY*8));            switch (countY)            {              case 0:                newForeColor.red = countX &lt;&lt; 9;                newForeColor.green = countX &lt;&lt; 9;                newForeColor.blue = countX &lt;&lt; 9;                RGBForeColor(&amp;newForeColor);                PaintRect(&amp;colorRect);              break;              case 1:                newForeColor.red = countX &lt;&lt; 9;                newForeColor.green = 0;                newForeColor.blue = 0;                RGBForeColor(&amp;newForeColor);                PaintRect(&amp;colorRect);              break;              case 2:                newForeColor.red = 0;                newForeColor.green = countX &lt;&lt; 9;                newForeColor.blue = 0;                RGBForeColor(&amp;newForeColor);                PaintRect(&amp;colorRect);              break;              case 3:                newForeColor.red = 0;                newForeColor.green = 0;                newForeColor.blue = countX &lt;&lt; 9;                RGBForeColor(&amp;newForeColor);                PaintRect(&amp;colorRect);              break;            }          }        }        RGBForeColor(&amp;oldForeColor);        return error;      break;    }  }  return kDefaultAppError;}/****  Force the colortable to be reset  ****/#pragma segment ImageWorldvoid  ForceRestoreColors(void){  RestoreDeviceClut(nil);  PaintBehind(nil, GetGrayRgn());  DrawMenuBar();}/****  Transfer visible portion of GWorld to current window  ****/#pragma segment ImageWorldOSErr  TransferImageToWindow(ImageDocHndl theWindDocHndl, WindowPtr theWindow){  PixMapHandle  thePixMapHndl = nil;  CGrafPtr    oldPort;  GDHandle    oldGDev;  RGBColor    oldForeColor,          oldBackColor;  Rect      sourceRect,
          destRect;  OSErr      error = noErr;    GetGWorld(&amp;oldPort,&amp;oldGDev);  SetGWorld((**theWindDocHndl).theImageWorld,nil);  GetForeColor(&amp;oldForeColor);  GetBackColor(&amp;oldBackColor);  RGBForeColor(&amp;kRGBBlack);  RGBBackColor(&amp;kRGBWhite);  thePixMapHndl = GetGWorldPixMap((**theWindDocHndl).theImageWorld);  if (PixMap32Bit(thePixMapHndl))          // if 32bit mode needed == true    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  if (!error)  {    sourceRect = (**theWindDocHndl).theImageWorld-&gt;portRect;    destRect = theWindow-&gt;portRect;    destRect.right -= kScrollBarWidth;  // resize port rect to exclude controller area    destRect.bottom -= kScrollBarWidth;    if (!EqualRect(&amp;destRect,&amp;sourceRect))      sourceRect = *CalcVisibleImage(theWindDocHndl,&amp;destRect);    SetGWorld(oldPort,oldGDev);    CopyBits((BitMap*)(*thePixMapHndl),         (BitMap*)&amp;((*theWindow).portBits),         &amp;sourceRect,&amp;destRect,srcCopy,nil);  }  UnlockPixels(thePixMapHndl);    // unlock GWorld  SaveSetMMUMode(false);  return error;}/****  Calculate the visible area of window contents region ****/#pragma segment ImageWorldRect*  CalcVisibleImage(ImageDocHndl theWindDocHndl,const Rect *destRect){  Rect  displayRect;  short  theXvalue,      theYvalue;  theXvalue = GetControlValue((**theWindDocHndl).theHScrollBar);  theYvalue = GetControlValue((**theWindDocHndl).theVScrollBar);  SetRect(&amp;displayRect,theXvalue,theYvalue,destRect-&gt;right+theXvalue,destRect-&gt;bottom+theYvalue);  return &amp;displayRect;}/****  Set and Reset the address mode between 24 and 32 bits  ****/#pragma segment ImageWorldvoid  SaveSetMMUMode(Boolean isSaveMode){  static signed char    theAddrMode = true32b;  static Boolean      swapModeNeeded = false;    if (isSaveMode == true)  {    if(GetMMUMode() == false32b)        // get current addr mode    {      swapModeNeeded = true;          // in 24 bit mode swap needed      SwapMMUMode (&amp;theAddrMode);        // switch to 32 bit mode    }  }  else if (swapModeNeeded == true)    SwapMMUMode (&amp;theAddrMode);}/****  Calc new index depth colors window palette  ****/#pragma segment ImageWorldOSErr  UpdateColorsWindPalette(ImageDocHndl theImageWindDocHndl, WindowPtr theImageWindow){  ImageDocHndl  theFrntWindHndl;  GrafPtr      oldPort;  WindowPtr    theWindow,          theNextWindow;  OSErr      error = noErr;    GetPort(&amp;oldPort);  theWindow = FrontWindow();  while (theWindow)  {    theFrntWindHndl = (ImageDocHndl)GetWRefCon(theWindow);    if ((*theFrntWindHndl)-&gt;isColorsWindow)    {      if ((*theImageWindDocHndl)-&gt;theImageDepth != (*theFrntWindHndl)-&gt;theImageDepth)        (*theFrntWindHndl)-&gt;theImageDepth = (*theImageWindDocHndl)-&gt;theImageDepth;      if ((*theFrntWindHndl)-&gt;theImageDepth &lt;= 8 &amp;&amp; !(*theImageWindDocHndl)-&gt;isUsingQDGX)      {        if ((*theFrntWindHndl)-&gt;theColorsPalette)          DisposePalette((*theFrntWindHndl)-&gt;theColorsPalette);        (*theFrntWindHndl)-&gt;theColorsPalette =           NewPalette(256,                 (*(*theImageWindDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pmTable,                 pmTolerant+pmExplicit,0);        if ((*theFrntWindHndl)-&gt;theColorsPalette)           NSetPalette(theWindow,(*theFrntWindHndl)-&gt;theColorsPalette,pmAllUpdates);        else          error = kFailMakePalette;      }      SetPort(theWindow);      InvalRect(&amp;theWindow-&gt;portRect);      SetPort(oldPort);      theWindow = nil;    }    if (theWindow)    {      theNextWindow = &amp;((WindowPeek)theWindow)-&gt;nextWindow-&gt;port;      theWindow = theNextWindow;    }  }  return error;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Imageer/listing11.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Imageer/listing11.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Imageer/listing11.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>