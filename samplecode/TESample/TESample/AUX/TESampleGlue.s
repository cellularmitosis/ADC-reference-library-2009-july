##	Apple Macintosh Developer Technical Support##	MultiFinder-Aware TextEdit Sample Application##	TESample##	TESample.a	-	Assembler Source##	Copyright © 1989 Apple Computer, Inc.#	All rights reserved.##	Versions:	#				1.00				08/88#				1.01				11/88#				1.02				04/89#				1.03				06/89##	Components:#				TESample.p			June 1, 1989#				TESample.c			June 1, 1989#				TESampleGlue.a		June 1, 1989	-MPW only-#				TESample.r			June 1, 1989#				TESample.h			June 1, 1989#				PTESample.make		June 1, 1989	-MPW only-#				CTESample.make		June 1, 1989	-MPW only-#				TESampleGlue.s		June 1, 1989	-A/UX only-#				TESampleAUX.r		June 1, 1989	-A/UX only-#				Makefile			June 1, 1989	-A/UX only-##	TESample is an example application that demonstrates how #	to initialize the commonly used toolbox managers, operate #	successfully under MultiFinder, handle desk accessories and #	create, grow, and zoom windows. The fundamental TextEdit #	toolbox calls and TextEdit autoscroll are demonstrated. It #	also shows how to create and maintain scrollbar controls.##	It does not by any means demonstrate all the techniques you #	need for a large application. In particular, Sample does not #	cover exception handling, multiple windows/documents, #	sophisticated memory management, printing, or undo. All of #	these are vital parts of a normal full-sized application.##	This application is an example of the form of a Macintosh #	application; it is NOT a template. It is NOT intended to be #	used as a foundation for the next world-class, best-selling, #	600K application. A stick figure drawing of the human body may #	be a good example of the form for a painting, but that does not #	mean it should be used as the basis for the next Mona Lisa.##	We recommend that you review this program or Sample before #	beginning a new application. Sample is a simple app. which doesnUt #	use TextEdit or the Control Manager.###	AsmClickLoop##	This routine gets called by the TextEdit Manager from TEClick.#	It calls the old, default click loop routine that scrolls the#	text, and then calls our own Pascal routine that handles#	tracking the scroll bars to follow along.  It doesn't bother#	with saving registers A0 and D0, because they are trashed#	anyway by TextEdit.#	text	global AsmClickLoopAsmClickLoop:#	movem.l	%d1/%d2/%a1,-(%sp)		# d0 and a0 need not be saved	jsr	GetOldClickLoop			# get the old clickLoop#	movem.l	(%sp)+,%d1/%d2/%a1		# restore the world as it was	jsr	(%a0)				# and execute old clickLoop#	movem.l	%d1/%d2/%a1,-(%sp)		# d0 and a0 need not be saved	jsr	CClickLoop			# do our clickLoop#	movem.l	(%sp)+,%d1/%d2/%a1		# restore the world as it was	move.l	&1,%d0			# clear the zero flag so textedit keeps going	rts# A/UX C doesn't now how to generate a Pascal calling sequence for a ROM# call-back routine.  So this routine takes the place of the VActionProc# declared in the TESample.c source.  This code, in turn, translates the# Pascal calling sequence into the C calling sequence and calls the # VActionProc in TESample.c, now called CVActionProc# void		VActionProc (theControl,partCode)# ControlHandle	theControl;# short		partCode;	global	VActionProcVActionProc:	move.w	4(%a7),-(%a7)	clr.w	-(%a7)	move.l	10(%a7),-(%a7)	jsr	CVActionProc		# Call the C version	move.l	8(%a7),%a1	add.l	&18,%a7	jmp	(%a1)# A/UX C doesn't now how to generate a Pascal calling sequence for a ROM# call-back routine.  So this routine takes the place of the HActionProc# declared in the TESample.c source.  This code, in turn, translates the# Pascal calling sequence into the C calling sequence and calls the # HActionProc in TESample.c, now called CHActionProc# void		HActionProc (theControl,partCode)# ControlHandle	theControl;# short		partCode;	global	HActionProcHActionProc:	move.w	4(%a7),-(%a7)	clr.w	-(%a7)	move.l	10(%a7),-(%a7)	jsr	CHActionProc		# Call the C version	move.l	8(%a7),%a1	add.l	&18,%a7	jmp	(%a1)