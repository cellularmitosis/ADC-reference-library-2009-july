<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Exported Symbols</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING100></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="RTArch-99.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-101.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="RTArch-2.html"><B>Mac OS Runtime Architectures</B></A> / <BR><DD><A HREF="RTArch-89.html"><B>Chapter 8 - PEF Structure</B></A> / <A HREF="RTArch-95.html"><B>The Loader Section</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING100-0></A>
<H2><A NAME=MARKER-9-101></A>Exported Symbols</H2>
 All exported symbols in a PEF container are stored in a hashed form, allowing the Code Fragment Manager to search for them efficiently when preparing a fragment. <B><A NAME=MARKER-2-102></A>Hashing</B> is a method of processing and organizing symbols so they can be searched for quickly. <P>
 PEF uses a modified version of the traditional hash table. The traditional model is shown in <A HREF=#MARKER-9-103>Figure 8-21</A>.<P>
<B>Figure 8-21  <A NAME=MARKER-9-103></A>A traditional hash table</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-87.jpg"> <P>
 A hash word is computed for every symbol and a hash index value is computed for every hash word. The hash words are grouped together in hash chains according to their index values, and each chain corresponds to an entry in the hash table. <P>
 The PEF implementation, as shown in <A HREF=#MARKER-9-104>Figure 8-22</A>, effectively flattens the traditional hash table. Functionally the hash tables in <A HREF=#MARKER-9-103>Figure 8-21</A> and <A HREF=#MARKER-9-104>Figure 8-22</A> are identical. <P>
<B>Figure 8-22  <A NAME=MARKER-9-104></A>Flattened hash table implementation</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-88.jpg"> <P>
 Each hash chain is stored consecutively in the export key table and the exported symbol table. For each hash index value, the hash table stores the number of entries in its chain and the starting table index value for that chain. <P>
 The general procedure for creating a hashed data structure is as follows:<P>
<OL>
<LI>Compute the number of hash index values. This value is based on the number of exported symbols in the container. See <A HREF=#MARKER-9-121>"The Exported Symbol Count to Hash Table Size Function" (page 8-42)</A> for a suggested method of calculating this value.
<LI>Compute the hash word value and hash index value for every exported symbol. (The hash index value is dependent on both the symbol and the size of the hash table.) See <A HREF=#MARKER-9-115>"The Name to Hash Word Function" (page 8-41)</A> and <A HREF=#MARKER-9-118>"The Hash Word to Hash Index Function" (page 8-42)</A> for details of the required calculations. 
<LI>Sort the exported symbols by hash index value. This procedure effectively indexes the exported symbols. Each symbol has a table index value that references its hash word in the export key table and an entry in the exported symbol table. 
<LI>Construct the hash table using the size determined in step 1. Each hash table entry contains a chain count indicating the number of exported symbols in the chain (that is, the number that have this hash index value) and the offset in the export key and symbol tables to the first symbol in the chain. <P>
</OL>
 The Code Fragment Manager can search for exported symbols by name or by table index number. When searching for a symbol by (zero-based) table index number, the Code Fragment Manager looks up the index value in the exported symbol table to obtain a pointer to the name of the symbol. Then it uses the same index to get the hash word value of the symbol in the export key table. (The length of the name is encoded in the hash word.)<P>
 Searching for exported symbols by name is somewhat more complicated. The Code Fragment Manager first computes the hash word of the symbol it is trying to locate. Then it computes a hash index value from the hash word and the size of the hash table. Using this value as an index into the hash table, the Code Fragment Manager obtains a chain count value and a table index value for the first entry in the hash chain (as determined in step 4). Then, beginning at the table index value, it searches the export key table for a hash word to match the one it previously calculated. If the Code Fragment Manager finds a match, it uses the matching table index value to look up the name in the symbol table. If the symbol names match, the Code Fragment Manager returns information about the symbol. If the Code Fragment Manager cannot find a match after searching the number of entries equivalent to the chain count value, it marks the symbol as not found. <P>
 The sections that follow describe the elements of the hashed data structure in more detail.<P>
<A NAME=HEADING100-18></A>
<H3>The Export Hash Table</H3>
 <A NAME=MARKER-2-105></A>The number of entries in the hash table is 2 raised to the value in the <CODE>exportHashTablePower</CODE> field of the loader header <A HREF=RTArch-96.html#MARKER-9-62>(page 8-18)</A>. The number of entries is determined from the number of exported symbols. If there are no exports, the table still contains one entry. See <A HREF=#MARKER-9-113>"Hashing Functions" (page 8-41)</A> for details of the hashing process and the suggested method for computing the number of hash table entries.<P>
 A hash table entry is of fixed size (4 bytes) and has the form shown in <A NAME=MARKER-2-106></A><A HREF=#MARKER-9-107>Figure 8-23</A>.<P>
<B>Figure 8-23  <A NAME=MARKER-9-107></A>A hash table entry</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-39.jpg"> <P>
 The field values are as follows:<P>
<UL>
<LI>The first field (14 bits) contains the number of items in this chain.
<LI>The second field (18 bits) contains the table index value of the first symbol in the chain (see <A HREF=#MARKER-9-104>Figure 8-22 (page 8-37)</A>).<P>
</UL>
<A NAME=HEADING100-26></A>
<H3>The Export Key Table</H3>
 <A NAME=MARKER-2-108></A>The export key table contains a key (a hash word) for every exported symbol. The structure of a hash word is fixed (4 bytes) and has the form shown in <A HREF=#MARKER-9-109>Figure 8-24</A>.<P>
<B>Figure 8-24  <A NAME=MARKER-9-109></A>A hash word </B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-92.jpg"> <P>
<UL>
<LI>The first field contains the length of the export symbol name in bytes. 
<LI>The second field contains the name of the symbol encoded using a hash key. <P>
</UL>
 For more information about calculating the hash word, see <A HREF=#MARKER-9-115>"The Name to Hash Word Function" (page 8-41)</A>.<P>
<A NAME=HEADING100-33></A>
<H3>The Exported Symbol Table</H3>
 <A NAME=MARKER-2-110></A>The exported symbol table contains an entry for every symbol exported by the fragment. All exports with a given hash index value are grouped together in the symbol table (see <A HREF=#MARKER-9-104>Figure 8-22 (page 8-37)</A>). <P>
 An exported symbol table entry data structure is of fixed size (10 bytes) and has the form shown in <A HREF=#MARKER-9-111>Listing 8-7</A>.<P>
<B>Listing 8-7  <A NAME=MARKER-9-111></A>Exported symbol table entry data structure </B><P>
<PRE>
struct PEFExportedSymbol {
   UInt32classAndName; 
   UInt32symbolValue; 
   SInt16sectionIndex; 
};
</PRE>
<DL>
<DT><B>Note</B>
<DD>Each entry is 10 bytes long. No padding bytes are used between successive entries.<EM></EM><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The fields in the entry are as follows:<P>
<UL>
<LI>The <CODE>classAndName</CODE> field (4 bytes) contains two entries: <P>
<UL>
<LI>The first byte designates the symbol class of the exported symbol. See <A HREF=RTArch-97.html#MARKER-9-7>Table 8-3 (page 8-21)</A> for a listing of classes. Flag bits for exported symbols are reserved for future use. 
<LI>The following 3 bytes designate the offset from the beginning of the loader string table to the name of the symbol. The name of the symbol is not null terminated, but you can determine the length of the string from the upper 2 bytes of the symbol's hash word (found in the export key table).<P>
</UL>
<LI>The <CODE>symbolValue</CODE> field (4 bytes) typically indicates the offset from the beginning of the symbol's section to the exported symbol. 
<LI>The <CODE>sectionIndex</CODE> field (2 bytes) indicates the number of the section that contains this symbol. Note that this is a signed field.<P>
</UL>
 The <CODE>symbolValue</CODE> field has special meaning when the section number is negative. If the section number is <CODE>-2</CODE>, the <CODE>symbolValue</CODE> field contains an absolute address. If the section number is <CODE>-3</CODE>, the <CODE>symbolValue</CODE> field contains an imported symbol index, indicating that the imported symbol is being reexp<A NAME=MARKER-2-112></A>orted.<P>
<A NAME=HEADING100-46></A>
<H3><A NAME=MARKER-9-113></A>Hashing Functions</H3>
 <A NAME=MARKER-2-114></A>This section describes hashing algorithms used to create the hashed data structure for exported symbols. <P>
<A NAME=HEADING100-48></A>
<H4><A NAME=MARKER-9-115></A>The Name to Hash Word Function</H4>
 <A NAME=MARKER-2-116></A>The hash word function computes a 32-bit hash word for a symbol name. The upper 16 bits contains the length of the name, and the symbol name is encoded using a hash key in the lower 16 bits. You are required to use this algorithm to calculate the hash word. <A HREF=#MARKER-9-117>Listing 8-8</A> shows a C implementation of the hash word function.<P>
<B>Listing 8-8  <A NAME=MARKER-9-117></A>Hash word function</B><P>
<PRE>
/* Computes a hash word for a given string. nameText points to the */ 
/* first character of the string (not the Pascal length byte). The */
/* string may be null terminated. */

enum {
   kPEFHashLengthShift= 16,
   kPEFHashValueMask = 0x0000FFFF
};

UInt32 PEFComputeHashWord (BytePtr nameText, UInt32 nameLength)
{
   BytePtrcharPtr = nameText;
   SInt32hashValue= 0;
   UInt32length   = 0;
   UInt32limit;
   UInt32result;
   UInt8 currChar;

   #define PseudoRotate(x)  ( ( (x) &lt;&lt; 1 ) - ( (x) &gt;&gt; 16 )) 

   for (limit = nameLength; limit &gt; 0; limit -= 1) 
   {
      currChar = *charPtr++;
      if (currChar == NULL) break;
      length += 1;
      hashValue = PseudoRotate (hashValue) ^ currChar;
   }

   result = (length &lt;&lt; kPEFHashLengthShift) | 
   ((UInt16) ((hashValue ^ (hashValue &gt;&gt; 16)) &amp; kPEFHashValueMask));

   return result;

} /* PEFComputeHashWord () */
</PRE>
<A NAME=HEADING100-52></A>
<H4><A NAME=MARKER-9-118></A>The Hash Word to Hash Index Function</H4>
 <A NAME=MARKER-2-119></A>The hash index (or hash slot number) function converts the 32-bit hash word value into a small index number.You are required to use this algorithm for calculating the index number. <A HREF=#MARKER-9-120>Listing 8-9</A> shows the hash word to hash index function.<P>
<B>Listing 8-9  <A NAME=MARKER-9-120></A>Hash word to hash index function</B><P>
<PRE>
#define PEFHashTableIndex(fullHashWord,hashTablePower) \
   ( ( (fullHashWord) ^ ((fullHashWord) &gt;&gt; (hashTablePower)) ) &amp; \
   ((1 &lt;&lt; (hashTablePower)) - 1) )
</PRE>
<A NAME=HEADING100-56></A>
<H4><A NAME=MARKER-9-121></A>The Exported Symbol Count to Hash Table Size Function</H4>
 <A NAME=MARKER-2-122></A><A HREF=#MARKER-9-123>Listing 8-10</A> shows a suggested method of calculating the hash table size. (This algorithm provides a good tradeoff between minimizing search time and minimizing table size, but you may substitute a similar algorithm.) The hash table size function computes the size of the hash table based on the number of exported symbols in the PEF container. The number of hash table entries is always a power of 2. The function in <A HREF=#MARKER-9-123>Listing 8-10</A> returns the value of the exponent. The value kExponentLimit can be arbitrary, but it must not exceed 30. The constant <CODE>kAverageChainLimit</CODE> is normally set to <CODE>10</CODE>, but you can adjust this to make a trade off between the size of the chain and search time.<P>
<B>Listing 8-10  <A NAME=MARKER-9-123></A>Exported symbol count to hash table size function</B><P>
<PRE>
UInt8 PEFComputeHashTableExponent (SInt32 exportCount)
{
   SInt32exponent;

   const SInt32kExponentLimit = 16;
   const SInt32kAverageChainLimit= 10;

   for (exponent = 0; exponent &lt; kExponentLimit; exponent += 1) {
      if ((exportCount / (1 &lt;&lt; exponent)) &lt; kAverageChainLimit)
         break;
   }

   return exponent;

}  /* PEFComputeHashTableExponent () */
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="RTArch-99.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-101.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="RTArch-3.html">&copy; Apple Computer, Inc.</A><br>11 MARCH 1997<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
