<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> Using Meshes</TITLE></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><H1 CLASS="H2.Heading2"><A NAME="pgfId=33331"> </A><A NAME="28740"> </A>Using Meshes</H1><P CLASS="T1.Text1"><A NAME="pgfId=33332"> </A>Like the polyhedron and trimesh, the mesh is designed for representing polyhedra. However, it is intended for the interactive topological creation and editing of polyhedra, so its architecture and API were designed to support both iterative construction and topological modification.</P><P CLASS="T1.Text1"><A NAME="pgfId=33333"> </A>Iterative construction means that you can easily construct a mesh by building it face-by-face, instead of filling in a data structure and constructing it from the data structure all at once.</P><P CLASS="T1.Text1"><A NAME="pgfId=33334"> </A>Topological modification means that you can easily add and delete vertices, faces, edges, and other components in a mesh. A mesh has no explicit public data structure; unlike the other geometric primitives, it also has no immediate-mode capability.</P><P CLASS="T1.Text1"><A NAME="pgfId=33335"> </A>Meshes are not intended for representing large-scale polyhedral models with many vertices and faces. If employed this way, the mesh format causes poor  I/O behavior, heavy memory usage, and suboptimal rendering speed. Hence modeling, animation, and design applications should use the polyhedron format for most model creation and storage.</P><P CLASS="T1.Text1"><A NAME="pgfId=33336"> </A>On the other hand, in some applications the mesh format is superior to other geometric primitives. For example, it would be ideal in an application that used a 3D sampling peripheral, such as a Polhemus device, to digitize physical objects. You could use the mesh to construct the digitized model face-by-face, to merge or split faces, to add or delete vertices, and so forth. Doing these tasks with an array-based data structure would be awkward to program and force the program to make repeated array reallocations.</P><P CLASS="T1.Text1"><A NAME="pgfId=33337"> </A>The faces of meshes, unlike those of the polyhedron and trimesh, may have more than three vertices, may be concave (though not self-intersecting), and may contain holes by defining faces with more than one list of vertices.</P><P CLASS="T1.Text1"><A NAME="pgfId=33338"> </A>The mesh API supports a rich variety of geometric and topological editing operations, but only for retained mode; it has no immediate-mode public data structure. If your application needs immediate mode, you should use the polyhedron format.</P><P CLASS="T1.Text1"><A NAME="pgfId=33339"> </A>In general, the rendering speed of meshes is relatively slow. They must be either traversed for rendering or decomposed into other primitives that yield faster rendering. Traversing usually results in the slow retransformation and reshading of shared vertices, while decomposition may require heavy memory usage as well as complex and slow bookkeeping code.</P><P CLASS="T1.Text1"><A NAME="pgfId=33340"> </A>To summarize, you should use the mesh primitive for interactive construction and topological editing. Its rich set of geometric and topological editing calls, the ability to make nontriangular faces directly, the ability to make concave faces and faces with holes, and the consistent use of attribute sets make the mesh primitive ideal for many purposes. In addition, the 3D metafile representation of a mesh is quite space efficient. Because the mesh lacks an immediate mode, however, it requires a large amount of memory and may be inefficient for other uses.</P><DIV><H2 CLASS="H3.Heading3"><A NAME="pgfId=34112"> </A><A NAME="11337"> </A>Creating a Mesh</H2><P CLASS="T1.Text1"><A NAME="pgfId=34116"> </A>As explained in <A HREF="qd3dgeometry.4.htm#37165" CLASS="XRef">&quot;Meshes&quot;</A>, you create a mesh by calling <TT CLASS="cv">Q3Mesh_New</TT> to create a new empty mesh and then by calling <TT CLASS="cv">Q3Mesh_VertexNew</TT> and <TT CLASS="cv">Q3Mesh_FaceNew</TT> to explicitly add vertices and faces to the mesh. <A HREF="qd3dgeometry.b.htm#37707" CLASS="XRef">Listing&nbsp;9</A> illustrates how to create a simple mesh using these functions. It also shows how to attach a custom surface parameterization to a mesh face, so that a texture can be mapped onto the face.<A NAME="marker=34120"> </A></P><P CLASS="L.Listing"><A NAME="pgfId=34122"> </A>Listing&nbsp;9<A NAME="37707"> </A>Creating a simple mesh</P><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39511"> </A>TQ3GroupObject MyBuildMesh (void)<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3ColorRGB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMeshColor;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3GroupObject&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myModel;<BR>&nbsp;&nbsp;&nbsp;&nbsp;static TQ3Vertex3D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[9] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ { -0.5, &nbsp;0.5, 0.0 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ { -0.5, -0.5, 0.0 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ {  0.0, -0.5, 0.3 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ {  0.5, -0.5, 0.0 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ {  0.5, &nbsp;0.5, 0.0 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ {  0.0, &nbsp;0.5, 0.3 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ { -0.4, &nbsp;0.2, 0.0 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ {  0.0, &nbsp;0.0, 0.0 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ { -0.4, -0.2, 0.0 }, NULL }};<BR>&nbsp;&nbsp;&nbsp;&nbsp;static TQ3Param2D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verticesUV[9] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0.0, 1.0}, {0.0, 0.0}, {0.5, 0.0}, {1.0, 0.0},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.0, 1.0}, {0.5, 1.0}, {0.1, 0.8}, {0.5, 0.5},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0.1, 0.4}};<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39517"> </A>&nbsp;&nbsp;&nbsp;&nbsp;TQ3MeshVertex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMeshVertices[9];<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3GeometryObject&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMesh;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3MeshFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMeshFace;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3AttributeSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myFaceAttrs;<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i;<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39523"> </A>&nbsp;&nbsp;&nbsp;&nbsp;myMesh = Q3Mesh_New();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*create new empty mesh*/<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39529"> </A>&nbsp;&nbsp;&nbsp;&nbsp;Q3Mesh_DelayUpdates(myMesh);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*turn off mesh updating*/<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39535"> </A>&nbsp;&nbsp;&nbsp;&nbsp;/*Add vertices and surface parameterization to mesh.*/<BR>&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 9; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TQ3AttributeSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myVertAttrs;<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39541"> </A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMeshVertices[i] = Q3Mesh_VertexNew(myMesh, &amp;vertices[i]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myVertAttrs = Q3AttributeSet_New();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q3AttributeSet_Add(myVertAttrs, kQ3AttributeTypeSurfaceUV, &amp;verticesUV[i]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q3Mesh_SetVertexAttributeSet(myMesh, myMeshVertices[i], myVertAttrs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q3Object_Dispose(myVertAttrs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39547"> </A>&nbsp;&nbsp;&nbsp;&nbsp;myFaceAttrs = Q3AttributeSet_New();<BR>&nbsp;&nbsp;&nbsp;&nbsp;myMeshColor.r = 0.3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myMeshColor.g = 0.9;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myMeshColor.b = 0.5;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Q3AttributeSet_Add(myFaceAttrs, kQ3AttributeTypeDiffuseColor, &amp;myMeshColor);<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39553"> </A>&nbsp;&nbsp;&nbsp;&nbsp;myMeshFace = Q3Mesh_FaceNew(myMesh, 6, myMeshVertices, myFaceAttrs);<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39559"> </A>&nbsp;&nbsp;&nbsp;&nbsp;Q3Mesh_FaceToContour(myMesh, myMeshFace, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q3Mesh_FaceNew(myMesh, 3, &amp;myMeshVertices[6], NULL));<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39565"> </A>&nbsp;&nbsp;&nbsp;&nbsp;Q3Mesh_ResumeUpdates(myMesh);<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39571"> </A>&nbsp;&nbsp;&nbsp;&nbsp;myModel = Q3OrderedDisplayGroup_New();<BR>&nbsp;&nbsp;&nbsp;&nbsp;Q3Group_AddObject(myModel, myMesh);<BR>&nbsp;&nbsp;&nbsp;&nbsp;Q3Object_Dispose(myFaceAttrs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;Q3Object_Dispose(myMesh);<BR>&nbsp;&nbsp;&nbsp;&nbsp;return (myModel);<BR>}<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=34125"> </A><A NAME="marker=39573"> </A>The new mesh created by MyBuildMesh is a retained object. Note that you need to call <TT CLASS="cv">Q3Mesh_New</TT> before you call <TT CLASS="cv">Q3Mesh_VertexNew</TT> and <TT CLASS="cv">Q3Mesh_FaceNew</TT>. Also, the call to <TT CLASS="cv">Q3Mesh_FaceToContour</TT> destroys any attributes associated with the mesh face that is turned into a contour.</P></DIV><DIV><H2 CLASS="H3.Heading3"><A NAME="pgfId=34126"> </A>Traversing a Mesh</H2><P CLASS="T1.Text1"><A NAME="pgfId=34131"> </A><A NAME="marker=34127"> </A>QuickDraw&nbsp;3D supplies functions that you can use to traverse a mesh by iterating through various parts of the it. For example, you can operate on each face of a mesh by calling the <TT CLASS="cv">Q3Mesh_FirstMeshFace</TT> function to get the first face in the mesh and then <TT CLASS="cv">Q3Mesh_NextMeshFace</TT> to get each successive face. When you call <TT CLASS="cv">Q3Mesh_FirstMeshFace</TT>, you specify a mesh and a <B CLASS="bold">mesh iterator structure,</B> which QuickDraw&nbsp;3D fills in with information about its current position while traversing the mesh. You must pass that same mesh iterator structure to <TT CLASS="cv">Q3Mesh_NextMeshFace</TT> when you get successive faces in the mesh. <A HREF="qd3dgeometry.b.htm#22340" CLASS="XRef">Listing&nbsp;10</A> illustrates how to use these routines to operate on all faces in a mesh.<A NAME="marker=34138"> </A><A NAME="marker=34139"> </A><A NAME="marker=34140"> </A></P><P CLASS="L.Listing"><A NAME="pgfId=34142"> </A>Listing&nbsp;10<A NAME="22340"> </A>Iterating through all faces in a mesh</P><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39577"> </A>TQ3Status MySetMeshFacesDiffuseColor (TQ3GeometryObject myMesh, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;TQ3ColorRGB color) <BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3MeshFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myFace;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3MeshIterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myIter;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3Status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myErr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3AttributeSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mySet;<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39583"> </A>&nbsp;&nbsp;&nbsp;&nbsp;for (myFace = Q3Mesh_FirstMeshFace(myMesh, &amp;myIter); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myFace;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myFace = Q3Mesh_NextMeshFace(&amp;myIter)) {<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39589"> </A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Get the current attribute set of the current face.*/<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myErr = Q3Mesh_GetFaceAttributeSet(myMesh, myFace, &amp;mySet);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (myErr == kQ3Failure) return (kQ3Failure);<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39595"> </A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Add the color attribute to the face attribute set.*/<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myErr = Q3AttributeSet_Add((TQ3AttributeSet)mySet, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kQ3AttributeTypeDiffuseColor, &amp;color);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (myErr == kQ3Failure) return (kQ3Failure);<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39601"> </A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Set the attribute set of the current face.*/<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myErr = Q3Mesh_SetFaceAttributeSet(myMesh, myFace, mySet);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (myErr == kQ3Failure) return (kQ3Failure);<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;return (kQ3Success);<BR>}<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=34149"> </A><A NAME="marker=39603"> </A>QuickDraw&nbsp;3D also supplies a number of C language macros that you can use to simplify your source code when traversing a mesh. For example, you can use the following Q3ForEachMeshFace macro:<A NAME="marker=34150"> </A></P><CODE CLASS="Cv.Code"><A NAME="pgfId=39607"> </A>#define Q3ForEachMeshFace(m,f,i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;for ( (f) = Q3Mesh_FirstMeshFace((m),(i));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f) = Q3Mesh_NextMeshFace((i)) )<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=34155"> </A><A HREF="qd3dgeometry.b.htm#13169" CLASS="XRef">Listing&nbsp;11</A> shows how to use two of these macros to attach a corner to each vertex or each face of a mesh.</P><P CLASS="L.Listing"><A NAME="pgfId=34157"> </A>Listing&nbsp;11<A NAME="13169"> </A>Attaching corners to all vertices in all faces of a mesh</P><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39613"> </A>TQ3Status MyAddCornersToMesh (TQ3GeometryObject myMesh, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;TQ3AttributeSet mySet)<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3MeshFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myFace;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3MeshVertex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myVertex;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3MeshIterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myIter1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3MeshIterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myIter2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3Status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myErr;<BR></CODE><CODE CLASS="CvF.CodeFull"><A NAME="pgfId=39619"> </A>&nbsp;&nbsp;&nbsp;&nbsp;Q3ForEachMeshFace(myMesh, myFace, &amp;myIter1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q3ForEachFaceVertex(myFace, myVertex, &amp;myIter2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myErr = Q3Mesh_SetCornerAttributeSet<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(myMesh, myFace, myVertex, mySet);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (myErr == kQ3Failure) return (kQ3Failure);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;return (kQ3Success);<BR>}<BR></CODE></DIV><hr>&#169; 1997 Apple Computer, Inc.</DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>