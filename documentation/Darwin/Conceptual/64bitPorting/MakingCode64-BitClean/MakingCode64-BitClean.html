<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>64-Bit Transition Guide: Making Code 64-Bit Clean</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Making Code 64-Bit Clean"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001064-CH226" title="Making Code 64-Bit Clean"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../Porting-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000553" target="_top">Porting</a> &gt; <a href="../intro/intro.html#//apple_ref/doc/uid/TP40001064-CH205-TPXREF101">64-Bit Transition Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../transition/transition.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../building/building.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001064-CH226-SW2" title="Making Code 64-Bit Clean"></a><h1>Making Code 64-Bit Clean</h1><p>Before you begin to update your code, you should familiarize yourself with the document <em><a href="../../../../MacOSX/Conceptual/OSX_Technology_Overview/index.html#//apple_ref/doc/uid/TP40001067" target="_top">Mac OS X Technology Overview</a></em>. After reading that document, the first thing you should do is compile your code with the <code>-Wall</code> compiler flag and fix any warnings that occur. In particular, make sure that all function prototypes are in scope, because out-of-scope prototypes can hide many subtle portability problems.</p><p>At a high level, to make your code 64-bit clean, you must do the following:</p><ul class="ul"><li class="li"><p>Avoid assigning 64-bit <code>long</code> integers to 32-bit integers.</p></li><li class="li"><p>Avoid assigning 64-bit pointers to 32-bit integers.</p></li><li class="li"><p>Fix alignment issues caused by changes in data type sizes.</p></li><li class="li"><p>Avoid pointer and <code>long</code> integer truncation during arithmetic operations.</p></li></ul>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-SW7">General Programming Tips</a>
				
			<br/>
			
        
			
			
				<a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_12">Data Type and Alignment Tips</a>
				
			<br/>
			
        
			
			
				<a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-SW1">Avoiding Pointer-to-Integer Conversion</a>
				
			<br/>
			
        
			
			
				<a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_13">Working with Bits and Bitmasks</a>
				
			<br/>
			
        
			
			
				<a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_14">Tools Tips</a>
				
			<br/>
			
        
			
			
				<a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-SW3">Alignment Pragmas</a>
				
			<br/>
			
        
			
			
				<a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-CHDFEBJD">Sign Extension Rules for C and C-derived Languages</a>
				
			<br/>
			
        
			
			
				<a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_15">Velocity Engine and SSE Alignment Tips</a>
				
			<br/>
			
        
			
			
				<a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-CACJEBAC">Porting Assembly Language Code</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001064-CH226-SW7" title="General Programming Tips"></a><h2>General Programming Tips</h2><p>This section contains some general tips for making your code 64-bit clean.</p><p><strong>Update architecture-specific code.</strong> If your application contains architecture-specific code, you must either add extra code for each additional architecture or modify your preprocessor directives so that the same code is included for both architectures. For example, code wrapped in an <code>#ifdef __ppc__</code> directive will not be included when compiling for the <code>ppc64</code> architecture. For an example, see <span class="content_text">Listing 3-1</span>.</p><a name="//apple_ref/doc/uid/TP40001064-CH226-SW4" title="Listing 3-1Architecture definition changes"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>Architecture definition changes</p><div class="codesample"><table><tr><td scope="row"><pre>#ifdef __ppc__<span></span></pre></td></tr><tr><td scope="row"><pre>// 32-bit PowerPC code<span></span></pre></td></tr><tr><td scope="row"><pre>#else<span></span></pre></td></tr><tr><td scope="row"><pre>#ifdef __ppc64__<span></span></pre></td></tr><tr><td scope="row"><pre>// 64-bit PowerPC code<span></span></pre></td></tr><tr><td scope="row"><pre>#else<span></span></pre></td></tr><tr><td scope="row"><pre>#if defined(__i386__) || defined(__x86_64__)<span></span></pre></td></tr><tr><td scope="row"><pre>// 32-bit or 64-bit Intel code<span></span></pre></td></tr><tr><td scope="row"><pre>#else<span></span></pre></td></tr><tr><td scope="row"><pre>#error UNKNOWN ARCHITECTURE<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr></table></div><p>Code that looks for only the <code>__ppc__</code> definition will break.</p><p>The macro <code>__LP64__</code> can be used to test for LP64 compilation in an architecture-independent way. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>#ifdef __LP64__<span></span></pre></td></tr><tr><td scope="row"><pre>// 64-bit code<span></span></pre></td></tr><tr><td scope="row"><pre>#else<span></span></pre></td></tr><tr><td scope="row"><pre>// 32-bit code<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr></table></div><p><strong>Avoid casting pointers to nonpointers.</strong> You should generally avoid casting a pointer to a nonpointer type for any reason (particularly when performing address arithmetic). Alternatives are described in <span class="content_text"><a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-SW1">“Avoiding Pointer-to-Integer Conversion.”</a></span></p><p><strong>Update assembly code.</strong> Any PowerPC assembly code needs to be checked because some instructions behave differently in 64-bit mode. Any Intel assembly code needs to be rewritten because 64-bit Intel assembly language is significantly different from its 32-bit counterpart. For more information, see <span class="content_text"><a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-CACJEBAC">“Porting Assembly Language Code.”</a></span></p><p>Any assembly code that directly deals with the structure of the stack (as opposed to simply using pointers to variables on the stack) must be modified to work in a 64-bit environment. For more information, see <em><a href="../../../../DeveloperTools/Conceptual/MachORuntime/index.html#//apple_ref/doc/uid/TP40000895" target="_top">Mac OS X ABI Mach-O File Format Reference</a></em>.</p><p><strong>Fix format strings.</strong> Print functions such as <code><!--a-->printf<!--/a--></code> can be tricky when writing code to support 32-bit and 64-bit platforms because of the change in the sizes of pointers. To solve this problem for pointer-sized integers (<code>uintptr_t</code>) and other standard types, various macros exist in the <code>inttypes.h</code> header file.</p><p>The format strings for various data types are described in <span class="content_text">Table 3-1</span>. These additional types, listed in the <code>inttypes.h</code> header file, are described in <span class="content_text">Table 3-2</span>.</p><a name="//apple_ref/doc/uid/TP40001064-CH226-TPXREF113" title="Table 3-1Standard format strings"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-1&nbsp;&nbsp;</strong>Standard format strings</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Format string</p></th></tr><tr><td  scope="row"><p><code>int</code></p></td><td ><p><code>%d</code></p></td></tr><tr><td  scope="row"><p><code>long</code></p></td><td ><p><code>%ld</code></p></td></tr><tr><td  scope="row"><p><code>long long</code></p></td><td ><p><code>%lld</code></p></td></tr><tr><td  scope="row"><p><code>size_t</code></p></td><td ><p><code>%zu</code></p></td></tr><tr><td  scope="row"><p><code>ptrdiff_t</code></p></td><td ><p><code>%td</code></p></td></tr><tr><td  scope="row"><p>any pointer</p></td><td ><p><code>%p</code></p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001064-CH226-TPXREF114" title="Table 3-2Additional inttypes.h format strings (where N is some number)"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-2&nbsp;&nbsp;</strong>Additional <code>inttypes.h</code> format strings (where <em>N</em> is some number)</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Format string</p></th></tr><tr><td  scope="row"><p><code>int<em>N</em>_t</code> (such as <code>int32_t</code>)</p></td><td ><p><code>PRId<em>N</em></code></p></td></tr><tr><td  scope="row"><p><code>uint<em>N</em>_t</code></p></td><td ><p><code>PRIu<em>N</em></code></p></td></tr><tr><td  scope="row"><p><code>int_least<em>N</em>_t</code></p></td><td ><p><code>PRIdLEAST<em>N</em></code></p></td></tr><tr><td  scope="row"><p><code>uint_least<em>N</em>_t</code></p></td><td ><p><code>PRIuLEAST<em>N</em></code></p></td></tr><tr><td  scope="row"><p><code>int_fast<em>N</em>_t</code></p></td><td ><p><code>PRIdFAST<em>N</em></code></p></td></tr><tr><td  scope="row"><p><code>uint_fast<em>N</em>_t</code></p></td><td ><p><code>PRIuFAST<em>N</em></code></p></td></tr><tr><td  scope="row"><p><code>intptr_t</code></p></td><td ><p><code>PRIdPTR</code></p></td></tr><tr><td  scope="row"><p><code>uintptr_t</code></p></td><td ><p><code>PRIuPTR</code></p></td></tr><tr><td  scope="row"><p><code>intmax_t</code></p></td><td ><p><code>PRIdMAX</code></p></td></tr><tr><td  scope="row"><p><code>uintmax_t</code></p></td><td ><p><code>PRIuMAX</code></p></td></tr></table></div><p>For example, to print an <code>intptr_t</code> variable (a pointer-sized integer) and a pointer, you write code similar to that in <span class="content_text">Listing 3-2</span>.</p><a name="//apple_ref/doc/uid/TP40001064-CH226-TPXREF112" title="Listing 3-2Architecture-independent printing"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>Architecture-independent printing</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;inttypes.h><span></span></pre></td></tr><tr><td scope="row"><pre>void *foo;<span></span></pre></td></tr><tr><td scope="row"><pre>intptr_t k = (intptr_t) foo;<span></span></pre></td></tr><tr><td scope="row"><pre>void *ptr = &amp;k;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>printf("The value of k is %" PRIdPTR "\n", k);<span></span></pre></td></tr><tr><td scope="row"><pre>printf("The value of ptr is %p\n", ptr);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_12" title="Data Type and Alignment Tips"></a><h2>Data Type and Alignment Tips</h2><p>Here are a few tips to help you avoid problems stemming from changes to data type size and alignment.</p><p><strong>Be careful when mixing integers and long integers.</strong> The size and alignment of <code>long</code> integers and pointers have changed from 32-bit to 64-bit. For the most part, if you always use the <code><!--a-->sizeof<!--/a--></code> function when allocating data structures, the size and alignment of pointers should not affect your code, because structures containing pointer members are generally not written to disk or sent across networks between 32-bit and 64-bit applications.</p><p>However, if you frequently move data between variables of type <code>int</code> and <code>long</code>, the change in the size of <code>long</code> can cause problems. You will see various related problems throughout this section.</p><p><strong>Use pragmas to control alignment of shared data.</strong> The alignment of <code>long long</code> (64-bit) integers has changed from 32-bit to 64-bit. This alignment change can pose a problem when you are exchanging data between 32-bit and 64-bit applications.</p><p>In <span class="content_text">Listing 3-3</span>, the alignment changes even though the data types are the same size.</p><a name="//apple_ref/doc/uid/TP40001064-CH226-TPXREF107" title="Listing 3-3Alignment of long long in structures"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>Alignment of <code>long long</code> in structures</p><div class="codesample"><table><tr><td scope="row"><pre>struct bar {<span></span></pre></td></tr><tr><td scope="row"><pre>    int foo0;<span></span></pre></td></tr><tr><td scope="row"><pre>    int foo1;<span></span></pre></td></tr><tr><td scope="row"><pre>    int foo2;<span></span></pre></td></tr><tr><td scope="row"><pre>    long long bar;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>When this code is compiled with a 32-bit compiler, the variable <code>bar</code> begins 12 bytes from the start of the structure. When the same code is compiled with a 64-bit compiler, the variable <code>bar</code> begins 16 bytes from the start of the structure, and a 4-byte pad is added after <code>foo2</code>.</p><p>To allow a single data structure to be shared, you can use a pragma to force power alignment mode (PowerPC only) or packed alignment mode for each structure, as needed. Then add appropriate pad bytes (if necessary) to obtain the desired alignment. An example is show in <span class="content_text">Listing 3-4</span>.</p><a name="//apple_ref/doc/uid/TP40001064-CH226-TPXREF108" title="Listing 3-4Using pragmas to control alignment"></a><p class="codesample"><strong>Listing 3-4&nbsp;&nbsp;</strong>Using pragmas to control alignment</p><div class="codesample"><table><tr><td scope="row"><pre>struct bar {<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma pack(4)<span></span></pre></td></tr><tr><td scope="row"><pre>    int foo0;<span></span></pre></td></tr><tr><td scope="row"><pre>    int foo1;<span></span></pre></td></tr><tr><td scope="row"><pre>    int foo2;<span></span></pre></td></tr><tr><td scope="row"><pre>    long long bar;<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma options align=reset<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>You should use this option only when absolutely necessary, because there is a performance penalty for misaligned accesses.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_29" title="Note"></a><p><strong>Note:</strong>&nbsp;If your code already explicitly uses <code>#pragma options align=power</code>, you should generally use <code>#pragma pack(4)</code> instead.</p></div><p><strong>Use sizeof with malloc.</strong> Since pointers and long integers are no longer 4 bytes long, never call <code><!--a-->malloc<!--/a--></code> with an explicit size (for example, <code><a href="../../../Reference/ManPages/man3/malloc.3.html#//apple_ref/doc/man/3/malloc" target="_top">malloc(3)</a></code>) to allocate space for them. Always use <code>sizeof</code> to obtain the correct size.</p><p>Never assume you know the size of any structure (containing a pointer or otherwise); always use <code><!--a-->sizeof<!--/a--></code> to find out for sure. To avoid future portability problems, search your code for any instance of <code><!--a-->malloc<!--/a--></code> that isn't followed by <code><!--a-->sizeof<!--/a--></code>. The <code><a href="../../../Reference/ManPages/man1/grep.1.html#//apple_ref/doc/man/1/grep" target="_top">grep(1)</a></code> command and regular expressions are your friend, though using Find in the Xcode Find menu can do the job.</p><p><strong>64-bit sizeof returns size_t.</strong> Note that <code><!--a-->sizeof<!--/a--></code> returns an integer of type <code>size_t</code>. Because the size of <code>size_t</code> has changed to 64 bits, do not pass the value to a function in a parameter of size <code>int</code> (unless you are certain that the size cannot be that large). If you do, truncation will occur.</p><p><strong>Use explicit types.</strong> You should use explicit types where possible. For example, types with names like <code>int32_t</code> and <code>uint32_t</code> will always be a 32-bit quantity, regardless of future architectural changes.</p><p><strong>Watch for conversion errors.</strong> Conversion of shorter types to 64-bit longs may yield unexpected results in certain cases. Be sure to read <span class="content_text"><a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-CHDFEBJD">“Sign Extension Rules for C and C-derived Languages”</a></span> if you are seeing unexpected values from math that mixes <code>int</code> and <code>long</code> variables.</p><p><strong>Use 64-bit types for pointer arithmetic results.</strong> Because the size of pointers is a 64-bit value, the result of pointer arithmetic is also a 64-bit value. You should always store these values in a variable of type <code>ptrdiff_t</code> to ensure that the variable is sized appropriately.</p><p><strong>Avoid truncating file positions and offsets.</strong> Although file operations have always used 64-bit positions and offsets, you should still check for errors in their use. Errors will become more and more important as common file sizes grow. Use <code>fpos_t</code> for file position and <code>off_t</code> for file offset.</p><p><strong>Be careful with variable argument lists.</strong> Variable argument list parameters (<code>varargs</code>) are promoted to integers of type <code>int</code>. If your code does not distinguish between <code>int</code> and <code>long</code> values, you will get incorrect results.</p><p>In particular, if your <code>varargs</code> function always uses the <code>long</code> type, any values that are not 64-bit values will contain garbage data in the upper half (and you may lose the next argument). Likewise, if your <code>varargs</code> function always uses the <code>int</code> type, you will get only part of the data (and the rest may incorrectly appear in the argument that follows).</p><p>For example, if you use incorrect <code><a href="../../../Reference/ManPages/man3/printf.3.html#//apple_ref/doc/man/3/printf" target="_top">printf(3)</a></code> format strings, you will get incorrect behavior. Some examples of these format string mistakes are shown in <span class="content_text"><a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-SW7">“General Programming Tips.”</a></span></p><a name="//apple_ref/doc/uid/TP40001064-CH226-SW1" title="Avoiding Pointer-to-Integer Conversion"></a><h2>Avoiding Pointer-to-Integer Conversion</h2><p>You should generally avoid casting a pointer to a nonpointer type for any reason. If possible, rewrite any code that uses these casts, either by changing the data types or by replacing address arithmetic with pointer arithmetic. For example, the following code:</p><div class="codesample"><table><tr><td scope="row"><pre>int *c = something passed in as an argument....<span></span></pre></td></tr><tr><td scope="row"><pre>int *d = (int *)((int)c + 4); // This code is WRONG!<span></span></pre></td></tr></table></div><p>results in pointer truncation. Because the resulting value would be correct for sufficiently small pointers, these bugs can be difficult to find. Instead, this code can be replaced with:</p><div class="codesample"><table><tr><td scope="row"><pre>int *c = something passed in as an argument....<span></span></pre></td></tr><tr><td scope="row"><pre>int *d = c + 1;<span></span></pre></td></tr></table></div><p>(Of course, this example is somewhat contrived, and such use of pointers is relatively uncommon.)</p><p>A more common problem is storing a pointer temporarily in a variable of type <code>int</code>. In most cases, the compiler will warn you that a pointer is being assigned to an integer of a different size. However, in a few cases, code containing such an assignment will compile without warning. For example, if the code stores the values in a variable of type <code>long</code> and then later copies it to an integer, the pointer itself is not <em>directly</em> truncated, so the compiler may not generate a warning. These problems are particularly hard to spot.</p><p>Finally, a common problem is the need to offset a pointer by a specific number of bytes. Instead of casting to an integer and using integer math, you should cast the pointer to a byte-width pointer type such as <code>char *</code> or <code>uint8_t *</code>. After you do this, the pointer will behave like an integer for arithmetic purposes. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>int *myptr = getPointerFromSomewhere();<span></span></pre></td></tr><tr><td scope="row"><pre>int *shiftbytwobytes = (int *)(((int)myptr) + 2);<span></span></pre></td></tr></table></div><p>can be rewritten as:</p><div class="codesample"><table><tr><td scope="row"><pre>int *myptr = getPointerFromSomewhere();<span></span></pre></td></tr><tr><td scope="row"><pre>int *shiftbytwobytes = (int *)(((char *)myptr) + 2);<span></span></pre></td></tr></table></div><p>By avoiding assignment of pointers to any nonpointer type, you avoid almost all pointer-related problems, because pointers are rarely stored or exchanged between 32-bit and 64-bit processes. In a few situations, however, there may be no easy way to avoid address-to-integer conversions. The <code>uintptr_t</code> type exists for these edge cases.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_30" title="Note"></a><p><strong>Note:</strong>&nbsp;Casting 64-bit pointers to integer types is also required when passing a pointer via a Mach port. In these cases, use the <code>caddr_t</code> type.</p></div><a name="//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_13" title="Working with Bits and Bitmasks"></a><h2>Working with Bits and Bitmasks</h2><p>When working with bits and masks with 64-bit values, you must be careful to avoid getting 32-bit values inadvertently. Here are some tips to help you:</p><p><strong>Shift carefully.</strong> If you are shifting through the bits stored in a variable of type <code>long</code>, don’t assume that the variable is of a particular length. Instead, use the value <code>LONG_BIT</code> to determine the number of bits in a <code>long</code>. The result of a shift that exceeds the length of a variable is architecture-dependent.</p><p><strong>Use inverted masks if needed.</strong> Be careful when using bit masks with variables of type <code>long</code>, because the width differs between 32-bit and 64-bit architectures. There are two ways to create a mask, depending on whether you want the mask to be zero-extended or one-extended:</p><ul class="ul"><li class="li"><p>If you want the mask value to contain zeros in the upper 32 bits on a 64-bit architecture, the usual fixed-width mask will work as expected, because it will be extended in an unsigned fashion to a 64-bit quantity.</p></li><li class="li"><p>If you want the mask value to contain ones in the upper bits, however, you should write the mask as the bitwise inverse of its inverse, as shown in <span class="content_text">Listing 3-5</span>.</p></li></ul><a name="//apple_ref/doc/uid/TP40001064-CH226-TPXREF111" title="Listing 3-5Using an inverted mask for sign extension"></a><p class="codesample"><strong>Listing 3-5&nbsp;&nbsp;</strong>Using an inverted mask for sign extension</p><div class="codesample"><table><tr><td scope="row"><pre>function_name(long value)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    long mask = ~0x3; // 0xfffffffc or 0xfffffffffffffffc<span></span></pre></td></tr><tr><td scope="row"><pre>    return (value &amp; mask);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In the code, note that the upper bits in the mask are filled with ones in the 64-bit case.</p><a name="//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_14" title="Tools Tips"></a><h2>Tools Tips</h2><p>Here are some tips to help you use the compiler more effectively in transitioning your application to 64-bit:</p><ul class="ul"><li class="li"><p>If data is being inadvertently truncated, to help you find the source, try turning on additional compiler warnings.</p></li><li class="li"><p>In 64-bit-capable versions of GCC (4.0 and later), the size of a <code>long double</code> will be 128 bits instead of 64 bits. This change is not limited to code compiled as a 64-bit executable, but it is a toolchain change you should be aware of.</p></li></ul><p>You can find detailed tips and information about 64-bit tools changes in <span class="content_text"><a href="../building/building.html#//apple_ref/doc/uid/TP40001064-CH208-TPXREF101">“Compiling 64-Bit Code.”</a></span></p><a name="//apple_ref/doc/uid/TP40001064-CH226-SW3" title="Alignment Pragmas"></a><h2>Alignment Pragmas</h2><p>Occasionally, developers use alignment pragmas to change the way that data structures are laid out in memory. They usually do this for backward compatibility. In many cases, Apple added pragmas to maintain data structure compatibility between 68K-based and PowerPC-based code running on the same machine under Mac OS 9 and earlier. Mac OS X retained these alignment overrides to maintain binary compatibility with existing Carbon data structures between Mac OS 9 and Mac OS X.</p><p>There is a performance cost associated with pragmas, however; memory accesses to unaligned data fields result in a performance penalty. Because there are no existing 64-bit Mac OS X GUI applications with which to be compatible, it is not necessary to preserve binary compatibility for these data structures in 64-bit applications. Thus, to improve overall performance, when compiling 64-bit executables, the Mac OS X version of GCC ignores requests for <code>mac68k</code> alignment.</p><p>If you are using this pragma only to access Apple data structures, you should not need to make any code changes to your code. When compiling 64-bit code, the compiler will ignore the pragmas and your code will work correctly. If, however, you currently use the <code>mac68k</code> alignment pragma in your own data structures that will be shared between 32-bit and 64-bit versions of your application, you must rewrite the data structure to use a packed alignment and pad the structure appropriately.</p><p>With the exception of Altivec data types, the following code is equivalent to <code>mac68k</code> alignment:</p><div class="codesample"><table><tr><td scope="row"><pre>#pragma pack(2)<span></span></pre></td></tr><tr><td scope="row"><pre>...structure declaration goes here...<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma options align=reset<span></span></pre></td></tr></table></div><p>Similarly, with the exception of Altivec data types, the following code is equivalent to the standard 32-bit PowerPC and Intel alignment (known on PowerPC as embedded power alignment):</p><div class="codesample"><table><tr><td scope="row"><pre>#pragma pack(4)<span></span></pre></td></tr><tr><td scope="row"><pre>...structure declaration goes here...<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma options align=reset<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001064-CH226-CHDFEBJD" title="Sign Extension Rules for C and C-derived Languages"></a><h2>Sign Extension Rules for C and C-derived Languages</h2><p>C and similar languages use a set of sign extension rules to determine whether to treat the top bit in an integer as a sign bit when the value is assigned to a variable of larger width. The sign extension rules are as follows:</p><ol class="ol"><li class="li"><p>The sum of a signed value and an unsigned value of the same size is an unsigned value.</p></li><li class="li"><p>Any promotion always results in a signed type unless a signed type cannot hold all values of the original type (that is, unless the resulting type is the same size as the original type).</p></li><li class="li"><p>Unsigned values are zero extended (not sign extended) when promoted to a larger type.</p></li><li class="li"><p>Signed values are always sign extended when promoted to a larger type, even if the resulting type is unsigned.</p></li><li class="li"><p>Constants (unless modified by a suffix, such as <code>0x8L</code>) are treated as the smallest size that will hold the value. Numbers written in hexadecimal may be treated by the compiler as <code>signed</code> and <code>unsigned </code> <code>int</code>, <code>long</code>, and <code>long long</code> types. Decimal numbers will always be treated as <code>signed</code> types.</p></li></ol><p><span class="content_text">Listing 3-6</span> shows an example of unexpected behavior resulting from these rules along with an accompanying explanation.</p><a name="//apple_ref/doc/uid/TP40001064-CH226-TPXREF109" title="Listing 3-6Sign extension example 1"></a><p class="codesample"><strong>Listing 3-6&nbsp;&nbsp;</strong>Sign extension example 1</p><div class="codesample"><table><tr><td scope="row"><pre>int a=-2;<span></span></pre></td></tr><tr><td scope="row"><pre>unsigned int b=1;<span></span></pre></td></tr><tr><td scope="row"><pre>long c = a + b;<span></span></pre></td></tr><tr><td scope="row"><pre>long long d=c; // to get a consistent size for printing.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>printf("%lld\n", d);<span></span></pre></td></tr></table></div><p><strong>Problem:</strong> When this code is executed on a 32-bit architecture, the result is <code>-1</code> (<code>0xffffffff</code>). When the code is run on a 64-bit architecture, the result is <code>4294967295</code> (<code>0x00000000ffffffff</code>), which is probably not what you were expecting.</p><p><strong>Cause:</strong> Why does this happen? First, the two numbers are added. A signed value plus an unsigned value results in an unsigned value <strong>(rule 1)</strong>. Next, that value is promoted to a larger type. This promotion does not cause sign extension <strong>(rule 2)</strong>.</p><p><strong>Solution:</strong> To fix this problem in a 32-bit-compatible way, cast <code>b</code> to <code>long</code>. This cast forces the non-sign-extended promotion of <code>b</code> to a 64-bit type prior to the addition, thus forcing the signed integer to be promoted (in a signed fashion) to match. With that change, the result is the expected <code>-1</code>.</p><p><span class="content_text">Listing 3-7</span> shows a related example with an accompanying explanation.</p><a name="//apple_ref/doc/uid/TP40001064-CH226-TPXREF110" title="Listing 3-7Sign extension example 2"></a><p class="codesample"><strong>Listing 3-7&nbsp;&nbsp;</strong>Sign extension example 2</p><div class="codesample"><table><tr><td scope="row"><pre>unsigned short a=1;<span></span></pre></td></tr><tr><td scope="row"><pre>unsigned long b = (a &lt;&lt; 31);<span></span></pre></td></tr><tr><td scope="row"><pre>unsigned long long c=b;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>printf("%llx\n", c);<span></span></pre></td></tr></table></div><p><strong>Problem:</strong> The expected result (and the result from a 32-bit executable) is <code>0x80000000</code>. The result generated by a 64-bit executable, however, is <code>0xffffffff80000000</code>.</p><p><strong>Cause:</strong> Why is this sign extended? First, when the shift operator is invoked, the variable <code>a</code> is promoted to a variable of type <code>int</code>. Because all values of a <code>short</code> can fit into a signed <code>int</code>, the result of this promotion is signed <strong>(rule 3)</strong>.</p><p>Second when the shift completed, the result was stored into a <code>long</code>. Thus, the 32-bit signed value represented by <code>(a &lt;&lt; 31)</code> was sign extended <strong>(rule 4)</strong> when it was promoted to a 64-bit value (even though the resulting type is unsigned).</p><p><strong>Solution:</strong> To fix this problem, you should cast the initial value to a <code>long</code> prior to the shift. Thus, the short will be promoted only once—this time, to a 64-bit type (at least when compiled as a 64-bit executable).</p><a name="//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_15" title="Velocity Engine and SSE Alignment Tips"></a><h2>Velocity Engine and SSE Alignment Tips</h2><p>Although the SSE and Velocity Engine C and assembly language interfaces have not changed for 64-bit, if you are using these technologies, you should review any code that attempts to align pointers to 16-byte addresses for processing.</p><p>For example, the following code contains two errors:</p><div class="codesample"><table><tr><td scope="row"><pre>TYPE *aligned = (TYPE *) ((int) misalignedPtr &amp; 0xFFFFFFF0); // BAD!<span></span></pre></td></tr></table></div><p>First, the pointer is cast to an <code>int</code> value, which results in truncation. Even after this problem is fixed, however, the pointer will still be truncated because the constant value <code>0xFFFFFFF0</code> is not a 64-bit value.</p><p>Instead, this code should be written as:</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;stdint.h><span></span></pre></td></tr><tr><td scope="row"><pre>TYPE *aligned = (TYPE *) ((intptr_t) misalignedPtr &amp; ~(intptr_t)0xF);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001064-CH226-CACJEBAC" title="Porting Assembly Language Code"></a><h2>Porting Assembly Language Code</h2><p>This section describes some of the issues involved in porting assembly language code to a 64-bit application. On the Intel architecture, in addition to the issues described in this section, you must considerably modify any assembly language code that deals with the stack directly, because the 64-bit ABI differs significantly from the 32-bit ABI. The subject of stack frames is beyond the scope of this section. For more information, see <em><a href="../../../../DeveloperTools/Conceptual/MachORuntime/index.html#//apple_ref/doc/uid/TP40000895" target="_top">Mac OS X ABI Mach-O File Format Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_16" title="Porting PowerPC Assembly Language Code to 64-Bit"></a><h3>Porting PowerPC Assembly Language Code to 64-Bit</h3><p>The include file <code>&lt;architecture/ppc/mode_independent_asm.h></code> contains a number of useful pseudo-mnemonics and macros to make it easier for you to write assembly language code that can be built in 32-bit or 64-bit mode.</p><p>Record form ("."), overflow form ("o"), and extended form ("e") instructions all behave differently in 64-bit mode. Specifically, they test and set condition bits on the 64-bit result, not the 32-bit result. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>lis     r4,0x4000<span></span></pre></td></tr><tr><td scope="row"><pre>add.    r5,r5,r5<span></span></pre></td></tr><tr><td scope="row"><pre>blt     xxx<span></span></pre></td></tr></table></div><p>In 32-bit mode, the add instruction sets <code>cr0_lt</code>, and so the branch is taken. In 64-bit mode, the branch is not taken.</p><p>All word-compare, shift, load, and store instructions must be carefully considered. Many need to be changed to use the corresponding 64-bit opcode. For example, this 32-bit code:</p><div class="codesample"><table><tr><td scope="row"><pre>lwz     r5,0(r3)    // load an address<span></span></pre></td></tr><tr><td scope="row"><pre>rlwinm  r5,r5,0,0,29// word align<span></span></pre></td></tr><tr><td scope="row"><pre>cmplwi  r5,0        // null?<span></span></pre></td></tr></table></div><p>should be rewritten as:</p><div class="codesample"><table><tr><td scope="row"><pre>ld      r5,0(r3)    // load an address<span></span></pre></td></tr><tr><td scope="row"><pre>rldicr  r5,r5,0,0,60// doubleword align<span></span></pre></td></tr><tr><td scope="row"><pre>cmpldi  r5,0        // null?<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_17" title="Porting Intel Assembly Language Code to 64-Bit"></a><h3>Porting Intel Assembly Language Code to 64-Bit</h3><p>On Intel-based Macintosh computers, 64-bit code uses the Intel 64 (formerly EM64T) extensions to the Intel assembly language ISA. This section summarizes the differences between Intel 64 code and IA32 code in terms of their impact on registers and instruction sets.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_31" title="Note"></a><p><strong>Note:</strong>&nbsp;The Itanium architecture is sometimes called IA64, short for Intel Architecture 64. Despite their similar names, the Intel 64 Architecture is not related to the Itanium (IA64) architecture.</p></div><a name="//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_18" title="Register Changes"></a><h4>Register Changes</h4><p>The 64-bit registers on Intel have different names than their 32-bit counterparts do. In addition, there are more of them. These register names are listed in <span class="content_text">Table 3-3</span>.</p><a name="//apple_ref/doc/uid/TP40001064-CH226-SW5" title="Table 3-3Register naming on 32-bit and 64-bit Intel architectures"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-3&nbsp;&nbsp;</strong>Register naming on 32-bit and 64-bit Intel architectures</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>IA32 32-bit register</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Intel 64 Architecture 64-bit variant</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>EIP</code></p></td><td ><p><code>RIP</code></p></td><td ><p>Instruction Pointer</p></td></tr><tr><td  scope="row"><p><code>EAX</code></p></td><td ><p><code>RAX</code></p></td><td ><p>General Purpose Register A</p></td></tr><tr><td  scope="row"><p><code>EBX</code></p></td><td ><p><code>RBX</code></p></td><td ><p>General Purpose Register B</p></td></tr><tr><td  scope="row"><p><code>ECX</code></p></td><td ><p><code>RCX</code></p></td><td ><p>General Purpose Register C</p></td></tr><tr><td  scope="row"><p><code>EDX</code></p></td><td ><p><code>RDX</code></p></td><td ><p>General Purpose Register D</p></td></tr><tr><td  scope="row"><p><code>ESP</code></p></td><td ><p><code>RSP</code></p></td><td ><p>Stack Pointer</p></td></tr><tr><td  scope="row"><p><code>EBP</code></p></td><td ><p><code>RBP</code></p></td><td ><p>Frame Pointer</p></td></tr><tr><td  scope="row"><p><code>ESI</code></p></td><td ><p><code>RSI</code></p></td><td ><p>Source Index Register</p></td></tr><tr><td  scope="row"><p><code>EDI</code></p></td><td ><p><code>RDI</code></p></td><td ><p>Destination Index Register</p></td></tr><tr><td  scope="row"><p>----</p></td><td ><p><code>R8</code> *</p></td><td ><p>Register 8 (new)</p></td></tr><tr><td  scope="row"><p>----</p></td><td ><p><code>R9</code> *</p></td><td ><p>Register 9 (new)</p></td></tr><tr><td  scope="row"><p>----</p></td><td ><p><code>R10</code> *</p></td><td ><p>Register 10 (new)</p></td></tr><tr><td  scope="row"><p>----</p></td><td ><p><code>R11</code> *</p></td><td ><p>Register 11 (new)</p></td></tr><tr><td  scope="row"><p>----</p></td><td ><p><code>R12</code> *</p></td><td ><p>Register 12 (new)</p></td></tr><tr><td  scope="row"><p>----</p></td><td ><p><code>R13</code> *</p></td><td ><p>Register 13 (new)</p></td></tr><tr><td  scope="row"><p>----</p></td><td ><p><code>R14</code> *</p></td><td ><p>Register 14 (new)</p></td></tr><tr><td  scope="row"><p>----</p></td><td ><p><code>R15</code> *</p></td><td ><p>Register 15 (new)</p></td></tr></table></div><p>All of the new registers (<code>R8</code> through<code>R15</code>) added in the Intel 64 Architecture instruction set can also be accessed as 32-bit, 16-bit, and 8-bit registers. For example, register <code>R8</code> can be addressed in the following ways:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Register name</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>R8</code></p></td><td ><p>A 64-bit register.</p></td></tr><tr><td  scope="row"><p><code>R8d</code></p></td><td ><p>A 32-bit register containing the bottom half of <code>R8</code>.</p></td></tr><tr><td  scope="row"><p><code>R8w</code></p></td><td ><p>A 16-bit register containing the bottom half of <code>R8d</code>.</p></td></tr><tr><td  scope="row"><p><code>R8l</code> (Lowercase “l”)</p></td><td ><p>An 8-bit register containing the bottom half of <code>R8w</code>.</p></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_32" title="Note"></a><p><strong>Note:</strong>&nbsp;When you assign a value to the 32-bit version of these registers, the value is automatically zero extended to fill the corresponding 64-bit register. To sign extend during assignment, use the <code>movsx</code> instruction instead.</p></div><p>In addition to adding general-purpose registers, the Intel 64 Architecture instruction set has eight additional vector registers. In the IA32 instruction set, the vector registers are numbered <code>XMM0</code> through <code>XMM7</code>. The Intel 64 Architecture instruction set extends this by adding <code>XMM8</code> through <code>XMM15</code>.</p><a name="//apple_ref/doc/uid/TP40001064-CH226-DontLinkElementID_19" title="Instruction Changes"></a><h4>Instruction Changes</h4><p>Most IA32 instructions can take 64-bit arguments. All IA32 instruction set extensions up through SSE3 are included as part of the Intel 64 Architecture. In addition, a number of new instructions have been added.</p><p>A complete list of these changes is beyond the scope of this document. For information on these changes, see the links in <span class="content_text"><a href="MakingCode64-BitClean.html#//apple_ref/doc/uid/TP40001064-CH226-SW6">“For More Information.”</a></span></p><a name="//apple_ref/doc/uid/TP40001064-CH226-SW6" title="For More Information"></a><h4>For More Information</h4><p>For more information on porting and optimizing Intel assembly language code for 64-bit, you should also read:</p><ul class="spaceabove"><li class="li"><p><em><a href="../../../../DeveloperTools/Conceptual/MachORuntime/index.html#//apple_ref/doc/uid/TP40000895" target="_top">Mac OS X ABI Mach-O File Format Reference</a></em>—ABI documentation for Mac OS X.</p></li><li class="li"><p><span class="content_text"><a href="http://developer.intel.com/technology/architecture-silicon/intel64/index.htm" target="_blank">http://developer.intel.com/technology/architecture-silicon/intel64/index.htm</a></span>—Intel 64 Architecture technology page (Intel).</p></li><li class="li"><p><span class="content_text"><a href="http://www.intel.com:80/cd/ids/developer/asmo-na/eng/dc/64bit/index.htm" target="_blank">http://www.intel.com:80/cd/ids/developer/asmo-na/eng/dc/64bit/index.htm</a></span>—Intel 64 Architecture developer documentation site (Intel).</p></li><li class="li"><p><span class="content_text"><a href="http://www.intel.com/cd/ids/developer/asmo-na/eng/technologies/64bit/170114.htm" target="_blank">http://www.intel.com/cd/ids/developer/asmo-na/eng/technologies/64bit/170114.htm</a></span>—Porting to 64-bit Intel architecture (Intel).</p></li><li class="li"><p><span class="content_text"><a href="http://www.intel.com/cd/ids/developer/asmo-na/eng/dc/enterprise/254740.htm?page=1" target="_blank">http://www.intel.com/cd/ids/developer/asmo-na/eng/dc/enterprise/254740.htm?page=1</a></span>—Information about 64-bit optimization. Note that the ABI information at this location is Windows oriented, so those portions do not apply.</p></li><li class="li"><p><span class="content_text"><a href="http://www.x86-64.org/documentation/assembly.html" target="_blank">http://www.x86-64.org/documentation/assembly.html</a></span>—General information on 64-bit Intel assembly (x86-64.org).</p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../transition/transition.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../building/building.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-04-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Conceptual/64bitPorting/MakingCode64-BitClean/MakingCode64-BitClean.html%3Fid%3DTP40001064-3.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Conceptual/64bitPorting/MakingCode64-BitClean/MakingCode64-BitClean.html%3Fid%3DTP40001064-3.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Conceptual/64bitPorting/MakingCode64-BitClean/MakingCode64-BitClean.html%3Fid%3DTP40001064-3.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>