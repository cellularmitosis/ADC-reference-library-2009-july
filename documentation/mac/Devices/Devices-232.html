<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the Power Manager(IM: D)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING232></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="Devices-231.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-233.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Devices-2.html"><B>Devices</B></A> / <BR><DD><A HREF="Devices-230.html"><B>Chapter 6 - Power Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING232-0></A>
<H1><A NAME=MARKER-9-101></A>Using the Power Manager</H1>
 You can use the Power Manager to install a sleep procedure that is executed when power to internal devices is about to be shut off or after power has just been restored. Most applications or other software components that are sensitive to the power-consumption state of the computer can use sleep procedures to perform any necessary processing at those times. See <A HREF=#MARKER-9-135>"Writing a Sleep Procedure," beginning on page 6-20</A>, and <A HREF=#MARKER-9-125>"Installing a Sleep Procedure," beginning on page 6-18</A>, for complete details on how to write and install sleep procedures.<P>
 The Power Manager provides routines that you can use to monitor the state of the battery charge and the status of the battery charger. See <A HREF=#MARKER-9-163>"Monitoring the Battery and Battery Charger," beginning on page 6-26</A>, for details. In all likelihood, only utility programs will need to use these routines.<P>
 If you are writing an application that is sensitive to the clock speed of the computer, you can use the Power Manager to disable the CPU idle state when necessary.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Do not disable the idle state except when executing a routine that must run at full speed. Disabling the idle state shortens the amount of time the user can operate the computer from a battery.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-102></A>If you want to ensure that a portable Macintosh computer is in the operating state at a particular time in the future, you can use the <CODE>SetWUTime</CODE> function to set the wakeup timer. You can use the wakeup timer in conjunction with the Time Manager, for example, when you want to use the computer to perform tasks that must be done at a specific time, like printing a large file in the middle of the night.<P>
 If you are writing a device driver for a portable Macintosh computer, you might need to use the Power Manager to control power to the subsystem that your driver controls. See <A HREF=#MARKER-9-151>"Switching Serial Power On and Off," on page 6-25</A>, for a discussion of power control for the serial communications subsystem. For power control for other devices, consult Apple Developer Technical Support. The Power Manager cannot control power to external peripheral devices such as hard disks and CD-ROM drives because such devices have their own power supplies.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Because the Power Manager saves the contents of all of the CPU registers, including the stack pointer, before putting the computer into the sleep state, and because the contents of RAM are preserved while the computer is in the sleep state, most applications are not adversely affected by the sleep state. Because a portable Macintosh computer does not enter the idle state when almost any sort of activity is going on (or even when the watch cursor is being displayed), few programs are adversely affected by the idle state. Therefore, it is likely that your application will not have to make calls to the Power Manager.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING232-8></A>
<H2><A NAME=MARKER-9-103></A>Determining Whether the Power Manager Is Present</H2>
 <A NAME=MARKER-2-104></A><A NAME=MARKER-2-105></A>You can use the <CODE>Gestalt</CODE> function with the <CODE>gestaltPowerMgrAttr</CODE> selector to determine whether the Power Manager is available on a particular computer and whether certain other devices in the computer can be put into the idle or sleep state. The <CODE>Gestalt</CODE> function returns in the <CODE>response</CODE> parameter a 32-bit value that may have some or all of the following bits set:<A NAME=MARKER-4-106></A><P>
<PRE>
CONST
   gestaltPMgrExists       = 0;{Power Manager is present}
   gestaltPMgrCPUIdle      = 1;{CPU can idle}
   gestaltPMgrSCC          = 2;{can stop SCC clock}
   gestaltPMgrSound        = 3;{can shut off sound circuits}
   gestaltPMgrDispatchExists = 4;{dispatch routines are present}
</PRE>
 If the <CODE>gestaltPMgrExists</CODE> bit is set, the Power Manager is present. If the <CODE>gestaltPMgrCPUIdle</CODE> bit is set, the CPU is capable of going into a state of low power consumption. If the <CODE>gestaltPMgrSCC</CODE> bit is set, it is possible to stop the SCC clock, thus effectively turning off the serial ports. If the <CODE>gestaltPMgrSound</CODE> bit is set, it is possible to turn off power to the sound circuits. If the gestaltPMgrDispatchExists bit is set, the Power Manager dispatch routines are available; see the next section for more information.<P>
<DL>
<DT><B>Note</B>
<DD>For complete details on using the <CODE>Gestalt</CODE> function, see the chapter "Gestalt Manager" in <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING232-13></A>
<H2>Determining Whether the Power Manager Dispatch Routines are Present</H2>
 You can use the <CODE>Gestalt</CODE> function with the <CODE>gestaltPowerMgrAttr</CODE> selector to determine whether the Power Manager dispatch routines are available on a particular computer. If the gestaltPMgrDispatchExists bit is set in the <CODE>response</CODE> parameter, the Power Manager dispatch routines are available.<P>
 Because more routines may be added in the future, the <CODE>PMSelectorCount</CODE> function (described on <A HREF=Devices-265.html#MARKER-9-268>page 6-41</A>) returns the number of dispatch routines that are implemented. The sample code in <A HREF=#MARKER-9-107>Listing 6-1</A> shows how you can use the <CODE>Gestalt</CODE> function to determine whether the Power Manager dispatch routines are present, and then use the <CODE>PMSelectorCount</CODE> function to find out which routines are supported. In this case, the sample code tests for the existence of the hard disk spindown routine (selector $07). <P>
<B>Listing 6-1  <A NAME=MARKER-9-107></A>Determining which Power Manager dispatch routines exist</B><P>
<PRE>
long pmgrAttributes;
Boolean routinesExist;

routinesExist = false;
if (! Gestalt(gestaltPowerMgrAttr, &amp;pmgrAttributes))
if (pmgrAttributes &amp; (1&lt;&lt;gestaltPMgrDispatchExists))
if (PMSelectorCount() &gt;= 7) /* do the first 8 routines exist? */
   routinesExist = true;
</PRE>
<DL>
<DT><B>WARNING</B>
<DD>If you call a routine that does not exist, the call to the public Power Manager trap (if the trap exists) will return an error code, which your program could misinterpret as data.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING232-19></A>
<H2><A NAME=MARKER-9-108></A>Enabling or Disabling the Idle State</H2>
 You can reset the activity timer to 15 seconds, disable or enable the idle state, and read the current CPU clock speed by using Power Manager routines.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Keep in mind that it is almost always better to design your code so that it is not affected by the idle state. If you do so, the computer can conserve power whenever possible. Note also that disabling the idle state does not disable the sleep state. To prevent your program from being adversely affected by the sleep state, you need to place a sleep procedure in the sleep queue, as described in <A HREF=#MARKER-9-125>"Installing a Sleep Procedure," beginning on page 6-18</A>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-109></A>To reset the activity timer to count down another 15 seconds before the Power Manager puts the computer into the idle state, use the <CODE>IdleUpdate</CODE> function. The <CODE>IdleUpdate</CODE> function takes no parameters and returns the value in the <CODE>Ticks</CODE> global variable at the time the function was called.<A NAME=MARKER-2-110></A><P>
 If you want to disable the idle state--that is, prevent the computer from entering the idle state--for more than 15 seconds, use the <CODE>DisableIdle</CODE> procedure. If your application cannot tolerate the idle state at all, you can call the <CODE>DisableIdle</CODE> procedure when your application starts up and then call the <CODE>EnableIdle</CODE> procedure when your application terminates.<A NAME=MARKER-9-141></A><P>
 <A NAME=MARKER-2-107></A>The <CODE>EnableIdle</CODE> procedure cancels the last call to the <CODE>DisableIdle</CODE> procedure. Note that canceling the last call to the <CODE>DisableIdle</CODE> procedure is not always the same thing as enabling the idle state. For example, if the user has used the Portable control panel to disable the idle state, then a call to the <CODE>EnableIdle</CODE> procedure does not enable the idle state. Similarly, if your routine called the <CODE>DisableIdle</CODE> procedure more than once or if another routine has called the <CODE>DisableIdle</CODE> procedure, then a call to the <CODE>EnableIdle</CODE> procedure cancels only the last call to the <CODE>DisableIdle</CODE> procedure; it does not enable the idle state.<P>
 The Power Manager does not actually reenable the idle state until every call to the <CODE>DisableIdle</CODE> procedure has been matched by a call to the <CODE>EnableIdle</CODE> procedure, and then only if the user has not disabled the idle state through the Portable (or PowerBook) control panel. For this reason, you must be very careful to match each call to the <CODE>DisableIdle</CODE> procedure with a single call to the <CODE>EnableIdle</CODE> procedure. Be careful to avoid making extra calls to the <CODE>EnableIdle</CODE> procedure so that you do not inadvertently reenable the idle state while another application needs it to remain disabled.<P>
 Calls to the <CODE>EnableIdle</CODE> procedure are not cumulative; that is, after you make several calls to the <CODE>EnableIdle</CODE> procedure, a single call to the <CODE>DisableIdle</CODE> procedure still disables the idle state. Disabling the idle state always takes precedence over enabling the idle state. A call to the <CODE>DisableIdle</CODE> procedure disables the idle state no matter how many times the <CODE>EnableIdle</CODE> procedure has been called and whether or not the user has enabled the idle state through the Portable or PowerBook control panel.<P>
 The following examples should help to clarify the use of <CODE>EnableIdle</CODE> and <CODE>DisableIdle</CODE>:<P>
<UL>
<LI>If an application calls the <CODE>EnableIdle</CODE> routine but the user disables or has disabled the idle state, the idle state is disabled.
<LI>If an application calls the <CODE>DisableIdle</CODE> routine and the user enables or has enabled the idle state, the idle state is disabled.
<LI>If an application calls the <CODE>DisableIdle</CODE> routine twice in a row and then calls the <CODE>EnableIdle</CODE> routine once, the idle state is disabled.
<LI>If an application calls the <CODE>EnableIdle</CODE> routine twice in a row and then calls the <CODE>DisableIdle</CODE> routine once, the idle state is disabled.
<LI>If the idle state is initially enabled and if an application calls the <CODE>DisableIdle</CODE> routine twice in a row and then calls the <CODE>EnableIdle</CODE> routine twice, the Power Manager first disables and then reenables the idle state.<P>
</UL>
 To determine whether a portable Macintosh computer is currently in the idle state, read the current clock speed with the <CODE>GetCPUSpeed</CODE> function. If the value returned by the <CODE>GetCPUSpeed</CODE> function is 1, the computer is in the idle state.<P>
<A NAME=HEADING232-34></A>
<H2><A NAME=MARKER-9-115></A>Setting, Disabling, and Reading the Wakeup Timer</H2>
 <A NAME=MARKER-2-116></A>When a portable Macintosh computer is in the sleep state, the power management hardware updates the real-time clock and compares it to the wakeup timer once each second. When the real-time clock and the wakeup timer have the same setting, the power management circuits return the computer to the operating state. The Power Manager provides functions that you can use to set the wakeup timer, disable the wakeup timer, and read the wakeup timer's current setting.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>In some portable Macintosh computers, the power management hardware does not receive this periodic "tickle." As a result, the wakeup timer cannot be used on those machines. To determine whether a particular portable Macintosh computer supports the use of the wakeup timer, call the <CODE>GetWUTime</CODE> function. An error is returned if the timer is not available.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-117></A>Use the <CODE>SetWUTime</CODE> function to set the wakeup timer. You pass one parameter to the <CODE>SetWUTime</CODE> function, an unsigned long word specifying the number of seconds since midnight, January 1, 1904. Setting the wakeup timer automatically enables it. <A HREF=#MARKER-9-118>Listing 6-2</A> illustrates how to call the <CODE>SetWUTime</CODE> function.<P>
<B>Listing 6-2  <A NAME=MARKER-9-118></A>Setting the wakeup timer</B><P>
<PRE>
FUNCTION WakeMeUp (when: LongInt): OSErr;
VAR
   myTime:  LongInt;
BEGIN
   GetDateTime(myTime);                   {get the current time}
   myTime := myTime + when;               {add desired delay}
   WakeMeUp := SetWUTime(LongInt(@myTime));
END;
</PRE>
 The <CODE>when</CODE> parameter passed to the <CODE>WakeMeUp</CODE> function defined in <A HREF=#MARKER-9-118>Listing 6-2</A> specifies how long from the current time the wakeup timer should go off. The <CODE>WakeMeUp</CODE> function determines the current time by calling <CODE>GetDateTime</CODE> and then passes the appropriate value to <CODE>SetWUTime</CODE>. Note that the parameter passed to <CODE>SetWUTime</CODE> is the <I>address</I> of the desired wakeup time, not the wakeup time itself.<A NAME=MARKER-2-119></A><P>
 To disable the wakeup timer, you can set the wakeup timer to any time earlier than the current setting of the real-time clock (that is, to some time in the past), or you can use the <CODE>DisableWUTime</CODE> function. To reenable the wakeup timer, you must use the <CODE>SetWUTime</CODE> function to set the timer to a new time in the future.<A NAME=MARKER-2-120></A><P>
 To get the current setting of the wakeup timer, use the <CODE>GetWUTime</CODE> function. This function returns two parameters: the time to which the wakeup timer is set (in seconds since midnight, January 1, 1904) and a flag indicating whether the wakeup timer is enabled.<A NAME=MARKER-2-116></A><P>
 If the computer is already in the operating state when the real-time clock reaches the setting in the wakeup timer, nothing happens.<P>
<DL>
<DT><B>Note</B>
<DD>The power management circuits do not return the computer to the operating state while battery voltage is low, even if the wakeup timer and real-time clock settings coincide.<EM></EM><A NAME=MARKER-2-98></A><A NAME=MARKER-9-233></A><A NAME=MARKER-2-124></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING232-45></A>
<H2><A NAME=MARKER-9-125></A>Installing a Sleep Procedure</H2>
 <A NAME=MARKER-2-126></A>If you want your program to be notified before the Power Manager puts a portable Macintosh computer into the sleep state or returns it to the operating state, you can put an entry in the sleep queue. If you do place an entry in the sleep queue, remember to remove it before your device driver or application terminates.<P>
 The sleep queue is a standard operating-system queue, as described in <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>. The <CODE>SleepQRec</CODE> data type defines a <B>sleep queue record</B> as follows:<A NAME=MARKER-2-127></A><P>
<PRE>
TYPE SleepQRec =                    {sleep queue record}
   RECORD
      sleepQLink:    SleepQRecPtr;  {next queue element}
      sleepQType:    Integer;       {queue type = 16}
      sleepQProc:    ProcPtr;       {pointer to sleep procedure}
      sleepQFlags:   Integer;       {reserved}
   END;
</PRE>
 To add an entry to the sleep queue, fill in the <CODE>sleepQType</CODE> and <CODE>sleepQProc<EM> fields of a sleep queue record. The </EM></CODE>sleepQLink<EM> and <CODE>sleepQFlags</CODE></EM> fields are maintained privately by the Power Manager; your application should not modify these fields, except to initialize them before it calls the <CODE>SleepQInstall</CODE> procedure. <CODE>SleepQInstall</CODE> takes one parameter, a pointer to your sleep queue record. <A HREF=#MARKER-9-128>Listing 6-3</A> shows how to add an entry to the sleep queue.<P>
<B>Listing 6-3  <A NAME=MARKER-9-128></A>Adding an entry to the sleep queue</B><P>
<PRE>
VAR
   gSleepRec:     SleepQRec;        {a sleep queue record}

PROCEDURE MyInstallSleepProcedure;
BEGIN
   {Set up the record before installing it into the sleep queue.}
   WITH gSleepRec DO
   BEGIN
      sleepQLink := NIL;            {initialize reserved field}
      sleepQType := slpQType;       {set sleep queue type}
      sleepQProc := @MySleepProc;   {set address of sleep proc}
      sleepQFlags := 0;             {initialize reserved field}
   END;
   SleepQInstall(@gSleepRec);       {install the record}
END;
</PRE>
 To remove your routine from the sleep queue, use the <CODE>SleepQRemove</CODE> procedure. This procedure also takes as its one parameter a pointer to your sleep queue record.<P>
<A NAME=HEADING232-53></A>
<H2>Using Application Global Variables in Sleep Procedures</H2>
 <A NAME=MARKER-2-129></A><A NAME=MARKER-2-130></A>When a sleep procedure installed by an application is called, the A5 world of that application might not be valid. That is to say, the A5 register might not point to the boundary between the application's global variables and its application parameters. When this happens, any attempt by the sleep procedure to read the application's global variables or to access any other information in the application's A5 world is likely to return erroneous information.<P>
 As a result, if you use an application to install a sleep procedure and your sleep procedure accesses any information in your application's A5 world, you'll need to make sure that, at the time you access that information, the A5 register points to your application's global variables. Your sleep procedure must also restore the A5 register to its previous value before exiting. This saving and restoring of the A5 register is necessary whenever your sleep procedure uses any information in your application's A5 world, such as your application global variables or any of your application's QuickDraw global variables.<P>
<DL>
<DT><B>Note</B>
<DD>The techniques described in this section are relevant only to sleep procedures installed by applications. Sleep procedures installed from other kinds of code (for example, from system extensions) do not need to worry about saving and restoring the A5 register.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 It's easy enough to use the <CODE>SetA5</CODE> function to read the value of the A5 register when your sleep procedure begins executing and to restore the register immediately before your procedure exits. (See <A HREF=#MARKER-9-140>Listing 6-6 on page 6-21</A>.) It's a bit harder to pass your application's A5 value to the sleep procedure. A standard way to do this in a high-level language like Pascal is to define a new data structure that contains both a sleep queue record and room for the A5 value. For example, you can define a structure of type <CODE>SleepInfoRec</CODE>, as follows:<P>
<PRE>
TYPE SleepInfoRec =                 {sleep information record}
   RECORD
      mySleepQRec:   SleepQRec;     {a sleep queue record}
      mySlpRefCon:   LongInt;       {address of app's A5 world}
   END;
   SleepInfoRecPtr = ^SleepInfoRec;
</PRE>
 Then, you simply need to call the <CODE>SetCurrentA5</CODE> function at a time that your application is the current application and pass the result of that function to your sleep procedure (via the <CODE>mySlpRefCon</CODE> field of the sleep information record). <A HREF=#MARKER-9-131>Listing 6-4</A> shows how to do this.<P>
<B>Listing 6-4  <A NAME=MARKER-9-131></A>Installing a sleep procedure that uses application global variables</B><P>
<PRE>
VAR
   gSleepInfoRec:    SleepInfoRec;  {a sleep information record}

PROCEDURE MyInstallSleepProc;
BEGIN
   {Set up the record before installing it into the sleep queue.}
   WITH gSleepInfoRec.mySleepQRec DO
   BEGIN
      sleepQLink := NIL;            {initialize reserved field}
      sleepQType := slpQType;       {set sleep queue type}
      sleepQProc := @MySleepProc;   {set address of sleep proc}
      sleepQFlags := 0;             {initialize reserved field}
   END;

   {Install app's A5 value into expanded sleep record.}
   gSleepInfoRec.mySlpRefCon := SetCurrentA5;

   SleepQInstall(@gSleepInfoRec));  {install the record}
END;
</PRE>
 The Power Manager puts the address you pass to <CODE>SleepQInstall</CODE> into register A0 when your sleep procedure is called. Thus, the sleep procedure simply needs to retrieve the <CODE>SleepInfoRec</CODE> record and extract the appropriate value of the application's A5 world. See the next section, <A HREF=#MARKER-9-135>"Writing a Sleep Procedure,"</A> for a sample sleep procedure that does this.<P>
<DL>
<DT><B>Note</B>
<DD>For more information about your application's A5 world and routines you can use to manipulate the A5 register, see the chapter "Introduction to Memory Management" in <I><A HREF="../Memory/Memory-2.html">Inside Macintosh: Memory</A></I>.<EM></EM><A NAME=MARKER-2-132></A><A NAME=MARKER-2-133></A><A NAME=MARKER-2-134></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING232-64></A>
<H2><A NAME=MARKER-9-135></A>Writing a Sleep Procedure</H2>
 <A NAME=MARKER-2-136></A>After you've added an entry to the sleep queue, the Power Manager calls your sleep procedure when the Power Manager issues a sleep request, a sleep demand, a wakeup demand, or a sleep-request revocation. Whenever the Power Manager calls your routine, the A0 register contains a pointer to your sleep queue record and the D0 register contains a <B>sleep procedure selector code</B> indicating the reason your routine is being called. One of four selector codes will be in the D0 register:<P>
<PRE>
CONST
   sleepRequest      = 1;     {sleep request}
   sleepDemand       = 2;     {sleep demand}
   sleepWakeUp       = 3;     {wakeup demand}
   sleepRevoke       = 4;     {sleep-request revocation}
</PRE>
 <A NAME=MARKER-2-138></A>When your routine receives a sleep request, it must either allow or deny the request and place its response in the D0 register. To allow the sleep request, clear the D0 register to 0 before returning control to the Power Manager. To deny the sleep request, return a nonzero value in the D0 register. (Note that you cannot deny a sleep demand.) <BR><A HREF=#MARKER-9-139>Listing 6-5</A> defines two assembly-language glue routines that you can use to accept or deny the request from a high-level language.<P>
<B>Listing 6-5  <A NAME=MARKER-9-139></A>Accepting and denying a sleep request</B><P>
<PRE>
PROCEDURE MyAllowSleepRequest;
INLINE
   $7000;      {MOVEQ #0, D0}

PROCEDURE MyDenySleepRequest;
INLINE
   $7001;      {MOVEQ #1, D0}
</PRE>
 If your routine or any other routine in the sleep queue denies the sleep request, the Power Manager sends a sleep-request revocation to each routine that it has already called with a sleep request. If none of the routines denies the sleep request, the Power Manager sends a sleep demand to each routine in the sleep queue. Because your routine will be called a second time in any case, it is not necessary to prepare for sleep in response to a sleep request; your routine need only allow or deny the sleep request by returning a result in the D0 register. <A HREF=#MARKER-9-140>Listing 6-6</A> shows a sample sleep procedure.<P>
<B>Listing 6-6  <A NAME=MARKER-9-140></A>A sleep procedure</B><P>
<PRE>
PROCEDURE MySleepProc;
VAR
   mySleepInfoPtr:   SleepInfoRecPtr;
   mySleepCommand:   LongInt;
   myOldA5:          LongInt;          {A5 upon entry to procedure}
   myCurA5:          LongInt;


BEGIN
   mySleepInfoPtr := MyGetSleepInfoPtr; {get the address of the sleep record}
   mySleepCommand := MyGetSleepCommand; {get the task we are to perform}

   {Set A5 register to app's A5 value, and save the original A5 value.}
   myOldA5 := SetA5(mySleepInfoPtr^.mySlpRefCon);

   CASE mySleepCommand OF               {do the right thing}
      sleepRequest: 
         MySleepRequest;
      sleepDemand: 
         MySleepDemand;
      sleepWakeUp: 
         MyWakeupDemand;
      sleepRevoke: 
         MySleepRevoke;
      OTHERWISE
         ;
   END; {CASE}

   myOldA5 := SetA5(myOldA5);           {restore original A5}
END;
</PRE>
 The <CODE>MySleepProc</CODE> sleep procedure defined in <A HREF=#MARKER-9-140>Listing 6-6</A> retrieves the address of the sleep queue record contained in register A0 and the selector code contained in register D0. Then it calls the appropriate application-defined routine to handle the selector code. <CODE>MySleepProc</CODE> uses two assembly-language glue routines, defined in <A HREF=#MARKER-9-141>Listing 6-7</A>, to get those values from the appropriate registers.<P>
<B>Listing 6-7  <A NAME=MARKER-9-141></A>Retrieving the sleep queue record and the selector code</B><P>
<PRE>
{Retrieve the address of our sleep info record from A0.}
FUNCTION MyGetSleepInfoPtr: SleepInfoRecPtr;
INLINE
   $2E88;      {MOVE.L A0, (A7)}

{Retrieve the command code for the sleep procedure from D0.}
FUNCTION MyGetSleepCommand: LongInt;
INLINE
   $2E80;      {MOVE.L D0, (A7)}
</PRE>
 <A NAME=MARKER-2-142></A>When your sleep procedure receives a sleep demand, it must prepare for the sleep state and return control to the Power Manager as quickly as possible. Because sleep demands are never sent by an interrupt handler, your sleep procedure can perform whatever tasks are necessary to prepare for sleep, including making calls to the Memory Manager. You can, for example, display an alert box to inform the user of potential problems, or you can even display a dialog box that requires the user to specify the action to be performed. However, if several applications display alert or dialog boxes, the user might become confused or alarmed. More important, if the user is not present to answer the alert box or dialog box, control is never returned to the Power Manager and the computer does not go to sleep. <A HREF=#MARKER-9-143>Listing 6-8</A> defines a procedure that displays a dialog box whenever a sleep demand is received.<P>
<B>Listing 6-8  <A NAME=MARKER-9-143></A>Displaying a dialog box in response to a sleep demand</B><P>
<PRE>
PROCEDURE MySleepDemand;
VAR
   myItem:        Integer;       {item number for ModalDialog}
   myRect:        Rect;          {rectangle for NewDialog}
   myOrigPort:    GrafPtr;       {original graphics port}
BEGIN
   myItem := 0;
   gOrigTime := TickCount;       {initialize timer}

   IF gDialog = NIL THEN         {create a dialog window}
   BEGIN
      SetRect(myRect, 50, 50, 400, 150);
      gDialog := NewDialog(NIL, myRect, '', FALSE, dBoxProc, 
                           WindowPtr(-1), FALSE, 0, gItemHandle);
   END;

   IF gDialog &lt;&gt; NIL THEN
   BEGIN
      GetPort(myOrigPort);       {remember current port}
      ShowWindow(gDialog);       {make dialog visible}
      SelectWindow(gDialog);
      SetPort(gDialog);
      REPEAT
         ModalDialog(@MyTimeOutFilter, myItem);
      UNTIL myItem = 1;

      HideWindow(gDialog);
      SetPort(myOrigPort);       {restore original port}
   END;
END;
</PRE>
 To display a dialog box, you need to build the dialog box from within the sleep procedure itself to ensure that the newly created dialog box appears frontmost on the screen. You can facilitate this process by passing a handle to the dialog item list to your sleep procedure. In <A HREF=#MARKER-9-143>Listing 6-8</A>, the global variable <CODE>gItemHandle</CODE> is assumed to contain a handle to the dialog item list. You can execute the following line of code early in your application's execution to set <CODE>gItemHandle</CODE> to the correct value:<P>
<PRE>
gItemHandle := Get1Resource('DITL', kAlertDITL);
</PRE>
<DL>
<DT><B>WARNING</B>
<DD>If your sleep procedure displays an alert box or modal dialog box, the computer does not enter the sleep state until the user responds. If the computer remains in the operating state until the battery voltage drops below a preset value, the power management hardware automatically shuts off all power to the system, without preserving the state of open applications or data that has not been saved to disk. To prevent this from happening, you should automatically remove your dialog box after several minutes have elapsed.<EM></EM><A NAME=MARKER-2-146></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 An easy way to implement this time-out feature is to pass the <CODE>ModalDialog</CODE> procedure the address of a modal dialog filter function that intercepts null events until the desired amount of time has elapsed. <A HREF=#MARKER-9-147>Listing 6-9</A> illustrates such a filter function.<P>
<B>Listing 6-9  <A NAME=MARKER-9-147></A>A modal dialog filter function that times out</B><P>
<PRE>
FUNCTION MyTimeOutFilter (myDialog: DialogPtr; 
                         VAR myEvent: EventRecord; 
                         VAR myItem: Integer): Boolean;
CONST
   kTimeOutMax = 18000;    {remove dialog box after 5 minutes}
BEGIN
   MyTimeOutFilter := FALSE;

   CASE myEvent.what OF
      nullEvent: 
         BEGIN
            IF (TickCount - gOrigTime) &gt;= kTimeOutMax THEN
            BEGIN
               myItem := 1;
               MyTimeOutFilter := TRUE;
            END;
         END;
      {handle other relevant events here}
      OTHERWISE
         ;
   END; {CASE}
END;
</PRE>
 The global variable <CODE>gOrigTime</CODE> is initialized in the <CODE>MySleepDemand</CODE> procedure; the modal dialog filter function defined in <A HREF=#MARKER-9-147>Listing 6-9</A> simply waits until the appropriate number of ticks (sixtieths of a second) have elapsed before simulating a click on the OK button (assumed to be dialog item number 1).<A NAME=MARKER-2-148></A><P>
 <A NAME=MARKER-2-149></A>When your routine receives a wakeup demand, it must prepare for the operating state and return control to the Power Manager as quickly as possible.<P>
 <A NAME=MARKER-2-150></A>When your routine receives a sleep-request revocation, it must reverse any changes it made in response to the sleep request that preceded it and return control to the Power Manager.<P>
<A NAME=HEADING232-88></A>
<H2><A NAME=MARKER-9-151></A>Switching Serial Power On and Off</H2>
 <A NAME=MARKER-2-154></A><A NAME=MARKER-9-213></A><A NAME=MARKER-2-57></A>The serial I/O subsystem of a portable Macintosh computer includes the following components:<P>
<UL>
<LI>the Serial Communications Controller (SCC) chip<A NAME=MARKER-2-157></A>
<LI>the serial driver chips
<LI>the -5 volt supply
<LI>the internal modem (if installed)<P>
</UL>
 Because serial drivers always use these components in certain combinations, the Power Manager provides five serial power procedures that perform the following tasks:<P>
<UL>
<LI>The <CODE>AOn</CODE> procedure switches on power to serial port A and switches on power to the internal modem if it is installed.
<LI>The <CODE>AOnIgnoreModem</CODE> procedure switches on power to serial port A (the modem port) but does not switch on power to the internal modem.
<LI>The <CODE>BOn</CODE> procedure switches on power to serial port B.
<LI>The <CODE>AOff</CODE> procedure switches off power to serial port A and to the internal modem if it is in use.
<LI>The <CODE>BOff</CODE> procedure switches off power to serial port B.<P>
</UL>
 If no internal modem is installed, then calling any of the power-on routines switches on power to the SCC, the serial driver chips, and the -5 volt supply.<P>
 To switch power on for port B whether or not there is an internal modem installed, use the <CODE>BOn</CODE> procedure. This procedure switches on power to the SCC, the serial driver chips, and the -5 volt supply.<P>
 If the internal modem is installed, then you can use the <CODE>AOn</CODE> procedure to switch on the modem. In this case, this procedure switches on power to the SCC, the -5 volt supply, and the modem; the internal modem does not use the serial driver chips.<P>
 If the internal modem is installed but you do not want to use it (whether or not the user has used the Portable control panel to disconnect the modem), then use the <CODE>AOnIgnoreModem</CODE> procedure to switch on power to the SCC, the serial driver chips, and the -5 volt supply.<A NAME=MARKER-9-103></A><A NAME=MARKER-2-139></A><A NAME=MARKER-2-160></A><A NAME=MARKER-9-159></A><A NAME=MARKER-2-65></A><P>
<DL>
<DT><B>Note</B>
<DD>You can use the Power Manager's <CODE>ModemStatus</CODE> function to determine whether an internal modem is turned on or off. For details, see the description of <CODE>ModemStatus</CODE> beginning on <A HREF=Devices-260.html#MARKER-9-230>page 6-36</A>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING232-105></A>
<H2><A NAME=MARKER-9-163></A>Monitoring the Battery and Battery Charger</H2>
 You can use the Power Manager to monitor the status of the battery and battery charger. To do so, use the <CODE>BatteryStatus</CODE> function to determine the current voltage in the battery.<P>
 For most accurate results, you might want to average the voltage over some extended period of time (anywhere from 30 seconds to several minutes). The power load within a portable Macintosh computer varies dynamically, and the current draw of the various subsystems affects the voltage read at any one moment.<P>

<HR>
<center>
<A HREF="Devices-231.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-233.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Devices-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML>  
