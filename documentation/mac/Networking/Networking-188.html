<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using Registers and Packet Headers(IM:N)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING188></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Networking-187.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-189.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Networking-2.html"><B>Networking</B></A> / <BR><DD><A HREF="Networking-179.html"><B>Chapter 7 - Datagram Delivery Protocol (DDP)</B></A> / <A HREF="Networking-185.html"><B>Using DDP</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING188-0></A>
<H2>Using Registers and Packet Headers</H2>
 To receive data at the DDP level, you need to include as part of your socket-client application a socket listener that reads packets addressed to your application and passes them to the application for further processing. DDP maintains a table with an entry <BR>for each socket and socket listener pair.<P>
 When the .MPP driver receives a packet addressed to your socket-client application, it calls your socket listener, using the CPU's registers to pass pointers to the internal buffer where it has stored the packet's headers and to some data values that your socket listener uses during its processing. <P>
 The CPU's registers that the .MPP driver uses to pass parameters to your socket listener are not directly accessible from Pascal. Because a DDP socket listener must read from and write to the CPU's registers, you must write a socket listener in assembly language; you cannot use Pascal. However, you can write the remainder of the client application that includes the socket listener in a high-level language such as Pascal. The client application sample code that this chapter shows is written in the Pascal language. <P>
<A NAME=HEADING188-4></A>
<H3><A NAME=MARKER-9-69></A>How the .MPP Driver Calls Your Socket Listener</H3>
 <A NAME=MARKER-2-101></A>When a frame addressed to a particular node arrives at that node and the frame contains a DDP packet, the node's CPU is interrupted and the link-access protocol calls the .MPP driver to receive the packet. When the .MPP driver receives a DDP packet, it reads the first 3 bytes of the frame header into an internal buffer called the<B> read-header area (RHA).</B> After the frame header is read into the RHA, 8 bytes of the RHA are still available for your use. <P>
 Next, the .MPP driver reads the socket address and calls the socket listener for that socket. The .MPP driver uses the CPU's registers to pass parameters to your socket listener as follows:
<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on call to DDP socket listener<TR>
<TD>A0<TD>Reserved for internal use by the .MPP driver. You must preserve this register until after the <CODE>ReadRest</CODE> routine has completed execution.<TR>
<TD>A1<TD>Reserved for internal use by the .MPP driver. You must preserve this register until after the <CODE>ReadRest</CODE> routine has completed execution.<TR>
<TD>A2<TD>Pointer to the .MPP driver's local variables. The value at the offset <CODE>toRHA</CODE> from the value in the A2 register points to the start of the RHA.<TR>
<TD>A3<TD>Pointer to the first byte in the RHA past the DDP header bytes (the first byte after the DDP protocol type field).<TR>
<TD>A4<TD>Pointer to the <CODE>ReadPacket</CODE> routine. The <CODE>ReadRest</CODE> routine starts 2 bytes after the start of the <CODE>ReadPacket</CODE> routine.<TR>
<TD>A5<TD>Free for your use before and until your socket listener calls <BR>the <CODE>ReadRest</CODE> routine. <TR>
<TD>D0<TD>Lower byte is the destination socket number of the packet. <TR>
<TD>D1<TD>Word indicating the number of bytes in the DDP packet left to be read (that is, <BR>the number of bytes following the DDP header).<B></B><TR>
<TD>D2<TD>Free for your use.<TR>
<TD>D3<TD>Free for your use.</TABLE>
<P>
 When the .MPP driver calls your socket listener, you can read the destination socket number that is in the D0 register and the frame header that is in the RHA. <A NAME=MARKER-9-71></A>You should assume that only 8 bytes are still available in the RHA for your use. <A HREF=#MARKER-9-76>Figure 7-5</A> shows the beginning of the RHA where the frame header begins; the frame header is followed by either a short or a long DDP header.<P>
<A NAME=HEADING188-8></A>
<H3><A NAME=MARKER-9-72></A>The <A NAME=MARKER-2-73></A>DDP Packet and Frame Headers</H3>
 <A NAME=MARKER-2-67></A>A DDP <A NAME=MARKER-2-82></A>packet includes a packet header followed by data. The DDP packet header is preceded by the frame header. <A HREF=#MARKER-9-77>Figure 7-6</A> shows both headers; they do not include the data portion. The DDP packet header can be long or short; if the destination and source network numbers are different, DDP uses a long header, which includes some additional fields.<P>
 The frame header includes<P>
<UL>
<LI>the source and destination node IDs 
<LI>the DDP header type (1 = short, 2 = long)<P>
</UL>
<B>Figure 7-5  <A NAME=MARKER-9-76></A>The RHA for both long and short DDP headers</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DDP-L-06.jpg"><P>
<B>Figure 7-6  <A NAME=MARKER-9-77></A>Data-link frame header and DDP<A NAME=MARKER-2-78></A> packet header</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DDP-L-05.jpg"><P>
 The DDP long and short packet headers have these fields in common:<P>
<UL>
<LI>the datagram length (10 bits)
<LI>the destination socket number
<LI>the source socket number 
<LI>the DDP protocol type<P>
</UL>
 A long DDP packet header also includes <P>
<UL>
<LI>a hop count
<LI>a checksum value, if one was calculated
<LI>the source network number and node ID
<LI>the destination network number and node ID <P>
</UL>
<A NAME=HEADING188-27></A>
<H3><A NAME=MARKER-9-79></A>The MPW Equates<A NAME=MARKER-2-157></A></H3>
 <A NAME=MARKER-21-66></A>You can <A NAME=MARKER-2-67></A>use the following equates from the MPW interface files in writing your socket listener process and the client application that includes it:<P>
<PRE>
;frame header
;
lapDstAdr   EQU   0     ;destination node address [byte]
lapSrcAdr   EQU   1     ;source node address [byte]
lapType     EQU   2     ;LAP type field [byte]
lapHdSz     EQU   3     ;size of LAP header

;DDP packet header
;
ddpHopCnt   EQU   0     ;hop count (only used in long 
                        ; header) [byte]
ddpLength   EQU   0     ;packet length (from this word 
                        ; onward) [word]
ddpChecksum EQU   2     ;checksum [word]
ddpDstNet   EQU   4     ;destination network no. [word]
ddpSrcNet   EQU   6     ;network of origin [word]
ddpDstNode  EQU   8     ;destination node address [byte]
ddpSrcNode  EQU   9     ;node of origin [byte]
ddpDstSkt   EQU   10    ;destination socket number [byte]
ddpSrcSkt   EQU   11    ;source socket number [byte]
ddpType     EQU   12    ;DDP protocol type field [byte]
sddpDstSkt  EQU   2     ;destination socket number (short
                        ; header) [byte]
sddpSrcSkt  EQU   3     ;source socket number (short 
                        ; header) [byte]
sddpType    EQU   4     ;DDP protocol type field (short header)
                        ; [byte]
;
ddphSzLong  EQU   13    ;size of extended DDP header
ddphSzShort EQU   5     ;size of short DDP header
;
shortDDP    EQU   $01   ;LAP type code for DDP (short header)
longDDP     EQU   $02   ;LAP type code for DDP (long header)
</PRE>
<A NAME=HEADING188-30></A>
<H3><A NAME=MARKER-9-83></A>Reading an Incoming Packet</H3>
 <A NAME=MARKER-2-177></A>Your socket listener calls the <CODE>R<A NAME=MARKER-2-78></A>eadPacket</CODE> and <CODE>ReadRest</CODE> processes to <A NAME=MARKER-2-6></A>read the incoming data packet. You can call <CODE>ReadPacket</CODE> as many times as you like to read the data piece by piece into one or more data buffers, but you must always use <CODE>ReadRest</CODE> to read the final piece of the data packet. Alternatively, you can read all of the data using only <CODE>ReadRest</CODE>. The <CODE>ReadRest</CODE> routine restores the machine state (the stack pointers, status register, and so forth) and checks for error conditions. <P>
<DL>
<DT><B>Note</B>
<DD>You can ignore any remaining data instead of reading it <BR>by setting the D3 register to 0 and calling <CODE>ReadRest</CODE>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 Before you call the <CODE>ReadPacket</CODE> routine, you must allocate memory for a data buffer and place a pointer to the buffer in the A3 register. You must also place the number of bytes you want to read in the D3 register. You must not request more bytes than remain in the data packet. <P>
 The buffer that you allocate must be large enough to hold all of the data and--if your socket listener places the packet header in the buffer--the header as well. The maximum amount of data in a DDP data packet is 586 bytes. A long DDP packet header is 13 bytes long; a short header is 5 bytes. The frame header is 3 bytes. Therefore, the maximum amount of data from the packet that the socket listener can return is 602 bytes. You can use the buffer as a data structure to hold other information as well, such as the number of bytes of data actually read by the socket listener, a flag that indicates when the data has been returned, and result codes. <P>
 After you have called the <CODE>ReadRest</CODE> routine, you can use registers A0 through A3 and D0 through D3 for your own use, but you must preserve all other registers. You cannot depend on having access to your application's global variables.<P>
 To call the <CODE>ReadPacket</CODE> routine, execute a JSR instruction to the address in the A4 register. The <CODE>ReadPacket</CODE> routine uses the registers as follows:
<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on entry to the <CODE>ReadPacket</CODE> routine<TR>
<TD>A3<TD>Pointer to a buffer to hold the data you want to read<TR>
<TD>D3<TD>Number of bytes to read; must be nonzero</TABLE>

<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on exit from the <CODE>ReadPacket</CODE> routine<TR>
<TD>A0<TD>Unchanged<TR>
<TD>A1<TD>Unchanged<TR>
<TD>A2<TD>Unchanged<TR>
<TD>A3<TD>Address of the first byte after the last byte read into buffer<TR>
<TD>A4<TD>Unchanged<TR>
<TD>D0<TD>Changed <TR>
<TD>D1<TD>Number of bytes left to be read<TR>
<TD>D2<TD>Unchanged<TR>
<TD>D3<TD>Equals 0 if requested number of bytes were read, nonzero if error</TABLE>
<P>
 After every time you call <CODE>ReadPacket</CODE> or <CODE>ReadRest</CODE>, you must check the zero (<CODE>z</CODE>) flag <BR>in the status register for errors because the <CODE>ReadPacket</CODE> routine indicates an error <BR>by clearing it to 0. If the <CODE>ReadPacket</CODE> routine returns an error, you must terminate execution of your socket listener with an RTS instruction without calling <CODE>ReadPacket</CODE> again or calling <CODE>ReadRest</CODE> at all. <P>
 Call the <CODE>ReadRest</CODE> routine to read the last portion of the data packet, or call it after <BR>you have read all the data with <CODE>ReadPacket</CODE> routines and before you do any other processing or terminate execution. After you call the <CODE>ReadRest</CODE> routine, you must terminate execution of your socket listener with an RTS instruction whether or not the <CODE>ReadRest</CODE> routine returns an error. <P>
 When you call the <CODE>ReadRest</CODE> routine, you must provide in the A3 register a pointer to <BR>a data buffer and must indicate in the D3 register the size of the data buffer. If you <BR>have already read all of the data with calls to the <CODE>ReadPacket</CODE> routine, specify a buffer of size 0.<P>
<DL>
<DT><B>WARNING</B>
<DD><A NAME=MARKER-9-87></A>If you do not call the <CODE>ReadRest</CODE> routine after the last time you call the <CODE>ReadPacket</CODE> routine successfully, the system will crash. You do not need to call the <CODE>ReadPacket</CODE> routine; you can call only the <CODE>ReadRest</CODE> routine to read in the entire packet. However, you must call the <CODE>ReadRest</CODE> routine.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To call the <CODE>ReadRest</CODE> routine, execute a JSR instruction to an address 2 bytes past the address in the A4 register. The <CODE>ReadRest</CODE> routine uses the registers as follows:
<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on entry to the <CODE>ReadRest</CODE> routine<TR>
<TD>A3<TD>Pointer to a buffer to hold the data you want to read<TR>
<TD>D3<TD>Size of the buffer (word length); may be 0</TABLE>

<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on exit from the <CODE>ReadRest</CODE> routine<TR>
<TD>A0<TD>Unchanged<TR>
<TD>A1<TD>Unchanged<TR>
<TD>A2<TD>Unchanged<TR>
<TD>A3<TD>Pointer to first byte after the last byte read into buffer<TR>
<TD>D0<TD>Changed<TR>
<TD>D1<TD>Changed<TR>
<TD>D2<TD>Unchanged<TR>
<TD>D3<TD>Equals 0 if requested number of bytes exactly equaled the size of the buffer; <BR>less than 0 if more data was left than would fit in buffer (extra data equals -D3 bytes); greater than 0 if less data was left than the size of the buffer (extra buffer space equals D3 bytes)</TABLE>
<P>
<DL>
<DT><B><A NAME=MARKER-9-88></A>Calling <CODE>ReadPacket</CODE> and <CODE>ReadRest</CODE> when LocalTalk is the data link</B>
<DD>If <A NAME=MARKER-2-100></A>LocalTalk is the data link that is being used, your socket listener <BR><A NAME=MARKER-2-23></A>has less than 95 microseconds (best case) to read more data with a <CODE>ReadPacket</CODE> or <CODE>ReadRest</CODE> call. If you need more time, you can read another 3 bytes into the RHA, which will allow you an additional <BR>95 microseconds.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 In implementing your socket listener, you can use the registers as follows:<P>
<UL>
<LI>You can use registers D0, D2, and D3 freely throughout the socket listener code. 
<LI>You must preserve the contents of registers A6 and D4 to D7. 
<LI>From entry to your socket listener until you call <CODE>ReadRest</CODE><P>
<UL>
<LI>you can use A5 register 
<LI>you must preserve registers A0 to A2, A4, and D1 <P>
</UL>
<LI>From <CODE>ReadRest</CODE> until your application exits from the socket listener<P>
<UL>
<LI>you must preserve register A5
<LI>you can use registers A0 to A3 and D0<A NAME=MARKER-2-59></A> to D3<A NAME=MARKER-2-142></A> <P>
</UL>
</UL>
<A NAME=HEADING188-53></A>
<H3><A NAME=MARKER-9-93></A>Using Checksums <A NAME=MARKER-2-41></A></H3>
 For packets that include a long header, DDP includes a checksum feature that you can use to verify that the packet data has not been corrupted by memory or data bus errors within routers on the internet.<P>
 <A NAME=MARKER-2-95></A>When you use the <A NAME=MARKER-9-108></A><CODE>PWriteDDP</CODE> function to send a DDP packet across an AppleTalk internet, you can set a flag (<A NAME=MARKER-2-97></A><CODE>checksumFlag</CODE>) to direct DDP to calculate a checksum <BR>for the packet. <P>
 If the checksum flag is set and the socket to which you are sending the packet (the destination socket) has a network number that is different from that of the socket from which you are sending the packet (the source socket), then the <A NAME=MARKER-4-98></A><CODE>PWriteDDP</CODE> function calculates a checksum for the datagram and includes it in the datagram packet header. In this case, DDP uses a long header for the packet; <A HREF=#MARKER-9-77>Figure 7-6 on page 7-15</A> shows both the long and short DDP headers.<P>
 When your socket listener receives a packet that has a lo<A NAME=MARKER-2-99></A>ng header, the socket listener must determine whether DDP calculated a checksum for the packet, and if so, use the checksum to verify that the data was delivered intact. You can use the equates from the MPW interface files in calculating checksums: see <A HREF=#MARKER-9-79>"The MPW Equates" on page 7-16</A>.<P>
 To determine this, your socket listener code should take the following steps:<P>
<OL>
<LI>Check the DDP header type field. This is set to 2 for a packet with a long header and 1 for a packet with a short header. 
<LI>Check the checksum field (<CODE>checksumFlag</CODE>). This is set to a nonzero value if the sender specified that DDP should calculate a checksum for the packet; a short header does not include a checksum field. 
<LI>Calculate the checksum using the following algorithm to calculate the checksum, starting with the byte immediately following the checksum field in the header and ending with the last data byte:<P>
checksum <EM>:=</EM> checksum <EM>+</EM> next byte; {unsigned addition}<BR>Rotate the most significant bit to the least significant bit<BR>Repeat
<LI>Compare the calculated checksum against the value set in the checksum field of the DDP packet header. <P>
You can use the equates from the MPW interface files in calculating<A NAME=MARKER-2-109></A> checksums: see <A HREF=#MARKER-9-79>"The MPW Equates" on page 7-16</A>.<P>
</OL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Networking-187.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-189.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Networking-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
