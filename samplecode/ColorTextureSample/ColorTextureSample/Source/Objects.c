/*********************************//*    OBJECT MANAGER 		     *//* (c)1993-1995 Pangea Software  *//* By Brian Greenstone      	 *//*********************************//***************//* EXTERNALS   *//***************/#include "myglobals.h"#include <QD3D.h>#include <QD3DCamera.h>#include <QD3DDrawContext.h>#include <QD3DErrors.h>#include <QD3DGeometry.h>#include <QD3DGroup.h>#include <QD3DIO.h>#include <QD3DMath.h>#include <QD3DView.h>#include <QD3DTransform.h>#include "objects.h"#include "misc.h"#include "qd3d_support.h"/****************************//*    CONSTANTS             *//****************************/#define INVALID_NODE_FLAG	0xffffffffL			// put into CType when node is deleted/**********************//*     VARIABLES      *//**********************/											// OBJECT LISTlong		gNumObjects;								ObjNode		*gFirstNodePtr;ObjNode		*gObjectNodeList = nil;ObjNode		*gFreeNodeStack[MAX_OBJECTS];long		gNodeStackTop;					ObjNode		*gCurrentNode,*gMostRecentlyAddedNode;										NewObjectDefinitionType	gNewObjectDefinition;TQ3Point3D	gCoord;TQ3Vector3D	gVelocity;/************************ INIT OBJECT MANAGER **********************/void InitObjectManager(void){short		i;				/* INIT LINKED LIST */	if (gObjectNodeList == nil)								// see if need to allocate memory for object list	{		gObjectNodeList = (ObjNode *)AllocPtr(sizeof(ObjNode)*MAX_OBJECTS);	}		gCurrentNode = nil;						/* CLEAR ENTIRE OBJECT LIST */			gFirstNodePtr = nil;									// no node yet	gNumObjects = 0;				for (i=0; i<MAX_OBJECTS; i++)	{		gObjectNodeList[i].PrevNode = nil;		gObjectNodeList[i].NextNode = nil;			gObjectNodeList[i].NodeNum = i;			gObjectNodeList[i].Genre = 0;		gObjectNodeList[i].SortSlot = 0;		gObjectNodeList[i].Type = 0;		gObjectNodeList[i].AnimNum = 0;		gObjectNodeList[i].ModeFlags = 0;		gObjectNodeList[i].Coord.x = 0;		gObjectNodeList[i].Coord.y = 0;		gObjectNodeList[i].Coord.z = 0;		gObjectNodeList[i].Velocity.x = 0;		gObjectNodeList[i].Velocity.y = 0;		gObjectNodeList[i].Velocity.z = 0;	}						/* INIT FREE NODE STACK */						gNodeStackTop = 0;	for (i=0; i<MAX_OBJECTS; i++)		gFreeNodeStack[i] = &gObjectNodeList[i];}/*********************** MAKE NEW OBJECT ******************///// MAKE NEW OBJECT & RETURN PTR TO IT//// The linked list is sorted from LARGEST z to smallest!//ObjNode	*MakeNewObject(NewObjectDefinitionType *newObjDef){ObjNode	*newNodePtr,*scanNodePtr,*reNodePtr;long	slot;	if (gNumObjects == (MAX_OBJECTS-1))			// check for overflow		return(nil);		slot = newObjDef->slot;					/* INITIALIZE NEW NODE */		newNodePtr = gFreeNodeStack[gNodeStackTop];	// get new node from stack	gNodeStackTop++;	newNodePtr->SortSlot = slot;	newNodePtr->Type = newObjDef->type;	newNodePtr->AnimNum = newObjDef->animNum;	newNodePtr->MoveCall = newObjDef->moveCall;		// save move routine	newNodePtr->Genre = newObjDef->genre;	newNodePtr->Coord = newObjDef->coord;	newNodePtr->ModeFlags = newObjDef->flags|OBJ_MODE_MOVE;	newNodePtr->Flag[0] = 	newNodePtr->Flag[1] = 	newNodePtr->Flag[2] = 	newNodePtr->Flag[3] = 	newNodePtr->CType =							// must init ctype to something ( INVALID_NODE_FLAG might be set from last delete)	newNodePtr->CBits =	newNodePtr->Velocity.x =	newNodePtr->Velocity.y = 	newNodePtr->Velocity.z = 	newNodePtr->RotX =	newNodePtr->RotY = 	newNodePtr->RotZ = 0;	newNodePtr->ScaleX =	newNodePtr->ScaleY = 	newNodePtr->ScaleZ = 1.0;			newNodePtr->BaseGroup = nil;										/* FIND INSERTION PLACE FOR NODE */						if (gFirstNodePtr == nil)							// special case only entry	{		gFirstNodePtr = newNodePtr;		newNodePtr->PrevNode = nil;		newNodePtr->NextNode = nil;	}	else	if (slot < gFirstNodePtr->SortSlot)				// INSERT AS FIRST NODE	{		newNodePtr->PrevNode = nil;					// no prev		newNodePtr->NextNode = gFirstNodePtr; 		// next pts to old 1st		gFirstNodePtr->PrevNode = newNodePtr; 		// old pts to new 1st		gFirstNodePtr = newNodePtr;	}	else	{		reNodePtr = gFirstNodePtr;		scanNodePtr = gFirstNodePtr;					while (scanNodePtr != nil)		{			if (slot < scanNodePtr->SortSlot)			// INSERT IN MIDDLE HERE			{				newNodePtr->NextNode = scanNodePtr;				newNodePtr->PrevNode = reNodePtr;				reNodePtr->NextNode = newNodePtr;				scanNodePtr->PrevNode = newNodePtr;							goto out;			}			reNodePtr = scanNodePtr;			scanNodePtr=(ObjNode *)scanNodePtr->NextNode;	// try next node		} 			newNodePtr->NextNode = nil;							// TAG TO END		newNodePtr->PrevNode = reNodePtr;		reNodePtr->NextNode = newNodePtr;			}out:	gNumObjects++;											// its done	gMostRecentlyAddedNode = newNodePtr;					// remember this	return(newNodePtr);}/*******************************  MOVE OBJECTS **************************/void MoveObjects(void){ObjNode		*thisNodePtr;					if (gFirstNodePtr == nil)								// see if there are any objects		return;	thisNodePtr = gFirstNodePtr;		do	{					/* NEXT TRY TO MOVE IT */							if ((thisNodePtr->ModeFlags & OBJ_MODE_MOVE) && (thisNodePtr->MoveCall != nil))		{			gCurrentNode = thisNodePtr;						// set current object node			thisNodePtr->MoveCall();						// call object's move routine		}					thisNodePtr = (ObjNode *)thisNodePtr->NextNode;		// next node	}	while (thisNodePtr != nil);}/**************************** DRAW OBJECTS ***************************/void DrawObjects(QD3DSetupOutputType *viewInfo){ObjNode		*theNode;TQ3Status	myStatus;	if (gFirstNodePtr == nil)				// see if there are any objects		return;	theNode = gFirstNodePtr;						/* MAIN NODE TASK LOOP */				do	{		if (theNode->ModeFlags & OBJ_MODE_DRAW)		{				if (theNode->BaseGroup)				// see if group exists				{									myStatus = Q3Object_Submit(theNode->BaseGroup,viewInfo->viewObject);					if ( myStatus == kQ3Failure )						DoFatalAlert("\p Drawing Q3Object_Submit Failed!");					break;							}		}		theNode = (ObjNode *)theNode->NextNode;	}while (theNode != nil);}/******************** DELETE ALL OBJECTS ********************/void DeleteAllObjects(void){	while (gFirstNodePtr != nil)		DeleteObject(gFirstNodePtr);}/************************ DELETE OBJECT ****************/void DeleteObject(ObjNode	*theNode){ObjNode *tempNode;	if (theNode == nil)								// see if passed a bogus node		return;	if (theNode->CType == INVALID_NODE_FLAG)		// see if already deleted	{		Str255	errString;		//-----------		DoAlert("\pAttempted to Double Delete an Object.  Object was already deleted!");		NumToString(theNode->Type,errString);		//------------		DoFatalAlert(errString);					//---------	}			/* PURGE SPECIAL DATA */				if(theNode->BaseGroup)	{		Q3Object_Dispose(theNode->BaseGroup);		theNode->BaseGroup = nil;		}								/* DO NODE SWITCHING */	if (theNode->PrevNode == nil)					// special case 1st node	{		gFirstNodePtr = (ObjNode *)theNode->NextNode;				tempNode = (ObjNode *)theNode->NextNode;		tempNode->PrevNode = nil;	}	else if (theNode->NextNode == nil)				// special case last node	{		tempNode = (ObjNode *)theNode->PrevNode;		tempNode->NextNode = nil;	}	else											// generic middle deletion	{		tempNode = (ObjNode *)theNode->PrevNode;		tempNode->NextNode = theNode->NextNode;		tempNode = (ObjNode *)theNode->NextNode;		tempNode->PrevNode = theNode->PrevNode;	}	gNodeStackTop--;								// put node back on stack	gFreeNodeStack[gNodeStackTop] = &gObjectNodeList[theNode->NodeNum];	gNumObjects--;									// 1 less obj		theNode->CType = INVALID_NODE_FLAG;				// INVALID_NODE_FLAG indicates its deleted}/********************** GET OBJECT INFO *********************/void GetObjectInfo(ObjNode *theNode){	gCoord = theNode->Coord;	gVelocity = theNode->Velocity;}/********************** UPDATE OBJECT *********************/void UpdateObject(ObjNode *theNode){	theNode->Coord = gCoord;	theNode->Velocity = gVelocity;}/************* MAKE NEW DISPLAY GROUP OBJECT *************/ObjNode *MakeNewDisplayGroupObject(NewObjectDefinitionType *newObjDef){ObjNode	*newObj;	newObjDef->genre = DISPLAY_GROUP_GENRE;	newObj = MakeNewObject(newObjDef);			if (newObj == nil)		return(nil);	CreateBaseGroup(newObj);	return(newObj);}/************************* ADD GEOMETRY TO DISPLAY GROUP OBJECT ***********************///// Attaches a geometry object to the BaseGroup object. MakeNewDisplayGroupObject must have already been// called which made the group & transforms.//void AttachGeometryToDisplayGroupObject(ObjNode *theNode, TQ3GeometryObject geometry){TQ3GroupPosition	groupPosition;	groupPosition = Q3Group_AddObject(theNode->BaseGroup,geometry);	if (groupPosition == nil)		DoFatalAlert("\pError: AttachGeometryToDisplayGroupObject");}/***************** CREATE BASE GROUP **********************///// the base group contains the base translation/rotation transforms// plus the link to the heirarchial chain of joint objects if its a skeleton object.//// NOTE: this is not only used for skeleton objects, but also for display group objects!!!//void CreateBaseGroup(ObjNode *theNode){TQ3GroupPosition		myGroupPosition;TQ3Matrix4x4			transMatrix,scaleMatrix;TQ3TransformObject		transObject;				/* CREATE THE GROUP OBJECT */					theNode->BaseGroup = Q3DisplayGroup_New();	if (theNode->BaseGroup == nil)		DoFatalAlert("\p Couldnt allocate BaseGroup!");					/* SETUP BASE MATRIX */				Q3Matrix4x4_SetRotate_XYZ(&theNode->BaseTransformMatrix,		// init rotation matrix								 theNode->RotX, theNode->RotY,								 theNode->RotZ);	Q3Matrix4x4_SetTranslate(&transMatrix, theNode->Coord.x, theNode->Coord.y,	// make translate matrix							 theNode->Coord.z);	Q3Matrix4x4_Multiply(&theNode->BaseTransformMatrix,				// mult rot & trans matrices						 &transMatrix,						 &theNode->BaseTransformMatrix);	Q3Matrix4x4_SetScale(&scaleMatrix, theNode->ScaleX,						 theNode->ScaleY,						 theNode->ScaleZ);	Q3Matrix4x4_Multiply(&theNode->BaseTransformMatrix,				// mult rot & trans matrices						 &scaleMatrix,						 &theNode->BaseTransformMatrix);					/* CREATE A MATRIX XFORM */	transObject = Q3MatrixTransform_New(&theNode->BaseTransformMatrix);	myGroupPosition = Q3Group_AddObject(theNode->BaseGroup, transObject);	// add to base group	if (myGroupPosition == 0)		DoFatalAlert("\pQ3Group_AddObject Failed!");	theNode->BaseTransformObject = transObject;								// keep illegal ref	Q3Object_Dispose(transObject);}/****************** UPDATE OBJECT TRANSFORMS *****************///// This updates the skeleton object's base translate & rotate transforms//void UpdateObjectTransforms(ObjNode *theNode){TQ3Matrix4x4	scaleMatrix;					/* RESET BASE MATRIX */				Q3Matrix4x4_SetRotate_XYZ(&theNode->BaseTransformMatrix,		// init rotation matrix								 theNode->RotX, theNode->RotY,								 theNode->RotZ);	TranslateObjectBaseMatrixByXYZ(theNode);															Q3Matrix4x4_SetScale(&scaleMatrix, theNode->ScaleX,		// do scale						 theNode->ScaleY,						 theNode->ScaleZ);	TransformObjectBaseMatrix(theNode,&scaleMatrix);								SetObjectTransformMatrix(theNode);}/***************** SET OBJECT TRANSFORM MATRIX *******************///// This call simply resets the base transform object so that it uses the latest// base transform matrix//void SetObjectTransformMatrix(ObjNode *theNode){TQ3Status 				error;	error = Q3MatrixTransform_Set(theNode->BaseTransformObject,&theNode->BaseTransformMatrix);	if (error != kQ3Success)		DoFatalAlert("\pQ3MatrixTransform_Set Failed!");}/******************** TRANSLATE OBJECT BASE MATRIX BY X/Y/Z  *******************/void TranslateObjectBaseMatrixByXYZ(ObjNode *theNode){TQ3Matrix4x4			transMatrix;	Q3Matrix4x4_SetTranslate(&transMatrix, theNode->Coord.x, theNode->Coord.y,	// make translate matrix							 theNode->Coord.z);							 	TransformObjectBaseMatrix(theNode,&transMatrix);}/***************** TRANSFORM OBJECT BASE MATRIX ******************///// This multiplies the current BaseTransformMatrix by the input transform matrix.//void TransformObjectBaseMatrix(ObjNode *theNode, TQ3Matrix4x4 *inMatrix){	Q3Matrix4x4_Multiply(&theNode->BaseTransformMatrix,							 inMatrix,						 &theNode->BaseTransformMatrix);}