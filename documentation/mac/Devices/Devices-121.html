<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>About the SCSI Manager(IM: D)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING121></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="Devices-120.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-122.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Devices-2.html"><B>Devices</B></A> / <BR><DD><A HREF="Devices-119.html"><B>Chapter 3 - SCSI Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING121-0></A>
<H1><A NAME=MARKER-9-29></A>About the SCSI Manager</H1>
 The SCSI Manager provides routines that allow Macintosh device drivers and other programs to communicate with SCSI peripheral devices using the SCSI protocol.<P>
 The SCSI Manager is a software layer that mediates between device drivers or applications and the SCSI controller hardware in the Macintosh computer. In some cases, the amount of mediation is small. For example, the SCSI Manager <CODE>SCSIReset</CODE> function does little except assert the reset signal on the SCSI bus. In other cases, a single SCSI Manager function may initiate a relatively complex series of actions.<P>
 <A HREF=#MARKER-9-30>Figure 3-2</A> shows the relationship of the SCSI Manager to the Macintosh system architecture. The architecture consists of multiple layers: the application layer, the system software layer (which is composed of several subordinate layers), and the hardware layer. <P>
<B>Figure 3-2  <A NAME=MARKER-9-30></A>The role of the SCSI Manager</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/SCSI-L-02.jpg"><p>
 Application programs usually rely on high-level services such as those provided by the File Manager, but may also call low-level services directly. The File Manager calls the Device Manager, which calls the appropriate device driver. SCSI device drivers do not control SCSI hardware directly; they use the SCSI Manager to communicate with SCSI devices. <P>
<A NAME=HEADING121-7></A>
<H2><A NAME=MARKER-9-31></A>Conformance With the SCSI Specification</H2>
 The <A NAME=MARKER-2-167></A>SCSI specification has been revised considerably since the first Macintosh SCSI implementation. For information about the SCSI standard as originally defined, see ANSI document X3.131-1986, <I>Small Computer System Interface</I>. Many of the features described in the newer SCSI-2 specification are supported by SCSI Manager 4.3. However, the original SCSI Manager predates these extensions.<P>
 Due to hardware variations among Macintosh models, there are minor differences in the behavior of some SCSI Manager routines. These differences lie mostly outside the scope of the SCSI protocol. For information about these differences, see the description of the <CODE>SCSIGet</CODE> function on <A HREF=Devices-138.html#MARKER-9-144>page 3-32</A>.<P>
 All Macintosh computers support these aspects of the SCSI specification:<P>
<UL>
<LI>multiple targets
<LI>as many as eight devices on the bus (the computer and up to seven peripherals)
<LI>parity generation<P>
</UL>
 The following optional features of the SCSI specification are not supported by the original SCSI Manager:<P>
<UL>
<LI>multiple SCSI buses
<LI>multiple initiators on a single bus
<LI>disconnect/reconnect
<LI>parity error detection<P>
</UL>
<DL>
<DT><B>SCSI Manager 4.3 Note</B>
<DD>These features and other enhancements are supported by SCSI Manager 4.3. <EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING121-21></A>
<H2>Overview of SCSI Manager Data Structures</H2>
 The SCSI specification and the Macintosh Operating System define a number of data structures for communicating with SCSI devices. These data structures fall into three categories:<P>
<UL>
<LI>structures defined by the SCSI specification, such as command descriptor blocks and SCSI messages
<LI>structures specific to the SCSI Manager, such as transfer instruction blocks and the 16-bit status word returned by the <CODE>SCSIStat</CODE> function
<LI>structures required for the proper operation of SCSI disk drives with the Start Manager and the File Manager; for example, the driver descriptor map and the partition map<P>
</UL>
 The command descriptor block and other data structures defined by the SCSI specification are not discussed in detail in this chapter. Refer to the SCSI specification for complete information about these structures. See <A HREF=Devices-122.html#MARKER-9-52>"Using CDB and TIB Structures," beginning on page 3-17</A>, for an example of how to send a CDB to a SCSI device.<P>
 Although the driver descriptor map and the partition map are not used by the SCSI Manager, they must be present on all block devices compatible with the Macintosh Operating System. These structures are discussed in the following section.<P>
 <A NAME=MARKER-2-132></A>A <B>transfer instruction block (TIB)</B> is a Macintosh-specific data structure that your program uses to pass instructions to the SCSI Manager. TIB structures are used to control data transfers, and for other purposes such as comparing data on a peripheral device with data in memory. TIB structures are passed as parameters to the SCSI Manager <CODE>SCSIRead</CODE>, <CODE>SCSIRBlind</CODE>, <CODE>SCSIWrite</CODE>, and <CODE>SCSIWBlind</CODE> functions. For read operations, the TIB specifies a memory location where the data should be stored. For write operations, the TIB specifies the location of the data to be written. <P>
 Although a transfer instruction block is data, not machine-executable code, it is analogous to code in that the data is interpreted and executed by the SCSI Manager in a manner similar to executing a program. The <CODE>SCSIInstr</CODE> data type defines a transfer instruction block.<P>
<PRE>
TYPE SCSIInstr =           {transfer instruction block}
RECORD
   scOpcode:   Integer;    {operation code}
   scParam1:   LongInt;    {first parameter}
   scParam2:   LongInt;    {second parameter}
END;
</PRE>
 The first field of the transfer instruction block contains a transfer operation code. This code is not a command in the SCSI protocol, but rather an instruction to the SCSI Manager that directs the transfer of data across the SCSI bus after a SCSI command has been sent. The instruction set consists of eight operation codes that allow you to transfer data, increment a counter, and form iterative loops. See <A HREF=Devices-127.html#MARKER-9-120>"SCSI Manager TIB Instructions," beginning on page 3-27</A>, for details of the TIB instruction set.<P>
 A sequence of TIB instructions is also known as a <B>TIB pseudoprogram</B>. Here is an example of a TIB pseudoprogram:<P>
<PRE>
scInc    $67B50   512
scLoop   -10      6
scStop
</PRE>
 This sample pseudoprogram consists of three TIB instructions that transfer six 512-byte blocks of data to or from address $67B50 (depending on whether these instructions are passed to a <CODE>SCSIRead</CODE> or a <CODE>SCSIWrite</CODE> function).<P>
 The first TIB instruction transfers a 512-byte block of data from a starting address and then increments that address by the amount of data transferred. The second TIB instruction branches back to the first (by branching back 10 bytes, which is the size of a TIB instruction), and forms a loop that is executed six times (as specified by the second parameter). The third and final TIB instruction terminates the execution sequence and returns to the calling routine.<P>
 See <A HREF=Devices-122.html#MARKER-9-52>"Using CDB and TIB Structures," beginning on page 3-17</A>, for an example of how to use TIB instructions.<P>
<A NAME=HEADING121-37></A>
<H2><A NAME=MARKER-2-169></A><A NAME=MARKER-9-35></A>The Structure of Block Devices</H2>
 <A NAME=MARKER-2-28></A>This section describes the low-level organization of data on random-access storage devices such as SCSI hard disk drives. Although this information is presented in the context of the SCSI Manager, it applies to any type of block device that can be used by the Macintosh Operating System, regardless of the hardware interface.<P>
 There are a number of ways to address data on block-structured storage devices such as disk drives. At the lowest level, a disk drive addresses a block by its cylinder, head, and sector number. The SCSI specification, however, conceals this level of detail. Instead, each block on a SCSI disk is assigned a number, beginning with 0 and extending to the last block on the disk. The SCSI specification describes these addresses as "logical" block numbers, but the SCSI Manager calls them physical block numbers because they correspond to a fixed location on the disk.<P>
 At an even higher level of abstraction, a device driver can define the mapping of physical addresses on a device to the logical addresses of a file system. This allows file systems to be independent of the characteristics of a particular device.<P>
 In the terminology of the SCSI Manager, a <A NAME=MARKER-2-37></A><B>physical block</B> refers to a specific, fixed location defined by the manufacturer of a SCSI device. A <A NAME=MARKER-2-38></A><B>logical block</B> refers to an abstract location defined by software. A <A NAME=MARKER-2-39></A><B>partition</B> is a series of contiguous logical blocks that have been allocated to a particular operating system, file system, or device driver. A disk can be divided into any number of partitions. Locations within these partitions are specified using logical block numbers, which are integer values ranging from 0 to the number of blocks in the partition.<P>
 The low-level organization of block devices is defined by two data structures: the driver descriptor record and the partition map. These structures are introduced in the following sections. See <A HREF=Devices-317.html#MARKER-9-38>"Data Structures," beginning on page 3-23</A>, for a complete description of the fields within these structures.<P>
<A NAME=HEADING121-43></A>
<H3><A NAME=MARKER-2-40></A><A NAME=MARKER-9-41></A>The Driver Descriptor Record</H3>
 The driver descriptor record is a data structure that identifies the device drivers installed on a disk. To support multiple operating systems or other features, a disk can have more than one device driver installed, each in its own partition. The Start Manager reads the driver descriptor record during system startup and uses the information to locate and load the appropriate device driver.<P>
 The driver descriptor record is always located at physical block 0, the first block on the disk. The driver descriptor record is defined by the <CODE>Block0</CODE> data type.<P>
<PRE>
TYPE Block0 = 
PACKED RECORD
   sbSig:         Integer;    {device signature}
   sbBlkSize:     Integer;    {block size of the device}
   sbBlkCount:    LongInt;    {number of blocks on the device}
   sbDevType:     Integer;    {reserved}
   sbDevId:       Integer;    {reserved}
   sbData:        LongInt;    {reserved}
   sbDrvrCount:   Integer;    {number of driver descriptor entries}
   ddBlock:       LongInt;    {first driver's starting block}
   ddSize:        Integer;    {size of the driver, in 512-byte blocks}
   ddType:        Integer;    {operating system type (MacOS = 1)}
   ddPad:         ARRAY [0..242] OF Integer; {additional drivers, if any}
END;
</PRE>
 The driver descriptor record consists of seven fixed fields, followed by a variable amount of driver-specific information. The first field in the driver descriptor record is a signature, which must be set to the value of the <CODE>sbSIGWord</CODE> constant to indicate that the record is valid (meaning that the disk has been formatted). The second field, <CODE>sbBlkSize</CODE>, specifies the size of the blocks on the device, in bytes. The <CODE>sbBlkCount</CODE> field specifies the total number of blocks on the device. The next three fields are reserved. The <CODE>sbDrvrCount</CODE> field specifies the number of drivers that are installed on the disk. The drivers can be located anywhere on the device and can be as large as necessary. <P>
 The <CODE>ddBlock</CODE>, <CODE>ddSize</CODE>, and <CODE>ddType</CODE> fields contain information about the first device driver on the disk. Information about any additional drivers is stored in the <CODE>ddPad</CODE> field, as an array of consecutive <CODE>ddBlock</CODE>, <CODE>ddSize</CODE>, and <CODE>ddType</CODE> fields. <P>
 <A NAME=MARKER-2-183></A><A NAME=MARKER-2-182></A>To select a particular device driver for loading at system startup, you use the Start Manager <CODE>SetOSDefault</CODE> function and specify a value corresponding to the <CODE>ddType</CODE> field in the driver descriptor record.<A NAME=MARKER-2-170></A><P>
<A NAME=HEADING121-50></A>
<H3><A NAME=MARKER-9-45></A><A NAME=MARKER-2-27></A>The Partition Map</H3>
 The partition map is a data structure that describes the partitions present on a block device. The Macintosh Operating System and all other operating systems from Apple use the same partitioning method. This allows a single device to support multiple operating systems.<P>
 The partition map always begins at physical block 1, the second block on the disk. With the exception of the driver descriptor record in block 0, every block on a disk must belong to a partition. <P>
 Each partition on a disk is described by an entry in the partition map. The partition map is itself a partition, and contains an entry describing itself. The partition map entry for the partition map is not necessarily the first entry in the map. Partition map entries can be in any order, and need not correspond to the physical organization of partitions on the disk.<P>
 The number of entries in the partition map is not restricted. However, because the partition map must begin at block 1 and must be contiguous, it cannot easily be expanded once other partitions are created. One way around this limitation is to create a large number of empty partition map entries when the disk is initialized.<P>
 To locate a partition, the Start Manager examines the <CODE>pmMapBlkCnt</CODE> field of the first partition map entry. This field contains the size of the partition map, in blocks. Then, using the block size value from the sbBlkSize field of the driver descriptor record, the Start Manager reads each block in the partition map, looking for a valid signature in the <CODE>pmSIG</CODE> field of each partition map entry record.<P>
 The partition map entry record is defined by the <CODE>Partition</CODE> data type.<P>
<PRE>
TYPE Partition = 
RECORD
   pmSig:         Integer;       {partition signature}
   pmSigPad:      Integer;       {reserved}
   pmMapBlkCnt:   LongInt;       {number of blocks in partition map}
   pmPyPartStart: LongInt;       {first physical block of partition}
   pmPartBlkCnt:  LongInt;       {number of blocks in partition}
   pmPartName:    PACKED ARRAY [0..31] OF Char; {partition name}
   pmParType:     PACKED ARRAY [0..31] OF Char; {partition type}
   pmLgDataStart: LongInt;       {first logical block of data area}
   pmDataCnt:     LongInt;       {number of blocks in data area}
   pmPartStatus:  LongInt;       {partition status information}
   pmLgBootStart: LongInt;       {first logical block of boot code}
   pmBootSize:    LongInt;       {size of boot code, in bytes}
   pmBootAddr:    LongInt;       {boot code load address}
   pmBootAddr2:   LongInt;       {reserved}
   pmBootEntry:   LongInt;       {boot code entry point}
   pmBootEntry2:  LongInt;       {reserved}
   pmBootCksum:   LongInt;       {boot code checksum}
   pmProcessor:   PACKED ARRAY [0..15] OF Char; {processor type}
   pmPad:         ARRAY [0..187] OF Integer;    {reserved}
END;
</PRE>
 The first three fields in a partition map entry record are redundant, in that all entries in the partition map must contain the same values for these fields. The <CODE>pmSig</CODE> field contains the partition map signature, which is defined by the pMapSIG constant. The <CODE>pmSigPad</CODE> field is currently unused and must be set to 0. The <CODE>pmMapBlkCnt</CODE> field contains the size in blocks of the entire partition map. Because this value is duplicated in every entry, you can determine the size of the partition map from any entry in the map.<P>
 The remaining fields of the partition map entry record contain information about a particular disk partition. The <CODE>pmPyPartStart</CODE> field contains the physical block number of the first block of the partition. The <CODE>pmPartBlkCnt</CODE> field contains the number of blocks in the partition. The <CODE>pmPartName</CODE> field can contain an optional 32-character partition name. If this field contains a string beginning with <CODE>Maci</CODE> (for Macintosh), the Start Manager will perform checksum verification of the device driver's boot code. Otherwise, this field is ignored.<P>
 The <CODE>pmParType</CODE> field contains a string that identifies the partition type. Strings beginning with <CODE>Apple_</CODE> are reserved for use by Apple Computer, Inc. The Start Manager uses this information to identify the type of device driver or file system in a partition. A bootable system disk must contain both an <CODE>Apple_Driver</CODE> and an <CODE>Apple_HFS</CODE> partition. See <A HREF=Devices-126.html#MARKER-9-1>page 3-26</A> for a list of the standard partition types defined by Apple.<P>
 For file systems that do not begin at logical block 0 of the partition, the <CODE>pmLgDataStart</CODE> field contains the logical block number of the first block of file system data. The <CODE>pmDataCnt</CODE> field specifies the size of the data area, in blocks. The <CODE>pmPartStatus</CODE> field is currently used only by the A/UX operating system. <P>
 For device driver partitions, the <CODE>pmLgBootStart</CODE> field specifies the logical block number of the first block containing boot code. The <CODE>pmBootSize</CODE> field contains the size in bytes of the boot code. The <CODE>pmBootAddr</CODE> field specifies the memory address where the boot code is to be loaded, while the <CODE>pmBootEntry</CODE> field specifies the address to which the Start Manager will transfer control after loading the boot code into memory. The <CODE>pmBootCksum</CODE> field holds the checksum of the boot code, which the Start Manager can compare against the calculated checksum after loading the code. The <CODE>pmProcessor</CODE> field is a string that identifies the type of processor that will execute the boot code.<P>
 For more information about the startup process and SCSI devices, see the chapter "Start Manager" in <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>.<A NAME=MARKER-9-171></A><A NAME=MARKER-2-184></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="Devices-120.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-122.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Devices-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML>  
