<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>AEObject-Edition Sample - /Subscribe.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">AEObject-Edition Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">AEObject-Edition Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Subscribe.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AEObject-Edition Sample.r</option>
<option value="listing2.html">/AEObject.c</option>
<option value="listing3.html">/AEUtilities.c</option>
<option value="listing4.html">/AppleEventCore.c</option>
<option value="listing5.html">/BuildHeaders.c</option>
<option value="listing6.html">/Files.c</option>
<option value="listing7.html">/globals.c</option>
<option value="listing8.html">/Initialize.c</option>
<option value="listing9.html">/Macros.h</option>
<option value="listing10.html">/main.c</option>
<option value="listing11.html">/Menu.c</option>
<option value="listing12.html">/Print.c</option>
<option value="listing13.html">/prototypes.h</option>
<option value="listing14.html">/Publish.c</option>
<option value="listing15.html">/SampConstants.h</option>
<option value="listing16.html">/Sampdefines.h</option>
<option value="listing17.html">/Structs.h</option>
<option value="listing18.html">/Subscribe.c</option>
<option value="listing19.html">/TextSections.c</option>
<option value="listing20.html">/Utilities.c</option>
<option value="listing21.html">/Windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="AEObject-Edition_Sample.zip">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.zip&#148;, 895.6K)<BR>
<strong><a href="AEObject-Edition_Sample.dmg">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.dmg&#148;, 1.22M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*------------------------------------------------------------------------------**  Apple Developer Technical Support**  Edition subscribing routines**  Program:    AEObject-Edition Sample*  File:       Subscribe.c -   C Source**  by:         C.K. Haun &lt;TR&gt;**  Copyright &copy; 1990-1992 Apple Computer, Inc.*  All rights reserved.**------------------------------------------------------------------------------* This file handles the Subscribe section of the program.  It also handles some of * the common use routines, like the section options dialog.*----------------------------------------------------------------------------*/#define __SUBSCRIBE__#pragma segment Subscribe#include &quot;Sampdefines.h&quot;/* this point tells EM to center our expanded box, if we're using that feature */Point expPoint = {    -1, -1};/* DoSubscribe presents the user with the Subscriber dialog, and allows the user to *//* subscribe to a PICT type edition, anywhere, anytime.  It also stores the *//* section handle returned in the window data structure for the current window *//* You can only subscribe to TEXT if you have a text box open in the current window.  *//* Optionally, of course, you can put in your own conversion of the TEXT to a PICT and *//* subscribe to that as such, same as you would with clipboard types. */void DoSubscribe(void){    OSErr myErr;    SectionHandle secHandle;    windowCHandle shortName;    NewSubscriberReply GetSub;    shortName = (windowCHandle)GetWRefCon(FrontWindow());       /* get our struct */    GetSub.formatsMask = kPICTformatMask;                   /* tell the dialog we only want PICT type editions */    if ((*shortName)-&gt;boxHandle != nil)                     /* is there a text box already? */        GetSub.formatsMask += kTEXTformatMask;    /* GetLastEditionContainerUsed gives you either the last edition container used  */    /* (either pub or sub, since they are the same to the Edition Manager) or if there */    /* was not a previous container, it fills it with a default container. */    GetLastEditionContainerUsed(&amp;GetSub.container);    /* Now ask the user to select an edition to subscribe to */    if (!gExpanded)        myErr = NewSubscriberDialog(&amp;GetSub);    else  {    ExpDlgHookUPP dhUPP = NewExpDlgHookProc(ExpOptHook);    ExpModalFilterUPP mfUPP = NewExpModalFilterProc(ExpOptFilter);        myErr = NewSubscriberExpDialog(&amp;GetSub, expPoint, kExpandedDITL, dhUPP, mfUPP, nil);    DisposeRoutineDescriptor(mfUPP);    DisposeRoutineDescriptor(dhUPP);  }      if (myErr != noErr) {                                   /* bail on fail */        ShowMe(&quot;\pNewSubscriberDialog&quot;, myErr, __LINE__);        return;    }    if (GetSub.canceled)                                    /* did they cancel the dialog? */        return;    HLock((Handle)shortName);    /* Now create a new section record for the container the user picked.  In other words, the */    /* Edition manager keeps track of things by the container, and will give you a section */    /* record that refers to it for you to keep track with.  */    /* *** NOTE: Whenever the Edition Manager gives you memory (like the section handle) */    /* it came out of your heap, and YOU are responsible for disposing of it when you are */    /* completely done (and have UnRegistered) the section.  If you're not careful about this */    /* then you'll get creeping memory loss.  */    /* Now see if the window has ever been saved.  If so, we can store a reference to */    /* the file in the section */    if (GetHandleSize((Handle)(*shortName)-&gt;fileAliasHandle) == 0) {        myErr = NewSection(&amp;GetSub.container, nil, stSubscriber, (*shortName)-&gt;windowID + gSectionID, sumAutomatic, &amp;secHandle);    } else {        /* if the file has been saved once, then we can store a reference to the 'parent' file */        /* in the edition */        FSSpec tempSpec;        Boolean myWasChanged;        myErr = ResolveAlias(nil, ((*shortName)-&gt;fileAliasHandle), &amp;tempSpec, &amp;myWasChanged);        myErr = NewSection(&amp;GetSub.container, &amp;tempSpec, stSubscriber, (*shortName)-&gt;windowID + gSectionID, sumAutomatic,                           &amp;secHandle);    }    if (myErr != noErr) {        ShowMe(&quot;\pNewSection&quot;, myErr, __LINE__);        return;    }    /* section successfully gotten.  Add it to the current window section list please */    /* Handle this in whatever way is appropriate for your application, of course.  */    /* The main point to remember is that you _must_ keep track of the section handles, */    /* they are your method (only method) for comunication between your application */    /* and the Edition Manager, you will be passing sections to the EM, and it will be */    /* passing them back to you. */    gSectionID++;                                           /* increment our unique ID */    StoreSubscriber(shortName, secHandle, nil, nil);    HUnlock((Handle)shortName);}/* end DoSubscribe *//* DoOptions handles the SectionOptions menu selection.  The handle passed *//* (inSection) is a subscriber OR publisher section, the Edition Manager will figure *//* out what dialog to display by looking at the section record *//* *** BE CAREFUL with the section  handle you pass to the options dialog (or anywhere, for that matter) *//* A section that has not been registered, or a section containing a bad alias handle, will *//* cause the options dialog to blow up in unusual and fun ways *//* This call also includes the expanded section options dialog box with one *//* extra item, to show how it's used. */void DoOptions(SectionHandle inSection){    OSErr myErr;    SectionOptionsReply oreply;    Boolean subExpansion;        oreply.sectionH = inSection;                            /* put the section passed in the reply record */    if ((*inSection)-&gt;kind == stSubscriber)        subExpansion = true;    else        subExpansion = false;    myErr = IsRegisteredSection(inSection);    if (myErr != noErr) {        ShowMe(&quot;\p Bad Section &quot;, myErr, __LINE__);        return;    }    if (subExpansion) {    ExpDlgHookUPP dhUPP = NewExpDlgHookProc(SubExpOptHook);    ExpModalFilterUPP mfUPP = NewExpModalFilterProc(SubExpOptFilter);        myErr = SectionOptionsExpDialog(&amp;oreply, expPoint, kExpandedSubDITL, dhUPP, mfUPP, nil);      DisposeRoutineDescriptor(dhUPP);      DisposeRoutineDescriptor(mfUPP);  } else {        if (!gExpanded)            myErr = SectionOptionsDialog(&amp;oreply);          /* run the dialog */        else    {      ExpDlgHookUPP dhUPP = NewExpDlgHookProc(ExpOptHook);      ExpModalFilterUPP mfUPP = NewExpModalFilterProc(ExpOptFilter);            myErr = SectionOptionsExpDialog(&amp;oreply, expPoint, kExpandedDITL, dhUPP, mfUPP, nil);      DisposeRoutineDescriptor(dhUPP);      DisposeRoutineDescriptor(mfUPP);    }    }    if (myErr != noErr) {        ShowMe(&quot;\pSection Options&quot;, myErr, __LINE__);        return;    }    if (oreply.canceled)                                    /* if user canceled */        return;    if (oreply.action == sectionReadMsgID) {        /* if the user clicked 'Get Edition Now' you'll call your section read routine, the same */        /* one that gets called on a sect read AppleEvent */        MyReadSection(inSection);    } else {        if (oreply.action == sectionWriteMsgID) {            /* if the user clicked 'Send Edition Now' you'll call your section write routine, the same */            /* one that gets called on a sect writ AppleEvent */            MyUpdateEdition(inSection);        } else {            if (oreply.action == 'goto') {  /* why isn't there a constant fo this? */                /* this is the sect scrl (section scroll) event from the dialog */                /* the dialog has already taken the action for you, that's it's job */            } else {                if (oreply.action == emCancelSectionDialogRefCon) {                    /* This is for canceling a section, either pub or sub, you have to make the */                    /* choice based on what the section is */                    SectionType tempST;                    HLock((Handle)inSection);                    tempST = (*inSection)-&gt;kind;            /* what kinda thing is this? */                    HUnlock((Handle)inSection);                                        MyCancelSection(inSection, FindSection(inSection));                }            }        }    }}/* end DoOptions *//* AEReadSectionHandler is the handler I installed in the AppleEvent manager list for *//* AppleEvents of the type 'sect' 'read'.  What this means is that whenever I get a *//* high level event of the type 'sect' 'read' this routine will be dispatched to when I *//* call AEProcessAppleEvent (in AppleEventM.c).   This is where the actual section data *//* gets read in, when the Edition Manager tells you the edition is ready to read */pascal OSErr AEReadSectionHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){#pragma unused (reply,refIn)    SectionHandle theSection;    OSErr myErr;        myErr = GetSectionHandleFromEvent(messagein, &amp;theSection);      /* in AppleEventM.c */    if (myErr) {        ShowMe(&quot;\pGetSectionHandleFromEvent&quot;, myErr, __LINE__);        return(myErr);    }    /* This next step is very important.  Unexpected things can happen to you, */    /* a section could disappear between the time an event gets posted and when it */    /* finally gets to your application (particularly since AppleEvents are the lowest in */    /* the event hierarchy), the section may have been canceled, deleted, disk off-line, or */    /* whatever.  You must make a current check with the EM to see if the section that */    /* you are supposed to read. */    myErr = IsRegisteredSection((SectionHandle)theSection);    if (myErr) {        ShowMe(&quot;\pRead IsRegisteredSection&quot;, myErr, __LINE__);        return(myErr);    }    /* It is a valid section.  Jump to my routine that opens and reads it */    MyReadSection(theSection);}/* end AEReadSectionHandler *//* MyReadSection opens and reads the edition data into my window data structure. */OSErr MyReadSection(SectionHandle theSection){    OSErr myErr;    EditionRefNum sRefNum=0;    Size dataSize;    Boolean existed = false;                                /* for setting the display rect */    /* open the edition and get a ref number */    SpinCursor();    myErr = OpenEdition(theSection, &amp;sRefNum);    if (myErr) {        if(sRefNum)CloseEdition(sRefNum,true);    ShowMe(&quot;\pOpenEdition&quot;, myErr, __LINE__);        return(myErr);        }    /* Here we are double-checking the edition.  I'm first checking for PICT data, */    /* and as a handy side effect, it gives us the size of the data (returned in my */    /* variable dataSize) for us to use when we read it later */            if (noErr == (myErr = EditionHasFormat(sRefNum, kGenericPICTWord, &amp;dataSize))) {        /* It does have a pict, read it in */        register  jj;                                    /* loop vars for window search */        long subIDtofind;                /*  There is already a handle allocated for this picture in the window structure.         *   Find it, resize it (since the edition size could have changed) and fill it.        *       Keep in mind that the section read may happen for a window which is not         *       frontmost, so we need to search all the windows to find the ID */        WindowPtr tempPort;        Boolean secFound = false;        SectionHandle *tempPtr;        SectionRecord *tempRecord;        Handle tempHandle;        WindowPtr tempNextWindow;        Rect *tempRect;        Rect holdRect;    SpinCursor();        HLock((Handle)theSection);        subIDtofind = (*theSection)-&gt;sectionID;             /* what ID are we reading?  */        /* check to see if this is the clipboard's section.  If so, let the clipboard */        /* handle it */        if ((subIDtofind == (*gClipSection)-&gt;sectionID) &amp;&amp; (gClipSection != nil)){            return(ReadClipSection(dataSize, sRefNum));      }        GetPort(&amp;tempPort);                                 /* save the current port */        /* search window list now */        tempNextWindow = (WindowPtr)LMGetWindowList();                         /* start at the beginning of the chain */        while (tempNextWindow) {            SpinCursor();      if (((WindowPeek)tempNextWindow)-&gt;windowKind == kDocumentWindow) {                windowCHandle tempWC;                /* do housekeeping to get to the section handle list */                tempWC = (windowCHandle)GetWRefCon(tempNextWindow);                HLock((Handle)tempWC);                tempHandle = (*tempWC)-&gt;subs;               /* handle containing SectionHandles */                HLock(tempHandle);                tempPtr = (SectionHandle *)*tempHandle;                /* Loop through all our sections until we find this edition */                for (jj = 0; jj &lt; (*tempWC)-&gt;numSubs; jj++) {                    Handle *newTemp;          SpinCursor();                    HLock((Handle)*tempPtr);                    tempRecord = *(*tempPtr);                    if (tempRecord-&gt;sectionID == subIDtofind) {                        /* found the section belonging to this read. */                        /* can't break, since it is conceiveable that the user has more that one subscription in this document */                        SetPort(tempNextWindow);            /* set the port to the window we found the section in */                        HLock((*tempWC)-&gt;subDataHandle);                        newTemp = (Handle *)*((*tempWC)-&gt;subDataHandle);                        newTemp += jj;                        /* if the dataSize returned was -1 then the size was unknown when opened.  */                        /* in this case, this should only happen with our special opener.  */                        /* So, if it is -1, then we'll have to handle the read */                        /* in a series of steps to get the right amount of data */                        /* For now, I'll leave that out until I put in a custom */                        /* opener. Watch this space */                        if (dataSize != -1) {                            HUnlock(*newTemp);                            MySetHandleSize(*newTemp, dataSize);                            HLock(*newTemp);                        }            SpinCursor();            /* read the pict in */                        myErr = MyReadEditionData(**newTemp, kGenericPICTWord, sRefNum, &amp;dataSize);                        /* ***** NOTE: After much discussion with our Human Interface folks and the */                        /* Edition Manager engineer, we've decided that the interface guidelines */                        /* for editions will say that reading a subscription does _not_ dirty */                        /* a document.  A lot of soul-searching went on to make this decision, and */                        /* we decided this way primarily to keep the user from getting confused.  */                        /* Editions should be as transparent and automatic as possible, and reminding */                        /* the user that an edition is a 'special' thing that they have to do */                        /* unusual things with to make work right will remove some of that */                        /* automation.  Of course, the 'cached' version of the subscription that */                        /* you save with the document should be updated when the subscription changes */                        /* So, the following line was commented out. */                        /* (*tempWC)-&gt;windowDirty = true;  */                        /* mark window dirty on every read */                        holdRect = (*(PicHandle)(*newTemp))-&gt;picFrame;                        HUnlock(*newTemp);                        /* put the picture in the corner, if it didn't exist.  If it did, adjust the rect as                        *   required */                        HLock((*tempWC)-&gt;subRects);                        newTemp = (Handle *)*((*tempWC)-&gt;subRects);                        newTemp += jj;                        /* if the handle is the size of a rect, I've seen this edition before */                        if (GetHandleSize(*newTemp) == sizeof(Rect)) {                            existed = true;                 /* it's already been made */                        } else {                            HUnlock(*newTemp);                            MySetHandleSize(*newTemp, sizeof(Rect));        /* new subscription */                        }                        HLock(*newTemp);                        tempRect = (Rect *)*(*newTemp);                        if (!existed) {                            tempRect-&gt;top = tempRect-&gt;left = 0;                            tempRect-&gt;bottom = holdRect.bottom - holdRect.top;                            tempRect-&gt;right = holdRect.right - holdRect.left;                        } else {                            InvalRect(tempRect);            /* refresh the old image if the thing was resized */                            /*          tempRect-&gt;bottom = tempRect-&gt;top + (holdRect.bottom - holdRect.top);                            tempRect-&gt;right = tempRect-&gt;left + (holdRect.right - holdRect.left);                            */                        }                        InvalRect(tempRect);                        HUnlock(*newTemp);                        HUnlock((Handle)*tempPtr);                                            } else {                        HUnlock((Handle)*tempPtr);                        tempPtr += 1;                    }                }                                           /* section handle loop jj */                HUnlock(tempHandle);                HUnlock((Handle)tempWC);                /* *** NOTE: You'll notice that there is no break or exit from this section searching loop */                /* Why?  Because there may be many subscribers to the same edition.  The user may */                /* have multiple subscribtions in the same window, or in any of his or her windows. */                /* Don't assume that there is only one subscriber (unless you require it, which may be */                /* reasonable for a single document but _not_ for a multi-document application), run */                /* your whole list each time to be certain everything gets refreshed */            }                                               /* if document */      SpinCursor();            tempNextWindow = (WindowPtr)((WindowPeek)tempNextWindow)-&gt;nextWindow;        }                                                   /* window loop qq */        SetPort(tempPort);                                  /* reset the port to what it was when we entered */    } else {        if (noErr == (myErr = EditionHasFormat(sRefNum, kGenericTEXTWord, &amp;dataSize))) {            WindowPtr theWindow;            windowCHandle tempWC;            TEHandle tempTEH;            mySectionDataHandle theTES;            long tempStart, tempEnd;      SpinCursor();            /* it's a text subscription.  That means we search in the text path, and also need */            /* to update the TEHandle for the window this goes with */            theWindow = FindSection(theSection);            theTES = TextSectionFromSecHandle(theSection);            HLock((Handle)theTES);            tempWC = (windowCHandle)GetWRefCon(theWindow);            tempTEH = (*tempWC)-&gt;boxHandle;            /* save the current TE selection range so that the user is returned to the */            /* place he or she was before we did the reading, so the text doesn't jump */            /* around all loony on them */            tempStart = (*tempTEH)-&gt;selStart;            tempEnd = (*tempTEH)-&gt;selEnd;                        /* first thing we need to do is remove whatever the current sub data in our */            /* TE Record is.  if there is any, o'course */            if ((*theTES)-&gt;startChar != (*theTES)-&gt;endChar) {                TESetSelect((*theTES)-&gt;startChar, (*theTES)-&gt;endChar, (TEHandle)tempTEH);                TEDelete(tempTEH);            }            SetHandleSize((*theTES)-&gt;additionalData, dataSize);            HLock((*theTES)-&gt;additionalData);            MyReadEditionData(*(*theTES)-&gt;additionalData, kGenericTEXTWord, sRefNum, &amp;dataSize);      SpinCursor();            /* that gives us the text.  Now we need to adjust our endpoint */            (*theTES)-&gt;endChar = ((*theTES)-&gt;startChar) + dataSize;            /* set insertion point to where we want to be */            TESetSelect((*theTES)-&gt;startChar, (*theTES)-&gt;startChar, tempTEH);            TEInsert(*(*theTES)-&gt;additionalData, dataSize, tempTEH);            HUnlock((*theTES)-&gt;additionalData);            HUnlock((Handle)theTES);            /* reset insertion point to what it once was */            TESetSelect(tempStart, tempEnd, tempTEH);        }    }}/* end MyReadSection */OSErr MyReadEditionData(Ptr readinPtr, DescType typeToGet, EditionRefNum readRef, Size *howMuch){    OSErr myErr;    if (myErr = ReadEdition(readRef, typeToGet, readinPtr, howMuch))        CloseEdition(readRef, false);    else        CloseEdition(readRef, true);    if(myErr)ShowMe(&quot;\p reading error&quot;,myErr,0);    return(myErr);}/*  HandleSectionSave handles saving and closing of subscribers for *//*       a document.  The Boolean flags tell this function wheither to write *//*       ouut the data [on save or save/close] and weither to UnRegister *//*       the sections [on close]. *//*       The resource fork is open on entry. *//* theWind is locked on entry */void HandleSectionSave(windowCHandle theWind, Boolean writeEm, Boolean dereg, FSSpec *theSpec){    SectionHandle *theSections;    Handle *newTemp;    SectionRecord secRec;    Handle tempHandle;    Rect *tempRectPtr;    register qq;    OSErr myErr;    if ((*theWind)-&gt;numSubs) {        Handle *tempPictPtr;        HLock((*theWind)-&gt;subs);        theSections = (SectionHandle *)*(*theWind)-&gt;subs;        /* and display rectangles */        HLock((*theWind)-&gt;subRects);        HLock((*theWind)-&gt;subDataHandle);        newTemp = (Handle *)*((*theWind)-&gt;subRects);        tempPictPtr = (Handle *)*((*theWind)-&gt;subDataHandle);        /* loop through the sections */        for (qq = 0; qq &lt; (*theWind)-&gt;numSubs; qq++) {        SpinCursor();            /* first update (or create, if needed, the Ed Manger will know) the alias */            myErr = AssociateSection(*theSections, theSpec);            if (myErr)                ShowMe(&quot;\p Assocate&quot;, myErr, __LINE__);                                                /* write the section handle out... */            if (writeEm) {                tempHandle = (Handle)*theSections;                HandToHand(&amp;tempHandle);                HLock((Handle)*theSections);                /* lock down the original section so we can work with it */                secRec = *(*(*theSections));                /* just for easier display below */                AddResource(tempHandle, rSectionType, secRec.sectionID, &quot;&quot;);                /* now do the same with the alias record please */                tempHandle = (Handle)secRec.alias;                HandToHand(&amp;tempHandle);                AddResource(tempHandle, rAliasType, secRec.sectionID, &quot;&quot;);                HUnlock((Handle)*theSections);                /* save off the display rect for this sub */                tempHandle = *newTemp;                HandToHand(&amp;tempHandle);                AddResource(tempHandle, kRECTType, secRec.sectionID, &quot;&quot;);                /* and save out the picture data, so we don't need to immediatly do a */                /* section read when the file is opened */                tempHandle = *tempPictPtr;                HandToHand(&amp;tempHandle);                AddResource(tempHandle, kGenericPICTWord, secRec.sectionID, &quot;&quot;);            }                                               /* writeEm if */                        if (dereg) {                UnRegisterSection(*theSections);                /* and dispose of the alias handle */                DisposeHandle((Handle)*(*(*theSections))-&gt;alias);                /* and the section handle */                DisposeHandle((Handle)*theSections);                /* and the rectangle handle */                DisposeHandle((Handle)*newTemp);                /* picture handle disposed in closewindow */            }            theSections += 1;                               /* go to next section handle please */            newTemp += 1;                                   /* and next rectangle */        }        HUnlock((*theWind)-&gt;subRects);        HUnlock((*theWind)-&gt;subs);    }                                                       /* end subscriber save section */    /* now do the same thing for our publishers please */    /* Of course, here you'll also write the data if pumAutomatic is set */        if ((*theWind)-&gt;numPubs) {        SpinCursor();    HLock((*theWind)-&gt;pubs);        theSections = (SectionHandle *)*(*theWind)-&gt;pubs;        /* and display rectangles */        HLock((*theWind)-&gt;pubRects);        tempRectPtr = (Rect *)*((*theWind)-&gt;pubRects);                /* loop through the sections */        for (qq = 0; qq &lt; (*theWind)-&gt;numPubs; qq++) {      SpinCursor();            /* first update (or create, if needed, the Ed Manger will know) the alias */            AssociateSection(*theSections, theSpec);            /* write the section handle out... */            if (writeEm) {                tempHandle = (Handle)*theSections;                HandToHand(&amp;tempHandle);                HLock((Handle)*theSections);                /* lock down the original section so we can work with it */                secRec = *(*(*theSections));                /* just for easier display below */                AddResource(tempHandle, rSectionType, secRec.sectionID, &quot;&quot;);        SpinCursor();                /* now do the same with the alias record please */                tempHandle = (Handle)secRec.alias;                HandToHand(&amp;tempHandle);                                AddResource(tempHandle, rAliasType, secRec.sectionID, &quot;&quot;);        SpinCursor();                        HUnlock((Handle)*theSections);                /* save off the display rect for this pub */                                tempHandle = NewHandle(sizeof(Rect));                PtrToHand((Ptr)tempRectPtr, &amp;tempHandle, sizeof(Rect));                HandToHand(&amp;tempHandle);                AddResource(tempHandle, kRECTType, secRec.sectionID, &quot;&quot;);        SpinCursor();                        if (secRec.mode == pumOnSave) {                    MyUpdateEdition(*theSections);                    /* and indicate that this was saved with a document */                    (*(*theSections))-&gt;refCon |= kSavedOnce;        /* OR in our saved flag with type */                }            }                                               /* writeEm if for pubs */                        if (dereg) {                UnRegisterSection(*theSections);                /* first see if this publisher has ever been saved with a document.  If it hasn't */                /* then we'll delete it.  */                if (((*(*theSections))-&gt;refCon &amp; 0xf0) == kNeverSaved) {                    OSErr myErr;                    FSSpec deleteSpec;                    Boolean myWasChanged;                    ResolveAlias(nil, ((*(*theSections))-&gt;alias), &amp;deleteSpec, &amp;myWasChanged);          SpinCursor();                              if (myErr = DeleteEditionContainerFile(&amp;deleteSpec)) {                        ShowMe(&quot;\pDelete Editon&quot;, myErr, __LINE__);                    }                }                                /* and dispose of the alias handle */                DisposeHandle((Handle)*(*(*theSections))-&gt;alias);                /* and the section handle */                DisposeHandle((Handle)*theSections);                            }            theSections += 1;                               /* go to next section handle please */            tempRectPtr += 1;                               /* and next rectangle */        }        HUnlock((*theWind)-&gt;pubRects);        HUnlock((*theWind)-&gt;pubs);    }    /* now save off any text sections in this document */    if ((*theWind)-&gt;textSections) {        mySectionDataHandle tempTS = (*theWind)-&gt;textSections;        do {      SpinCursor();            tempHandle = (Handle)(*tempTS)-&gt;theSection;            /* make sure the text is the latest */            RePackText(tempTS, (*theWind)-&gt;boxHandle);            AssociateSection((SectionHandle)tempHandle, theSpec);                        if (writeEm) {                HandToHand(&amp;tempHandle);                myErr = MemError();                if (myErr)                    ShowMe(&quot;\p memerr&quot;, myErr, __LINE__);                HLock(tempHandle);                          /* lock down the original section so we can work with it */                secRec = *(*(SectionHandle)tempHandle);     /* just for easier display below */                AddResource(tempHandle, rSectionType, secRec.sectionID, &quot;&quot;);        SpinCursor();                /* save the alias */                tempHandle = (Handle)secRec.alias;                HandToHand(&amp;tempHandle);                AddResource(tempHandle, rAliasType, secRec.sectionID, &quot;&quot;);        SpinCursor();                /* now save a copy of my whole text record */                                tempHandle = (Handle)tempTS;                HandToHand(&amp;tempHandle);                /* use the same ID number as the section, make things easy */                /* zap any forward link in this, so StoreSection doesn't get */                /* confused when the section is read back in */                (*(mySectionDataHandle)tempHandle)-&gt;nextSection = nil;                (*(mySectionDataHandle)tempHandle)-&gt;additionalData = nil;                (*(mySectionDataHandle)tempHandle)-&gt;theSection = nil;                AddResource(tempHandle, rMyTextRecordType, secRec.sectionID, &quot;&quot;);                                /* and finally, the associated text */                tempHandle = (*tempTS)-&gt;additionalData;                HandToHand(&amp;tempHandle);                AddResource(tempHandle, rMyTextBlock, secRec.sectionID, &quot;&quot;);        SpinCursor();                if (secRec.kind == stPublisher &amp;&amp; secRec.mode == pumOnSave) {                    MyUpdateEdition((*tempTS)-&gt;theSection);                    /* and indicate that this was saved with a document */                    (*(*tempTS)-&gt;theSection)-&gt;refCon |= kSavedOnce;     /* OR in our saved flag with type */                }            }                                               /* text writeem if */                        if (dereg) {                UnRegisterSection((SectionHandle)tempHandle);                /* first see if this publisher has ever been saved with a document.  If it hasn't */                /* then we'll delete it.  */                if (((*(*theSections))-&gt;refCon &amp; 0xf0) == kNeverSaved &amp;&amp; (*(*theSections))-&gt;kind == stPublisher) {                    OSErr myErr;                    FSSpec deleteSpec;                    Boolean myWasChanged;                    ResolveAlias(nil, (*(SectionHandle)tempHandle)-&gt;alias, &amp;deleteSpec, &amp;myWasChanged);                    if (myErr = DeleteEditionContainerFile(&amp;deleteSpec)) {                        ShowMe(&quot;\pSection Save Delete Editon&quot;, myErr, __LINE__);                    }                }                                /* and dispose of the alias handle */                DisposeHandle((Handle)(*(SectionHandle)tempHandle)-&gt;alias);                /* and the section handle */                DisposeHandle((Handle)tempHandle);                            }            tempTS = (*tempTS)-&gt;nextSection;        }                while (tempTS);            }}/* MyCancelSection cancels this section.  It removes  *//*  the section info from our window structure, and also de-registers the *//* section with (from) the Edition Manager.  If it's a publisher, it also  *//* deletes the edition file  */void MyCancelSection(SectionHandle inSection, WindowPtr theWindow){    OSErr myErr;    windowCHandle shortName;    SectionHandle *tempPtr;    Rect *tempRectPtr;    register qq;    FSSpec deleteSpec;    Boolean myWasChanged;    shortName = (windowCHandle)GetWRefCon(theWindow);    HLock((Handle)shortName);        /* first thing to do is deregister the thing */    UnRegisterSection(inSection);    if ((*inSection)-&gt;kind == stPublisher) {                /* only delete publishers */        ResolveAlias(nil, ((*inSection)-&gt;alias), &amp;deleteSpec, &amp;myWasChanged);        if (myErr = DeleteEditionContainerFile(&amp;deleteSpec)) {            ShowMe(&quot;\pCancel Delete Editon&quot;, myErr, __LINE__);        }    }    /* get rid of the alias handle for it */    DisposeHandle((Handle)(*inSection)-&gt;alias);    if ((*inSection)-&gt;kind == stPublisher) {        HLock((*shortName)-&gt;pubs);                          /* lock down my list of section handles */        tempPtr = (SectionHandle *)*(*shortName)-&gt;pubs;        for (qq = 0; qq &lt; (*shortName)-&gt;numPubs; qq++) {            HLock((Handle)*tempPtr);            if ((*inSection)-&gt;sectionID == (*(*tempPtr))-&gt;sectionID) {                DisposeHandle((Handle)inSection);                DisposeHandle((Handle)(*(*tempPtr))-&gt;alias);                DisposeHandle((Handle)*tempPtr);                HLock((*shortName)-&gt;pubRects);                tempRectPtr = (Rect *)*((*shortName)-&gt;pubRects);                tempRectPtr += qq;                if (qq != (*shortName)-&gt;numPubs) {                    register ii;                            /* need to move information down */                    for (ii = qq; ii &lt; ((*shortName)-&gt;numPubs) - 1; ii++) {                        *tempPtr = *(tempPtr + 1);                        *tempRectPtr = *(tempRectPtr + 1);                        tempPtr += 1;                        tempRectPtr += 1;                    }                }                (*shortName)-&gt;numPubs--;                HUnlock((*shortName)-&gt;pubs);                MySetHandleSize((*shortName)-&gt;pubs, GetHandleSize((*shortName)-&gt;pubs) - sizeof(Handle));                HUnlock((*shortName)-&gt;pubRects);                MySetHandleSize((*shortName)-&gt;pubRects, (GetHandleSize((*shortName)-&gt;pubRects) - sizeof(Rect)));                            }        }    } else {                                                /* it's a subscriber */                HLock((*shortName)-&gt;subs);                          /* lock down my list of section handles */        tempPtr = (SectionHandle *)*(*shortName)-&gt;subs;        for (qq = 0; qq &lt; (*shortName)-&gt;numSubs; qq++) {                        HLock((Handle)*tempPtr);            if ((*inSection)-&gt;sectionID == (*(*tempPtr))-&gt;sectionID) {                SectionHandle removeSection;                Handle *tempRectHand;                Handle *tempPicHand;                Handle *tempPicHand2;                removeSection = (*tempPtr);                HLock((Handle)removeSection);                /* When the user cancels a subscription, you do NOT want to delete the */                /* current subscription data (the picture) at this time.  Since the data should be */                /* selectable in the document they are working on (text in a text doc, pic in a */                /* pic doc, etc) they keep the last subscription data, and delete it */                /* seperatly if they'd like */                HLock((*shortName)-&gt;subRects);                HLock((*shortName)-&gt;subDataHandle);                tempRectHand = (Handle *)*((*shortName)-&gt;subRects);                tempPicHand = (Handle *)*((*shortName)-&gt;subDataHandle);                tempRectHand += qq;                tempPicHand += qq;                                /* move the picture over, increase the handle by 1 */                (*shortName)-&gt;numPicts++;                HUnlock((*shortName)-&gt;pictHandle);                MySetHandleSize((*shortName)-&gt;pictHandle, (GetHandleSize((*shortName)-&gt;pictHandle) + sizeof(Handle)));                HLock((*shortName)-&gt;pictHandle);                tempPicHand2 = (Handle *)*(*shortName)-&gt;pictHandle;                tempPicHand2 += ((*shortName)-&gt;numPicts) - 1;                *tempPicHand2 = *tempPicHand;                /* move the rect over also */                HUnlock((*shortName)-&gt;pictRects);                MySetHandleSize((*shortName)-&gt;pictRects, (GetHandleSize((*shortName)-&gt;pictRects) + sizeof(Handle)));                HLock((*shortName)-&gt;pictRects);                tempPicHand2 = (Handle *)*(*shortName)-&gt;pictRects;                tempPicHand2 += ((*shortName)-&gt;numPicts) - 1;                *tempPicHand2 = *tempRectHand;                HUnlock((*shortName)-&gt;pictRects);                HUnlock((*shortName)-&gt;pictHandle);                if ((qq + 1) != (*shortName)-&gt;numSubs) {                    register ii;                            /* need to move information down */                    for (ii = qq; ii &lt; ((*shortName)-&gt;numSubs) - 1; ii++) {                        *tempPtr = *(tempPtr + 1);                        *tempRectHand = *(tempRectHand + 1);                        *tempPicHand = *(tempPicHand + 1);                        tempPtr += 1;                        tempRectHand += 1;                        tempPicHand += 1;                    }                }                (*shortName)-&gt;numSubs--;                HUnlock((*shortName)-&gt;subs);                MySetHandleSize((*shortName)-&gt;subs, GetHandleSize((*shortName)-&gt;subs) - sizeof(SectionHandle));                HUnlock((*shortName)-&gt;subRects);                MySetHandleSize((*shortName)-&gt;subRects, (GetHandleSize((*shortName)-&gt;subRects) - sizeof(Handle)));                            }        }    }    HUnlock((Handle)shortName);    /* and clear the highlight */    if (gShowPub || gShowSub) {        extern Rect gShowPubRect;        extern Rect gShowSubRect;        extern SectionHandle gShowingSecHandle;        gShowPub = gShowSub = false;        gShowingSecHandle = nil;        InvalRect(&amp;gShowPubRect);        InvalRect(&amp;gShowSubRect);    }}/* end MyCancelSection */void StoreSubscriber(windowCHandle shortName, SectionHandle secHandle, Handle inRect, Handle pictIn){    OSErr myErr;    SectionHandle *tempPtr;    Handle *tempPicHand;    Size dataSize;    EditionRefNum sRefNum;    /* first we need to determine if this is a PICT or TEXT subscription, since I'm handling */    /* them differently for drill. */    myErr = OpenEdition(secHandle, &amp;sRefNum);    if (myErr = EditionHasFormat(sRefNum, kGenericPICTWord, &amp;dataSize))        (*secHandle)-&gt;refCon |= kTextType;    else        (*secHandle)-&gt;refCon |= kPictType;    /* Now that little mechanism could screw up, if the formats of the section have been */    /* changed since the subscription was originally created.  But it'll work here */    CloseEdition(sRefNum, true);        /* increase our section handle holding handle by the size of a handle */    if (((*secHandle)-&gt;refCon &amp; 0xf) == kPictType) {        HUnlock((*shortName)-&gt;subs);        MySetHandleSize((*shortName)-&gt;subs, GetHandleSize((*shortName)-&gt;subs) + sizeof(SectionHandle));        HLock((*shortName)-&gt;subs);        /* dereference the handle to our section handles in our window structure */        /* and cast it to a pointer to section handles, since that's what it contains */        tempPtr = (SectionHandle *)((*(*shortName)-&gt;subs) + (sizeof(SectionHandle) * ((*shortName)-&gt;numSubs)));        /* and store our subscriber section */        *tempPtr = (SectionHandle)secHandle;        HUnlock((*shortName)-&gt;subs);                        /* let it float again */        /* Here I'm setting up a handle for the picture data contained in the edition we just */        /* subscribed to, in an array of handles held in the handle subDataHandle  */        HUnlock((*shortName)-&gt;subDataHandle);        MySetHandleSize((*shortName)-&gt;subDataHandle, GetHandleSize((*shortName)-&gt;subDataHandle) + sizeof(Handle));  /* allocate */        HLock((*shortName)-&gt;subDataHandle);        /* deref it */        tempPicHand = (Handle *)*((*shortName)-&gt;subDataHandle);        tempPicHand += ((*shortName)-&gt;numSubs);                if (pictIn == nil)            *tempPicHand = NewHandle(0);                    /* set up a nil handleo */        else            *tempPicHand = pictIn;        /* *** NOTE:  You do _NOT_ read the data contained in this section yet! */        /* All you have done is subscribed to it, the Edition Manager has not told you */        /* that you can read it!  Wait for the section read event (see below) to get the */        /* data.  SO I store an empty handle here as a placeholder */        MoveHHi(*tempPicHand);        HUnlock((*shortName)-&gt;subRects);        MySetHandleSize((*shortName)-&gt;subRects, (GetHandleSize((*shortName)-&gt;subRects) + sizeof(Handle)));  /* allocate a new re*/        myErr = MemError();        if (myErr)            ShowMe(&quot;\pMemory error &quot;, myErr, __LINE__);        HLock((*shortName)-&gt;subRects);        /* generate an empty display rectangle handle also */        tempPicHand = (Handle *)*((*shortName)-&gt;subRects);        tempPicHand += ((*shortName)-&gt;numSubs);                if (inRect == nil)            *tempPicHand = NewHandle(0);                    /* set up a nil handleo */        else            *tempPicHand = inRect;        MoveHHi(*tempPicHand);        (*shortName)-&gt;numSubs++;                            /* increment our count of subscribers */        HUnlock((*shortName)-&gt;subRects);        HUnlock((*shortName)-&gt;subDataHandle);    } else {        if (((*secHandle)-&gt;refCon &amp; 0xf) == kTextType) {        /* double checking here */            mySectionDataHandle newSection;            /* get a new text section record */            if (inRect == nil) {                /* this means that it is being created fresh, so we have to get a */                /* text section record from my routine */                newSection = GetTextSection(shortName, stSubscriber);                /* fill it with stuff relating to the section we just created */                (*newSection)-&gt;publishing = false;                (*newSection)-&gt;theID = (*secHandle)-&gt;sectionID;                (*newSection)-&gt;theSection = secHandle;            } else {                newSection = (mySectionDataHandle)inRect;            }            /* store it in our window structure */            if ((*shortName)-&gt;textSections) {                mySectionDataHandle tempSection = (*shortName)-&gt;textSections;                if ((*shortName)-&gt;textSections) {                    while ((*tempSection)-&gt;nextSection)                        tempSection = (*tempSection)-&gt;nextSection;                }                (*tempSection)-&gt;nextSection = newSection;                            } else {                /* first one */                (*shortName)-&gt;textSections = newSection;            }        }    }}pascal short SubExpOptHook(short itemOffset, short itemHit, DialogPtr theDialog, Ptr yourDataPtr){#pragma unused (yourDataPtr)    short myHit;    short itemType;    ControlHandle theButton;    Rect theRect;    /* first make sure that a sub-dialog is not frontmost */    /* so we don't filter keys or hits to a sub-dialog */    if (GetWRefCon((WindowPtr)theDialog) == sfMainDialogRefCon || GetWRefCon((WindowPtr)theDialog) == emOptionsDialogRefCon) {        /* first see if it's the 'first call' item (see the Standard File chapter).  If it is, then */        /* we preset our check box */        if (itemHit == -1) {            /* this gets the handle to our check box, since we know it's one past the last standard item */            GetDialogItem(theDialog, itemOffset + 1, &amp;itemType, (Handle *)&amp;theButton, &amp;theRect);            SetControlValue(theButton, gResizeSub);             /* and set our current value */        } else {            /* only have one item in this expansion, but we'll check the range anyway to be safe */            myHit = itemHit - itemOffset;                   /* since our item numbers are relative to the total number */            /* of items in the dialog, and the system may change.  Always do your item numbering based */            /* on the offset, this will prevent incompatability when the system dialog grows or shrinks */            if (myHit == 1) {                               /* I only added one item, so this be the one */                /* Pass itemHit here, not myHit, since the dialog manager has no idea that this is an */                /* additive dialog.  It is counting from the actual start of the DITL, not the start of */                /* your custom items */                GetDialogItem(theDialog, itemHit, &amp;itemType, (Handle *)&amp;theButton, &amp;theRect);                if (GetControlValue(theButton))                    gResizeSub = false;                else                    gResizeSub = true;                SetControlValue(theButton, gResizeSub);            }        }    }    return(itemHit);                                        /* the return value must be absolute */}pascal Boolean SubExpOptFilter(DialogPtr theDialog, EventRecord *theEvent, short itemOffset, short *itemHit, Ptr yourDataPtr){#pragma unused (itemHit,yourDataPtr)     short itemType;    ControlHandle theButton;    Rect theRect;    /* first make sure that a sub-dialog is not frontmost */    /* so we don't filter keys or hits to a sub-dialog */    if (GetWRefCon((WindowPtr)theDialog) == sfMainDialogRefCon || GetWRefCon((WindowPtr)theDialog) == emOptionsDialogRefCon) {        /* standard filter proc kinda stuff here */        if ((theEvent-&gt;what) == keyDown) {            char tempChar;            tempChar = theEvent-&gt;message &amp; charCodeMask;                        if (((tempChar == 'A') || (tempChar == 'a')) &amp;&amp; (theEvent-&gt;modifiers &amp; cmdKey)) {                /* they pressed an A with the command key down, we get to handle it. */                GetDialogItem(theDialog, itemOffset + 1, &amp;itemType, (Handle *)&amp;theButton, &amp;theRect);                if (GetControlValue(theButton))                    gResizeSub = false;                else                    gResizeSub = true;                SetControlValue(theButton, gResizeSub);                return(true);                               /* tell folks we handled it */            }        }    }    return(false);                                          /* was not a keystroke we wanted */    }/* DeleteSubscriber is called by a menu command 'Clear' */void DeleteSubscriber(void){  ModalFilterUPP upp = NewModalFilterProc(standardAlertFilter);    if (StopAlert(kCanxSub, upp) == 2) {        MyCancelSection(gShowingSecHandle, FindSection(gShowingSecHandle));            }  DisposeRoutineDescriptor(upp);}/* end DeleteSubscriber *//* PasteSubscription pastes the section (a subscriber) from the clipboard into the *//* frontmost window (as you would expect) */void PasteSubscription(void){        windowCHandle tempWC;    SectionHandle tempHandle;    AliasHandle tempHandle2;    FSSpec newFileSpec;    Boolean myWasChanged;    Rect tempPRect =  {        0, 0, 40, 40    };    long myOffset;    long fred;    Handle tempRectHand = NewHandle(sizeof(Rect));    /* first see if there is a section handle on the clipboard */    /* kill the current section on the clipboard, if there is one */    /* **** NEW, we're looking for section handles and aliases on the clipboard.  */        /* set up a dummy picture for this incoming section.... */    if (!gScrapData)        gScrapData = NewHandle(0);    fred = GetScrap(gScrapData, rSectionType, &amp;myOffset);    if (fred &gt; 0) {                                         /* if there is a section on the clipboard */        myOffset = 0;        /* read in the rect also */                fred = GetScrap(tempRectHand, kRECTType, &amp;myOffset);                if (fred &gt; 0) {            short offH, offV;            /* move the rect to the upper left */            offH = (*(Rect *)*tempRectHand).right - (*(Rect *)*tempRectHand).left;            offV = (*(Rect *)*tempRectHand).bottom - (*(Rect *)*tempRectHand).top;            (*(Rect *)*tempRectHand).left = 0;            (*(Rect *)*tempRectHand).top = 0;            (*(Rect *)*tempRectHand).right = offH;            (*(Rect *)*tempRectHand).bottom = offV;            /* and read in the pict */            myOffset = 0;            GetScrap((Handle)gClipPict, kGenericPICTWord, &amp;myOffset);        } else {            *(Rect *)*tempRectHand = tempPRect;             /* default it */        }    }    HLock(tempRectHand);    tempWC = (windowCHandle)GetWRefCon(FrontWindow());    HLock((Handle)tempWC);    if (gClipPict &amp;&amp; GetHandleSize((Handle)gClipPict)) {        InvalRect((Rect *)*tempRectHand);            } else {        *(Rect *)(*tempRectHand) = tempPRect;    }    /* update the ID of the section to include the master ID of the window yer pasting into */    (*gClipSection)-&gt;sectionID += (*tempWC)-&gt;windowID;    StoreSubscriber(tempWC, gClipSection, tempRectHand, (Handle)gClipPict);    HUnlock((Handle)tempWC);    /* Now, after you paste the subscription, you have to change the subscription on the clipboard. */    /* You need to duplicate it, and assign a new ID number, since if the thing is pasted again */    /* you could have two subscriptions with the same ID, which would not be nice.  So we do this... */    tempHandle = gClipSection;    tempHandle2 = (*gClipSection)-&gt;alias;    HandToHand((Handle *)&amp;tempHandle);    HandToHand((Handle *)&amp;tempHandle2);    (*tempHandle)-&gt;sectionID = gSectionID;    (*tempHandle)-&gt;alias = tempHandle2;    gSectionID++;    /* now register the section so the edition manager knows to send you updates */    ResolveAlias(nil, tempHandle2, &amp;newFileSpec, &amp;myWasChanged);    if ((RegisterSection(&amp;newFileSpec, tempHandle, &amp;myWasChanged))==noErr)        gClipSection = tempHandle;    gClipHasContents = kClipHasSub;    MyReadSection(tempHandle);    }/* CutSubscription and CopySubscription move the current selection in the active window to the *//* ClipBoard.  The main difference here from standard scrap handling is that the scrap you now *//* have is dynamic.  The contents of the clipboard can change if the publisher of this subscription *//* changes, so you must treat this section as you would any other subscriber *//* frontmost window (as you would expect) */void CutSubscription(void){    CopySubscription();    DeleteSubscriber();                                     /* even though they said cut, I want to make sure that they really mean it */}/* CopySubscriber moves the current display subscriber to the clipboard, making a new *//* subscription in the process, since we don't want to have two copies of the same thing */void CopySubscription(void){    SectionHandle tempHandle;    AliasHandle tempHandle2;    FSSpec newFileSpec;    Boolean myWasChanged;    /* First check to see if there is already a section to remove */    if (gClipHasContents == kClipHasSub) {        KillClipSub();    }    tempHandle = gShowingSecHandle;    /* copy the alias also */    tempHandle2 = (*gShowingSecHandle)-&gt;alias;    HandToHand((Handle *)&amp;tempHandle);    HandToHand((Handle *)&amp;tempHandle2);    /* create a unique ID for this section.  I'll just use the next section ID */    (*tempHandle)-&gt;sectionID = gSectionID;    (*tempHandle)-&gt;alias = tempHandle2;    gSectionID++;    /* now register the section so the edition manager knows to send you updates */    ResolveAlias(nil, tempHandle2, &amp;newFileSpec, &amp;myWasChanged);    if ((RegisterSection(&amp;newFileSpec, tempHandle, &amp;myWasChanged))==noErr)        gClipSection = tempHandle;    gClipPict = (PicHandle)NewHandle(0);                    /* allocate an empty handle for this picture data */    gClipHasContents = kClipHasSub;    /* write the section handle out to the cipboard */    ZeroScrap();    PutScrap(sizeof(Handle), rSectionType, (Ptr)&amp;tempHandle);    PutScrap(sizeof(Rect), kRECTType, (Ptr)&amp;gShowSubRect);        MyReadSection(tempHandle);        InitCursor();                                           /* set to watch by MyReadSection, would normally be reset next pass */    /* through the event loop, but NOT if it's being called by Cut, */    /* so I'll reset it just to be safe */}OSErr ReadClipSection(Size readIn, EditionRefNum sRefNum){OSErr myErr = noErr;    extern Handle gScrapData;    MySetHandleSize((Handle)gClipPict, readIn);    HLock((Handle)gClipPict);    /* read the pict in */    myErr = MyReadEditionData((Ptr)*gClipPict, kGenericPICTWord, sRefNum, &amp;readIn);    HUnlock((Handle)gClipPict);    gScrapData = (Handle)gClipPict;    if (((WindowPeek)FindClipWindow())-&gt;visible) {        WindowPtr temp;        GetPort(&amp;temp);        SetPort(FindClipWindow());        InvalRect(&amp;FindClipWindow()-&gt;portRect);        SetPort(temp);    }  return(myErr);}/* This kills the current section on the clipboard, since it's being replaced *//* and you don't want to receive events for it anymore */void KillClipSub(void){    UnRegisterSection(gClipSection);    DisposeHandle((Handle)(*gClipSection)-&gt;alias);    DisposeHandle((Handle)gClipSection);    gClipSection = nil;    gClipHasContents = kClipEmpty;    if (GetHandleSize((Handle)gClipPict) != nil)        KillPicture(gClipPict);}/* MyGoToPublisher is used if the user was holding down the Option key during a *//* double click, to send them to the publisher without seeing the dialog box */OSErr MyGoToPublisher(SectionHandle theSection){    EditionInfoRecord theEdInfo;        GetEditionInfo(theSection, &amp;theEdInfo);    return(GoToPublisherSection(&amp;theEdInfo.container));}/* Searches the subcriber list, hilites the selection, and drags it *//* This is very similar to the publisher check, but has added functionality *//* for dragging the subscriber around the window */Boolean SearchSubs(Point thePoint){    register qq;  Str63 pubString;    Handle *theRectsHandle;    Boolean subGotIt = false;    windowCHandle shortname = (windowCHandle)GetWRefCon(FrontWindow());    HLock((Handle)shortname);    if ((*shortname)-&gt;numSubs) {                            /* does it have any subscribers? */        HLock((*shortname)-&gt;subRects);                      /* lock down the rect handle */        /* cast it as a pointer to handles for reading ease */        theRectsHandle = (Handle *)*(*shortname)-&gt;subRects;        for (qq = 0; qq &lt; (*shortname)-&gt;numSubs; qq++) {        /* step through the subscribers */            SectionHandle *tempPtr;            Rect *checkRect;            Rect cornerRect;            HLock(*theRectsHandle);            checkRect = (Rect *)**theRectsHandle;            /* did they click in this rect? */            InsetRect(checkRect, kNegFour, kNegFour);                   /* include the possible borders */            if (PtInRect(thePoint, checkRect)) {            /* yes */                /* erase the old display rectangles, if there are any */                if (gShowSub){                    InsetRect(&amp;gShowSubRect, kNegFour, kNegFour);          InvalRect(&amp;gShowSubRect);          InsetRect(&amp;gShowSubRect, kFour, kFour);          }                gShowSub = true;                if (gShowPub) {                    InvalRect(&amp;gShowPubRect);                    gShowPub = false;                }                /* get the section handle for this section */                HLock((*shortname)-&gt;subs);                tempPtr = (SectionHandle *)*(*shortname)-&gt;subs;                tempPtr += qq;                gShowingSecHandle = *tempPtr;                HUnlock((*shortname)-&gt;subs);                /* change the menu item name now */        GetIndString(pubString, kGeneralStrings, kSubOptString);                        SetMenuItemText(gEditMenuHandle, kSoptionsItem,pubString);                                InvalRect(checkRect);                       /* make sure it gets redrawn */                /* now I want the actual rect values so I can drag it around */                /* in response to the user */                gShowSubRect = *checkRect;                PenPat(&amp;qd.dkGray);                PenSize(3, 3);                FrameRect(&amp;gShowSubRect);                PenSize(1, 1);                /* Here you drag the thing around to where the user wants it, updating the                 *   window record as you do it. */                GetMouse(&amp;thePoint);                InvalRect(&amp;gShowSubRect);                /* two choices here.  They could be dragging the whole thing, or resizing it.  */                /* The resize box is in the lower right ten pixels, I'll say, so if the original */                /* click is there I'll go to the resize routine */                cornerRect = gShowSubRect;                cornerRect.top = cornerRect.bottom - 7;                cornerRect.left = cornerRect.right - 7;                if (PtInRect(thePoint, &amp;cornerRect) &amp;&amp; gResizeSub) {                                        PullRect(shortname, &amp;gShowSubRect, false, true,true);                                    } else {                    while (StillDown()) {                   /* keep doing it until they release the mouse */                        Point tempPoint;                         PenMode(patXor);                         FrameRect(&amp;gShowSubRect);           /* nasty way to put up a flashing border for the drag */                         FrameRect(&amp;gShowSubRect);            GetMouse(&amp;tempPoint);                        /* keep inside the window please, don't let them drag the */                        /* rectangle outside the window bounds */                        if (PtInRect(tempPoint, &amp;(FrontWindow()-&gt;portRect))) {                            if (tempPoint != thePoint) {                                OffsetRect(&amp;gShowSubRect, tempPoint.h - thePoint.h, tempPoint.v - thePoint.v);                                thePoint = tempPoint;                            }                        }                    }                    PenMode(normal);                }        InvalRect(&amp;gShowSubRect);        InsetRect(checkRect, kFour, kFour);                 /* remember that ShowingRect is kFour bigger */        InsetRect(&amp;gShowSubRect, kFour, kFour);                 /* remember that ShowingRect is kFour bigger */                if (gShowSubRect != *checkRect) {           /* don't update if they didn't end up moving it */                        *checkRect = gShowSubRect;          /* update our record of things */        }                                                subGotIt = true;            } else {      /* shrink it back agin */            InsetRect(checkRect, kFour, kFour);                 /* remember that ShowingRect is kFour bigger */      }            HUnlock(*theRectsHandle);            theRectsHandle += 1;                            /* increase by one Rect to check next */            if (subGotIt)                break;        }        HUnlock((*shortname)-&gt;subRects);    }    HUnlock((Handle)shortname);    return(subGotIt);}/* end SearchSubs */#undef __SUBSCRIBE__</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/AEObject-Edition_Sample/listing18.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/AEObject-Edition_Sample/listing18.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/AEObject-Edition_Sample/listing18.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>