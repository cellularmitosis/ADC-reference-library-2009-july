<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ATSUIDirectAccessDemo - /Window.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxTextFonts-date.html">Text & Fonts</a> &gt; <A HREF="javascript:location.replace('index.html');">ATSUIDirectAccessDemo</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ATSUIDirectAccessDemo</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Window.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/DirectAccessCallbacks.c</option>
<option value="listing2.html">/DirectAccessCallbacks.h</option>
<option value="listing3.html">/HIElements.h</option>
<option value="listing4.html">/main.c</option>
<option value="listing5.html">/MenuHandler.c</option>
<option value="listing6.html">/MenuHandler.h</option>
<option value="listing7.html">/Window.c</option>
<option value="listing8.html">/Window.h</option></select>
				</p>
				</form>
				<p><strong><a href="ATSUIDirectAccessDemo.zip">Download Sample</a></strong> (&#147;ATSUIDirectAccessDemo.zip&#148;, 80.7K)<BR>
<strong><a href="ATSUIDirectAccessDemo.dmg">Download Sample</a></strong> (&#147;ATSUIDirectAccessDemo.dmg&#148;, 148.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    Window.c
  
  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
        use, installation, modification or redistribution of this Apple software
        constitutes acceptance of these terms.  If you do not agree with these terms,
        please do not use, install, modify or redistribute this Apple software.

        In consideration of your agreement to abide by the following terms, and subject
        to these terms, Apple grants you a personal, non-exclusive license, under Apple's
        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
        reproduce, modify and redistribute the Apple Software, with or without
        modifications, in source and/or binary forms; provided that if you redistribute
        the Apple Software in its entirety and without modifications, you must retain
        this notice and the following text and disclaimers in all such redistributions of
        the Apple Software.  Neither the name, trademarks, service marks or logos of
        Apple Computer, Inc. may be used to endorse or promote products derived from the
        Apple Software without specific prior written permission from Apple.  Except as
        expressly stated in this notice, no other rights or licenses, express or implied,
        are granted by Apple herein, including but not limited to any patent rights that
        may be infringed by your derivative works or by other works in which the Apple
        Software may be incorporated.

        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
        COMBINATION WITH YOUR PRODUCTS.

        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

                Copyright &copy; 2002 Apple Computer, Inc., All Rights Reserved
*/
// This code will run on Mac OS X 10.2 (or later) ONLY!!!
#include &lt;Carbon/Carbon.h&gt;

#include &quot;Window.h&quot;
#include &quot;MenuHandler.h&quot;
#include &quot;HIElements.h&quot;
#include &quot;DirectAccessCallbacks.h&quot;

#define BUGWORKAROUNDS 1

// ------------------------------------------------------------------------------
// Constants
// ------------------------------------------------------------------------------

enum {
  kDefaultUnicodeBufferSize = 20,
  kGlyphBurstLines = 20
};

// ------------------------------------------------------------------------------
// Data Structures
// ------------------------------------------------------------------------------

typedef struct WindowListItem {

  WindowRef        windowRef;
  struct WindowListItem  *nextItem;
  
} WindowListItem;

// ------------------------------------------------------------------------------
// Global Variables
// ------------------------------------------------------------------------------

IBNibRef gMainNibRef = NULL;

static WindowListItem *gWindowList = NULL;

// ------------------------------------------------------------------------------
// Function Prototypes
// ------------------------------------------------------------------------------

static OSStatus InstallWindowEventHandlers( WindowRef windowRef );

static OSStatus HandleKeyEvent( EventHandlerCallRef inHandlerCallRef,
  EventRef inEvent, void *inUserData );
  
static OSStatus HandleWindowEvent( EventHandlerCallRef inHandlerCallRef,
  EventRef inEvent, void *inUserData );
  
static OSStatus AddNewTextLayoutToContext( DrawContextStruct *context );
  
static OSStatus DrawWindow( WindowRef windowRef );

static void AddWindowToList( WindowRef windowRef );

static OSStatus DrawSingleLine( DrawContextStruct *context, Rect windowBounds );

static OSStatus DrawGlyphBurst( DrawContextStruct *context, Rect windowBounds );

static OSStatus ResizeDemoWindow( EventRef inEvent, WindowRef windowRef );

static void CloseDemoWindow( WindowRef windowRef );

// ------------------------------------------------------------------------------
// NewDemoWindow                            [EXPORT]
// ------------------------------------------------------------------------------

extern
OSStatus NewDemoWindow( void )
{
  OSStatus  err;
  WindowRef   windowRef;

  // create the window from the interface builder NIB file
  err = CreateWindowFromNib(gMainNibRef, CFSTR(&quot;MainWindow&quot;), &amp;windowRef);
    require_noerr( err, NewDemoWindow_err );
  
  // install the standard event handlers for the window
  err = InstallWindowEventHandlers( windowRef );
  require_noerr( err, NewDemoWindowEvent_err );
  
  // add the window to the window list
  AddWindowToList( windowRef );
    
    // The window was created hidden so show it
    ShowWindow( windowRef );
  
NewDemoWindow_err:  

  return err;

NewDemoWindowEvent_err:

  // dispose the window on error
  DisposeWindow( windowRef );

  return err;
  
}

// ------------------------------------------------------------------------------
// RedrawWindows                            [EXPORT]
// ------------------------------------------------------------------------------

extern
OSStatus RedrawWindows( void )
{
  OSStatus      err = noErr;
  WindowListItem     *currentItem = gWindowList;
  
  // search through the window list
  while( currentItem != NULL )
  {
    // draw the window
    err = DrawWindow( currentItem-&gt;windowRef );
    require_noerr( err, RedrawWindows_err );
    
    // grab the next context
    currentItem = currentItem-&gt;nextItem;
    
  }

RedrawWindows_err:

  return err;

}

// ------------------------------------------------------------------------------
// CloseAllWindows                            [EXPORT]
// ------------------------------------------------------------------------------

extern
OSStatus CloseAllWindows( void )
{
  WindowListItem  *currentItem = gWindowList;

  // run through the window list
  while( currentItem != NULL )
  {
    // close the window
    CloseDemoWindow( currentItem-&gt;windowRef );
    
    // move on to the next item
    currentItem = currentItem-&gt;nextItem;
  }

  return noErr;
}

// ------------------------------------------------------------------------------
// InvalidateAndRedrawWindows                      [EXPORT]
// ------------------------------------------------------------------------------

extern
OSStatus InvalidateAndRedrawWindows( void )
{
  OSStatus      err = noErr;
  WindowListItem     *currentItem = gWindowList;
  DrawContextStruct  *windowContext;
  
  // search through the window list
  while( currentItem != NULL )
  {
    // get the draw context struct from the window's refCon
    windowContext = (DrawContextStruct *) GetWRefCon( 
      currentItem-&gt;windowRef );
    
    // make sure that we have a context
    if ( windowContext != NULL )
    {  
      // if we have a text layout, then make sure that we get rid of it.
      // This really is invalidation!
      if ( windowContext-&gt;layoutObject != NULL )
      {
        err = ATSUDisposeTextLayout( windowContext-&gt;layoutObject );
        require_noerr( err, InvalidateAndRedrawWindows_err );
        
        windowContext-&gt;layoutObject = NULL;
      }
    
      // nifty. Now, we need to redraw the window
      err = DrawWindow( currentItem-&gt;windowRef  );
      require_noerr( err, InvalidateAndRedrawWindows_err );
    }
    
    // grab the next context
    currentItem = currentItem-&gt;nextItem;
    
  }

InvalidateAndRedrawWindows_err:

  return err;

}

// ------------------------------------------------------------------------------
// CloseDemoWindow                          [INTERNAL]
// ------------------------------------------------------------------------------

static
void CloseDemoWindow(
  WindowRef windowRef )
{
  WindowListItem     *currentItem = gWindowList;
  WindowListItem     *previousItem = NULL;
  DrawContextStruct  *windowContext;

  // search through the window list, looking for the windowRef
  while( currentItem != NULL )
  {
    // check to see if the current item is the one that we're looking for
    if ( currentItem-&gt;windowRef == windowRef )
    {
      // we've got a match, so set the previous item's next item pointer
      // to the current item's next item pointer
      if ( previousItem != NULL )
      {
        previousItem-&gt;nextItem = currentItem-&gt;nextItem;
      }
      else
      {
        gWindowList = currentItem-&gt;nextItem;
      }
      
      
      // free up the current item
      free( currentItem );
      break;
    }
    
    // move on to the next item
    previousItem = currentItem;
    currentItem = currentItem-&gt;nextItem;
  }
  
  // get the draw context struct from the window's refCon
  windowContext = (DrawContextStruct *) GetWRefCon( windowRef );
  
  // if we have a context, then we need to make sure to dispose of everything
  // that's in the context before we free the context.
  if ( windowContext != NULL )
  {
  
    // stop the CGContext for the port
    if ( windowContext-&gt;cgContext != NULL )
    {  
      CGrafPtr  windowPort;
    
      // get the window port for the window
      windowPort = GetWindowPort( windowRef );
          
      verify_noerr( 
        QDEndCGContext( windowPort, &amp;windowContext-&gt;cgContext ) );
    }
    
    // dispose of the text layout object
    if ( windowContext-&gt;layoutObject != NULL ) 
    {
      verify_noerr( 
        ATSUDisposeTextLayout( windowContext-&gt;layoutObject ) );
    }
    
    // free the text buffer, if there is one
    if( windowContext-&gt;textBuffer != NULL )
    {
      free( windowContext-&gt;textBuffer );
    }
    
    // free the context itself
    free( windowContext );
    
  }

}

// ------------------------------------------------------------------------------
// AddWindowToList                          [INTERNAL]
// ------------------------------------------------------------------------------

static
void AddWindowToList(
  WindowRef windowRef )
{  
  WindowListItem *newItem;
  
  // allocate a new item
  newItem = (WindowListItem *) malloc( sizeof( WindowListItem ) );
  require( newItem != NULL, AddWindowToList_err );
  
  // add the new item to the head of the list
  newItem-&gt;windowRef = windowRef;
  newItem-&gt;nextItem = gWindowList;
  gWindowList = newItem;

AddWindowToList_err:

  return;
}

// ------------------------------------------------------------------------------
// ResizeDemoWindow                          [INTERNAL]
// ------------------------------------------------------------------------------

static
OSStatus ResizeDemoWindow(
  EventRef   inEvent, 
  WindowRef   windowRef )
{
  OSStatus      err;
  Rect        newBounds;
  Rect        oldBounds;
  short        newWidth;
  short        newLength;
  
  // get the event parameter which will tell us the new size
  err = GetEventParameter( inEvent, kEventParamCurrentBounds, typeQDRectangle,
    NULL, sizeof( Rect ), NULL, &amp;newBounds );
  require_noerr( err, ResizeDemoWindow_err );

  // get the old bounds, just to see if we don't need to draw anything
  err = GetEventParameter( inEvent, kEventParamPreviousBounds,  typeQDRectangle,
    NULL, sizeof( Rect ), NULL, &amp;oldBounds );
  require_noerr( err, ResizeDemoWindow_err );    
  
  // calculate the new width and length
  newWidth = newBounds.right - newBounds.left;
  newLength = newBounds.bottom - newBounds.top;
  
  // check to see if we need to redraw. If this is a simple translation,
  // then we don't.
  if ( ( newLength != ( oldBounds.bottom - oldBounds.top ) ) ||
     ( newWidth !=  ( oldBounds.right - oldBounds.left ) ) )
  {
    DrawContextStruct  *windowContext;
    CGrafPtr      windowPort;
  
    // get the draw context struct from the window's refCon
    windowContext = (DrawContextStruct *) GetWRefCon( windowRef );

#if BUGWORKAROUNDS
    
    // get the window port
    windowPort = GetWindowPort( windowRef );
      
    // okay, so this is really, really lame. I'm going to get rid of
    // the current cg context and get a new one. This is because I
    // don't have the time right now to figure out how to synchronize the
    // clipping regions and such for the window and the context. This
    // is really bad, beacuse the text layout needs to have the new
    // cg context tag set in it, which will invalidate the layout.
    
    // I only need to dispose of the context each time until I figure
    // out what's going wrong with the Quickdraw clipping regions.
    
    // dispose of the context
    err = QDEndCGContext( windowPort, &amp;windowContext-&gt;cgContext );
    require_noerr( err, ResizeDemoWindow_err );
        
    // re-grab the cgContext from the port
    err = QDBeginCGContext( windowPort, &amp;windowContext-&gt;cgContext );
    require_noerr( err, ResizeDemoWindow_err );
    
    // make sure that the context is re-set in the ATSUI object
    if ( windowContext-&gt;layoutObject != NULL )
    {
      ATSUAttributeTag tag = kATSUCGContextTag;
      ByteCount valueSize = sizeof( CGContextRef );
      ATSUAttributeValuePtr valuePtr = &amp;windowContext-&gt;cgContext;
      
      err = ATSUSetLayoutControls( windowContext-&gt;layoutObject, 1, &amp;tag,
        &amp;valueSize, &amp;valuePtr );
      require_noerr( err, ResizeDemoWindow_err );
      
    }
#endif
    
    // redraw the context
    err = DrawWindow( windowRef );
    require_noerr( err, ResizeDemoWindow_err );
    
  }

ResizeDemoWindow_err:

  return eventNotHandledErr;  

}

// ------------------------------------------------------------------------------
// InstallWindowEventHandlers                    [INTERNAL]
// ------------------------------------------------------------------------------

static
OSStatus InstallWindowEventHandlers(
  WindowRef windowRef )
{
  static const EventTypeSpec   inputEventSpec[] = 
    {   { kEventClassTextInput, kEventTextInputUnicodeForKeyEvent } };
    
  static const EventTypeSpec  windowEventSpec[] =
    {  { kEventClassWindow, kEventWindowClosed },
      { kEventClassWindow, kEventWindowBoundsChanged },
      { kEventClassWindow, kEventWindowDrawContent } };
    
  OSStatus       err;
  DrawContextStruct  *newContext;
  CGrafPtr      windowPort;
  
  // allocate a new draw context
  newContext = calloc( 1, sizeof( DrawContextStruct ) );
  require_action( newContext != NULL, InstallWindowEventHandlers_err,
    err = paramErr );
    
  // get the window port for the window
  windowPort = GetWindowPort( windowRef );
    
  // grab the cgContext from the port
  err = QDBeginCGContext( windowPort, &amp;newContext-&gt;cgContext );
  require_noerr( err, InstallWindowEventHandlersEvent_err );
  
  // install a key event handler
  err = InstallWindowEventHandler( windowRef,
    NewEventHandlerUPP( HandleKeyEvent ), GetEventTypeCount( inputEventSpec ), 
    inputEventSpec, (void *) windowRef, NULL );
  require_noerr( err, InstallWindowEventHandlersEvent_err );
  
  // install a general window event handler
  err = InstallWindowEventHandler( windowRef,
    NewEventHandlerUPP( HandleWindowEvent ), GetEventTypeCount( windowEventSpec ), 
    windowEventSpec, (void *) windowRef, NULL );
  require_noerr( err, InstallWindowEventHandlersEvent_err );
  
  // also, set the context as the window refcon
  SetWRefCon( windowRef, (long) newContext );

  return noErr;
  
InstallWindowEventHandlersEvent_err:

  // make sure that if we're bailing to get rid of the allocated buffer
  free( newContext );

InstallWindowEventHandlers_err:
  
  return err;

}

// ------------------------------------------------------------------------------
// HandleWindowEvent                        [INTERNAL]
// ------------------------------------------------------------------------------

static
OSStatus HandleWindowEvent(
  EventHandlerCallRef inHandlerCallRef,
  EventRef       inEvent, 
  void         *inUserData )
{
#pragma unused( inHandlerCallRef )

  OSStatus   err = eventNotHandledErr;
  WindowRef  windowRef;

  // cast away the user data to the context for easier handling
  windowRef = (WindowRef) inUserData;
  check( windowRef != NULL );
  
  // pass the control off to our handlers based on event kind
  switch ( GetEventKind( inEvent ) )
  {
    case kEventWindowClosed:    
      CloseDemoWindow( windowRef );
      break;
      
    case kEventWindowBoundsChanged:
      ResizeDemoWindow( inEvent, windowRef );
      break;
      
    case kEventWindowDrawContent:
    {          
      // redraw  the context
      DrawWindow( windowRef );
      break;
    }
      
    default:
      break;
  
  };
  
  return err;  

}


// ------------------------------------------------------------------------------
// HandleKeyEvent                          [INTERNAL]
// ------------------------------------------------------------------------------

static
OSStatus HandleKeyEvent(
  EventHandlerCallRef inHandlerCallRef,
  EventRef       inEvent, 
  void         *inUserData )
{
#pragma unused( inHandlerCallRef )

  OSStatus      err;
  EventRef      keyboardEvent;
  UInt32        dataSize;
  UniCharCount    numNewCharacters;
  WindowRef      windowRef;
  DrawContextStruct  *context;
  
  // cast away the user data to the context for easier handling
  windowRef = (WindowRef) inUserData;
  
  // get the context from windowRef    
  context = (DrawContextStruct *) GetWRefCon( windowRef );
  check( context != NULL );
  
  // get the keyboard event
  err = GetEventParameter( inEvent, kEventParamTextInputSendKeyboardEvent,
    typeEventRef, NULL, sizeof( EventRef ), NULL, &amp;keyboardEvent );
  require_noerr( err, HandleKeyEvent_err );
  
  // get the data size of the event
  err = GetEventParameter( keyboardEvent, kEventParamKeyUnicodes,
    typeUnicodeText, NULL, 0, &amp;dataSize, NULL );
  require_noerr( err, HandleKeyEvent_err );
  
  // calculate the number of characters based on the data size
  numNewCharacters = dataSize / sizeof( UniChar );
  
  // check to see if the buffer is large enough to fit the key
  if ( context-&gt;textBufferSize &lt; ( context-&gt;characterCount + 
    numNewCharacters ) )
  {
    ByteCount newSize;
  
    // nope. We need to resize the buffer. First, we need to pick a
    // size.
    if ( context-&gt;textBufferSize == 0 )
    {
      // the buffer has never been allocated. So, set it to a default
      // size plus whatever we got
      newSize = dataSize + kDefaultUnicodeBufferSize;
    }
    else
    {
      // the buffer has been allocated, so just double it's current
      // size. This is actually one of the most efficient ways to
      // use realloc
      newSize = dataSize + (context-&gt;textBufferSize * 2);
    }
    
    // allocate the new buffer
    context-&gt;textBuffer = realloc( context-&gt;textBuffer, newSize );
    require_action( context-&gt;textBuffer != NULL, HandleKeyEvent_err,
      err = memFullErr );
      
    // reset the text pointer, if there is one
    if ( context-&gt;layoutObject != NULL ) {
      err = ATSUSetTextPointerLocation( context-&gt;layoutObject, 
        context-&gt;textBuffer, kATSUFromTextBeginning, 
        kATSUToTextEnd, context-&gt;characterCount );
      require_noerr( err, HandleKeyEvent_err );
    }
      
    // set the new size in the buffer size
    context-&gt;textBufferSize = newSize / sizeof( UniChar );
  }
  
  // add the keys to the buffer from the event
  err = GetEventParameter( keyboardEvent, kEventParamKeyUnicodes,
    typeUnicodeText, NULL, dataSize, NULL,
    (void*) ( context-&gt;textBuffer + context-&gt;characterCount ) );
  require_noerr( err, HandleKeyEvent_err );
    
  // if the layout's already been allocated, then add the characters
  // to it. Otherwise, do nothing and let the draw function handle
  // everything
  if ( context-&gt;layoutObject != NULL ) {
    
    // insert the text into the layout
    err = ATSUTextInserted( context-&gt;layoutObject,
      context-&gt;characterCount, numNewCharacters );
    require_noerr( err, HandleKeyEvent_err );
    
  }
  
  // increment the character count stored in the context
  context-&gt;characterCount += numNewCharacters;

  // draw the context
  err = DrawWindow( windowRef );
  require_noerr( err, HandleKeyEvent_err );

HandleKeyEvent_err:

  return err;

}

// ------------------------------------------------------------------------------
// AddNewTextLayoutToContext                    [INTERNAL]
// ------------------------------------------------------------------------------

static
OSStatus AddNewTextLayoutToContext( 
  DrawContextStruct  *context )
{
  OSStatus err;
  ATSUAttributeTag tag;
  ByteCount valueSize;
  ATSUAttributeValuePtr valuePtr;
  UniCharCount runLength = kATSUToTextEnd;
  
  // create a text layout object
  err = ATSUCreateTextLayoutWithTextPtr( context-&gt;textBuffer,
    kATSUFromTextBeginning, kATSUToTextEnd, context-&gt;characterCount, 1,
    &amp;runLength, &amp;gGlobalStyle, &amp;context-&gt;layoutObject );
  require_noerr( err, AddNewTextLayoutToContext_err );
  
  // add the cgContext to the text layout
  tag = kATSUCGContextTag;
  valueSize = sizeof( CGContextRef );
  valuePtr = &amp;context-&gt;cgContext;
  err = ATSUSetLayoutControls( context-&gt;layoutObject, 1, &amp;tag, &amp;valueSize,
    &amp;valuePtr );
  require_noerr( err, AddNewTextLayoutToContext_err );
  
  // set font substitution for the new layout  
  err = ATSUSetTransientFontMatching( context-&gt;layoutObject, true );
  require_noerr( err, AddNewTextLayoutToContext_err );
  
  // now, check the menu and see if we need to install a callback
  switch ( gDemoMenuSelection )
  {
    case kDemoMenuItemStretch:
      err = InstallStrechyGlyphCallback( context-&gt;layoutObject );
      require_noerr( err, AddNewTextLayoutToContext_err );
      break;
      
    case kDemoMenuItemShrink:
      err = InstallShrinkyGlyphCallback( context-&gt;layoutObject );
      require_noerr( err, AddNewTextLayoutToContext_err );
      break;
    
    case kDemoMenuItemWhitespaceReplace:    
      err = InstallGlyphReplacementCallback( context-&gt;layoutObject );
      require_noerr( err, AddNewTextLayoutToContext_err );
      break;
      
    case kDemoMenuItemSineWave:
      err = InstallGlyphWaveCallback( context-&gt;layoutObject );
      require_noerr( err, AddNewTextLayoutToContext_err );
      break;
    
    case kDemoMenuItemNone:
    default:    
      break;
      
  }


AddNewTextLayoutToContext_err:
  
  return err;
}

// ------------------------------------------------------------------------------
// DrawWindow                            [INTERNAL]
// ------------------------------------------------------------------------------

static
OSStatus DrawWindow(
  WindowRef windowRef )
{
  OSStatus         err = noErr;
  DrawContextStruct    *context;
  
  // get the context from windowRef    
  context = (DrawContextStruct *) GetWRefCon( windowRef );
  check( context != NULL );
  
  // we only need to do this if there are characters in the buffer. If there
  // aren't any characters, then there's nothing to draw.
  if ( context-&gt;characterCount &gt; 0 )
  {  
    CGRect     cgRect;
    CGrafPtr  windowPort;
    Rect    windowBounds;
    
    // get the window port for the window
    windowPort = GetWindowPort( windowRef );
  
    // sync the origins
    SyncCGContextOriginWithPort( context-&gt;cgContext, windowPort );
    
    // get the bounds for the port
    GetPortBounds( windowPort, &amp;windowBounds );
      
    // now, we need to set the clipping region for the document. Let's 
    cgRect = CGRectMake( windowBounds.left, windowBounds.top,
      windowBounds.right, windowBounds.bottom );
    
#if BUGWORKAROUNDS
    // reset the clipping region for the document. This should stop that
    // silly bug which is causing stuff to draw into the window tilebar
    CGContextClipToRect( context-&gt;cgContext, cgRect );
#endif
      
    // save the current state
    CGContextSaveGState(context-&gt;cgContext);
    
    // set a fill color in the CGContext. Make it white.
    CGContextSetRGBFillColor( context-&gt;cgContext, 1.0, 1.0, 1.0, 1.0 );
    
    // fill the window rect to clear it out
    CGContextFillRect( context-&gt;cgContext, cgRect );
    
    // restore the old state
    CGContextRestoreGState( context-&gt;cgContext );
    
    
    // if there isn't a layout object, then we need to add one to the
    // context
    if ( context-&gt;layoutObject == NULL )
    {
      err = AddNewTextLayoutToContext( context );
      require_noerr( err, DrawContext_err );
    }
    
    // based on the current options selection, either just draw a single
    // line, or do the fancy glyph rotate stuff.
    switch ( gOptionsMenuSelection )
    {
      case kOptionsMenuTextBurst:
        err = DrawGlyphBurst( context, windowBounds );
        require_noerr( err, DrawContext_err );
        break;
      
      case kOptionsMenuItemNone:
      default:
        err = DrawSingleLine( context, windowBounds );
        require_noerr( err, DrawContext_err );
        break;
    }

    // flush the CGContext
    CGContextFlush( context-&gt;cgContext );

  }
    
DrawContext_err:

  return err;

}

// ------------------------------------------------------------------------------
// DrawSingleLine                          [INTERNAL]
// ------------------------------------------------------------------------------

static
OSStatus DrawSingleLine(
  DrawContextStruct *context,
  Rect        windowBounds )
{
  OSStatus        err;
  ATSTrapezoid      glyphBounds;
  ItemCount        numGlyphBounds;
  Fixed          lineHeight;
  ATSUTextMeasurement    xPosition;
  ATSUTextMeasurement    yPosition;
  
  // set the xPosition and the yPosition as the boundries. 
  xPosition = windowBounds.left &lt;&lt; 16;
  yPosition = windowBounds.bottom &lt;&lt; 16;
  
  // we need to calculate where the line should start, so get the height of the
  // line.
  err = ATSUGetGlyphBounds( context-&gt;layoutObject, 0, 0, kATSUFromTextBeginning,
    kATSUToTextEnd, kATSUseCaretOrigins, 1, &amp;glyphBounds, &amp;numGlyphBounds );
  require_noerr( err, DrawSingleLine_err );
  
  lineHeight = glyphBounds.lowerRight.y - glyphBounds.upperRight.y;
  
  // adjust the line position based on the line height
  yPosition -= lineHeight;
  
  // draw!
  err = ATSUDrawText( context-&gt;layoutObject, kATSUFromTextBeginning,
    kATSUToTextEnd, xPosition, yPosition );
  check_noerr( err );
  
DrawSingleLine_err:
  
  return err;
}

// ------------------------------------------------------------------------------
// DrawGlyphBurst                          [INTERNAL]
// ------------------------------------------------------------------------------

static
OSStatus DrawGlyphBurst(
  DrawContextStruct   *context,
  Rect        windowBounds )
{
  OSStatus        err;
  ATSUTextMeasurement    xPosition;
  ATSUTextMeasurement    yPosition;
  Fixed          numDegreesPerLine;
  Fixed          currentDegree;
  ATSUAttributeTag    tag = kATSULineRotationTag;
  ByteCount        valueSize = sizeof( Fixed );
  ATSUAttributeValuePtr  valuePtr = &amp;currentDegree;
  
  // initialize the current degree to 360 degrees
  currentDegree = (360 &lt;&lt; 16);
  
  // calculate the number of degrees for each glyph burst
  numDegreesPerLine = currentDegree / kGlyphBurstLines;
  
  // set the xPosition and the yPosition at the center of the window
  xPosition = ( ( windowBounds.right - windowBounds.left ) / 2 ) &lt;&lt; 16;
  yPosition = ( ( windowBounds.bottom - windowBounds.top ) / 2 ) &lt;&lt; 16;
    
  // loop through until all lines are drawn
  while ( currentDegree &gt; 0 )
  {
    // set the current rotation degree in the text layout object
    err = ATSUSetLayoutControls( context-&gt;layoutObject, 1, &amp;tag,
      &amp;valueSize, &amp;valuePtr );
    require_noerr( err, DrawGlyphBurst_err );
    
    // draw!
    err = ATSUDrawText( context-&gt;layoutObject, kATSUFromTextBeginning,
      kATSUToTextEnd, xPosition, yPosition );
      
    // decrement the current degree
    currentDegree -= numDegreesPerLine;
  }
  
  // set the current degree back to zero, in case it wasn't
  currentDegree = 0;
  err = ATSUSetLayoutControls( context-&gt;layoutObject, 1, &amp;tag,
    &amp;valueSize, &amp;valuePtr );
  require_noerr( err, DrawGlyphBurst_err );  
    
DrawGlyphBurst_err:
    
  return err;  

}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ATSUIDirectAccessDemo/listing7.html%3Fid%3DDTS10001092-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ATSUIDirectAccessDemo/listing7.html%3Fid%3DDTS10001092-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ATSUIDirectAccessDemo/listing7.html%3Fid%3DDTS10001092-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>