<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Summary of the Memory Manager (IM: M)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING150></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Memory-149.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-151.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Memory-2.html"><B>Memory</B></A> / <BR><DD><A HREF="Memory-56.html"><B>Chapter 2 - Memory Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING150-0></A>
<H1><A NAME=MARKER-9-533></A>Summary of the Memory Manager</H1>
<A NAME=HEADING150-1></A>
<H2>Pascal Summary</H2>
<A NAME=HEADING150-2></A>
<H3>Constants</H3>
<PRE>
CONST
   {Gestalt constants}
   gestaltOSAttr              = 'os  ';   {O/S attributes}
   gestaltTempMemSupport      = 4;        {temp memory support present}
   gestaltRealTempMemory      = 5;        {temp memory handles are real}
   gestaltTempMemTracked      = 6;        {temp memory handles tracked}
   maxSize                    = $800000;  {maximum size of a block}
</PRE>
<A NAME=HEADING150-5></A>
<H3>Data Types</H3>
<PRE>
TYPE
   SignedByte           = -128..127;      {arbitrary byte of memory}
   Byte                 = 0..255;         {unsigned, arbitrary byte}
   Ptr                  = ^SignedByte;    {pointer to nonrelocatable block}
   Handle               = ^Ptr;           {handle to relocatable block}
   Str255               = STRING[255];    {Pascal string}
   StringPtr            = ^Str255;
   StringHandle         = ^StringPtr;
   ProcPtr              = Ptr;            {procedure pointer}

   Size                 = LongInt;        {size in bytes of block}
   Zone =
   RECORD
      bkLim:         Ptr;                 {first usable byte after zone}
      purgePtr:      Ptr;                 {used internally}
      hFstFree:      Ptr;                 {first free master pointer}
      zcbFree:       LongInt;             {number of free bytes}
      gzProc:        ProcPtr;             {grow-zone function}
      moreMast:      Integer;             {number of master ptrs to allocate}
      flags:         Integer;             {used internally}
      cntRel:        Integer;             {reserved}
      maxRel:        Integer;             {reserved}
      cntNRel:       Integer;             {reserved}
      maxNRel:       Integer;             {reserved}
      cntEmpty:      Integer;             {reserved}
      cntHandles:    Integer;             {reserved}
      minCBFree:     LongInt;             {reserved}
      purgeProc:     ProcPtr;             {purge-warning procedure}
      sparePtr:      Ptr;                 {used internally}
      allocPtr:      Ptr;                 {used internally}
      heapData:      Integer;             {first usable byte in zone}
   END;

   THz = ^Zone;                           {zone pointer}
</PRE>
<A NAME=HEADING150-10></A>
<H3>Memory Manager Routines</H3>
<A NAME=HEADING150-11></A>
<H4>Setting Up the Application Heap</H4>
<PRE>
PROCEDURE MaxApplZone;
PROCEDURE MoreMasters;
</PRE>
<A NAME=HEADING150-14></A>
<H4>Allocating and Releasing Relocatable Blocks of Memory</H4>
<PRE>
FUNCTION NewHandle		(logicalSize: Size): Handle;
FUNCTION NewHandleSys		(logicalSize: Size): Handle;
FUNCTION NewHandleClear		(logicalSize: Size): Handle;
FUNCTION NewHandleSysClear	(logicalSize: Size): Handle;
FUNCTION NewEmptyHandle		: Handle;
FUNCTION NewEmptyHandleSys	: Handle;
PROCEDURE DisposeHandle		(h: Handle);
</PRE>
<A NAME=HEADING150-22></A>
<H4>Allocating and Releasing Nonrelocatable Blocks of Memory</H4>
<PRE>
FUNCTION NewPtr			(logicalSize: Size): Ptr;
FUNCTION NewPtrSys		(logicalSize: Size): Ptr;
FUNCTION NewPtrClear		(logicalSize: Size): Ptr;
FUNCTION NewPtrSysClear		(logicalSize: Size): Ptr;
PROCEDURE DisposePtr		(p: Ptr);
</PRE>
<A NAME=HEADING150-28></A>
<H4>Changing the Sizes of Relocatable and Nonrelocatable Blocks</H4>
<PRE>
FUNCTION GetHandleSize		(h: Handle): Size;
PROCEDURE SetHandleSize		(h: Handle; newSize: Size);
FUNCTION GetPtrSize		(p: Ptr): Size;
PROCEDURE SetPtrSize		(p: Ptr; newSize: Size);
</PRE>
<A NAME=HEADING150-33></A>
<H4>Setting the Properties of Relocatable Blocks</H4>
<PRE>
FUNCTION HGetState			(h: Handle): SignedByte;
PROCEDURE HSetState			(h: Handle; flags: SignedByte);
PROCEDURE HLock				(h: Handle);
PROCEDURE HUnlock			(h: Handle);
PROCEDURE HPurge			(h: Handle);
PROCEDURE HNoPurge			(h: Handle);
PROCEDURE HSetRBit			(h: Handle);
PROCEDURE HClrRBit			(h: Handle);
</PRE>
<A NAME=HEADING150-42></A>
<H4>Managing Relocatable Blocks</H4>
<PRE>
PROCEDURE EmptyHandle		(h: Handle);
PROCEDURE ReallocateHandle	(h: Handle; logicalSize: Size);
FUNCTION RecoverHandle		(p: Ptr): Handle;
PROCEDURE ReserveMem		(cbNeeded: Size);
PROCEDURE ReserveMemSys		(cbNeeded: Size);
PROCEDURE MoveHHi		(h: Handle);
PROCEDURE HLockHi		(h: Handle);
</PRE>
<A NAME=HEADING150-50></A>
<H4>Manipulating Blocks of Memory</H4>
<PRE>
PROCEDURE BlockMove		(sourcePtr, destPtr: Ptr; byteCount: Size);
FUNCTION PtrToHand		(srcPtr: Ptr; VAR dstHndl: Handle; 
				size: LongInt): OSErr;
FUNCTION PtrToXHand		(srcPtr: Ptr; dstHndl: Handle; size: LongInt): 
				OSErr;
FUNCTION HandToHand		(VAR theHndl: Handle): OSErr;
FUNCTION HandAndHand		(aHndl, bHndl: Handle): OSErr;
FUNCTION PtrAndHand		(pntr: Ptr; hndl: Handle; size: LongInt): OSErr;
</PRE>
<A NAME=HEADING150-57></A>
<H4>Assessing Memory Conditions</H4>
<PRE>
FUNCTION FreeMem		: LongInt;
FUNCTION FreeMemSys		: LongInt;
FUNCTION MaxBloc			k: LongInt;
FUNCTION MaxBlockSys		: LongInt;
PROCEDURE PurgeSpace		(VAR total: LongInt; VAR contig: LongInt);
FUNCTION StackSpace		: LongInt;
FUNCTION MemError		: OSErr;
</PRE>
<A NAME=HEADING150-65></A>
<H4>Freeing Memory</H4>
<PRE>
FUNCTION CompactMem		(cbNeeded: Size): Size;
FUNCTION CompactMemSys		(cbNeeded: Size): Size;
PROCEDURE PurgeMem		(cbNeeded: Size);
PROCEDURE PurgeMemSys		(cbNeeded: Size);
FUNCTION MaxMem			(VAR grow: Size): Size;
FUNCTION MaxMemSys		(VAR grow: Size): Size;
</PRE>
<A NAME=HEADING150-72></A>
<H4>Grow-Zone Operations</H4>
<PRE>
PROCEDURE SetGrowZone		(growZone: ProcPtr);
FUNCTION GZSaveHnd		: Handle;
</PRE>
<A NAME=HEADING150-75></A>
<H4>Allocating Temporary Memory</H4>
<PRE>
FUNCTION TempNewHandle		(logicalSize: Size; VAR resultCode: OSErr): 
				Handle;
FUNCTION TempFreeMem		: LongInt;
FUNCTION TempMaxMem		(VAR grow: Size): Size;
</PRE>
<A NAME=HEADING150-79></A>
<H4>Accessing Heap Zones</H4>
<PRE>
FUNCTION GetZone		: THz;
PROCEDURE SetZone		(hz: THz);
FUNCTION ApplicationZone	: THz;
FUNCTION SystemZone		: THz;
FUNCTION HandleZone		(h: Handle): THz;
FUNCTION PtrZone		(p: Ptr): THz;
</PRE>
<A NAME=HEADING150-86></A>
<H4>Manipulating Heap Zones</H4>
<PRE>
FUNCTION GetApplLimit		: Ptr;
PROCEDURE SetApplLimit		(zoneLimit: Ptr);
FUNCTION TopMem			: Ptr;
PROCEDURE InitZone		(pGrowZone: ProcPtr; cMoreMasters: Integer; 
				limitPtr, startPtr: Ptr);
PROCEDURE InitApplZone;
PROCEDURE SetApplBase		(startPtr: Ptr);
</PRE>
<A NAME=HEADING150-93></A>
<H3>Application-Defined Routines</H3>
<A NAME=HEADING150-94></A>
<H4>Grow-Zone Functions</H4>
<PRE>
FUNCTION MyGrowZone		(cbNeeded: Size): LongInt;
</PRE>
<A NAME=HEADING150-96></A>
<H4>Purge-Warning Procedures</H4>
<PRE>
PROCEDURE MyPurgeProc		(h: Handle);
</PRE>
<A NAME=HEADING150-98></A>
<H2>C Summary</H2>
<A NAME=HEADING150-99></A>
<H3>Constants</H3>
<PRE>
/*Gestalt constants*/
#define gestaltOSAttr            'os  ';     /*O/S attributes*/
#define gestaltTempMemSupport    4;          /*temp memory support present*/
#define gestaltRealTempMemory    5;          /*temp memory handles are real*/
#define gestaltTempMemTracked    6;          /*temp memory handles tracked*/
#define maxSize                  0x800000;   /*maximum size of a block*/
</PRE>
<A NAME=HEADING150-102></A>
<H3>Data Types</H3>
<PRE>
typedef char SignedByte;               /*arbitrary byte of memory*/
typedef unsigned char Byte;            /*unsigned, arbitrary byte*/
typedef char *Ptr;                     /*pointer to nonrelocatable block*/
typedef Ptr *Handle;                   /*handle to relocatable block*/
typedef unsigned char Str255[256];     /*Pascal string*/
typedef unsigned char *StringPtr;
typedef unsigned char **StringHandle;
typedef long (*ProcPtr)();             /*procedure pointer*/
typedef long Size;                     /*size in bytes of block*/
struct Zone {
   Ptr               bkLim;            /*first usable byte after zone*/
   Ptr               purgePtr;         /*used internally*/
   Ptr               hFstFree;         /*first free master pointer*/
   long              zcbFree;          /*number of free bytes*/
   GrowZoneProcPtr   gzProc;           /*grow-zone function*/
   short             moreMast;         /*number of master ptrs to allocate*/
   short             flags;            /*used internally*/
   short             cntRel;           /*reserved*/
   short             maxRel;           /*reserved*/
   short             cntNRel;          /*reserved*/
   short             maxNRel;          /*reserved*/
   short             cntEmpty;         /*reserved*/
   short             cntHandles;       /*reserved*/
   long              minCBFree;        /*reserved*/
   ProcPtr           purgeProc;        /*purge-warning procedure*/
   Ptr               sparePtr;         /*used internally*/
   Ptr               allocPtr;         /*used internally*/
   short             heapData;         /*first usable byte in zone*/
};
typedef struct Zone Zone;
typedef Zone *THz;                     /*zone pointer*/
</PRE>
<A NAME=HEADING150-107></A>
<H3>Memory Manager Routines</H3>
<A NAME=HEADING150-108></A>
<H4>Setting Up the Application Heap</H4>
<PRE>
pascal void MaxApplZone		(void);
pascal void MoreMasters		(void);
</PRE>
<A NAME=HEADING150-111></A>
<H4>Allocating and Releasing Relocatable Blocks of Memory</H4>
<PRE>
pascal Handle NewHandle		(Size byteCount);
pascal Handle NewHandleSys	(Size byteCount);
pascal Handle NewHandleClear	(Size byteCount);
pascal Handle NewHandleSysClear
   				(Size byteCount);
pascal Handle NewEmptyHandle	(void);
pascal Handle NewEmptyHandleSys
   				(void);
pascal void DisposeHandle	(Handle h);
</PRE>
<A NAME=HEADING150-121></A>
<H4>Allocating and Releasing Nonrelocatable Blocks of Memory</H4>
<PRE>
pascal Ptr NewPtr		(Size byteCount);
pascal Ptr NewPtrSys		(Size byteCount);
pascal Ptr NewPtrClear		(Size byteCount);
pascal Ptr NewPtrSysClear	(Size byteCount);
pascal void DisposePtr		(Ptr p);
</PRE>
<A NAME=HEADING150-127></A>
<H4>Changing the Sizes of Relocatable and Nonrelocatable Blocks</H4>
<PRE>
pascal Size GetHandleSize	(Handle h);
pascal void SetHandleSize	(Handle h, Size newSize);
pascal Size GetPtrSize		(Ptr p);
pascal void SetPtrSize		(Ptr p, Size newSize);
</PRE>
<A NAME=HEADING150-132></A>
<H4>Setting the Properties of Relocatable Blocks</H4>
<PRE>
pascal char HGetState		(Handle h);
pascal void HSetState		(Handle h, char flags);
pascal void HLock		(Handle h);
pascal void HUnlock		(Handle h);
pascal void HPurge		(Handle h);
pascal void HNoPurge		(Handle h);
pascal void HSetRBit		(Handle h);
pascal void HClrRBit		(Handle h);
</PRE>
<A NAME=HEADING150-141></A>
<H4>Managing Relocatable Blocks</H4>
<PRE>
pascal void EmptyHandle		(Handle h);
pascal void ReallocateHandle	(Handle h, Size byteCount);
pascal Handle RecoverHandle	(Ptr p);
pascal void ReserveMem		(Size cbNeeded);
pascal void ReserveMemSys	(Size cbNeeded);
pascal void MoveHHi		(Handle h);
pascal void HLockHi		(Handle h);
</PRE>
<A NAME=HEADING150-149></A>
<H4>Manipulating Blocks of Memory</H4>
<PRE>
pascal void BlockMove		(const void *srcPtr, void *destPtr, 
				Size byteCount);
pascal OSErr PtrToHand		(Ptr srcPtr, Handle *dstHndl, long size);
pascal OSErr PtrToXHand		(Ptr srcPtr, Handle dstHndl, long size);
pascal OSErr HandToHand		(Handle *theHndl);
pascal OSErr HandAndHand	(Handle hand1, Handle hand2);
pascal OSErr PtrAndHand		(Ptr ptr1, Handle hand2, long size);
</PRE>
<A NAME=HEADING150-156></A>
<H4>Assessing Memory Conditions</H4>
<PRE>
pascal long FreeMem		(void);
pascal long FreeMemSys		(void);
pascal long MaxBlock		(void);
pascal long MaxBlockSys		(void);
pascal void PurgeSpace		(long *total, long *contig);
pascal long StackSpace		(void);
#define MemError()		(* (OSErr*) 0x0220)
</PRE>
<A NAME=HEADING150-164></A>
<H4>Freeing Memory</H4>
<PRE>
pascal Size CompactMem		(Size cbNeeded);
pascal Size CompactMemSys	(Size cbNeeded);
pascal void PurgeMem		(Size cbNeeded);
pascal void PurgeMemSys		(Size cbNeeded);
pascal Size MaxMem		(Size *grow);
pascal Size MaxMemSys		(Size *grow);
</PRE>
<A NAME=HEADING150-171></A>
<H4>Grow-Zone Operations</H4>
<PRE>
pascal void SetGrowZone		(GrowZoneProcPtr growZone);
#define GZSaveHnd()		(* (Handle*) 0x0328)
</PRE>
<A NAME=HEADING150-174></A>
<H4>Allocating Temporary Memory</H4>
<PRE>
pascal Handle TempNewHandle	(Size logicalSize, OSErr *resultCode);
pascal long TempFreeMem		(void);
pascal Size TempMaxMem		(Size *grow);
</PRE>
<A NAME=HEADING150-178></A>
<H4>Accessing Heap Zones</H4>
<PRE>
pascal THz GetZone		(void);
pascal void SetZone		(THz hz);
#define ApplicationZone() 	(* (THz*) 0x02AA)
#define SystemZone() 		(* (THz*) 0x02A6)
pascal THz HandleZone		(Handle h);
pascal THz PtrZone		(Ptr p);
</PRE>
<A NAME=HEADING150-185></A>
<H4>Manipulating Heap Zones</H4>
<PRE>
#define GetApplLimit() 		(* (Ptr*) 0x0130)
pascal void SetApplLimit	(void *zoneLimit);
#define TopMem() 		(* (Ptr*) 0x0108)
pascal void InitZone		(GrowZoneProcPtr pgrowZone, short cmoreMasters, 
				void *limitPtr, void *startPtr);
pascal void InitApplZone	(void);
pascal void SetApplBase		(void *startPtr);
</PRE>
<A NAME=HEADING150-192></A>
<H3>Application-Defined Routines</H3>
<A NAME=HEADING150-193></A>
<H4>Grow-Zone Functions</H4>
<PRE>
pascal long MyGrowZone		(Size cbNeeded);
</PRE>
<A NAME=HEADING150-195></A>
<H4>Purge-Warning Procedures</H4>
<PRE>
pascal void MyPurgeProc		(Handle h);
</PRE>
<A NAME=HEADING150-197></A>
<H2>Assembly-Language Summary</H2>
<A NAME=HEADING150-198></A>
<H3>Constants</H3>
<PRE>
;flags in trap words
CLEAR             EQU      $200     ;set all bytes in block to 0
SYS               EQU      $400     ;use the system heap
;values for the tag byte of a block header
tyBkFree          EQU      0        ;free block
tyBkNRel          EQU      1        ;nonrelocatable block
tyBkRel           EQU      2        ;relocatable block
;flags for the high-order byte of a 24-bit master pointer
lock              EQU      7        ;lock bit
purge             EQU      6        ;purge bit
resource          EQU      5        ;resource bit
</PRE>
<A NAME=HEADING150-202></A>
<H3>Data Structures</H3>
<A NAME=HEADING150-203></A>
<H4>Zone Data Structure
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>0<TH>bkLim<TH>long<TH>pointer to first usable byte after zone<TR>
<TD>4<TD>purgePtr<TD>long<TD>used internally<TR>
<TD>8<TD>hFstFree<TD>long<TD>first free master pointer<TR>
<TD>12<TD>zcbFree<TD>4 bytes<TD>number of free bytes in zone<TR>
<TD>16<TD>gzProc<TD>long<TD>grow-zone function<TR>
<TD>20<TD>mAllocCnt<TD>word<TD>number of master pointers to allocate<TR>
<TD>22<TD>flags<TD>word<TD>used internally<TR>
<TD>24<TD>cntRel<TD>word<TD>reserved<TR>
<TD>26<TD>maxRel<TD>word<TD>reserved<TR>
<TD>28<TD>cntNRel<TD>word<TD>reserved<TR>
<TD>30<TD>maxNRel<TD>word<TD>reserved<TR>
<TD>32<TD>cntEmpty<TD>word<TD>reserved<TR>
<TD>34<TD>cntHandles<TD>word<TD>reserved<TR>
<TD>36<TD>minCBFree<TD>long<TD>reserved<TR>
<TD>40<TD>purgeProc<TD>long<TD>purge-warning procedure<TR>
<TD>44<TD>sparePtr<TD>long<TD>used internally<TR>
<TD>48<TD>allocPtr<TD>long<TD>used internally<TR>
<TD>52<TD>heapData<TD>word<TD>first usable byte in zone</TABLE>
</H4>
<A NAME=HEADING150-204></A>
<H4>Parameter Block for <CODE>InitZone</CODE> Procedure
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>0<TH>startPtr<TH>long<TH>first byte of new zone<TR>
<TD>4<TD>limitPtr<TD>long<TD>first byte beyond new zone<TR>
<TD>8<TD>cMoreMasters<TD>word<TD>number of master pointers to be allocated at a time<TR>
<TD>10<TD>pGrowZone<TD>long<TD>pointer to grow-zone function for new zone</TABLE>
</H4>
<A NAME=HEADING150-205></A>
<H3>Trap Macros</H3>
<A NAME=HEADING150-206></A>
<H4>Trap Macro Names
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Pascal name<TH>Trap macro name<TR>
<TD>BlockMove<TD>_BlockMove<TR>
<TD>CompactMem<TD>_CompactMem<TR>
<TD>CompactMemSys<TD>_CompactMem<TR>
<TD>DisposeHandle<TD>_DisposeHandle<TR>
<TD>DisposePtr<TD>_DisposePtr<TR>
<TD>EmptyHandle<TD>_EmptyHandle<TR>
<TD>FreeMem<TD>_FreeMem<TR>
<TD>FreeMemSys<TD>_FreeMem<TR>
<TD>GetHandleSize<TD>_GetHandleSize<TR>
<TD>GetPtrSize<TD>_GetPtrSize<TR>
<TD>GetZone<TD>_GetZone<TR>
<TD>HandAndHand<TD>_HandAndHand<TR>
<TD>HandleZone<TD>_HandleZone<TR>
<TD>HandToHand<TD>_HandToHand<TR>
<TD>HClrRBit<TD>_HClrRBit<TR>
<TD>HGetState<TD>_HGetState<TR>
<TD>HLock<TD>_HLock<TR>
<TD>HNoPurge<TD>_HNoPurge<TR>
<TD>HPurge<TD>_HPurge<TR>
<TD>HSetRBit<TD>_HSetRBit<TR>
<TD>HSetState<TD>_HSetState<TR>
<TD>HUnlock<TD>_HUnlock<TR>
<TD>InitApplZone<TD>_InitApplZone<TR>
<TD>InitZone<TD>_InitZone<TR>
<TD>MaxApplZone<TD>_MaxApplZone<TR>
<TD>MaxBlock<TD>_MaxBlock<TR>
<TD>MaxBlockSys<TD>_MaxBlock<TR>
<TD>MaxMem<TD>_MaxMem<TR>
<TD>MaxMemSys<TD>_MaxMem<TR>
<TD>MoreMasters<TD>_MoreMasters<TR>
<TD>MoveHHi<TD>_MoveHHi<TR>
<TD>NewEmptyHandle<TD>_NewEmptyHandle<TR>
<TD>NewEmptyHandleSys<TD>_NewEmptyHandle<TR>
<TD>NewHandle<TD>_NewHandle<TR>
<TD>NewHandleClear<TD>_NewHandle<TR>
<TD>NewHandleSys<TD>_NewHandle<TR>
<TD>NewHandleSysClear<TD>_NewHandle<TR>
<TD>NewPtr<TD>_NewPtr<TR>
<TD>NewPtrClear<TD>_NewPtr<TR>
<TD>NewPtrSys<TD>_NewPtr<TR>
<TD>NewPtrSysClear<TD>_NewPtr<TR>
<TD>PtrAndHand<TD>_PtrAndHand<TR>
<TD>PtrToHand<TD>_PtrToHand<TR>
<TD>PtrToXHand<TD>_PtrToXHand<TR>
<TD>PtrZone<TD>_PtrZone<TR>
<TD>PurgeMem<TD>_PurgeMem<TR>
<TD>PurgeMemSys<TD>_PurgeMem<TR>
<TD>PurgeSpace<TD>_PurgeSpace<TR>
<TD>ReallocateHandle<TD>_ReallocHandle<TR>
<TD>RecoverHandle<TD>_RecoverHandle<TR>
<TD>ReserveMem<TD>_ResrvMem<TR>
<TD>ReserveMemSys<TD>_ResrvMem<TR>
<TD>SetApplBase<TD>_SetApplBase<TR>
<TD>SetApplLimit<TD>_SetApplLimit<TR>
<TD>SetGrowZone<TD>_SetGrowZone<TR>
<TD>SetHandleSize<TD>_SetHandleSize<TR>
<TD>SetPtrSize<TD>_SetPtrSize<TR>
<TD>SetZone<TD>_SetZone<TR>
<TD>StackSpace<TD>_StackSpace</TABLE>
</H4>
<A NAME=HEADING150-207></A>
<H4>Trap Macro Requiring Routine Selectors</H4>
<PRE>
<CODE>_OSDispatch<A NAME=MARKER-2-534></A></CODE>
<TABLE BORDER="0" CELLPADDING=3><TD>Selector<TD>Routine<TR>
<TD>$0015<TD>TempMaxMem<TR>
<TD>$0018<TD>TempFreeMem<TR>
<TD>$001D<TD>TempNewHandle</TABLE>
<CODE></CODE>
</PRE>
<A NAME=HEADING150-209></A>
<H3>Global Variables
<TABLE BORDER="0" CELLPADDING=3><TD>ApplLimit<TD>long<TD>The application heap limit, beyond which the heap cannot expand.<TR>
<TD>ApplZone<TD>long<TD>A pointer to the original application heap zone.<TR>
<TD>BufPtr<TD>long<TD>Address of highest byte of allocatable memory.<TR>
<TD>CurStackBase<TD>long<TD>Address of base of stack; start of application global variables.<A NAME=MARKER-2-162></A><TR>
<TD>GZRootHnd<TD>long<TD>A handle to a block that the grow-zone function must not move.<TR>
<TD>HeapEnd<TD>long<TD>Address of end of application heap zone.<A NAME=MARKER-2-86></A><TR>
<TD>MemErr<TD>word<TD>The current value that <CODE>MemError</CODE> would return.<TR>
<TD>MemTop<TD>long<TD>After startup time, the address at the end of an application's partition.<TR>
<TD>SysZone<TD>long<TD>A pointer to the system heap zone.<TR>
<TD>TheZone<TD>long<TD>A pointer to the current heap zone.</TABLE>
</H3>
<A NAME=HEADING150-210></A>
<H2>Result Codes
<TABLE BORDER="0" CELLPADDING=3><TD>noErr<TD>0<TD>No error<TR>
<TD>paramErr<TD>-50<TD>Error in parameter list<TR>
<TD>memROZErr<TD>-99<TD>Operation on a read-only zone<TR>
<TD>memFullErr<TD>-108<TD>Not enough memory<TR>
<TD>nilHandleErr<TD>-109<TD><CODE>NIL</CODE> master pointer<TR>
<TD>memWZErr<TD>-111<TD>Attempt to operate on a free block<TR>
<TD>memPurErr<TD>-112<TD>Attempt to purge a locked block<TR>
<TD>memBCErr<TD>-115<TD>Block check failed<TR>
<TD>memLockedErr<TD>-117<TD>Block is locked</TABLE>
</H2>
 <A NAME=MARKER-2-34></A><A NAME=MARKER-2-536></A><A NAME=MARKER-2-537></A><A NAME=MARKER-2-538></A><A NAME=MARKER-2-103></A><A NAME=MARKER-2-540></A><A NAME=MARKER-2-204></A><A NAME=MARKER-2-542></A><P>
</BLOCKQUOTE><P>

<HR>
<center>
<A HREF="Memory-149.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-151.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Memory-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
