<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>UniversalHIDModuleTest - /UHIDTest.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">UniversalHIDModuleTest</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/index.html" target="_blank">Reference Library > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">UniversalHIDModuleTest</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/UHIDTest.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/TestHIDprobe.c</option>
<option value="listing2.html">/UHIDTest.c</option></select>
				</p>
				</form>
				<p><strong><a href="UniversalHIDModuleTest.zip">Download Sample</a></strong> (&#147;UniversalHIDModuleTest.zip&#148;, 15.1K)<BR>
<strong><a href="UniversalHIDModuleTest.dmg">Download Sample</a></strong> (&#147;UniversalHIDModuleTest.dmg&#148;, 75.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    UHIDTest.c  Contains:  xxx put contents here xxx  Version:  xxx put version here xxx  Copyright:  &copy; 1999 by Apple Computer, Inc., all rights reserved.  File Ownership:    DRI:        xxx put dri here xxx    Other Contact:    xxx put other contact here xxx    Technology:      xxx put technology here xxx  Writers:    (BWS)  Brent Schorsch  Change History (most recent first):     &lt;SP6&gt;   3/20/99  BWS    Update to lastest HIDOpenReportDescriptor API     &lt;SP5&gt;    3/7/99  BWS    Add Simulate ISp enumeration - similar code to ISp driver     &lt;SP4&gt;    3/7/99  BWS    Print out caps usage page and usage. Print all usages in hex     &lt;SP3&gt;    3/7/99  BWS    Implemented get capabilities and print parsed data     &lt;SP2&gt;    3/5/99  BWS    Added HIDLib calls*/#include &lt;MacTypes.h&gt;#include &lt;SIOUX.h&gt;#include &lt;LowMem.h&gt;#include &lt;USB.h&gt;#include &lt;InputSprocket.h&gt;#include &quot;HID.h&quot;//#include &quot;UniversalHIDModule.h&quot;#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//#include &quot;HIDPriv.h&quot;// extern protosextern void PrintHIDReport(UInt8 * reportDesc, UInt32 length);// globals// quit stateBoolean              gShouldQuit = false;// steps of processSInt32               gStep;char               gStepId[255];// 'safe' (delayed) printfenum { kPrintfBufferSize    = 1024 * 32 };UInt32              gMaxPacketSize;char              gPrintfBuffer1[kPrintfBufferSize + 256];char              gPrintfBuffer2[kPrintfBufferSize + 256];char *              gInsertPrintfBuffer;char *              gFreePrintfBuffer;UInt32              gInsertIndex = 0;enum{  kPrint_AsHex      = 1,  kPrint_AsBinary,  kPrint_ParseButtons,  kPrint_ParseBoth,  kPrint_SimulateISp};UInt32              gPrint_AsType;// HID stuff// these constants are from the USB HID Usage Table specenum{  kHIDPage_Generic    = 1,  kHIDUsage_Joystick    = 0x04,  kHIDUsage_Gamepad    = 0x05,  kHIDUsage_X        = 0x30,  kHIDUsage_Y        = 0x31,  kHIDUsage_Z        = 0x32,  kHIDUsage_Rx      = 0x33,  kHIDUsage_Ry      = 0x34,  kHIDUsage_Rz      = 0x35,  kHIDUsage_Slider    = 0x36,  kHIDUsage_Dial      = 0x37,  kHIDUsage_Wheel      = 0x38,  kHIDUsage_HatSwitch    = 0x39,    kHIDPage_Simulation    = 2,  kHIDUsage_Rudder    = 0xBA,  kHIDUsage_Throttle    = 0xBB,  kHIDPage_Button      = 9};// these constants are used to describe specific values for an element (a usbElementKey)enum{  // it is important that all buttons come first and start at 1  kUSB_button1_element = 1,  kUSB_button2_element,  kUSB_button3_element,  kUSB_button4_element,  kUSB_button5_element,  kUSB_button6_element,  kUSB_button7_element,  kUSB_button8_element,  kUSB_button9_element,  kUSB_button10_element,  kUSB_button11_element,  kUSB_button12_element,  kUSB_button13_element,  kUSB_button14_element,  kUSB_button15_element,  kUSB_button16_element,  kUSB_trigger_element,  kUSB_buttonStart_element,  kUSB_buttonSelect_element,  kUSB_povhat_element,  kUSB_povhat4_element,  kUSB_dpad_element,  kUSB_dpad4_element,  kUSB_xaxis_element,  kUSB_yaxis_element,  kUSB_throttle_element,  kUSB_rudder_element,  kUSB_trim_element,  kUSB_gas_element,  kUSB_brake_element,  kUSB_axis_element};enum{  kStrListResource_DefaultNames = 128};enum{  kStrList_DefaultNames_Trigger = 1,  kStrList_DefaultNames_LeftTrigger,  kStrList_DefaultNames_RightTrigger,  kStrList_DefaultNames_LeftIndexTop,  kStrList_DefaultNames_LeftIndexBottom,  kStrList_DefaultNames_RightIndexTop,  kStrList_DefaultNames_RightIndexBottom,  kStrList_DefaultNames_ThumbLeftButton,  kStrList_DefaultNames_ThumbCenterButton,  kStrList_DefaultNames_ThumbRightButton,  kStrList_DefaultNames_ThumbTopButton,  kStrList_DefaultNames_ThumbBottomButton,  kStrList_DefaultNames_AButton,  kStrList_DefaultNames_BButton,  kStrList_DefaultNames_CButton,  kStrList_DefaultNames_DButton,  kStrList_DefaultNames_EButton,  kStrList_DefaultNames_FButton,  kStrList_DefaultNames_XButton,  kStrList_DefaultNames_YButton,  kStrList_DefaultNames_ZButton,  kStrList_DefaultNames_MButton,  kStrList_DefaultNames_TAButton,  kStrList_DefaultNames_TBButton,  kStrList_DefaultNames_F1Button,  kStrList_DefaultNames_F2Button,  kStrList_DefaultNames_F3Button,  kStrList_DefaultNames_F4Button,  kStrList_DefaultNames_F5Button,  kStrList_DefaultNames_F6Button,  kStrList_DefaultNames_F7Button,  kStrList_DefaultNames_F8Button,  kStrList_DefaultNames_YellowButton,  kStrList_DefaultNames_RedButton,  kStrList_DefaultNames_GreenButton,  kStrList_DefaultNames_BlueButton,  kStrList_DefaultNames_StartButton,  kStrList_DefaultNames_SelectButton,  kStrList_DefaultNames_ShiftButton,  kStrList_DefaultNames_LeftShiftButton,  kStrList_DefaultNames_RightShiftButton,  kStrList_DefaultNames_SensorButton,  kStrList_DefaultNames_Button1,  kStrList_DefaultNames_Button2,  kStrList_DefaultNames_Button3,  kStrList_DefaultNames_Button4,  kStrList_DefaultNames_Button5,  kStrList_DefaultNames_Button6,  kStrList_DefaultNames_Button7,  kStrList_DefaultNames_Button8,  kStrList_DefaultNames_Button9,  kStrList_DefaultNames_Button10,  kStrList_DefaultNames_Button11,  kStrList_DefaultNames_Button12,  kStrList_DefaultNames_Button13,  kStrList_DefaultNames_Button14,  kStrList_DefaultNames_Button15,  kStrList_DefaultNames_Button16,  kStrList_DefaultNames_Button,  kStrList_DefaultNames_POVHat,  kStrList_DefaultNames_DPad,  kStrList_DefaultNames_XAxis,  kStrList_DefaultNames_YAxis,  kStrList_DefaultNames_XTilt,  kStrList_DefaultNames_YTilt,  kStrList_DefaultNames_Twist,  kStrList_DefaultNames_Throttle,  kStrList_DefaultNames_Trim,  kStrList_DefaultNames_Rudder,  kStrList_DefaultNames_Axis,  kStrList_DefaultNames_Wheel,  kStrList_DefaultNames_Gas,  kStrList_DefaultNames_Brake,  kStrList_DefaultNames_Error};enum{  kButtonElement  = 1,  kValueElement  = 2};struct  HIDElement{  UInt32    type;  UInt32    capsIndex;  HIDUsage  usagePage;  HIDUsage  usage;  UInt32    key;  SInt32    min;  SInt32    max;  SInt32    stringIndex;};typedef struct HIDElement HIDElement;HIDCaps        gHIDCaps;HIDButtonCaps *    gHIDButtonCaps;HIDValueCaps *    gHIDValueCaps;HIDElement *    gHIDElements;UInt32        gHIDElementCount = 0;enum { kMaxReportDescSize    = 1024 };UInt8              gReportDesc[kMaxReportDescSize];UInt32              gReportDescLength;HIDPreparsedDataRef        gPreparsedDataRef;HIDPreparsedData        gPreparsedData;UInt32              gMaxUsageListLength = 0;HIDUsageAndPage *        gPreviousDownButtons = nil;HIDUsageAndPage *        gCurrentDownButtons = nil;// lists of dispatch tablesenum { kMaxDevices    = 128 };UHIDModuleDispatchTablePtr    gUHID_dispatchTables[kMaxDevices];int                gUHID_count = 0;UHIDModuleDispatchTablePtr    gCurrentUHID_dispatchTable;UHIDModuleConnectionID      gCurrentUHIDModuleConnectionID;USBHIDModuleDispatchTablePtr  gMouse_dispatchTables[kMaxDevices];int                gMouse_count = 0;// macros#define VERIFY(x)  if (x) { FailCode(x); return; }#define FAILMSG(x) { FailMsg(x); return; }#define FAILCODE(x) { FailCode(x); return; }#define FFAILMSG(x) { FailMsg(x); return false; }#define FFAILCODE(x) { FailCode(x); return false; }// protosvoid   ShowFourByte(OSType fourByte);void   ExitProc (void);void   DoHIDTest (void);void  GetButtonCapabilities (void);void  GetValueCapabilities (void);void  PrintButtonCapabilities (HIDCaps hidCaps, HIDButtonCaps * hidButtonCaps);void  PrintValueCapabilities (HIDCaps hidCaps, HIDValueCaps * hidValueCaps);void  ClaimAndInstallHandler (void);void  RemoveHandlerAndRelease (void);void   myUniversalInterruptProc(void * theData, UInt32 refcon);OSStatus  HidP_PrintAllInputValues          (UInt32                       iCollection,          HIDPreparsedDataPtr       ptPreparsedData,           char                      *psReport,           int                        iReportLength);int safeprintf(const char *format, ...);void PrintPreparsedData (void);void PrintCollectionItems (UInt32 firstCollection, UInt32 collectionCount, char * indent);void PrintReportItems (UInt32 firstReportItem, UInt32 reportItemCount, char * indent);void PrintUsageItems (UInt32 firstUsageItem, UInt32 usageItemCount, char * indent);void    SimulateISpEnumeration (void);OSStatus   PrintHIDElements (void);OSStatus   BuildHIDElements (void);UInt32     CountHIDElements(void);OSStatus   InitializeHIDElement(HIDElement * hidElement);SInt32    ParseElementValue (UInt32 inElementIndex, Ptr inBuffer);// codestatic Boolean Progress(UInt32 inItr, UInt32 inTotal, UInt32 inNumReports, char *string){  UInt32 everyNTimes = inTotal / inNumReports;    if (everyNTimes == 0) { everyNTimes = 1; }    if (inItr == 0) { return false; }    if ((inItr % everyNTimes) == 0)  {    UInt32 percent = (inItr * 100) / inTotal;    sprintf(string, &quot;%d%% [%d of %d]&quot;, percent, inItr, inTotal);    return true;  }    return false;}static void InitStep(char *msg){  gStep = 0;  sprintf(gStepId, &quot;%3d&quot;);    if (msg == nil)  {    printf(&quot;step %s\n&quot;, gStepId);  }  else  {    printf(&quot;step %s %s\n&quot;,gStepId, msg);  }}static void NextStep(char *msg){  long this_app_memory;  long this_sys_memory;  static Boolean first_time = true;  static long last_app_memory;  static long last_sys_memory;  gStep++;  sprintf(gStepId, &quot;%3d&quot;, gStep);  this_app_memory = FreeMem();  this_sys_memory = FreeMemSys();  if (first_time)    {    first_time = false;  }  else  {    long delta_app_memory = last_app_memory - this_app_memory;    long delta_sys_memory = last_sys_memory - this_sys_memory;        printf(&quot;step %s ending app mem = %d sys mem = %d\n&quot;, gStepId, this_app_memory, this_sys_memory);    printf(&quot;step %s delta app mem = %d sys mem = %d\n&quot;, gStepId, delta_app_memory, delta_sys_memory);  }  if (msg == nil)  {    printf(&quot;step %s\n&quot;, gStepId);  }  else  {    printf(&quot;step %s %s\n&quot;,gStepId, msg);  }  printf(&quot;step %s starting app mem = %d sys mem = %d\n&quot;, gStepId, this_app_memory, this_sys_memory);  last_app_memory = this_app_memory;  last_sys_memory = this_sys_memory;}static void FailMsg(char *failure){  printf(&quot;step %s FAILED reason = %s\n&quot;, gStepId, failure);}static void FailCode(OSStatus errorCode){  printf(&quot;step %s FAILED errorCode = %d\n&quot;, gStepId, errorCode);}static void StatusMsg(char *msg){  printf(&quot;step %s status msg = %s\n&quot;,gStepId, msg);}void ShowFourByte(OSType fourByte){  putchar(((fourByte &amp; 0xff000000) &gt;&gt; 24));  putchar(((fourByte &amp; 0x00ff0000) &gt;&gt; 16));  putchar(((fourByte &amp; 0x0000ff00) &gt;&gt; 8));  putchar(((fourByte &amp; 0x000000ff) &gt;&gt; 00));}void main(void){  OSErr               status = noErr;  CFragConnectionID        usbConnID;  USBDeviceRef          usbDeviceRef;  CFragSymbolClass        symClass;  UHIDModuleDispatchTablePtr    uHID_dispatchTable;//  USBHIDModuleDispatchTablePtr  mouse_dispatchTable;  UInt16               vendor;  UInt16               product;  THz                currentZone;      #if defined(__MWERKS__)  // tell SIOUX to shut up  SIOUXSettings.autocloseonquit = false;  SIOUXSettings.asktosaveonclose = false;  SIOUXSettings.columns = 120;  SIOUXSettings.rows = 70;#endif    printf(&quot;starting up...\n&quot;);    printf(&quot;searching for universal HID devices\n&quot;);    usbDeviceRef = 0;  while (status == noErr &amp;&amp; gUHID_count &lt; kMaxDevices)  {    printf (&quot;searching for next device...\n&quot;);        status = USBGetNextDeviceByClass (&amp;usbDeviceRef, &amp;usbConnID, kUSBHIDClass, kUSBCompositeSubClass, kUSBNoInterfaceProtocol);    if (status)    {      if (status != kUSBNotFound &amp;&amp; status != fnfErr)        FailCode (status);      continue;    }        printf (&quot;candidate found (connID: %00000008x), searching for symbol...\n&quot;, usbConnID);        // need to be in the system zone when we search for the symbol    currentZone = GetZone ();    SetZone (SystemZone ());    status = FindSymbol (usbConnID, &quot;\pTheUHIDModuleDispatchTable&quot;, (Ptr *)&amp;uHID_dispatchTable, &amp;symClass);    SetZone (currentZone);        // if we failed to find it, go on to the next device      if (status)    {      FailCode (status);      status = noErr;       continue;    }        printf(&quot;symbol found, checking versions...\n&quot;);        // version checking    if (uHID_dispatchTable-&gt;dispatchTableCurrentVersion &lt; kOldestCompatableDispatchTableVersion)    {      printf (&quot;         DispatchTable current version (%d) too old (%d)\n&quot;,         uHID_dispatchTable-&gt;dispatchTableCurrentVersion, kOldestCompatableDispatchTableVersion);      continue;    }    if (uHID_dispatchTable-&gt;dispatchTableOldestVersion &gt; kCurrentDispatchTableVersion)    {      printf (&quot;         DispatchTable oldest version (%d) too new (%d)\n&quot;,         uHID_dispatchTable-&gt;dispatchTableOldestVersion, kCurrentDispatchTableVersion);      continue;    }        gUHID_dispatchTables[gUHID_count++] = uHID_dispatchTable;      (UHIDInstallInterruptProcPtr)(*(uHID_dispatchTable-&gt;pUHIDGetDeviceInfo))(kUHIDGetVenderID, &amp;vendor);    (UHIDInstallInterruptProcPtr)(*(uHID_dispatchTable-&gt;pUHIDGetDeviceInfo))(kUHIDGetProductID, &amp;product);    printf(&quot;version check success, valid device (Vender:%0004X Product:%0004X).\n&quot;, vendor, product);  }    while (gUHID_count &gt; 0 &amp;&amp; !gShouldQuit)    DoHIDTest();    printf(&quot;quitting...\n&quot;);}void   ExitProc (void){  RemoveHandlerAndRelease ();}void DoHIDTest (void){  OSErr               status = noErr;  UHIDModuleDispatchTablePtr    uHID_dispatchTable;//  USBHIDModuleDispatchTablePtr  mouse_dispatchTable;  UInt16               vendor;  UInt16               product;  int                index;  char               string[256];choosedevice:  // *** memory leak here, but who cares for now... (We never dispose of these)  gHIDElementCount = 0;    printf (&quot;\nChoose a device:\n&quot;);    // choice to quit  printf (&quot;1. Exit\n&quot;);  // print out UHID choices  index = 0;  while (index &lt; gUHID_count)  {    uHID_dispatchTable = gUHID_dispatchTables[index];    (UHIDInstallInterruptProcPtr)(*(uHID_dispatchTable-&gt;pUHIDGetDeviceInfo))(kUHIDGetVenderID, &amp;vendor);    (UHIDInstallInterruptProcPtr)(*(uHID_dispatchTable-&gt;pUHIDGetDeviceInfo))(kUHIDGetProductID, &amp;product);    printf (&quot;%d. Vender:%0004X Product:%0004X\n&quot;, index + 2, vendor, product);    index++;  }  // * todo *\xCAprint out mouse choices  // get user choice  printf (&quot;Selection: &quot;);  gets (string);  index = atoi (string);  printf (&quot;\n&quot;);    // handle the quit case  if (index == 1)  {    gShouldQuit = true;    return;  }    // setup for this device  uHID_dispatchTable = gCurrentUHID_dispatchTable = gUHID_dispatchTables[index - 2];    // init the printf double buffer  gInsertPrintfBuffer = gPrintfBuffer1;  gFreePrintfBuffer = gPrintfBuffer2;  gInsertIndex = 0;    // get the max packet size  gMaxPacketSize = 0;  (UHIDInstallInterruptProcPtr)(*(uHID_dispatchTable-&gt;pUHIDGetDeviceInfo))(kUHIDGetMaxPacketSize, &amp;gMaxPacketSize);  printf(&quot;Max packet size = %d\n&quot;, gMaxPacketSize);    printf(&quot;Printing the report descriptor\n&quot;, status);  // print the HID report descriptor  gReportDescLength = sizeof (gReportDesc);  status = (*uHID_dispatchTable-&gt;pUHIDGetHIDDescriptor)(kUSBReportDesc, 0, &amp;gReportDescLength, gReportDesc);  if (status)    printf(&quot;*** Error (%d) on Get Report Descriptor Device\n&quot;, status);  else    PrintHIDReport(gReportDesc, gReportDescLength);    // setup the HID stuff  status = HIDOpenReportDescriptor (gReportDesc, gReportDescLength, &amp;gPreparsedDataRef, kHIDFlag_StrictErrorChecking);  if (status)    printf(&quot;*** Error (%d) on HIDOpenDescriptor (strict error checking) \n&quot;, status);    // if error, less error checking on the HID stuff  if (status)  {    status = HIDOpenReportDescriptor (gReportDesc, gReportDescLength, &amp;gPreparsedDataRef, 0);    if (status)      printf(&quot;*** Error (%d) on HIDOpenDescriptor\n&quot;, status);    else      printf(&quot;HIDOpenDescriptor (lax error checking) succeeded. \n&quot;, status);  }    // allocate our buffers  gMaxUsageListLength = HIDMaxUsageListLength (kHIDInputReport, 0, gPreparsedDataRef);  printf(&quot;Number of buttons (max usage list length) = %ld\n&quot;, gMaxUsageListLength);    gPreviousDownButtons = (HIDUsageAndPage *) NewPtr (gMaxUsageListLength * sizeof (HIDUsageAndPage));  if (gPreviousDownButtons == nil)    printf(&quot;*** Error (%d) on NewPtr for gPreviousDownButtons\n&quot;, MemError());  gCurrentDownButtons = (HIDUsageAndPage *) NewPtr (gMaxUsageListLength * sizeof (HIDUsageAndPage));  if (gCurrentDownButtons == nil)    printf(&quot;*** Error (%d) on NewPtr for gCurrentDownButtons\n&quot;, MemError());  printf(&quot;gPreviousDownButtons = %lx, gCurrentDownButtons = %lx\n&quot;, gPreviousDownButtons, gCurrentDownButtons);whattoget:  printf (&quot;1. Exit\n&quot;);  printf (&quot;2. Choose another device\n&quot;);  printf (&quot;3. Get data\n&quot;);  printf (&quot;4. Get button capabilities\n&quot;);  printf (&quot;5. Get value capabilities\n&quot;);  printf (&quot;6. Print preparsed data\n&quot;);  printf (&quot;7. Simulate ISp Enumeration\n&quot;);    // get user choice  printf (&quot;Selection: &quot;);  gets (string);  index = atoi (string);  printf (&quot;\n&quot;);    switch (index)  {    // exit    case 1:      gShouldQuit = true;      goto close;        case 2:      goto choosedevice;        case 3:      break;        case 4:      GetButtonCapabilities();            goto whattoget;        case 5:      GetValueCapabilities();            goto whattoget;        case 6:      PrintPreparsedData();            goto whattoget;        case 7:      SimulateISpEnumeration();            goto whattoget;        default:      goto whattoget;  }getdata:  printf (&quot;1. Exit\n&quot;);  printf (&quot;2. Previous menu\n&quot;);  printf (&quot;3. Display raw bits as hex\n&quot;);  printf (&quot;4. Display raw bits as binary\n&quot;);  printf (&quot;5. Display parsed buttons\n&quot;);  printf (&quot;6. Display parsed values and buttons\n&quot;);  if (gHIDElementCount &gt; 0)    printf (&quot;7. Simulate ISp\n&quot;);    // get user choice  printf (&quot;Selection: &quot;);  gets (string);  index = atoi (string);  printf (&quot;\n&quot;);      // make as binary the default, and use in the unimplemented cases?  gPrint_AsType = kPrint_AsBinary;    switch (index)  {    // exit    case 1:      gShouldQuit = true;      goto close;        case 2:      goto whattoget;        case 3:      gPrint_AsType = kPrint_AsHex;      break;    case 4:      gPrint_AsType = kPrint_AsBinary;      break;    case 5:      gPrint_AsType = kPrint_ParseButtons;      break;    case 6:      gPrint_AsType = kPrint_ParseBoth;      break;    case 7:      if (gHIDElementCount &gt; 0)        gPrint_AsType = kPrint_SimulateISp;      else        goto getdata;      break;        default:      goto getdata;  }    ClaimAndInstallHandler();    // get data    printf(&quot;getting data (press command to end)\n&quot;);  while (1)  {    KeyMap theKeys;    if (gInsertIndex)  // if we have data in the queue, then printf it    {      char * temp = gInsertPrintfBuffer;            gInsertPrintfBuffer = gFreePrintfBuffer;  // must do 1st! - atomic switch      gInsertIndex = 0;              // _technically_ bad, could possibly miss some data            gFreePrintfBuffer = temp;            printf(temp);              fflush(stdout);    }    GetKeys(theKeys);    if ((theKeys[1] &amp; 0x8000))    {      break;    }        SIOUXHandleOneEvent(nil);    }    RemoveHandlerAndRelease ();    if (!gShouldQuit)    goto getdata;close:  status = HIDCloseReportDescriptor (gPreparsedDataRef);  if (status)    printf(&quot;*** Error (%d) on HIDCloseDescriptor\n&quot;, status);  DisposePtr ((void *) gPreviousDownButtons);  gPreviousDownButtons = nil;    DisposePtr ((void *) gCurrentDownButtons);  gCurrentDownButtons = nil;    printf(&quot;finished\n\n&quot;);}void  GetButtonCapabilities(void){  OSStatus err = noErr;    HIDCaps        hidCaps;  HIDButtonCaps *    hidButtonCaps = nil;  // get the overall capabilities of the device  if (err == noErr)    err = HIDGetCaps (gPreparsedDataRef, &amp;hidCaps);  // allocate space for button caps  if (err == noErr)  {    hidButtonCaps = (HIDButtonCaps *) NewPtrSysClear(sizeof(HIDButtonCaps) * hidCaps.numberInputButtonCaps);    if (hidButtonCaps == nil)    {      printf (&quot;\n** Failed to allocate space for ButtonCaps\n&quot;);      err = memFullErr;    }  }  // get the button capabilities  if (err == noErr)    err = HIDGetButtonCaps (kHIDInputReport, hidButtonCaps, &amp;hidCaps.numberInputButtonCaps, gPreparsedDataRef);    // print what we found  if (err == noErr)    PrintButtonCapabilities (hidCaps, hidButtonCaps);    // dispose the memory  if (hidButtonCaps != nil)    DisposePtr((LogicalAddress) hidButtonCaps);}void  GetValueCapabilities (void){  OSStatus err = noErr;    HIDCaps        hidCaps;  HIDValueCaps *    hidValueCaps = nil;  // get the overall capabilities of the device  if (err == noErr)    err = HIDGetCaps (gPreparsedDataRef, &amp;hidCaps);  // allocate space for value caps  if (err == noErr)  {    hidValueCaps = (HIDValueCaps *) NewPtrSysClear(sizeof(HIDValueCaps) * hidCaps.numberInputValueCaps);    if (hidValueCaps == nil)    {      err = memFullErr;      printf (&quot;\n** Failed to allocate space for ValueCaps\n&quot;);    }  }  // get the value capabilities  if (err == noErr)    err = HIDGetValueCaps (kHIDInputReport, hidValueCaps, &amp;hidCaps.numberInputValueCaps, gPreparsedDataRef);  // print what we found  if (err == noErr)    PrintValueCapabilities (hidCaps, hidValueCaps);    // dispose the memory  if (hidValueCaps != nil)    DisposePtr((LogicalAddress) hidValueCaps);}void  PrintButtonCapabilities (HIDCaps hidCaps, HIDButtonCaps * hidButtonCaps){  UInt32  index;  UInt32  reportID = 0;    printf(&quot;%d buttons (device usage: %X on page: %d)\n&quot;,     hidCaps.numberInputButtonCaps,     hidCaps.usage,     hidCaps.usagePage);  for (index = 0; index &lt; hidCaps.numberInputButtonCaps; index++)  {    if (reportID != hidButtonCaps[index].reportID)    {      reportID = hidButtonCaps[index].reportID;      printf(&quot;Report ID: %d\n&quot;, reportID);    }        if (hidButtonCaps[index].isRange)      printf(&quot;%X-%X:%d\n&quot;,         hidButtonCaps[index].u.range.usageMin,         hidButtonCaps[index].u.range.usageMax,         hidButtonCaps[index].usagePage);    else      printf(&quot;%X:%d\n&quot;,         hidButtonCaps[index].u.notRange.usage,         hidButtonCaps[index].usagePage);  }  printf(&quot;\n\n&quot;);}void  PrintValueCapabilities (HIDCaps hidCaps, HIDValueCaps * hidValueCaps){  UInt32  index;  UInt32  reportID = 0;    printf(&quot;%d values (device usage:%d on page:%d\n&quot;,     hidCaps.numberInputValueCaps,     hidCaps.usage,     hidCaps.usagePage);  for (index = 0; index &lt; hidCaps.numberInputValueCaps; index++)  {    if (reportID != hidValueCaps[index].reportID)    {      reportID = hidValueCaps[index].reportID;      printf(&quot;Report ID: %d\n&quot;, reportID);    }        if (hidValueCaps[index].isRange)      printf(&quot;%X-%X:%d\t\t(%d&lt;-&gt;%d)\t(%d&lt;-&gt;%d)\t\t[%d * %d]\t\t****\n&quot;,         hidValueCaps[index].u.range.usageMin,         hidValueCaps[index].u.range.usageMax,         hidValueCaps[index].usagePage,        hidValueCaps[index].logicalMin,        hidValueCaps[index].logicalMax,        hidValueCaps[index].physicalMin,        hidValueCaps[index].physicalMax,        hidValueCaps[index].bitSize,        hidValueCaps[index].reportCount);    else      printf(&quot;%X:%d\t\t(%d&lt;-&gt;%d)\t(%d&lt;-&gt;%d)\t\t[%d * %d]\n&quot;,         hidValueCaps[index].u.notRange.usage,         hidValueCaps[index].usagePage,        hidValueCaps[index].logicalMin,        hidValueCaps[index].logicalMax,        hidValueCaps[index].physicalMin,        hidValueCaps[index].physicalMax,        hidValueCaps[index].bitSize,        hidValueCaps[index].reportCount);    if (hidValueCaps[index].reportCount &gt; 1)      printf(&quot;*** Report Count &gt; 1\n&quot;);  }        printf(&quot;\n\n&quot;);}void  ClaimAndInstallHandler (void){  OSErr               status = noErr;  UHIDModuleConnectionID      uHIDModuleConnectionID;  if (gCurrentUHID_dispatchTable == nil)  {    printf(&quot;*** Error: have not specified a device\n&quot;);    return;  }    if (gCurrentUHIDModuleConnectionID != 0)  {    printf(&quot;*** Error: Already have device active\n&quot;);    return;  }    printf(&quot;Claiming the device\n&quot;);  // claim the device  status = (OSStatus) ((UHIDClaimDeviceProcPtr)(*(gCurrentUHID_dispatchTable-&gt;pUHIDClaimDevice))              (&amp;uHIDModuleConnectionID, 0));  if (status)  {    printf(&quot;*** Error (%d) on Claim Device\n&quot;, status);    return;  }  gCurrentUHIDModuleConnectionID = uHIDModuleConnectionID;    // install the handler  printf(&quot;Installing the handler\n&quot;);  status = (OSStatus) ((UHIDInstallInterruptProcPtr)(*(gCurrentUHID_dispatchTable-&gt;pUHIDInstallInterrupt))              (uHIDModuleConnectionID, myUniversalInterruptProc, 0));  if (status)  {    printf(&quot;*** Error (%d) on Universal Interrupt Handler install\n&quot;, status);    return;  }  }void  RemoveHandlerAndRelease (void){  OSErr               status = noErr;    if (gCurrentUHID_dispatchTable == nil)  {    printf(&quot;*** Error have not specified a device\n&quot;);    return;  }    if (gCurrentUHIDModuleConnectionID == 0)    return;    // remove the handler    status = (OSStatus) (UHIDInstallInterruptProcPtr)(*(gCurrentUHID_dispatchTable-&gt;pUHIDInstallInterrupt))              (gCurrentUHIDModuleConnectionID, nil, 0);  if (status)     printf(&quot;*** Error (%d) on Universal Interrupt Handler remove\n&quot;, status);    // release the device    status = (OSStatus) ((UHIDReleaseDeviceProcPtr)(*(gCurrentUHID_dispatchTable-&gt;pUHIDReleaseDevice))              (gCurrentUHIDModuleConnectionID));  if (status)     printf(&quot;*** Error (%d) on release device\n&quot;, status);    gCurrentUHIDModuleConnectionID = 0;  }void myUniversalInterruptProc(void * theData, UInt32 /* refcon */){//#pragma unused refcon  UInt16        i;  UInt8        *pRawData;  OSErr        status = noErr;  UInt32        length;  UInt32        index;  SInt32        value;  pRawData = (UInt8*)theData;  switch (gPrint_AsType)  {    case kPrint_AsHex:    case kPrint_AsBinary:      for (i = 0; i &lt; gMaxPacketSize; i++)      {        switch (gPrint_AsType)        {          case kPrint_AsHex:            safeprintf(&quot;$%02X &quot;, pRawData[i]);            break;          case kPrint_AsBinary:            safeprintf(&quot;%d%d%d%d%d%d%d%d &quot;, !!(pRawData[i]&amp;0x80), !!(pRawData[i]&amp;0x40),                             !!(pRawData[i]&amp;0x20), !!(pRawData[i]&amp;0x10),                            !!(pRawData[i]&amp;0x08), !!(pRawData[i]&amp;0x04),                             !!(pRawData[i]&amp;0x02), !!(pRawData[i]&amp;0x01));            break;        }      }      break;    case kPrint_ParseButtons:      length = gMaxUsageListLength;      status = HIDGetButtons (kHIDInputReport, 0, gCurrentDownButtons, &amp;length,                     gPreparsedDataRef, theData, gMaxPacketSize);      if (status)        safeprintf(&quot;HIDGetButtons error (%d)\n&quot;, status);                          safeprintf(&quot;%d buttons down:   &quot;, length);      for (i = 0; i &lt; length; i++)        safeprintf(&quot;%d(%d) &quot;, gCurrentDownButtons[i].usage, gCurrentDownButtons[i].usagePage);      break;    case kPrint_ParseBoth:      status = HidP_PrintAllInputValues (0,(HIDPreparsedDataPtr) gPreparsedDataRef, theData, gMaxPacketSize);      if (status)        safeprintf(&quot;HidP_PrintAllInputValues error (%d)\n&quot;, status);      break;    case kPrint_SimulateISp:      for (index = 0; index &lt; gHIDElementCount; index++)      {        value = ParseElementValue (index, theData);        safeprintf(&quot;%ld, &quot;, value);      }      break;  }  safeprintf(&quot;   &quot;);  safeprintf(&quot;\n&quot;);  }OSStatus  HidP_PrintAllInputValues          (UInt32                        iCollection,          HIDPreparsedDataPtr       ptPreparsedData,           char                      *psReport,           int                        iReportLength){    HIDCollection *ptCollection;    HIDReportItem *ptReportItem;    UInt32 iR, iE, iU;    SInt32 iValue;    UInt32 iStart;    UInt32 iReportItem;    HIDUsageAndPage tUsageAndPage;/* *  Disallow Null Pointers*/    if ((ptPreparsedData == NULL) || (psReport == NULL))        return kHIDNullPointerErr;    if (ptPreparsedData-&gt;hidTypeIfValid != kHIDOSType)        return kHIDInvalidPreparsedDataErr;/* *  Search only the scope of the Collection specified *  Go through the ReportItems *  Filter on ReportType*/    ptCollection = &amp;ptPreparsedData-&gt;collections[iCollection];#if 0safeprintf (&quot;Collection: count: %d\n&quot;, ptCollection-&gt;reportItemCount);#endif    for (iR=0; iR&lt;ptCollection-&gt;reportItemCount; iR++)    {        iReportItem = ptCollection-&gt;firstReportItem + iR;        ptReportItem = &amp;ptPreparsedData-&gt;reportItems[iReportItem];#if 0safeprintf (&quot;Report Item: Type:%d, Size:%d, Start:%d, Count:%d, %s, %s\n&quot;,           ptReportItem-&gt;reportType,          ptReportItem-&gt;globals.reportSize,          ptReportItem-&gt;startBit,          ptReportItem-&gt;globals.reportCount,          (ptReportItem-&gt;dataModes &amp; kHIDDataArrayBit) == kHIDDataArray ? &quot;isArray&quot; : &quot;notArray&quot;,          (ptReportItem-&gt;dataModes &amp; kHIDDataConstantBit) == kHIDDataConstant ? &quot;isConstant&quot; : &quot;notConstant&quot;);#endif        if ((ptReportItem-&gt;reportType == kHIDInputReport) &amp;&amp;          (ptReportItem-&gt;dataModes &amp; kHIDDataConstantBit) != kHIDDataConstant)        {/* *          Values*/          if (HIDIsVariable(ptReportItem))          {          int iUsageItem;                                iStart = ptReportItem-&gt;startBit;        iUsageItem = ptReportItem-&gt;firstUsageItem;                                // loop for each usage item              for (iU=0; iU&lt;ptReportItem-&gt;usageItemCount; iU++)              {          OSStatus status = kHIDSuccess;            HIDP_UsageItem *ptUsageItem;                    ptUsageItem = &amp;ptPreparsedData-&gt;usageItems[iU];                    // if range, loop for each usage in range (is this right???)          if (ptUsageItem-&gt;isRange &amp;&amp; false)  // **\xCAdiabled          {            int  iUsageValue, min, max;                        min = ptUsageItem-&gt;usageMinimum;            max = ptUsageItem-&gt;usageMaximum;            if (max &lt; min)            {              int temp;              temp = min; min = max; max = temp;            }                        for (iUsageValue = min; iUsageValue &lt;= max; iUsageValue++)            {                      status = HIDGetData(psReport, iReportLength, iStart,                                             ptReportItem-&gt;globals.reportSize, &amp;iValue,                                             ((ptReportItem-&gt;globals.logicalMinimum &lt; 0)                                            ||(ptReportItem-&gt;globals.logicalMaximum &lt; 0)));                        if (status)                          safeprintf (&quot;\nHidP_GetData error = %d\n&quot;, status);                        iStart += ptReportItem-&gt;globals.reportSize;                    safeprintf(&quot;%d:\t%d (%x) &quot;, iUsageValue, iValue, iValue);  /*  *                    Try to scale the data  */#if 0              status = HIDScaleUsageValueIn(ptReportItem,iValue,&amp;iValue);                        if (status)                          safeprintf (&quot;\nHidP_ScaleUsageValueIn error = %d\n&quot;, status);              else                safeprintf(&quot;[%d (%x)]  &quot;, iValue, iValue);#endif            }          }          else // not range          {                    status = HIDGetData(psReport, iReportLength, iStart,                                           ptReportItem-&gt;globals.reportSize, &amp;iValue,                                           ((ptReportItem-&gt;globals.logicalMinimum &lt; 0)                                          ||(ptReportItem-&gt;globals.logicalMaximum &lt; 0)));                      if (status)                        safeprintf (&quot;\nHidP_GetData error = %d\n&quot;, status);                      iStart += ptReportItem-&gt;globals.reportSize;                safeprintf(&quot;%d(%d-%d):\t%d (%x) &quot;,               ptUsageItem-&gt;usage, ptUsageItem-&gt;usageMinimum, ptUsageItem-&gt;usageMinimum,               iValue, iValue);#if 0/**                    Try to scale the data*/            status = HIDScaleUsageValueIn(ptReportItem,iValue,&amp;iValue);                      if (status)                        safeprintf (&quot;\nHidP_ScaleUsageValueIn error = %d\n&quot;, status);            else              safeprintf(&quot;[%d (%x)]  &quot;, iValue, iValue);#endif                        }        }         }/* *          Buttons*/          else  // is button          {  /*   *          Save Arrays and Bitmaps  */              iStart = ptReportItem-&gt;startBit;              for (iE=0; iE&lt;ptReportItem-&gt;globals.reportCount; iE++)              {          OSStatus status = kHIDSuccess;            #if 0  safeprintf (&quot;startbits = %d (%x) of report item %d:%d\n&quot;, iStart, iStart, iR, iE);  #endif          if ((ptReportItem-&gt;dataModes &amp; kHIDDataArrayBit) == kHIDDataArray)                  {                      status = HIDGetData(psReport, iReportLength, iStart, ptReportItem-&gt;globals.reportSize, &amp;iValue, false);                      if (status)                        safeprintf (&quot;\nHidP_GetData error = %d\n&quot;, status);  #if 0                    else                        safeprintf (&quot;Value = %d (%x) of array item %d:%d\n&quot;, iValue, iValue, iE, iR);  #endif                      iStart += ptReportItem-&gt;globals.reportSize;                      HIDUsageAndPageFromIndex((HIDPreparsedDataRef)ptPreparsedData,ptReportItem,ptReportItem-&gt;globals.logicalMinimum+iE, &amp;tUsageAndPage);            safeprintf(&quot;%d:%d &quot;, tUsageAndPage.usage, tUsageAndPage.usagePage);                  }                  else                  {                      iValue = 0;                      status = HIDGetData(psReport, iReportLength, iStart, 1, &amp;iValue, false);                      if (status)                        safeprintf (&quot;\nHidP_GetData error = %d\n&quot;, status);  #if 0                    else                        safeprintf (&quot;Value = %d (%x) of item %d:%d\n&quot;, iValue, iValue, iE, iR);  #endif                                              iStart++;                      if (iValue != 0)                      {                          HIDUsageAndPageFromIndex((HIDPreparsedDataRef)ptPreparsedData,ptReportItem,ptReportItem-&gt;globals.logicalMinimum+iE,&amp;tUsageAndPage);              safeprintf(&quot;%d:%d &quot;, tUsageAndPage.usage, tUsageAndPage.usagePage);                      }                  }              }          }        }    }    return kHIDSuccess;}int safeprintf(const char *format, ...){  va_list arglist;  int return_value = 0;  long len;    va_start(arglist, format);  return_value= vsprintf(&amp;gInsertPrintfBuffer[gInsertIndex], format, arglist);  va_end(arglist);    len = strlen(&amp;gInsertPrintfBuffer[gInsertIndex]);    if (gInsertIndex + len &lt; kPrintfBufferSize)    gInsertIndex += len;  return return_value;}void PrintPreparsedData (void){  HIDPreparsedDataPtr    parsedData = (HIDPreparsedDataPtr) gPreparsedDataRef;  char          indent[] = &quot;  &quot;;    printf (&quot;\n_Collections_\n&quot;);  PrintCollectionItems(0, parsedData-&gt;collectionCount, indent);  printf (&quot;\n_ReportItems_\n&quot;);  PrintReportItems(0, parsedData-&gt;reportItemCount, indent);  printf (&quot;\n_UsageItems_\n&quot;);  PrintUsageItems(0, parsedData-&gt;usageItemCount, indent);  printf (&quot;\n_StringItems_: %d items\n&quot;, parsedData-&gt;stringItemCount);  printf (&quot;\n_DesigItems_: %d items\n&quot;, parsedData-&gt;desigItemCount);    if (parsedData-&gt;stringItemCount &gt; 0 || parsedData-&gt;desigItemCount &gt; 0)    printf (&quot;*** Wow, it has strings or physical designators!\n&quot;);    printf (&quot;\n\n&quot;);}void PrintCollectionItems (UInt32 firstCollection, UInt32 collectionCount, char * indent){  HIDPreparsedDataPtr    parsedData = (HIDPreparsedDataPtr) gPreparsedDataRef;  unsigned         index, start, end;  char          subIndent[32];    sprintf (subIndent, &quot;\t%s&quot;, indent);    start = firstCollection;  end = start + collectionCount;    if (end &gt; parsedData-&gt;collectionCount)  {    printf (&quot;%s***!!!collection integrity error! (%d, %d)\n&quot;, indent, end, parsedData-&gt;collectionCount);    return;  }  else for (index = start; index &lt; end; index++)  {    printf (&quot;%sCollection (%X): %d (parent:%d, children:%d, firstChild:%d, nextSibling:%d)\n&quot;,       indent,      index,      parsedData-&gt;collections[index].data,      parsedData-&gt;collections[index].parent,      parsedData-&gt;collections[index].children,      parsedData-&gt;collections[index].firstChild,      parsedData-&gt;collections[index].nextSibling);        // print usage items in collection    PrintUsageItems     (parsedData-&gt;collections[index].firstUsageItem,               parsedData-&gt;collections[index].usageItemCount,               subIndent);    // print report items in collection    PrintReportItems   (parsedData-&gt;collections[index].firstReportItem,               parsedData-&gt;collections[index].reportItemCount,               subIndent);  }}void PrintReportItems (UInt32 firstReportItem, UInt32 reportItemCount, char * indent){  HIDPreparsedDataPtr    parsedData = (HIDPreparsedDataPtr) gPreparsedDataRef;  unsigned         index, start, end;  char          subIndent[32];    sprintf (subIndent, &quot;\t%s&quot;, indent);    start = firstReportItem;  end = start + reportItemCount;    if (end &gt; parsedData-&gt;reportItemCount)  {    printf (&quot;%s***!!!report integrity error! (%d, %d)\n&quot;, indent, end, parsedData-&gt;reportItemCount);    return;  }  else for (index = start; index &lt; end; index++)  {    printf (&quot;%sReportItem(%d): Page:%d\t(%d&lt;-&gt;%d)\t(%d&lt;-&gt;%d)\t[%d+(%d*%d)] %s %s\n&quot;,      indent,      index,       parsedData-&gt;reportItems[index].globals.usagePage,       parsedData-&gt;reportItems[index].globals.logicalMinimum,       parsedData-&gt;reportItems[index].globals.logicalMaximum,       parsedData-&gt;reportItems[index].globals.physicalMinimum,       parsedData-&gt;reportItems[index].globals.physicalMaximum,       parsedData-&gt;reportItems[index].startBit,       parsedData-&gt;reportItems[index].globals.reportSize,       parsedData-&gt;reportItems[index].globals.reportCount,      (parsedData-&gt;reportItems[index].dataModes &amp; kHIDDataConstantBit) ? &quot;isConstant&quot; : &quot;&quot;,      (parsedData-&gt;reportItems[index].dataModes &amp; kHIDDataArrayBit) ? &quot;isArray&quot; : &quot;&quot;);    // print usage items in report item    PrintUsageItems     (parsedData-&gt;reportItems[index].firstUsageItem,               parsedData-&gt;reportItems[index].usageItemCount,               subIndent);    if (parsedData-&gt;reportItems[index].stringItemCount &gt; 0 || parsedData-&gt;reportItems[index].desigItemCount &gt; 0)      printf (&quot;%sWow, it has strings or physical designators!\n&quot;, indent);  }}void PrintUsageItems (UInt32 firstUsageItem, UInt32 usageItemCount, char * indent){  HIDPreparsedDataPtr    parsedData = (HIDPreparsedDataPtr) gPreparsedDataRef;  unsigned         index, start, end;  start = firstUsageItem;  end = start + usageItemCount;    if (end &gt; parsedData-&gt;usageItemCount)  {    printf (&quot;%s***!!!usage integrity error! (%d, %d)\n&quot;, indent, end, parsedData-&gt;usageItemCount);    return;  }  else for (index = start; index &lt; end; index++)  {    if (parsedData-&gt;usageItems[index].isRange)      printf (&quot;%sUsage(%X): %d-%d\n&quot;, indent, index,         parsedData-&gt;usageItems[index].usageMinimum,         parsedData-&gt;usageItems[index].usageMaximum);    else      printf (&quot;%sUsage(%d): %d\n&quot;, indent, index, parsedData-&gt;usageItems[index].usage);  }}void SimulateISpEnumeration (void){  OSStatus       err = noErr;  UInt32        count;  // get the overall capabilities of the device  if (err == noErr)    err = HIDGetCaps (gPreparsedDataRef, &amp;gHIDCaps);  // *** for now, only work with devices that appear to be a joystick or gamepad  if (err == noErr)  {    if (gHIDCaps.usagePage != kHIDPage_Generic ||      (gHIDCaps.usage != kHIDUsage_Joystick &amp;&amp; gHIDCaps.usage != kHIDUsage_Gamepad))    {      printf(&quot;** matched to non-joystick, non-gamepad... bailing out\n&quot;);      err = fnfErr;    }  }    // allocate space for button caps  if (err == noErr)  {    gHIDButtonCaps = (HIDButtonCaps *) NewPtrSysClear(sizeof(HIDButtonCaps) * gHIDCaps.numberInputButtonCaps);    if (gHIDButtonCaps == nil) printf(&quot;** could not allocate space for buttonCaps\n&quot;);    if (gHIDButtonCaps == nil) err = memFullErr;  }  // get the button capabilities  if (err == noErr)  {    count = gHIDCaps.numberInputButtonCaps;    err = HIDGetButtonCaps (kHIDInputReport, gHIDButtonCaps, &amp;gHIDCaps.numberInputButtonCaps, gPreparsedDataRef);        if (count &gt; gHIDCaps.numberInputButtonCaps)      printf (&quot;** number of button caps increased! (%d-&gt;%d)\n&quot;, gHIDCaps.numberInputButtonCaps, count);    else      gHIDCaps.numberInputButtonCaps = count;  }  // allocate space for value caps  if (err == noErr)  {    gHIDValueCaps = (HIDValueCaps *) NewPtrSysClear(sizeof(HIDValueCaps) * gHIDCaps.numberInputValueCaps);    if (gHIDValueCaps == nil) printf(&quot;** could not allocate space for valueCaps\n&quot;);    if (gHIDValueCaps == nil) err = memFullErr;  }  // get the value capabilities  if (err == noErr)    err = HIDGetValueCaps (kHIDInputReport, gHIDValueCaps, &amp;gHIDCaps.numberInputValueCaps, gPreparsedDataRef);    // build HID elements  if (err == noErr)    err = BuildHIDElements ();  // print HID elements  if (err == noErr)    err = PrintHIDElements ();    // report error  if (err)    printf (&quot;**\xCAerror = %d\n&quot;, err);}OSStatus PrintHIDElements (void){  UInt32  index;    printf (&quot;\nHIDElements (%d):\n&quot;, gHIDElementCount);  for (index = 0; index &lt; gHIDElementCount; index++)  {    switch (gHIDElements[index].type)    {      case kButtonElement:        printf (&quot;%2.2d:Button (%d): %X:%d, key:%d, (%d&lt;-&gt;%d), str:%d\n&quot;,          index,          gHIDElements[index].capsIndex,          gHIDElements[index].usage,          gHIDElements[index].usagePage,          gHIDElements[index].key,          gHIDElements[index].min,          gHIDElements[index].max,          gHIDElements[index].stringIndex          );        break;              case kValueElement:        printf (&quot;%2.2d:Value (%d): %X:%d, key:%d, (%d&lt;-&gt;%d), str:%d\n&quot;,          index,          gHIDElements[index].capsIndex,          gHIDElements[index].usage,          gHIDElements[index].usagePage,          gHIDElements[index].key,          gHIDElements[index].min,          gHIDElements[index].max,          gHIDElements[index].stringIndex          );        break;    }  }    printf (&quot;\n&quot;);    return noErr;}OSStatus BuildHIDElements (void){  OSStatus       err = noErr;  OSStatus       initErr;  UInt32         hidElementIndex = 0;  UInt32         valueIndex;  UInt32         buttonIndex;  HIDUsage       usage;    // allocate space for HID elements  if (err == noErr)  {    gHIDElementCount = CountHIDElements();    gHIDElements = (HIDElement *) NewPtrSysClear(sizeof(HIDElement) * gHIDElementCount);    if (gHIDElements == nil) printf(&quot;** could not allocate space for HIDElements\n&quot;);    if (gHIDElements == nil) err = memFullErr;  }  // add all values to the elements  if (err == noErr)    for (valueIndex = 0; valueIndex &lt; gHIDCaps.numberInputValueCaps; valueIndex++)    {      HIDElement hidElement;      if (gHIDValueCaps[valueIndex].reportCount != 1)        printf(&quot;BuildHIDElements: value caps reportCount is not 1!\n&quot;);              if (gHIDValueCaps[valueIndex].isRange)        printf(&quot;BuildHIDElements: value caps is range!\n&quot;);      hidElement.type = kValueElement;      hidElement.capsIndex = valueIndex;      hidElement.usagePage = gHIDValueCaps[valueIndex].usagePage;      hidElement.min = gHIDValueCaps[valueIndex].logicalMin;      hidElement.max = gHIDValueCaps[valueIndex].logicalMax;            // NOTE: no devices I can find have values that are ranges, so this code may not be right!      if (gHIDValueCaps[valueIndex].isRange)      {        for     (usage = gHIDValueCaps[valueIndex].u.range.usageMin;            usage &lt;= gHIDValueCaps[valueIndex].u.range.usageMax;            usage++)        {          hidElement.usage = usage;          initErr = InitializeHIDElement(&amp;hidElement);                    if (initErr == noErr)            gHIDElements[hidElementIndex++] = hidElement;        }      }      else // notRange      {        hidElement.usage = gHIDValueCaps[valueIndex].u.notRange.usage;        initErr = InitializeHIDElement(&amp;hidElement);                if (initErr == noErr)          gHIDElements[hidElementIndex++] = hidElement;      }    }  // add all buttons to the elements  if (err == noErr)    for (buttonIndex = 0; buttonIndex &lt; gHIDCaps.numberInputButtonCaps; buttonIndex++)    {      HIDElement hidElement;      hidElement.type = kButtonElement;      hidElement.capsIndex = buttonIndex;      hidElement.usagePage = gHIDButtonCaps[buttonIndex].usagePage;      hidElement.min = 0;      hidElement.max = 1;            printf(&quot;enumerating button (%d)\n&quot;, buttonIndex);      // most buttons are reported as ranges of usage values      if (gHIDButtonCaps[buttonIndex].isRange)      {        for     (usage = gHIDButtonCaps[buttonIndex].u.range.usageMin;            usage &lt;= gHIDButtonCaps[buttonIndex].u.range.usageMax;            usage++)        {          hidElement.usage = usage;          initErr = InitializeHIDElement(&amp;hidElement);                    if (initErr == noErr)            gHIDElements[hidElementIndex++] = hidElement;        }      }      else // notRange      {        hidElement.usage = gHIDButtonCaps[buttonIndex].u.notRange.usage;        initErr = InitializeHIDElement(&amp;hidElement);                if (initErr == noErr)          gHIDElements[hidElementIndex++] = hidElement;      }    }  return err;}UInt32 CountHIDElements(void){  OSStatus       err = noErr;  UInt32         count = 0;  UInt32         valueIndex;  UInt32         buttonIndex;    if (err == noErr)    for (valueIndex = 0; valueIndex &lt; gHIDCaps.numberInputValueCaps; valueIndex++)    {      if (gHIDValueCaps[valueIndex].isRange)        count += (gHIDValueCaps[valueIndex].u.range.usageMax - gHIDValueCaps[valueIndex].u.range.usageMin) + 1;      else // notRange        count++;    }  // count all buttons  if (err == noErr)    for (buttonIndex = 0; buttonIndex &lt; gHIDCaps.numberInputButtonCaps; buttonIndex++)    {      if (gHIDButtonCaps[buttonIndex].isRange)        count += (gHIDButtonCaps[buttonIndex].u.range.usageMax - gHIDButtonCaps[buttonIndex].u.range.usageMin) + 1;      else // notRange        count++;    }    return count;}OSStatus InitializeHIDElement(HIDElement * hidElement){  OSStatus       err = noErr;  SInt32         stringIndex = -1;  switch (hidElement-&gt;type)  {    case kButtonElement:      if (hidElement-&gt;usagePage != kHIDPage_Button)        printf(&quot;InitializeHIDElement: button found not on button page (%d)\n&quot;, hidElement-&gt;usagePage);      if (hidElement-&gt;usagePage != kHIDPage_Button)        return kHIDBadParameterErr;            switch (hidElement-&gt;usage)      {        case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8:         case 9: case 10: case 11: case 12: case 13: case 14: case 15: case 16:          hidElement-&gt;key = kUSB_button1_element + (hidElement-&gt;usage - 1);          stringIndex = kStrList_DefaultNames_Button1 + (hidElement-&gt;usage - 1);          break;        default:          return kHIDBadParameterErr;      }      break;    case kValueElement:      if (hidElement-&gt;usagePage == kHIDPage_Generic)        switch (hidElement-&gt;usage)        {          case kHIDUsage_X:            hidElement-&gt;key = kUSB_xaxis_element;            stringIndex = kStrList_DefaultNames_XAxis;            break;          case kHIDUsage_Y:            hidElement-&gt;key = kUSB_yaxis_element;            stringIndex = kStrList_DefaultNames_YAxis;            break;          case kHIDUsage_Z:            hidElement-&gt;key = kUSB_axis_element;            stringIndex = kStrList_DefaultNames_Axis;            break;          case kHIDUsage_Rx:            hidElement-&gt;key = kUSB_axis_element;            stringIndex = kStrList_DefaultNames_Axis;            break;          case kHIDUsage_Ry:            hidElement-&gt;key = kUSB_axis_element;            stringIndex = kStrList_DefaultNames_Axis;            break;          case kHIDUsage_Rz:            hidElement-&gt;key = kUSB_rudder_element;            stringIndex = kStrList_DefaultNames_Twist;            break;          case kHIDUsage_Slider:            hidElement-&gt;key = kUSB_throttle_element;            stringIndex = kStrList_DefaultNames_Throttle;            break;          case kHIDUsage_Dial:          case kHIDUsage_Wheel:            hidElement-&gt;key = kUSB_trim_element;            stringIndex = kStrList_DefaultNames_Trim;            break;          case kHIDUsage_HatSwitch:            hidElement-&gt;key = kUSB_povhat_element;            stringIndex = kStrList_DefaultNames_POVHat;            break;        }      else if (hidElement-&gt;usagePage == kHIDPage_Simulation)        switch (hidElement-&gt;usage)        {          case kHIDUsage_Rudder:            hidElement-&gt;key = kUSB_rudder_element;            stringIndex = kStrList_DefaultNames_Rudder;            break;          case kHIDUsage_Throttle:            hidElement-&gt;key = kUSB_throttle_element;            stringIndex = kStrList_DefaultNames_Throttle;            break;        }      break;    default:      printf(&quot;InitializeHIDElement: unknown type (%d)\n&quot;, hidElement-&gt;type);      err = kHIDBadParameterErr;      break;  }    hidElement-&gt;stringIndex = stringIndex;      return err;}SInt32 ParseElementValue (UInt32 inElementIndex, Ptr inBuffer){  OSStatus     err = noErr;  HIDUsage    usageList[kUSB_button16_element];  UInt32      usageListSize = kUSB_button16_element;  UInt32      index;  HIDElement *  hidElement = &amp;gHIDElements[inElementIndex];  SInt32      usageValue;    switch (hidElement-&gt;type)  {    case kButtonElement:      // for now, we'll only look at buttons on the button page      err = HIDGetButtonsOnPage  (kHIDInputReport,                     kHIDPage_Button,                     0,                    usageList,                    &amp;usageListSize,                    gPreparsedDataRef,                    inBuffer,                    gMaxPacketSize);            // confirm we succeeded      if (err != noErr &amp;&amp; err != kHIDUsageNotFoundErr)        safeprintf (&quot;**ParseElementValue: HIDGetButtonsOnPage failed (%d)&quot;, err);      if (err != noErr)        break;            // walk the returned usage list      for (index = 0; index &lt; usageListSize; index++)      {        // if our usage is in the usage list, then we are down        if (usageList[index] == hidElement-&gt;usage)          return 1;      }            // we were not in the list, so we are up      return 0;          case kValueElement:      // get the usage value      err = HIDGetUsageValue (kHIDInputReport,                  hidElement-&gt;usagePage,                  0,  // ** this might be faster if we store collection and pass here                  hidElement-&gt;usage,                  &amp;usageValue,                  gPreparsedDataRef,                  inBuffer,                  gMaxPacketSize);      // confirm we succeeded      if (err != noErr &amp;&amp; err != kHIDUsageNotFoundErr)        safeprintf (&quot;**ParseElementValue: HIDGetUsageValue failed (%d)&quot;, err);      if (err != noErr)        break;            // handle dpads      if (false &amp;&amp; hidElement-&gt;key == kUSB_povhat_element)      {        if (usageValue &lt; hidElement-&gt;min || usageValue &gt; hidElement-&gt;max)          usageValue = kISpPadIdle;        else        {          SInt32  normalized = usageValue - hidElement-&gt;min;          SInt32  normalizedMax = hidElement-&gt;max - hidElement-&gt;min;                    // avoid devide by zero          if (normalizedMax == 0) return kISpPadIdle;                    // rescale value          normalized = ((normalized * 7)) / normalizedMax;          switch (normalized)          {            case 0:  usageValue = kISpPadUp;     break;            case 1:  usageValue = kISpPadUpRight;  break;            case 2:  usageValue = kISpPadRight;    break;            case 3:  usageValue = kISpPadDownRight;  break;            case 4:  usageValue = kISpPadDown;    break;            case 5:  usageValue = kISpPadDownLeft;  break;            case 6:  usageValue = kISpPadLeft;    break;            case 7:  usageValue = kISpPadUpLeft;    break;            default:usageValue = kISpPadIdle;    break; // should not get here          }        }      }            return usageValue;  }    return 0;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/UniversalHIDModuleTest/listing2.html%3Fid%3DDTS10000062-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/UniversalHIDModuleTest/listing2.html%3Fid%3DDTS10000062-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/UniversalHIDModuleTest/listing2.html%3Fid%3DDTS10000062-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>