<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Object-Oriented Programming with Objective-C: The Object Model</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="The Object Model"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005149-CH5" title="The Object Model"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40005149-CH1-SW2">Object-Oriented Programming with Objective-C</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ooOOP.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ooStructuringPrograms.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005149-CH5-SW4" title="The Object Model"></a>
    <h1>The Object Model</h1>
    
        <p>
            <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_10"></a>The insight of object-oriented programming is to combine state and behavior<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_11"></a>—data and operations on data—in a high-level unit, an <strong>object</strong>, and to give it language support. An object is a group of related functions and a data structure that serves those functions. The functions are known as the object’s <strong>methods</strong>, and the fields of its data structure<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_12"></a> are its <strong>instance variables</strong>.
            <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_13"></a> The methods wrap around the instance variables and hide them from the rest of the program, as <span class="content_text">Figure 3-1</span> illustrates:</p>
        <br/><div><a name="//apple_ref/doc/uid/TP40005149-CH5-85907" title="Figure 3-1An Object"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW1" title="Figure 3-1An Object"></a>
            <p><strong>Figure 3-1&nbsp;&nbsp;</strong>An Object</p>
            <img src = "../Art/singleobject.gif" alt = "" width="94" height="95">
        </div><br/>
        <p>Likely, if you’ve ever tackled any kind of difficult programming problem, your design has included groups of functions that work on a particular kind of data—implicit “objects” without the language support. Object-oriented programming makes these function groups explicit and permits you to think in terms of the group, rather than its components. The only way to an object’s data, the only interface, is through its methods.</p>
        <p>By combining both state and behavior in a single unit, an object becomes more than either alone; the whole really is greater than the sum of its parts. An object is a kind of self-sufficient “subprogram” with jurisdiction over a specific functional area. It can play a full-fledged modular role within a larger program design.</p>
        <div class="notebox"><a name="//apple_ref/doc/uid/TP40005149-CH5-SW20" title="Terminology"></a>
            <p><strong>Terminology:</strong>&nbsp;
            Object-oriented terminology varies from language to language. For example, in C++, methods are called “member functions” and instance variables are known as “data members.” This document uses the terminology of Objective-C, which has its basis in Smalltalk.</p>
        </div>
        <p>For example, if you were to write a program that modeled home water usage, you might invent objects to represent the various components of the water-delivery system. One might be a Faucet object that would have methods to start and stop the flow of water, set the rate of flow, return the amount of water consumed in a given period, and so on. To do this work, a Faucet object would need instance variables to keep track of whether the tap is open or shut, how much water is being used, and where the water is coming from.</p>
        <p>Clearly, a programmatic Faucet can be smarter than a real one (it’s analogous to a mechanical faucet with lots of gauges and instruments attached). But even a real faucet, like any system component, exhibits both state and behavior. To effectively model a system, you need programming units, like objects, that also combine state and behavior.</p>
        <p>
            <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_14"></a>A program consists of a network of interconnected objects that call upon each other to solve a part of the puzzle. Each object has a specific role to play in the overall design of the program and is able to communicate with other objects. Objects communicate through <strong>messages</strong>
            <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_15"></a>, requests to perform methods.</p>
        <br/><div><a name="//apple_ref/doc/uid/TP40005149-CH5-85963" title="Figure 3-2Object Network"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW5" title="Figure 3-2Object Network"></a>
            <p><strong>Figure 3-2&nbsp;&nbsp;</strong>Object Network</p>
            <img src = "../Art/objnetwork.gif" alt = "" width="255" height="240">
        </div><br/>
        <p>The objects in the network won’t all be the same. For example, in addition to Faucets, the program that models water usage might also have Pipe objects that can deliver water to the Faucets and Valve objects to regulate the flow among Pipes. There could be a Building object to coordinate a set of Pipes, Valves, and Faucets, some Appliance objects—corresponding to dishwashers, toilets, and washing machines—that can turn Valves on and off, and maybe some Users to work the Appliances and Faucets. When a Building object is asked how much water is being used, it might call upon each Faucet and Valve to report its current state. When a User starts up an Appliance, the Appliance will need to turn on a Valve to get the water it requires.<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_16"></a>
        </p>
    
    
        
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ooObjectModel.html#//apple_ref/doc/uid/TP40005149-CH5-SW6">The Messaging Metaphor</a>
				
			<br/>
			
        
			
			
				<a href="ooObjectModel.html#//apple_ref/doc/uid/TP40005149-CH5-SW7">Classes</a>
				
			<br/>
			
        
			
			
				<a href="ooObjectModel.html#//apple_ref/doc/uid/TP40005149-CH5-SW2">Mechanisms Of Abstraction</a>
				
			<br/>
			
        
			
			
				<a href="ooObjectModel.html#//apple_ref/doc/uid/TP40005149-CH5-SW12">Inheritance</a>
				
			<br/>
			
        
			
			
				<a href="ooObjectModel.html#//apple_ref/doc/uid/TP40005149-CH5-SW16">Dynamism</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005149-CH5-85981" title="The Messaging Metaphor"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW6" title="The Messaging Metaphor"></a>
            <h2>The Messaging Metaphor</h2>
            <p>
                <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_17"></a>Every programming paradigm comes with its own terminology and metaphors. None more so than object-oriented programming. Its jargon invites you to think about what goes on in a program from a particular perspective.</p>
            <p>There’s a tendency, for example, to think of objects as “actors” and to endow them with human-like intentions and abilities. It’s tempting sometimes to talk about an object “deciding” what to do about a situation, “asking” other objects for information, “introspecting” about itself to get requested information, “delegating” responsibility to another object, or “managing” a process.</p>
            <p>Rather than think in terms of functions or methods doing the work, as you would in a procedural programming language, this metaphor asks you to think of objects as “performing” their methods. Objects are not passive containers for state and behavior, but are said to be the agents of the program’s activity.</p>
            <p>This is actually a useful metaphor. An object is like an actor in a couple of respects: It has a particular role to play within the overall design of the program, and within that role it can act fairly independently of the other parts of the program. It interacts with other objects as they play their own roles, but is self-contained and to a certain extent can act on its own. Like an actor on stage, it can’t stray from the script, but the role it plays can be multi-faceted and quite complex.</p>
            <p>The idea of objects as actors fits nicely with the principal metaphor of object-oriented programming—the idea that objects communicate through “messages.” Instead of calling a method as you would a function, you send a message to an object requesting it to perform one of its methods.</p>
            <p>Although it can take some getting used to, this metaphor leads to a useful way of looking at methods and objects. It abstracts methods away from the particular data they act on and concentrates on behavior instead. For example, in an object-oriented programming interface, a <code>start</code> method might initiate an operation, an <code>archive</code> method might archive information, and a <code>draw</code> method might produce an image. Exactly which operation is initiated, which information is archived, and which image is drawn isn’t revealed by the method name. Different objects might perform these methods in different ways.</p>
            <p>Thus, methods are a vocabulary of abstract behaviors. To invoke one of those behaviors, you have to make it concrete by associating the method with an object. This is done by naming the object as the “receiver” of a message. The object you choose as receiver will determine the exact operation that’s initiated, the data that’s archived, or the image that’s drawn.</p>
            <p>Since methods belong to objects, they can be invoked only through a particular receiver (the owner of the method and of the data structure the method will act on). Different receivers can have different implementations of the same method, so different receivers can do different things in response to the same message. The result of a message can’t be calculated from the message or method name alone; it also depends on the object that receives the message.</p>
            <p>By separating the message (the requested behavior) from the receiver (the owner of a method that can respond to the request), the messaging metaphor perfectly captures the idea that behaviors<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_18"></a> can be abstracted away from their particular implementations.<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_19"></a>
                <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_20"></a>
            </p>
        
        <a name="//apple_ref/doc/uid/TP40005149-CH5-86047" title="Classes"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW7" title="Classes"></a>
            <h2>Classes</h2>
            <p>
                <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_21"></a> A program can have more than one object of the same kind. The program that models water usage, for example, might have several Faucets and Pipes and perhaps a handful of Appliances and Users. Objects<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_22"></a> of the same kind are said to be members of the same <strong>class</strong>. All members of a class are able to perform the same methods and have matching sets of instance variables. They also share a common definition; each kind of object is defined just once.</p>
            <p>In this, objects are similar to C structures. Declaring a structure defines a type. For example, this declaration</p>
            
                <div class="codesample"><table><tr><td scope="row"><pre>struct key {<span></span></pre></td></tr><tr><td scope="row"><pre>    char *word;<span></span></pre></td></tr><tr><td scope="row"><pre>    int count;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div>
            
            <p>defines the <code>struct key</code> type. Once defined, the structure name can be used to produce any number of instances of the type:</p>
            
                <div class="codesample"><table><tr><td scope="row"><pre>struct key  a, b, c, d;<span></span></pre></td></tr><tr><td scope="row"><pre>struct key *p = malloc(sizeof(struct key) * MAXITEMS);<span></span></pre></td></tr></table></div>
            
            <p>The declaration is a template for a kind of structure, but it doesn’t create a structure that the program can use. It takes another step to allocate memory for an actual structure of that type, a step that can be repeated any number of times.</p>
            <p>Similarly, defining an object creates a template for a kind of object. It defines a class of objects. The template can be used to produce any number of similar objects—<strong>instances</strong>
                <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_23"></a> of the class. For example, there would be a single definition of the Faucet class. Using this definition, a program could allocate as many Faucet instances as it needed.</p>
            <p>A class definition is like a structure definition in that it lays out an arrangement of data elements (instance variables) that become part of every instance. Each instance has memory allocated for its own set of instance variables, which store values peculiar to the instance.</p>
            <p>However, a class definition differs from a structure declaration in that it also defines methods that specify the behavior of class members. Every instance is characterized by its access to the methods defined for the class. Two objects with equivalent data structures but different methods would not belong to the same class.</p>
            <a name="//apple_ref/doc/uid/TP40005149-CH5-86148" title="Modularity"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW8" title="Modularity"></a>
                <h3>Modularity</h3>
                <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_24"></a>
                <p>To a C programmer, a “module” is nothing more than a file containing source code. Breaking a large (or even not-so-large) program into different files is a convenient way of splitting it into manageable pieces. Each piece can be worked on independently and compiled alone, then integrated with other pieces when the program is linked. Using the <code>static</code> storage class designator to limit the scope of names to just the files where they’re declared enhances the independence of source modules.</p>
                <p>This kind of module is a unit defined by the file system. It’s a container for source code, not a logical unit of the language. What goes into the container is up to each programmer. You can use them to group logically related parts of the code, but you don’t have to. Files are like the drawers of a dresser; you can put your socks in one drawer, underwear in another, and so on, or you can use another organizing scheme or simply choose to mix everything up.</p>
                <div class="notebox"><a name="//apple_ref/doc/uid/TP40005149-CH5-SW21" title="Access to Methods"></a>
                    <p><strong>Access to Methods:</strong>&nbsp;
                    It’s convenient to think of methods<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_25"></a> as being part of an object, just as instance variables are. As in <span class="content_text"><a href="ooObjectModel.html#//apple_ref/doc/uid/TP40005149-CH5-85907">Figure 3-1</a></span>, methods can be diagrammed as surrounding the object’s instance variables. But, of course, methods aren’t grouped with instance variables in memory. Memory is allocated for the instance variables of each new object, but there’s no need to allocate memory for methods. All an instance needs is access to its methods, and all instances of the same class share access to the same set of methods. There’s only one copy of the methods in memory, no matter how many instances of the class are created.</p>
                </div>
                <p>Object-oriented programming languages support the use of file containers for source code, but they also add a logical module to the language—class definitions. As you’d expect, it’s often the case that each class is defined in its own source file—logical modules are matched to container modules.</p>
                <p>In Objective-C, for example, it would be possible to define the part of the Valve class that interacts with Pipes in the same file that defines the Pipe class, thus creating a container module for Pipe-related code and splitting the Valve class into more than one file. The Valve class definition would still act as a modular unit within the construction of the program—it would still be a logical module—no matter how many files the source code was located in.</p>
                <p>The mechanisms that make class definitions logical units of the language are discussed in some detail under <span class="content_text"><a href="ooObjectModel.html#//apple_ref/doc/uid/TP40005149-CH5-86316">“Mechanisms Of Abstraction.”</a></span></p>
            
            <a name="//apple_ref/doc/uid/TP40005149-CH5-86209" title="Reusability"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW9" title="Reusability"></a>
                <h3>Reusability</h3>
                <p>
                    <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_26"></a>A principal goal of object-oriented programming is to make the code you write as reusable as possible—to have it serve many different situations and applications—so that you can avoid reimplementing, even if only slightly differently, something that’s already been done.</p>
                <p>Reusability is influenced by a variety of different factors, including:</p>
                <ul class="spaceabove">
                    <li class="li">
                        <p>How reliable and bug-free the code is</p>
                    </li>
                    <li class="li">
                        <p>How clear the documentation is</p>
                    </li>
                    <li class="li">
                        <p>How simple and straightforward the programming interface is</p>
                    </li>
                    <li class="li">
                        <p>How efficiently the code performs its tasks</p>
                    </li>
                    <li class="li">
                        <p>How full the feature set is</p>
                    </li>
                </ul>
                <p>Clearly, these factors don’t apply just to the object model. They can be used to judge the reusability of any code—standard C functions<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_27"></a> as well as class definitions. Efficient and well-documented functions, for example, would be more reusable than undocumented and unreliable ones.</p>
                <p>Nevertheless, a general comparison would show that class definitions lend themselves to reusable code in ways that functions do not. There are various things you can do to make functions more reusable—passing data as arguments rather than assuming specifically named global variables, for example. Even so, it turns out that only a small subset of functions can be generalized beyond the applications they were originally designed for. Their reusability is inherently limited in at least three ways:</p>
                <ul class="spaceabove">
                    <li class="li">
                        <p>Function names are global; each function must have a unique name (except for those declared <code>static</code>). This makes it difficult to rely heavily on library code when building a complex system. The programming interface would be hard to learn and so extensive that it couldn’t easily capture significant generalizations.</p>
                        <p>Classes, on the other hand, can share programming interfaces. When the same naming conventions are used over and over, a great deal of functionality can be packaged with a relatively small and easy-to-understand interface.</p>
                    </li>
                    <li class="li">
                        <p>Functions are selected from a library one at a time. It’s up to programmers to pick and choose the individual functions they need.</p>
                        <p>In contrast, objects come as packages of functionality, not as individual methods and instance variables. They provide integrated services, so users of an object-oriented library won’t get bogged down piecing together their own solutions to a problem.</p>
                    </li>
                    <li class="li">
                        <p>Functions are typically tied to particular kinds of data structures devised for a specific program. The interaction between data and function is an unavoidable part of the interface. A function is useful only to those who agree to use the same kind of data structures it accepts as arguments.</p>
                        <p>Because it hides its data, an object doesn’t have this problem. This is one of the principal reasons why classes can be reused more easily than functions.</p>
                    </li>
                </ul>
                <p>An object’s data is protected and won’t be touched by any other part of the program. Methods can therefore trust its integrity. They can be sure that external access hasn’t put it in an illogical or untenable state. This makes an object data structure more reliable than one passed to a function, so methods can depend on it more. Reusable methods are consequently easier to write.</p>
                <p>Moreover, because an object’s data is hidden, a class can be reimplemented to use a different data structure without affecting its interface. All programs that use the class can pick up the new version without changing any source code; no reprogramming is required.<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_28"></a>
                    <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_29"></a>
                </p>
            
        
        <a name="//apple_ref/doc/uid/TP40005149-CH5-86316" title="Mechanisms Of Abstraction"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW2" title="Mechanisms Of Abstraction"></a>
            <h2>Mechanisms Of Abstraction</h2>
            <p>
                <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_30"></a>To this point, objects have been introduced as units that embody higher-level abstractions and as coherent role-players within an application. However, they couldn’t be used this way without the support of various language mechanisms. Two of the most important mechanisms are: <strong>encapsulation</strong> and <strong>polymorphism</strong>.</p>
            <p>Encapsulation keeps the implementation of an object out of its interface, and polymorphism results from giving each class its own name space. The following sections discuss each of these mechanisms in turn.</p>
            <a name="//apple_ref/doc/uid/TP40005149-CH5-86349" title="Encapsulation"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW10" title="Encapsulation"></a>
                <h3>Encapsulation</h3>
                <p>
                    <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_31"></a>To design effectively at any level of abstraction, you need to be able to leave details of implementation behind and think in terms of units that group those details under a common interface. For a programming unit to be truly effective, the barrier between interface and implementation must be absolute. The interface must encapsulate the implementation—hide it from other parts of the program. Encapsulation protects an implementation from unintended actions and inadvertent access.</p>
                <p>In C, a function is clearly encapsulated; its implementation is inaccessible to other parts of the program and protected from whatever actions might be taken outside the body of the function. Method implementations are similarly encapsulated, but, more importantly, so are an object’s instance variables. They’re hidden inside the object and invisible outside it. The encapsulation of instance variables<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_32"></a> is sometimes also called <em>information hiding</em>.
                    <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_33"></a></p>
                <p>It might seem, at first, that hiding the information in instance variables would constrain your freedom as a programmer. Actually, it gives you more room to act and frees you from constraints that might otherwise be imposed. If any part of an object’s implementation could leak out and become accessible or a concern to other parts of the program, it would tie the hands both of the object’s implementor and of those who would use the object. Neither could make modifications without first checking with the other.</p>
                <p>Suppose, for example, that you’re interested in the Faucet object being developed for the program that models water use and you want to incorporate it in another program you’re writing. Once the interface to the object is decided, you don’t have to be concerned as others work on it, fix bugs, and find better ways to implement it. You get the benefit of these improvements, but none of them affects what you do in your program. Because you depend solely on the interface, nothing they do can break your code. Your program is insulated from the object’s implementation.</p>
                <p>Moreover, although those implementing the Faucet object would be interested in how you use the class and might try to make sure it meets your needs, they don’t have to be concerned with the way you write your code. Nothing you do can touch the implementation of the object or limit their freedom to make implementation changes in future releases. The implementation is insulated from anything that you or other users of the object might do.<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_34"></a>
                </p>
            
            <a name="//apple_ref/doc/uid/TP40005149-CH5-86391" title="Polymorphism"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW11" title="Polymorphism"></a>
                <h3>Polymorphism</h3>
                <p>
                    <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_35"></a>The ability of different objects to respond, each in its own way, to identical messages is called polymorphism.<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_36"></a></p>
                <p>Polymorphism results from the fact that every class lives in its own name space. The names assigned within a class definition don’t conflict with names assigned anywhere outside it. This is true both of the instance variables in an object’s data structure and of the object’s methods:</p>
                <ul class="spaceabove">
                    <li class="li">
                        <p> Just as the fields of a C structure are in a protected namespace, so are an object’s instance variables.</p>
                    </li>
                    <li class="li">
                        <p>Method names are also protected. Unlike the names of C functions, method names aren’t global symbols. The name of a method in one class can’t conflict with method names in other classes; two very different classes could implement identically named methods.</p>
                    </li>
                </ul>
                <p>Method names are part of an object’s interface. When a message is sent requesting an object to do something, the message names the method the object should perform. Because different objects can have methods with the same name, the meaning of a message must be understood relative to the particular object that receives the message. The same message sent to two different objects could invoke two distinct methods.</p>
                <p>The main benefit of polymorphism is that it simplifies the programming interface. It permits conventions to be established that can be reused in class after class. Instead of inventing a new name for each new function you add to a program, the same names can be reused. The programming interface can be described as a set of abstract behaviors, quite apart from the classes that implement them.</p>
                <div class="notebox"><a name="//apple_ref/doc/uid/TP40005149-CH5-SW22" title="Overloading"></a>
                    <p><strong>Overloading:</strong>&nbsp;
                    The<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_37"></a>
                        <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_38"></a> terms “polymorphism” and “argument overloading” refer basically to the same thing, but from slightly different points of view. Polymorphism takes a pluralistic point of view and notes that several classes can each have a method with the same name. Argument overloading takes the point of the view of the method name and notes that it can have different effects depending on the arguments passed to it. Operator overloading is similar. It refers to the ability to turn operators of the language (such as <code>==</code> and <code>+</code> in C) into methods that can be assigned particular meanings for particular kinds of objects. Objective-C implements polymorphism of method names, but not argument or operator overloading.</p>
                </div>
                <p>For example, suppose you want to report the amount of water used by an Appliance object over a given period of time. Instead of defining an <code>amountConsumed</code> method for the Appliance class, an <code>amountDispensedAtFaucet</code> method for a Faucet class, and a <code>cumulativeUsage</code> method for a Building class, you can simply define a <code>waterUsed</code> method for each class. This consolidation reduces the number of methods used for what is conceptually the same operation.</p>
                <p>Polymorphism also permits code to be isolated in the methods of different objects rather than be gathered in a single function that enumerates all the possible cases. This makes the code you write more extensible and reusable. When a new case comes along, you don’t have to reimplement existing code; you need only to add a new class with a new method, leaving the code that’s already written alone.</p>
                <p>For example, suppose you have code that sends a <code>draw</code> message to an object. Depending on the receiver, the message might produce one of two possible images. When you want to add a third case, you don’t have to change the message or alter existing code, but merely allow another object to be assigned as the message receiver.<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_39"></a>
                    <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_40"></a>
                </p>
            
        
        <a name="//apple_ref/doc/uid/TP40005149-CH5-86489" title="Inheritance"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW12" title="Inheritance"></a>
            <h2>Inheritance</h2>
            <p>
                <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_41"></a>
                <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_42"></a>The easiest way to explain something new is to start with something understood. If you want to describe what a “schooner” is, it helps if your listeners already know what a “sailboat” is. If you want to explain how a harpsichord works, it’s best if you can assume your audience has already looked inside a piano, or has seen a guitar played, or at least is familiar with the idea of a “musical instrument.”</p>
            <p>The same is true if you want to define a new kind of object; the description is simpler if it can start from the definition of an existing object.</p>
            <p>With this in mind, object-oriented programming languages permit you to base a new class definition on a class already defined. The base class is called a <strong>superclass</strong>
                <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_43"></a>; the new class is its <strong>subclass</strong>. The subclass definition specifies only how it differs from the superclass; everything else is taken to be the same.</p>
            <p>Nothing is copied from superclass to subclass. Instead, the two classes<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_44"></a> are connected so that the subclass <strong>inherits</strong> all the methods and instance variables of its superclass, much as you want your listener’s understanding of “schooner” to inherit what they already know about sailboats. If the subclass definition were empty (if it didn’t define any instance variables or methods of its own), the two classes would be identical (except for their names) and share the same definition. It would be like explaining what a “fiddle” is by saying that it’s exactly the same as a “violin.” However, the reason for declaring a subclass isn’t to generate synonyms, but to create something at least a little different from its superclass. You’d want to let the fiddle play bluegrass in addition to classical music.</p>
            <a name="//apple_ref/doc/uid/TP40005149-CH5-86529" title="Class Hierarchies"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW13" title="Class Hierarchies"></a>
                <h3>Class Hierarchies</h3>
                <p>Any class can be used as a superclass for a new class definition. A class can simultaneously be a subclass of another class and a superclass for its own subclasses. Any number of classes can thus be linked in a hierarchy of inheritance, such as the one depicted in <span class="content_text">Figure 3-3</span>.</p>
                <br/><div><a name="//apple_ref/doc/uid/TP40005149-CH5-86542" title="Figure 3-3Inheritance Hierarchy"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW3" title="Figure 3-3Inheritance Hierarchy"></a>
                    <p><strong>Figure 3-3&nbsp;&nbsp;</strong>Inheritance Hierarchy</p>
                    <img src = "../Art/emptyhierarchy.gif" alt = "" width="334" height="114">
                </div><br/>
                <p>Every inheritance hierarchy begins with a root class that has no superclass. From the root class, the hierarchy branches downward. Each class inherits from its superclass, and through its superclass, from all the classes above it in the hierarchy. Every class inherits from the root class.</p>
                <p>Each class is the accumulation of all the class definitions in its inheritance chain. In the example above, class D inherits both from C, its superclass, and the root class. Members of the D class have methods and instance variables defined in all three classes—D, C, and root.</p>
                <p>Typically, every class has just one superclass and can have an unlimited number of subclasses. However, in some object-oriented programming languages (though not in Objective-C), a class can have more than one superclass; it can inherit through multiple sources. Instead of a single hierarchy that branches downward as shown in <span class="content_text">Figure 3-3</span>, multiple inheritance lets some branches of the hierarchy (or of different hierarchies) merge.</p>
            
            <a name="//apple_ref/doc/uid/TP40005149-CH5-86575" title="Subclass Definitions"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW14" title="Subclass Definitions"></a>
                <h3>Subclass Definitions</h3>
                <p>A subclass<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_45"></a> can make three kinds of changes to the definition it inherits through its superclass:</p>
                <ul class="spaceabove">
                    <li class="li">
                        <p>It can expand the class definition it inherits by adding new methods and instance variables. This is the most common reason for defining a subclass. Subclasses always add new methods, and new instance variables if the methods require it.</p>
                    </li>
                    <li class="li">
                        <p>It can modify the behavior it inherits by replacing an existing method with a new version. This is done by simply implementing a new method with the same name as one that’s inherited. The new version <em>overrides</em>
                            <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_46"></a> the inherited version. (The inherited method doesn’t disappear; it’s still valid for the class that defined it and other classes that inherit it.)</p>
                    </li>
                    <li class="li">
                        <p>It can refine or extend the behavior<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_47"></a>
                            <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_48"></a> it inherits by replacing an existing method with a new version but still retain the old version by incorporating it in the new method. This is done by sending a message to perform the old version in the body of the new method. Each class in an inheritance chain can contribute part of a method’s behavior. In <span class="content_text"><a href="ooObjectModel.html#//apple_ref/doc/uid/TP40005149-CH5-86542">Figure 3-3</a></span>, for example, class D might override a method defined in class C and incorporate C’s version, while C’s version incorporates a version defined in the root class.</p>
                    </li>
                </ul>
                <p>Subclasses thus tend to fill out a superclass definition, making it more specific and specialized. They add, and sometimes replace, code rather than subtract it. Note that methods generally can’t be disinherited and instance variables can’t be removed or overridden.<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_49"></a>
                </p>
            
            <a name="//apple_ref/doc/uid/TP40005149-CH5-86621" title="Uses of Inheritance"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW15" title="Uses of Inheritance"></a>
                <h3>Uses of Inheritance</h3>
                <p>
                    <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_50"></a>The classic examples of an inheritance hierarchy are borrowed from animal and plant taxonomies. For example, there could be a class corresponding to the Pinaceae (pine) family of trees. Its subclasses could be Fir, Spruce, Pine, Hemlock, Tamarack, DouglasFir, and TrueCedar, corresponding to the various genera that make up the family. The Pine class might have SoftPine and HardPine subclasses, with WhitePine, SugarPine, and BristleconePine as subclasses of SoftPine, and PonderosaPine, JackPine, MontereyPine, and RedPine as subclasses of HardPine.</p>
                <p>There’s rarely a reason to program a taxonomy like this, but the analogy is a good one. Subclasses tend to specialize a superclass or adapt it to a special purpose, much as a species specializes a genus.</p>
                <p>Here are some typical uses of inheritance:</p>
                <ul class="spaceabove">
                    <li class="li">
                        <p>Reusing code. If two or more classes have some things in common but also differ in some ways, the common elements can be put in a single class definition that the other classes inherit. The common code is shared and need only be implemented once.</p>
                        <p>For example, Faucet, Valve, and Pipe objects, defined for the program that models water use, all need a connection to a water source and should be able to record the rate of flow. These commonalities can be encoded once, in a class that the Faucet, Valve, and Pipe classes inherit from. A Faucet can be said to be a kind of Valve, so perhaps the Faucet class would inherit most of what it is from Valve, and add very little of its own.</p>
                    </li>
                    <li class="li">
                        <p>Setting up a protocol. A class can declare a number of methods that its subclasses are expected to implement. The class might have empty versions of the methods, or it might implement partial versions that are to be incorporated into the subclass methods. In either case, its declarations establish a <strong>protocol</strong> that all its subclasses must follow.</p>
                        <p>When different classes implement similarly named methods, a program is better able to make use of polymorphism<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_51"></a> in its design. Setting up a protocol that subclasses must implement helps enforce these conventions.</p>
                    </li>
                    <li class="li">
                        <p>Delivering generic functionality. One implementor can define a class that contains a lot of basic, general code to solve a problem, but doesn’t fill in all the details. Other implementors can then create subclasses to adapt the generic class to their specific needs. For example, the Appliance class in the program that models water use might define a generic water-using device that subclasses would turn into specific kinds of appliances.</p>
                        <p>Inheritance is thus both a way to make someone else’s programming task easier and a way to separate levels of implementation.</p>
                    </li>
                    <li class="li">
                        <p>Making slight modifications. When inheritance is used to deliver generic functionality, set up a protocol, or reuse code, a class is devised that other classes are expected to inherit from. But you can also use inheritance to modify classes that aren’t intended as superclasses. Suppose, for example, that there’s an object that would work well in your program, but you’d like to change one or two things that it does. You can make the changes in a subclass.</p>
                    </li>
                    <li class="li">
                        <p>Previewing possibilities. Subclasses can also be used to factor out alternatives for testing purposes. For example, if a class is to be encoded with a particular user interface, alternative interfaces can be factored into subclasses during the design phase of the project. Each alternative can then be demonstrated to potential users to see which they prefer. When the choice is made, the selected subclass can be reintegrated into its superclass.<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_52"></a>
                            <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_53"></a>
                        </p>
                    </li>
                </ul>
            
        
        <a name="//apple_ref/doc/uid/TP40005149-CH5-86694" title="Dynamism"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW16" title="Dynamism"></a>
            <h2>Dynamism</h2>
            <p>At one time in programming history, the question of how much memory a program would use was typically settled when the source code was compiled and linked. All the memory the program would ever need was set aside for it as it was launched. This memory was fixed; it could neither grow nor shrink.</p>
            <p>In hindsight, it’s evident what a serious constraint this was. It limited not only how programs were constructed, but what you could imagine a program doing. It constrained design, not just programming technique. Functions (like <code>malloc</code>) that dynamically allocate memory as a program runs opened possibilities that didn’t exist before.</p>
            <p>Compile-time and link-time constraints are limiting because they force issues to be decided from information found in the programmer’s source code, rather than from information obtained from the user as the program runs.</p>
            <p>Although dynamic allocation removes one such constraint, many others, equally as limiting as static memory allocation, remain. For example, the elements that make up an application must be matched to data types at compile time. And the boundaries of an application are typically set at link time. Every part of the application must be united in a single executable file. New modules and new types can’t be introduced as the program runs.</p>
            <p>Objective-C seeks to overcome these limitations and to make programs as dynamic and fluid as possible. It shifts much of the burden of decision making from compile time and link time to runtime. The goal is to let program users decide what will happen, rather than constrain their actions artificially by the demands of the language and the needs of the compiler and linker.</p>
            <p>Three kinds of dynamism are especially important for object-oriented design:</p>
            <ul class="ul">
                <li class="li">
                    <p>Dynamic typing, waiting until runtime to determine the class of an object</p>
                </li>
                <li class="li">
                    <p>Dynamic binding, determining at runtime what method to invoke</p>
                </li>
                <li class="li">
                    <p>Dynamic loading, adding new components to a program as it runs</p>
                </li>
            </ul>
            <a name="//apple_ref/doc/uid/TP40005149-CH5-86755" title="Dynamic Typing"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW17" title="Dynamic Typing"></a>
                <h3>Dynamic Typing</h3>
                <p>
                    <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_54"></a>The compiler typically complains if the code you write assigns a value to a type that can’t accommodate it. You might see warnings like these:</p>
                
                    <div class="codesample"><table><tr><td scope="row"><pre>incompatible types in assignment<span></span></pre></td></tr><tr><td scope="row"><pre>assignment of integer from pointer lacks a cast<span></span></pre></td></tr></table></div>
                
                <p>Type checking is useful, but there are times when it can interfere with the benefits you get from polymorphism<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_55"></a>, especially if the type of every object must be known to the compiler.</p>
                <p>Suppose, for example, that you want to send an object a message to perform the <code>start</code> method. Like other data elements, the object is represented by a variable. If the variable’s type (its class) must be known at compile time, it would be impossible to let runtime factors influence the decision about what kind of object should be assigned to the variable. If the class of the variable is fixed in source code, so is the version of <code>start</code> that the message invokes.</p>
                <p>If, on the other hand, it’s possible to wait until runtime to discover the class of the variable, any kind of object could be assigned to it. Depending on the class of the receiver, the <code>start</code> message might invoke different versions of the method and produce very different results.</p>
                <p>Dynamic typing thus gives substance to dynamic binding (discussed next). But it does more than that. It permits associations between objects to be determined at runtime, rather than forcing them to be encoded in a static design. For example, a message could pass an object as an argument without declaring exactly what kind of object it is—that is, without declaring its class. The message receiver might then send its own messages to the object, again without ever caring about what kind of object it is. Because the receiver uses the object it’s passed to do some of its work, it is in a sense customized by an object of indeterminate type (indeterminate in source code, that is, not at runtime).<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_56"></a>
                </p>
            
            <a name="//apple_ref/doc/uid/TP40005149-CH5-86819" title="Dynamic Binding"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW18" title="Dynamic Binding"></a>
                <h3>Dynamic Binding</h3>
                <p>
                    <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_57"></a>In standard C, you can declare a set of alternative functions, like the standard string-comparison functions,</p>
                
                    <div class="codesample"><table><tr><td scope="row"><pre>int strcmp(const char *, const char *);   /* case sensitive */<span></span></pre></td></tr><tr><td scope="row"><pre>int strcasecmp(const char *, const char *); /*case insensitive*/<span></span></pre></td></tr></table></div>
                
                <p>and declare a pointer to a function that has the same return and argument types<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_58"></a>:</p>
                
                    <div class="codesample"><table><tr><td scope="row"><pre>int (* compare)(const char *, const char *);<span></span></pre></td></tr></table></div>
                
                <p>You can then wait until runtime to determine which function to assign to the pointer,</p>
                
                    <div class="codesample"><table><tr><td scope="row"><pre>if ( **argv == 'i' )<span></span></pre></td></tr><tr><td scope="row"><pre>    compare = strcasecmp;<span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>    compare = strcmp;<span></span></pre></td></tr></table></div>
                
                <p>and call the function through the pointer:</p>
                
                    <div class="codesample"><table><tr><td scope="row"><pre>if ( compare(s1, s2) )<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div>
                
                <p>This is akin to what in object-oriented programming is called <strong>dynamic binding</strong>, delaying the decision of exactly which method to perform until the program is running.</p>
                <p>Although not all object-oriented languages support it, dynamic binding can be routinely and transparently accomplished through messaging. You don’t have to go through the indirection of declaring a pointer and assigning values to it as shown in the example above. You also don’t have to assign each alternative procedure a different name.</p>
                <p>Messages invoke methods indirectly. Every message expression must find a method implementation to “call.” To find that method, the messaging machinery must check the class of the receiver and locate its implementation of the method named in the message. When this is done at runtime, the method is dynamically bound to the message. When it’s done by the compiler, the method is statically bound.</p>
                <div class="notebox"><a name="//apple_ref/doc/uid/TP40005149-CH5-SW23" title="Late Binding"></a>
                    <p><strong>Late Binding:</strong>&nbsp;
                    Some<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_59"></a> object-oriented programming languages (notably C++) require a message receiver to be statically typed in source code, but don’t require the type to be exact. An object can be typed to its own class or to any class that it inherits from. The compiler therefore can’t tell whether the message receiver is an instance of the class specified in the type declaration, an instance of a subclass, or an instance of some more distantly derived class. Since it doesn’t know the exact class of the receiver, it can’t know which version of the method named in the message to invoke. In this circumstance, the choice is between treating the receiver as if it were an instance of the specified class and simply bind the method defined for that class to the message, or waiting until some later time to resolve the situation. In C++, the decision is postponed to link time for methods (member functions) that are declared <strong>virtual</strong>. This is sometimes referred to as “late binding” rather than “dynamic binding.” While “dynamic” in the sense that it happens at runtime, it carries with it strict compile-time type constraints. As discussed here (and implemented in Objective-C), “dynamic binding” is unconstrained.</p>
                </div>
                <p>Dynamic binding is possible even in the absence of dynamic typing, but it’s not very interesting. There’s little benefit in waiting until runtime to match a method to a message when the class of the receiver is fixed and known to the compiler. The compiler could just as well find the method itself; the runtime result won’t be any different.</p>
                <p>However, if the class of the receiver is dynamically typed, there’s no way for the compiler to determine which method to invoke. The method can be found only after the class of the receiver is resolved at runtime. Dynamic typing thus entails dynamic binding.</p>
                <p>Dynamic typing also makes dynamic binding interesting, for it opens the possibility that a message might have very different results depending on the class of the receiver. Runtime factors can influence the choice of receiver and the outcome of the message.</p>
                <p>Dynamic typing and binding also open the possibility that the code you write can send messages to objects not yet invented. If object types don’t have to be decided until runtime, you can give others the freedom to design their own classes and name their own data types, and still have your code send messages to their objects. All you need to agree on are the messages, not the data types.<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_60"></a>
                </p>
                <div class="notebox"><a name="//apple_ref/doc/uid/TP40005149-CH5-SW24" title="Note"></a>
                    <p><strong>Note:</strong>&nbsp;
                    Dynamic binding is routine in Objective-C. You don’t need to arrange for it specially, so your design never needs to bother with what’s being done when.</p>
                </div>
            
            <a name="//apple_ref/doc/uid/TP40005149-CH5-86999" title="Dynamic Loading"></a><a name="//apple_ref/doc/uid/TP40005149-CH5-SW19" title="Dynamic Loading"></a>
                <h3>Dynamic Loading</h3>
                <p>
                    <a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_61"></a>Historically, in many common environments, before a program can run all its parts had to be linked together in one file. When it was launched, the entire program was loaded into memory at once.</p>
                <p>Some object-oriented programming environments overcome this constraint and allow different parts of an executable program to be kept in different files. The program can be launched in bits and pieces as they’re needed. Each piece is dynamically loaded and linked with the rest of program as it’s launched. User actions can determine which parts of the program are in memory and which aren’t.</p>
                <p>Only the core of a large program needs to be loaded at the start. Other modules can be added as the user requests their services. Modules<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_62"></a> the user doesn’t request make no memory demands on the system.</p>
                <p>Dynamic loading raises interesting possibilities. For example, an entire program does not have to be developed at once. You can deliver your software in pieces and update one part of it at a time. You can devise a program that groups several tools under a single interface, and load just the tools the user wants. The program can even offer sets of alternative tools to do the same job—the user then selects one tool from the set and only that tool would be loaded.</p>
                <p>Perhaps the most important current benefit of dynamic loading is that it makes applications extensible. You can allow others to add to and customize a program you’ve designed. All your program needs to do is provide a framework that others can fill in, and, at runtime, find the pieces that they’ve implemented and load them dynamically. For example, Interface Builder<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_63"></a> dynamically loads custom plugins and inspectors. Anyone can design their own custom plugins that Interface Builder can load and incorporate into itself.</p>
                <p>The main challenge that dynamic loading faces is getting a newly loaded part of a program to work with parts already running, especially when the different parts were written by different people. However, much of this problem disappears in an object-oriented environment because code is organized into logical modules with a clear division between implementation and interface. When classes are dynamically loaded, nothing in the newly loaded code can clash with the code already in place. Each class encapsulates its implementation and has an independent namespace.</p>
                <p>In addition, dynamic typing and dynamic binding let classes designed by others fit effortlessly into the program you’ve designed. Once a class is dynamically loaded, it’s treated no differently than any other class. Your code can send messages to their objects and theirs to yours. Neither of you has to know what classes the other has implemented. You need only agree on a communications protocol.<a name="//apple_ref/doc/uid/TP40005149-CH5-DontLinkElementID_64"></a>
                </p>
                <div class="notebox"><a name="//apple_ref/doc/uid/TP40005149-CH5-SW25" title="Loading and Linking"></a>
                    <p><strong>Loading and Linking:</strong>&nbsp;
                    Although it’s the term commonly used, “dynamic loading” could just as well be called “dynamic linking.” Programs are linked when their various parts are joined so that they can work together; they’re loaded when they’re read into volatile memory at launch time. Linking usually precedes loading. Dynamic loading refers to the process of separately loading new or additional parts of a program and linking them dynamically to the parts already running.</p>
                </div>
            
        
    


        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ooOOP.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ooStructuringPrograms.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-11-19<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/OOP_ObjC/Articles/ooObjectModel.html%3Fid%3DTP40005149-1.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/OOP_ObjC/Articles/ooObjectModel.html%3Fid%3DTP40005149-1.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/OOP_ObjC/Articles/ooObjectModel.html%3Fid%3DTP40005149-1.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>