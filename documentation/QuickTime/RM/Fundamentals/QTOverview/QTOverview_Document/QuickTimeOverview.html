<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>QuickTime Overview</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="QuickTime Overview"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000992-CH1g" title="QuickTime Overview"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000433" target="_top">QuickTime</a> &gt; <a href="../QTOverview_AIntro/Introduction.html#//apple_ref/doc/uid/TP30000992-CH202-DontLinkElementID_3">QuickTime Overview</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../QTOverview_AIntro/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../QTOverview_RevHistory/revisionhistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000992-CH1g-QuickTimeOverview" title="QuickTime Overview"></a>
<h1>QuickTime Overview</h1>

<p>QuickTime is a cross-platform multimedia architecture for the Mac OS and Windows. It consists of a set of multimedia operating-system extensions (implemented as DLLs in Windows), a comprehensive API, a file format, and a set of user applications such as QuickTime Player, the QuickTime ActiveX control, and the QuickTime browser plug-in.</p>
<p>QuickTime is a complete multimedia architecture, not just a media player. It supports creating, producing, and delivering a broad variety of media. QuickTime provides end-to-end support for the entire process: capturing media in real time; synthesizing media programatically; importing and exporting existing media; editing and compositing; compression, delivery, and user playback.</p>
<p>Specific tasks that QuickTime is useful for include:</p>
<ul class="ul">
<li class="li"><p>Playing movies and other media, such as Flash or MP3 audio</p></li>
<li class="li"><p>Nondestructive editing of movies and other media</p></li>
<li class="li"><p>Importing and exporting images between formats, such as JPEG and PNG</p></li>
<li class="li"><p>Compressing and decompressing sound and video</p></li>
<li class="li"><p>Compositing, layering, and arranging multiple media elements from different sources</p></li>
<li class="li"><p>Synchronizing multiple time-dependent media to a single timeline</p></li>
<li class="li"><p>Capturing and storing sequences from real-time sources, such as audio and video inputs</p></li>
<li class="li"><p>Creating movies programmatically from synthesized data</p></li>
<li class="li"><p>Creating sprites that use intelligent, scripted animation</p></li>
<li class="li"><p>Creating presentations that interact with viewers, remote databases, and application servers</p></li>
<li class="li"><p>Creating movies that include customized window shapes, “skins,” and controls</p></li>
<li class="li"><p>Streaming movies in real time over a network or the Internet</p></li>
<li class="li"><p>Broadcasting real-time streams from live sources such as cameras and microphones</p></li>
<li class="li"><p>Distributing downloadable media on disc or over a network or the Internet</p></li>
</ul>



<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="QuickTimeOverview.html#//apple_ref/doc/uid/TP30000992-CH1g-Architecture">Architecture</a>
				
			<br/>
			
        
			
			
				<a href="QuickTimeOverview.html#//apple_ref/doc/uid/TP30000992-CH1g-TheQuickTimeAPI">The QuickTime API</a>
				
			<br/>
			
        
			
			
				<a href="QuickTimeOverview.html#//apple_ref/doc/uid/TP30000992-CH1g-QuickTimeMovies">QuickTime Movies</a>
				
			<br/>
			
        
			
			
				<a href="QuickTimeOverview.html#//apple_ref/doc/uid/TP30000992-CH1g-AtomsQuickTimeAtomsandAtomContainers">Atoms, QuickTime Atoms, and Atom Containers</a>
				
			<br/>
			
        
			
			
				<a href="QuickTimeOverview.html#//apple_ref/doc/uid/TP30000992-CH1g-StreamingBroadcastingandProgressiveDownload">Streaming, Broadcasting, and Progressive Download</a>
				
			<br/>
			
        
			
			
				<a href="QuickTimeOverview.html#//apple_ref/doc/uid/TP30000992-CH1g-QuickTimeRoadMap">QuickTime Road Map</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-Architecture" title="Architecture"></a>
<h2>Architecture</h2>
<p>The QuickTime programming architecture is a combination of flexible tool sets and plug-in components.</p>
<a name="//apple_ref/doc/uid/TP30000992-CH1g-Tool160Sets" title="Tool&Acirc;&nbsp;Sets"></a>
<h3>Tool Sets</h3>
<p>To support the complete spectrum of multimedia tasks, the QuickTime API contains a collection of <strong>toolsets</strong>, such as the <strong>Movie</strong> <strong>Toolbox,</strong> the <strong>Image</strong> <strong>Compression</strong> <strong>Manager,</strong> the <strong>sequence</strong> <strong>grabber,</strong> and the <strong>QuickTime</strong> <strong>streaming</strong> <strong>API.</strong></p>
<ul class="spaceabove">
<li class="li"><p>The Movie Toolbox is used to initialize QuickTime; open, play, edit, and save movies; and manipulate time-based media.</p></li>
<li class="li"><p>The Image Compression Manager is a device-independent and driver-independent means of compressing and decompressing image data.</p></li>
<li class="li"><p>The sequence grabber is a framework for components that capture and record samples from real-time sources, such as video cards or audio inputs.</p></li>
<li class="li"><p>The streaming API allows you to send and receive real-time streams using standard protocols such as RTP and  RTSP.</p></li>
</ul>
<p>There are several other tool sets, including <strong>QuickTime</strong> <strong>VR,</strong> the <strong>sprite</strong> <strong>toolbox,</strong> and the <strong>wired</strong> <strong>movies</strong> <strong>API,</strong> but you don’t need to use them all or even know them all. These tool sets work together, allowing you to focus on the task at hand, without needing to learn the entire QuickTime API. The different tool sets often share data types and programming paradigms, making it relatively easy to extend your knowledge of QuickTime as you go.</p>
<p>Many tool sets are useful when you need direct access to things that QuickTime usually deals with automatically. For example, when you use the Movie Toolbox to play a movie, it may open a stream of real-time data and decompress a series of images, without requiring you to interact with the streaming API or the Image Compression Manager. But if you need to check for streaming packet loss or be notified each time an image is decompressed, you can use the appropriate tool set from your application.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_4" title="Figure 1-1Using tool sets"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>Using tool sets</p><img src = "../art/using_toolsets.jpg" alt = "Using tool sets" ></div><br/>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-Components" title="Components"></a>
<h3>Components</h3>
<p>The QuickTime architecture makes extensive use of <strong>components,</strong> making it modular, flexible, and extensible. A QuickTime component is a shared code resource with a defined API. It is possible to add a new component to QuickTime and have existing applications automatically find it and use it when needed, largely because it responds to the same API as existing components of that general type.</p>
<p>For example, QuickTime works with a number of media types: sound, video, text, sprites, Flash, 3D models, photographic virtual reality, and others. Each media type is supported by a media handler component. The number and types of supported media are continually growing. You can add a new media type to QuickTime yourself by creating a new media handler component.</p>
<p>There are also component types for controlling and playing movies, importing and exporting media, compressing and decompressing images or sound, accessing data (from file systems, network servers, or blocks of memory), capturing sequences of digitized sample data, and so on. Here is a partial list:</p>
<ul class="spaceabove">
<li class="li"><p>Movie controller components are used to play movies and can provide a standard user interface.</p></li>
<li class="li"><p>Media handler components handle a particular type of media data, such as video, sound, Flash, or text.</p></li>
<li class="li"><p>Data handler components access data from a particular kind of data source, such as local files, URLs, or handles.</p></li>
<li class="li"><p>Image compressor components compress or decompress image data.</p></li>
<li class="li"><p>Image compression dialog components let the user specify the parameters for compression operations.</p></li>
<li class="li"><p>Video digitizer components are used to control video digitization by external devices such as video capture cards.</p></li>
<li class="li"><p>Movie data-exchange components (also known as movie import and movie export components) move data between QuickTime and other formats. QuickTime can play any type of media file for which it has an importer or create any type for which it has an exporter.</p></li>
<li class="li"><p>Video output components convert the visual output of QuickTime movies into video streams for devices other than displays.</p></li>
<li class="li"><p>Graphics import and export components provide a single API that lets you work with a wide variety of image file formats.</p></li>
<li class="li"><p>Music components process and synthesize MIDI-like music tracks in QuickTime movies.</p></li>
<li class="li"><p>Effects and transitions components implement visual filters, effects, and transitions. (Effects components are implemented as a special type of image compressor component.)</p></li>
</ul>
<p>As with tool sets, you don’t need to work with, or even know about, every type of component. Most components are used automatically as needed, but most also support an API that you can work with directly when you want to.</p>
<p>Each component has a <strong>type,</strong> a <strong>subtype,</strong> and a <strong>manufacturer</strong> code, each represented by a four-character code. A four-character code is a 32-bit value that is usually best interpreted as four ASCII characters. For example, an image decompressor component has a type of <code>'imdc'.</code></p>
<p>QuickTime often has multiple components of a given type. For example, QuickTime has many decompressor components. They all have the same type: <code>'imdc'.</code> Each <code>'imdc'</code> component has a subtype that specifies the kind of compression it understands, such as JPEG, and a manufacturer code that distinguishes among components of the same subtype. For example, the image decompressor for JPEG supplied by Apple has the type, subtype, and manufacturer codes of <code>'imdc',</code> <code>'jpeg',</code> <code>'aapl'</code> .</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_5" title="Figure 1-2Some commonly used tool sets and components"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Some commonly used tool sets and components</p><img src = "../art/toolsets_components.jpg" alt = "Some commonly used tool sets and components" ></div><br/>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_6" title="Important"></a><p><strong>Important:</strong>&nbsp;There are no “three-character” codes. Some of the four-character codes, such as <code>'eat</code> ', include an ASCII blank space (<code>0x020).</code> The space character is an important part of the code, and cannot be omitted. </p></div>
<p>QuickTime ships with a number of components and has the ability to download others when needed (provided there is an Internet connection and user consent). Third-party components installed locally can, in many cases, be recognized and used by existing applications without modification.</p>
<p>QuickTime finds, selects, loads, and unloads components as needed. This is often transparent to the applications programmer. For example, when you tell QuickTime to open a movie, QuickTime automatically finds and loads the correct media handlers and decompressors for the movie. An error is returned if these operations fail, but otherwise they are transparent to the application.</p>
<p>Nearly all QuickTime programmers need to deal directly with components from time to time, however. For example, to play a QuickTime movie, applications may work directly with a movie controller component.</p>
<p>Selecting and working with components is documented in <em><a href="../../../../Conceptual/ComponentMgr/index.html#//apple_ref/doc/uid/TP40000858" target="_top">Component Manager for QuickTime</a></em> This is a subset of the <em><a href="../../../../../Carbon/Reference/Component_Manager/index.html#//apple_ref/doc/uid/TP30000201" target="_top">Component Manager Reference</a></em> for the Mac OS (Carbon); it describes the parts of the Component Manager that QuickTime programmers are likely to use, and that are included in QuickTime for Windows.</p>
<p>Specific QuickTime components are discussed in the QuickTime documentation for the topic relevant to that component. For example, movie controller components are described in <em><a href="../../../MovieBasics/MTOpenPlayMovies/index.html#//apple_ref/doc/uid/TP40000919" target="_top">QuickTime Movie Playback Programming Guide</a></em> and compressor components are described in <span class="content_text"><a href="../../../../CompressionDecompression-date.html#//apple_ref/doc/uid/TP30000433-TP30000498" target="_top">Compression and Decompression</a></span>.</p>
<p>Note that the primary QuickTime documentation describes the interface to components from the perspective of an application calling the component. There is an additional set of documents that describe writing new components (see <span class="content_text"><a href="../../../../QuickTimeComponentCreation-date.html#//apple_ref/doc/uid/TP30000433-TP30000595" target="_top">Creating QuickTime Components</a></span>). If you are writing a QuickTime component, you need to read the primary documentation for that component, the generic documentation for creating QuickTime components, and any additional documentation for creating that particular kind of component in order to understand how the component is used, what API you need to support, and how best to implement it.</p>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-Examples" title="Examples"></a>
<h3>Examples</h3>
<p>Let’s look at two examples of the QuickTime architecture in action: getting a movie from a file and playing a movie using a movie controller.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_7" title="Figure 1-3Getting a Movie"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>Getting a Movie</p><img src = "../art/getting_a_movie.jpg" alt = "Getting a Movie" ></div><br/>
<ul class="spaceabove">
<li class="li"><p>Your application tells the Movie Toolbox to get a movie, in this case from a file.</p></li>
<li class="li"><p>A data handler component is used to access the file; a different component would be used to get a movie from a local file, a URL, or a stream. QuickTime chooses the appropriate component based on the data source.</p></li>
<li class="li"><p>If the file is not a QuickTime movie file, a movie importer component is used to create a movie from the file; a different component would be used to import from an MP3 file or a JPEG file. QuickTime chooses the appropriate importer based on the file type, file extension, or MIME type.</p></li>
<li class="li"><p>The Movie Toolbox passes a movie to your application.</p></li>
</ul>
<br/><div><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_8" title="Figure 1-4Playing a Movie"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>Playing a Movie</p><img src = "../art/playing_a_movie.jpg" alt = "Playing a Movie" ></div><br/>
<ul class="spaceabove">
<li class="li"><p>Your application attaches a movie controller to the movie and the user presses the “Play” button on the control bar.</p></li>
<li class="li"><p>A media handler component is used to work with each type of media used in the movie; different components are used for sound, video, Flash, and so on. QuickTime chooses the appropriate media handlers based on the media types.</p></li>
<li class="li"><p>Media handlers makes calls to data handlers to access their media samples, which may come from a different data sources. For example, a movie on a local disk might point to media samples on a local disk, a remote file server, and an Internet stream. QuickTime chooses the appropriate data handler for each data source.</p></li>
<li class="li"><p>A media handler typically makes calls to a decompressor component to decompress the media samples; different components are used for different media types, such as sound and video, and for different compression schemes, such as MP3 or MP4 audio, JPEG or GIF images. QuickTime chooses a decompressor based on the media type and compression scheme.</p></li>
<li class="li"><p>A media handler may then pass its output directly to a low-level service, such as the Sound Manager, for final disposal, or to another component, such as a video output component, for further processing.</p></li>
</ul>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-Output" title="Output"></a>
<h3>Output</h3>
<p>QuickTime can provide various kinds of output during playback. The output is typically sound and video, with a visible controller, but it can be simply sound, with no display or visible controller, or even a silent and invisible DV stream to a FireWire port.</p>
<p>The actual output is handled by a lower-level technology, such as Core Image, OpenGL, Core Audio, DirectX, or the Sound Manager. QuickTime shields you from having to deal with these details in most cases. When you play a movie, QuickTime selects and configures the default devices for playback on your platform.</p>
<p>If you need to work with QuickTime at a lower level, to modify individual video frames during playback, for example, or to add a filter to the sound output, you need to work with the underlying technology that QuickTime relies on for output. This will vary depending on your platform and software revision.</p>
<p>For example, QuickTime 7 for Mac OS X uses Core Audio for audio output. To work with QuickTime audio at the low level, you should use the Core Audio API.  Older versions of QuickTime send audio output to the Sound Manager (included in QuickTime for Windows). To work with low level audio on these systems, you need to use the Sound Manager API.</p>
<p>By default the visual output from QuickTime 7 for Mac OS X goes to a graphics context managed by Quartz, while visual output on QuickTime for Windows and older versions of QuickTime for the Mac OS goes to a graphics port associated with a window, represented by an offscreen buffer called a <code>GWorld</code>. QuickTime handles decompression and visual rendering automatically.</p>
<p>QuickTime can be specifically directed to send its visual output to any device that has an installed video output component.</p>
<p>In addition, in QuickTime 7 and later you can create a visual context to specify a particular output format, such as Core Image pixel buffers or OpenGL textures. If you do this, however, you become responsible for rendering the decompressed frames to the screen. You can render the images using one of the underlying graphics Mac OS APIs, such as Core Video and Core Image, OpenGL, or QuickDraw. On Windows, you might use native Windows video APIs, OpenGL, or the parts of QuickDraw included in QuickTime for Windows.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_9" title="Note"></a><p><strong>Note:</strong>&nbsp;QuickTime programmers working on Windows OS or versions of the Mac OS prior to 10.4 need to learn a little about graphics worlds and QuickDraw to learn how to properly set up a graphics world, associate it with a graphics port, and work with the common QuickDraw data types, such as a rect. (See <span class="content_text"><a href="http://developer.apple.com/documentation/quicktime/INMAC/MACWIN/imClrQuickDraw.htm" target="_top">Color QuickDraw</a></span>, <span class="content_text"><a href="http://developer.apple.com/documentation/QuickTime/INMAC/MACWIN/imGraphDevices.htm#10802" target="_top">Graphic Devices</a></span> and <em><a href="../../../../../Carbon/Reference/QuickDraw_Ref/index.html#//apple_ref/doc/uid/TP30000975" target="_top">QuickDraw Reference</a></em>.) </p></div>
<p>Audio output goes to your system’s default audio device by default, but QuickTime 7 and later support an audio context that allows you to specify any output device. QuickTime 7 and later also include some functions for working with audio, such as setting track volume, balance, and channel layout, and monitoring frequency levels during playback. To do sound processing or filtering, however, you need to use a lower-level technology such as Core Audio or DirectSound.</p>


<a name="//apple_ref/doc/uid/TP30000992-CH1g-TheQuickTimeAPI" title="The QuickTime API"></a>
<h2>The QuickTime API</h2>
<p>The QuickTime API allows you to add a host of multimedia features to your application without needing to master the often arcane details of particular media formats and specifications.</p>
<p>For example, you can use QuickTime to open and display a series of JPEG images, concatenate them into a time-based slideshow with an MP3 sound track, then export the images as TIFF or PNG graphics, or export the slides and music together as a DV stream, without needing to work directly with, or necessarily understand, the  compression, stream, or file formats for JPEG, TIFF, PNG, MP3, or DV.</p>
<a name="//apple_ref/doc/uid/TP30000992-CH1g-MultilevelAPI" title="Multilevel API"></a>
<h3>Multilevel API</h3>
<p>The QuickTime API includes over 2500 functions, divided into tool sets for particular tasks, with special functions and data types for virtually any task.</p>
<p>This can be a little daunting for programmers new to the API. It is easy to get lost in details and lose sight of the big picture. The most common error among new QuickTime programmers is to attack a problem using a complex, low-level tool set when there is a much simpler high-level command to perform the entire task.</p>
<p>You can interact with the QuickTime API at many different levels:</p>
<ul class="spaceabove">
<li class="li"><p>You can simply open and play movies, letting QuickTime handle all the file and format conversion, synchronization, data buffering, component loading and unloading, memory management, and even the user interface. Prebuilt controls are available for play/pause, volume control, time scrubbing, and cut-and-paste editing.</p></li>
<li class="li"><p>You can control the playback or editing yourself, setting the play rate, scaling the duration of movie or track segments, rearranging the playback order, and so on, creating your own user interface and controls.</p></li>
<li class="li"><p>You can work with individual components, loading particular importers or image decompressors, applying them to groups of files or blocks of memory, and disposing of them when you are done.</p></li>
<li class="li"><p>You can work with individual data samples—synthesizing graphics and overlaying them on video frames as a movie plays, for example—or performing pattern recognition on groups of samples, or even generating whole movies programatically.</p></li>
<li class="li"><p>You can write new QuickTime components to support features such as new compression algorithms, new media types, new media capture devices, output devices, or data sources.</p></li>
</ul>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-Frameworks" title="Frameworks"></a>
<h3>Frameworks</h3>
<p>You can work directly with the QuickTime API using C, C++, Objective C, or Java. There are also QuickTime interfaces for JavaScript, and Windows interfaces for Visual Basic, C#, and other COM or .Net frameworks.  Other languages, such as BASIC or Pascal, may support indirect calls to the QuickTime API through calls to a directly supported language or framework.</p>
<p>Most developers call the QuickTime API from procedural C  programs written in C or C++, and most of the QuickTime documentation describes this use of the API. Nearly all of the procedural C QuickTime API is also part of the Carbon framework for Mac OS X. However, the QuickTime API does include some Windows-only functions and some legacy functions from earlier versions of the Mac OS. The documentation of any function in the <em><!--a target="_top" -->QuickTime API Reference<!--/a--></em> tells you whether that particular function is included in Carbon.</p>
<p>The procedural C QuickTime API for Windows is almost identical to the Mac OS version, with a few exceptions and some minor modifications to avoid naming conflicts with the Windows operating system. These exceptions and modifications are documented in <span class="content_text"><a href="../../../../QuickTimeforWindows-date.html#//apple_ref/doc/uid/TP30000433-TP30000563" target="_top">QuickTime for Windows Programmers.</a></span> Some newer parts of the QuickTime API make use of advanced features of Mac OS X that are not available in Windows. In these cases the documentation will note an alternative API to achieve similar functionality in Windows, if this is possible.</p>
<p>There is also a QuickTime API for Objective-C, which corresponds to the Cocoa programming framework for Mac OS X. This rapidly growing part of the API is greatly streamlined and simplified. It is documented in <span class="content_text"><a href="../../../../Cocoa-date.html#//apple_ref/doc/uid/TP30000433-TP30000495" target="_top">QuickTime for Cocoa Programmers.</a></span>  It is also possible to call the procedural C parts of the QuickTime API from Cocoa programs if lower-level access to QuickTime is needed.</p>
<p>The Java API for QuickTime is documented in <span class="content_text"><!--a target="_top" -->QuickTime for Java<!--/a--></span>. You can make calls to the procedural C parts of the QuickTime API from Java.</p>
<p>Documentation of the JavaScript API can be found in the <em><a href="../../../../Conceptual/QTScripting_JavaScript/index.html#//apple_ref/doc/uid/TP40001526" target="_top">JavaScript Scripting Guide for QuickTime</a></em>.</p>


<a name="//apple_ref/doc/uid/TP30000992-CH1g-QuickTimeMovies" title="QuickTime Movies"></a>
<h2>QuickTime Movies</h2>
<p>When working with the QuickTime API, nearly all operations are performed on a data structure known as a QuickTime <strong>movie.</strong> The QuickTime movie is a description of a multimedia presentation. It tells a computer (or other multimedia-capable device):</p>
<ul class="ul">
<li class="li"><p>What type of media to present</p></li>
<li class="li"><p>Where the data is located</p></li>
<li class="li"><p>When and how to present each sample</p></li>
<li class="li"><p>How to layer, arrange, and composite multiple elements</p></li>
</ul>
<p>You can use QuickTime movies in several ways:</p>
<ul class="ul">
<li class="li"><p>Record digital data into QuickTime movies</p></li>
<li class="li"><p>Import media from other formats into QuickTime movies</p></li>
<li class="li"><p>Export from QuickTime movies to other formats</p></li>
<li class="li"><p>Create, edit, and play all types of media (as QuickTime movies)</p></li>
</ul>
<p>For example, to play an MP3 audio file using QuickTime, you create a new movie in memory from the MP3 file and play the movie. This does not directly copy the MP3 audio data into memory; it creates a small movie data structure that allows QuickTime to find, decompress, and play the audio data in the MP3 file.</p>
<p>A QuickTime movie does not contain sample data, such as audio samples or video frames. A movie is the organizing principle that allows a computer to locate and interpret the required sample data. Playing a movie causes QuickTime to locate and obtain sample data from wherever it is, decompress and composite it as necessary, and present it in the proper sequence and arrangement.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_10" title="Figure 1-5Sample data resides outside of the movie"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>Sample data resides outside of the movie</p><img src = "../art/external_data.jpg" alt = "Sample data resides outside of the movie" ></div><br/>
<p>High-level QuickTime operations, such as opening and playing movies, can often be performed with no need to delve into any details of a particular movie, such as what kind of media are presented, how the media are compressed, or where the data samples are stored. Still, a basic understanding of QuickTime movie structure is useful for any QuickTime programmer and is essential for lower-level operations.</p>
<a name="//apple_ref/doc/uid/TP30000992-CH1g-MoviesandMovieFiles" title="Movies and Movie Files"></a>
<h3>Movies and Movie Files</h3>
<p>It’s important to distinguish between a QuickTime movie, the data structure we have been discussing, and a QuickTime <strong>movie</strong> <strong>file.</strong> A movie is not the same as a movie file.</p>
<p>A movie file can contain a stored copy of a movie data structure, or it can contain only a reference to such a structure, stored somewhere else.</p>
<p>If a movie file contains a stored movie, it can optionally contain the sample data used by the movie as well. This is sometimes called a self-contained movie file, and it is quite common. When the sample data is stored in a movie file, it is interleaved for smooth playback.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_11" title="Figure 1-6Three kinds of movie files"></a><p><strong>Figure 1-6&nbsp;&nbsp;</strong>Three kinds of movie files</p><img src = "../art/movie_files.jpg" alt = "Three kinds of movie files" ></div><br/>
<p>In casual use, a QuickTime movie file is sometimes simply called a movie. Similarly, a reference movie file may be called a reference movie, and a self-contained movie file may be called a self-contained movie. But in the QuickTime API documentation, the word “movie” always refers to a movie <em>data</em> <em>structure,</em> not a movie file. It is sometimes useful to think of a movie in memory as an instance of a movie stored in a file.</p>
<p>The copy of a movie stored in a movie file is sometimes referred to as a <strong>movie</strong> <strong>resource</strong> to distinguish it from a movie in memory.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_12" title="Note"></a><p><strong>Note:</strong>&nbsp;In early versions of QuickTime, the movie data structure was stored in the resource fork of Mac OS files; hence the name “movie resource.” This is no longer the case, but the name remains, and the distinction is sometimes useful. </p></div>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-Tracks" title="Tracks"></a>
<h3>Tracks</h3>
<p>A QuickTime movie is organized into <strong>tracks.</strong> A movie can contain many tracks; there are practical limits, which change as computers become more powerful, but there is no predefined limit.</p>
<a name="//apple_ref/doc/uid/TP30000992-CH1g-TrackMediaCompressionandDataReferences" title="Track Media, Compression, and Data References"></a>
<h4>Track Media, Compression, and Data References</h4>
<p>Each track specifies a <strong>media</strong> <strong>type—such</strong> as video, sound, or text—and a <strong>data</strong> <strong>reference</strong> that specifies where the sample data for that track can be found. A track may also specify a <strong>compression</strong> <strong>format</strong> (such as JPEG video or GSM audio).</p>
<p>The data reference may be to a local file, a file on a network or Internet server, a data stream from a network or Internet server, or a handle or pointer to a block of memory; other data reference types are also possible and the type itself is extensible. Simply put, the movie data can be anywhere. A data reference identifies the data source.</p>
<p>Different tracks can specify the same data source or different data sources. All the movie’s media samples can be in a single file, for example, or the samples for a movie’s sound track can be in one file while the samples for the video track are stored in a different file.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_13" title="Figure 1-7Movies can use data from multiple sources"></a><p><strong>Figure 1-7&nbsp;&nbsp;</strong>Movies can use data from multiple sources</p><img src = "../art/multiple_data_refs.jpg" alt = "Movies can use data from multiple sources" ></div><br/>
<p>A given track can specify only one media type, and most tracks get all of their samples from a single source. Some media types support multiple sources, however. For example, a video track can consist a series of JPEG images, each stored in a separate file. In this case, there is a data reference for every image.</p>
<p>Different tracks can be of the same media type or of different media types—you can have multiple video tracks and multiple sound tracks in the same movie, for example, or multiple text tracks in different languages.</p>
<p>A given track can use only one type of compression, but multiple tracks of the same media type may be compressed differently in the same movie. For example, a single movie can contain both MP3 and MPEG-4 compressed audio tracks.</p>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-TrackVisualandSoundCharacteristics" title="Track Visual and Sound Characteristics"></a>
<h4>Track Visual and Sound Characteristics</h4>
<p>Visual tracks have properties such as height, width, x and y offsets, layer numbers, and graphics modes. This allows you to play multiple visual tracks at the same time: side by side, partly or completely overlapping, and with various degrees of transparency or translucence. Visual tracks also contain a transformation matrix that can be used for rotating, scaling, or skewing the visual output of a track at runtime. QuickTime provides automatic clipping of images at the track boundary, and can have an associated mask, or matte, for cropping the output using arbitrary shapes.</p>
<p>Sound tracks have properties such as volume and balance, allowing you to create layers of sound. Multichannel sound formats, such as four-speaker and 5.1 surround sound, are supported in QuickTime 7 and later.</p>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-TrackMedia" title="Track Media"></a>
<h4>Track Media</h4>
<p>A track also contains a data structure known as a media. This is a low-level data structure that describes the location, duration, and natural time scale of the media sample data. This can be confusing, because in casual use the sample data itself is sometimes referred to as the track’s media.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_14" title="Important"></a><p><strong>Important:</strong>&nbsp;Try not to confuse the media data structure with the data samples themselves. </p></div>
<p>When a QuickTime function or data type specifies a <code>media</code> as a parameter or field, it always refers to the media data structure inside a movie, not to actual data samples.</p>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-MediaTimeScale" title="Media Time Scale"></a>
<h4>Media Time Scale</h4>
<p>A QuickTime movie always has a <strong>time</strong> <strong>scale,</strong> expressed in units per second. You can specify a time scale when you create a movie, but the time scale cannot be changed once a movie exists. When you perform operations on a QuickTime movie, you frequently need to specify a point in the movie timeline at which to begin the operation; this is specified using a time value, expressed in movie time scale units. You may also need to specify a duration; this is also expressed in movie time scale units.</p>
<p>The default movie time scale is 600, so to advance a movie to a point 2 seconds into its duration, you would typically go to time 1200. Similarly, a duration of 1/30th of a second would be 20 time scale units. You can obtain the movie time scale by calling <code><a href="../../../../Reference/QTRef_MovieManager/Reference/reference.html#//apple_ref/c/func/GetMovieTimeScale" target="_top">GetMovieTimeScale</a></code>.</p>
<p>Tracks use the time scale of their parent movie. Time values and durations for all track operations are expressed in movie time scale units.</p>
<p>Each track’s media, however, has its own time scale, which is typically the sample rate of the track’s media data. For example, a track containing NTSC video might have a time scale of 30, while a track containing PAL video would have a time scale of 25, and a track containing CD audio would have a time scale of 44100. This allows you to conveniently refer to individual media data samples, increment through a group of samples, and so on.</p>
<p>Operations on individual media samples typically use times and durations expressed in the media time scale. You can obtain the media time scale for a given track by calling <code><a href="../../../../Reference/QTRef_TrackAndMedia/Reference/reference.html#//apple_ref/c/func/GetMediaTimeScale" target="_top">GetMediaTimeScale</a></code>.</p>
<p>There are utility functions for translating between track time (which is also movie time) and media time. There are also numerous functions that allow you to translate between the time domain (time and duration) and the sample domain (sample number and number of samples).</p>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-TrackEditList" title="Track Edit List"></a>
<h4>Track Edit List</h4>
<p>Each track contains an edit list, which allows you to alter or reorder the display of media samples without changing or rearranging the samples themselves. This results in nondestructive editing. You can “edit out” a track segment without deleting any samples from the data source, or repeat a segment without increasing the size of the data source with duplicate samples.</p>
<p>You can also use the edit list to alter the duration of a media segment, causing it to play back faster or more slowly than it normally would, or insert an “empty” track segment that contains no data for a period of time.  In other words, any segment of media time, including an empty segment, can be mapped to any segment of track time.</p>
<p>If a track has not been edited, the edit list is empty and the track is treated as a single segment, with all the media samples played in the order they are stored, at the natural time scale for the media sample data.</p>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-TrackDuration" title="Track Duration"></a>
<h4>Track Duration</h4>
<p>Each track has a duration, which is the combined duration of all segments in its edit list (typically the combined duration of all of its samples), including any “empty” segments.</p>
<p>Similarly, each movie has a duration, which is simply the duration of its longest track.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_15" title="Note"></a><p><strong>Note:</strong>&nbsp;Technically, it is possible to offset the beginning of a track from the beginning of a movie by a fixed amount of time. In practice, this is rarely done; instead, an “empty” segment is inserted at the beginning of the track’s edit list, so that the first sample is displayed after a fixed amount of time. </p></div>


<a name="//apple_ref/doc/uid/TP30000992-CH1g-Samples" title="Samples"></a>
<h3>Samples</h3>
<p>At the lowest level, a QuickTime track contains a set of sample tables. Each entry in a sample table specifies the location and duration of a chunk of sample data, such as a still image, a video frame, a sequence of PCM audio samples, or a text string.</p>
<p>There is at least one sample description for each table of samples. The sample description provides the details necessary to translate a stored sample into a format that the media handler can work with. For example, a sample description might specify the height, width, and pixel format of an image, or the sample size and sampling rate of a group of PCM audio samples.</p>
<p>For some media types, such as sound, all data samples in a given track share a single sample description. If you have audio samples that use different sample rates or sample sizes, for example, they must be in separate sound tracks.</p>
<p>Other media types can have multiple sample descriptions, so a series of images could have varying heights and widths, with different sample descriptions used whenever the dimensions change.</p>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-SampleDurationandFrameRate" title="Sample Duration and Frame Rate"></a>
<h3>Sample Duration and Frame Rate</h3>
<p>Because each chunk of sample data has its own duration, and a chunk can be as small as a single sample, a QuickTime track may not have any fixed “frame rate.” A video track might consist of a series of images that act as a slideshow, for example, with each “slide” on screen for a different length of time.</p>
<p>This can be very difficult to grasp if you are used to working in media with fixed frame rates, but it is a powerful feature of QuickTime. A fixed frame rate would require images to be repeated periodically, perhaps many times, to display them on screen for an extended period; in QuickTime, each image can be stored as a single sample with its own unique duration.</p>
<p>By extension, a QuickTime movie does not necessarily have a fixed frame rate. A 25-fps PAL video track may play side by side with a 30-fps NTSC video track in the same movie, for example, perhaps with both tracks composited on top of a still image that is displayed for the entire duration of the movie, or on top of a “slideshow” track that changes at irregular intervals. This is possible because the display is created at runtime by a programmable device, not mechanically projected by display hardware.</p>
<p>Of course, a QuickTime track, or a QuickTime movie, may have a frame rate; it is very common for a video track to contain a series of samples that all have the same duration, and it is also common for a movie to have a single video track with a constant sample rate. But it is not a requirement.</p>
<p>You can always compute a frame rate by dividing the duration of a track by the total number of video samples, but be aware that the results of this calculation are not always predictive of the movie’s behavior; the actual frame rate could change abruptly at several points during the movie.</p>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-Time" title="Time"></a>
<h3>Time</h3>
<p>As noted in the discussion of tracks, a movie has a <strong>time</strong> <strong>scale,</strong> as does the media for each track. A time scale specifies some number of units per second. For a media, the time scale is usually the sample rate. For a track or a movie, the time scale can be any convenient number (the track time scale is the same as the movie time scale).</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_16" title="Note"></a><p><strong>Note:</strong>&nbsp;The default time scale for a movie is 600 units per second. You can specify a time scale when you create a movie or add a blank media to a new track. </p></div>
<p>The relationship among the movie’s time scale and the time scales of the various media define the movie’s <strong>time-coordinate</strong> <strong>system.</strong>  QuickTime uses the movie’s time-coordinate system to synchronize all the tracks and media to the movie timeline.</p>
<p>A movie always has a <strong>current</strong> <strong>time,</strong> which designates what parts of the movie should be presented immediately. The current time is expressed in movie time-scale units. For example, if the movie time-scale is 600, and the movie has been playing for half a second, the current time is 300.</p>
<p>The current time can range from 0 to the movie’s duration. Current time changes as the movie plays. Dragging the playhead in a movie controller changes the current time in the movie.</p>
<p>A movie also has a <strong>rate,</strong> which is 0 when the movie is stopped and 1 when the movie is playing at its normal speed, which is defined by the movie time-scale. For example, a movie with a time-scale of 600 plays at 600 units per second when the rate is 1. Negative rates cause the movie to play backward. Rates greater or less than 1 cause the movie to play faster or slower than normal. For example, a movie with a time-scale of 600 plays at 300 units per second when the rate is 0.5, and at 1200 units per second when the rate is 2.</p>
<p>QuickTime establishes a playback <strong>time</strong> <strong>base</strong> when a movie is run. The time base consists of the movie’s time-coordinate system, a rate, a current time, and a reference to a <strong>clock</strong> <strong>component</strong> that provides QuickTime with measurements of real time. This allows QuickTime to play a movie at the correct number of time-scale units per second for the current rate in real time.</p>
<p>This also allows QuickTime to “drop frames” appropriately if the data rate of the movie exceeds the capability of the playback device, so tracks remain synchronized with each other and with real time specifications (for example, a one-minute movie plays in exactly one minute, even if the playback device cannot decompress all of the movie’s video frames in that length of time).</p>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-LinearandNonlinearMediaandMovies" title="Linear and Nonlinear Media and Movies"></a>
<h3>Linear and Nonlinear Media and Movies</h3>
<p><strong>Linear</strong> media, such as a series of consecutive video frames, are tied to the movie timeline; they change in a fixed manner as the current time changes, varying in tempo and direction with the movie’s rate.</p>
<p>QuickTime also supports <strong>nonlinear</strong> media, such as a bouncing sprite, whose actions can be specified with respect to the passage of real time, or with respect to user actions such as mouse clicks. These actions can continue even when the movie is paused (has a rate of 0). This makes it possible to embed customized controls in a movie that respond to user interaction.</p>
<p>Movies that normally play at a fixed rate are called linear movies and typically feature a controller with a play/pause button and a time-slider. Movies that are nonlinear may feature a different type of controller or no controller at all.</p>
<p>For example, a VR panorama is usually controlled by a special VR controller that changes the image in response to the keyboard and mouse. A VR movie normally has a rate of 0, because it consists of a still image that the user can interact with. The VR image is nonlinear; it does not change in a fixed manner during the movie timeline, but in response to unpredictable user actions.</p>
<p>Nonlinear movies can use the movie timeline to separate distinct behaviors. For example, if a panorama has multiple nodes, each node is located at a different point on the movie timeline to keep them from displaying simultaneously; jumping to a new node involves changing the current time, typically while leaving the rate at 0.</p>
<p>It is possible to mix linear and nonlinear media in the same movie. To add sound to a VR panorama, for example, the duration of the VR image is extended to match the duration of the sound track. When the rate is nonzero, the sound plays.  The display of the panorama remains nonlinear, however; it changes when the user interacts with it, without regard to the movie’s current time or rate (as long as the current movie time is within the VR image’s duration). If the movie is paused, for example, the sound stops playing but the VR image remains interactive.</p>
<p>When mixing linear and nonlinear media, it is sometimes necessary to create custom movie controls. For example, the VR controller has no play/pause button to start and stop a sound track. You can control the movie rate programatically from your application or add an interactive sprite to the movie, such as a play/pause button, to provide user control.</p>


<a name="//apple_ref/doc/uid/TP30000992-CH1g-AtomsQuickTimeAtomsandAtomContainers" title="Atoms, QuickTime Atoms, and Atom Containers"></a>
<h2>Atoms, QuickTime Atoms, and Atom Containers</h2>
<p>QuickTime makes frequent use of data types known as <strong>atoms.</strong> You do not normally need to deal with QuickTime at the atomic level. In general, there are higher-level functions that allow you to, for example, create a movie, add or delete a track, or set a track’s media type, without directly manipulating, or necessarily knowing anything about, atoms.</p>
<p>To understand the various ways movies can be delivered over a network, however, it is useful to know how movies are stored in files, and QuickTime movies are stored in files as atoms.</p>
<p>An atom is simply a container; it has a 4-byte <strong>length</strong> field, which specifies its total size (including the length field), and a 4-byte <strong>type</strong> field, typically four ASCII characters, which specifies the type of atom it is. The type field can be followed by data, the amount and kind of data depending on the atom type.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_17" title="Figure 1-8Atom layout"></a><p><strong>Figure 1-8&nbsp;&nbsp;</strong>Atom layout</p><img src = "../art/atom_layout.jpg" alt = "Atom layout" ></div><br/>
<p>The smallest possible atom is therefore 8 bytes: a 4-byte size field and a 4-byte type field, with no data.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_18" title="Note"></a><p><strong>Note:</strong>&nbsp;Because no atom can be smaller than 8 bytes, the size field can contain the values 0 through 7 as special flags; a flag could indicate, for example, that the atom extends to the end of a file, or that the atom is larger than a 32-bit field can describe, and the actual size is in a 64-bit field following the type field. </p></div>
<p>One atom can contain other atoms, allowing you to nest them in arbitrary hierarchies. This makes atoms handy building blocks for larger data structures.</p>
<p>You can “insert” one atom into another simply by appending the new atom and adding its size to the size field of the original atom. The original atom has now been extended to “contain” the new atom. If the original atom is inside yet another atom, that atom can be extended in the same manner.</p>
<p>An atom inside another atom is sometimes called a <strong>child</strong> <strong>atom.</strong> Child atoms at the same level in a hierarchy are called <strong>siblings.</strong> An atom that has other atoms inside is called a <strong>parent</strong> <strong>atom</strong> or <strong>container</strong> <strong>atom.</strong> An atom that has tabular data inside, instead of other atoms, is called a <strong>leaf</strong> <strong>atom.</strong></p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_19" title="Note"></a><p><strong>Note:</strong>&nbsp;It is possible for an atom to contain both tabular data and other atoms, but this is discouraged. </p></div>
<br/><div><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_20" title="Figure 1-9Parent atoms and leaf atoms"></a><p><strong>Figure 1-9&nbsp;&nbsp;</strong>Parent atoms and leaf atoms</p><img src = "../art/atom_hierachies.jpg" alt = "Parent atoms and leaf atoms" ></div><br/>
<p>Because an atom begins with its size, it is easy to “walk” an atom structure by skipping from atom to atom within the structure. You can quickly scan a collection of atoms for an atom of a particular type or skip over an atom you are not interested in.</p>
<p>A QuickTime movie is a parent atom whose type is <code>'moov'</code>.</p>
<p>Each track in a movie is a child atom of type <code>'trak'</code> inside a <code>'moov'</code> atom.</p>
<p>Each track atom contains other child atoms, such as an edit list atom and a media atom. These atoms in turn contain other atoms, such as a media handler atom or various sample table atoms. The sample tables are leaf atoms.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_21" title="Figure 1-10Layout of a movie atom"></a><p><strong>Figure 1-10&nbsp;&nbsp;</strong>Layout of a movie atom</p><img src = "../art/structure_movie_atom.jpg" alt = "Layout of a movie atom" ></div><br/>
<p>Specific atoms are documented in the <em><!--a target="_top" -->QuickTime API Reference<!--/a--></em>, and may also be described conceptually in the documentation of a relevant topic, function, or group of functions. Additional details of the content and structure of various atoms can be found in the <span class="content_text"><!--a target="_top" -->QuickTime File Format<!--/a--></span> specification.</p>
<p>A refinement of the basic atom, used for some types of QuickTime data, is the QuickTime atom, or <strong>QT</strong> <strong>atom.</strong> This type of atom has additional header fields that specify the version of a particular atom type, an ID that allows you to distinguish one atom of a given type from its siblings in a hierarchy, and other useful information. It also has the restriction of containing either tabular data or other atoms, but never both. (If a QT atom needs to contain data about itself, in addition to containing other atoms, the necessary data is simply wrapped in an atom.)</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_22" title="Figure 1-11QT Atom Layout"></a><p><strong>Figure 1-11&nbsp;&nbsp;</strong>QT Atom Layout</p><img src = "../art/qt_atom_layout.jpg" alt = "QT Atom Layout" ></div><br/>
<p>At the highest level, a hierarchy of QT atoms is stored in an <strong>atom</strong> <strong>container.</strong> This is a unique data structure (not an atom) that contains a hierarchy of QT atoms.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_23" title="Figure 1-12Atom container and QT atoms"></a><p><strong>Figure 1-12&nbsp;&nbsp;</strong>Atom container and QT atoms</p><img src = "../art/qt_atom_container.jpg" alt = "Atom container and QT atoms" ></div><br/>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000992-CH1g-DontLinkElementID_24" title="Important"></a><p><strong>Important:</strong>&nbsp;An atom container is <em>not</em> an atom; it is a non-atom data structure that <em>contains</em> a hierarchy of QT atoms. Do not confuse it with a “container atom” (another name for a parent atom), which is simply an atom that contains other atoms. To prevent confusion with atom containers, the term “parent atom” is preferred rather than “container atom.” </p></div>
<p>Complex data structures, such as compression settings, are commonly stored in atom containers. This allows these data structures to be flexible and extensible, unlike a rigid struct. Properties can be stored as atoms, and it is possible to find out if a particular instance of the structure has a given property, and what data format the property takes, before getting or setting the property. The QT atoms within a container are typically accessed by their byte offsets within the container, which makes data transfer quick and efficient.</p>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-StreamingBroadcastingandProgressiveDownload" title="Streaming, Broadcasting, and Progressive Download"></a>
<h2>Streaming, Broadcasting, and Progressive Download</h2>
<p>QuickTime movies are usually stored to disk in QuickTime movie files. These files often contain the sample data used by the movie as well. The QuickTime API includes functions to store a movie, or a movie and all its associated sample data, to a file. By default, the movie data structure is stored at the beginning of the file (in the form of a <code>'moov'</code> atom) followed by any sample data (typically wrapped in an <code>'mdat'</code> atom). By default, the sample data is interleaved, so that media samples that are displayed at the same time are stored close together, with the samples needed earliest stored first.</p>
<p>This typical movie file can be delivered by any web server, using common protocols such as HTTP and FTP, just as if it were an HTML file or a JPEG image. It is necessary only to name the file correctly and associate the filename extension with the correct MIME type on the server. (The correct filename extension for QuickTime movies is .mov, and the correct MIME type is <code>'video/quicktime'.)</code></p>
<p>When a file is delivered over a network or downloaded over the Internet, the entire file is not available immediately, but a typical QuickTime movie can be played while it downloads. This is called <strong>progressive</strong> <strong>download,</strong> or <strong>Fast</strong> <strong>Start.</strong> It works because the movie atom is stored at the beginning of the file, so QuickTime knows how to interpret the movie sample data even before it arrives, and because the movie data is intelligently interleaved with respect to display time.</p>
<p>It is also possible to create a movie file with the sample data stored first, followed by the movie data structure. This is not usually desirable, because the entire file must download before QuickTime can interpret the sample data. You can correct this kind of data inversion simply by opening the movie file in QuickTime and saving it as a new, self-contained file. QuickTime stores the movie data structure at the beginning of the file by default.</p>
<p>A QuickTime movie file may contain <em>only</em> a movie data structure, pointing to sample data in other files or URLs. In most cases, this type of movie can also play as the movie data downloads, because, again, the movie data structure allows QuickTime to interpret the incoming data, and because the data source for each track is specified independently, causing the network to perform a kind of interleaving by delivering all of the media independently and simultaneously. Obviously, this kind of interleaving is less reliable than the deliberate interleaving QuickTime does when creating a self-contained movie file, so playback may not always be as smooth.</p>
<p>When the bandwidth of a connection meets or exceeds the data rate of the movie, a well-formed QuickTime movie file can play as it downloads. This kind of progressive download, or Fast Start movie, provides the same user experience as real-time streaming.</p>
<p>If the connection is not fast enough to play the movie in real time, you can either wait until the download completes or play as much of the movie as has downloaded at a given time. QuickTime can even estimate the required download time and begin playback when it calculates that enough data has arrived to play the movie smoothly (because the remaining data is expected to arrive by the time it is needed).</p>
<p>QuickTime movies can also be delivered using real-time protocols such as RTP and RTSP. This requires a streaming server, such as the QuickTime Streaming Server or Darwin Streaming Server. To stream movies in real time, the server requires information about how to packetize each track in the movie. This information is stored in special tracks in a QuickTime movie, known as <strong>hint</strong> <strong>tracks.</strong> There are functions in the API for adding hint tracks to existing movies, as well as flags that can be used to tell QuickTime to create hint tracks when saving a movie to disk.</p>
<p>Movies with hint tracks can also be delivered using HTTP or FTP protocols for progressive download, but additional bandwidth is needed to carry the hint tracks, which are used only for streaming. Consequently, it is best to determine how you will deliver a movie before saving it as hinted or nonhinted.</p>
<p>In addition to progressive download and real-time streaming of stored movie files, QuickTime supports <strong>broadcasting,</strong> the creation of one or more real-time streams from real-time sources, such as  cameras or microphones. This involves capturing the incoming data, compressing it to the desired bandwidth, and generating streams of outgoing packets, all in real time. The QuickTime broadcast API is currently available for the Mac OS only; it is not available for Windows or Java.</p>
<a name="//apple_ref/doc/uid/TP30000992-CH1g-StreamingVersusProgressiveDownload" title="Streaming Versus Progressive Download"></a>
<h3>Streaming Versus Progressive Download</h3>
<p>There are trade-offs to consider when deciding whether to deliver a movie using progressive download, streaming, or broadcasting.</p>
<p>All QuickTime media types can be delivered as progressive downloads. Streaming is limited to sound, video, and text. Broadcasting is further limited to compression schemes and quality settings compatible with real-time capture and compression.</p>
<p>Progressive download works even when the bandwidth is not sufficient for real-time playback; it simply buffers incoming data and delivers delayed playback. Streaming and broadcasting are bandwidth limited; if the connection is not fast enough, the movie cannot play.</p>
<p>Streaming movies do not store a copy of the movie on the client computer, making them inherently more difficult to copy without the consent of the movie’s owner. This can be an important consideration, and is one reason why people choose streaming over progressive download.</p>
<p>Streams take up a specified amount of bandwidth, whereas HTTP file downloads proceed as quickly as the connection allows. It is therefore easier to manage the bandwidth usage of a streaming server than of a web server delivering progressive-download movies.</p>
<p>Broadcasting allows you to deliver coverage of live events as they happen, or to provide real time “chat” between computers.</p>
<p>To sum up, if your movie includes live coverage, you must use broadcasting. If bandwidth management and copy discouragement are paramount considerations, streaming may be your best choice for stored content. If simplicity, reliability, or quality regardless of connection speed are most important to you, progressive download is probably best.</p>

<a name="//apple_ref/doc/uid/TP30000992-CH1g-CombinedMoviesandReferenceMovies" title="Combined Movies and Reference Movies"></a>
<h3>Combined Movies and Reference Movies</h3>
<p>It is possible to combine progressive download media with streaming or broadcast media in a single QuickTime movie, providing the best features of each delivery method. This is done by creating a self-contained QuickTime movie for progressive download, then adding tracks whose data references specify the RTSP URL of a live broadcast or a hinted movie on a streaming server.</p>
<p>A QuickTime movie with a custom media skin and wired sprites can act as a customized movie player application that plays streaming media from a predefined source. This is a relatively common application for promoting music and music videos.</p>
<p>A QuickTime movie file may not always contain a movie data structure, at least not directly. It may contain a reference, such as a path and filename, or a URL, specifying another movie file. It can also contain references to several movie files, with specified criteria for choosing a particular file. These kinds of movies are called <strong>reference</strong> <strong>movies.</strong> For example, you can create a reference movie with three URLs, pointing to three versions of the same movie compressed at different bit rates, and specifying the preferred connection speed for each version.</p>
<p>A reference movie can refer to Fast Start movies, stored streaming movies, or live streams, so a reference movie can be used to improve the user experience with any kind of Internet delivery: broadcast, streaming, or progressive download.</p>


<a name="//apple_ref/doc/uid/TP30000992-CH1g-QuickTimeRoadMap" title="QuickTime Road Map"></a>
<h2>QuickTime Road Map</h2>
<p>QuickTime is a large API, with over 2000 functions and dozens of components. Fortunately, you normally need to use only a small part of the QuickTime API to accomplish a given task.</p>
<p>The trick is to know what part of QuickTime to use for your purpose, and to find the documentation and sample code that can guide you. That’s what this roadmap is for.</p>
<p>QuickTime usually provides multiple ways to do the same thing: an easy way where most things are done for you, and a set of increasingly lower-level toolsets for doing it yourself. If you find that you’re immersed in something complicated and frustrating, when it ought to be simple, there’s a good chance that you’re using the wrong toolset. Come back to the roadmap and look for a higher-level approach.</p>
<a name="//apple_ref/doc/uid/TP30000992-CH1g-MainAreasofInterest" title="Main Areas of Interest"></a>
<h3>Main Areas of Interest</h3>
<p>The QuickTime API documentation is divided into 17 main areas, listed and linked below.</p>
<ul class="spaceabove">
<li class="li"><p><em><a href="../../../../../../referencelibrary/GettingStarted/GS_QuickTime/index.html#//apple_ref/doc/uid/TP30001099" target="_top">Getting Started with QuickTime</a></em>—Getting oriented, finding the sdks, suggested reading</p></li>
<li class="li"><p><span class="content_text"><a href="http://developer.apple.com/referencelibrary/API_Fundamentals/QuickTime-fund-date.html" target="_top">Fundamentals</a></span>— QuickTime overview, quick-start tutorial,  component manager, initializing QuickTime, opening and playing movies</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../QuickTimeforWindows-date.html#//apple_ref/doc/uid/TP30000433-TP30000563" target="_top">QuickTime for Windows</a></span>—Aspects of QuickTime that are different in Windows</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../Scripting-date.html#//apple_ref/doc/uid/TP30000433-TP30000569" target="_top">Scripting</a></span>—Control Apple’s QuickTime applications (player, browser plug-in, ActiveX control) with high-level scripting languages such as JavaScript, Visual Basic, AppleScript, HTML, and SMIL.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../MovieBasics-date.html#//apple_ref/doc/uid/TP30000433-TP30000545" target="_top">Movie Basics</a></span>—Initialize QuickTime, open and play movies, edit and save movies, work with QuickTime data types, set up callbacks to your application.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../Streaming-date.html#//apple_ref/doc/uid/TP30000433-TP30000577" target="_top">Streaming</a></span>—Work with streaming media using real-time protocols, do live broadcasts, or write components for the streaming server.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../MovieInternals-date.html#//apple_ref/doc/uid/TP30000433-TP30000546" target="_top">Movie Internals</a></span>—Work with movies at the track, property, and component level; set time scales and layers; rotate, skew, scale, and transform visual tracks; work with clock components, track references and modifier tracks, previews and media access keys.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../MovieCreation-date.html#//apple_ref/doc/uid/TP30000433-TP30000501" target="_top">Movie Creation</a></span>—Capture or synthesize data and create your own movies; use the sequence grabber, media-specific sequence grabber channel components (such as text), and video digitizers.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../ImportExport-date.html#//apple_ref/doc/uid/TP30000433-TP30000523" target="_top">QuickTime Import and Export</a></span>—Bring existing media into  QuickTime from dozens of other formats, export movies, tracks, or images to various non-QuickTime formats and file types.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../CompressionDecompression-date.html#//apple_ref/doc/uid/TP30000433-TP30000498" target="_top">Compression and Decompression</a></span>—Set up and work directly with image and sound compressors and decompressors, data codecs, and image transcoders.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../VideoEffectsTransitions-date.html#//apple_ref/doc/uid/TP30000433-TP30000588" target="_top">Video Effects and Transitions</a></span>—Work with QuickTime filters, wipe and fade transitions, and other effects.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../MediaTypesMediaHandlers-date.html#//apple_ref/doc/uid/TP30000433-TP30000543" target="_top">Media Types and Media Handlers</a></span>—Work directly with media handlers for video, sound, text, timecode, and more, including tween components.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../WiredMoviesandSprites-date.html#//apple_ref/doc/uid/TP30000433-TP30000594" target="_top">Wired Movies and Sprites</a></span>—Animate sprites programmatically, add interactive controls and wired actions to movies, make movies that interact with remote servers.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../VirtualReality-date.html#//apple_ref/doc/uid/TP30000433-TP30000589" target="_top">Virtual Reality</a></span>—Work with QuickTime VR panoramas and cubes, set up hotspots, control cursors, add interactive features.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../MusicAudio-date.html#//apple_ref/doc/uid/TP30000433-TP30000452" target="_top">Music and Audio</a></span>—Work with digital sound at a low level, or use the QuickTime Music Architecture to synthesize music.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../TransportDelivery-date.html#//apple_ref/doc/uid/TP30000433-TP30000580" target="_top">Transport and Delivery</a></span>—Use data handler components and video output components to get movies and media from special data sources  (such as databases) or to send video to output devices other than screens.</p></li>
<li class="li"><p><span class="content_text"><a href="../../../../QuickTimeComponentCreation-date.html#//apple_ref/doc/uid/TP30000433-TP30000595" target="_top">Writing Components</a></span>—Extend QuickTime by writing your own components for new media types, compression schemes, data sources, output devices, clock sources, and more.</p></li>
</ul>
<p>The main <span class="content_text"><a href="../../../../index.html#//apple_ref/doc/uid/TP30000433" target="_top">QuickTime documentation page</a></span> contains links to all these areas. Clicking a link brings up a list of documents in that area; you can sort the documents by date, title, or topic. The areas are listed alphabetically.</p>





        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../QTOverview_AIntro/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../QTOverview_RevHistory/revisionhistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2005 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2005-08-11<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/QuickTime/RM/Fundamentals/QTOverview/QTOverview_Document/QuickTimeOverview.html%3Fid%3DTP30000992-3.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/QuickTime/RM/Fundamentals/QTOverview/QTOverview_Document/QuickTimeOverview.html%3Fid%3DTP30000992-3.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/QuickTime/RM/Fundamentals/QTOverview/QTOverview_Document/QuickTimeOverview.html%3Fid%3DTP30000992-3.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>