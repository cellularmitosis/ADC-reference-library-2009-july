<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>WiredSprites - /Application Files/WiredSpriteUtilities.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxWiredMoviesandSprites-date.html">Wired Movies and Sprites</a> &gt; <A HREF="javascript:location.replace('index.html');">WiredSprites</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">WiredSprites</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Application Files/WiredSpriteUtilities.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Application Files/ComApplication.c</option>
<option value="listing2.html">/Application Files/ComApplication.h</option>
<option value="listing3.html">/Application Files/ComResource.h</option>
<option value="listing4.html">/Application Files/QTWiredSprites.r</option>
<option value="listing5.html">/Application Files/WiredSpriteUtilities.c</option>
<option value="listing6.html">/Application Files/WiredSpriteUtilities.h</option>
<option value="listing7.html">/Clippings/AddMovieResource.txt</option>
<option value="listing8.html">/Clippings/AddOverrideSamples.txt</option>
<option value="listing9.html">/Clippings/AddSpriteActions.txt</option>
<option value="listing10.html">/Clippings/AddSpriteSampleToMedia.txt</option>
<option value="listing11.html">/Clippings/AssignImageGroupIDs.txt</option>
<option value="listing12.html">/Clippings/CreateKeyFrameSample.txt</option>
<option value="listing13.html">/Clippings/CreateMovieFile.txt</option>
<option value="listing14.html">/Clippings/InsertMediaIntoTrack.txt</option>
<option value="listing15.html">/Clippings/SetSpriteProperties.txt</option>
<option value="listing16.html">/Clippings/SpriteTrackProperties.txt</option>
<option value="listing17.html">/Common Files/ComFramework.c</option>
<option value="listing18.html">/Common Files/ComFramework.h</option>
<option value="listing19.html">/Common Files/EndianUtilities.c</option>
<option value="listing20.html">/Common Files/EndianUtilities.h</option>
<option value="listing21.html">/Common Files/ImageCompressionUtilities.c</option>
<option value="listing22.html">/Common Files/ImageCompressionUtilities.h</option>
<option value="listing23.html">/Common Files/MacFramework.c</option>
<option value="listing24.html">/Common Files/MacFramework.h</option>
<option value="listing25.html">/Common Files/MacPrefix.h</option>
<option value="listing26.html">/Common Files/QTUtilities.c</option>
<option value="listing27.html">/Common Files/QTUtilities.h</option>
<option value="listing28.html">/Common Files/SpriteUtilities.c</option>
<option value="listing29.html">/Common Files/SpriteUtilities.h</option>
<option value="listing30.html">/Common Files/WinFramework.c</option>
<option value="listing31.html">/Common Files/WinFramework.h</option>
<option value="listing32.html">/Common Files/WinPrefix.h</option>
<option value="listing33.html">/Completed Lab/QTWiredSprites.c</option>
<option value="listing34.html">/Completed Lab/QTWiredSprites.h</option>
<option value="listing35.html">/Start Code/QTWiredSprites.c</option>
<option value="listing36.html">/Start Code/QTWiredSprites.h</option></select>
				</p>
				</form>
				<p><strong><a href="WiredSprites.zip">Download Sample</a></strong> (&#147;WiredSprites.zip&#148;, 1.43M)<BR>
<strong><a href="WiredSprites.dmg">Download Sample</a></strong> (&#147;WiredSprites.dmg&#148;, 1.96M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//////////////  File:    WiredSpriteUtilities.c////  Contains:  Utilities for creating wired sprite media.////  Written by:  Sean Allen//  Revised by:  Chris Flick and Tim Monroe////  Copyright:  &copy; 1998 by Apple Computer, Inc., all rights reserved.////  Change History (most recent first)://     &lt;4&gt;      02/21/03    era     kActionTrackSetClip takes a *RgnHandle as its parameter, not a RgnHandle (radar #3115855)//     &lt;3&gt;     03/29/98  rtm    added Endian macros to flags parameter in AddActionParameterOptions//     &lt;2&gt;     03/??/98  cf    added Endian macros//     &lt;1&gt;     12/??/97  sa    first file////  NOTES:////  ***(1)***//  You need to pay attention to the endian-ness of the data you pass to these routines. Wired sprite//  media data is stored in QuickTime atoms and atom containers and must therefore be big-endian. We've//  tried to conform to this rule: if the data to be written to a wired sprite media is 4 bytes or less,//  then we will perform the endian swap for you. There are several exceptions to this rule; for instance,//  we swap the data in any matrices you pass to the AddSpriteSetMatrixAction function. But we do not swap//  the data in any matrices passed to AddActionParameterOptions (since we don't know that they are matrices!).//  Let the caller beware!////////////#ifndef _WIREDSPRITEUTILITIES_#include &quot;WiredSpriteUtilities.h&quot;#endif#ifndef __ENDIANUTILITIES__#include &quot;EndianUtilities.h&quot;#endif/*These atoms are at same level as sprite property atoms[(SpriteActionAtoms)] =   kQTEventType, theQTEventType, (1 .. numEventTypes)      [(ActionListAtoms)]This atom is at same level as kSpriteAtomType atoms&lt;kQTEventFrameLoaded&gt;, 1, 1  [(ActionListAtoms)]    [(ActionListAtoms)] =   kAction, (anyUniqueIDs), (1..numActions)    kWhichAction  1, 1      [long whichActionConstant]    &lt;kActionParameter&gt;  (anyUniqueIDs), (1..numParameters)      [parameter data depending on actionConstant and paramIndex]    &lt;kActionFlags&gt;  parameterID,  (1..numParamsWithFlags)      [long actionFlags]    &lt;kActionParameterMinValue&gt;  parameterID,  (1.. numParamsWithMin)      [data depends on param type]    &lt;kActionParameterMaxValue&gt;  parameterID,  (1.. numParamsWithMax)      [data depends on param type]    [(ActionTargetAtoms)][(ActionTargetAtoms)] =  &lt;kActionTarget&gt;    &lt;kTargetMovie&gt;      [no data]    &lt;kTargetTrackName&gt;      [PString trackName]    &lt;kTargetTrackType&gt;      [OSType trackType]    &lt;kTargetTrackIndex&gt;      [long trackIndex]      OR      [(kExpressionAtoms)]    &lt;kTargetTrackID&gt;      [long trackID]      OR      [(kExpressionAtoms)]    &lt;kTargetSpriteName&gt;      [PString spriteName]    &lt;kTargetSpriteIndex&gt;      [short spriteIndex]      OR      [(kExpressionAtoms)]    &lt;kTargetSpriteID&gt;      [QTAtomID spriteIID]      OR      [(kExpressionAtoms)]Both [(CaseStatementActionAtoms)] and [(WhileStatementActionAtoms)]are child atoms of a kActionParameter 1, 1 atom[(CaseStatementActionAtoms)] =  kConditionalAtomType, (anyUniqueIDs), (1..numCases)    [(kExpressionAtoms)]    kActionListAtomType 1, 1      [(ActionListAtoms)]      // may contain nested conditional actions  [(WhileStatementActionAtoms)] =  kConditionalAtomType, 1, 1    [(kExpressionAtoms)]    kActionListAtomType 1, 1      [(ActionListAtoms)]        // may contain nested conditional actions[(kExpressionAtoms)] =  kExpressionContainerAtomType, 1, 1    &lt;kOperatorAtomType, theOperatorType, 1&gt;      kOperandAtomType, (anyUniqueIDs), (1..numOperands)        [(OperandAtoms)]    OR    &lt;kOperandAtomType, 1, 1&gt;      [(OperandAtoms)][(OperandAtoms)] =   &lt;kExpressionOperandAtomType&gt; 1, 1    [(kExpressionAtoms)]          // allows for recursion  OR  &lt;kConstantOperandAtomType&gt; 1, 1    [ float theConstant ]  OR  &lt;kSpriteVariableOperandAtomType&gt; 1, 1    [(ActionTargetAtoms)]    kActionParameter, 1, 1      [QTAtomID spriteVariableID]  OR  &lt;kOperandKeyIsDown&gt; 1, 1    [(ActionTargetAtoms)]    kActionParameter, 1, 1      [UInt16 modifierKeys]    kActionParameter, 2, 2      [UInt8 asciiCharCode]  OR      &lt;any other operand atom type&gt;    [(ActionTargetAtoms)]*/// exception handling macros#define    FailIf(a, e)     {if (a)   { err = e; goto bail; }}#define    FailOSErr(a)     {if (err = a)   goto bail;}#define    FailMemErr(a)    {a; if (err = MemError()) goto bail;}// for the kQTEventFrameLoaded event, the actionAtoms atom should be a sibling of a kSpriteAtomTypeOSErr AddQTEventAtom( QTAtomContainer container, QTAtom actionAtoms, QTAtomID theQTEventType, QTAtom *newQTEventAtom ){  OSErr  err = noErr;    if ( (! container) || (theQTEventType == 0) || (newQTEventAtom == nil) )  { err = paramErr; goto bail; }    if ( theQTEventType == kQTEventFrameLoaded ) {    FailOSErr( QTInsertChild( container, actionAtoms, kQTEventFrameLoaded, 1, 1, 0, nil, newQTEventAtom ) );  }  else {    *newQTEventAtom =  QTFindChildByID( container, actionAtoms, kQTEventType, theQTEventType, nil );    if ( ! *newQTEventAtom ) {      FailOSErr( QTInsertChild( container, actionAtoms, kQTEventType, theQTEventType, 1, 0, nil, newQTEventAtom ) );    }  }  bail:  return err;}OSErr AddActionAtom( QTAtomContainer container, QTAtom eventAtom, long whichActionConstant, QTAtom *newActionAtom ){  OSErr  err = noErr;  QTAtom  actionAtom;    if ( (! container) || (whichActionConstant == 0) )  { return paramErr; }    FailOSErr( QTInsertChild( container, eventAtom, kAction, 0, 0, 0, nil, &amp;actionAtom ) );  whichActionConstant = EndianU32_NtoB(whichActionConstant);  FailOSErr( QTInsertChild( container, actionAtom, kWhichAction, 1, 1, sizeof(whichActionConstant), &amp;whichActionConstant, nil ) );  bail:  if ( newActionAtom ) {    if ( err )        *newActionAtom = 0;    else      *newActionAtom = actionAtom;  }  return err;}OSErr AddActionParameterAtom( QTAtomContainer container, QTAtom actionAtom, long parameterIndex, long paramDataSize, void *paramData, QTAtom *newParamAtom ){  return QTInsertChild( container, actionAtom, kActionParameter, 0, (short)parameterIndex, paramDataSize, paramData, newParamAtom );}OSErr AddActionParameterOptions( QTAtomContainer container, QTAtom actionAtom, QTAtomID paramID, long flags, long minValueSize,              void *minValue, long maxValueSize, void *maxValue ){  OSErr  err = noErr;  flags = EndianU32_NtoB(flags);  FailOSErr( QTInsertChild( container, actionAtom, kActionFlags, paramID, 0, sizeof(flags), &amp;flags, nil ) );  if ( minValue ) {    FailOSErr( QTInsertChild( container, actionAtom, kActionParameterMinValue, paramID, 0, minValueSize, minValue, nil ) );  }  if ( maxValue ) {    FailOSErr( QTInsertChild( container, actionAtom, kActionParameterMaxValue, paramID, 0, maxValueSize, maxValue, nil ) );  }bail:  return err;}OSErr AddTrackNameActionTargetAtom( QTAtomContainer container, QTAtom actionAtom, Str255 trackName, QTAtom *newTargetAtom ){  OSErr  err = noErr;  QTAtom  targetAtom;    if ( newTargetAtom )  *newTargetAtom = 0;    if ( ! (targetAtom = QTFindChildByIndex( container, actionAtom, kActionTarget, 1, nil )) )    FailOSErr( QTInsertChild( container, actionAtom, kActionTarget, 1, 1, 0, nil, &amp;targetAtom ) );  FailOSErr( QTInsertChild( container, targetAtom, kTargetTrackName, 1, 1, trackName[0] + 1, trackName, nil ) );bail:  if ( newTargetAtom )  *newTargetAtom = targetAtom;  return err;}OSErr AddTrackIDActionTargetAtom( QTAtomContainer container, QTAtom actionAtom, long trackID, QTAtom *newTargetAtom ){  OSErr  err = noErr;  QTAtom  targetAtom;    if ( newTargetAtom )  *newTargetAtom = 0;    if ( ! (targetAtom = QTFindChildByIndex( container, actionAtom, kActionTarget, 1, nil )) )    FailOSErr( QTInsertChild( container, actionAtom, kActionTarget, 1, 1, 0, nil, &amp;targetAtom ) );      trackID = EndianU32_NtoB(trackID);  FailOSErr( QTInsertChild( container, targetAtom, kTargetTrackID, 1, 1, sizeof(trackID), &amp;trackID, nil ) );bail:  if ( newTargetAtom )  *newTargetAtom = targetAtom;  return err;}OSErr AddTrackTypeActionTargetAtom( QTAtomContainer container, QTAtom actionAtom, OSType trackType, QTAtom *newTargetAtom ){  OSErr  err = noErr;  QTAtom  targetAtom;    if ( newTargetAtom )  *newTargetAtom = 0;    if ( ! (targetAtom = QTFindChildByIndex( container, actionAtom, kActionTarget, 1, nil )) )    FailOSErr( QTInsertChild( container, actionAtom, kActionTarget, 1, 1, 0, nil, &amp;targetAtom ) );      trackType = EndianU32_NtoB(trackType);  FailOSErr( QTInsertChild( container, targetAtom, kTargetTrackType, 1, 1, sizeof(trackType), &amp;trackType, nil ) );bail:  if ( newTargetAtom )  *newTargetAtom = targetAtom;  return err;}OSErr AddTrackIndexActionTargetAtom( QTAtomContainer container, QTAtom actionAtom, long trackIndex, QTAtom *newTargetAtom ){  OSErr  err = noErr;  QTAtom  targetAtom;    if ( newTargetAtom )  *newTargetAtom = 0;    if ( ! (targetAtom = QTFindChildByIndex( container, actionAtom, kActionTarget, 1, nil )) )    FailOSErr( QTInsertChild( container, actionAtom, kActionTarget, 1, 1, 0, nil, &amp;targetAtom ) );  trackIndex = EndianU32_NtoB(trackIndex);  FailOSErr( QTInsertChild( container, targetAtom, kTargetTrackIndex, 1, 1, sizeof(trackIndex), &amp;trackIndex, nil ) );bail:  if ( newTargetAtom )  *newTargetAtom = targetAtom;  return err;}OSErr AddSpriteNameActionTargetAtom( QTAtomContainer container, QTAtom actionAtom, Str255 spriteName, QTAtom *newTargetAtom ){  OSErr  err = noErr;  QTAtom  targetAtom;    if ( newTargetAtom )  *newTargetAtom = 0;    if ( ! (targetAtom = QTFindChildByIndex( container, actionAtom, kActionTarget, 1, nil )) )    FailOSErr( QTInsertChild( container, actionAtom, kActionTarget, 1, 1, 0, nil, &amp;targetAtom ) );  FailOSErr( QTInsertChild( container, targetAtom, kTargetSpriteName, 1, 1, spriteName[0] + 1, spriteName, nil ) );bail:  if ( newTargetAtom )  *newTargetAtom = targetAtom;  return err;}OSErr AddSpriteIDActionTargetAtom( QTAtomContainer container, QTAtom actionAtom, QTAtomID spriteID, QTAtom *newTargetAtom ){  OSErr  err = noErr;  QTAtom  targetAtom;    if ( newTargetAtom )  *newTargetAtom = 0;    if ( ! (targetAtom = QTFindChildByIndex( container, actionAtom, kActionTarget, 1, nil )) )    FailOSErr( QTInsertChild( container, actionAtom, kActionTarget, 1, 1, 0, nil, &amp;targetAtom ) );  spriteID = EndianU32_NtoB(spriteID);  FailOSErr( QTInsertChild( container, targetAtom, kTargetSpriteID, 1, 1, sizeof(spriteID), &amp;spriteID, nil ) );bail:  if ( newTargetAtom )  *newTargetAtom = targetAtom;  return err;}OSErr AddSpriteIndexActionTargetAtom( QTAtomContainer container, QTAtom actionAtom, short spriteIndex, QTAtom *newTargetAtom ){  OSErr  err = noErr;  QTAtom  targetAtom;    if ( newTargetAtom )  *newTargetAtom = 0;    if ( ! (targetAtom = QTFindChildByIndex( container, actionAtom, kActionTarget, 1, nil )) )    FailOSErr( QTInsertChild( container, actionAtom, kActionTarget, 1, 1, 0, nil, &amp;targetAtom ) );  spriteIndex = EndianU16_NtoB(spriteIndex);  FailOSErr( QTInsertChild( container, targetAtom, kTargetSpriteIndex, 1, 1, sizeof(spriteIndex), &amp;spriteIndex, nil ) );bail:  if ( newTargetAtom )  *newTargetAtom = targetAtom;  return err;}//______ High level WiredSprite Utilities _____OSErr AddQTEventAndActionAtoms( QTAtomContainer container, QTAtom atom, long whichEvent, long whichAction, QTAtom *actionAtom ){  OSErr  err = noErr;  QTAtom  eventAtom;    eventAtom = atom;    if ( whichEvent != 0 )    FailOSErr( AddQTEventAtom( container, atom, whichEvent, &amp;eventAtom ) );    FailOSErr( AddActionAtom( container, eventAtom, whichAction, actionAtom ) );bail:  return err;}// trackTypeIndex only used if trackTargetType is kTargetTrackType, can be zero for default index of 1OSErr AddTrackTargetAtom( QTAtomContainer container, QTAtom actionAtom, long trackTargetType, void *trackTarget, long trackTypeIndex ){  OSErr  err = noErr;    // allow zero for default target, the sprite track which received the event  if ( trackTargetType ) {    switch ( trackTargetType ) {      case kTargetTrackName: {          StringPtr trackName = trackTarget;          FailOSErr( AddTrackNameActionTargetAtom( container, actionAtom, trackName, nil ) );        }        break;              case kTargetTrackID: {          long trackID = (long)trackTarget;          FailOSErr( AddTrackIDActionTargetAtom( container, actionAtom, trackID, nil ) );        }        break;      case kTargetTrackType: {          OSType trackType = (long)trackTarget;          FailOSErr( AddTrackTypeActionTargetAtom( container, actionAtom, trackType, nil ) );          if ( trackTypeIndex )            FailOSErr( AddTrackIndexActionTargetAtom( container, actionAtom, trackTypeIndex, nil ) );        }        break;                  case kTargetTrackIndex: {          long trackIndex = (long)trackTarget;          FailOSErr( AddTrackIndexActionTargetAtom( container, actionAtom, trackIndex, nil ) );        }        break;                  default:        err = paramErr;     }  }  bail:  return err;}OSErr AddSpriteTargetAtom( QTAtomContainer container, QTAtom actionAtom, long spriteTargetType, void *spriteTarget ){  OSErr  err = noErr;    // allow zero for default target, the sprite which received the event  if ( spriteTargetType ) {    switch ( spriteTargetType ) {      case kTargetSpriteName: {          StringPtr spriteName = spriteTarget;          FailOSErr( AddSpriteNameActionTargetAtom( container, actionAtom, spriteName, nil ) );        }        break;              case kTargetSpriteID: {          QTAtomID spriteID = (QTAtomID)spriteTarget;          FailOSErr( AddSpriteIDActionTargetAtom( container, actionAtom, spriteID, nil ) );        }        break;      case kTargetSpriteIndex: {          short spriteIndex = (short)spriteTarget;          FailOSErr( AddSpriteIndexActionTargetAtom( container, actionAtom, spriteIndex, nil ) );        }        break;                  default:        err = paramErr;     }  }bail:  return err;}OSErr AddTrackAndSpriteTargetAtoms( QTAtomContainer container, QTAtom actionAtom, long trackTargetType, void *trackTarget, long trackTypeIndex,                     long spriteTargetType, void *spriteTarget ){  OSErr  err = noErr;    FailOSErr( AddTrackTargetAtom( container, actionAtom, trackTargetType, trackTarget, trackTypeIndex ) );    FailOSErr( AddSpriteTargetAtom( container, actionAtom, spriteTargetType, spriteTarget ) );  bail:  return err;}OSErr AddMovieSetVolumeAction( QTAtomContainer container, QTAtom atom, long whichEvent, short volume ){    OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMovieSetVolume, &amp;actionAtom ) );  volume = EndianS16_NtoB(volume);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(volume), &amp;volume, nil ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddMovieSetRateAction( QTAtomContainer container, QTAtom atom, long whichEvent, Fixed rate ){    OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMovieSetRate, &amp;actionAtom ) );  rate = EndianS32_NtoB(rate);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(rate), &amp;rate, nil ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddMovieSetLoopingFlagsAction( QTAtomContainer container, QTAtom atom, long whichEvent, long loopingFlags ){    OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMovieSetLoopingFlags, &amp;actionAtom ) );  loopingFlags = EndianU32_NtoB(loopingFlags);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(loopingFlags), &amp;loopingFlags, nil ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddMovieGoToTimeAction( QTAtomContainer container, QTAtom atom, long whichEvent, TimeValue time ){    OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMovieGoToTime, &amp;actionAtom ) );  time = EndianS32_NtoB(time);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(time), &amp;time, nil ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddMovieGoToTimeByNameAction( QTAtomContainer container, QTAtom atom, long whichEvent, Str255 timeName ){    OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMovieGoToTimeByName, &amp;actionAtom ) );  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, timeName[0] + 1, timeName, nil ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddMovieGoToBeginningAction( QTAtomContainer container, QTAtom atom, long whichEvent ){    OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMovieGoToBeginning, &amp;actionAtom ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddMovieGoToEndAction( QTAtomContainer container, QTAtom atom, long whichEvent ){    OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMovieGoToEnd, &amp;actionAtom ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddMovieStepForwardAction( QTAtomContainer container, QTAtom atom, long whichEvent ){    OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMovieStepForward, &amp;actionAtom ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddMovieStepBackwardAction( QTAtomContainer container, QTAtom atom, long whichEvent ){    OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMovieStepBackward, &amp;actionAtom ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddMovieSetSelectionAction( QTAtomContainer container, QTAtom atom, long whichEvent, TimeValue startTime, TimeValue endTime ){    OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMovieSetSelection, &amp;actionAtom ) );  startTime = EndianS32_NtoB(startTime);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(startTime), &amp;startTime, nil ) );  endTime = EndianS32_NtoB(endTime);  FailOSErr( AddActionParameterAtom( container, actionAtom, kSecondParam, sizeof(endTime), &amp;endTime, nil ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddMovieSetSelectionByNameAction( QTAtomContainer container, QTAtom atom, long whichEvent, Str255 startTimeName, Str255 endTimeName ){    OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMovieSetSelectionByName, &amp;actionAtom ) );  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, startTimeName[0] + 1, startTimeName, nil ) );  FailOSErr( AddActionParameterAtom( container, actionAtom, kSecondParam, endTimeName[0] + 1, endTimeName, nil ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddMoviePlaySelectionAction( QTAtomContainer container, QTAtom atom, long whichEvent, Boolean selectionOnly ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMoviePlaySelection, &amp;actionAtom ) );  // Booleans don't need endian flipping  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(selectionOnly), &amp;selectionOnly, nil ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddMovieSetLanguage( QTAtomContainer container, QTAtom atom, long whichEvent, long language ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMovieSetLanguage, &amp;actionAtom ) );  language = EndianS32_NtoB(language);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(language), &amp;language, nil ) );  // the movie is the default target for movie actions  bail:  return err;}OSErr AddTrackSetVolumeAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                  void *trackTarget, long trackTypeIndex, short volume ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionTrackSetVolume, &amp;actionAtom ) );  volume = EndianS16_NtoB(volume);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(volume), &amp;volume, nil ) );  FailOSErr( AddTrackTargetAtom( container, actionAtom, trackTargetType, trackTarget, trackTypeIndex ) );  bail:  return err;}OSErr AddTrackSetBalanceAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                 void *trackTarget, long trackTypeIndex, short balance ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionTrackSetBalance, &amp;actionAtom ) );  balance = EndianS16_NtoB(balance);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(balance), &amp;balance, nil ) );  FailOSErr( AddTrackTargetAtom( container, actionAtom, trackTargetType, trackTarget, trackTypeIndex ) );  bail:  return err;}OSErr AddTrackSetEnabledAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                 void *trackTarget, long trackTypeIndex, Boolean enabled ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionTrackSetEnabled, &amp;actionAtom ) );  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(enabled), &amp;enabled, nil ) );  FailOSErr( AddTrackTargetAtom( container, actionAtom, trackTargetType, trackTarget, trackTypeIndex ) );  bail:  return err;}OSErr AddTrackSetMatrixAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                  void *trackTarget, long trackTypeIndex, MatrixRecordPtr matrix, QTAtom *actionAtom ){  OSErr      err = noErr;  QTAtom      theActionAtom = 0;  MatrixRecord  bigEndianMatrix;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionTrackSetMatrix, &amp;theActionAtom ) );  bigEndianMatrix = *matrix;  EndianUtils_MatrixRecord_NtoB( &amp;bigEndianMatrix );  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFirstParam, sizeof(MatrixRecord), &amp;bigEndianMatrix, nil ) );  FailOSErr( AddTrackTargetAtom( container, theActionAtom, trackTargetType, trackTarget, trackTypeIndex ) );    if ( actionAtom )    *actionAtom = theActionAtom;bail:  return err;}OSErr AddTrackSetLayerAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                 void *trackTarget, long trackTypeIndex, short layer ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionTrackSetLayer, &amp;actionAtom ) );  layer = EndianS16_NtoB(layer);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(layer), &amp;layer, nil ) );  FailOSErr( AddTrackTargetAtom( container, actionAtom, trackTargetType, trackTarget, trackTypeIndex ) );  bail:  return err;}OSErr AddTrackSetClipAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                void *trackTarget, long trackTypeIndex, RgnHandle clip ){  OSErr      err = noErr;  QTAtom      actionAtom;#if TARGET_RT_LITTLE_ENDIAN  RgnHandle    bigEndianClip = nil;#else  SignedByte    saveState;#endif    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionTrackSetClip, &amp;actionAtom ) );  // clip is native-endian but it needs to be big endian to be stored in the data atom container.  // We need a routine to flip it.#if TARGET_RT_LITTLE_ENDIAN  // For little endian platforms, we copy the clip into a temporary region handle and then flip that region  bigEndianClip = (RgnHandle)NewHandle(0);  if( err = MemError() ) goto bail;    err = HandAndHand( (Handle)clip, (Handle)bigEndianClip );  if( err ) goto bail;    EndianUtils_RgnHandle_NtoB( bigEndianClip );  HLockHi((Handle) bigEndianClip );  // Lock the handle down so that it doesn't move during addition to container QTAtomContainer. We                    // don't unlock since we dispose of it at bottom of this function.  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, GetHandleSize((Handle)bigEndianClip), *bigEndianClip, nil ) );#else  // For big endian platforms, just add the clip    // Lock the handle down so that it doesn't move during addition to container QTAtomContainer. Save state so that we  // can restore its &quot;lockedness&quot; when we're done.  saveState = HGetState((Handle) clip );  HLockHi((Handle) clip );      FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, GetHandleSize((Handle)clip), *(Handle)clip, nil ) );    HSetState((Handle) clip, saveState );  // Restore handle's &quot;lockedness&quot;#endif  FailOSErr( AddTrackTargetAtom( container, actionAtom, trackTargetType, trackTarget, trackTypeIndex ) );  bail:#if TARGET_RT_LITTLE_ENDIAN  if( bigEndianClip )  DisposeRgn( bigEndianClip );#endif    return err;}OSErr AddSpriteSetMatrixAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                  void *trackTarget, long trackTypeIndex, long spriteTargetType, void *spriteTarget,                   MatrixRecordPtr matrix, QTAtom *actionAtom ){  OSErr      err = noErr;  QTAtom      theActionAtom;  MatrixRecord  bigEndianMatrix;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionSpriteSetMatrix, &amp;theActionAtom ) );  bigEndianMatrix = *matrix;  EndianUtils_MatrixRecord_NtoB( &amp;bigEndianMatrix );  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFirstParam, sizeof(MatrixRecord), &amp;bigEndianMatrix, nil ) );  FailOSErr( AddTrackAndSpriteTargetAtoms( container, theActionAtom, trackTargetType, trackTarget, trackTypeIndex,                        spriteTargetType, spriteTarget ) );  if ( actionAtom )    *actionAtom = theActionAtom;                          bail:  return err;}OSErr AddSpriteSetImageIndexAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                    void *trackTarget, long trackTypeIndex, long spriteTargetType, void *spriteTarget,                     short setImageIndex, QTAtom *actionAtom ){  OSErr  err = noErr;  QTAtom  theActionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionSpriteSetImageIndex, &amp;theActionAtom ) );  setImageIndex = EndianS16_NtoB(setImageIndex);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFirstParam, sizeof(setImageIndex), &amp;setImageIndex, nil ) );  FailOSErr( AddTrackAndSpriteTargetAtoms( container, theActionAtom, trackTargetType, trackTarget, trackTypeIndex,                        spriteTargetType, spriteTarget ) );  if ( actionAtom )    *actionAtom = theActionAtom;                          bail:  return err;}OSErr AddSpriteSetVisibleAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                  void *trackTarget, long trackTypeIndex, long spriteTargetType, void *spriteTarget,                  short visible, QTAtom *actionAtom ){  OSErr  err = noErr;  QTAtom  theActionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionSpriteSetVisible, &amp;theActionAtom ) );  visible = EndianS16_NtoB(visible);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFirstParam, sizeof(visible), &amp;visible, nil ) );  FailOSErr( AddTrackAndSpriteTargetAtoms( container, theActionAtom, trackTargetType, trackTarget, trackTypeIndex,                        spriteTargetType, spriteTarget ) );  if ( actionAtom )    *actionAtom = theActionAtom;                       bail:  return err;}OSErr AddSpriteSetLayerAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                  void *trackTarget, long trackTypeIndex, long spriteTargetType, void *spriteTarget,                  short layer ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionSpriteSetLayer, &amp;actionAtom ) );  layer = EndianS16_NtoB(layer);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(layer), &amp;layer, nil ) );  FailOSErr( AddTrackAndSpriteTargetAtoms( container, actionAtom, trackTargetType, trackTarget, trackTypeIndex,                        spriteTargetType, spriteTarget ) );bail:  return err;}OSErr AddSpriteSetGraphicsModeAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                       void *trackTarget, long trackTypeIndex, long spriteTargetType, void *spriteTarget,                       ModifierTrackGraphicsModeRecord *graphicsMode, QTAtom *actionAtom ){  OSErr                err = noErr;  QTAtom                theActionAtom;  ModifierTrackGraphicsModeRecord    bigEndianGraphicsMode;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionSpriteSetGraphicsMode, &amp;theActionAtom ) );  bigEndianGraphicsMode         = *graphicsMode;  bigEndianGraphicsMode.graphicsMode  = EndianU32_NtoB(bigEndianGraphicsMode.graphicsMode);  bigEndianGraphicsMode.opColor.red   = EndianU16_NtoB(bigEndianGraphicsMode.opColor.red);  bigEndianGraphicsMode.opColor.green  = EndianU16_NtoB(bigEndianGraphicsMode.opColor.green);  bigEndianGraphicsMode.opColor.blue  = EndianU16_NtoB(bigEndianGraphicsMode.opColor.blue);    FailOSErr( AddActionParameterAtom( container, theActionAtom, kFirstParam, sizeof(ModifierTrackGraphicsModeRecord),                      &amp;bigEndianGraphicsMode, nil ) );  FailOSErr( AddTrackAndSpriteTargetAtoms( container, theActionAtom, trackTargetType, trackTarget, trackTypeIndex,                        spriteTargetType, spriteTarget ) );  if ( actionAtom )    *actionAtom = theActionAtom;bail:  return err;}OSErr AddSpriteTranslateAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                       void *trackTarget, long trackTypeIndex, long spriteTargetType, void *spriteTarget,                       Fixed x, Fixed y, Boolean isRelative, QTAtom *actionAtom ){  OSErr  err = noErr;  QTAtom  theActionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionSpriteTranslate, &amp;theActionAtom ) );  x = EndianS32_NtoB(x);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFirstParam, sizeof(x), &amp;x, nil ) );  y = EndianS32_NtoB(y);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kSecondParam, sizeof(y), &amp;y, nil ) );  FailOSErr( AddActionParameterAtom( container, theActionAtom, kThirdParam, sizeof(isRelative), &amp;isRelative, nil ) );  FailOSErr( AddTrackAndSpriteTargetAtoms( container, theActionAtom, trackTargetType, trackTarget, trackTypeIndex,                        spriteTargetType, spriteTarget ) );  if ( actionAtom )    *actionAtom = theActionAtom;bail:  return err;}// ****\xCAaboutX and aboutY are no longer parameters!!! Uses registration point now. Also, isRelative is gone.OSErr AddSpriteScaleAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,               void *trackTarget, long trackTypeIndex, long spriteTargetType, void *spriteTarget,               Fixed xScale, Fixed yScale, Fixed aboutX, Fixed aboutY, Boolean isRelative, QTAtom *actionAtom ){  OSErr  err = noErr;  QTAtom  theActionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionSpriteScale, &amp;theActionAtom ) );  xScale = EndianS32_NtoB(xScale);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFirstParam, sizeof(xScale), &amp;xScale, nil ) );  yScale = EndianS32_NtoB(yScale);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kSecondParam, sizeof(yScale), &amp;yScale, nil ) );  aboutX = EndianS32_NtoB(aboutX);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kThirdParam, sizeof(aboutX), &amp;aboutX, nil ) );  aboutY = EndianS32_NtoB(aboutY);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFourthParam, sizeof(aboutY), &amp;aboutY, nil ) );  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFifthParam, sizeof(isRelative), &amp;isRelative, nil ) );  FailOSErr( AddTrackAndSpriteTargetAtoms( container, theActionAtom, trackTargetType, trackTarget, trackTypeIndex,                        spriteTargetType, spriteTarget ) );  if ( actionAtom )    *actionAtom = theActionAtom;bail:  return err;}// ****\xCAaboutX and aboutY are no longer parameters!!! Uses registration point now. Also, isRelative is gone.OSErr AddSpriteRotateAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,               void *trackTarget, long trackTypeIndex, long spriteTargetType, void *spriteTarget,               Fixed degrees, Fixed aboutX, Fixed aboutY, Boolean isRelative, QTAtom *actionAtom ){  OSErr  err = noErr;  QTAtom  theActionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionSpriteRotate, &amp;theActionAtom ) );  degrees = EndianS32_NtoB(degrees);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFirstParam, sizeof(degrees), &amp;degrees, nil ) );  aboutX = EndianS32_NtoB(aboutX);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kSecondParam, sizeof(aboutX), &amp;aboutX, nil ) );  aboutY = EndianS32_NtoB(aboutY);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kThirdParam, sizeof(aboutY), &amp;aboutY, nil ) );  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFourthParam, sizeof(isRelative), &amp;isRelative, nil ) );  FailOSErr( AddTrackAndSpriteTargetAtoms( container, theActionAtom, trackTargetType, trackTarget, trackTypeIndex,                        spriteTargetType, spriteTarget ) );  if ( actionAtom )    *actionAtom = theActionAtom;bail:  return err;}// **** isRelative is gone?OSErr AddSpriteStretchAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,               void *trackTarget, long trackTypeIndex, long spriteTargetType, void *spriteTarget,               Fixed p1x, Fixed p1y, Fixed p2x, Fixed p2y, Fixed p3x, Fixed p3y, Fixed p4x, Fixed p4y,               Boolean isRelative, QTAtom *actionAtom ){  OSErr  err = noErr;  QTAtom  theActionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionSpriteStretch, &amp;theActionAtom ) );  p1x = EndianS32_NtoB(p1x);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFirstParam, sizeof(p1x), &amp;p1x, nil ) );  p1y = EndianS32_NtoB(p1y);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kSecondParam, sizeof(p1y), &amp;p1y, nil ) );  p2x = EndianS32_NtoB(p2x);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kThirdParam, sizeof(p2x), &amp;p2x, nil ) );  p2y = EndianS32_NtoB(p2y);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFourthParam, sizeof(p2y), &amp;p2y, nil ) );  p3x = EndianS32_NtoB(p3x);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kFifthParam, sizeof(p3x), &amp;p3x, nil ) );  p3y = EndianS32_NtoB(p3y);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kSixthParam, sizeof(p3y), &amp;p3y, nil ) );  p4x = EndianS32_NtoB(p4x);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kSeventhParam, sizeof(p4x), &amp;p4x, nil ) );  p4y = EndianS32_NtoB(p4y);  FailOSErr( AddActionParameterAtom( container, theActionAtom, kEighthParam, sizeof(p4y), &amp;p4y, nil ) );  FailOSErr( AddActionParameterAtom( container, theActionAtom, kNinthParam, sizeof(isRelative), &amp;isRelative, nil ) );  FailOSErr( AddTrackAndSpriteTargetAtoms( container, theActionAtom, trackTargetType, trackTarget, trackTypeIndex,                        spriteTargetType, spriteTarget ) );  if ( actionAtom )    *actionAtom = theActionAtom;bail:  return err;}OSErr AddMusicPlayNoteAction( QTAtomContainer container, QTAtom atom, long whichEvent, long trackTargetType,                   void *trackTarget, long trackTypeIndex, long sampleDescIndex, long partIndex,                  long pitch, long velocity, long duration ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionMusicPlayNote, &amp;actionAtom ) );  sampleDescIndex = EndianS32_NtoB(sampleDescIndex);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(sampleDescIndex), &amp;sampleDescIndex, nil ) );    partIndex = EndianS32_NtoB(partIndex);  FailOSErr( AddActionParameterAtom( container, actionAtom, kSecondParam, sizeof(partIndex), &amp;partIndex, nil ) );    pitch = EndianS32_NtoB(pitch);  FailOSErr( AddActionParameterAtom( container, actionAtom, kThirdParam, sizeof(pitch), &amp;pitch, nil ) );    velocity = EndianS32_NtoB(velocity);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFourthParam, sizeof(velocity), &amp;velocity, nil ) );    duration = EndianS32_NtoB(duration);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFifthParam, sizeof(duration), &amp;duration, nil ) );  FailOSErr( AddTrackTargetAtom( container, actionAtom, trackTargetType, trackTarget, trackTypeIndex ) );bail:  return err;}OSErr AddSpriteTrackSetVariableAction( QTAtomContainer container, QTAtom atom, long whichEvent, QTAtomID variableID, float value,                      long trackTargetType, void *trackTarget, long trackTypeIndex ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionSpriteTrackSetVariable, &amp;actionAtom ) );  variableID = EndianU32_NtoB(variableID);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(variableID), &amp;variableID, nil ) );//  value = EndianU32_NtoB(value);        // just flipping the 4 bytes  EndianUtils_Float_NtoB(&amp;value);    FailOSErr( AddActionParameterAtom( container, actionAtom, kSecondParam, sizeof(value), &amp;value, nil ) );  FailOSErr( AddTrackTargetAtom( container, actionAtom, trackTargetType, trackTarget, trackTypeIndex ) );bail:  return err;}                                 OSErr AddGoToURLAction( QTAtomContainer container, QTAtom atom, long whichEvent, Handle urlLink ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionGoToURL, &amp;actionAtom ) );  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, GetHandleSize(urlLink), *urlLink, nil ) );  // no target for system actionsbail:  return err;}OSErr AddSendQTEventAction( QTAtomContainer container, QTAtom atom, long whichEvent, QTEventRecordPtr theEvent,              long trackTargetType, void *trackTarget, long trackTypeIndex, long spriteTargetType, void *spriteTarget ){  OSErr  err = noErr;  QTAtom  actionAtom, paramAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionSendQTEventToSprite, &amp;actionAtom ) );  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, 0, nil, &amp;paramAtom ) );  // note that these target atoms are the first parameter to the kActionSendQTEvent action   FailOSErr( AddTrackAndSpriteTargetAtoms( container, paramAtom, trackTargetType, trackTarget, trackTypeIndex,                          spriteTargetType, spriteTarget ) );  FailOSErr( AddActionParameterAtom( container, actionAtom, kSecondParam, sizeof(*theEvent), theEvent, &amp;paramAtom ) );bail:  return err;}                                 OSErr AddDebugStrAction( QTAtomContainer container, QTAtom atom, long whichEvent, Str255 theString ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionDebugStr, &amp;actionAtom ) );  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, theString[0] + 1, theString, nil ) );  // no target for system actionsbail:  return err;}OSErr AddPushCurrentTimeAction( QTAtomContainer container, QTAtom atom, long whichEvent ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionPushCurrentTime, &amp;actionAtom ) );  // no target for system actionsbail:  return err;}      OSErr AddPushCurrentTimeWithLabelAction( QTAtomContainer container, QTAtom atom, long whichEvent, Str255 theLabel ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionPushCurrentTimeWithLabel, &amp;actionAtom ) );  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, theLabel[0] + 1, theLabel, nil ) );  // no target for system actionsbail:  return err;}        OSErr AddPopAndGotoTopTimeAction( QTAtomContainer container, QTAtom atom, long whichEvent ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionPopAndGotoTopTime, &amp;actionAtom ) );  // no target for system actionsbail:  return err;}OSErr AddPopAndGotoLabeledTimeAction( QTAtomContainer container, QTAtom atom, long whichEvent, Str255 theLabel ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionPopAndGotoLabeledTime, &amp;actionAtom ) );  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, theLabel[0] + 1, theLabel, nil ) );  // no target for system actionsbail:  return err;}OSErr AddApplicationNumberAndStringAction( QTAtomContainer container, QTAtom atom, long whichEvent, long theNumber, Str255 theString ){  OSErr  err = noErr;  QTAtom  actionAtom;    FailOSErr( AddQTEventAndActionAtoms( container, atom, whichEvent, kActionApplicationNumberAndString, &amp;actionAtom ) );  theNumber = EndianS32_NtoB(theNumber);  FailOSErr( AddActionParameterAtom( container, actionAtom, kFirstParam, sizeof(theNumber), &amp;theNumber, nil ) );  FailOSErr( AddActionParameterAtom( container, actionAtom, kSecondParam, theString[0] + 1, theString, nil ) );  // no target for system actionsbail:  return err;}                             // ________ Interpreted Actions __________OSErr AddOperandAtom( QTAtomContainer container, QTAtom operatorAtom, QTAtomType operandType, short operandIndex,            QTAtomContainer operandAtoms, float constantValue ){  OSErr   err = noErr;  QTAtom  operandAtom, operandTypeAtom;    FailOSErr( QTInsertChild( container, operatorAtom, kOperandAtomType, 0, operandIndex, 0, nil, &amp;operandAtom ) );    FailOSErr( QTInsertChild( container, operandAtom, operandType, 1, 1, 0, nil, &amp;operandTypeAtom ) );  if ( operandType == kOperandConstant ) {      EndianUtils_Float_NtoB(&amp;constantValue);  //  constantValue = EndianU32_NtoB(constantValue);    FailOSErr( QTSetAtomData( container, operandTypeAtom, sizeof( constantValue ), &amp;constantValue ) );  }  else {    FailOSErr( QTInsertChildren( container, operandTypeAtom, operandAtoms ) );  }  bail:  return err;}OSErr AddVariableOperandAtom( QTAtomContainer container, QTAtom operatorAtom, short operandIndex,                  long trackTargetType, void *trackTarget, long trackTypeIndex, QTAtomID variableID ){  OSErr   err = noErr;  QTAtom  operandAtom, operandTypeAtom;    FailOSErr( QTInsertChild( container, operatorAtom, kOperandAtomType, 0, operandIndex, 0, nil, &amp;operandAtom ) );    FailOSErr( QTInsertChild( container, operandAtom, kOperandSpriteTrackVariable, 1, 1, 0, nil, &amp;operandTypeAtom ) );  variableID = EndianU32_NtoB(variableID);  FailOSErr( QTInsertChild( container, operandTypeAtom, kActionParameter, 1, 1, sizeof(variableID), &amp;variableID, nil ) );  FailOSErr( AddTrackTargetAtom( container, operandTypeAtom, trackTargetType, trackTarget, trackTypeIndex ) );    bail:  return err;}OSErr AddOperatorAtom( QTAtomContainer container, QTAtom expressionAtom, QTAtomID theOperatorType, QTAtom *operatorAtom ){  return QTInsertChild( container, expressionAtom, kOperatorAtomType, theOperatorType, 1, 0, nil, operatorAtom );}OSErr AddExpressionContainerAtomType( QTAtomContainer container, QTAtom atom, QTAtom *expressionAtom ){  return QTInsertChild( container, atom, kExpressionContainerAtomType, 1, 1, 0, nil, expressionAtom );}OSErr AddConditionalAtom( QTAtomContainer container, QTAtom atom, short conditionIndex, QTAtom *conditionalAtom ){  return QTInsertChild( container, atom, kConditionalAtomType, 0, conditionIndex, 0, nil, conditionalAtom );}OSErr AddActionListAtom( QTAtomContainer container, QTAtom atom, QTAtom *actionListAtom ){  return QTInsertChild( container, atom, kActionListAtomType, 1, 1, 0, nil, actionListAtom );}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/WiredSprites/listing5.html%3Fid%3DDTS10001044-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/WiredSprites/listing5.html%3Fid%3DDTS10001044-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/WiredSprites/listing5.html%3Fid%3DDTS10001044-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>