<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>USB Device Interface Guide: Working With USB Device Interfaces</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Working With USB Device Interfaces"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002645" title="Working With USB Device Interfaces"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/USB-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30000583" target="_top">USB</a> &gt; <a href="../USBIntro/USBIntro.html#//apple_ref/doc/uid/TP40002643-TPXREF101">USB Device Interface Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../USBOverview/USBOverview.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../USBRevisionHistory/USBRevHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40002645-TPXREF101" title="Working With USB Device Interfaces"></a><h1>Working With USB Device Interfaces</h1><p>This chapter describes how to develop a user-space tool that finds and communicates with an attached USB device and one of its interfaces. The sample code in this chapter is taken from the USB Notification Example sample project, available in <code>/Developer/Examples/IOKit/usb</code> of the Developer version of Mac OS X.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002645-DontLinkElementID_8" title="Important:"></a><p><strong>Important:</strong>&nbsp;The sample code featured in this document is intended to illustrate how to access a USB device from an application. It is not intended to provide guidance on error handling and other features required for production-quality code.</p><p></p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIHCIHB">Using USB Device Interfaces</a>
				
			<br/>
			
        
			
			
				<a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIDDHCI">Accessing a USB Device</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002645-BBIHCIHB" title="Using USB Device Interfaces"></a><h2>Using USB Device Interfaces</h2><p>Applications running in Mac OS X get access to USB devices by using I/O Kit functions to acquire a device interface, a type of plug-in that specifies functions the application can call to communicate with the device. The USB family provides two types of device interface: </p><ul class="ul"><li class="li"><p><code>IOUSBDeviceInterface</code> for communicating with the device itself</p></li><li class="li"><p><code>IOUSBInterfaceInterface</code> for communicating with an interface in the device</p></li></ul><p>Both device interfaces are defined in <code>/System/Library/Frameworks/IOKit.framework/Headers/usb/IOUSBLib.h</code>.</p><p>Communicating with the device itself is usually only necessary when you need to set or change its configuration. For example, vendor-specific devices are often not configured because there are no default drivers that set a particular configuration. In this case, your application must use the device interface for the device to set the configuration it needs so the interfaces become available.</p><p>The process of finding and communicating with a USB device is divided into two sets of steps. The first set outlines how to find a USB device, acquire a device interface of type <code>IOUSBDeviceInterface</code> for it, and set or change its configuration. The second set describes how to find an interface in a device, acquire a device interface of type <code>IOUSBInterfaceInterface</code> for it, and use it to communicate with that interface. If you need to communicate with an unconfigured device or if you need to change a device’s configuration, you follow both sets of steps. If you need to communicate with a device that is already configured to your specification, you follow only the second set of steps. The sample code in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIDDHCI">“Accessing a USB Device”</a></span> follows both sets of steps and extends them to include setting up notifications it can receive when devices are dynamically added or removed.</p><p>Follow this first set of steps <em>only</em> to set or change the configuration of a device. If the device you’re interested in is already configured for your needs, skip these steps and follow the second set of steps.</p><ol class="ol"><li class="li"><p>Find the <code>IOUSBDevice</code> object that represents the device in the I/O Registry. This includes setting up a matching dictionary with a key from the <em>USB Common Class Specification</em> (see <span class="content_text"><a href="../USBOverview/USBOverview.html#//apple_ref/doc/uid/TP40002644-BBIDGCHB">“Finding USB Devices and Interfaces”</a></span>). The sample code uses the key elements <code>kUSBVendorName</code> and <code>kUSBProductName</code> to find a particular USB device (this is the second key listed in <span class="content_text"><a href="../USBOverview/USBOverview.html#//apple_ref/doc/uid/TP40002644-BBCCGEEF">Table 1-2</a></span>).</p></li><li class="li"><p>Create a device interface of type <code>IOUSBDeviceInterface</code> for the device. This device interface provides functions that perform tasks such as setting or changing the configuration of the device, getting information about the device, and resetting the device.</p></li><li class="li"><p>Examine the device’s configurations with <code><!--a-->GetConfigurationDescriptorPtr<!--/a--></code>, choose the appropriate one, and call <code><!--a-->SetConfiguration<!--/a--></code> to set the device’s configuration and instantiate the <code>IOUSBInterface</code> objects for that configuration.</p></li></ol><p>Follow this second set of steps to find and choose an interface, acquire a device interface for it, and communicate with the device.</p><ol class="ol"><li class="li"><p>Create an interface iterator to iterate over the available interfaces.</p></li><li class="li"><p>Create a device interface for each interface so you can examine its properties and select the appropriate one. To do this, you create a device interface of type <code>IOUSBInterfaceInterface</code>. This device interface provides functions that perform tasks such as getting information about the interface, setting the interface’s alternate setting, and accessing its pipes.</p></li><li class="li"><p>Use the <code><!--a-->USBInterfaceOpen<!--/a--></code> function to open the selected interface. This will cause the pipes associated with the interface to be instantiated so you can examine the properties of each and select the appropriate one.</p></li><li class="li"><p>Communicate with the device through the selected pipe. You can write to and read from the pipe synchronously or asynchronously—the sample code in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIDDHCI">“Accessing a USB Device”</a></span> shows how to do both.</p></li></ol><a name="//apple_ref/doc/uid/TP40002645-BBIDDHCI" title="Accessing a USB Device"></a><h2>Accessing a USB Device</h2><p>This section provides snippets of sample code that show how to access a Cypress EZ-USB chip with an 8051 microcontroller core. The sample code follows the first set of steps in section <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIHCIHB">“Using USB Device Interfaces”</a></span> to find the Cypress EZ-USB chip in its default, unprogrammed state (also referred to as the “raw device”). It then configures the device and downloads firmware provided by Cypress to program the chip to behave as a device that echoes all information it receives on its bulk out pipe to its bulk in pipe.</p><p>Once the chip has been programmed, the device nub representing the default, unprogrammed device is detached from the I/O Registry and a new device nub, representing the programmed chip, is attached. To communicate with the programmed chip (also referred to as the “bulk test device”), the sample code must perform the first set of steps again to find the device, create a device interface for it, and configure it. Then it performs the second set of steps to find an interface, create a device interface for it, and test the device. The sample code also shows how to set up notifications for the dynamic addition and removal of a device.</p><p>If you want to build and run the sample code, open the USB Notification Example project (located in <code>/Developer/Examples/IOKit/usb</code>) in Xcode. You can observe the resulting tool’s status messages in the Xcode Run Log and terminate the tool by clicking the Terminate button. Alternatively, you can open a Terminal window, navigate to the location of the executable (for example, <code>/Developer/Examples/IOKit/usb/USBNotification Example/build</code>), run the tool, and terminate it by pressing Control-C. Note that the project also includes the <code>bulktest.c</code> file, which contains the firmware to download to the raw device, and the <code>hex2c.h</code> file, which defines the structure the firmware uses.</p><a name="//apple_ref/doc/uid/TP40002645-CHDDJEAF" title="Definitions and Global Variables"></a><h3>Definitions and Global Variables</h3><p>The code in the USB Notification Example uses the definitions and global variables shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-CCHBIHDI">Listing 2-1</a></span>. The definition of <code>USE_ASYNC_IO</code> allows you to choose to use either synchronous or asynchronous calls to read from and write to the chip by commenting out the line or leaving it in, respectively. The definition of <code><!--a  -->kTestMessage<!--/a--></code> sets up a simple message to write to the device. The remaining definitions are specific to the Cypress EZ-USB chip.</p><a name="//apple_ref/doc/uid/TP40002645-CCHBIHDI" title="Listing 2-1Definitions and global variables"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Definitions and global variables</p><div class="codesample"><table><tr><td scope="row"><pre>#define USE_ASYNC_IO    //Comment this line out if you want to use<span></span></pre></td></tr><tr><td scope="row"><pre>                        //synchronous calls for reads and writes<span></span></pre></td></tr><tr><td scope="row"><pre>#define kTestMessage        "Bulk I/O Test"<span></span></pre></td></tr><tr><td scope="row"><pre>#define k8051_USBCS         0x7f92<span></span></pre></td></tr><tr><td scope="row"><pre>#define kOurVendorID        1351    //Vendor ID of the USB device<span></span></pre></td></tr><tr><td scope="row"><pre>#define kOurProductID           8193    //Product ID of device BEFORE it<span></span></pre></td></tr><tr><td scope="row"><pre>                                        //is programmed (raw device)<span></span></pre></td></tr><tr><td scope="row"><pre>#define kOurProductIDBulkTest   4098    //Product ID of device AFTER it is<span></span></pre></td></tr><tr><td scope="row"><pre>                                        //programmed (bulk test device)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//Global variables<span></span></pre></td></tr><tr><td scope="row"><pre>static IONotificationPortRef    gNotifyPort;<span></span></pre></td></tr><tr><td scope="row"><pre>static io_iterator_t            gRawAddedIter;<span></span></pre></td></tr><tr><td scope="row"><pre>static io_iterator_t            gRawRemovedIter;<span></span></pre></td></tr><tr><td scope="row"><pre>static io_iterator_t            gBulkTestAddedIter;<span></span></pre></td></tr><tr><td scope="row"><pre>static io_iterator_t            gBulkTestRemovedIter;<span></span></pre></td></tr><tr><td scope="row"><pre>static char                     gBuffer[64];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002645-TPXREF104" title="The main Function"></a><h3>The main Function</h3><p>The <code>main</code> function in the USB Notification Example project (contained in the file <code>main.c</code>) accomplishes the following tasks.</p><ul class="spaceabove"><li class="li"><p>It establishes communication with the I/O Kit and sets up a matching dictionary to find the Cypress EZ-USB chip.</p></li><li class="li"><p>It sets up an asynchronous notification to be called when an unprogrammed (raw) device is first attached to the I/O Registry and another to be called when the device is removed.</p></li><li class="li"><p>It modifies the matching dictionary to find the programmed (bulk test) device.</p></li><li class="li"><p>It sets up additional notifications to be called when the bulk test device is first attached or removed.</p></li><li class="li"><p>It starts the run loop so the notifications that have been set up will be received.</p></li></ul><p>The <code>main</code> function uses I/O Kit functions to set up and modify a matching dictionary and set up notifications, and Core Foundation functions to set up the run loop for receiving the notifications. It calls the following functions to access both the raw device and the bulk test device.</p><ul class="spaceabove"><li class="li"><p><code><!--a-->RawDeviceAdded<!--/a--></code>, shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIEHHGE">Listing 2-3</a></span>, iterates over the set of matching devices and creates a device interface for each one. It calls <code><!--a-->ConfigureDevice<!--/a--></code> (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIJEJEI">Listing 2-5</a></span>) to set the device’s configuration, and then <code><!--a-->DownloadToDevice<!--/a--></code> (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIFBJJA">Listing 2-6</a></span>) to download the firmware to program it.</p></li><li class="li"><p><code><!--a-->RawDeviceRemoved<!--/a--></code>, shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIHFJFJ">Listing 2-4</a></span>, iterates over the set of matching devices and releases each one in turn.</p></li><li class="li"><p><code><!--a-->BulkTestDeviceAdded<!--/a--></code>, shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIBAGDH">Listing 2-7</a></span>, iterates over the new set of matching devices, creates a device interface for each one, and calls <code><!--a-->ConfigureDevice<!--/a--></code> (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIJEJEI">Listing 2-5</a></span>) to set the device’s configuration. It then calls <code><!--a-->FindInterfaces<!--/a--></code> (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIEIEII">Listing 2-8</a></span>) to get access to the interfaces on the device.</p></li><li class="li"><p><code><!--a-->BulkTestDeviceRemoved<!--/a--></code> iterates over the new set of matching devices and releases each one in turn. This function is not shown in this chapter; see <code><!--a-->RawDeviceRemoved<!--/a--></code> (<span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIHFJFJ">Listing 2-4</a></span>) for a nearly identical function.</p></li></ul><a name="//apple_ref/doc/uid/TP40002645-BBIFFAIA" title="Listing 2-2The main function"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>The main function</p><div class="codesample"><table><tr><td scope="row"><pre>int main (int argc, const char *argv[])<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    mach_port_t             masterPort;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFMutableDictionaryRef  matchingDict;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopSourceRef      runLoopSource;<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t           kr;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32                  usbVendor = kOurVendorID;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32                  usbProduct = kOurProductID;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get command line arguments, if any<span></span></pre></td></tr><tr><td scope="row"><pre>    if (argc > 1)<span></span></pre></td></tr><tr><td scope="row"><pre>        usbVendor = atoi(argv[1]);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (argc > 2)<span></span></pre></td></tr><tr><td scope="row"><pre>        usbProduct = atoi(argv[2]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Create a master port for communication with the I/O Kit<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = IOMasterPort(MACH_PORT_NULL, &amp;masterPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (kr || !masterPort)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("ERR: Couldn’t create a master I/O Kit port(%08x)\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>        return -1;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    //Set up matching dictionary for class IOUSBDevice and its subclasses<span></span></pre></td></tr><tr><td scope="row"><pre>    matchingDict = IOServiceMatching(kIOUSBDeviceClassName);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!matchingDict)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Couldn’t create a USB matching dictionary\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        mach_port_deallocate(mach_task_self(), masterPort);<span></span></pre></td></tr><tr><td scope="row"><pre>        return -1;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Add the vendor and product IDs to the matching dictionary.<span></span></pre></td></tr><tr><td scope="row"><pre>    //This is the second key in the table of device-matching keys of the<span></span></pre></td></tr><tr><td scope="row"><pre>    //USB Common Class Specification<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDictionarySetValue(matchingDict, CFSTR(kUSBVendorName),<span></span></pre></td></tr><tr><td scope="row"><pre>                        CFNumberCreate(kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     kCFNumberSInt32Type, &amp;usbVendor));<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDictionarySetValue(matchingDict, CFSTR(kUSBProductName),<span></span></pre></td></tr><tr><td scope="row"><pre>                        CFNumberCreate(kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    kCFNumberSInt32Type, &amp;usbProduct));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //To set up asynchronous notifications, create a notification port and<span></span></pre></td></tr><tr><td scope="row"><pre>    //add its run loop event source to the program’s run loop<span></span></pre></td></tr><tr><td scope="row"><pre>    gNotifyPort = IONotificationPortCreate(masterPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    runLoopSource = IONotificationPortGetRunLoopSource(gNotifyPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopAddSource(CFRunLoopGetCurrent(), runLoopSource,<span></span></pre></td></tr><tr><td scope="row"><pre>                        kCFRunLoopDefaultMode);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Retain additional dictionary references because each call to<span></span></pre></td></tr><tr><td scope="row"><pre>    //IOServiceAddMatchingNotification consumes one reference<span></span></pre></td></tr><tr><td scope="row"><pre>    matchingDict = (CFMutableDictionaryRef) CFRetain(matchingDict);<span></span></pre></td></tr><tr><td scope="row"><pre>    matchingDict = (CFMutableDictionaryRef) CFRetain(matchingDict);<span></span></pre></td></tr><tr><td scope="row"><pre>    matchingDict = (CFMutableDictionaryRef) CFRetain(matchingDict);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Now set up two notifications: one to be called when a raw device<span></span></pre></td></tr><tr><td scope="row"><pre>    //is first matched by the I/O Kit and another to be called when the<span></span></pre></td></tr><tr><td scope="row"><pre>    //device is terminated<span></span></pre></td></tr><tr><td scope="row"><pre>    //Notification of first match:<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = IOServiceAddMatchingNotification(gNotifyPort,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kIOFirstMatchNotification, matchingDict,<span></span></pre></td></tr><tr><td scope="row"><pre>                    RawDeviceAdded, NULL, &amp;gRawAddedIter);<span></span></pre></td></tr><tr><td scope="row"><pre>    //Iterate over set of matching devices to access already-present devices<span></span></pre></td></tr><tr><td scope="row"><pre>    //and to arm the notification<span></span></pre></td></tr><tr><td scope="row"><pre>    RawDeviceAdded(NULL, gRawAddedIter);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Notification of termination:<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = IOServiceAddMatchingNotification(gNotifyPort,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kIOTerminatedNotification, matchingDict,<span></span></pre></td></tr><tr><td scope="row"><pre>                    RawDeviceRemoved, NULL, &amp;gRawRemovedIter);<span></span></pre></td></tr><tr><td scope="row"><pre>    //Iterate over set of matching devices to release each one and to<span></span></pre></td></tr><tr><td scope="row"><pre>    //arm the notification<span></span></pre></td></tr><tr><td scope="row"><pre>    RawDeviceRemoved(NULL, gRawRemovedIter);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Now change the USB product ID in the matching dictionary to match<span></span></pre></td></tr><tr><td scope="row"><pre>    //the one the device will have after the firmware has been downloaded<span></span></pre></td></tr><tr><td scope="row"><pre>    usbProduct = kOurProductIDBulkTest;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDictionarySetValue(matchingDict, CFSTR(kUSBProductName),<span></span></pre></td></tr><tr><td scope="row"><pre>                        CFNumberCreate(kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    kCFNumberSInt32Type, &amp;usbProduct));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Now set up two notifications: one to be called when a bulk test device<span></span></pre></td></tr><tr><td scope="row"><pre>    //is first matched by the I/O Kit and another to be called when the<span></span></pre></td></tr><tr><td scope="row"><pre>    //device is terminated.<span></span></pre></td></tr><tr><td scope="row"><pre>    //Notification of first match<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = IOServiceAddMatchingNotification(gNotifyPort,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kIOFirstMatchNotification, matchingDict,<span></span></pre></td></tr><tr><td scope="row"><pre>                    BulkTestDeviceAdded, NULL, &amp;gBulkTestAddedIter);<span></span></pre></td></tr><tr><td scope="row"><pre>    //Iterate over set of matching devices to access already-present devices<span></span></pre></td></tr><tr><td scope="row"><pre>    //and to arm the notification<span></span></pre></td></tr><tr><td scope="row"><pre>    BulkTestDeviceAdded(NULL, gBulkTestAddedIter);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Notification of termination<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = IOServiceAddMatchingNotification(gNotifyPort,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kIOTerminatedNotification, matchingDict,<span></span></pre></td></tr><tr><td scope="row"><pre>                    BulkTestDeviceRemoved, NULL, &amp;gBulkTestRemovedIter);<span></span></pre></td></tr><tr><td scope="row"><pre>    //Iterate over set of matching devices to release each one and to<span></span></pre></td></tr><tr><td scope="row"><pre>    //arm the notification. NOTE: this function is not shown in this document.<span></span></pre></td></tr><tr><td scope="row"><pre>    BulkTestDeviceRemoved(NULL, gBulkTestRemovedIter);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Finished with master port<span></span></pre></td></tr><tr><td scope="row"><pre>    mach_port_deallocate(mach_task_self(), masterPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    masterPort = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Start the run loop so notifications will be received<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopRun();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Because the run loop will run forever until interrupted,<span></span></pre></td></tr><tr><td scope="row"><pre>    //the program should never reach this point<span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002645-TPXREF105" title="Working With the Raw Device"></a><h3>Working With the Raw Device</h3><p>Now that you’ve obtained an iterator for a set of matching devices, you can use it to gain access to each raw device, configure it, and download the appropriate firmware to it. The function <code><!--a-->RawDeviceAdded<!--/a--></code> (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIEHHGE">Listing 2-3</a></span>) uses I/O Kit functions to create a device interface for each device and then calls the following functions to configure the device and download firmware to it.</p><ul class="spaceabove"><li class="li"><p><code><!--a-->ConfigureDevice<!--/a--></code>, shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIJEJEI">Listing 2-5</a></span>, uses device interface functions to get the number of configurations, examine the first one, and set the device’s configuration.</p></li><li class="li"><p><code><!--a-->DownloadToDevice<!--/a--></code>, shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIFBJJA">Listing 2-6</a></span>, downloads the firmware in <code>bulktest.c</code> to the device.</p></li></ul><a name="//apple_ref/doc/uid/TP40002645-BBIEHHGE" title="Listing 2-3Accessing and programming the raw device"></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>Accessing and programming the raw device</p><div class="codesample"><table><tr><td scope="row"><pre>void RawDeviceAdded(void *refCon, io_iterator_t iterator)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t               kr;<span></span></pre></td></tr><tr><td scope="row"><pre>    io_service_t                usbDevice;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOCFPlugInInterface         **plugInInterface = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOUSBDeviceInterface        **dev = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    HRESULT                     result;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32                      score;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16                      vendor;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16                      product;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16                      release;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while (usbDevice = IOIteratorNext(iterator))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        //Create an intermediate plug-in<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = IOCreatePlugInInterfaceForService(usbDevice,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kIOUSBDeviceUserClientTypeID, kIOCFPlugInInterfaceID,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;plugInInterface, &amp;score);<span></span></pre></td></tr><tr><td scope="row"><pre>        //Don’t need the device object after intermediate plug-in is created<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = IOObjectRelease(usbDevice);<span></span></pre></td></tr><tr><td scope="row"><pre>        if ((kIOReturnSuccess != kr) || !plugInInterface)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Unable to create a plug-in (%08x)\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            continue;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        //Now create the device interface<span></span></pre></td></tr><tr><td scope="row"><pre>        result = (*plugInInterface)->QueryInterface(plugInInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>                        CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID),<span></span></pre></td></tr><tr><td scope="row"><pre>                        (LPVOID *)&amp;dev);<span></span></pre></td></tr><tr><td scope="row"><pre>        //Don’t need the intermediate plug-in after device interface<span></span></pre></td></tr><tr><td scope="row"><pre>        //is created<span></span></pre></td></tr><tr><td scope="row"><pre>        (*plugInInterface)->Release(plugInInterface);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (result || !dev)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Couldn’t create a device interface (%08x)\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    (int) result);<span></span></pre></td></tr><tr><td scope="row"><pre>            continue;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Check these values for confirmation<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*dev)->GetDeviceVendor(dev, &amp;vendor);<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*dev)->GetDeviceProduct(dev, &amp;product);<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*dev)->GetDeviceReleaseNumber(dev, &amp;release);<span></span></pre></td></tr><tr><td scope="row"><pre>        if ((vendor != kOurVendorID) || (product != kOurProductID) ||<span></span></pre></td></tr><tr><td scope="row"><pre>            (release != 1))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Found unwanted device (vendor = %d, product = %d)\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                    vendor, product);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*dev)->Release(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>            continue;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Open the device to change its state<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*dev)->USBDeviceOpen(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Unable to open device: %08x\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*dev)->Release(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>            continue;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        //Configure device<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = ConfigureDevice(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Unable to configure device: %08x\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*dev)->USBDeviceClose(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*dev)->Release(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>            continue;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Download firmware to device<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = DownloadToDevice(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Unable to download firmware to device: %08x\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*dev)->USBDeviceClose(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*dev)->Release(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>            continue;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Close this device and release object<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*dev)->USBDeviceClose(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*dev)->Release(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The function <code><!--a-->RawDeviceRemoved<!--/a--></code> simply uses the iterator obtained from the <code><!--a-->main<!--/a--></code> function (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIFFAIA">Listing 2-2</a></span>) to release each device object. This also has the effect of arming the raw device termination notification so it will notify the program of future device removals. <code><!--a-->RawDeviceRemoved<!--/a--></code> is shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIHFJFJ">Listing 2-4</a></span>.</p><a name="//apple_ref/doc/uid/TP40002645-BBIHFJFJ" title="Listing 2-4Releasing the raw device objects"></a><p class="codesample"><strong>Listing 2-4&nbsp;&nbsp;</strong>Releasing the raw device objects</p><div class="codesample"><table><tr><td scope="row"><pre>void RawDeviceRemoved(void *refCon, io_iterator_t iterator)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   kr;<span></span></pre></td></tr><tr><td scope="row"><pre>    io_service_t    object;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while (object = IOIteratorNext(iterator))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = IOObjectRelease(object);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Couldn’t release raw device object: %08x\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            continue;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Although every USB device has one or more configurations, unless the device is a composite class device that’s been matched by the <code>AppleUSBComposite</code> driver which automatically sets the first configuration, none of those configurations may have been set. Therefore, your application may have to use device interface functions to get the appropriate configuration value and use it to set the device’s configuration. In the sample code, the function <code><!--a-->ConfigureDevice<!--/a--></code> (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIJEJEI">Listing 2-5</a></span>) accomplishes this task. In fact, it is called twice: once by <code><!--a-->RawDeviceAdded<!--/a--></code> to configure the raw device and again by <code><!--a-->BulkTestDeviceAdded<!--/a--></code> (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIBAGDH">Listing 2-7</a></span>) to configure the bulk test device.</p><a name="//apple_ref/doc/uid/TP40002645-BBIJEJEI" title="Listing 2-5Configuring a USB device"></a><p class="codesample"><strong>Listing 2-5&nbsp;&nbsp;</strong>Configuring a USB device</p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn ConfigureDevice(IOUSBDeviceInterface **dev)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8                           numConfig;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn                        kr;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOUSBConfigurationDescriptorPtr configDesc;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Get the number of configurations. The sample code always chooses<span></span></pre></td></tr><tr><td scope="row"><pre>    //the first configuration (at index 0) but your code may need a<span></span></pre></td></tr><tr><td scope="row"><pre>    //different one<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = (*dev)->GetNumberOfConfigurations(dev, &amp;numConfig);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!numConfig)<span></span></pre></td></tr><tr><td scope="row"><pre>        return -1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Get the configuration descriptor for index 0<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = (*dev)->GetConfigurationDescriptorPtr(dev, 0, &amp;configDesc);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (kr)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Couldn’t get configuration descriptor for index %d (err =<span></span></pre></td></tr><tr><td scope="row"><pre>                %08x)\n", 0, kr);<span></span></pre></td></tr><tr><td scope="row"><pre>        return -1;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Set the device’s configuration. The configuration value is found in<span></span></pre></td></tr><tr><td scope="row"><pre>    //the bConfigurationValue field of the configuration descriptor<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = (*dev)->SetConfiguration(dev, configDesc->bConfigurationValue);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (kr)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Couldn’t set configuration to value %d (err = %08x)\n", 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                kr);<span></span></pre></td></tr><tr><td scope="row"><pre>        return -1;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return kIOReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Now that the device is configured, you can download firmware to it. Cypress makes firmware available to program the EZ-USB chip to emulate different devices. The sample code in this document uses firmware that programs the chip to be a bulk test device, a device that takes the data it receives from its bulk out pipe and echoes it to its bulk in pipe. The firmware, contained in the file <code>bulktest.c</code>, is an array of <code>INTEL_HEX_RECORD</code> structures (defined in the file <code>hex2c.h</code>). </p><p>The function <code><!--a-->DownloadToDevice<!--/a--></code> uses the function <code><!--a-->WriteToDevice<!--/a--></code> (shown together in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIFBJJA">Listing 2-6</a></span>) to prepare the device to receive the download and then to write information from each structure to the appropriate address on the device. When all the firmware has been downloaded, <code><!--a-->DownloadToDevice<!--/a--></code> calls <code><!--a-->WriteToDevice<!--/a--></code> a last time to inform the device that the download is complete. At this point, the raw device detaches itself from the bus and reattaches as a bulk test device. This causes the device nub representing the raw device to be removed from the I/O Registry and a new device nub, representing the bulk test device, to be attached.</p><a name="//apple_ref/doc/uid/TP40002645-BBIFBJJA" title="Listing 2-6Two functions to download firmware to the raw device"></a><p class="codesample"><strong>Listing 2-6&nbsp;&nbsp;</strong>Two functions to download firmware to the raw device</p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn DownloadToDevice(IOUSBDeviceInterface **dev)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int         i;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8       writeVal;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn    kr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Assert reset. This tells the device that the download is<span></span></pre></td></tr><tr><td scope="row"><pre>    //about to occur<span></span></pre></td></tr><tr><td scope="row"><pre>    writeVal = 1;   //For this device, a value of 1 indicates a download<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = WriteToDevice(dev, k8051_USBCS, 1, &amp;writeVal);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("WriteToDevice reset returned err 0x%x\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>        (*dev)->USBDeviceClose(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>        (*dev)->Release(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>        return kr;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Download firmware<span></span></pre></td></tr><tr><td scope="row"><pre>    i = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    while (bulktest[i].Type == 0)   //While bulktest[i].Type == 0, this is<span></span></pre></td></tr><tr><td scope="row"><pre>    {                               //not the last firmware record to<span></span></pre></td></tr><tr><td scope="row"><pre>                                    //download<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = WriteToDevice(dev, bulktest[i].Address,<span></span></pre></td></tr><tr><td scope="row"><pre>                            bulktest[i].Length, bulktest[i].Data);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("WriteToDevice download %i returned err 0x%x\n", i,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            (*dev)->USBDeviceClose(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>            (*dev)->Release(dev);<span></span></pre></td></tr><tr><td scope="row"><pre>            return kr;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        i++;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //De-assert reset. This tells the device that the download is complete<span></span></pre></td></tr><tr><td scope="row"><pre>    writeVal = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = WriteToDevice(dev, k8051_USBCS, 1, &amp;writeVal);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("WriteToDevice run returned err 0x%x\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return kr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn WriteToDevice(IOUSBDeviceInterface **dev, UInt16 deviceAddress,<span></span></pre></td></tr><tr><td scope="row"><pre>                        UInt16 length, UInt8 writeBuffer[])<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOUSBDevRequest     request;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    request.bmRequestType = USBmakebmRequestType(kUSBOut, kUSBVendor,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                kUSBDevice);<span></span></pre></td></tr><tr><td scope="row"><pre>    request.bRequest = 0xa0;<span></span></pre></td></tr><tr><td scope="row"><pre>    request.wValue = deviceAddress;<span></span></pre></td></tr><tr><td scope="row"><pre>    request.wIndex = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    request.wLength = length;<span></span></pre></td></tr><tr><td scope="row"><pre>    request.pData = writeBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return (*dev)->DeviceRequest(dev, &amp;request);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002645-TPXREF106" title="Working With the Bulk Test Device"></a><h3>Working With the Bulk Test Device</h3><p>After you download the firmware to the device, the raw device is no longer attached to the bus. To gain access to the bulk test device, you repeat most of the same steps you used to get access to the raw device.</p><ul class="spaceabove"><li class="li"><p>Use the iterator obtained by a call to <code><!--a-->IOServiceAddMatchingNotification<!--/a--></code> in the <code><!--a-->main<!--/a--></code> function (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIFFAIA">Listing 2-2</a></span>) to iterate over a set of matching devices.</p></li><li class="li"><p>Create a device interface for each device.</p></li><li class="li"><p>Configure the device.</p></li></ul><p>This time, however, the next step is to find the interfaces on the device so you can choose the appropriate one and get access to its pipes. Because of the similarities of these tasks, the function <code><!--a-->BulkTestDeviceAdded<!--/a--></code> follows the same outline of the <code><!--a-->RawDeviceAdded<!--/a--></code> function except that instead of downloading firmware to the device, it calls <code><!--a-->FindInterfaces<!--/a--></code> (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIEIEII">Listing 2-8</a></span>) to examine the available interfaces and their pipes. The code in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIBAGDH">Listing 2-7</a></span> replaces most of the <code>BulkTestDeviceAdded</code> function’s code with comments, focusing on the differences between it and the <code>RawDeviceAdded</code> function.</p><a name="//apple_ref/doc/uid/TP40002645-BBIBAGDH" title="Listing 2-7Accessing the bulk test device"></a><p class="codesample"><strong>Listing 2-7&nbsp;&nbsp;</strong>Accessing the bulk test device</p><div class="codesample"><table><tr><td scope="row"><pre>void BulkTestDeviceAdded(void *refCon, io_iterator_t iterator)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t           kr;<span></span></pre></td></tr><tr><td scope="row"><pre>    io_service_t            usbDevice;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOUSBDeviceInterface    **device=NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while (usbDevice = IOIteratorNext(iterator))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        //Create an intermediate plug-in using the<span></span></pre></td></tr><tr><td scope="row"><pre>        //IOCreatePlugInInterfaceForService function<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Release the device object after getting the intermediate plug-in<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Create the device interface using the QueryInterface function<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Release the intermediate plug-in object<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Check the vendor, product, and release number values to<span></span></pre></td></tr><tr><td scope="row"><pre>        //confirm we’ve got the right device<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Open the device before configuring it<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*device)->USBDeviceOpen(device);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Configure the device by calling ConfigureDevice<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Close the device and release the device interface object if<span></span></pre></td></tr><tr><td scope="row"><pre>        //the configuration is unsuccessful<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Get the interfaces<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = FindInterfaces(device);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Unable to find interfaces on device: %08x\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            (*device)->USBDeviceClose(device);<span></span></pre></td></tr><tr><td scope="row"><pre>            (*device)->Release(device);<span></span></pre></td></tr><tr><td scope="row"><pre>            continue;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//If using synchronous IO, close and release the device interface here<span></span></pre></td></tr><tr><td scope="row"><pre>#ifndef USB_ASYNC_IO<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*device)->USBDeviceClose(device);<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*device)->Release(device);<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The function <code><!--a-->BulkTestDeviceRemoved<!--/a--></code> simply uses the iterator obtained from the <code><!--a-->main<!--/a--></code> function (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIFFAIA">Listing 2-2</a></span>) to release each device object. This also has the effect of arming the bulk test device termination notification so it will notify the program of future device removals.The <code><!--a-->BulkTestDeviceRemoved<!--/a--></code> function is identical to the <code><!--a-->RawDeviceRemoved<!--/a--></code> function (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIHFJFJ">Listing 2-4</a></span>), with the exception of the wording of the printed error statement.</p><a name="//apple_ref/doc/uid/TP40002645-TPXREF107" title="Working With Interfaces"></a><h3>Working With Interfaces</h3><p>Now that you’ve configured the device, you have access to its interfaces. The <code><!--a-->FindInterfaces<!--/a--></code> function (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIEIEII">Listing 2-8</a></span>) creates an iterator to iterate over all interfaces on the device and then creates a device interface to communicate with each one. For each interface found, the function opens the interface, determines how many endpoints (or pipes) it has, and prints out the properties of each pipe. Because opening an interface causes its pipes to be instantiated, you can get access to any pipe by using its pipe index. The pipe index is the number of the pipe within the interface, ranging from one to the number of endpoints returned by <code>GetNumEndpoints</code>. You can communicate with the default control pipe (described in <span class="content_text"><a href="../USBOverview/USBOverview.html#//apple_ref/doc/uid/TP40002644-BBIHAIAG">“USB Transfer Types”</a></span>) from any interface by using pipe index 0, but it is usually better to use the device interface functions for the device itself (see the use of <code>IOUSBDeviceInterface</code> functions in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIJEJEI">Listing 2-5</a></span>).</p><p>The sample code employs conditional compilation using <code>#ifdef</code> and <code>#ifndef</code> to demonstrate both synchronous and asynchronous I/O. If you’ve chosen to test synchronous I/O, <code><!--a-->FindInterfaces<!--/a--></code> writes the test message (defined in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-CCHBIHDI">Listing 2-1</a></span>) to pipe index 2 on the device and reads its echo before returning. For asynchronous I/O, <code><!--a-->FindInterfaces<!--/a--></code> first creates an event source and adds it to the run loop created by the <code><!--a-->main<!--/a--></code> function (shown in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIFFAIA">Listing 2-2</a></span>). It then sets up an asynchronous write and read that will cause a notification to be sent upon completion. The completion functions <code><!--a-->WriteCompletion<!--/a--></code> and <code><!--a-->ReadCompletion<!--/a--></code> are shown together in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIIBJJD">Listing 2-9</a></span>.</p><a name="//apple_ref/doc/uid/TP40002645-BBIEIEII" title="Listing 2-8Finding interfaces on the bulk test device"></a><p class="codesample"><strong>Listing 2-8&nbsp;&nbsp;</strong>Finding interfaces on the bulk test device</p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn FindInterfaces(IOUSBDeviceInterface **device)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn                    kr;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOUSBFindInterfaceRequest   request;<span></span></pre></td></tr><tr><td scope="row"><pre>    io_iterator_t               iterator;<span></span></pre></td></tr><tr><td scope="row"><pre>    io_service_t                usbInterface;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOCFPlugInInterface         **plugInInterface = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOUSBInterfaceInterface     **interface = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    HRESULT                     result;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32                      score;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8                       interfaceClass;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8                       interfaceSubClass;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8                       interfaceNumEndpoints;<span></span></pre></td></tr><tr><td scope="row"><pre>    int                         pipeRef;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#ifndef USE_ASYNC_IO<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                      numBytesRead;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                      i;<span></span></pre></td></tr><tr><td scope="row"><pre>#else<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopSourceRef          runLoopSource;<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Placing the constant kIOUSBFindInterfaceDontCare into the following<span></span></pre></td></tr><tr><td scope="row"><pre>    //fields of the IOUSBFindInterfaceRequest structure will allow you<span></span></pre></td></tr><tr><td scope="row"><pre>    //to find all the interfaces<span></span></pre></td></tr><tr><td scope="row"><pre>    request.bInterfaceClass = kIOUSBFindInterfaceDontCare;<span></span></pre></td></tr><tr><td scope="row"><pre>    request.bInterfaceSubClass = kIOUSBFindInterfaceDontCare;<span></span></pre></td></tr><tr><td scope="row"><pre>    request.bInterfaceProtocol = kIOUSBFindInterfaceDontCare;<span></span></pre></td></tr><tr><td scope="row"><pre>    request.bAlternateSetting = kIOUSBFindInterfaceDontCare;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Get an iterator for the interfaces on the device<span></span></pre></td></tr><tr><td scope="row"><pre>    kr = (*device)->CreateInterfaceIterator(device,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        &amp;request, &amp;iterator);<span></span></pre></td></tr><tr><td scope="row"><pre>    while (usbInterface = IOIteratorNext(iterator))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        //Create an intermediate plug-in<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = IOCreatePlugInInterfaceForService(usbInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>                            kIOUSBInterfaceUserClientTypeID,<span></span></pre></td></tr><tr><td scope="row"><pre>                            kIOCFPlugInInterfaceID,<span></span></pre></td></tr><tr><td scope="row"><pre>                            &amp;plugInInterface, &amp;score);<span></span></pre></td></tr><tr><td scope="row"><pre>        //Release the usbInterface object after getting the plug-in<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = IOObjectRelease(usbInterface);<span></span></pre></td></tr><tr><td scope="row"><pre>        if ((kr != kIOReturnSuccess) || !plugInInterface)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Unable to create a plug-in (%08x)\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Now create the device interface for the interface<span></span></pre></td></tr><tr><td scope="row"><pre>        result = (*plugInInterface)->QueryInterface(plugInInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>                    CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID),<span></span></pre></td></tr><tr><td scope="row"><pre>                    (LPVOID *) &amp;interface);<span></span></pre></td></tr><tr><td scope="row"><pre>        //No longer need the intermediate plug-in<span></span></pre></td></tr><tr><td scope="row"><pre>        (*plugInInterface)->Release(plugInInterface);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (result || !interface)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Couldn’t create a device interface for the interface<span></span></pre></td></tr><tr><td scope="row"><pre>                    (%08x)\n", (int) result);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Get interface class and subclass<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*interface)->GetInterfaceClass(interface,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    &amp;interfaceClass);<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*interface)->GetInterfaceSubClass(interface,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                &amp;interfaceSubClass);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Interface class %d, subclass %d\n", interfaceClass,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    interfaceSubClass);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Now open the interface. This will cause the pipes associated with<span></span></pre></td></tr><tr><td scope="row"><pre>        //the endpoints in the interface descriptor to be instantiated<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*interface)->USBInterfaceOpen(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Unable to open interface (%08x)\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*interface)->Release(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Get the number of endpoints associated with this interface<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*interface)->GetNumEndpoints(interface,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        &amp;interfaceNumEndpoints);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Unable to get number of endpoints (%08x)\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*interface)->USBInterfaceClose(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*interface)->Release(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Interface has %d endpoints\n", interfaceNumEndpoints);<span></span></pre></td></tr><tr><td scope="row"><pre>        //Access each pipe in turn, starting with the pipe at index 1<span></span></pre></td></tr><tr><td scope="row"><pre>        //The pipe at index 0 is the default control pipe and should be<span></span></pre></td></tr><tr><td scope="row"><pre>        //accessed using (*usbDevice)->DeviceRequest() instead<span></span></pre></td></tr><tr><td scope="row"><pre>        for (pipeRef = 1; pipeRef &lt;= interfaceNumEndpoints; pipeRef++)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            IOReturn        kr2;<span></span></pre></td></tr><tr><td scope="row"><pre>            UInt8           direction;<span></span></pre></td></tr><tr><td scope="row"><pre>            UInt8           number;<span></span></pre></td></tr><tr><td scope="row"><pre>            UInt8           transferType;<span></span></pre></td></tr><tr><td scope="row"><pre>            UInt16          maxPacketSize;<span></span></pre></td></tr><tr><td scope="row"><pre>            UInt8           interval;<span></span></pre></td></tr><tr><td scope="row"><pre>            char            *message;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            kr2 = (*interface)->GetPipeProperties(interface,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        pipeRef, &amp;direction,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        &amp;number, &amp;transferType,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        &amp;maxPacketSize, &amp;interval);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (kr2 != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>                printf("Unable to get properties of pipe %d (%08x)\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                                        pipeRef, kr2);<span></span></pre></td></tr><tr><td scope="row"><pre>            else<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                printf("PipeRef %d: ", pipeRef);<span></span></pre></td></tr><tr><td scope="row"><pre>                switch (direction)<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    case kUSBOut:<span></span></pre></td></tr><tr><td scope="row"><pre>                        message = "out";<span></span></pre></td></tr><tr><td scope="row"><pre>                        break;<span></span></pre></td></tr><tr><td scope="row"><pre>                    case kUSBIn:<span></span></pre></td></tr><tr><td scope="row"><pre>                        message = "in";<span></span></pre></td></tr><tr><td scope="row"><pre>                        break;<span></span></pre></td></tr><tr><td scope="row"><pre>                    case kUSBNone:<span></span></pre></td></tr><tr><td scope="row"><pre>                        message = "none";<span></span></pre></td></tr><tr><td scope="row"><pre>                        break;<span></span></pre></td></tr><tr><td scope="row"><pre>                    case kUSBAnyDirn:<span></span></pre></td></tr><tr><td scope="row"><pre>                        message = "any";<span></span></pre></td></tr><tr><td scope="row"><pre>                        break;<span></span></pre></td></tr><tr><td scope="row"><pre>                    default:<span></span></pre></td></tr><tr><td scope="row"><pre>                        message = "???";<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                printf("direction %s, ", message);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                switch (transferType)<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    case kUSBControl:<span></span></pre></td></tr><tr><td scope="row"><pre>                        message = "control";<span></span></pre></td></tr><tr><td scope="row"><pre>                        break;<span></span></pre></td></tr><tr><td scope="row"><pre>                    case kUSBIsoc:<span></span></pre></td></tr><tr><td scope="row"><pre>                        message = "isoc";<span></span></pre></td></tr><tr><td scope="row"><pre>                        break;<span></span></pre></td></tr><tr><td scope="row"><pre>                    case kUSBBulk:<span></span></pre></td></tr><tr><td scope="row"><pre>                        message = "bulk";<span></span></pre></td></tr><tr><td scope="row"><pre>                        break;<span></span></pre></td></tr><tr><td scope="row"><pre>                    case kUSBInterrupt:<span></span></pre></td></tr><tr><td scope="row"><pre>                        message = "interrupt";<span></span></pre></td></tr><tr><td scope="row"><pre>                        break;<span></span></pre></td></tr><tr><td scope="row"><pre>                    case kUSBAnyType:<span></span></pre></td></tr><tr><td scope="row"><pre>                        message = "any";<span></span></pre></td></tr><tr><td scope="row"><pre>                        break;<span></span></pre></td></tr><tr><td scope="row"><pre>                    default:<span></span></pre></td></tr><tr><td scope="row"><pre>                        message = "???";<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                printf("transfer type %s, maxPacketSize %d\n", message,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    maxPacketSize);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#ifndef USE_ASYNC_IO    //Demonstrate synchronous I/O<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*interface)->WritePipe(interface, 2, kTestMessage,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            strlen(kTestMessage));<span></span></pre></td></tr><tr><td scope="row"><pre>        if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Unable to perform bulk write (%08x)\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*interface)->USBInterfaceClose(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*interface)->Release(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Wrote \"%s\" (%ld bytes) to bulk endpoint\n", kTestMessage,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        (UInt32) strlen(kTestMessage));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        numBytesRead = sizeof(gBuffer) - 1; //leave one byte at the end<span></span></pre></td></tr><tr><td scope="row"><pre>                                             //for NULL termination<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*interface)->ReadPipe(interface, 9, gBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            &amp;numBytesRead);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Unable to perform bulk read (%08x)\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*interface)->USBInterfaceClose(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*interface)->Release(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Because the downloaded firmware echoes the one’s complement of the<span></span></pre></td></tr><tr><td scope="row"><pre>        //message, now complement the buffer contents to get the original data<span></span></pre></td></tr><tr><td scope="row"><pre>        for (i = 0; i &lt; numBytesRead; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>            gBuffer[i] = ~gBuffer[i];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Read \"%s\" (%ld bytes) from bulk endpoint\n", gBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                    numBytesRead);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#else   //Demonstrate asynchronous I/O<span></span></pre></td></tr><tr><td scope="row"><pre>        //As with service matching notifications, to receive asynchronous<span></span></pre></td></tr><tr><td scope="row"><pre>        //I/O completion notifications, you must create an event source and<span></span></pre></td></tr><tr><td scope="row"><pre>        //add it to the run loop<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*interface)->CreateInterfaceAsyncEventSource(<span></span></pre></td></tr><tr><td scope="row"><pre>                                    interface, &amp;runLoopSource);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Unable to create asynchronous event source<span></span></pre></td></tr><tr><td scope="row"><pre>                                    (%08x)\n", kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*interface)->USBInterfaceClose(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*interface)->Release(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRunLoopAddSource(CFRunLoopGetCurrent(), runLoopSource,<span></span></pre></td></tr><tr><td scope="row"><pre>                            kCFRunLoopDefaultMode);<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Asynchronous event source added to run loop\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        bzero(gBuffer, sizeof(gBuffer));<span></span></pre></td></tr><tr><td scope="row"><pre>        strcpy(gBuffer, kTestMessage);<span></span></pre></td></tr><tr><td scope="row"><pre>        kr = (*interface)->WritePipeAsync(interface, 2, gBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    strlen(gBuffer),<span></span></pre></td></tr><tr><td scope="row"><pre>                                    WriteCompletion, (void *) interface);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (kr != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Unable to perform asynchronous bulk write (%08x)\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    kr);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*interface)->USBInterfaceClose(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) (*interface)->Release(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>        //For this test, just use first interface, so exit loop<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return kr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When an asynchronous write action is complete, the <code><!--a-->WriteCompletion<!--/a--></code> function is called by the notification. <code><!--a-->WriteCompletion<!--/a--></code> then calls the interface function <code><!--a-->ReadPipeAsync<!--/a--></code> to perform an asynchronous read from the pipe. When the read is complete, control passes to <code><!--a-->ReadCompletion<!--/a--></code> which simply prints status messages and adds a <code><!--a  -->NULL<!--/a--></code> termination to the global buffer containing the test message read from the device. The <code><!--a-->WriteCompletion<!--/a--></code> and <code><!--a-->ReadCompletion<!--/a--></code> functions are shown together in <span class="content_text"><a href="USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIIBJJD">Listing 2-9</a></span>.</p><a name="//apple_ref/doc/uid/TP40002645-BBIIBJJD" title="Listing 2-9Two asynchronous I/O completion functions"></a><p class="codesample"><strong>Listing 2-9&nbsp;&nbsp;</strong>Two asynchronous I/O completion functions</p><div class="codesample"><table><tr><td scope="row"><pre>void WriteCompletion(void *refCon, IOReturn result, void *arg0)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOUSBInterfaceInterface **interface = (IOUSBInterfaceInterface **) refCon;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                  numBytesWritten = (UInt32) arg0;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                  numBytesRead;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    printf("Asynchronous write complete\n");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (result != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("error from asynchronous bulk write (%08x)\n", result);<span></span></pre></td></tr><tr><td scope="row"><pre>        (void) (*interface)->USBInterfaceClose(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>        (void) (*interface)->Release(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("Wrote \"%s\" (%ld bytes) to bulk endpoint\n", kTestMessage,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        numBytesWritten);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    numBytesRead = sizeof(gBuffer) - 1; //leave one byte at the end for<span></span></pre></td></tr><tr><td scope="row"><pre>                                            //NULL termination<span></span></pre></td></tr><tr><td scope="row"><pre>    result = (*interface)->ReadPipeAsync(interface, 9, gBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    numBytesRead, ReadCompletion, refCon);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (result != kIOReturnSuccess)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Unable to perform asynchronous bulk read (%08x)\n", result);<span></span></pre></td></tr><tr><td scope="row"><pre>        (void) (*interface)->USBInterfaceClose(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>        (void) (*interface)->Release(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void ReadCompletion(void *refCon, IOReturn result, void *arg0)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOUSBInterfaceInterface **interface = (IOUSBInterfaceInterface **) refCon;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32      numBytesRead = (UInt32) arg0;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32      i;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    printf("Asynchronous bulk read complete\n");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (result != kIOReturnSuccess) {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("error from async bulk read (%08x)\n", result);<span></span></pre></td></tr><tr><td scope="row"><pre>        (void) (*interface)->USBInterfaceClose(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>        (void) (*interface)->Release(interface);<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    //Check the complement of the buffer’s contents for original data<span></span></pre></td></tr><tr><td scope="row"><pre>    for (i = 0; i &lt; numBytesRead; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>        gBuffer[i] = ~gBuffer[i];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    printf("Read \"%s\" (%ld bytes) from bulk endpoint\n", gBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    numBytesRead);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../USBOverview/USBOverview.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../USBRevisionHistory/USBRevHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-09-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/USBBook/USBDeviceInterfaces/USBDevInterfaces.html%3Fid%3DTP40000973-4.7&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/USBBook/USBDeviceInterfaces/USBDevInterfaces.html%3Fid%3DTP40000973-4.7&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/USBBook/USBDeviceInterfaces/USBDevInterfaces.html%3Fid%3DTP40000973-4.7&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>