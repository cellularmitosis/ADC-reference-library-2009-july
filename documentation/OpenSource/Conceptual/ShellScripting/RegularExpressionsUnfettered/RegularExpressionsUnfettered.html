<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Shell Scripting Primer: Regular Expressions Unfettered</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Regular Expressions Unfettered"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40004268-CH238" title="Regular Expressions Unfettered"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP40003594" target="_top">Open Source</a> &gt; <a href="../../../Scripting-date.html#//apple_ref/doc/uid/TP30000440-TP40003594-TP30000569" target="_top">Scripting &amp; Automation</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40004268-TP40003516-SW1">Shell Scripting Primer</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../PaintbyNumbers/PaintbyNumbers.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Howawk-ward/Howawk-ward.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40004268-CH238-SW7" title="Regular Expressions Unfettered"></a><h1>Regular Expressions Unfettered</h1><p>Regular expressions are a powerful mechanism for text processing. You can use regular expressions to search for a pattern within a block of text, to replace bits of that text with other bits of text, and to manipulate strings in various other subtle and interesting ways.</p><p>For the purposes of this chapter, you should paste the following lines of text into a text file with UNIX line endings (newline):</p>
<div class="codesample"><table><tr><td scope="row"><pre>Mary had a little lamb,<span></span></pre></td></tr><tr><td scope="row"><pre>its fleece was white as snow,<span></span></pre></td></tr><tr><td scope="row"><pre>and everywhere that Mary went,<span></span></pre></td></tr><tr><td scope="row"><pre>the lamb was sure to go.<span></span></pre></td></tr><tr><td scope="row"><pre>A few more lines to confuse things:<span></span></pre></td></tr><tr><td scope="row"><pre>Marylamb had a little.<span></span></pre></td></tr><tr><td scope="row"><pre>This is a test.  This is only a test.<span></span></pre></td></tr><tr><td scope="row"><pre>Mary was married.  A lamb was nearby.<span></span></pre></td></tr><tr><td scope="row"><pre>Mary, a little lamb, and my grocer's freezer...<span></span></pre></td></tr><tr><td scope="row"><pre>Mary a lamb.<span></span></pre></td></tr><tr><td scope="row"><pre>Marry a lamb.<span></span></pre></td></tr><tr><td scope="row"><pre>Mary had a lamb looked like a lamb.<span></span></pre></td></tr><tr><td scope="row"><pre>I want chocolate for Valentine's day.<span></span></pre></td></tr><tr><td scope="row"><pre>This line contains a slash (/).<span></span></pre></td></tr><tr><td scope="row"><pre>This line contains a backslash (\).<span></span></pre></td></tr><tr><td scope="row"><pre>This line contains brackets ([]).<span></span></pre></td></tr><tr><td scope="row"><pre>Why is mary lowercase?<span></span></pre></td></tr><tr><td scope="row"><pre>What about Mary, Mary, and Mary?<span></span></pre></td></tr><tr><td scope="row"><pre>const people fox<span></span></pre></td></tr><tr><td scope="row"><pre>constant turtles bear<span></span></pre></td></tr><tr><td scope="row"><pre>constellation Libra<span></span></pre></td></tr><tr><td scope="row"><pre>The quick brown fox jumped over the lazy dog.<span></span></pre></td></tr></table></div><p>Save this into a file called <code>poem.txt</code>.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW18">Types of Regular Expressions</a>
				
			<br/>
			
        
			
			
				<a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW4">Regular Expression Syntax</a>
				
			<br/>
			
        
			
			
				<a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW9">Positional Anchors and Flags</a>
				
			<br/>
			
        
			
			
				<a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW3">Wildcards and Repetition Operators</a>
				
			<br/>
			
        
			
			
				<a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW10">Character Classes and Groups</a>
				
			<br/>
			
        
			
			
				<a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW15">Quoting Special Characters</a>
				
			<br/>
			
        
			
			
				<a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW1">Capturing Operators and Variables</a>
				
			<br/>
			
        
			
			
				<a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW16">Mixing Capturing and Grouping Operators</a>
				
			<br/>
			
        
			
			
				<a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW17">Using Modifiers</a>
				
			<br/>
			
        
			
			
				<a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW2">Perl and Python Extensions</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40004268-CH238-SW18" title="Types of Regular Expressions"></a><h2>Types of Regular Expressions</h2><p>There are three basic types of regular expressions: basic regular expressions, extended regular expressions, and Perl regular expressions. Throughout this chapter, the sections points out areas in which they diverge. This section is just a summary of the differences. For more detail, see the appropriate section.</p><p>Basic regular expressions and extended regular expressions differ in the following areas:<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_308"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_309"></a></p><ul class="ul"><li class="li"><p>Basic regular expressions use a backslash prior to grouping/capturing parentheses (and prior to pipe operators within these parentheses). Extended regular expressions do not. These operators are described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW13">“Grouping Operators.”</a></span></p></li><li class="li"><p>Basic regular expressions use a backslash prior to a plus sign when used to mean “one or more of the previous character or group”. Extended regular expressions do not. This operator is described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW3">“Wildcards and Repetition Operators.”</a></span></p></li><li class="li"><p>Basic regular expressions use a backslash prior to a question mark when used to mean “zero or one of the previous character or group”. Extended regular expressions do not. This operator is described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW3">“Wildcards and Repetition Operators.”</a></span></p></li></ul><p>Perl regular expressions are equivalent to extended regular expressions with a few additional features:<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_310"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_311"></a></p><ul class="ul"><li class="li"><p>Perl can (optionally) use a dollar sign instead of a backslash to represent variables in substitution patterns, as described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW1">“Capturing Operators and Variables.”</a></span></p></li><li class="li"><p>Perl supports noncapturing parentheses, as described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW8">“Noncapturing Parentheses.”</a></span></p></li><li class="li"><p>The order of multiple options within parentheses can be important when substrings come into play, as described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW13">“Grouping Operators.”</a></span></p></li><li class="li"><p>Perl allows you to include a literal square bracket anywhere within a character class by preceding it with a backslash, as described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW15">“Quoting Special Characters.”</a></span></p></li><li class="li"><p>Perl adds a number of additional switches that are equivalent to certain special characters and character classes. These are described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW5">“Character Class Shortcuts.”</a></span></p></li><li class="li"><p>Perl supports a broader range of modifiers. These are described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW17">“Using Modifiers.”</a></span></p></li></ul><p></p><a name="//apple_ref/doc/uid/TP40004268-CH238-SW4" title="Regular Expression Syntax"></a><h2>Regular Expression Syntax</h2><p>The fundamental format for regular expressions is one of the following, depending on what you are trying to do:</p>
<div class="codesample"><table><tr><td scope="row"><pre>/search_pattern/modifiers<span></span></pre></td></tr><tr><td scope="row"><pre>command/search_pattern/modifiers<span></span></pre></td></tr><tr><td scope="row"><pre>command/search_pattern/replacement/modifiers<span></span></pre></td></tr></table></div><p>The first syntax is a basic <a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_312"></a>search syntax. In the absence of a command prefix, such a regular expression returns the lines matching the search pattern. In some cases, the slash marks may be (or must be) omitted—in the pattern argument to the <code><a href="../../../../Darwin/Reference/ManPages/man1/grep.1.html#//apple_ref/doc/man/1/grep" target="_top">grep</a></code> command, for example.</p><p>The second syntax is used for most commands. In this form, some operation occurs on lines matching the pattern. This may be a form of matching, or it may involve removing the portions of the line that match the pattern.</p><p>The third syntax is used for substitution commands. These can be thought of as a more complex form of search and replace.</p><p>For example, the following command searches for the word 'test' within the specified file:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression: /test/<span></span></pre></td></tr><tr><td scope="row"><pre>grep 'test' poem.txt<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW19" title="Note"></a><p><strong>Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_313"></a>Note that <code>grep</code> expects the leading and trailing slashes in the regular expression to be removed.</p></div><p>The availability of commands and flags varies somewhat between regular expression variants, and is described in the relevant sections.</p><a name="//apple_ref/doc/uid/TP40004268-CH238-SW9" title="Positional Anchors and Flags"></a><h2>Positional Anchors and Flags</h2><p>A common way to significantly alter regular expression matching is through the use of positional anchors and flags.</p><p><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_314"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_315"></a>Positional anchors allow you to specify the position within a line of text where an expression is allowed to match. There are two positional anchors that are regularly used: caret (<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_316"></a>^) and dollar (<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_317"></a>$). When placed at the beginning or end of an expression, these match the beginning and end of a line of text, respectively.</p><p>For example:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression: /^Mary/<span></span></pre></td></tr><tr><td scope="row"><pre>grep "^Mary" &lt; poem.txt<span></span></pre></td></tr></table></div><p>This matches the word "Mary", but only when it appears at the beginning of a line. Similarly, the following matches the word "fox," but only at the end of a line:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression: /fox$/<span></span></pre></td></tr><tr><td scope="row"><pre>grep "fox$" &lt; poem.txt<span></span></pre></td></tr></table></div><p>The other common technique for altering the matching behavior of a regular expression is through the use of flags. These flags, when placed at the end of a regular expression, can change whether a regular expression is allowed to match across multiple lines, whether the matching is case sensitive or insensitive, and various other aspects of matching.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW20" title="Note"></a><p><strong>Note:</strong>&nbsp;Different tools support different flags, and not all flags are supported with all tools. The <code>grep</code> command-line tool uses command-line flags instead of flags in the expression itself.</p></div><p>The most commonly used flag is the global flag. By default, only the first occurrence of a search term is matched. This is mainly of concern when performing substitutions. The global flag changes this so that a substitution alters every match in the line instead of just the first one.</p><p>For example:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression: s/Mary/Joe/<span></span></pre></td></tr><tr><td scope="row"><pre>sed "s/Mary/Joe/" &lt; poem.txt<span></span></pre></td></tr></table></div><p>This replaces only the first occurrence of "Mary" with "Joe." By adding the global flag to the expression, it instead replaces every occurrence, as shown in the following example:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression s/Mary/Joe/g<span></span></pre></td></tr><tr><td scope="row"><pre>sed "s/Mary/Joe/g" &lt; poem.txt<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004268-CH238-SW3" title="Wildcards and Repetition Operators"></a><h2>Wildcards and Repetition Operators</h2><p><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_318"></a>One of the most common ways to enhance searching through regular expressions is with the use of wildcard matching.</p><p>A wildcard is a symbol that takes the place of any other symbol. In regular expressions, a period (<code><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_319"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_320"></a>.</code>) is considered a wildcard, as it matches any single character. For example:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression: /wa./<span></span></pre></td></tr><tr><td scope="row"><pre>grep 'wa.' poem.txt<span></span></pre></td></tr></table></div><p>This matches lines containing both "was" and "want" because the dot can match any character.</p><p>Wildcards are typically combined with <a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_321"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_322"></a>repetition operators to match lines in which only a portion of the content is known. For example, you might want to search for every line containing "Mary" with the word "lamb" appearing later. You might specify the expression like this:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression: /Mary.*lamb/<span></span></pre></td></tr><tr><td scope="row"><pre>grep "Mary.*lamb" poem.txt<span></span></pre></td></tr></table></div><p>This searches for Mary followed by zero or more characters, followed by lamb.</p><p>Of course, you probably want at least one character between those to avoid matches for strings containing "Marylamb". The most common way to solve this is with the plus (<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_323"></a><code>+</code>) operator. However, you can construct this expression in several ways:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression (Basic): /Mary.\+lamb/<span></span></pre></td></tr><tr><td scope="row"><pre># Expression (Extended): /Mary.+lamb/<span></span></pre></td></tr><tr><td scope="row"><pre># Expression: /Mary..*lamb/<span></span></pre></td></tr><tr><td scope="row"><pre>grep "Mary.\+lamb" poem.txt<span></span></pre></td></tr><tr><td scope="row"><pre>grep -E "Mary.+lamb" poem.txt    # extended regexp<span></span></pre></td></tr><tr><td scope="row"><pre>grep "Mary..*lamb" poem.txt<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW21" title="Note"></a><p><strong>Note:</strong>&nbsp;The appearance of the plus operator differs depending on whether you are using basic or extended regular expressions; in basic regular expressions, it must be preceded by a backslash.</p></div><p>The first dot in the third expression matches a single character. The dot-asterisk afterwards matches be zero or more additional characters. Thus, these three statements are equivalent.</p><p>The final useful repetition operator is the question mark operator (<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_324"></a><code>?</code>). This operator matches zero or one repetitions of whatever precedes it.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW22" title="Note"></a><p><strong>Note:</strong>&nbsp;Like the plus operator, this differs in appearance depending on whether you are using basic or extended regular expressions; in basic regular expressions, it must be preceded by a backslash.</p></div><p>For example, if you want to match both Mary and Marry, you might use an expression like this:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression (Basic): /Marr\?y/<span></span></pre></td></tr><tr><td scope="row"><pre># Expression (Extended): /Marr?y/<span></span></pre></td></tr><tr><td scope="row"><pre>grep "Marr\?y" poem.txt<span></span></pre></td></tr><tr><td scope="row"><pre>grep -E "Marr?y" poem.txt<span></span></pre></td></tr></table></div><p>The question mark causes the preceding r to be optional, and thus, this expression matches lines containing either “Mary” or “Marry.”</p><p>In summary, the basic wildcard and repetition operators are:</p><ul class="simple"><li><p>period (<code>.</code>)—wildcard; matches a single character.</p></li><li><p>question mark (<code>\?</code> or <code>?</code>)—matches 0 or 1 of the previous character, grouping, or wildcard. (This operator differs depending on whether you are using basic or extended regular expressions.)</p></li><li><p>asterisk(<code>*</code>)—matches zero or more of the previous character, grouping, or wildcard.</p></li><li><p>plus(<code>\+</code> or <code>+</code>)—matches one or more of the previous character, grouping, or wildcard. (This operator differs depending on whether you are using basic or extended regular expressions.)<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_325"></a></p></li></ul><a name="//apple_ref/doc/uid/TP40004268-CH238-SW10" title="Character Classes and Groups"></a><h2>Character Classes and Groups</h2><p>Searching for certain keywords can be useful, but it is often not enough. It is often useful to search for the presence or absence of key characters at a given position in a search string.</p><p>For example, assume that you require the words Mary and lamb to be within the same sentence. To do this, you need to only allow certain characters to appear between the two words. This can be achieved through the use of character classes.</p><p>There are two basic types of <a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_326"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_327"></a>character classes: predefined character classes and custom, or user-defined character classes. These are described in the following sections.</p><a name="//apple_ref/doc/uid/TP40004268-CH238-SW11" title="Predefined Character Classes"></a><h3>Predefined Character Classes</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_328"></a>Most regular expression languages support some form of predefined character classes. When used between brackets, these define commonly used sets of characters.</p><ul class="simple"><li><p><code>:alnum:</code>—all alphanumeric characters (a-z, A-Z, and 0-9).</p></li><li><p><code>:cntrl:</code>—all control characters (ASCII 0-31).</p></li><li><p><code>:lower:</code>—all lowercase letters (a-z).</p></li><li><p><code>:space:</code>—all whitespace characters (space, tab, newline, carriage return, form feed, and vertical tab).</p></li><li><p><code>:alpha:</code>—all alphabetic characters (a-z, A-Z).</p></li><li><p><code>:digit:</code>—all numbers.</p></li><li><p><code>:print:</code>—all printable characters (opposite of :cntrl:).</p></li><li><p><code>:upper:</code>—all uppercase letters.</p></li><li><p><code>:blank:</code>—all whitespace within a line (spaces or tabs).</p></li><li><p><code>:graph:</code>—all alphanumeric or punctuation characters.</p></li><li><p><code>:punct:</code>—all punctuation characters</p></li><li><p><code>:xdigit:</code>—all hexadecimal digits (0-9, a-f, A-F).</p></li></ul><p>For example, the following is another way to match any sentence containing Mary and lamb:</p>
<div class="codesample"><table><tr><td scope="row"><pre>/Mary[:alpha::digit::blank:][:alpha::digit::blank:]*lamb/<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_329"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-SW12" title="Custom Character Classes"></a><h3>Custom Character Classes</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_330"></a>In addition to the predefined character classes, regular expression languages also allow custom, user-defined character classes. These custom character classes just look like a list of characters surrounded by square brackets<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_331"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_332"></a>.</p><p>For example, if you only want to allow spaces and letters, you might create a character class like this one:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression: /Mary[a-z A-Z]*lamb/<span></span></pre></td></tr><tr><td scope="row"><pre>grep "Mary[a-z A-Z]*lamb" poem.txt<span></span></pre></td></tr></table></div><p>In this example, there are two ranges (‘<code>a</code>’ through ‘<code>z</code>’ and ‘<code>A</code>’ through ‘<code>Z</code>’) allowed, as well as the space character. Thus, any letter or space matches this pattern, but other things (including the period character) do not. Thus, this line matches the first line of the poem, but does not match the later line that begins with "Mary was married."</p><p>However, this pattern also did not match the line containing a comma, which was not really the intent. Listing every reasonable range of characters with a single omission would be prohibitively large, particularly if you want to include high ASCII characters, control characters, and other potentially unprintable characters.</p><p>Fortunately, there is another special operator, the caret (<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_333"></a><code>^</code>). When placed as the first character of a character class, matching is reversed. Thus, the following expression matches any character other than a period:</p>
<div class="codesample"><table><tr><td scope="row"><pre># /Mary[^.]*lamb/<span></span></pre></td></tr><tr><td scope="row"><pre>grep "Mary[^.]*lamb" poem.txt<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_334"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-SW13" title="Grouping Operators"></a><h3>Grouping Operators</h3><p>As mentioned previously, regular expressions also have a notion of grouping. The purpose of grouping is to treat multiple characters as a single entity, usually for the purposes of modifying that entity with a repeat operator. This grouping is done using parentheses or quoted <a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_335"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_336"></a>parentheses, depending on the regular expression dialect being used.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW23" title="Note"></a><p><strong>Note:</strong>&nbsp;The syntax for grouping also results in a capture. This process is described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW1">“Capturing Operators and Variables.”</a></span></p></div><p>For example, say that you want to search for any string that contains the word “Mary” followed optionally by the word “had", followed by the word “a”. You might write this expression like this:</p>
<div class="codesample"><table><tr><td scope="row"><pre>#Expression (Basic): /Mary \(had \)\?a/<span></span></pre></td></tr><tr><td scope="row"><pre>#Expression (Extended): /Mary (had )?a/<span></span></pre></td></tr><tr><td scope="row"><pre>grep "Mary \(had \)\?a" poem.txt<span></span></pre></td></tr><tr><td scope="row"><pre>grep -E "Mary (had )?a" poem.txt<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW24" title="Note"></a><p><strong>Note:</strong>&nbsp;The grouping operator and optional operator differ depending on which program is processing the regular expression. The tools <code><a href="../../../../Darwin/Reference/ManPages/man1/sed.1.html#//apple_ref/doc/man/1/sed" target="_top">sed</a></code>, <code><a href="../../../../Darwin/Reference/ManPages/man1/awk.1.html#//apple_ref/doc/man/1/awk" target="_top">awk</a></code>, and <code><a href="../../../../Darwin/Reference/ManPages/man1/grep.1.html#//apple_ref/doc/man/1/grep" target="_top">grep</a></code> use basic regular expressions (by default), and thus, these operators must be quoted. Any tools that use extended regular expressions use the bare operators.</p>Also note that the <code>-E</code> flag enables extended regular expressions in <code>grep</code>.</p>The flag to enable extended regular expressions in <code>sed</code> differs among different versions of the tool. For this reason, you should use basic regular expressions if at all possible when working with <code>sed</code>.</p></div><p>You can also use the grouping syntax to provide multiple options, any one of which is treated as a match. Expressions enclosed in parentheses match any one of a series of smaller expressions separated by a pipe (<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_337"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_338"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_339"></a><code>|</code>) operator. For example, to search for Mary, lamb, or had, you might use this expression:</p>
<div class="codesample"><table><tr><td scope="row"><pre>#Expression (Basic): /\(Mary\|had\|lamb\)/<span></span></pre></td></tr><tr><td scope="row"><pre>#Expression (Extended): /(Mary|had|lamb)/<span></span></pre></td></tr><tr><td scope="row"><pre>grep '\(Mary\|had\|lamb\)' poem.txt<span></span></pre></td></tr><tr><td scope="row"><pre>grep -E '(Mary|had|lamb)' poem.txt<span></span></pre></td></tr></table></div><p>Because regular expressions generally match from left to right, you should be careful when working with multiple options that are substrings of one another during substitution and be sure to place the larger of the possible matches first. Some regular expression engines always take the longer match, while other regular expression engines always take the leftmost match.<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_340"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_341"></a></p><p>For example, the following lines give the same result:</p><div class="codesample"><table><tr><td scope="row"><pre>sed -E 's/(lamb|lamb,)/orange/' poem.txt<span></span></pre></td></tr><tr><td scope="row"><pre>sed -E 's/(lamb,|lamb)/orange/' poem.txt<span></span></pre></td></tr></table></div><p>However the following lines do not:</p><div class="codesample"><table><tr><td scope="row"><pre>perl -pi.bak -e 's/(lamb|lamb,)/orange/' &lt; poem.txt<span></span></pre></td></tr><tr><td scope="row"><pre>perl -pi.bak -e 's/(lamb,|lamb)/orange/' &lt; poem.txt<span></span></pre></td></tr></table></div><p>In Perl, when the input contains the word “lamb” followed by a comma, the regular expression engine matches the word “lamb” first because it is the leftmost option. It replaces it with the word “orange” and leaves the comma. In the second option, because the version with a comma matches first, the comma is deleted if it is there.</p><p>You can, of course, also avoid this problem by writing the expression as:</p><div class="codesample"><table><tr><td scope="row"><pre>perl -pi.bak -e 's/lamb,?/orange/' &lt; poem.txt<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004268-CH238-SW14" title="Using Empty Subexpressions"></a><h3>Using Empty Subexpressions</h3><p>Sometimes, when working with groups, you may find it necessary to include an optional group. It may be tempting to write such an expression like this:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression (Extended): /const(ant|ellation|) (.*)/<span></span></pre></td></tr></table></div><p>In an odd quirk, however, some command-line tools do not appreciate an <a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_342"></a>empty subexpression. There are two ways to solve this.</p><p>The easiest way is to make the entire group optional like this:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression (Extended): /const(ant|ellation)? (.*)/<span></span></pre></td></tr><tr><td scope="row"><pre>grep -E 'const(ant|ellation)? (.*)'<span></span></pre></td></tr></table></div><p>Alternately, an empty expression may be inserted after the vertical bar.</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression (Extended): /const(ant|ellation|()) (.*)/<span></span></pre></td></tr><tr><td scope="row"><pre>grep -E "const(ant|ellation|()) (.*)" poem.txt<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW25" title="Note"></a><p><strong>Note:</strong>&nbsp;If you are mixing capturing with grouping, this method creates an empty capture, which ends up in the buffer following the capture buffer for this group (more on this in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW1">“Capturing Operators and Variables”</a></span>).</p></div><a name="//apple_ref/doc/uid/TP40004268-CH238-SW15" title="Quoting Special Characters"></a><h2>Quoting Special Characters</h2><p>As seen in previous sections, a number of characters have special meaning in regular expressions. For example, character classes are surrounded by square brackets, and the dash and caret characters have special meaning. You might ask how you can search for one of these characters. This is where <a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_343"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_344"></a>quoting comes in.</p><p>In regular expressions, certain nonletter characters may have some special meaning, depending on context. To treat these characters as an ordinary character, you can prefix them with a backslash character (<code>\</code>). This also means that the backslash character is special in any context, so to match a literal backslash character, you must quote it with a second backslash.</p><p>There is one exception, however. To make a close bracket be a member of a character class, you do not quote it. Instead, you make it be the first character in the class.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW26" title="Note"></a><p><strong>Note:</strong>&nbsp;Perl rules for extended regular expressions allow you to quote a close bracket anywhere within a character class. Perl also recognizes the syntax shown here, however.</p></div><p>For example, to search for any string containing a backslash or a close bracket, you might use the following regular expression:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression: /[]\\]/<span></span></pre></td></tr><tr><td scope="row"><pre>grep '[]\\]' poem.txt<span></span></pre></td></tr></table></div><p>It looks a bit cryptic, but it is really relatively straightforward. The outer slashes delimit the regular expression. The brackets immediately inside the outer slashes are character class delimiters. The first close bracket immediately follows the open bracket, which makes it match an actual close bracket character instead of ending the character class. The two backslashes afterwards are, in fact, a quoted backslash, which makes this character class match the literal backslash character.</p><p>As a general rule, at least in extended regular expressions, any nonalphanumeric character can safely be quoted whether it is necessary to do so or not. If quoting it is not necessary, the extra backslash is simply ignored. However, it is not always safe to quote letters or numbers, as these have special meanings in certain regular expression dialects, as described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW1">“Capturing Operators and Variables”</a></span> and <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW2">“Perl and Python Extensions.”</a></span> In addition, quoting parentheses may not do what you might expect in some dialects, as described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW1">“Capturing Operators and Variables.”</a></span></p><p>In basic regular expressions the behavior when quoting characters other than parentheses, curly braces, numbers, and characters within a character class is undefined.</p><a name="//apple_ref/doc/uid/TP40004268-CH238-SW1" title="Capturing Operators and Variables"></a><h2>Capturing Operators and Variables</h2><p>In <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW3">“Wildcards and Repetition Operators,”</a></span> this chapter described ways to create more complicated patterns to match for the search portion of a search and replace operation. This section describes more powerful operations for the replacement portion of a search and replace operation.</p><p><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_345"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_346"></a>Capturing operators and variables are used to take pieces of the original input text, capture them while searching, and then substitute those bits into the middle of the replacement text.</p><p>The easiest way to explain capturing operators and <a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_347"></a>variables is by example. Suppose you want to swap the words quick and lazy in the string, "The quick brown fox jumped over the lazy dog." You might write an expression like this:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression (Basic): s/The \(.*\) brown \(.*\) the \(.*\) dog/The \3 brown \2 the \1 dog/<span></span></pre></td></tr><tr><td scope="row"><pre># Expression (Extended): s/The (.*) brown (.*) the (.*) dog/The \3 brown \2 the \1 dog/<span></span></pre></td></tr></table></div><p>When you pass these expressions to <code><a href="../../../../Darwin/Reference/ManPages/man1/sed.1.html#//apple_ref/doc/man/1/sed" target="_top">sed</a></code>, the last line of <code>poem.txt</code> should become "The lazy brown fox jumped over the quick dog."</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression (Basic): s/The (.*) brown (.*) the (.*) dog/The \3 brown \2 the \1 dog/<span></span></pre></td></tr><tr><td scope="row"><pre>sed "s/The \(.*\) brown \(.*\) the \(.*\) dog/The \3 brown \2 the \1 dog/" &lt; poem.txt<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Expression (Extended): s/The \(.*\) brown \(.*\) the \(.*\) dog/The \3 brown \2 the \1 dog/<span></span></pre></td></tr><tr><td scope="row"><pre>sed -E "s/The (.*) brown (.*) the (.*) dog/The \3 brown \2 the \1 dog/" &lt; poem.txt<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Perl supports extended form, but also supports<span></span></pre></td></tr><tr><td scope="row"><pre># using a dollar sign for the variable name.  (Note<span></span></pre></td></tr><tr><td scope="row"><pre># the use of single quotes to prevent the shell from<span></span></pre></td></tr><tr><td scope="row"><pre># doing variable substitution on $1, $2, and $3.)<span></span></pre></td></tr><tr><td scope="row"><pre>perl -pi.bak -e "s/The (.*) brown (.*) the (.*) dog/The \3 brown \2 the \1 dog/" &lt; poem.txt<span></span></pre></td></tr><tr><td scope="row"><pre>perl -pi.bak -e 's/The (.*) brown (.*) the (.*) dog/The $3 brown $2 the $1 dog/' &lt; poem.txt<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW27" title="Note"></a><p><strong>Note:</strong>&nbsp;The syntax of the capturing operator differs depending on whether you are using basic, extended, or Perl regular expressions.</p></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW28" title="Compatibility Note"></a><p><strong>Compatibility Note:</strong>&nbsp;The use of the <code>-E</code> flag with <code>sed</code> to enable extended regular expressions varies from one operating system to another. For maximum portability, you should avoid using extended regular expressions with <code>sed</code>.</p></div><p>The content between each pair of parentheses (in this case—see note) is captured into its own buffer, numbered consecutively. Thus, in this expression, the content between “the” and “brown” is captured into a buffer. Then, the content between “brown” and “the” is captured. Finally, the content between “the” and “dog” is captured.</p><p>In the replacement string, the delimiter words (“The”, “brown”, “the”, and “dog”) are inserted, and the contents of the capture buffers are inserted in the opposite order.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW29" title="Note"></a><p><strong>Note:</strong>&nbsp;By default, repetition operators (except the question mark operator) are greedy. By default, they match the longest possible string that matches the expression as a whole. For example:</p>
<div class="codesample"><table><tr><td scope="row"><pre># s/Mary.*lamb/Joe/<span></span></pre></td></tr><tr><td scope="row"><pre>sed "s/Mary.*lamb/Joe/" &lt; poem.txt<span></span></pre></td></tr></table></div>In the poem, the line “Mary had a lamb looked like a lamb.” becomes simply “Joe.”.</p>If you want to only match up to the <em>first</em> occurrence of “lamb”, you must either use a Perl regular expression dialect extension, as described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW6">“Nongreedy Wildcard Matching”</a></span> or use a greedy regular expression from the other end of the string to replace the word “lamb” with another word that is known to not occur elsewhere in the input.</p>For example:</p><div class="codesample"><table><tr><td scope="row"><pre>sed 's/lamb\(.*\)$/UNMATCHABLE\1/' &lt; poem.txt | sed 's/^.*UNMATCHABLE/Joe/'<span></span></pre></td></tr></table></div>This statement produces the line “Joe looked like a lamb.”</p></div><a name="//apple_ref/doc/uid/TP40004268-CH238-SW16" title="Mixing Capturing and Grouping Operators"></a><h2>Mixing Capturing and Grouping Operators</h2><p>Since parentheses serve both as capturing and grouping operators, use of grouping may result in <a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_348"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_349"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_350"></a>unexpected consequences when capturing text in the same expression. For example, the following expression will behave very differently depending on input:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression /const(ant)? (.*)/<span></span></pre></td></tr></table></div><p>The text you probably intended to capture is in the second buffer, not the first.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW30" title="Note"></a><p><strong>Note:</strong>&nbsp;In the Perl version of extended regular expressions (as described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW8">“Noncapturing Parentheses”</a></span>), you can use noncapturing parentheses to prevent the capture of the first portion, as show below:</p>
<div class="codesample"><table><tr><td scope="row"><pre>/const(?:ant)? (.*)/<span></span></pre></td></tr></table></div>However, if you are using most command-line tools, this extended syntax is not supported.<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_351"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_352"></a></p></div><a name="//apple_ref/doc/uid/TP40004268-CH238-SW17" title="Using Modifiers"></a><h2>Using Modifiers</h2><p><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_353"></a>The overall behavior of a regular expression can be tuned using a number of modifiers. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>/foo/i<span></span></pre></td></tr></table></div><p>In this example, the <code>/i</code> modifier makes the regular expression match in a case-insensitive fashion. Thus, this matches both “Foo” and “fOo”.</p><p>Not all commands and languages support all modifiers. For example, most versions of the <code><a href="../../../../Darwin/Reference/ManPages/man1/sed.1.html#//apple_ref/doc/man/1/sed" target="_top">sed</a></code> command support only the <code>/g</code> modifier.</p><p>The basic modifiers are:</p><ul class="ul"><li class="li"><p><code>/g</code>—replace globally. Without this flag, a substitution command replaces only the first matching occurrence per line. With this flag, a substitution command also replaces subsequent matches.</p></li><li class="li"><p><code>/i</code>—use case insensitive matching (Perl extension; equivalent to <code>grep -i</code>).</p></li><li class="li"><p><code>/m</code>—multiline matching (Perl extension). the <code>$</code> and <code>^</code> anchors should match at newline boundaries in addition to matching at the beginning an end of the string as a whole. The dot (<code>.</code>) does not match newline characters.</p></li><li class="li"><p><code>/o</code>—compile once (Perl extension). In Perl, if a regular expression includes a variable as part of the pattern, the regular expression engine must recompile the expression every time it is used because the variable contents might have changed. </p><p>If you know that the contents will not change after they are set the first time, the <code>/o</code> flag disables recompilation of the expression. For regular expressions that do not contain variables, this switch has no effect.</p></li><li class="li"><p><code>/s</code>—single-line matching (Perl extension). The <code>$</code> and <code>^</code> anchors should <em>not</em> match at newline boundaries. With this modifier, they only match at the very beginning and end of the string as a whole. The dot (<code>.</code>) matches newline characters just like any other character.</p></li><li class="li"><p><code>/x</code>—extend readability (Perl extension). This mode causes matching to ignore all whitespace between tokens in the expression unless quoted or wrapped in brackets (in most languages) and to treat a hash mark (<code>#</code>) as the start of a single-line comment.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW31" title="Note"></a><p><strong>Note:</strong>&nbsp;Not all whitespace is ignored; multicharacter tokens like <code>\d</code> must not be split or they will be interpreted differently.</p></div><p>The purpose of this mode is to allow you to split complex regular expressions into multiple lines. For example, in Perl, you might detect a date like this:</p><div class="codesample"><table><tr><td scope="row"><pre>if ($foo =~ /(\d\d\d\d) # year<span></span></pre></td></tr><tr><td scope="row"><pre>    \s*-\s* # separator<span></span></pre></td></tr><tr><td scope="row"><pre>    (\d\d) # month<span></span></pre></td></tr><tr><td scope="row"><pre>    \s*-\s* # separator<span></span></pre></td></tr><tr><td scope="row"><pre>    (\d\d) # day<span></span></pre></td></tr><tr><td scope="row"><pre>    /x) {<span></span></pre></td></tr><tr><td scope="row"><pre>        print "Date detected\n";<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The syntactical details vary from language to language.</p></li></ul><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_354"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-SW2" title="Perl and Python Extensions"></a><h2>Perl and Python Extensions</h2><p><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_355"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_356"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_357"></a>The regular expression dialect used in Perl, Python, and many other languages, are a further extension of extended regular expressions. Some of the major differences include:</p><ul class="ul"><li class="li"><p>Addition of shortcuts for character classes. See <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW5">“Character Class Shortcuts.”</a></span></p></li><li class="li"><p>Addition of quotation operators. In a regular expression, the contents of variables appearing between <code>\Q</code> and <code>\E</code> are automatically quoted, and thus treated as literal text even if the variable contains characters that ordinarily have special meaning in a regular expression. These operators are useful when user input, stored in a Perl variable, is used as part of a regular expression.</p></li><li class="li"><p>Support for retrieving captured values outside the scope of the expression; the captured values are stored in the variables <code>$1</code>, <code>$2</code>, and so on. (See <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW1">“Capturing Operators and Variables”</a></span> for information about capturing parts of a regular expression.)</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW32" title="Note"></a><p><strong>Note:</strong>&nbsp;In PHP, these captured values are passed back in an array that you can provide as an optional argument.</p></div></li><li class="li"><p>Addition of nongreedy matching. See <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW6">“Nongreedy Wildcard Matching”</a></span> for more information.</p></li><li class="li"><p>Noncapturing parentheses. See <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW8">“Noncapturing Parentheses”</a></span> for more information.</p></li></ul><p>You can find links to additional resources that describe these extensions in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW34">“For More Information.”</a></span></p><a name="//apple_ref/doc/uid/TP40004268-CH238-SW5" title="Character Class Shortcuts"></a><h3>Character Class Shortcuts</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_358"></a>Perl regular expressions add a number of additional character class shortcuts. Some of these are listed below:</p><ul class="simple"><li><p><code>\A</code>—anchors matching to the beginning of the string as a whole (but not the beginning of lines within the string).</p><p>This shortcut is not broadly supported outside of Perl. In other languages, use <code>^</code> and add the <code>/s</code> modifier (or do not specify the <code>/m</code> modifier, depending) to specify line-at-once matching.</p></li><li><p><code>\b</code>—word boundary (see note).</p></li><li><p><code>\B</code>—nonword boundary (see note).</p></li><li><p><code>\d</code>—equivalent to [:digit:].</p></li><li><p><code>\D</code>—equivalent to [^:digit:].</p></li><li><p><code>\f</code>—form feed.</p></li><li><p><code>\n</code>—newline.</p></li><li><p><code>\p</code>—character matching a Unicode character property that follows. For example, <code>\p{L}</code> matches a Unicode letter.</p></li><li><p><code>\P</code>—character not matching a Unicode property that follows. For example, <code>\P{L}</code> matches any Unicode character that is not a letter.</p></li><li><p><code>\r</code>—carriage return.</p></li><li><p><code>\s</code>—equivalent to [:space:].</p></li><li><p><code>\S</code>—equivalent to [^:space:].</p></li><li><p><code>\t</code>—tab.</p></li><li><p><code>\u</code>—a single Unicode character in JavaScript regular expressions. This shortcut must be followed by four hexadecimal digits.</p></li><li><p><code>\v</code>—vertical tab.</p></li><li><p><code>\w</code>—equivalent to [:word:].</p></li><li><p><code>\W</code>—equivalent to [^:word:].</p></li><li><p><code>\x</code>—start of an ASCII character code (in hex). For example, \x20 is a space.</p></li><li><p><code>\X</code>—a single Unicode character (not supported universally). This shortcut must be followed by four hexadecimal digits.</p></li><li><p><code>\z</code>—anchors matching to the end of the string as a whole (but not the end of lines within the string).</p><p>This shortcut is not broadly supported outside of Perl. In other languages, use <code>$</code> and add the <code>/s</code> modifier (or do not specify the <code>/m</code> modifier, depending) to specify line-at-once matching.</p></li><li><p><code>\Z</code>—anchors matching to the end of the string as a whole (but not the end of lines within the string). In some languages (including Perl), this matches prior to the closing line break if the string ends with a line break. To avoid this, use <code>\z</code> instead.</p><p>This shortcut is not broadly supported outside of Perl. In other languages, use <code>$</code> and add the <code>/s</code> modifier to specify line-at-once matching.</p></li></ul><p>These can be used anywhere on the left side of a regular expression, including within character classes.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH238-SW33" title="Note"></a><p><strong>Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_359"></a>Word boundaries (the <code>\b</code> and <code>\B</code> switches) do not exist in basic or non-Perl extended regular expressions. These match the position between two characters rather than an actual character.</p>A word boundary occurs before the first character of a line (if it is a word character), at the end of the line (if it ends in a word character), and between any word character and nonword character that occur consecutively.</p>For substitution purposes, “replacing” a word boundary with text is equivalent to inserting that text, much like replacing other anchors such as <code>^</code> or <code>$</code>.<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_360"></a></p></div><a name="//apple_ref/doc/uid/TP40004268-CH238-SW6" title="Nongreedy Wildcard Matching"></a><h3>Nongreedy Wildcard Matching</h3><p>By default, repeat operators are greedy<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_361"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_362"></a>, matching as many times as possible before attempting to match the next part of the string. This will generally result in the longest possible string that matches the expression as a whole. In some cases, you may want the matching to stop at the shortest possible string that matches the entire expression.</p><p>To support this, Perl regular expressions (along with many other dialects) supports nongreedy wildcard matching. To convert a greedy repeat operator to a <a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_363"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_364"></a>nongreedy repeat operator, you just add a question mark after it.</p><p>For example, consider the nursery rhyme “Mary had a little lamb, its fleece was white as snow, and everywhere that Mary went, the lamb was sure to go.” Assume that you apply the following expression:</p>
<div class="codesample"><table><tr><td scope="row"><pre>/Mary.*lamb/<span></span></pre></td></tr></table></div><p>That expression matches “Mary had a little lamb, its fleece was white as snow, and everywhere that Mary went, the lamb”.</p><p>Suppose that instead, you want to find the shortest possible string beginning with “Mary” and ending with “lamb”. You might instead use the following expression:</p>
<div class="codesample"><table><tr><td scope="row"><pre>/Mary.*?lamb/<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_365"></a><span></span></pre></td></tr></table></div><p>That expression matches only the words “Mary had a little lamb”. The <a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_366"></a><code>+?</code> operator behaves similarly.</p><a name="//apple_ref/doc/uid/TP40004268-CH238-SW8" title="Noncapturing Parentheses"></a><h3>Noncapturing Parentheses</h3><p>You may notice that the syntax for capture is identical to the syntax for grouping described in <span class="content_text"><a href="RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW3">“Wildcards and Repetition Operators.”</a></span> In most cases, the additional captures are not a problem. However, in some cases (particularly when splitting strings into arrays in Perl), you may wish to avoid <a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_367"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_368"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_369"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_370"></a>capturing content if you are using parentheses merely as a grouping tool.</p><p>To turn off capturing for a given set of parentheses, add a question mark followed by a colon after the open parenthesis.</p><p>Consider the following example:</p>
<div class="codesample"><table><tr><td scope="row"><pre># Expression (Perl and Similar ONLY): /Mary (?:had)* a little lamb\./<span></span></pre></td></tr><tr><td scope="row"><pre>perl -pi.bak -e "s/Mary (?:had )*a little lamb\./Lovely day, isn't it?/" &lt; poem.txt<span></span></pre></td></tr></table></div><p>This expression matches “Mary”, followed by zero (0) or more instances of “had” followed by “a little lamb”, followed by a literal period, and replaces the offending line (“Mary had had a little lamb.”) with “Lovely day, isn't it?”.</p><a name="//apple_ref/doc/uid/TP40004268-CH238-SW34" title="For More Information"></a><h3>For More Information</h3><p>This chapter covers regular expressions as they apply to shell scripts. While it covers some of the more interesting extensions provided by languages such as Perl, it is by no means a complete reference to Perl regular expressions.</p><p>For a thorough explanation of Perl <a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_371"></a>regular expressions and additional features and quirks in various programming languages, see <span class="content_text"><a href="http://perldoc.perl.org/perlre.html" target="_blank">http://perldoc.perl.org/perlre.html</a></span> and <span class="content_text"><a href="http://www.regular-expressions.info/" target="_blank">http://www.regular-expressions.info/</a></span>.<a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_372"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_373"></a><a name="//apple_ref/doc/uid/TP40004268-CH238-DontLinkElementID_374"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../PaintbyNumbers/PaintbyNumbers.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Howawk-ward/Howawk-ward.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-04-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/OpenSource/Conceptual/ShellScripting/RegularExpressionsUnfettered/RegularExpressionsUnfettered.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/OpenSource/Conceptual/ShellScripting/RegularExpressionsUnfettered/RegularExpressionsUnfettered.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/OpenSource/Conceptual/ShellScripting/RegularExpressionsUnfettered/RegularExpressionsUnfettered.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>