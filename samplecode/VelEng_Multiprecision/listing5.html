<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>VelEng Multiprecision - /vfactor source/vecarith.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Performance/index.html">Performance</a> &gt; <a href="../../samplecode/Performance/idxVelocityEngine-date.html">Velocity Engine</a> &gt; <A HREF="javascript:location.replace('index.html');">VelEng Multiprecision</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">VelEng Multiprecision</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/vfactor source/vecarith.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/vfactor source/factor.c</option>
<option value="listing2.html">/vfactor source/giantsdebug.h</option>
<option value="listing3.html">/vfactor source/giantsstack.c</option>
<option value="listing4.html">/vfactor source/giantsstack.h</option>
<option value="listing5.html">/vfactor source/vecarith.c</option>
<option value="listing6.html">/vfactor source/vecarith.h</option>
<option value="listing7.html">/vfactor source/vecarith.s</option>
<option value="listing8.html">/vfactor source/vgiants.c</option>
<option value="listing9.html">/vfactor source/vgiants.h</option></select>
				</p>
				</form>
				<p><strong><a href="VelEng_Multiprecision.zip">Download Sample</a></strong> (&#147;VelEng_Multiprecision.zip&#148;, 229.5K)<BR>
<strong><a href="VelEng_Multiprecision.dmg">Download Sample</a></strong> (&#147;VelEng_Multiprecision.dmg&#148;, 308.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/************************************************************** * *  vecarith.c * *  Routines for AltiVec-based giant arithmetic. * * *  This package is part of ongoing research in the *  Advanced Computation Group, Apple Computer. *   *  c. 1999 Apple Computer, Inc. *  All Rights Reserved. * * *************************************************************//*  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your        use, installation, modification or redistribution of this Apple software        constitutes acceptance of these terms.  If you do not agree with these terms,        please do not use, install, modify or redistribute this Apple software.        In consideration of your agreement to abide by the following terms, and subject        to these terms, Apple grants you a personal, non-exclusive license, under Apple's        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,        reproduce, modify and redistribute the Apple Software, with or without        modifications, in source and/or binary forms; provided that if you redistribute        the Apple Software in its entirety and without modifications, you must retain        this notice and the following text and disclaimers in all such redistributions of        the Apple Software.  Neither the name, trademarks, service marks or logos of        Apple Computer, Inc. may be used to endorse or promote products derived from the        Apple Software without specific prior written permission from Apple.  Except as        expressly stated in this notice, no other rights or licenses, express or implied,        are granted by Apple herein, including but not limited to any patent rights that        may be infringed by your derivative works or by other works in which the Apple        Software may be incorporated.        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN        COMBINATION WITH YOUR PRODUCTS.        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.*/#include &quot;vecarith.h&quot;#define GENERATE_CONSTANTS 1    // build constants using vec ops. or load themvoid VecMult(            vector unsigned long *pVec1,                  unsigned long  len1,                  vector unsigned long *pVec2,                  unsigned long  len2,                  vector unsigned long *pResult){  ////////////////////////////////////////////////////////////////////  // index for current column of parallelogram that we are  // summing products for  ////////////////////////////////////////////////////////////////////  unsigned long        columnIndex;  ////////////////////////////////////////////////////////////////////  // pointers to short and long arrays of vector digits  ////////////////////////////////////////////////////////////////////    vector unsigned long    *pLongSrc, *pShortSrc;  ////////////////////////////////////////////////////////////////////  // short and long count of 128-bit digits in arguments  ////////////////////////////////////////////////////////////////////    unsigned long         shortcount, longcount;  ////////////////////////////////////////////////////////////////////  // hi and lo vectors for sum of products for current column  ////////////////////////////////////////////////////////////////////    vector unsigned long    sumlo     = (vector unsigned long)(0);  vector unsigned long     sumhi     = (vector unsigned long)(0);  ////////////////////////////////////////////////////////////////////  // carry from sums in current column that carry over into next  // column.  ////////////////////////////////////////////////////////////////////  vector unsigned long    carryNext   = (vector unsigned long)(0);  ////////////////////////////////////////////////////////////////////  // all-purpose zero register  ////////////////////////////////////////////////////////////////////  vector unsigned long      zero     = (vector unsigned long)(0);  ////////////////////////////////////////////////////////////////////  // permute vectors for selecting multiplicand vectors for  // msum operation  ////////////////////////////////////////////////////////////////////  vector unsigned char     switchByteSelectorLo;    vector unsigned char     switchByteSelectorHi;    vector unsigned char     staggeredSumPermuterEven;  vector unsigned char     staggeredSumPermuterOdd;    ////////////////////////////////////////////////////////////////////  // pointers for convolution of vectors for partial products  ////////////////////////////////////////////////////////////////////  vector unsigned long    *pIncrementer;  vector unsigned long    *pDecrementer;  ////////////////////////////////////////////////////////////////////  // bounds from which vector pointers start for column  ////////////////////////////////////////////////////////////////////  vector unsigned long    *pLongBound;  vector unsigned long    *pShortBound;  ////////////////////////////////////////////////////////////////////  // count of how many 128-bit products are summed in the current  // column.  ////////////////////////////////////////////////////////////////////  unsigned long        productCount;  ////////////////////////////////////////////////////////////////////  // figure out which vector is longer, and set up some counters  // and pointers based on lengths.  ////////////////////////////////////////////////////////////////////  if (len1 &gt; len2) {    pLongSrc  = pVec1;    pShortSrc   = pVec2;    longcount   = len1;    shortcount   = len2;  } else {    pLongSrc   = pVec2;    pShortSrc   = pVec1;    longcount   = len2;    shortcount   = len1;    }  ////////////////////////////////////////////////////////////////////  //  //          ********************  //          ** IMPORTANT NOTE **  //          ********************  //  // if there are more than 16384 products in a column to be added  // together, then our carry calculation will overflow.  Note that  // this will only occur if one of the multiplicands is over two  // million bits long.  If this situation needs to be handled, an  // enhanced carry overflow calculation will have to be employed.  //  ////////////////////////////////////////////////////////////////////  if (longcount &gt; 16384) {    //DebugStr(&quot;\pvector multiply overflow&quot;);  }  ////////////////////////////////////////////////////////////////////  // start bounds pointing at least significant vector of multiplicand  // vector arrays.  First column has only one product.  ////////////////////////////////////////////////////////////////////  pLongBound =  pLongSrc;  pShortBound =   pShortSrc;  ////////////////////////////////////////////////////////////////////  // first (rightmost) column has only one product  ////////////////////////////////////////////////////////////////////  productCount =  1;  ////////////////////////////////////////////////////////////////////  // clear all result vectors to zero  ////////////////////////////////////////////////////////////////////  for (columnIndex = 0; columnIndex &lt; shortcount + longcount; columnIndex++) {    pResult[columnIndex] = (vector unsigned long)(0);  }  ////////////////////////////////////////////////////////////////////  //  Load or generate some constants that are needed for some  // of the vector manipulations that are performed in the multiplies  ////////////////////////////////////////////////////////////////////#if GENERATE_CONSTANTS    ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterOdd = 00 01 02 03 10 11 12 13 ...  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterOdd =     (vector unsigned char)vec_mergeh(                    (vector unsigned long)vec_lvsl(0, (unsigned long*)0),                    (vector unsigned long)vec_lvsr(0, (unsigned long*)0));    ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterEven = 08 09 0a 0b 18 19 1a 1b ...  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterEven  = vec_add(vec_splat_u8(8), staggeredSumPermuterOdd);  ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterOdd = 00010203 08090a0b 10111213 18191a1b  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterOdd    = (vector unsigned char)vec_mergeh(                    (vector unsigned long)staggeredSumPermuterOdd,                    (vector unsigned long)staggeredSumPermuterEven);    ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterEven = 04050607 0c0d0e0f 14151617 1c1d1e1f  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterEven  = vec_add(vec_splat_u8(4), staggeredSumPermuterOdd);              ////////////////////////////////////////////////////////////////////  // We generate two permute vectors that are used to select the high  // and low bytes of the rightmost shorts in a vector.  For example,  // given the multiplicand vectors V1 and V2, we get the following  // result:  //  //    Given That:  //    * V1:V2 = A B C D E F G H : I J K L M N P Q  //      (where each of {A....P} is a short)   //    *\xCAswitchByteSelectorHi = 0x001e 001c 001e 001c 001e 001c....  //  //     v3 = vec_perm(zero, v2, switchByteSelectorHi);  //  //     gives v3 = (0x00Qh 00Ph 00Qh 00Ph 00Qh 00Ph....  //    (High bytes of last two words)  //   //     v3 = vec_perm(zero, v2, switchByteSelectorLo);  //  //     gives v3 = (0x00Ql 00Pl 00Ql 00Pl 00Ql 00Pl....  //    (Low bytes of last two words)  ////////////////////////////////////////////////////////////////////  ////////////////////////////////////////////////////////////////////  // 10,11,12....0x1D 0x1E 0x1F  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = vec_lvsr(0, (int *)0);      ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x0000 0000....0x191b 0x1d1f  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = vec_pack((vector unsigned short)zero, (vector unsigned short)switchByteSelectorLo);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x1d1f, 1d1f, 1d1f....1d1f  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = (vector unsigned char)vec_splat((vector unsigned short)switchByteSelectorLo, 7);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x001d 001f, 001d, 001f....  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = (vector unsigned char)vec_unpackl((vector signed char)switchByteSelectorLo);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x001f, 001d, 001f, 001d...  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = vec_sld(switchByteSelectorLo, switchByteSelectorLo, 2);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorHi = 0001 0001 0001 0001...  ////////////////////////////////////////////////////////////////////  switchByteSelectorHi = (vector unsigned char)vec_splat_u16(1);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorHi = 0x001e, 001c, 001e, 001c...  ////////////////////////////////////////////////////////////////////  switchByteSelectorHi = vec_sub(switchByteSelectorLo, switchByteSelectorHi);  #else  switchByteSelectorLo =     (vector unsigned char)((vector unsigned long)(0x001f001d, 0x001f001d, 0x001f001d, 0x001f001d));  switchByteSelectorHi =     (vector unsigned char)((vector unsigned long)(0x001e001c, 0x001e001c, 0x001e001c, 0x001e001c));  staggeredSumPermuterEven =  (vector unsigned char)((vector unsigned long)(0x04050607, 0x0c0d0e0f, 0x14151617, 0x1c1d1e1f));  staggeredSumPermuterOdd =   (vector unsigned char)((vector unsigned long)(0x00010203, 0x08090a0b, 0x10111213, 0x18191a1b));#endif  ////////////////////////////////////////////////////////////////////  // loop through each column of result vectors in the product  ////////////////////////////////////////////////////////////////////  for (columnIndex = 1; columnIndex &lt; len1+len2; columnIndex++) {    ////////////////////////////////////////////////////////////////////    // vectors to keep running sum from msum operations    ////////////////////////////////////////////////////////////////////    vector unsigned long currentLoSumHiOddBytes;    vector unsigned long currentLoSumHiEvenBytes;    vector unsigned long currentLoSumLoOddBytes;    vector unsigned long currentLoSumLoEvenBytes;    vector unsigned long currentHiSumHiOddBytes;    vector unsigned long currentHiSumHiEvenBytes;    vector unsigned long currentHiSumLoOddBytes;    vector unsigned long currentHiSumLoEvenBytes;                  ////////////////////////////////////////////////////////////////////    // temporary vectors for calculating sums    ////////////////////////////////////////////////////////////////////    vector unsigned long tempsumhi, tempsumlo;    ////////////////////////////////////////////////////////////////////    // temporary vectors for summing carries    ////////////////////////////////////////////////////////////////////    vector unsigned long carrytemphi, carrytemplo;    ////////////////////////////////////////////////////////////////////    // vectors for carries for hi, lo result vectors     ////////////////////////////////////////////////////////////////////    vector unsigned long carryhi, carrylo;      ////////////////////////////////////////////////////////////////////    // vector for carry into next column of results    ////////////////////////////////////////////////////////////////////    vector unsigned long carrynext=(vector unsigned long)(0);    ////////////////////////////////////////////////////////////////////    // multiplicand vectors    ////////////////////////////////////////////////////////////////////    vector unsigned long p1, p2;          ////////////////////////////////////////////////////////////////////    // indices for looping through pairs of multiplicand vectors    // (outerLoop) and rows within vector product (innerLoop)_        ////////////////////////////////////////////////////////////////////    int innerLoop, outerLoop;    ////////////////////////////////////////////////////////////////////    // start both pointers out at LSD.    ////////////////////////////////////////////////////////////////////    pIncrementer = pShortBound;    pDecrementer = pLongBound;        ////////////////////////////////////////////////////////////////////    // clear carries and sums    ////////////////////////////////////////////////////////////////////    carryhi =           (vector unsigned long)(0);    carrylo =           (vector unsigned long)(0);    currentLoSumHiOddBytes =  (vector unsigned long)(0);    currentLoSumHiEvenBytes =  (vector unsigned long)(0);    currentLoSumLoOddBytes =  (vector unsigned long)(0);    currentLoSumLoEvenBytes =  (vector unsigned long)(0);    currentHiSumHiOddBytes =  (vector unsigned long)(0);    currentHiSumHiEvenBytes =  (vector unsigned long)(0);    currentHiSumLoOddBytes =  (vector unsigned long)(0);    currentHiSumLoEvenBytes =  (vector unsigned long)(0);    ////////////////////////////////////////////////////////////////////    // Loop through each pair of multiplicand vectors in the column    ////////////////////////////////////////////////////////////////////    for (outerLoop = 1; outerLoop &lt;= productCount; outerLoop++) {              ////////////////////////////////////////////////////////////////////      // Here we calculate the product of the two vectors p1 and p2:      //     p1 = A B C D E F G H      //     p2 = a b c d e f g h      //      //  This product can be viewed as the familiar parallelogram of      // partial products:      //      //                    h*A h*B h*C h*D h*E h*F h*G h*H      //                  g*A g*B g*C g*D g*E g*F g*G g*H      //                f*A f*B f*C f*D f*E f*F f*G f*H      //              e*A e*B e*C e*D e*E e*F e*G e*H      //            d*A d*B d*C d*D d*E d*F d*G d*H      //          c*A c*B c*C c*D c*E c*F c*G c*H      //        b*A b*B b*C b*D b*E b*F b*G b*H      //      a*A a*B a*C a*D a*E a*F a*G a*H      //      ------------------------------------------------------------      //column:   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15      //      ////////////////////////////////////////////////////////////////////            {        ////////////////////////////////////////////////////////////////////        // multiplicand vectors for the msum operation        ////////////////////////////////////////////////////////////////////                vector unsigned short candVectorLoBytes;        vector unsigned short candVectorHiBytes;        vector unsigned short candHiVectorHorizontalHi;        vector unsigned short candHiVectorHorizontalLo;            vector unsigned short candLoVectorHorizontalHi;            vector unsigned short candLoVectorHorizontalLo;            ////////////////////////////////////////////////////////////////////        // get vector &quot;digits&quot; for each multiplicand         ////////////////////////////////////////////////////////////////////                p1 = *pIncrementer++;        p2 = *pDecrementer--;                        ////////////////////////////////////////////////////////////////////        // Generate multiplicand vectors        ////////////////////////////////////////////////////////////////////                candLoVectorHorizontalHi = (vector unsigned short)vec_mergeh((vector unsigned short)p1, (vector unsigned short)p1);        candLoVectorHorizontalLo = (vector unsigned short)vec_mergel((vector unsigned short)p1, (vector unsigned short)p1);                                                    candHiVectorHorizontalHi = (vector unsigned short)(0);        ////////////////////////////////////////////////////////////////////        // shift cand vectors over by one        ////////////////////////////////////////////////////////////////////        candHiVectorHorizontalLo = vec_sld((vector unsigned short)zero, candLoVectorHorizontalHi, 2);        candLoVectorHorizontalHi = vec_sld(candLoVectorHorizontalHi, candLoVectorHorizontalLo, 2);        candLoVectorHorizontalLo = vec_sld(candLoVectorHorizontalLo, (vector unsigned short)zero, 2);        ////////////////////////////////////////////////////////////////////        // We now have these four partial multiplicand vectors:        //         // candHiVectorHorizontalHi = (0, 0, 0, 0, 0, 0, 0, 0)        // candHiVectorHorizontalLo = (0, 0, 0, 0, 0, 0, 0, A)        // candLoVectorHorizontalHi = (A, B, B, C, C, D, D, E)        // candLoVectorHorizontalLo = (E, F, F, G, G, H, H, 0)        //        ////////////////////////////////////////////////////////////////////                        ////////////////////////////////////////////////////////////////////                //  We go through the following loop two times, to calculate the        // top four rows of the parallelogram (each time through the loop        // we calculate two rows).  We do this because we know that the         // upper fourth of the result (corresponding to candHiVectorHorizontalHi)        // is zero, so we don't need to perform that msum operation.          ////////////////////////////////////////////////////////////////////                              for (innerLoop = 0; innerLoop &lt; 2; innerLoop++) {          ////////////////////////////////////////////////////////////////////                  // generate other set of multiplicand vectors.  The first time          // through the loop, this will generate:          //          // candVectorLoBytes = (00hl 00gl 00hl 00gl 00hl 00gl 00hl 00gl)          // candVectorHiBytes = (00hh 00gh 00hh 00gh 00hh 00gh 00hh 00gh)          //          // (where 'hl' is the low byte of the 16-bit element 'h', and          // 'gh' is the high byte of the 16-bit element 'g'.)          //          // The second time through, it will generate:                    // candVectorLoBytes = (00fl 00el 00fl 00el 00fl 00el 00fl 00el)          // candVectorHiBytes = (00fh 00eh 00fh 00eh 00fh 00eh 00fh 00eh)          //          ////////////////////////////////////////////////////////////////////                  candVectorLoBytes = vec_perm((vector unsigned short)zero,                      (vector unsigned short)p2, switchByteSelectorLo);          candVectorHiBytes = vec_perm((vector unsigned short)zero,                      (vector unsigned short)p2, switchByteSelectorHi);                    ////////////////////////////////////////////////////////////////////                  //  The msum operation takes arguments 1 and 2 and multiplies their          // 16-bit elements together to yield 8 32-bit results.  It then adds          // results 1+2, 3+4, 5+6, 7+8, yielding 4 32-bit results.  Each of          // these elements is added to the corresponding 32-bit element of          // argument 3.  So, if we have:          //          //   candHiVectorHorizontalLo =  (0,     0,    0,    0,    0,    0,    0,    A)          //  candVectorHiBytes =     (00hh, 00gh, 00hh, 00gh, 00hh, 00gh, 00hh, 00gh)            //  currentHiSumLoOddBytes =   (0,          0,          0,          0)          //            // Then vec_msum(candHiVectorHorizontalLo, candVectorHiBytes, currentHiSumLoOddBytes)          // will produce:          //          //  (0, 0, 0, A*gh)          //              // and vec_msum(candHiVectorHorizontalLo, candVectorLoBytes, currentHiSumLoEvenBytes);          // will produce:          //            //  (0, 0, 0, A*gl)          //          //  The next time through the loop, when we have:          //          //   candHiVectorHorizontalLo =  (0,    0,    0,    A,    A,    B,    B,    C)          //  candVectorHiBytes =     (00fh, 00eh, 00fh, 00eh, 00fh, 00eh, 00fh, 00eh)          //  currentHiSumLoOddBytes =   (0,          0,          0,          A*gh)          //          //   currentHiSumLoOddBytes = vec_msum(  candHiVectorHorizontalLo,           //                    candVectorHiBytes,           //                    currentHiSumLoOddBytes);          //          //   will produce:          //          //  currentHiSumLoOddBytes =           //    (0, A*eh, (A*fh)+(B*eh), (B*fh)+(C*eh)+(A*gh))          //          //  Because the products are 24 bits each, we can add them together          // without worrying about carries, since each element in the vectors          // for the sums of partial products is 32 bits.          ////////////////////////////////////////////////////////////////////                    currentHiSumLoOddBytes =   vec_msum(candHiVectorHorizontalLo, candVectorHiBytes, currentHiSumLoOddBytes);          currentHiSumLoEvenBytes =   vec_msum(candHiVectorHorizontalLo, candVectorLoBytes, currentHiSumLoEvenBytes);                    ////////////////////////////////////////////////////////////////////          // shift high multiplicand vectors left by 4 elements (8 bytes)          // for next time through loop          ////////////////////////////////////////////////////////////////////          candHiVectorHorizontalHi =   vec_sld(candHiVectorHorizontalHi, candHiVectorHorizontalLo, 8);          candHiVectorHorizontalLo =   vec_sld(candHiVectorHorizontalLo, candLoVectorHorizontalHi, 8);          // ---------------------------------------------------------------------------------------------          ////////////////////////////////////////////////////////////////////          // perform partial products for low side of result          //           // first time through loop:          //   candLoVectorHorizontalHi =   (A,    B,    B,    C,    C,    D,    D,    E)          //  candVectorHiBytes =     (00hh, 00gh, 00hh, 00gh, 00hh, 00gh, 00hh, 00gh)            //   currentLoSumHiOddBytes =  (0           0           0           0)          //           // then          //   currentLoSumHiOddBytes = vec_msum(  candLoVectorHorizontalHi,          //                    candVectorHiBytes,           //                    currentLoSumHiOddBytes)          // will produce:          //          //  currentLoSumHiOddBytes = ((A*hh)+(B*gh), (B*hh)+(C*gh), (C*hh)+(D*gh), (D*hh)+(E*gh))          //          // second time through the loop:          //   candLoVectorHorizontalHi =   (C,    D,    D,    E,    E,     F,    F,    G)          //  candVectorHiBytes =     (00fh, 00eh, 00fh, 00eh, 00fh, 00eh, 00fh, 00eh)          //  currentLoSumHiOddBytes =   ( (A*hh)+(B*gh), (B*hh)+(C*gh), (C*hh)+(D*gh), (D*hh)+(E*gh) )          //          //   currentLoSumHiOddBytes = vec_msum(  candLoVectorHorizontalHi,          //                    candVectorHiBytes,           //                    currentLoSumHiOddBytes)          // will produce:          //  currentLoSumHiOddBytes = (  (A*hh)+(B*gh)+(C*fh)+(D*eh),          //                 (B*hh)+(C*gh)+(D*fh)+(E*eh),          //                (C*hh)+(D*gh)+(E*fh)+(F*eh),          //                (D*hh)+(E*gh)+(F*fh)+(G*eh) )          //          // Note that each of these four elements corresponds to the sums          // of the partial products of the first four rows of columns 8-11           // in the above parallelogram.          //          ////////////////////////////////////////////////////////////////////          currentLoSumHiOddBytes =   vec_msum(candLoVectorHorizontalHi, candVectorHiBytes, currentLoSumHiOddBytes);          currentLoSumHiEvenBytes =   vec_msum(candLoVectorHorizontalHi, candVectorLoBytes, currentLoSumHiEvenBytes);                    currentLoSumLoOddBytes =   vec_msum(candLoVectorHorizontalLo, candVectorHiBytes, currentLoSumLoOddBytes);          currentLoSumLoEvenBytes =   vec_msum(candLoVectorHorizontalLo, candVectorLoBytes, currentLoSumLoEvenBytes);                    ////////////////////////////////////////////////////////////////////          // shift high multiplicand vectors left by 4 elements (8 bytes)          // for next time through loop          ////////////////////////////////////////////////////////////////////          candLoVectorHorizontalHi =   vec_sld(candLoVectorHorizontalHi, candLoVectorHorizontalLo, 8);          candLoVectorHorizontalLo =   vec_sld(candLoVectorHorizontalLo, (vector unsigned short)zero, 8);          ////////////////////////////////////////////////////////////////////          // shift p2 right by 2 elements, so that our permute operation will          // select the hi and lo bytes of the next-highest two elements.          ////////////////////////////////////////////////////////////////////          p2 = vec_sld(zero, p2, 12);        }        ////////////////////////////////////////////////////////////////////        // Perform a loop similar to the one above, except we do not do        // the partial products for the low half of the low vector, since        // we know that it will be zero.  The partial products of these        // msums will be added to the results of the previous loop.        ////////////////////////////////////////////////////////////////////        for (innerLoop = 0; innerLoop &lt; 2; innerLoop++) {          candVectorLoBytes = vec_perm((vector unsigned short)zero,                      (vector unsigned short)p2, switchByteSelectorLo);          candVectorHiBytes = vec_perm((vector unsigned short)zero,                      (vector unsigned short)p2, switchByteSelectorHi);                    // ---------------------------------------------------------------------------------------------          currentHiSumHiOddBytes =   vec_msum(candHiVectorHorizontalHi, candVectorHiBytes, currentHiSumHiOddBytes);          currentHiSumHiEvenBytes =   vec_msum(candHiVectorHorizontalHi, candVectorLoBytes, currentHiSumHiEvenBytes);          currentHiSumLoOddBytes =   vec_msum(candHiVectorHorizontalLo, candVectorHiBytes, currentHiSumLoOddBytes);          currentHiSumLoEvenBytes =  vec_msum(candHiVectorHorizontalLo, candVectorLoBytes, currentHiSumLoEvenBytes);                    candHiVectorHorizontalHi =   vec_sld(candHiVectorHorizontalHi, candHiVectorHorizontalLo, 8);          candHiVectorHorizontalLo =   vec_sld(candHiVectorHorizontalLo, candLoVectorHorizontalHi, 8);          // ---------------------------------------------------------------------------------------------          currentLoSumHiOddBytes =   vec_msum(candLoVectorHorizontalHi, candVectorHiBytes, currentLoSumHiOddBytes);          currentLoSumHiEvenBytes =   vec_msum(candLoVectorHorizontalHi, candVectorLoBytes, currentLoSumHiEvenBytes);                    candLoVectorHorizontalHi =   vec_sld(candLoVectorHorizontalHi, candLoVectorHorizontalLo, 8);          // ---------------------------------------------------------------------------------------------          p2 = vec_sld(zero, p2, 12);        }      }      ////////////////////////////////////////////////////////////////////      // The loop above adds at most four partial products to each      // sum accumulator (currentHiSumHiOddBytes, etc...), each of      // which is at most 24 bits, which means that the result is      // at most 26 bits.  Since each vector element is 32 bits,      // we can go through the above set of msum calculations 64      // times at most before we saturate the accumulator vectors.      // If we have either reached the end of the loop, or if we      // have reached saturation, we permute these partial sums into      // the form we need them in to add them together, and then add      // them and calculate the carries.                  if ( (!(outerLoop &amp; 0x3f)) || outerLoop == productCount) {        ////////////////////////////////////////////////////////////////////        //  we have eight result vectors that are the sum of partial        //  products:        //        //        //  currentLoSumLoEvenBytes =  r8        //  currentLoSumLoOddBytes =  r7        //  currentLoSumHiEvenBytes =  r6        //  currentLoSumHiOddBytes =  r5        //  currentHiSumLoEvenBytes =  r4        //  currentHiSumLoOddBytes =  r3        //  currentHiSumHiEvenBytes =  r2        //  currentHiSumHiOddBytes =  r1        //        //  If each vector is broken down into four elements (i.e.        //   r1 = (r1A, r1B, r1C, r1D), then the vector elements need        //   to be added together in positions represented in this        //  chart:        //        //  Byte position:        //  -03 -02 -01 00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31        //  ----------------------------------------------------------------------------------------------------------------------------------------------        //        '      |---- r1D -----|                  '      |---- r5D -----|        //        '  |---- r1C -----|                      '  |---- r5C -----|        //      |---- r1B -----|                        |---- r5B -----|        //  |---- r1A -----|                        |---- r5A -----|        //        '        |---- r2D -----|                '        |---- r6D -----|        //        '    |---- r2C -----|                    '    |---- r6C -----|        //        |---- r2B -----|                        |---- r6B -----|        //    |---- r2A -----|                        |---- r2A -----|        //        '                      |---- r3D -----|  '                      |---- r7D -----|        //        '                  |---- r3C -----|      '                  |---- r7C -----|        //        '              |---- r3B -----|          '              |---- r7B -----|        //        '          |---- r3A -----|              '          |---- r7A -----|        //        '                        |---- r4D -----|'                        |---- r8D -----|        //        '                    |---- r4C -----  |    '                    |---- r8C -----|        //        '                |---- r4B -----|        '                |---- r8B -----|        //        '            |---- r4A -----|            '            |---- r8A -----|        //  --------------------------------------------------------------------------------------------------------------------------------------------        //        ^ vector boundary                        ^ vector boundary        //        //  To do this, we permute out of these vectors to create new        //  vectors that have non-overlapping elements.  For example,        //  we create the vectors         //        //  tempsumhi = (r2B, r2D, r4B, r4D)        //  tempsumlo = (r6B, r6D, r8B, r8D)        //        //  which can then be added into our final result vectors.        //          //        //  In the case of:        //        //  tempsumhi = (r2A, r2C, r4A, r4C)        //  tempsumlo = (r6A, r6C, r8A, r8C)        //        //  these vectors must be shifted left by 16 bits before        //   being added in to the result.  Note that this makes        //   the top 16 bits of tempsumhi overflow the high vector.        //  This overflow is accumulated as a carry for the next        //  column of calculations.        ////////////////////////////////////////////////////////////////////        ////////////////////////////////////////////////////////////////////        // add in vector elements which require no shifting                ////////////////////////////////////////////////////////////////////                // select out elements        tempsumhi = vec_perm(currentHiSumHiEvenBytes, currentHiSumLoEvenBytes, staggeredSumPermuterEven);        tempsumlo = vec_perm(currentLoSumHiEvenBytes, currentLoSumLoEvenBytes, staggeredSumPermuterEven);        // figure out carry from adding to sum        carrytemphi = vec_addc(tempsumhi, sumhi);          carrytemplo = vec_addc(tempsumlo, sumlo);          // add in carry to existing carries        carryhi = vec_add(carryhi, carrytemphi);        carrylo = vec_add(carrylo, carrytemplo);        // add to sum        sumhi = vec_add(tempsumhi, sumhi);          sumlo = vec_add(tempsumlo, sumlo);        ////////////////////////////////////////////////////////////////////        // add in vector elements which require shifting 8 bits left        ////////////////////////////////////////////////////////////////////        // select out elements        tempsumhi = vec_perm(currentHiSumHiOddBytes, currentHiSumLoOddBytes, staggeredSumPermuterEven);        tempsumlo = vec_perm(currentLoSumHiOddBytes, currentLoSumLoOddBytes, staggeredSumPermuterEven);        // figure out how much shifts out of the vector, and add it to the next carry        carrytemphi = vec_sld(zero, tempsumhi, 1);        carrynext = vec_add(carrynext, carrytemphi);        // shift elements        tempsumhi = vec_sld(tempsumhi, tempsumlo, 1);        tempsumlo = vec_sld(tempsumlo, zero, 1);        // figure out carry        carrytemphi = vec_addc(tempsumhi, sumhi);          carrytemplo = vec_addc(tempsumlo, sumlo);          // add carry to existing carries        carryhi = vec_add(carryhi, carrytemphi);        carrylo = vec_add(carrylo, carrytemplo);        // add to sum        sumhi = vec_add(tempsumhi, sumhi);          sumlo = vec_add(tempsumlo, sumlo);        ////////////////////////////////////////////////////////////////////        // add in vector elements which require shifting 16 bits left        ////////////////////////////////////////////////////////////////////        // select out elements        tempsumhi = vec_perm(currentHiSumHiEvenBytes, currentHiSumLoEvenBytes, staggeredSumPermuterOdd);        tempsumlo = vec_perm(currentLoSumHiEvenBytes, currentLoSumLoEvenBytes, staggeredSumPermuterOdd);        // figure out how much shifts out of the vector, and add it to the carry        carrytemphi = vec_sld(zero, tempsumhi, 2);        carrynext = vec_add(carrynext, carrytemphi);                // shift elements        tempsumhi = vec_sld(tempsumhi, tempsumlo, 2);        tempsumlo = vec_sld(tempsumlo, zero, 2);        // figure out carry        carrytemphi = vec_addc(tempsumhi, sumhi);          carrytemplo = vec_addc(tempsumlo, sumlo);          // add carry to previous carry        carryhi = vec_add(carryhi, carrytemphi);        carrylo = vec_add(carrylo, carrytemplo);        // add to sum        sumhi = vec_add(tempsumhi, sumhi);          sumlo = vec_add(tempsumlo, sumlo);                ////////////////////////////////////////////////////////////////////        // add in vector elements which require shifting 16 bits left        ////////////////////////////////////////////////////////////////////        // select out elements        tempsumhi = vec_perm(currentHiSumHiOddBytes, currentHiSumLoOddBytes, staggeredSumPermuterOdd);        tempsumlo = vec_perm(currentLoSumHiOddBytes, currentLoSumLoOddBytes, staggeredSumPermuterOdd);        // figure out how much shifts out of the vector, and add it to the carry        carrytemphi = vec_sld(zero, tempsumhi, 3);        carrynext = vec_add(carrynext, carrytemphi);                // shift elements        tempsumhi = vec_sld(tempsumhi, tempsumlo, 3);        tempsumlo = vec_sld(tempsumlo, zero, 3);        // figure out carry        carrytemphi = vec_addc(tempsumhi, sumhi);          carrytemplo = vec_addc(tempsumlo, sumlo);          // add carry to previous carry        carryhi = vec_add(carryhi, carrytemphi);        carrylo = vec_add(carrylo, carrytemplo);        // add to sum        sumhi = vec_add(tempsumhi, sumhi);          sumlo = vec_add(tempsumlo, sumlo);                ////////////////////////////////////////////////////////////////////        // Now, if we're going through the loop again, we need to clear        // our partial product sums        ////////////////////////////////////////////////////////////////////        if (outerLoop != productCount) {          currentLoSumHiOddBytes =  (vector unsigned long)(0);          currentLoSumHiEvenBytes =  (vector unsigned long)(0);          currentLoSumLoOddBytes =  (vector unsigned long)(0);          currentLoSumLoEvenBytes =  (vector unsigned long)(0);          currentHiSumHiOddBytes =  (vector unsigned long)(0);          currentHiSumHiEvenBytes =  (vector unsigned long)(0);          currentHiSumLoOddBytes =  (vector unsigned long)(0);          currentHiSumLoEvenBytes =  (vector unsigned long)(0);        }            }    }        ////////////////////////////////////////////////////////////////////    // We have finished adding all partial products together, so now    // we need to reconcile all carries. We repeatedly shift the    // carries left by 32 bits, add them, and figure out the new    // resulting carry.    ////////////////////////////////////////////////////////////////////    do {      // add any overflow to carry for next column      carrynext = vec_add(carrynext, vec_sld(zero, carryhi, 4));            // shift carries left 32 bits      carryhi = vec_sld(carryhi, carrylo, 4);      carrylo = vec_sld(carrylo, zero, 4);            // figure out new high carry      carrytemphi = vec_addc(carryhi, sumhi);            // add carry to sum      sumhi = vec_add(carryhi, sumhi);            // save new carry      carryhi = carrytemphi;      // figure out new low carry      carrytemplo = vec_addc(carrylo, sumlo);            // add carry to sum      sumlo = vec_add(carrylo, sumlo);            // save new carry      carrylo = carrytemplo;    } while (!vec_all_eq(zero, vec_or(carryhi, carrylo)));        ////////////////////////////////////////////////////////////////////    // save this result, and increment pointer for storage of    // next result.    ////////////////////////////////////////////////////////////////////    *pResult++ = sumlo;        ////////////////////////////////////////////////////////////////////    // This column's high result is added in as part of next column's    // low result, and our carry goes in to the next columns high    // result.    ////////////////////////////////////////////////////////////////////        sumlo = sumhi;    sumhi = carrynext;    ////////////////////////////////////////////////////////////////////    // move bounds pointers to point to new bounds of 128-bit    // multiplicand elements.    ////////////////////////////////////////////////////////////////////    if (columnIndex &lt; shortcount) {      pLongBound++;      productCount++;    } else if (columnIndex &lt; longcount) {      pLongBound++;    } else {      productCount--;      pShortBound++;    }  }  ////////////////////////////////////////////////////////////////////  // save the final column's result  ////////////////////////////////////////////////////////////////////  *pResult = sumlo;}void VecSquare(            vector unsigned long *pVec1,                  unsigned long  len1,                  vector unsigned long *pResult){  ////////////////////////////////////////////////////////////////////  // index for current column of parallelogram that we are  // summing products for  ////////////////////////////////////////////////////////////////////  unsigned long        columnIndex;    ////////////////////////////////////////////////////////////////////  // hi and lo vectors for sum of products for current column  ////////////////////////////////////////////////////////////////////    vector unsigned long    sumlo     = (vector unsigned long)(0);  vector unsigned long     sumhi     = (vector unsigned long)(0);  ////////////////////////////////////////////////////////////////////  // carry from sums in current column that carry over into next  // column.  ////////////////////////////////////////////////////////////////////  vector unsigned long    carryNext   = (vector unsigned long)(0);  ////////////////////////////////////////////////////////////////////  // all-purpose zero register  ////////////////////////////////////////////////////////////////////  vector unsigned long      zero     = (vector unsigned long)(0);  ////////////////////////////////////////////////////////////////////  // permute vectors for selecting multiplicand vectors for  // msum operation  ////////////////////////////////////////////////////////////////////  vector unsigned char     switchByteSelectorLo;    vector unsigned char     switchByteSelectorHi;    vector unsigned char     staggeredSumPermuterEven;  vector unsigned char     staggeredSumPermuterOdd;    ////////////////////////////////////////////////////////////////////  // pointers for convolution of vectors for partial products  ////////////////////////////////////////////////////////////////////  vector unsigned long    *pIncrementer;  vector unsigned long    *pDecrementer;  ////////////////////////////////////////////////////////////////////  // bounds from which vector pointers start for column  ////////////////////////////////////////////////////////////////////  vector unsigned long    *pTopBound;  vector unsigned long    *pBottomBound;    ////////////////////////////////////////////////////////////////////  // count of how many 128-bit products are summed in the current  // column.  ////////////////////////////////////////////////////////////////////  unsigned long        productCount;    ////////////////////////////////////////////////////////////////////  // set to true if current partial product is added in to the  // current column only once  ////////////////////////////////////////////////////////////////////  long            singleadd;    ////////////////////////////////////////////////////////////////////  // true if next product will only be added once  ////////////////////////////////////////////////////////////////////    long            singlenext;  ////////////////////////////////////////////////////////////////////  // true if this is the last product for the current column  ////////////////////////////////////////////////////////////////////  long            lastproduct;    ////////////////////////////////////////////////////////////////////  // count of how many times we've been through outer loop in column  ////////////////////////////////////////////////////////////////////    int              outerloopcount=0;  ////////////////////////////////////////////////////////////////////  //  //          ********************  //          ** IMPORTANT NOTE **  //          ********************  //  // if there are more than 16384 products in a column to be added  // together, then our carry calculation will overflow.  Note that  // this will only occur if one of the multiplicands is over two  // million bits long.  If this situation needs to be handled, an  // enhanced carry overflow calculation will have to be employed.  //  ////////////////////////////////////////////////////////////////////  if (len1 &gt; 16384) {    //DebugStr(&quot;\pvector multiply overflow&quot;);  }  ////////////////////////////////////////////////////////////////////  // start bounds pointing at least significant vector of multiplicand  // vector arrays.  First column has only one product.  ////////////////////////////////////////////////////////////////////  pTopBound = pVec1;  pBottomBound = pVec1;  ////////////////////////////////////////////////////////////////////  // first (rightmost) column has only one product  ////////////////////////////////////////////////////////////////////  productCount = 1;  ////////////////////////////////////////////////////////////////////  // clear all result vectors to zero  ////////////////////////////////////////////////////////////////////  for (columnIndex = 0; columnIndex &lt; 2*len1; columnIndex++) {    pResult[columnIndex] = (vector unsigned long)(0);  }  ////////////////////////////////////////////////////////////////////  //  Load or generate some constants that are needed for some  // of the vector manipulations that are performed in the multiplies  ////////////////////////////////////////////////////////////////////#if GENERATE_CONSTANTS    ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterOdd = 00 01 02 03 10 11 12 13 ...  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterOdd =     (vector unsigned char)vec_mergeh(                    (vector unsigned long)vec_lvsl(0, (unsigned long*)0),                    (vector unsigned long)vec_lvsr(0, (unsigned long*)0));    ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterEven = 08 09 0a 0b 18 19 1a 1b ...  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterEven  = vec_add(vec_splat_u8(8), staggeredSumPermuterOdd);  ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterOdd = 00010203 08090a0b 10111213 18191a1b  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterOdd    = (vector unsigned char)vec_mergeh(                    (vector unsigned long)staggeredSumPermuterOdd,                    (vector unsigned long)staggeredSumPermuterEven);    ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterEven = 04050607 0c0d0e0f 14151617 1c1d1e1f  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterEven  = vec_add(vec_splat_u8(4), staggeredSumPermuterOdd);              ////////////////////////////////////////////////////////////////////  // We generate two permute vectors that are used to select the high  // and low bytes of the rightmost shorts in a vector.  For example,  // given the multiplicand vectors V1 and V2, we get the following  // result:  //  //    Given That:  //    * V1:V2 = A B C D E F G H : I J K L M N P Q  //      (where each of {A....P} is a short)   //    *\xCAswitchByteSelectorHi = 0x001e 001c 001e 001c 001e 001c....  //  //     v3 = vec_perm(zero, v2, switchByteSelectorHi);  //  //     gives v3 = (0x00Qh 00Ph 00Qh 00Ph 00Qh 00Ph....  //    (High bytes of last two words)  //   //     v3 = vec_perm(zero, v2, switchByteSelectorLo);  //  //     gives v3 = (0x00Ql 00Pl 00Ql 00Pl 00Ql 00Pl....  //    (Low bytes of last two words)  ////////////////////////////////////////////////////////////////////  ////////////////////////////////////////////////////////////////////  // 10,11,12....0x1D 0x1E 0x1F  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = vec_lvsr(0, (int *)0);      ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x0000 0000....0x191b 0x1d1f  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = vec_pack((vector unsigned short)zero, (vector unsigned short)switchByteSelectorLo);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x1d1f, 1d1f, 1d1f....1d1f  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = (vector unsigned char)vec_splat((vector unsigned short)switchByteSelectorLo, 7);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x001d 001f, 001d, 001f....  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = (vector unsigned char)vec_unpackl((vector signed char)switchByteSelectorLo);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x001f, 001d, 001f, 001d...  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = vec_sld(switchByteSelectorLo, switchByteSelectorLo, 2);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorHi = 0001 0001 0001 0001...  ////////////////////////////////////////////////////////////////////  switchByteSelectorHi = (vector unsigned char)vec_splat_u16(1);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorHi = 0x001e, 001c, 001e, 001c...  ////////////////////////////////////////////////////////////////////  switchByteSelectorHi = vec_sub(switchByteSelectorLo, switchByteSelectorHi);  #else  switchByteSelectorLo =     (vector unsigned char)((vector unsigned long)(0x001f001d, 0x001f001d, 0x001f001d, 0x001f001d));  switchByteSelectorHi =     (vector unsigned char)((vector unsigned long)(0x001e001c, 0x001e001c, 0x001e001c, 0x001e001c));  staggeredSumPermuterEven =  (vector unsigned char)((vector unsigned long)(0x04050607, 0x0c0d0e0f, 0x14151617, 0x1c1d1e1f));  staggeredSumPermuterOdd =   (vector unsigned char)((vector unsigned long)(0x00010203, 0x08090a0b, 0x10111213, 0x18191a1b));#endif  ////////////////////////////////////////////////////////////////////  // loop through each column of result vectors in the product  ////////////////////////////////////////////////////////////////////  for (columnIndex = 1; columnIndex &lt; 2*len1; columnIndex++) {    ////////////////////////////////////////////////////////////////////    // vectors to keep running sum from msum operations    ////////////////////////////////////////////////////////////////////    vector unsigned long currentLoSumHiOddBytes;    vector unsigned long currentLoSumHiEvenBytes;    vector unsigned long currentLoSumLoOddBytes;    vector unsigned long currentLoSumLoEvenBytes;    vector unsigned long currentHiSumHiOddBytes;    vector unsigned long currentHiSumHiEvenBytes;    vector unsigned long currentHiSumLoOddBytes;    vector unsigned long currentHiSumLoEvenBytes;                  ////////////////////////////////////////////////////////////////////    // temporary vectors for calculating sums    ////////////////////////////////////////////////////////////////////    vector unsigned long tempsumhi, tempsumlo;    ////////////////////////////////////////////////////////////////////    // temporary vectors for summing carries    ////////////////////////////////////////////////////////////////////    vector unsigned long carrytemphi, carrytemplo;    ////////////////////////////////////////////////////////////////////    // vectors for carries for hi, lo result vectors     ////////////////////////////////////////////////////////////////////    vector unsigned long carryhi, carrylo;      ////////////////////////////////////////////////////////////////////    // vector for carry into next column of results    ////////////////////////////////////////////////////////////////////    vector unsigned long carrynext=(vector unsigned long)(0);    ////////////////////////////////////////////////////////////////////    // multiplicand vectors    ////////////////////////////////////////////////////////////////////    vector unsigned long p1, p2;          ////////////////////////////////////////////////////////////////////    // index for looping through rows within the current column    ////////////////////////////////////////////////////////////////////    int            innerLoop;    ////////////////////////////////////////////////////////////////////    // start pointers off at opposite bounds    ////////////////////////////////////////////////////////////////////    pIncrementer = pBottomBound;    pDecrementer = pTopBound;    ////////////////////////////////////////////////////////////////////    // clear carries and sums    ////////////////////////////////////////////////////////////////////        carryhi = (vector unsigned long)(0);    carrylo = (vector unsigned long)(0);    currentLoSumHiOddBytes=(vector unsigned long)(0);    currentLoSumHiEvenBytes=(vector unsigned long)(0);    currentLoSumLoOddBytes=(vector unsigned long)(0);    currentLoSumLoEvenBytes=(vector unsigned long)(0);    currentHiSumHiOddBytes=(vector unsigned long)(0);    currentHiSumHiEvenBytes=(vector unsigned long)(0);    currentHiSumLoOddBytes=(vector unsigned long)(0);    currentHiSumLoEvenBytes=(vector unsigned long)(0);    ////////////////////////////////////////////////////////////////////    // Loop through each pair of multiplicands    ////////////////////////////////////////////////////////////////////    do {      ////////////////////////////////////////////////////////////////////      // Here we calculate the product of the two vectors p1 and p2:      //     p1 = A B C D E F G H      //     p2 = a b c d e f g h      //      //  This product can be viewed as the familiar parallelogram of      // partial products:      //      //                    h*A h*B h*C h*D h*E h*F h*G h*H      //                  g*A g*B g*C g*D g*E g*F g*G g*H      //                f*A f*B f*C f*D f*E f*F f*G f*H      //              e*A e*B e*C e*D e*E e*F e*G e*H      //            d*A d*B d*C d*D d*E d*F d*G d*H      //          c*A c*B c*C c*D c*E c*F c*G c*H      //        b*A b*B b*C b*D b*E b*F b*G b*H      //      a*A a*B a*C a*D a*E a*F a*G a*H      //      ------------------------------------------------------------      //column:   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15      //      ////////////////////////////////////////////////////////////////////              {        ////////////////////////////////////////////////////////////////////        // multiplicand vectors for the msum operation        ////////////////////////////////////////////////////////////////////                vector unsigned short candVectorLoBytes;        vector unsigned short candVectorHiBytes;        vector unsigned short candHiVectorHorizontalHi;        vector unsigned short candHiVectorHorizontalLo;            vector unsigned short candLoVectorHorizontalHi;            vector unsigned short candLoVectorHorizontalLo;            ////////////////////////////////////////////////////////////////////        // get vector &quot;digits&quot; for each multiplicand         ////////////////////////////////////////////////////////////////////                p1 = *pIncrementer;        p2 = *pDecrementer;                ////////////////////////////////////////////////////////////////////        // Generate multiplicand vectors        ////////////////////////////////////////////////////////////////////                candLoVectorHorizontalHi = (vector unsigned short)vec_mergeh((vector unsigned short)p1, (vector unsigned short)p1);        candLoVectorHorizontalLo = (vector unsigned short)vec_mergel((vector unsigned short)p1, (vector unsigned short)p1);                                                    candHiVectorHorizontalHi = (vector unsigned short)(0);        ////////////////////////////////////////////////////////////////////        // shift cand vectors over by one        ////////////////////////////////////////////////////////////////////        candHiVectorHorizontalLo = vec_sld((vector unsigned short)zero, candLoVectorHorizontalHi, 2);        candLoVectorHorizontalHi = vec_sld(candLoVectorHorizontalHi, candLoVectorHorizontalLo, 2);        candLoVectorHorizontalLo = vec_sld(candLoVectorHorizontalLo, (vector unsigned short)zero, 2);        ////////////////////////////////////////////////////////////////////        // We now have these four partial multiplicand vectors:        //         // candHiVectorHorizontalHi = (0, 0, 0, 0, 0, 0, 0, 0)        // candHiVectorHorizontalLo = (0, 0, 0, 0, 0, 0, 0, A)        // candLoVectorHorizontalHi = (A, B, B, C, C, D, D, E)        // candLoVectorHorizontalLo = (E, F, F, G, G, H, H, 0)        //        ////////////////////////////////////////////////////////////////////                        ////////////////////////////////////////////////////////////////////                //  We go through the following loop two times, to calculate the        // top four rows of the parallelogram (each time through the loop        // we calculate two rows).  We do this because we know that the         // upper fourth of the result (corresponding to candHiVectorHorizontalHi)        // is zero, so we don't need to perform that msum operation.          ////////////////////////////////////////////////////////////////////                for (innerLoop = 0; innerLoop &lt; 2; innerLoop++) {          ////////////////////////////////////////////////////////////////////                  // generate other set of multiplicand vectors.  The first time          // through the loop, this will generate:          //          // candVectorLoBytes = (00hl 00gl 00hl 00gl 00hl 00gl 00hl 00gl)          // candVectorHiBytes = (00hh 00gh 00hh 00gh 00hh 00gh 00hh 00gh)          //          // (where 'hl' is the low byte of the 16-bit element 'h', and          // 'gh' is the high byte of the 16-bit element 'g'.)          //          // The second time through, it will generate:                    // candVectorLoBytes = (00fl 00el 00fl 00el 00fl 00el 00fl 00el)          // candVectorHiBytes = (00fh 00eh 00fh 00eh 00fh 00eh 00fh 00eh)          //          ////////////////////////////////////////////////////////////////////                  candVectorLoBytes = vec_perm((vector unsigned short)zero,                      (vector unsigned short)p2, switchByteSelectorLo);          candVectorHiBytes = vec_perm((vector unsigned short)zero,                      (vector unsigned short)p2, switchByteSelectorHi);                    ////////////////////////////////////////////////////////////////////                  //  The msum operation takes arguments 1 and 2 and multiplies their          // 16-bit elements together to yield 8 32-bit results.  It then adds          // results 1+2, 3+4, 5+6, 7+8, yielding 4 32-bit results.  Each of          // these elements is added to the corresponding 32-bit element of          // argument 3.  So, if we have:          //          //   candHiVectorHorizontalLo =  (0,     0,    0,    0,    0,    0,    0,    A)          //  candVectorHiBytes =     (00hh, 00gh, 00hh, 00gh, 00hh, 00gh, 00hh, 00gh)            //  currentHiSumLoOddBytes =   (0,          0,          0,          0)          //            // Then vec_msum(candHiVectorHorizontalLo, candVectorHiBytes, currentHiSumLoOddBytes)          // will produce:          //          //  (0, 0, 0, A*gh)          //              // and vec_msum(candHiVectorHorizontalLo, candVectorLoBytes, currentHiSumLoEvenBytes);          // will produce:          //            //  (0, 0, 0, A*gl)          //          //  The next time through the loop, when we have:          //          //   candHiVectorHorizontalLo =  (0,    0,    0,    A,    A,    B,    B,    C)          //  candVectorHiBytes =     (00fh, 00eh, 00fh, 00eh, 00fh, 00eh, 00fh, 00eh)          //  currentHiSumLoOddBytes =   (0,          0,          0,          A*gh)          //          //   currentHiSumLoOddBytes = vec_msum(  candHiVectorHorizontalLo,           //                    candVectorHiBytes,           //                    currentHiSumLoOddBytes);          //          //   will produce:          //          //  currentHiSumLoOddBytes =           //    (0, A*eh, (A*fh)+(B*eh), (B*fh)+(C*eh)+(A*gh))          //          //  Because the products are 24 bits each, we can add them together          // without worrying about carries, since each element in the vectors          // for the sums of partial products is 32 bits.          ////////////////////////////////////////////////////////////////////                    currentHiSumLoOddBytes =   vec_msum(candHiVectorHorizontalLo, candVectorHiBytes, currentHiSumLoOddBytes);          currentHiSumLoEvenBytes =   vec_msum(candHiVectorHorizontalLo, candVectorLoBytes, currentHiSumLoEvenBytes);                    ////////////////////////////////////////////////////////////////////          // shift high multiplicand vectors left by 4 elements (8 bytes)          // for next time through loop          ////////////////////////////////////////////////////////////////////          candHiVectorHorizontalHi =   vec_sld(candHiVectorHorizontalHi, candHiVectorHorizontalLo, 8);          candHiVectorHorizontalLo =   vec_sld(candHiVectorHorizontalLo, candLoVectorHorizontalHi, 8);          // ---------------------------------------------------------------------------------------------          ////////////////////////////////////////////////////////////////////          // perform partial products for low side of result          //           // first time through loop:          //   candLoVectorHorizontalHi =   (A,    B,    B,    C,    C,    D,    D,    E)          //  candVectorHiBytes =     (00hh, 00gh, 00hh, 00gh, 00hh, 00gh, 00hh, 00gh)            //   currentLoSumHiOddBytes =  (0           0           0           0)          //           // then          //   currentLoSumHiOddBytes = vec_msum(  candLoVectorHorizontalHi,          //                    candVectorHiBytes,           //                    currentLoSumHiOddBytes)          // will produce:          //          //  currentLoSumHiOddBytes = ((A*hh)+(B*gh), (B*hh)+(C*gh), (C*hh)+(D*gh), (D*hh)+(E*gh))          //          // second time through the loop:          //   candLoVectorHorizontalHi =   (C,    D,    D,    E,    E,     F,    F,    G)          //  candVectorHiBytes =     (00fh, 00eh, 00fh, 00eh, 00fh, 00eh, 00fh, 00eh)          //  currentLoSumHiOddBytes =   ( (A*hh)+(B*gh), (B*hh)+(C*gh), (C*hh)+(D*gh), (D*hh)+(E*gh) )          //          //   currentLoSumHiOddBytes = vec_msum(  candLoVectorHorizontalHi,          //                    candVectorHiBytes,           //                    currentLoSumHiOddBytes)          // will produce:          //  currentLoSumHiOddBytes = (  (A*hh)+(B*gh)+(C*fh)+(D*eh),          //                 (B*hh)+(C*gh)+(D*fh)+(E*eh),          //                (C*hh)+(D*gh)+(E*fh)+(F*eh),          //                (D*hh)+(E*gh)+(F*fh)+(G*eh) )          //          // Note that each of these four elements corresponds to the sums          // of the partial products of the first four rows of columns 8-11           // in the above parallelogram.          //          ////////////////////////////////////////////////////////////////////          currentLoSumHiOddBytes =   vec_msum(candLoVectorHorizontalHi, candVectorHiBytes, currentLoSumHiOddBytes);          currentLoSumHiEvenBytes =   vec_msum(candLoVectorHorizontalHi, candVectorLoBytes, currentLoSumHiEvenBytes);                    currentLoSumLoOddBytes =   vec_msum(candLoVectorHorizontalLo, candVectorHiBytes, currentLoSumLoOddBytes);          currentLoSumLoEvenBytes =   vec_msum(candLoVectorHorizontalLo, candVectorLoBytes, currentLoSumLoEvenBytes);                    ////////////////////////////////////////////////////////////////////          // shift high multiplicand vectors left by 4 elements (8 bytes)          // for next time through loop          ////////////////////////////////////////////////////////////////////          candLoVectorHorizontalHi =   vec_sld(candLoVectorHorizontalHi, candLoVectorHorizontalLo, 8);          candLoVectorHorizontalLo =   vec_sld(candLoVectorHorizontalLo, (vector unsigned short)zero, 8);          ////////////////////////////////////////////////////////////////////          // shift p2 right by 2 elements, so that our permute operation will          // select the hi and lo bytes of the next-highest two elements.          ////////////////////////////////////////////////////////////////////          p2 = vec_sld(zero, p2, 12);        }        ////////////////////////////////////////////////////////////////////        // Perform a loop similar to the one above, except we do not do        // the partial products for the low half of the low vector, since        // we know that it will be zero.  The partial products of these        // msums will be added to the results of the previous loop.        ////////////////////////////////////////////////////////////////////        for (innerLoop = 0; innerLoop &lt; 2; innerLoop++) {          candVectorLoBytes = vec_perm((vector unsigned short)zero,                      (vector unsigned short)p2, switchByteSelectorLo);          candVectorHiBytes = vec_perm((vector unsigned short)zero,                      (vector unsigned short)p2, switchByteSelectorHi);                    // ---------------------------------------------------------------------------------------------          currentHiSumHiOddBytes =   vec_msum(candHiVectorHorizontalHi, candVectorHiBytes, currentHiSumHiOddBytes);          currentHiSumHiEvenBytes =   vec_msum(candHiVectorHorizontalHi, candVectorLoBytes, currentHiSumHiEvenBytes);          currentHiSumLoOddBytes =   vec_msum(candHiVectorHorizontalLo, candVectorHiBytes, currentHiSumLoOddBytes);          currentHiSumLoEvenBytes =  vec_msum(candHiVectorHorizontalLo, candVectorLoBytes, currentHiSumLoEvenBytes);                    candHiVectorHorizontalHi =   vec_sld(candHiVectorHorizontalHi, candHiVectorHorizontalLo, 8);          candHiVectorHorizontalLo =   vec_sld(candHiVectorHorizontalLo, candLoVectorHorizontalHi, 8);          // ---------------------------------------------------------------------------------------------          currentLoSumHiOddBytes =   vec_msum(candLoVectorHorizontalHi, candVectorHiBytes, currentLoSumHiOddBytes);          currentLoSumHiEvenBytes =   vec_msum(candLoVectorHorizontalHi, candVectorLoBytes, currentLoSumHiEvenBytes);                    candLoVectorHorizontalHi =   vec_sld(candLoVectorHorizontalHi, candLoVectorHorizontalLo, 8);          // ---------------------------------------------------------------------------------------------          p2 = vec_sld(zero, p2, 12);        }      }            ////////////////////////////////////////////////////////////////////      // The loop above adds at most four partial products to each sum      // accumulator (currentHiSumHiOddBytes, etc...), each of which is      // at most 24 bits, which means that the result is at most 26 bits.      // We can add at most 32 of these together before the resulting      // sums will be 31 bits, which gives us room to double the sums      // without overflowing.  We want to provide room to double the      // sums because we can take advantage of an optimization while      // squaring a number.  In the columns of sums for a squared      // value, some products appear twice.  For example:      //      //     A*E      //     B*D      //     C*C      //     D*B      //     E*A      //            // So, we know that if we are pointing at two different vector      // digits, then their product should be added in twice to the      // end sum. By doubling these sums, we only have to perform      // approximately 1/2 the multiplications.            ////////////////////////////////////////////////////////////////////      ////////////////////////////////////////////////////////////////////      // if the multiplicand vectors are the same, we only add their      // product in once to the accumulated sum.      ////////////////////////////////////////////////////////////////////      singleadd = (pIncrementer++ == pDecrementer--);            ////////////////////////////////////////////////////////////////////      // if the pointers for the next multiplicand vectors are the same,      // then the next product will only be added in once.      ////////////////////////////////////////////////////////////////////            singlenext = (pIncrementer == pDecrementer);      ////////////////////////////////////////////////////////////////////            // if the pointers have passed one another, then this is the last      // product in the column.      ////////////////////////////////////////////////////////////////////            lastproduct = pDecrementer &lt; pIncrementer;            //-------------------------------------------------------------------------------------------------      // each of the sums of partial products is the sum of four partial products that are at most      // 25 bits each, which means that the sums will be at most 27 bits.  We can add a total of      // 32 of these together before we will overflow the sums, so we will check for that here. If      // we have reached saturation, we permute these partial sums into the form we need to add them      // together, and then add them and calculate the carries.  We also do this if it's the last      // time through the loop, or the second to last, so that we can do the last (single) add      // separately      ////////////////////////////////////////////////////////////////////            // If we have reached a saturation point for our accumulators (we      // have gone through the loop 32 times), or if the next product      // is one that doesn't get doubled, or if this is the last product      // that we add, then we add our results to the end sum.      ////////////////////////////////////////////////////////////////////                  if ( (!(++outerloopcount &amp; 0x1f)) || (singlenext | lastproduct)) {              ////////////////////////////////////////////////////////////////////                    // If this product isn't added in only once, then we double        // all of the accumulated products.        ////////////////////////////////////////////////////////////////////                    if (!singleadd) {          currentLoSumHiOddBytes = vec_add(currentLoSumHiOddBytes, currentLoSumHiOddBytes);          currentHiSumHiOddBytes = vec_add(currentHiSumHiOddBytes, currentHiSumHiOddBytes);          currentLoSumLoOddBytes = vec_add(currentLoSumLoOddBytes, currentLoSumLoOddBytes);          currentHiSumLoOddBytes = vec_add(currentHiSumLoOddBytes, currentHiSumLoOddBytes);          currentLoSumHiEvenBytes = vec_add(currentLoSumHiEvenBytes, currentLoSumHiEvenBytes);          currentHiSumHiEvenBytes = vec_add(currentHiSumHiEvenBytes, currentHiSumHiEvenBytes);          currentLoSumLoEvenBytes = vec_add(currentLoSumLoEvenBytes, currentLoSumLoEvenBytes);          currentHiSumLoEvenBytes = vec_add(currentHiSumLoEvenBytes, currentHiSumLoEvenBytes);        }                  ////////////////////////////////////////////////////////////////////        //  we have eight result vectors that are the sum of partial        //  products:        //        //        //  currentLoSumLoEvenBytes =  r8        //  currentLoSumLoOddBytes =  r7        //  currentLoSumHiEvenBytes =  r6        //  currentLoSumHiOddBytes =  r5        //  currentHiSumLoEvenBytes =  r4        //  currentHiSumLoOddBytes =  r3        //  currentHiSumHiEvenBytes =  r2        //  currentHiSumHiOddBytes =  r1        //        //  If each vector is broken down into four elements (i.e.        //   r1 = (r1A, r1B, r1C, r1D), then the vector elements need        //   to be added together in positions represented in this        //  chart:        //        //  Byte position:        //  -03 -02 -01 00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31        //  ----------------------------------------------------------------------------------------------------------------------------------------------        //        '      |---- r1D -----|                  '      |---- r5D -----|        //        '  |---- r1C -----|                      '  |---- r5C -----|        //      |---- r1B -----|                        |---- r5B -----|        //  |---- r1A -----|                        |---- r5A -----|        //        '        |---- r2D -----|                '        |---- r6D -----|        //        '    |---- r2C -----|                    '    |---- r6C -----|        //        |---- r2B -----|                        |---- r6B -----|        //    |---- r2A -----|                        |---- r2A -----|        //        '                      |---- r3D -----|  '                      |---- r7D -----|        //        '                  |---- r3C -----|      '                  |---- r7C -----|        //        '              |---- r3B -----|          '              |---- r7B -----|        //        '          |---- r3A -----|              '          |---- r7A -----|        //        '                        |---- r4D -----|'                        |---- r8D -----|        //        '                    |---- r4C -----  |    '                    |---- r8C -----|        //        '                |---- r4B -----|        '                |---- r8B -----|        //        '            |---- r4A -----|            '            |---- r8A -----|        //  --------------------------------------------------------------------------------------------------------------------------------------------        //        ^ vector boundary                        ^ vector boundary        //        //  To do this, we permute out of these vectors to create new        //  vectors that have non-overlapping elements.  For example,        //  we create the vectors         //        //  tempsumhi = (r2B, r2D, r4B, r4D)        //  tempsumlo = (r6B, r6D, r8B, r8D)        //        //  which can then be added into our final result vectors.        //          //        //  In the case of:        //        //  tempsumhi = (r2A, r2C, r4A, r4C)        //  tempsumlo = (r6A, r6C, r8A, r8C)        //        //  these vectors must be shifted left by 16 bits before        //   being added in to the result.  Note that this makes        //   the top 16 bits of tempsumhi overflow the high vector.        //  This overflow is accumulated as a carry for the next        //  column of calculations.        ////////////////////////////////////////////////////////////////////        ////////////////////////////////////////////////////////////////////        // add in vector elements which require no shifting                ////////////////////////////////////////////////////////////////////                  // select out elements        tempsumhi = vec_perm(currentHiSumHiEvenBytes, currentHiSumLoEvenBytes, staggeredSumPermuterEven);        tempsumlo = vec_perm(currentLoSumHiEvenBytes, currentLoSumLoEvenBytes, staggeredSumPermuterEven);        // figure out carry from adding to sum        carrytemphi = vec_addc(tempsumhi, sumhi);          carrytemplo = vec_addc(tempsumlo, sumlo);          // add in carry to existing carries        carryhi = vec_add(carryhi, carrytemphi);        carrylo = vec_add(carrylo, carrytemplo);        // add to sum        sumhi = vec_add(tempsumhi, sumhi);          sumlo = vec_add(tempsumlo, sumlo);        ////////////////////////////////////////////////////////////////////        // add in vector elements which require shifting 8 bits left        ////////////////////////////////////////////////////////////////////        // select out elements        tempsumhi = vec_perm(currentHiSumHiOddBytes, currentHiSumLoOddBytes, staggeredSumPermuterEven);        tempsumlo = vec_perm(currentLoSumHiOddBytes, currentLoSumLoOddBytes, staggeredSumPermuterEven);        // figure out how much shifts out of the vector, and add it to the next carry        carrytemphi = vec_sld(zero, tempsumhi, 1);        carrynext = vec_add(carrynext, carrytemphi);        // shift elements        tempsumhi = vec_sld(tempsumhi, tempsumlo, 1);        tempsumlo = vec_sld(tempsumlo, zero, 1);        // figure out carry        carrytemphi = vec_addc(tempsumhi, sumhi);          carrytemplo = vec_addc(tempsumlo, sumlo);          // add carry to existing carries        carryhi = vec_add(carryhi, carrytemphi);        carrylo = vec_add(carrylo, carrytemplo);        // add to sum        sumhi = vec_add(tempsumhi, sumhi);          sumlo = vec_add(tempsumlo, sumlo);        ////////////////////////////////////////////////////////////////////        // add in vector elements which require shifting 16 bits left        ////////////////////////////////////////////////////////////////////        // select out elements        tempsumhi = vec_perm(currentHiSumHiEvenBytes, currentHiSumLoEvenBytes, staggeredSumPermuterOdd);        tempsumlo = vec_perm(currentLoSumHiEvenBytes, currentLoSumLoEvenBytes, staggeredSumPermuterOdd);        // figure out how much shifts out of the vector, and add it to the carry        carrytemphi = vec_sld(zero, tempsumhi, 2);        carrynext = vec_add(carrynext, carrytemphi);                // shift elements        tempsumhi = vec_sld(tempsumhi, tempsumlo, 2);        tempsumlo = vec_sld(tempsumlo, zero, 2);        // figure out carry        carrytemphi = vec_addc(tempsumhi, sumhi);          carrytemplo = vec_addc(tempsumlo, sumlo);          // add carry to previous carry        carryhi = vec_add(carryhi, carrytemphi);        carrylo = vec_add(carrylo, carrytemplo);        // add to sum        sumhi = vec_add(tempsumhi, sumhi);          sumlo = vec_add(tempsumlo, sumlo);                ////////////////////////////////////////////////////////////////////        // add in vector elements which require shifting 16 bits left        ////////////////////////////////////////////////////////////////////        // select out elements        tempsumhi = vec_perm(currentHiSumHiOddBytes, currentHiSumLoOddBytes, staggeredSumPermuterOdd);        tempsumlo = vec_perm(currentLoSumHiOddBytes, currentLoSumLoOddBytes, staggeredSumPermuterOdd);        // figure out how much shifts out of the vector, and add it to the carry        carrytemphi = vec_sld(zero, tempsumhi, 3);        carrynext = vec_add(carrynext, carrytemphi);                // shift elements        tempsumhi = vec_sld(tempsumhi, tempsumlo, 3);        tempsumlo = vec_sld(tempsumlo, zero, 3);        // figure out carry        carrytemphi = vec_addc(tempsumhi, sumhi);          carrytemplo = vec_addc(tempsumlo, sumlo);          // add carry to previous carry        carryhi = vec_add(carryhi, carrytemphi);        carrylo = vec_add(carrylo, carrytemplo);        // add to sum        sumhi = vec_add(tempsumhi, sumhi);          sumlo = vec_add(tempsumlo, sumlo);                ////////////////////////////////////////////////////////////////////        // Now, if we're going through the loop again, we need to clear        // our partial product sums        ////////////////////////////////////////////////////////////////////        if (!lastproduct) {          currentLoSumHiOddBytes =  (vector unsigned long)(0);          currentLoSumHiEvenBytes =  (vector unsigned long)(0);          currentLoSumLoOddBytes =  (vector unsigned long)(0);          currentLoSumLoEvenBytes =  (vector unsigned long)(0);          currentHiSumHiOddBytes =  (vector unsigned long)(0);          currentHiSumHiEvenBytes =  (vector unsigned long)(0);          currentHiSumLoOddBytes =  (vector unsigned long)(0);          currentHiSumLoEvenBytes =  (vector unsigned long)(0);        }      }            ////////////////////////////////////////////////////////////////////      // continue this loop while there are more products to calculate      ////////////////////////////////////////////////////////////////////          } while (!lastproduct);        ////////////////////////////////////////////////////////////////////    // We have finished adding all partial products together, so now    // we need to reconcile all carries. We repeatedly shift the    // carries left by 32 bits, add them, and figure out the new    // resulting carry.    ////////////////////////////////////////////////////////////////////    do {      // add any overflow to carry for next column      carrynext = vec_add(carrynext, vec_sld(zero, carryhi, 4));            // shift carries left 32 bits      carryhi = vec_sld(carryhi, carrylo, 4);      carrylo = vec_sld(carrylo, zero, 4);            // figure out new high carry      carrytemphi = vec_addc(carryhi, sumhi);            // add carry to sum      sumhi = vec_add(carryhi, sumhi);            // save new carry      carryhi = carrytemphi;      // figure out new low carry      carrytemplo = vec_addc(carrylo, sumlo);            // add carry to sum      sumlo = vec_add(carrylo, sumlo);            // save new carry      carrylo = carrytemplo;    } while (!vec_all_eq(zero, vec_or(carryhi, carrylo)));    ////////////////////////////////////////////////////////////////////    // save this result, and increment pointer for storage of    // next result.    ////////////////////////////////////////////////////////////////////    *pResult++ = sumlo;        ////////////////////////////////////////////////////////////////////    // This column's high result is added in as part of next column's    // low result, and our carry goes in to the next columns high    // result.    ////////////////////////////////////////////////////////////////////        sumlo = sumhi;    sumhi = carrynext;    ////////////////////////////////////////////////////////////////////    // move bounds pointers to point to new bounds of 128-bit    // multiplicand elements.    ////////////////////////////////////////////////////////////////////    if (columnIndex &lt; len1) {      pTopBound++;      productCount++;    } else {      productCount--;      pBottomBound++;    }  }  ////////////////////////////////////////////////////////////////////  // save the final column's result  ////////////////////////////////////////////////////////////////////  *pResult = sumlo;}                    void VecMult1(            vector unsigned long *pMultiplier,                  unsigned long  vecCount,                  vector unsigned long *pVectors,                  vector unsigned long *pDest){  ////////////////////////////////////////////////////////////////////  // index for current vector digit that we are multiplying by  ////////////////////////////////////////////////////////////////////  unsigned long        columnIndex;    ////////////////////////////////////////////////////////////////////  // hi and lo vectors for sum of products for current column  ////////////////////////////////////////////////////////////////////    vector unsigned long    sumlo     = (vector unsigned long)(0);  vector unsigned long     sumhi     = (vector unsigned long)(0);  ////////////////////////////////////////////////////////////////////  // carry from sums in current column that carry over into next  // column.  ////////////////////////////////////////////////////////////////////  vector unsigned long    carryNext   = (vector unsigned long)(0);  ////////////////////////////////////////////////////////////////////  // all-purpose zero register  ////////////////////////////////////////////////////////////////////  vector unsigned long      zero     = (vector unsigned long)(0);  ////////////////////////////////////////////////////////////////////  // permute vectors for selecting multiplicand vectors for  // msum operation  ////////////////////////////////////////////////////////////////////  vector unsigned char     switchByteSelectorLo;    vector unsigned char     switchByteSelectorHi;    vector unsigned char     staggeredSumPermuterEven;  vector unsigned char     staggeredSumPermuterOdd;  ////////////////////////////////////////////////////////////////////  //  multiplicand by which we multiply array of vectors  ////////////////////////////////////////////////////////////////////  vector unsigned long    vMultiplier = *pMultiplier;  ////////////////////////////////////////////////////////////////////  //  Load or generate some constants that are needed for some  // of the vector manipulations that are performed in the multiplies  ////////////////////////////////////////////////////////////////////#if GENERATE_CONSTANTS    ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterOdd = 00 01 02 03 10 11 12 13 ...  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterOdd =     (vector unsigned char)vec_mergeh(                    (vector unsigned long)vec_lvsl(0, (unsigned long*)0),                    (vector unsigned long)vec_lvsr(0, (unsigned long*)0));    ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterEven = 08 09 0a 0b 18 19 1a 1b ...  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterEven  = vec_add(vec_splat_u8(8), staggeredSumPermuterOdd);  ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterOdd = 00010203 08090a0b 10111213 18191a1b  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterOdd    = (vector unsigned char)vec_mergeh(                    (vector unsigned long)staggeredSumPermuterOdd,                    (vector unsigned long)staggeredSumPermuterEven);    ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterEven = 04050607 0c0d0e0f 14151617 1c1d1e1f  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterEven  = vec_add(vec_splat_u8(4), staggeredSumPermuterOdd);              ////////////////////////////////////////////////////////////////////  // We generate two permute vectors that are used to select the high  // and low bytes of the rightmost shorts in a vector.  For example,  // given the multiplicand vectors V1 and V2, we get the following  // result:  //  //    Given That:  //    * V1:V2 = A B C D E F G H : I J K L M N P Q  //      (where each of {A....P} is a short)   //    *\xCAswitchByteSelectorHi = 0x001e 001c 001e 001c 001e 001c....  //  //     v3 = vec_perm(zero, v2, switchByteSelectorHi);  //  //     gives v3 = (0x00Qh 00Ph 00Qh 00Ph 00Qh 00Ph....  //    (High bytes of last two words)  //   //     v3 = vec_perm(zero, v2, switchByteSelectorLo);  //  //     gives v3 = (0x00Ql 00Pl 00Ql 00Pl 00Ql 00Pl....  //    (Low bytes of last two words)  ////////////////////////////////////////////////////////////////////  ////////////////////////////////////////////////////////////////////  // 10,11,12....0x1D 0x1E 0x1F  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = vec_lvsr(0, (int *)0);      ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x0000 0000....0x191b 0x1d1f  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = vec_pack((vector unsigned short)zero, (vector unsigned short)switchByteSelectorLo);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x1d1f, 1d1f, 1d1f....1d1f  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = (vector unsigned char)vec_splat((vector unsigned short)switchByteSelectorLo, 7);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x001d 001f, 001d, 001f....  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = (vector unsigned char)vec_unpackl((vector signed char)switchByteSelectorLo);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x001f, 001d, 001f, 001d...  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = vec_sld(switchByteSelectorLo, switchByteSelectorLo, 2);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorHi = 0001 0001 0001 0001...  ////////////////////////////////////////////////////////////////////  switchByteSelectorHi = (vector unsigned char)vec_splat_u16(1);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorHi = 0x001e, 001c, 001e, 001c...  ////////////////////////////////////////////////////////////////////  switchByteSelectorHi = vec_sub(switchByteSelectorLo, switchByteSelectorHi);  #else  switchByteSelectorLo =     (vector unsigned char)((vector unsigned long)(0x001f001d, 0x001f001d, 0x001f001d, 0x001f001d));  switchByteSelectorHi =     (vector unsigned char)((vector unsigned long)(0x001e001c, 0x001e001c, 0x001e001c, 0x001e001c));  staggeredSumPermuterEven =  (vector unsigned char)((vector unsigned long)(0x04050607, 0x0c0d0e0f, 0x14151617, 0x1c1d1e1f));  staggeredSumPermuterOdd =   (vector unsigned char)((vector unsigned long)(0x00010203, 0x08090a0b, 0x10111213, 0x18191a1b));#endif  ////////////////////////////////////////////////////////////////////  // loop through each column of result vectors in the product  ////////////////////////////////////////////////////////////////////  for (columnIndex = 1; columnIndex &lt; vecCount+1; columnIndex++) {    ////////////////////////////////////////////////////////////////////    // vectors to keep running sum from msum operations    ////////////////////////////////////////////////////////////////////    vector unsigned long currentLoSumHiOddBytes;    vector unsigned long currentLoSumHiEvenBytes;    vector unsigned long currentLoSumLoOddBytes;    vector unsigned long currentLoSumLoEvenBytes;    vector unsigned long currentHiSumHiOddBytes;    vector unsigned long currentHiSumHiEvenBytes;    vector unsigned long currentHiSumLoOddBytes;    vector unsigned long currentHiSumLoEvenBytes;                  ////////////////////////////////////////////////////////////////////    // temporary vectors for calculating sums    ////////////////////////////////////////////////////////////////////    vector unsigned long tempsumhi, tempsumlo;    ////////////////////////////////////////////////////////////////////    // temporary vectors for summing carries    ////////////////////////////////////////////////////////////////////    vector unsigned long carrytemphi, carrytemplo;    ////////////////////////////////////////////////////////////////////    // vectors for carries for hi, lo result vectors     ////////////////////////////////////////////////////////////////////    vector unsigned long carryhi, carrylo;      ////////////////////////////////////////////////////////////////////    // current vector from array that is used as multiplicand    ////////////////////////////////////////////////////////////////////    vector unsigned long currentVector;          ////////////////////////////////////////////////////////////////////    // index for looping through rows within vector product    ////////////////////////////////////////////////////////////////////    int    innerLoop;    ////////////////////////////////////////////////////////////////////    // clear carries and sums    ////////////////////////////////////////////////////////////////////    carryhi = (vector unsigned long)(0);    carrylo = (vector unsigned long)(0);    currentLoSumHiOddBytes=(vector unsigned long)(0);    currentLoSumHiEvenBytes=(vector unsigned long)(0);    currentLoSumLoOddBytes=(vector unsigned long)(0);    currentLoSumLoEvenBytes=(vector unsigned long)(0);    currentHiSumHiOddBytes=(vector unsigned long)(0);    currentHiSumHiEvenBytes=(vector unsigned long)(0);    currentHiSumLoOddBytes=(vector unsigned long)(0);    currentHiSumLoEvenBytes=(vector unsigned long)(0);    ////////////////////////////////////////////////////////////////////    // Here we calculate the product of the two vectors p1 and p2:    //     p1 = A B C D E F G H    //     p2 = a b c d e f g h    //    //  This product can be viewed as the familiar parallelogram of    // partial products:    //    //                    h*A h*B h*C h*D h*E h*F h*G h*H    //                  g*A g*B g*C g*D g*E g*F g*G g*H    //                f*A f*B f*C f*D f*E f*F f*G f*H    //              e*A e*B e*C e*D e*E e*F e*G e*H    //            d*A d*B d*C d*D d*E d*F d*G d*H    //          c*A c*B c*C c*D c*E c*F c*G c*H    //        b*A b*B b*C b*D b*E b*F b*G b*H    //      a*A a*B a*C a*D a*E a*F a*G a*H    //      ------------------------------------------------------------    //column:   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15    //    ////////////////////////////////////////////////////////////////////    {      ////////////////////////////////////////////////////////////////////      // multiplicand vectors for the msum operation      ////////////////////////////////////////////////////////////////////              vector unsigned short candVectorLoBytes;      vector unsigned short candVectorHiBytes;      vector unsigned short candHiVectorHorizontalHi;      vector unsigned short candHiVectorHorizontalLo;          vector unsigned short candLoVectorHorizontalHi;          vector unsigned short candLoVectorHorizontalLo;              ////////////////////////////////////////////////////////////////////      // vector that we use to permute out of for multiplicand vector      ////////////////////////////////////////////////////////////////////      vector unsigned short selectBLo;      ////////////////////////////////////////////////////////////////////      // get vector &quot;digit&quot; for multiplicand       ////////////////////////////////////////////////////////////////////              currentVector = *pVectors++;            ////////////////////////////////////////////////////////////////////      // Generate multiplicand vectors      ////////////////////////////////////////////////////////////////////              candLoVectorHorizontalHi = (vector unsigned short)vec_mergeh((vector unsigned short)currentVector, (vector unsigned short)currentVector);      candLoVectorHorizontalLo = (vector unsigned short)vec_mergel((vector unsigned short)currentVector, (vector unsigned short)currentVector);                                                candHiVectorHorizontalHi = (vector unsigned short)(0);      ////////////////////////////////////////////////////////////////////      // shift cand vectors over by one      ////////////////////////////////////////////////////////////////////      candHiVectorHorizontalLo = vec_sld((vector unsigned short)zero, candLoVectorHorizontalHi, 2);      candLoVectorHorizontalHi = vec_sld(candLoVectorHorizontalHi, candLoVectorHorizontalLo, 2);      candLoVectorHorizontalLo = vec_sld(candLoVectorHorizontalLo, (vector unsigned short)zero, 2);      ////////////////////////////////////////////////////////////////////      // We now have these four partial multiplicand vectors:      //       // candHiVectorHorizontalHi = (0, 0, 0, 0, 0, 0, 0, 0)      // candHiVectorHorizontalLo = (0, 0, 0, 0, 0, 0, 0, A)      // candLoVectorHorizontalHi = (A, B, B, C, C, D, D, E)      // candLoVectorHorizontalLo = (E, F, F, G, G, H, H, 0)      //      ////////////////////////////////////////////////////////////////////              selectBLo = (vector unsigned short)vMultiplier;      ////////////////////////////////////////////////////////////////////              //  We go through the following loop two times, to calculate the      // top four rows of the parallelogram (each time through the loop      // we calculate two rows).  We do this because we know that the       // upper fourth of the result (corresponding to candHiVectorHorizontalHi)      // is zero, so we don't need to perform that msum operation.        ////////////////////////////////////////////////////////////////////              for (innerLoop = 0; innerLoop &lt; 2; innerLoop++) {        ////////////////////////////////////////////////////////////////////                // generate other set of multiplicand vectors.  The first time        // through the loop, this will generate:        //        // candVectorLoBytes = (00hl 00gl 00hl 00gl 00hl 00gl 00hl 00gl)        // candVectorHiBytes = (00hh 00gh 00hh 00gh 00hh 00gh 00hh 00gh)        //        // (where 'hl' is the low byte of the 16-bit element 'h', and        // 'gh' is the high byte of the 16-bit element 'g'.)        //        // The second time through, it will generate:                  // candVectorLoBytes = (00fl 00el 00fl 00el 00fl 00el 00fl 00el)        // candVectorHiBytes = (00fh 00eh 00fh 00eh 00fh 00eh 00fh 00eh)        //        ////////////////////////////////////////////////////////////////////                candVectorLoBytes = vec_perm((vector unsigned short)zero,                    selectBLo, switchByteSelectorLo);        candVectorHiBytes = vec_perm((vector unsigned short)zero,                    selectBLo, switchByteSelectorHi);                ////////////////////////////////////////////////////////////////////                //  The msum operation takes arguments 1 and 2 and multiplies their        // 16-bit elements together to yield 8 32-bit results.  It then adds        // results 1+2, 3+4, 5+6, 7+8, yielding 4 32-bit results.  Each of        // these elements is added to the corresponding 32-bit element of        // argument 3.  So, if we have:        //        //   candHiVectorHorizontalLo =  (0,     0,    0,    0,    0,    0,    0,    A)        //  candVectorHiBytes =     (00hh, 00gh, 00hh, 00gh, 00hh, 00gh, 00hh, 00gh)          //  currentHiSumLoOddBytes =   (0,          0,          0,          0)        //          // Then vec_msum(candHiVectorHorizontalLo, candVectorHiBytes, currentHiSumLoOddBytes)        // will produce:        //        //  (0, 0, 0, A*gh)        //            // and vec_msum(candHiVectorHorizontalLo, candVectorLoBytes, currentHiSumLoEvenBytes);        // will produce:        //          //  (0, 0, 0, A*gl)        //        //  The next time through the loop, when we have:        //        //   candHiVectorHorizontalLo =  (0,    0,    0,    A,    A,    B,    B,    C)        //  candVectorHiBytes =     (00fh, 00eh, 00fh, 00eh, 00fh, 00eh, 00fh, 00eh)        //  currentHiSumLoOddBytes =   (0,          0,          0,          A*gh)        //        //   currentHiSumLoOddBytes = vec_msum(  candHiVectorHorizontalLo,         //                    candVectorHiBytes,         //                    currentHiSumLoOddBytes);        //        //   will produce:        //        //  currentHiSumLoOddBytes =         //    (0, A*eh, (A*fh)+(B*eh), (B*fh)+(C*eh)+(A*gh))        //        //  Because the products are 24 bits each, we can add them together        // without worrying about carries, since each element in the vectors        // for the sums of partial products is 32 bits.        ////////////////////////////////////////////////////////////////////                currentHiSumLoOddBytes =   vec_msum(candHiVectorHorizontalLo, candVectorHiBytes, currentHiSumLoOddBytes);        currentHiSumLoEvenBytes =   vec_msum(candHiVectorHorizontalLo, candVectorLoBytes, currentHiSumLoEvenBytes);                ////////////////////////////////////////////////////////////////////        // shift high multiplicand vectors left by 4 elements (8 bytes)        // for next time through loop        ////////////////////////////////////////////////////////////////////        candHiVectorHorizontalHi =   vec_sld(candHiVectorHorizontalHi, candHiVectorHorizontalLo, 8);        candHiVectorHorizontalLo =   vec_sld(candHiVectorHorizontalLo, candLoVectorHorizontalHi, 8);        // ---------------------------------------------------------------------------------------------        ////////////////////////////////////////////////////////////////////        // perform partial products for low side of result        //         // first time through loop:        //   candLoVectorHorizontalHi =   (A,    B,    B,    C,    C,    D,    D,    E)        //  candVectorHiBytes =     (00hh, 00gh, 00hh, 00gh, 00hh, 00gh, 00hh, 00gh)          //   currentLoSumHiOddBytes =  (0           0           0           0)        //         // then        //   currentLoSumHiOddBytes = vec_msum(  candLoVectorHorizontalHi,        //                    candVectorHiBytes,         //                    currentLoSumHiOddBytes)        // will produce:        //        //  currentLoSumHiOddBytes = ((A*hh)+(B*gh), (B*hh)+(C*gh), (C*hh)+(D*gh), (D*hh)+(E*gh))        //        // second time through the loop:        //   candLoVectorHorizontalHi =   (C,    D,    D,    E,    E,     F,    F,    G)        //  candVectorHiBytes =     (00fh, 00eh, 00fh, 00eh, 00fh, 00eh, 00fh, 00eh)        //  currentLoSumHiOddBytes =   ( (A*hh)+(B*gh), (B*hh)+(C*gh), (C*hh)+(D*gh), (D*hh)+(E*gh) )        //        //   currentLoSumHiOddBytes = vec_msum(  candLoVectorHorizontalHi,        //                    candVectorHiBytes,         //                    currentLoSumHiOddBytes)        // will produce:        //  currentLoSumHiOddBytes = (  (A*hh)+(B*gh)+(C*fh)+(D*eh),        //                 (B*hh)+(C*gh)+(D*fh)+(E*eh),        //                (C*hh)+(D*gh)+(E*fh)+(F*eh),        //                (D*hh)+(E*gh)+(F*fh)+(G*eh) )        //        // Note that each of these four elements corresponds to the sums        // of the partial products of the first four rows of columns 8-11         // in the above parallelogram.        //        ////////////////////////////////////////////////////////////////////        currentLoSumHiOddBytes =   vec_msum(candLoVectorHorizontalHi, candVectorHiBytes, currentLoSumHiOddBytes);        currentLoSumHiEvenBytes =   vec_msum(candLoVectorHorizontalHi, candVectorLoBytes, currentLoSumHiEvenBytes);                currentLoSumLoOddBytes =   vec_msum(candLoVectorHorizontalLo, candVectorHiBytes, currentLoSumLoOddBytes);        currentLoSumLoEvenBytes =   vec_msum(candLoVectorHorizontalLo, candVectorLoBytes, currentLoSumLoEvenBytes);                ////////////////////////////////////////////////////////////////////        // shift high multiplicand vectors left by 4 elements (8 bytes)        // for next time through loop        ////////////////////////////////////////////////////////////////////        candLoVectorHorizontalHi =   vec_sld(candLoVectorHorizontalHi, candLoVectorHorizontalLo, 8);        candLoVectorHorizontalLo =   vec_sld(candLoVectorHorizontalLo, (vector unsigned short)zero, 8);        ////////////////////////////////////////////////////////////////////        // shift selectBLo right by 2 elements, so that our permute        // operation will select the hi and lo bytes of the next-highest        // two elements.        ////////////////////////////////////////////////////////////////////        selectBLo = vec_sld((vector unsigned short)zero, selectBLo, 12);      }      ////////////////////////////////////////////////////////////////////      // Perform a loop similar to the one above, except we do not do      // the partial products for the low half of the low vector, since      // we know that it will be zero.  The partial products of these      // msums will be added to the results of the previous loop.      ////////////////////////////////////////////////////////////////////      for (innerLoop = 0; innerLoop &lt; 2; innerLoop++) {        candVectorLoBytes = vec_perm((vector unsigned short)zero,                    selectBLo, switchByteSelectorLo);        candVectorHiBytes = vec_perm((vector unsigned short)zero,                    selectBLo, switchByteSelectorHi);                // ---------------------------------------------------------------------------------------------        currentHiSumHiOddBytes = vec_msum(candHiVectorHorizontalHi, candVectorHiBytes, currentHiSumHiOddBytes);        currentHiSumHiEvenBytes = vec_msum(candHiVectorHorizontalHi, candVectorLoBytes, currentHiSumHiEvenBytes);        currentHiSumLoOddBytes = vec_msum(candHiVectorHorizontalLo, candVectorHiBytes, currentHiSumLoOddBytes);        currentHiSumLoEvenBytes = vec_msum(candHiVectorHorizontalLo, candVectorLoBytes, currentHiSumLoEvenBytes);                candHiVectorHorizontalHi = vec_sld(candHiVectorHorizontalHi, candHiVectorHorizontalLo, 8);        candHiVectorHorizontalLo = vec_sld(candHiVectorHorizontalLo, candLoVectorHorizontalHi, 8);        // ---------------------------------------------------------------------------------------------        currentLoSumHiOddBytes = vec_msum(candLoVectorHorizontalHi, candVectorHiBytes, currentLoSumHiOddBytes);        currentLoSumHiEvenBytes = vec_msum(candLoVectorHorizontalHi, candVectorLoBytes, currentLoSumHiEvenBytes);                candLoVectorHorizontalHi = vec_sld(candLoVectorHorizontalHi, candLoVectorHorizontalLo, 8);        // ---------------------------------------------------------------------------------------------        selectBLo = vec_sld((vector unsigned short)zero, selectBLo, 12);      }    }        ////////////////////////////////////////////////////////////////////    //  we have eight result vectors that are the sum of partial    //  products:    //    //    //  currentLoSumLoEvenBytes =  r8    //  currentLoSumLoOddBytes =  r7    //  currentLoSumHiEvenBytes =  r6    //  currentLoSumHiOddBytes =  r5    //  currentHiSumLoEvenBytes =  r4    //  currentHiSumLoOddBytes =  r3    //  currentHiSumHiEvenBytes =  r2    //  currentHiSumHiOddBytes =  r1    //    //  If each vector is broken down into four elements (i.e.    //   r1 = (r1A, r1B, r1C, r1D), then the vector elements need    //   to be added together in positions represented in this    //  chart:    //    //  Byte position:    //  -03 -02 -01 00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31    //  ----------------------------------------------------------------------------------------------------------------------------------------------    //        '      |---- r1D -----|                  '      |---- r5D -----|    //        '  |---- r1C -----|                      '  |---- r5C -----|    //      |---- r1B -----|                        |---- r5B -----|    //  |---- r1A -----|                        |---- r5A -----|    //        '        |---- r2D -----|                '        |---- r6D -----|    //        '    |---- r2C -----|                    '    |---- r6C -----|    //        |---- r2B -----|                        |---- r6B -----|    //    |---- r2A -----|                        |---- r2A -----|    //        '                      |---- r3D -----|  '                      |---- r7D -----|    //        '                  |---- r3C -----|      '                  |---- r7C -----|    //        '              |---- r3B -----|          '              |---- r7B -----|    //        '          |---- r3A -----|              '          |---- r7A -----|    //        '                        |---- r4D -----|'                        |---- r8D -----|    //        '                    |---- r4C -----  |    '                    |---- r8C -----|    //        '                |---- r4B -----|        '                |---- r8B -----|    //        '            |---- r4A -----|            '            |---- r8A -----|    //  --------------------------------------------------------------------------------------------------------------------------------------------    //        ^ vector boundary                        ^ vector boundary    //    //  To do this, we permute out of these vectors to create new    //  vectors that have non-overlapping elements.  For example,    //  we create the vectors     //    //  tempsumhi = (r2B, r2D, r4B, r4D)    //  tempsumlo = (r6B, r6D, r8B, r8D)    //    //  which can then be added into our final result vectors.    //      //    //  In the case of:    //    //  tempsumhi = (r2A, r2C, r4A, r4C)    //  tempsumlo = (r6A, r6C, r8A, r8C)    //    //  these vectors must be shifted left by 16 bits before    //   being added in to the result.  Note that this makes    //   the top 16 bits of tempsumhi overflow the high vector.    //  This overflow is accumulated as a carry for the next    //  column of calculations.    ////////////////////////////////////////////////////////////////////    ////////////////////////////////////////////////////////////////////    // add in vector elements which require no shifting            ////////////////////////////////////////////////////////////////////        // select out elements    tempsumhi = vec_perm(currentHiSumHiEvenBytes, currentHiSumLoEvenBytes, staggeredSumPermuterEven);    tempsumlo = vec_perm(currentLoSumHiEvenBytes, currentLoSumLoEvenBytes, staggeredSumPermuterEven);    // figure out carry from adding to sum    carrytemphi = vec_addc(tempsumhi, sumhi);      carrytemplo = vec_addc(tempsumlo, sumlo);      // add in carry to existing carries    carryhi = vec_add(carryhi, carrytemphi);    carrylo = vec_add(carrylo, carrytemplo);    // add to sum    sumhi = vec_add(tempsumhi, sumhi);      sumlo = vec_add(tempsumlo, sumlo);    ////////////////////////////////////////////////////////////////////    // add in vector elements which require shifting 8 bits left    ////////////////////////////////////////////////////////////////////    // select out elements    tempsumhi = vec_perm(currentHiSumHiOddBytes, currentHiSumLoOddBytes, staggeredSumPermuterEven);    tempsumlo = vec_perm(currentLoSumHiOddBytes, currentLoSumLoOddBytes, staggeredSumPermuterEven);    // shift elements    tempsumhi = vec_sld(tempsumhi, tempsumlo, 1);    tempsumlo = vec_sld(tempsumlo, zero, 1);    // figure out carry    carrytemphi = vec_addc(tempsumhi, sumhi);      carrytemplo = vec_addc(tempsumlo, sumlo);      // add carry to existing carries    carryhi = vec_add(carryhi, carrytemphi);    carrylo = vec_add(carrylo, carrytemplo);    // add to sum    sumhi = vec_add(tempsumhi, sumhi);      sumlo = vec_add(tempsumlo, sumlo);    ////////////////////////////////////////////////////////////////////    // add in vector elements which require shifting 16 bits left    ////////////////////////////////////////////////////////////////////    // select out elements    tempsumhi = vec_perm(currentHiSumHiEvenBytes, currentHiSumLoEvenBytes, staggeredSumPermuterOdd);    tempsumlo = vec_perm(currentLoSumHiEvenBytes, currentLoSumLoEvenBytes, staggeredSumPermuterOdd);        // shift elements    tempsumhi = vec_sld(tempsumhi, tempsumlo, 2);    tempsumlo = vec_sld(tempsumlo, zero, 2);    // figure out carry    carrytemphi = vec_addc(tempsumhi, sumhi);      carrytemplo = vec_addc(tempsumlo, sumlo);      // add carry to previous carry    carryhi = vec_add(carryhi, carrytemphi);    carrylo = vec_add(carrylo, carrytemplo);    // add to sum    sumhi = vec_add(tempsumhi, sumhi);      sumlo = vec_add(tempsumlo, sumlo);        ////////////////////////////////////////////////////////////////////    // add in vector elements which require shifting 16 bits left    ////////////////////////////////////////////////////////////////////    // select out elements    tempsumhi = vec_perm(currentHiSumHiOddBytes, currentHiSumLoOddBytes, staggeredSumPermuterOdd);    tempsumlo = vec_perm(currentLoSumHiOddBytes, currentLoSumLoOddBytes, staggeredSumPermuterOdd);        // shift elements    tempsumhi = vec_sld(tempsumhi, tempsumlo, 3);    tempsumlo = vec_sld(tempsumlo, zero, 3);    // figure out carry    carrytemphi = vec_addc(tempsumhi, sumhi);      carrytemplo = vec_addc(tempsumlo, sumlo);      // add carry to previous carry    carryhi = vec_add(carryhi, carrytemphi);    carrylo = vec_add(carrylo, carrytemplo);    // add to sum    sumhi = vec_add(tempsumhi, sumhi);      sumlo = vec_add(tempsumlo, sumlo);    ////////////////////////////////////////////////////////////////////    // We have finished adding all partial products together, so now    // we need to reconcile all carries. We repeatedly shift the    // carries left by 32 bits, add them, and figure out the new    // resulting carry.    ////////////////////////////////////////////////////////////////////    do {      carryhi = vec_sld(carryhi, carrylo, 4);      carrylo = vec_sld(carrylo, zero, 4);            carrytemphi = vec_addc(carryhi, sumhi);      sumhi = vec_add(carryhi, sumhi);      carryhi = carrytemphi;      carrytemplo = vec_addc(carrylo, sumlo);      sumlo = vec_add(carrylo, sumlo);      carrylo = carrytemplo;    } while (!vec_all_eq(zero, vec_or(carryhi, carrylo)));    *pDest++ = sumlo;        sumlo = sumhi;    sumhi = (vector unsigned long)(0);  }  *pDest = sumlo;}/*  mult2by2 multiplies two 256-bit values to compute a 512-bit result.  The two  multiplicand vectors (A and B), for the sake of representation, are broken  down into 16-bit elements A-P:    A = A B C D E F G H I J K L M N O P  B = a b c d e f g h i j k l m n o p  With the full result written out as:    X   X   X   X   X   X   X   X | Y   Y   Y   Y   Y   Y   Y   Y|||A   B   C   D   E   F   G   H | I   J   K   L   M   N   O   P  X   X   X   X   X   X   X   X | Y   Y   Y   Y   Y   Y   Y   Y|||a   b   c   d   e   f   g   h | i   j   k   l   m   n   o   p  -------------------------------------------------------------------------------------------------------------------------------                                  p*A  p*B p*C p*D p*E p*F p*G p*H p*I p*J p*K p*L p*M p*N p*O p*P                                o*A  o*B o*C o*D o*E o*F o*G o*H o*I o*J o*K o*L o*M o*N o*O o*P                              n*A  n*B n*C n*D n*E n*F n*G n*H n*I n*J n*K n*L n*M n*N n*O n*P                            m*A  m*B m*C m*D m*E m*F m*G m*H m*I m*J m*K m*L m*M m*N m*m m*P                          l*A  l*B l*C l*D l*E l*F l*G l*H l*I l*J l*K l*L l*M l*N l*O l*P                        k*A  k*B k*C k*D k*E k*F k*G k*H k*I k*J k*K k*L k*M k*N k*O k*P                      j*A  j*B j*C j*D j*E j*F j*G j*H j*I j*J j*K j*L j*M j*N j*O j*P                    i*A  i*B i*C i*D i*E i*F i*G i*H i*I i*J i*K i*L i*M i*N i*O i*P                  h*A  h*B h*C h*D h*E h*F h*G h*I h*I h*J h*K h*L h*M h*N h*O h*P                g*A  g*B g*C g*D g*E g*F g*G g*H g*I g*J g*K g*L g*M g*N g*O g*P              f*A  f*B f*C f*D f*E f*F f*G f*H f*I f*J f*K f*L f*M f*N f*O f*P            e*A  e*B e*C e*D e*E e*F e*G e*H e*I e*J e*K e*L e*M e*N e*O e*P          d*A  d*B d*C d*D d*E d*F d*G d*H d*I d*J d*K d*L d*M d*N d*O d*P        c*A  c*B c*C c*D c*E c*F c*G c*H c*I c*J c*K c*L c*M c*N c*O c*P      b*A  b*B b*C b*D b*E b*F b*G b*H b*I b*J b*K b*L b*M b*N b*O b*P    a*A  a*B a*C a*D a*E a*F a*G a*H a*I a*J a*K a*L a*M a*N a*O a*P  -------------------------------------------------------------------------------------------------------------------------------    |    Section 3        |      Section 2        |      Section 1        |      Section 0        |    The rightmost portion (section 0) of the partial products parallelogram looks like this:    p*I p*J p*K p*L p*M p*N p*O p*P    o*J o*K o*L o*M o*N o*O o*P    n*K n*L n*M n*N n*O n*P    m*L m*M m*N m*m m*P    l*M l*N l*O l*P    k*N k*O k*P    j*O j*P    i*P  Taking the top two rows:    p*I p*J p*K p*L p*M p*N p*O p*P    o*J o*K o*L o*M o*N o*O o*P    We see that the sum of these two rows is the sum of four vectors of partial  products, where p' is the low byte of halfword p, and p&quot; is the high byte  of halfword p:         I*p' J*p' K*p' L*p' M*p' N*p' O*p' P*p'        J*o' K*o' L*o' M*o' N*o' O*o' P*o' --      I*p&quot; J*p&quot; K*p&quot; L*p&quot; M*p&quot; N*p&quot; O*p&quot; P*p&quot;    +  J*o&quot; K*p&quot; L*p&quot; M*p&quot; N*p&quot; O*p&quot; P*p&quot; --    ---------------------------------------------------  The first column is then [(I*p')+(J*o')] + [((I*p&quot;)+(J*o&quot;)) &lt;&lt; 8)]  So, if we generate the vectors:  v1 = I  J  J  K  K  L  L  M    u1 = p' o' p' o' p' o' p' o'  where I, J, etc. are 16-bit values, and p', o' are 16 bit values, with the MSB  being 0, then by performing an msum on 16-bit elements, we get the following:    r1 = vec_msum(v1, u1, W);    r1 = I*p'+J*o'+W(0)  J*p'+K*o'+W(1) K*p'L*o'+W(2) L*p'+M*o'+W(3)  where each element is a 32-bit result, with W(n) being the nth 32-bit  element in the vector W, i.e.    W = W0|W1|W2|W3  So, given the four partial-product rows and the msum operation, we can  similarly calculate these other three vectors:    r2 = I*p&quot;+J*o&quot;+X(0) J*p&quot;+K*o&quot;+X(1) K*p'+L*o&quot;+X(2) L*p&quot;+M*o&quot;+X(3)    r3 = M*p'+N*o'+Y(0) N*p'+O*o'+Y(1) O*p'+P*o'+Y(2) 0+Y(3)    r4 = M*p&quot;+N*o&quot;+Z(0) N*p&quot;+O*o&quot;+Z(1) O*p&quot;+P*o&quot;+Z(2) 0+Z(3)  We then assign these four vectors to W, X, Y, and Z, respectively, and  calculate r1 thru r4 for the next two rows down in our result, specifically:      n*K n*L n*M n*N n*O n*P --- ---    m*L m*M m*N m*O m*P --- --- ---    Because we have assigned the previous rows' results to W X Y Z,   at the end, we end up with the four partial sums of the eight columns  for all four rows, since the previous results get added in during the  msum operation.    Continuing this iteratively through all rows, we end up with four  vectors containing partial sums for each column. Because the result  of each 8*16 bit multiply is 24 bits, and we're adding a total of at  most 8 of them together, we know that each partial sum will not overflow  its 32-bit vector element, thus eliminating any need for dealing with carries.    The next step is to add these vectors together into one result. The problem  is that we have a 32-bit result for each column, which must be added in-place  in a 16-bit position, with the carry accounted for.  To facilitate this we divide  each result vector into 32-bit values as follows:      r1 = r1A r1B r1C r1D    (high byte, high side of sum)    r2 = r2A r2B r2C r2D    (low byte, high side of sum)    r3 = r3A r3B r3C r3D    (high byte, low side of sum)    r4 = r4A r4B r4C r4D    (low byte, low side of sum)        Some of these results must be shifted left by 8 bits, since they were calculated  by using a partial product with a high-order byte in a low-order position.      Here is a diagram showing the relative positions of each 32 bit value in the  complete sum.      -- Byte position, with negative numbers being into the next vector --    -04 -03 -02 -01 00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15  -------------------------------------------------------------------------------------          '      |---- r1D -----|          '  |---- r1C -----|        |---- r1B -----|    |---- r1A -----|          '        |---- r2D -----|          '    |---- r2C -----|          |---- r2B -----|      |---- r2A -----|          '                      |---- r3D -----|          '                  |---- r3C -----|          '              |---- r3B -----|          '          |---- r3A -----|          '                        |---- r4D -----|          '                    |---- r4C -----|          '                |---- r4B -----|          '            |---- r4A -----|    ------------------------------------------------------------------------------------    To simplify additions, we regroup these into four vectors with no overlapping sums:      Q = r1A r1C r3A r3C    R = r2A r2C r4A r4C    S = r1B r1D r3B r3D    T = r2B r2D r4B r4D      Now, the total can be written as:          Q &lt;&lt; 3 Bytes        R &lt;&lt; 2 Bytes        S &lt;&lt; 1 Byte      +  T &lt;&lt; 0 Bytes    ----------------------      Total Right 1/4    There are carries to deal with, both within the result and outside of it.  To  account for the overlap on the left with the next sum, we figure out the parts of  Q, R, S that overlap, and sum them to a carry value to be saved for the next  column's result.    As we add the vectors together, we also accumulate carries, which are resolved  after all additions are completed.      Once all of this has been done, the process is repeated for the remaining  three single-vector wide columns of results (sections 1-3), to yield the 512-bit  product.*/void mult2by2(  vector unsigned long  *pA0,        vector unsigned long  *pA1,        vector unsigned long  *pB0,        vector unsigned long  *pB1,        vector unsigned long  *results){  int      innerloop;    ////////////////////////////////////////////////////////////////////  // initialize a zero vector that will be used for our calculations  // (faster than having to generate it everywhere we need it)  ////////////////////////////////////////////////////////////////////      vector unsigned long  zero = (vector unsigned long)(0);  ////////////////////////////////////////////////////////////////////  // our four result vectors   ////////////////////////////////////////////////////////////////////  vector unsigned long    R0;  vector unsigned long    R1;  vector unsigned long    R2;  vector unsigned long    R3;  ////////////////////////////////////////////////////////////////////  // initialize carries to zero  ////////////////////////////////////////////////////////////////////  vector unsigned long  C0=(vector unsigned long)(0);  vector unsigned long  C1=(vector unsigned long)(0);  vector unsigned long  C2=(vector unsigned long)(0);  vector unsigned long  C3=(vector unsigned long)(0);          ////////////////////////////////////////////////////////////////////  // a temporary sum value  ////////////////////////////////////////////////////////////////////  vector unsigned long tempSum;    ////////////////////////////////////////////////////////////////////  // a temporary carry value  ////////////////////////////////////////////////////////////////////  vector unsigned long carryTemp;      ////////////////////////////////////////////////////////////////////  // permute vectors, used to create v1, v2  ////////////////////////////////////////////////////////////////////  vector unsigned char staggerSelectorHi;      vector unsigned char staggerSelectorLo;      ////////////////////////////////////////////////////////////////////  // permute vectors, used to create u1, u2  ////////////////////////////////////////////////////////////////////  vector unsigned char switchByteSelectorLo;    vector unsigned char switchByteSelectorHi;    ////////////////////////////////////////////////////////////////////  // permute vectors, used to create Q, R, S, T  ////////////////////////////////////////////////////////////////////  vector unsigned char staggeredSumPermuterEven;  vector unsigned char staggeredSumPermuterOdd;  ////////////////////////////////////////////////////////////////////  // vectors to keep running sum from msum operations (r1, r2, r3, r4)  ////////////////////////////////////////////////////////////////////  vector unsigned long currentSumHiOddBytes;  vector unsigned long currentSumHiEvenBytes;  vector unsigned long currentSumLoOddBytes;  vector unsigned long currentSumLoEvenBytes;  ////////////////////////////////////////////////////////////////////  // create or load vectors we will use (for permute operation) to  // generate multiplicand vectors for the msum operation.  ////////////////////////////////////////////////////////////////////  #if GENERATE_CONSTANTS    ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterOdd = 00 01 02 03 10 11 12 13 ...  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterOdd =     (vector unsigned char)vec_mergeh(                    (vector unsigned long)vec_lvsl(0, (unsigned long*)0),                    (vector unsigned long)vec_lvsr(0, (unsigned long*)0));    ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterEven = 08 09 0a 0b 18 19 1a 1b ...  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterEven  = vec_add(vec_splat_u8(8), staggeredSumPermuterOdd);  ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterOdd = 00010203 08090a0b 10111213 18191a1b  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterOdd    = (vector unsigned char)vec_mergeh(                    (vector unsigned long)staggeredSumPermuterOdd,                    (vector unsigned long)staggeredSumPermuterEven);    ////////////////////////////////////////////////////////////////////  // staggeredSumPermuterEven = 04050607 0c0d0e0f 14151617 1c1d1e1f  ////////////////////////////////////////////////////////////////////  staggeredSumPermuterEven  = vec_add(vec_splat_u8(4), staggeredSumPermuterOdd);              ////////////////////////////////////////////////////////////////////  // We generate two permute vectors that are used to select the high  // and low bytes of the rightmost shorts in a vector.  For example,  // given the multiplicand vectors V1 and V2, we get the following  // result:  //  //    Given That:  //    * V1:V2 = A B C D E F G H : I J K L M N P Q  //      (where each of {A....P} is a short)   //    *\xCAswitchByteSelectorHi = 0x001e 001c 001e 001c 001e 001c....  //  //     v3 = vec_perm(zero, v2, switchByteSelectorHi);  //  //     gives v3 = (0x00Qh 00Ph 00Qh 00Ph 00Qh 00Ph....)  //    (High bytes of last two words)  //   //     v3 = vec_perm(zero, v2, switchByteSelectorLo);  //  //     gives v3 = (0x00Ql 00Pl 00Ql 00Pl 00Ql 00Pl....)  //    (Low bytes of last two words)  ////////////////////////////////////////////////////////////////////  ////////////////////////////////////////////////////////////////////  // 10,11,12....0x1D 0x1E 0x1F  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = vec_lvsr(0, (int *)0);      ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x0000 0000....0x191b 0x1d1f  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = vec_pack((vector unsigned short)zero, (vector unsigned short)switchByteSelectorLo);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x1d1f, 1d1f, 1d1f....1d1f  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = (vector unsigned char)vec_splat((vector unsigned short)switchByteSelectorLo, 7);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x001d 001f, 001d, 001f....  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = (vector unsigned char)vec_unpackl((vector signed char)switchByteSelectorLo);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorLo = 0x001f, 001d, 001f, 001d...  ////////////////////////////////////////////////////////////////////  switchByteSelectorLo = vec_sld(switchByteSelectorLo, switchByteSelectorLo, 2);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorHi = 0001 0001 0001 0001...  ////////////////////////////////////////////////////////////////////  switchByteSelectorHi = (vector unsigned char)vec_splat_u16(1);  ////////////////////////////////////////////////////////////////////  // switchByteSelectorHi = 0x001e, 001c, 001e, 001c...  ////////////////////////////////////////////////////////////////////  switchByteSelectorHi = vec_sub(switchByteSelectorLo, switchByteSelectorHi);  ////////////////////////////////////////////////////////////////////  // Next we generate permute vectors that can be used to select   // vectors in the following pattern.  //   //    Given That:  //    * v1:v2 = A B C D E F G H : I J K L M N O P  //      (where each of {A....P} is a short)   //    *\xCAstaggerSelectorHi = 0x0001 0x0203 0203 0405 0405...  //  //     v3 = vec_perm(v1, v2, staggerSelectorHi);  //  //     gives v3 = A B B C C D D E   //   //     v3 = vec_perm(v1, v2, staggerSelectorLo);  //  //     gives v3 = E F F G G H H I  //  ////////////////////////////////////////////////////////////////////  ////////////////////////////////////////////////////////////////////  // generate 0001 0203 0203 0405 0405 0607 0607 0809  ////////////////////////////////////////////////////////////////////  staggerSelectorHi = vec_lvsl(0, (int *)0);  // 00 01 02 03 04 05 06 07 08 09  staggerSelectorLo = vec_lvsl(2, (int *)0);  // 02 03 04 05 06 07 08 09 0A 0B  staggerSelectorHi = (vector unsigned char)vec_mergeh((vector unsigned short)staggerSelectorHi,                            (vector unsigned short)staggerSelectorLo);                              ////////////////////////////////////////////////////////////////////  // generate 0809 0a0b 0a0b 0c0d 0c0d 0e0f 0e0f 1011  ////////////////////////////////////////////////////////////////////  staggerSelectorLo = vec_splat_u8(8);                // 08080808080808080808080808080808  staggerSelectorLo = vec_add(staggerSelectorHi, staggerSelectorLo);   // 08090a0b0a0b0c0d0c0d0e0f0e0f1011    #else  switchByteSelectorLo = (vector unsigned char)((vector unsigned long)(0x001f001d, 0x001f001d, 0x001f001d, 0x001f001d));  switchByteSelectorHi = (vector unsigned char)((vector unsigned long)(0x001e001c, 0x001e001c, 0x001e001c, 0x001e001c));  staggeredSumPermuterEven = (vector unsigned char)((vector unsigned long)(0x04050607, 0x0c0d0e0f, 0x14151617, 0x1c1d1e1f));  staggeredSumPermuterOdd = (vector unsigned char)((vector unsigned long)  (0x00010203, 0x08090a0b, 0x10111213, 0x18191a1b));  staggerSelectorHi = (vector unsigned char)((vector unsigned long)(0x00010203, 0x02030405, 0x04050607, 0x06070809));  staggerSelectorLo = (vector unsigned char)((vector unsigned long)(0x08090a0b, 0x0a0b0c0d, 0x0c0d0e0f, 0x0e0f1011));#endif    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  /////////////////////////////// Section 3 (of 0-3) of 256-bit multiply parallelogram. ////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  {    vector unsigned short candVectorHorizontalHi;  // v1 of description      vector unsigned short candVectorHorizontalLo;  // v2 of description    vector unsigned short candVectorLoBytes;    // u1 of description    vector unsigned short candVectorHiBytes;    // u2 of description          vector unsigned short selectAHi;        // vector that we permute out of to generate v1, v2    vector unsigned short selectALo;        // vector that we permute out of to generate v1, v2    vector unsigned short selectBHi;        // vector that we permute out of to generate u1, u2    vector unsigned short selectBLo;        // vector that we permute out of to generate u1, u2    ////////////////////////////////////////////////////////////////////    // We set up two sets of two vectors for our multiplicands that we     // will use our previously generated permute vectors to select out    // of.    ////////////////////////////////////////////////////////////////////    selectAHi = (vector unsigned short)*pA1;               // IJKLMNOP    selectALo = (vector unsigned short)zero;    selectBHi = (vector unsigned short)zero;                selectBLo = (vector unsigned short)*pB1;              // ijklmnop        ////////////////////////////////////////////////////////////////////    // clear vectors that are used for the sums of partial products    ////////////////////////////////////////////////////////////////////    currentSumHiOddBytes =   (vector unsigned long)(0);    currentSumHiEvenBytes =  (vector unsigned long)(0);    currentSumLoOddBytes =   (vector unsigned long)(0);    currentSumLoEvenBytes =  (vector unsigned long)(0);    ////////////////////////////////////////////////////////////////////    // we do the following loop two times, which calculates the top    // four rows in the rightmost section of the parallelogram:    //    //    p*I p*J p*K p*L p*M p*N p*O p*P    //    o*J o*K o*L o*M o*N o*O o*P    //    n*K n*L n*M n*N n*O n*P    //    m*L m*M m*N m*m m*P    //    // We don't do the last four in this loop because the last    // four rows don't need to have their lower half calculated    // (since they are zero), so we have an optimized loop for    // the lower half.    ////////////////////////////////////////////////////////////////////    for (innerloop = 0;innerloop&lt;2; innerloop++) {      candVectorHorizontalHi = vec_perm(selectAHi, selectALo, staggerSelectorHi);  // something like I J J K K L L M      candVectorHorizontalLo = vec_perm(selectAHi, selectALo, staggerSelectorLo);  // something like M N N O O P P -      candVectorLoBytes = vec_perm((vector unsigned short)zero,                  selectBLo, switchByteSelectorLo);  // something like 0 p(lo) 0 o(lo) 0 p(lo)...      candVectorHiBytes = vec_perm((vector unsigned short)zero,                  selectBLo, switchByteSelectorHi);   // something like 0 p(hi) 0 o(hi) 0 p(hi)...            ////////////////////////////////////////////////////////////////////      // do multiplication of high half of sum with odd and even bytes      // and add to previous iteration's result      ////////////////////////////////////////////////////////////////////      currentSumHiOddBytes = vec_msum(candVectorHorizontalHi, candVectorHiBytes, currentSumHiOddBytes);      currentSumHiEvenBytes = vec_msum(candVectorHorizontalHi, candVectorLoBytes, currentSumHiEvenBytes);            ////////////////////////////////////////////////////////////////////      // do multiplication of low half of sum with odd and even bytes      // and add to previous iteration's result      ////////////////////////////////////////////////////////////////////      currentSumLoOddBytes = vec_msum(candVectorHorizontalLo, candVectorHiBytes, currentSumLoOddBytes);      currentSumLoEvenBytes = vec_msum(candVectorHorizontalLo, candVectorLoBytes, currentSumLoEvenBytes);      ////////////////////////////////////////////////////////////////////      // shift the vector sets that our permute operation selects out of,      // so that the next permutes will generate the correct hi/lo byte      // and hi/lo end multiplicand vectors.      ////////////////////////////////////////////////////////////////////      selectAHi = vec_sld(selectAHi, selectALo, 4);      selectBLo = vec_sld(selectBHi, selectBLo, 12);      selectBHi = vec_sld((vector unsigned short)zero, selectBHi, 12);        };    ////////////////////////////////////////////////////////////////////    // we go through this loop twice, to calculate the bottom four    // rows of section 3:    //    //    l*M l*N l*O l*P    //    k*N k*O k*P    //    j*O j*P    //    i*P    //    ////////////////////////////////////////////////////////////////////    for (innerloop = 0;innerloop&lt;2; innerloop++) {      candVectorHorizontalHi = vec_perm(selectAHi, selectALo, staggerSelectorHi);  // something like M N N O O P P -      candVectorLoBytes = vec_perm((vector unsigned short)zero,                  selectBLo, switchByteSelectorLo);  // something like l(lo) k(lo) l(lo)...      candVectorHiBytes = vec_perm((vector unsigned short)zero,                  selectBLo, switchByteSelectorHi); // something like l(hi) k(hi) l(hi)...            ////////////////////////////////////////////////////////////////////      // do multiplication of high half of sum with odd and even bytes      // and add to previous iteration's result      ////////////////////////////////////////////////////////////////////      currentSumHiOddBytes = vec_msum(candVectorHorizontalHi, candVectorHiBytes, currentSumHiOddBytes);      currentSumHiEvenBytes = vec_msum(candVectorHorizontalHi, candVectorLoBytes, currentSumHiEvenBytes);            ////////////////////////////////////////////////////////////////////      // shift the vector sets that our permute operation selects out of,      // so that the next permutes will generate the correct hi/lo byte      // and hi/lo end multiplicand vectors.      ////////////////////////////////////////////////////////////////////      selectAHi = vec_sld(selectAHi, selectALo, 4);      selectBLo = vec_sld(selectBHi, selectBLo, 12);      selectBHi = vec_sld((vector unsigned short)zero, selectBHi, 12);        };  }  ////////////////////////////////////////////////////////////////////  // We now have result vectors r1, r2, r3, and r4.  Before we can sum  // these four results, we need to munge them into four non-overlapping  // vectors that can then be shifted and added in to the sum for this  // vector column of the total result.  Each of the result vectors  // Q R S T is selected by a permute and then added to the result.  ////////////////////////////////////////////////////////////////////    ////////////////////////////////////////////////////////////////////  // start with vector T, which needs no shifting, by selecting the  // even 32-bit elements from the even-byte sum results.  //  T = r2B r2D r4B r4D  ////////////////////////////////////////////////////////////////////              // ABCD|EFGH-&gt; BDFH  R3 = vec_perm(currentSumHiEvenBytes, currentSumLoEvenBytes, staggeredSumPermuterEven);   ////////////////////////////////////////////////////////////////////  // next, we add in Q, which needs to be shifted by 3.  Since the   // leftmost 3 bytes will overflow into the next vector, we shift  // them into a carry for the next vector.  ////////////////////////////////////////////////////////////////////    // ABCD|EFGH -&gt; ACEG  tempSum = vec_perm(currentSumHiOddBytes, currentSumLoOddBytes, staggeredSumPermuterOdd);  R2 = vec_sld(zero, tempSum, 3);    tempSum = vec_sld(tempSum, zero, 3);  C3 = vec_addc(R3, tempSum);  R3 = vec_add(R3, tempSum);    ////////////////////////////////////////////////////////////////////  // next we add in the R vector, which needs to be shifted 1 byte to  // the left. We need to take the resulting carry and add it to the  // accumulated carry. Since we're shifting it to the left, we need  // to add the overflowing part of the shift into the carry for the   // next result vector.  ////////////////////////////////////////////////////////////////////  // ABCD|EFGH-&gt; BDFH  tempSum = vec_perm(currentSumHiOddBytes, currentSumLoOddBytes, staggeredSumPermuterEven);  carryTemp = vec_sld(zero, tempSum, 1);  R2 = vec_add(R2, carryTemp);    tempSum = vec_sld(tempSum, zero, 1);  carryTemp = vec_addc(R3, tempSum);  R3 = vec_add(R3, tempSum);    C3 = vec_add(carryTemp, C3);  ////////////////////////////////////////////////////////////////////  // next we add in the S vector, which needs to be shifted 2 bytes  // to the left. We need to take the resulting carry and add it to  // the accumulated carry. Since we're shifting it to the left, we  // need to add the overflowing part of the shift into the carry for  // the next result vector.  ////////////////////////////////////////////////////////////////////  // ABCD|EFGH -&gt; ACEG  tempSum = vec_perm(currentSumHiEvenBytes, currentSumLoEvenBytes, staggeredSumPermuterOdd);  carryTemp = vec_sld(zero, tempSum, 2);  R2 = vec_add(R2, carryTemp);    tempSum = vec_sld(tempSum, zero, 2);  carryTemp = vec_addc(R3, tempSum);    R3 = vec_add(R3, tempSum);    C3 = vec_add(carryTemp, C3);  ////////////////////////////////////////////////////////////////////  // We have now completely calculated the lowest 128 bits of the   // 512-bit result, in R3, as well as any carries that need to be  // resolved (in C3), and any carry into the next section of the  // result (in R2).  ////////////////////////////////////////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  /////////////////////////////// Section 2 (of 0-3) of 256-bit multiply parallelogram. ////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  {    vector unsigned short candVectorHorizontalHi;  // v1 of description      vector unsigned short candVectorHorizontalLo;  // v2 of description    vector unsigned short candVectorLoBytes;    // u1 of description    vector unsigned short candVectorHiBytes;    // u2 of description          vector unsigned short selectAHi;        // vector that we permute out of to generate v1, v2    vector unsigned short selectALo;        // vector that we permute out of to generate v1, v2    vector unsigned short selectBHi;        // vector that we permute out of to generate u1, u2    vector unsigned short selectBLo;        // vector that we permute out of to generate u1, u2    ////////////////////////////////////////////////////////////////////    // We set up two sets of two vectors for our multiplicands that we     // will use our previously generated permute vectors to select out    // of.    ////////////////////////////////////////////////////////////////////    selectAHi = (vector unsigned short)*pA0;    selectALo = (vector unsigned short)*pA1;        selectBHi = (vector unsigned short)*pB0;    selectBLo = (vector unsigned short)*pB1;    ////////////////////////////////////////////////////////////////////    // clear vectors that are used for the sums of partial products    ////////////////////////////////////////////////////////////////////    currentSumHiOddBytes =   (vector unsigned long)(0);    currentSumHiEvenBytes =  (vector unsigned long)(0);    currentSumLoOddBytes =   (vector unsigned long)(0);    currentSumLoEvenBytes =  (vector unsigned long)(0);    ////////////////////////////////////////////////////////////////////    // we do the following loop six times, which calculates the top    // twelve rows in section 2 of the parallelogram:    //    //  p*A  p*B p*C p*D p*E p*F p*G p*H    //  o*B o*C o*D o*E o*F o*G o*H o*I    //  n*C n*D n*E n*F n*G n*H n*I n*J    //  m*D m*E m*F m*G m*H m*I m*J m*K    //  l*E l*F l*G l*H l*I l*J l*K l*L    //  k*F k*G k*H k*I k*J k*K k*L k*M    //  j*G j*H j*I j*J j*K j*L j*M j*N    //  i*H i*I i*J i*K i*L i*M i*N i*O    //  h*I h*J h*K h*L h*M h*N h*O h*P    //  g*J g*K g*L g*M g*N g*O g*P    //  f*K f*L f*M f*N f*O f*P    //  e*L e*M e*N e*O e*P    //    // We don't do the last four in this loop because the last    // four rows don't need to have their lower half calculated    // (since they are zero), so we have an optimized loop for    // the lower half.    ////////////////////////////////////////////////////////////////////    for (innerloop = 0;innerloop&lt;6; innerloop++) {      candVectorHorizontalHi = vec_perm(selectAHi, selectALo, staggerSelectorHi);    // something like A B B C C D D E      candVectorHorizontalLo = vec_perm(selectAHi, selectALo, staggerSelectorLo);    // something like E F F G G H H I      candVectorLoBytes = vec_perm((vector unsigned short)zero,                  selectBLo, switchByteSelectorLo);  // something like p(lo) o(lo) p(lo)...      candVectorHiBytes = vec_perm((vector unsigned short)zero,                  selectBLo, switchByteSelectorHi); // something like p(hi) o(hi) p(hi)...            ////////////////////////////////////////////////////////////////////      // do multiplication of high half of sum with odd and even bytes      // and add to previous iteration's result      ////////////////////////////////////////////////////////////////////      currentSumHiOddBytes = vec_msum(candVectorHorizontalHi, candVectorHiBytes, currentSumHiOddBytes);      currentSumHiEvenBytes = vec_msum(candVectorHorizontalHi, candVectorLoBytes, currentSumHiEvenBytes);            ////////////////////////////////////////////////////////////////////      // do multiplication of low half of sum with odd and even bytes      // and add to previous iteration's result      ////////////////////////////////////////////////////////////////////      currentSumLoOddBytes = vec_msum(candVectorHorizontalLo, candVectorHiBytes, currentSumLoOddBytes);      currentSumLoEvenBytes = vec_msum(candVectorHorizontalLo, candVectorLoBytes, currentSumLoEvenBytes);      ////////////////////////////////////////////////////////////////////      // shift the vector sets that our permute operation selects out of,      // so that the next permutes will generate the correct hi/lo byte      // and hi/lo end multiplicand vectors.      ////////////////////////////////////////////////////////////////////      selectAHi = vec_sld(selectAHi, selectALo, 4);      selectALo = vec_sld(selectALo, (vector unsigned short)zero, 4);      selectBLo = vec_sld(selectBHi, selectBLo, 12);      selectBHi = vec_sld((vector unsigned short)zero, selectBHi, 12);        }            ////////////////////////////////////////////////////////////////////    // we go through this loop twice, to calculate the bottom four    // rows of section 2:    //    //  d*M d*N d*O d*P    //  c*N c*O c*P    //  b*O b*P    //  a*P    //    ////////////////////////////////////////////////////////////////////    for (innerloop = 0;innerloop&lt;2; innerloop++) {      candVectorHorizontalHi = vec_perm(selectAHi, selectALo, staggerSelectorHi);    // something like A B B C C D D E      candVectorLoBytes = vec_perm((vector unsigned short)zero,                  selectBLo, switchByteSelectorLo);  // something like p(lo) o(lo) p(lo)...      candVectorHiBytes = vec_perm((vector unsigned short)zero,                  selectBLo, switchByteSelectorHi); // something like p(hi) o(hi) p(hi)...            ////////////////////////////////////////////////////////////////////      // do multiplication of high half of sum with odd and even bytes      // and add to previous iteration's result      ////////////////////////////////////////////////////////////////////      currentSumHiOddBytes = vec_msum(candVectorHorizontalHi, candVectorHiBytes, currentSumHiOddBytes);      currentSumHiEvenBytes = vec_msum(candVectorHorizontalHi, candVectorLoBytes, currentSumHiEvenBytes);            ////////////////////////////////////////////////////////////////////      // shift the vector sets that our permute operation selects out of,      // so that the next permutes will generate the correct hi/lo byte      // and hi/lo end multiplicand vectors.      ////////////////////////////////////////////////////////////////////      selectAHi = vec_sld(selectAHi, selectALo, 4);      selectBLo = vec_sld(selectBHi, selectBLo, 12);      selectBHi = vec_sld((vector unsigned short)zero, selectBHi, 12);        }      }  ////////////////////////////////////////////////////////////////////  // We now have result vectors r1, r2, r3, and r4.  Before we can sum  // these four results, we need to munge them into four non-overlapping  // vectors that can then be shifted and added in to the sum for this  // vector column of the total result.  Each of the result vectors  // Q R S T is selected by a permute and then added to the result.  ////////////////////////////////////////////////////////////////////    ////////////////////////////////////////////////////////////////////  // start with vector T, which needs no shifting, by selecting the  // even 32-bit elements from the even-byte sum results, and then  // adding the previous section's result to it.  //  T = r2B r2D r4B r4D  ////////////////////////////////////////////////////////////////////  // ABCD|EFGH-&gt; BDFH    tempSum = vec_perm(currentSumHiEvenBytes, currentSumLoEvenBytes, staggeredSumPermuterEven);  carryTemp = vec_addc(R2, tempSum);    C2 = vec_add(C2, carryTemp);    R2 = vec_add(R2, tempSum);  ////////////////////////////////////////////////////////////////////  // next, we add in Q, which needs to be shifted by 3.  Since the   // leftmost 3 bytes will overflow into the next vector, we shift  // them into a carry for the next vector.  ////////////////////////////////////////////////////////////////////    // ABCD|EFGH -&gt; ACEG  tempSum = vec_perm(currentSumHiOddBytes, currentSumLoOddBytes, staggeredSumPermuterOdd);  R1 = vec_sld(zero, tempSum, 3);    tempSum = vec_sld(tempSum, zero, 3);  carryTemp = vec_addc(R2, tempSum);    R2 = vec_add(R2, tempSum);  C2 = vec_add(C2, carryTemp);  ////////////////////////////////////////////////////////////////////  // next we add in the R vector, which needs to be shifted 1 byte to  // the left. We need to take the resulting carry and add it to the  // accumulated carry. Since we're shifting it to the left, we need  // to add the overflowing part of the shift into the carry for the   // next result vector.  ////////////////////////////////////////////////////////////////////  // ABCD|EFGH-&gt; BDFH  tempSum = vec_perm(currentSumHiOddBytes, currentSumLoOddBytes, staggeredSumPermuterEven);  carryTemp = vec_sld(zero, tempSum, 1);  R1 = vec_add(carryTemp, R1);    tempSum = vec_sld(tempSum, zero, 1);  carryTemp = vec_addc(R2, tempSum);  R2 = vec_add(R2, tempSum);      C2 = vec_add(C2, carryTemp);  ////////////////////////////////////////////////////////////////////  // next we add in the S vector, which needs to be shifted 2 bytes  // to the left. We need to take the resulting carry and add it to  // the accumulated carry. Since we're shifting it to the left, we  // need to add the overflowing part of the shift into the carry for  // the next result vector.  ////////////////////////////////////////////////////////////////////  // ABCD|EFGH -&gt; ACEG  tempSum = vec_perm(currentSumHiEvenBytes, currentSumLoEvenBytes, staggeredSumPermuterOdd);   carryTemp = vec_sld(zero, tempSum, 2);  R1 = vec_add(carryTemp, R1);    tempSum = vec_sld(tempSum, zero, 2);  carryTemp = vec_addc(R2, tempSum);  R2 = vec_add(R2, tempSum);      C2 = vec_add(C2, carryTemp);  ////////////////////////////////////////////////////////////////////  // We have now completely calculated the lowest 256 bits of the   // 512-bit result, as well as any carries that need to be  // resolved, and any carry into the next section of the  // result (in R1).  ////////////////////////////////////////////////////////////////////  ////////////////////////////////////////////////////////////////////  // For the upper half of the parallelogram, we need to set up  // different vectors to use as permute vectors for creating  // the multiplicands.  ////////////////////////////////////////////////////////////////////  ///////////////////////////////////////////////////////////////////////////////////////  // staggerSelectorHi is currently (0x00010203, 0x02030405, 0x04050607, 0x06070809)  // staggerSelectorLo is currently (0x08090a0b, 0x0a0b0c0d, 0x0c0d0e0f, 0x0e0f1011)  ///////////////////////////////////////////////////////////////////////////////////////  tempSum = (vector unsigned long)vec_splat_u8(0x0E);  // 0x0e0e0e0e 0x0e0e0e0e....    ////////////////////////////////////////////////////////////////////  // staggerSelectorLo = 0x0e0f1011 0x10111213 0x12131415 0x14151617  // staggerSelectorHi = 0x16171819 0x18191A1B 0x1A1B1C1D 0x1C1D1E1F  ////////////////////////////////////////////////////////////////////  staggerSelectorLo = vec_add((vector unsigned char)staggerSelectorLo, (vector unsigned char)tempSum);    staggerSelectorHi = vec_add((vector unsigned char)staggerSelectorHi, (vector unsigned char)tempSum);    ////////////////////////////////////////////////////////////////////  // switchByteSelectorHi = 0x0012 0010 0012 0010....  // switchByteSelectorLo = 0x0013 0011 0013 0011....  ////////////////////////////////////////////////////////////////////  tempSum = (vector unsigned long)vec_splat_u16(0x0c);                    switchByteSelectorHi = vec_sub(switchByteSelectorHi, (vector unsigned char)tempSum);    switchByteSelectorLo = vec_sub(switchByteSelectorLo, (vector unsigned char)tempSum);      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  /////////////////////////////// Section 1 (of 0-3) of 256-bit multiply parallelogram. ////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  {    vector unsigned short candVectorHorizontalHi;  // v1 of description      vector unsigned short candVectorHorizontalLo;  // v2 of description    vector unsigned short candVectorLoBytes;    // u1 of description    vector unsigned short candVectorHiBytes;    // u2 of description          vector unsigned short selectAHi;        // vector that we permute out of to generate v1, v2    vector unsigned short selectALo;        // vector that we permute out of to generate v1, v2    vector unsigned short selectBHi;        // vector that we permute out of to generate u1, u2    vector unsigned short selectBLo;        // vector that we permute out of to generate u1, u2    ////////////////////////////////////////////////////////////////////    // We set up two sets of two vectors for our multiplicands that we     // will use our previously generated permute vectors to select out    // of.    ////////////////////////////////////////////////////////////////////    selectAHi = (vector unsigned short)*pA0;    selectALo = (vector unsigned short)*pA1;    // shift right by 2 bytes    selectALo = vec_sld(selectAHi, selectALo, 14);    selectAHi = vec_sld((vector unsigned short)zero, selectAHi, 14);          selectBHi = (vector unsigned short)*pB0;    selectBLo = (vector unsigned short)*pB1;    ////////////////////////////////////////////////////////////////////    // clear vectors that are used for the sums of partial products    ////////////////////////////////////////////////////////////////////    currentSumHiOddBytes =   (vector unsigned long)(0);    currentSumHiEvenBytes =  (vector unsigned long)(0);    currentSumLoOddBytes =   (vector unsigned long)(0);    currentSumLoEvenBytes =  (vector unsigned long)(0);    ////////////////////////////////////////////////////////////////////    // we do the following loop six times, which calculates the bottom    // twelve rows in section 1 of the parallelogram:    //    //            l*A  l*B l*C l*D     //          k*A  k*B k*C k*D k*E     //        j*A  j*B j*C j*D j*E j*F     //      i*A  i*B i*C i*D i*E i*F i*G     //    h*A  h*B h*C h*D h*E h*F h*G h*I     //    g*B g*C g*D g*E g*F g*G g*H g*I     //    f*C f*D f*E f*F f*G f*H f*I f*J     //    e*D e*E e*F e*G e*H e*I e*J e*K     //    d*E d*F d*G d*H d*I d*J d*K d*L     //    c*F c*G c*H c*I c*J c*K c*L c*M     //    b*G b*H b*I b*J b*K b*L b*M b*N     //    a*H a*I a*J a*K a*L a*M a*N a*O     //    // We don't do the top three in this loop because they    // don't need to have their upper (left) half calculated    // (since they are zero), so we have an optimized loop for    // these other three.    ////////////////////////////////////////////////////////////////////    for (innerloop=0;innerloop&lt;6; innerloop++) {      candVectorHorizontalHi = vec_perm(selectAHi, selectALo, staggerSelectorHi);    // something like G H H I I J J K      candVectorHorizontalLo = vec_perm(selectAHi, selectALo, staggerSelectorLo);    // something like K L L M M N N O      candVectorLoBytes = vec_perm((vector unsigned short)zero, selectBHi, switchByteSelectorLo);      // something like p(lo) o(lo) p(lo) o(lo)      candVectorHiBytes = vec_perm((vector unsigned short)zero, selectBHi, switchByteSelectorHi);            ////////////////////////////////////////////////////////////////////      // do multiplication of high half of sum with odd and even bytes      // and add to previous iteration's result      ////////////////////////////////////////////////////////////////////      currentSumHiOddBytes = vec_msum(candVectorHorizontalHi, candVectorHiBytes, currentSumHiOddBytes);      currentSumHiEvenBytes = vec_msum(candVectorHorizontalHi, candVectorLoBytes, currentSumHiEvenBytes);            ////////////////////////////////////////////////////////////////////      // do multiplication of low half of sum with odd and even bytes      // and add to previous iteration's result      ////////////////////////////////////////////////////////////////////      currentSumLoOddBytes = vec_msum(candVectorHorizontalLo, candVectorHiBytes, currentSumLoOddBytes);      currentSumLoEvenBytes = vec_msum(candVectorHorizontalLo, candVectorLoBytes, currentSumLoEvenBytes);            ////////////////////////////////////////////////////////////////////      // shift the vector sets that our permute operation selects out of,      // so that the next permutes will generate the correct hi/lo byte      // and hi/lo end multiplicand vectors.      ////////////////////////////////////////////////////////////////////      // shift right by 4 bytes      selectALo = vec_sld(selectAHi, selectALo, 12);      selectAHi = vec_sld((vector unsigned short)zero, selectAHi, 12);                // shift left by 4 bytes      selectBHi = vec_sld(selectBHi, selectBLo, 4);      selectBLo = vec_sld(selectBLo, (vector unsigned short)zero, 4);    }    ////////////////////////////////////////////////////////////////////    // we go through this loop twice, to calculate the top three    // rows of section 1:    //    //        o*A      //      n*A  n*B     //    m*A  m*B m*C     //    ////////////////////////////////////////////////////////////////////        for (innerloop=0;innerloop&lt;2; innerloop++) {      candVectorHorizontalLo = vec_perm(selectAHi, selectALo, staggerSelectorLo);    // something like - - - A A B B C      candVectorLoBytes = vec_perm((vector unsigned short)zero, selectBHi, switchByteSelectorLo);      // something like p(lo) o(lo) p(lo) o(lo)      candVectorHiBytes = vec_perm((vector unsigned short)zero, selectBHi, switchByteSelectorHi);            ////////////////////////////////////////////////////////////////////      // do multiplication of low half of sum with odd and even bytes      // and add to previous iteration's result      ////////////////////////////////////////////////////////////////////      currentSumLoOddBytes = vec_msum(candVectorHorizontalLo, candVectorHiBytes, currentSumLoOddBytes);      currentSumLoEvenBytes = vec_msum(candVectorHorizontalLo, candVectorLoBytes, currentSumLoEvenBytes);            ////////////////////////////////////////////////////////////////////      // shift the vector sets that our permute operation selects out of,      // so that the next permutes will generate the correct hi/lo byte      // and hi/lo end multiplicand vectors.      ////////////////////////////////////////////////////////////////////      // shift right by 4 bytes      selectALo = vec_sld(selectAHi, selectALo, 12);                // shift left by 4 bytes      selectBHi = vec_sld(selectBHi, selectBLo, 4);      selectBLo = vec_sld(selectBLo, (vector unsigned short)zero, 4);    }      }    ////////////////////////////////////////////////////////////////////  // We now have result vectors r1, r2, r3, and r4.  Before we can sum  // these four results, we need to munge them into four non-overlapping  // vectors that can then be shifted and added in to the sum for this  // vector column of the total result.  Each of the result vectors  // Q R S T is selected by a permute and then added to the result.  ////////////////////////////////////////////////////////////////////    ////////////////////////////////////////////////////////////////////  // start with vector T, which needs no shifting, by selecting the  // even 32-bit elements from the even-byte sum results, and then  // adding the previous section's result to it.  //  T = r2B r2D r4B r4D  ////////////////////////////////////////////////////////////////////  // ABCD|EFGH-&gt; BDFH    tempSum = vec_perm(currentSumHiEvenBytes, currentSumLoEvenBytes, staggeredSumPermuterEven);  carryTemp = vec_addc(R1, tempSum);    C1 = vec_add(C1, carryTemp);    R1 = vec_add(R1, tempSum);  ////////////////////////////////////////////////////////////////////  // next, we add in Q, which needs to be shifted by 3.  Since the   // leftmost 3 bytes will overflow into the next vector, we shift  // them into a carry for the next vector.  ////////////////////////////////////////////////////////////////////    // ABCD|EFGH -&gt; ACEG  tempSum = vec_perm(currentSumHiOddBytes, currentSumLoOddBytes, staggeredSumPermuterOdd);  R0 = vec_sld(zero, tempSum, 3);    tempSum = vec_sld(tempSum, zero, 3);  carryTemp = vec_addc(R1, tempSum);    R1 = vec_add(R1, tempSum);  C1 = vec_add(C1, carryTemp);  ////////////////////////////////////////////////////////////////////  // next we add in the R vector, which needs to be shifted 1 byte to  // the left. We need to take the resulting carry and add it to the  // accumulated carry. Since we're shifting it to the left, we need  // to add the overflowing part of the shift into the carry for the   // next result vector.  ////////////////////////////////////////////////////////////////////  // ABCD|EFGH-&gt; BDFH  tempSum = vec_perm(currentSumHiOddBytes, currentSumLoOddBytes, staggeredSumPermuterEven);  carryTemp = vec_sld(zero, tempSum, 1);  R0 = vec_add(carryTemp, R0);    tempSum = vec_sld(tempSum, zero, 1);  carryTemp = vec_addc(R1, tempSum);  R1 = vec_add(R1, tempSum);      C1 = vec_add(C1, carryTemp);  ////////////////////////////////////////////////////////////////////  // next we add in the S vector, which needs to be shifted 2 bytes  // to the left. We need to take the resulting carry and add it to  // the accumulated carry. Since we're shifting it to the left, we  // need to add the overflowing part of the shift into the carry for  // the next result vector.  ////////////////////////////////////////////////////////////////////  // ABCD|EFGH -&gt; ACEG  tempSum = vec_perm(currentSumHiEvenBytes, currentSumLoEvenBytes, staggeredSumPermuterOdd);   carryTemp = vec_sld(zero, tempSum, 2);  R0 = vec_add(carryTemp, R0);    tempSum = vec_sld(tempSum, zero, 2);  carryTemp = vec_addc(R1, tempSum);  R1 = vec_add(R1, tempSum);      C1 = vec_add(C1, carryTemp);  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  /////////////////////////////// Section 0 (of 0-3) of 256-bit multiply parallelogram. ////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  {    vector unsigned short candVectorHorizontalHi;  // v1 of description      vector unsigned short candVectorHorizontalLo;  // v2 of description    vector unsigned short candVectorLoBytes;    // u1 of description    vector unsigned short candVectorHiBytes;    // u2 of description          vector unsigned short selectAHi;        // vector that we permute out of to generate v1, v2    vector unsigned short selectALo;        // vector that we permute out of to generate v1, v2    vector unsigned short selectBHi;        // vector that we permute out of to generate u1, u2    vector unsigned short selectBLo;        // vector that we permute out of to generate u1, u2    ////////////////////////////////////////////////////////////////////    // We set up two sets of two vectors for our multiplicands that we     // will use our previously generated permute vectors to select out    // of.    ////////////////////////////////////////////////////////////////////    selectAHi = (vector unsigned short)zero;    selectALo = (vector unsigned short)*pA0;        selectALo = vec_sld((vector unsigned short)zero, selectALo, 14);    selectBHi = (vector unsigned short)*pB0;    selectBLo = (vector unsigned short)*pB1;    ////////////////////////////////////////////////////////////////////    // clear vectors that are used for the sums of partial products    ////////////////////////////////////////////////////////////////////    currentSumHiOddBytes =   (vector unsigned long)(0);    currentSumHiEvenBytes =  (vector unsigned long)(0);    currentSumLoOddBytes =   (vector unsigned long)(0);    currentSumLoEvenBytes =  (vector unsigned long)(0);    ////////////////////////////////////////////////////////////////////    // we do the following loop two times, which calculates the bottom    // four rows in section 0 of the parallelogram:    //    //          d*A  d*B d*C d*D    //        c*A  c*B c*C c*D c*E    //      b*A  b*B b*C b*D b*E b*F    //    a*A  a*B a*C a*D a*E a*F a*G    //    // We don't do the top three in this loop because they    // don't need to have their upper (left) half calculated    // (since they are zero), so we have an optimized loop for    // these other three.    ////////////////////////////////////////////////////////////////////    for (innerloop=0;innerloop&lt;2; innerloop++) {      candVectorHorizontalHi = vec_perm(selectAHi, selectALo, staggerSelectorHi);    // something like - - - A A B B C      candVectorHorizontalLo = vec_perm(selectAHi, selectALo, staggerSelectorLo);    // something like C D D E E F F G       candVectorLoBytes = vec_perm((vector unsigned short)zero, selectBHi, switchByteSelectorLo);      // something like p(lo) o(lo) p(lo) o(lo)      candVectorHiBytes = vec_perm((vector unsigned short)zero, selectBHi, switchByteSelectorHi);            ////////////////////////////////////////////////////////////////////      // do multiplication of high half of sum with odd and even bytes      // and add to previous iteration's result      ////////////////////////////////////////////////////////////////////      currentSumHiOddBytes = vec_msum(candVectorHorizontalHi, candVectorHiBytes, currentSumHiOddBytes);      currentSumHiEvenBytes = vec_msum(candVectorHorizontalHi, candVectorLoBytes, currentSumHiEvenBytes);            ////////////////////////////////////////////////////////////////////      // do multiplication of low half of sum with odd and even bytes      // and add to previous iteration's result      ////////////////////////////////////////////////////////////////////      currentSumLoOddBytes = vec_msum(candVectorHorizontalLo, candVectorHiBytes, currentSumLoOddBytes);      currentSumLoEvenBytes = vec_msum(candVectorHorizontalLo, candVectorLoBytes, currentSumLoEvenBytes);            ////////////////////////////////////////////////////////////////////      // shift the vector sets that our permute operation selects out of,      // so that the next permutes will generate the correct hi/lo byte      // and hi/lo end multiplicand vectors.      ////////////////////////////////////////////////////////////////////      // shift right by 4 bytes      selectALo = vec_sld(selectAHi, selectALo, 12);      selectAHi = vec_sld((vector unsigned short)zero, selectAHi, 12);                // shift left by 4 bytes      selectBHi = vec_sld(selectBHi, selectBLo, 4);      selectBLo = vec_sld(selectBLo, (vector unsigned short)zero, 4);    };        ////////////////////////////////////////////////////////////////////    // we go through this loop twice, to calculate the top three    // rows of section 0:    //    //        g*A    //      f*A  f*B    //    e*A  e*B e*C    //    ////////////////////////////////////////////////////////////////////    for (innerloop=0;innerloop&lt;2; innerloop++) {      candVectorHorizontalLo = vec_perm(selectAHi, selectALo, staggerSelectorLo);    // something like - - - A A B B C      candVectorLoBytes = vec_perm((vector unsigned short)zero, selectBHi, switchByteSelectorLo);      // something like p(lo) o(lo) p(lo) o(lo)      candVectorHiBytes = vec_perm((vector unsigned short)zero, selectBHi, switchByteSelectorHi);            ////////////////////////////////////////////////////////////////////      // do multiplication of low half of sum with odd and even bytes      // and add to previous iteration's result      ////////////////////////////////////////////////////////////////////      currentSumLoOddBytes = vec_msum(candVectorHorizontalLo, candVectorHiBytes, currentSumLoOddBytes);      currentSumLoEvenBytes = vec_msum(candVectorHorizontalLo, candVectorLoBytes, currentSumLoEvenBytes);            ////////////////////////////////////////////////////////////////////      // shift the vector sets that our permute operation selects out of,      // so that the next permutes will generate the correct hi/lo byte      // and hi/lo end multiplicand vectors.      ////////////////////////////////////////////////////////////////////      // shift right by 4 bytes      selectALo = vec_sld(selectAHi, selectALo, 12);      selectAHi = vec_sld((vector unsigned short)zero, selectAHi, 12);                // shift left by 4 bytes      selectBHi = vec_sld(selectBHi, selectBLo, 4);      selectBLo = vec_sld(selectBLo, (vector unsigned short)zero, 4);    };      }  ////////////////////////////////////////////////////////////////////  // We now have result vectors r1, r2, r3, and r4.  Before we can sum  // these four results, we need to munge them into four non-overlapping  // vectors that can then be shifted and added in to the sum for this  // vector column of the total result.  Each of the result vectors  // Q R S T is selected by a permute and then added to the result.  ////////////////////////////////////////////////////////////////////    ////////////////////////////////////////////////////////////////////  // start with vector T, which needs no shifting, by selecting the  // even 32-bit elements from the even-byte sum results, and then  // adding the previous section's result to it.  //  T = r2B r2D r4B r4D  ////////////////////////////////////////////////////////////////////  // ABCD|EFGH-&gt; BDFH    tempSum = vec_perm(currentSumHiEvenBytes, currentSumLoEvenBytes, staggeredSumPermuterEven);  carryTemp = vec_addc(R0, tempSum);    C0 = vec_add(C0, carryTemp);    R0 = vec_add(R0, tempSum);  ////////////////////////////////////////////////////////////////////  // next, we add in Q, which needs to be shifted by 3.  Since the   // leftmost 3 bytes will overflow into the next vector, we shift  // them into a carry for the next vector.  ////////////////////////////////////////////////////////////////////    // ABCD|EFGH -&gt; ACEG  tempSum = vec_perm(currentSumHiOddBytes, currentSumLoOddBytes, staggeredSumPermuterOdd);  tempSum = vec_sld(tempSum, zero, 3);  carryTemp = vec_addc(R0, tempSum);    R0 = vec_add(R0, tempSum);  C0 = vec_add(C0, carryTemp);  ////////////////////////////////////////////////////////////////////  // next we add in the R vector, which needs to be shifted 1 byte to  // the left. We need to take the resulting carry and add it to the  // accumulated carry. Since we're shifting it to the left, we need  // to add the overflowing part of the shift into the carry for the   // next result vector.  ////////////////////////////////////////////////////////////////////  // ABCD|EFGH-&gt; BDFH  tempSum = vec_perm(currentSumHiOddBytes, currentSumLoOddBytes, staggeredSumPermuterEven);    tempSum = vec_sld(tempSum, zero, 1);  carryTemp = vec_addc(R0, tempSum);  R0 = vec_add(R0, tempSum);      C0 = vec_add(C0, carryTemp);  ////////////////////////////////////////////////////////////////////  // next we add in the S vector, which needs to be shifted 2 bytes  // to the left. We need to take the resulting carry and add it to  // the accumulated carry. Since we're shifting it to the left, we  // need to add the overflowing part of the shift into the carry for  // the next result vector.  ////////////////////////////////////////////////////////////////////  // ABCD|EFGH -&gt; ACEG  tempSum = vec_perm(currentSumHiEvenBytes, currentSumLoEvenBytes, staggeredSumPermuterOdd);     tempSum = vec_sld(tempSum, zero, 2);  carryTemp = vec_addc(R0, tempSum);  R0 = vec_add(R0, tempSum);      C0 = vec_add(C0, carryTemp);  ////////////////////////////////////////////////////////////////////  // Finally, we take all of the carries, shift them left by one  // column, and add them in (keeping track of any resulting carries  // in the process). We continue until there are no more carries  // to add in.  ////////////////////////////////////////////////////////////////////  do {    // shift all carries left by 32 bits    C0 = vec_sld(C0, C1, 4);    C1 = vec_sld(C1, C2, 4);    C2 = vec_sld(C2, C3, 4);    C3 = vec_sld(C3, zero, 4);        // add carry 0 to result 0    carryTemp = vec_addc(C0, R0);    R0 = vec_add(C0, R0);    C0 = carryTemp;    // add carry 1 to result 1    carryTemp = vec_addc(C1, R1);    R1 = vec_add(C1, R1);    C1 = carryTemp;    // add carry 2 to result 2    carryTemp = vec_addc(C2, R2);    R2 = vec_add(C2, R2);    C2 = carryTemp;    // add carry 3 to result 3    carryTemp = vec_addc(C3, R3);    R3 = vec_add(C3, R3);    C3 = carryTemp;  } while (!vec_all_eq(zero, vec_or(vec_or(C0, C1), vec_or(C2, C3))));  // return results  *results++ =  R3;  *results++ =   R2;  *results++ =   R1;  *results =     R0;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/VelEng_Multiprecision/listing5.html%3Fid%3DDTS10000459-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/VelEng_Multiprecision/listing5.html%3Fid%3DDTS10000459-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/VelEng_Multiprecision/listing5.html%3Fid%3DDTS10000459-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>