<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Recipes--Lists and Iteration (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING129></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-128.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-130.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-127.html"><B>Chapter 25 - Working With Lists and Iteration</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING129-0></A>
<H1><A NAME=MARKER-2-75></A>Recipes--Lists and Iteration</H1>
 The recipes and sample code in this section demonstrate how to define a sorted list class with a <CODE>Compare</CODE> method, create a list based on the class, add items to a list, and iterate through the items in a list.<P>
<A NAME=HEADING129-2></A>
<H2><A NAME=MARKER-2-76></A><A NAME=MARKER-9-77></A>Recipe--Defining and Working With a Sorted List Class</H2>
 The Calc sample application implements a spreadsheet view with rows and columns of cells. It uses the <CODE>TRowList</CODE> class for operations such as copying a selection, writing row data to disk, and writing row data to the desk scrap.<P>
 To define and work with a sorted list class, you perform these steps:<P>
<OL>
<LI>Define a class based on one of MacApp's sorted list classes.
<LI>Define a <CODE>Compare</CODE> method to order the items in your list.
<LI>Create a list object in your application.
<LI>Add items to the list.
<LI>Optionally add accessor methods.<P>
</OL>
 This recipe uses the <CODE>TRowList</CODE> class from the Calc application as an example of working with a sorted list class.<P>
<A NAME=HEADING129-11></A>
<H3>Define a Class Based on One of MacApp's Sorted List Classes</H3>
 When you define a subclass of a sorted list class, you normally provide at least the following methods:<P>
<DL>
<DT>constructor<B></B>
<DD> The constructor method has the same name as the class. It sets any fields you have added to the class to default or safe values. It should not perform any operation that might fail, such as allocating storage.
<DT>
<DD> The TRowList class adds no fields, so it has no constructor method.
<DT>destructor<B></B>
<DD> The destructor method has the same name as the class, prepended with a ~ (tilde) character. It frees any storage allocated by the object and does any other cleanup that should be performed when the object is deleted.
<DT>
<DD> The TRowList class requires no special cleanup, so its destructor method is empty.
<DT>initialization<B></B>
<DD> By convention, the initialization method is named by replacing the <CODE>T</CODE> in the class name with an <CODE>I</CODE> (for example, <CODE>IRowList</CODE>). The initialization method performs any initialization for the class that can't be safely performed in the constructor method, such as allocating storage.
<DT>
<DD> The IRowList method just calls <CODE>ISortedList</CODE>, the initialization method of its parent class.
<DT>comparison<B></B>
<DD> MacApp's <CODE>TSortedList</CODE> class calls the <CODE>Compare</CODE> method when it needs to insert an item into the list in order. You must supply a <CODE>Compare</CODE> method that can order the items stored in your sorted list class.
<DT>
<DD> The <CODE>Compare</CODE> method of the TRowList class is shown in the next section. It compares two <CODE>TRow</CODE> objects based on their row numbers.
</DL>
 The following is the class definition for the TRowList class:<P>
<PRE>
class TRowList : public TSortedList
{
   MA_DECLARE_CLASS;

public:

   // Destructor.
   virtual ~TRowList();
   
   // Initialize the list procedurally.
   virtual void IRowList();

   // Compare two rows based on row number.
   virtual CompareResult Compare(TObject* item1,
                           TObject* item2); // Override.
   // Return the row that matches the passed row number.
   virtual TRow* GetRow(RowNumber r);
};
</PRE>
<A NAME=HEADING129-23></A>
<H3>Define a Compare Method to Order the Items in Your List</H3>
 The Compare method specifies an ordering between items in your sorted list. Passed two list items, it determines whether item 1 is greater than item 2, less than item 2, or equal to item 2. MacApp supplies constant definitions for these conditions: <CODE>kItem1GreaterThanItem2</CODE>, <CODE>kItem1LessThanItem2</CODE>, and <CODE>kItem1EqualItem2</CODE>.<P>
 The Compare method for TRowList compares <CODE>TRow</CODE> items based on row number:<P>
<PRE>
CompareResult TRowList::Compare(TObject* item1,
                        TObject* item2) // Override.
{
   // The calling code makes sure never to insert anything but a
   // row into the list, so typecasting should always be safe.
   if (((TRow *)(item1))-&gt;fNumber &gt; ((TRow *)(item2))-&gt;fNumber)
      return kItem1GreaterThanItem2;
   else if (((TRow *)(item1))-&gt;fNumber &lt; ((TRow *)(item2))-&gt;fNumber)
      return kItem1LessThanItem2;
   else
      return kItem1EqualItem2;
}
</PRE>
<A NAME=HEADING129-27></A>
<H3>Create a List Object in Your Application</H3>
 You can create an instance of your list class using the <CODE>new</CODE> operator. In the Calc application, the <CODE>TCalcDocument</CODE> class keeps a reference to a TRowList object in its fRows field. The following code from the <CODE>ICalcDocument</CODE> method creates and initializes a TRowList object and assigns it to the fRows field.<P>
<PRE>
TRowList * aRowList;

aRowList = new TRowList;
aRowList-&gt;IRowList();
fRows = aRowList;
</PRE>
 The <CODE>new</CODE> operator causes a failure if the object can't be created, so this code doesn't have to check the returned TRowList object.<P>
<A NAME=HEADING129-31></A>
<H3>Add Items to the List</H3>
 MacApp's list classes provide a number of methods for adding items to a list. Some of these methods, including the <CODE>Insert</CODE> method, are described in <A HREF=MacAppProgGuide-128.html#MARKER-9-26>"Adding an Object to a List," beginning on page 574</A>. For a sorted list, calling the <CODE>Insert</CODE> method inserts an item in sorted order, based on the ordering supplied by the <CODE>Compare</CODE> method.<P>
 In the Calc application, the <CODE>TCalcDocument::AddRow</CODE> method adds a row item to the <CODE>fRows</CODE> field by calling the <CODE>Insert</CODE> method:<P>
<PRE>
fRows-&gt;Insert(theRow);
</PRE>
 As a result, rows in the list are stored in row order--not a surprising choice.<A NAME=MARKER-2-78></A><P>
<A NAME=HEADING129-36></A>
<H2><A NAME=MARKER-2-79></A>Recipe--Iterating Over the Items in a List</H2>
 The general mechanism for iteration is described in <A HREF=MacAppProgGuide-128.html#MARKER-9-57>"Iteration," beginning on page 576</A>. To iterate through a list of items, you perform these steps:<P>
<OL>
<LI>Choose an iterator for the list.
<LI>Initialize the iterator.
<LI>Use the iterator in a <CODE>for</CODE> loop to access the items in the list.
<LI>Optionally add accessor methods.<P>
</OL>
 The sample code shown in this recipe is from MacApp's <CODE>TView</CODE> class.<P>
<A NAME=HEADING129-43></A>
<H3>Choose an Iterator for the List</H3>
 MacApp provides many specialized iterator classes. Included among them are iterators for processing lists of documents, views, windows, and generic objects. This recipe uses the <CODE>CSubViewIterator</CODE> class. If your list requires processing that is not provided by one of MacApp's iterator classes, you can define your own iterator subclass.<P>
<A NAME=HEADING129-45></A>
<H3>Initialize the Iterator</H3>
 Iterators are commonly created as stack-based variables that are used within a method or routine. To initialize such a variable, you merely declare the variable and pass the required arguments to the constructor. Remember that many iterator classes have multiple constructor methods to choose from. For example, the CDocumentIterator class declares the following three constructors:<P>
<PRE>
CDocumentIterator(TApplication* itsApplication,
               ArrayIndex itsLowBound, ArrayIndex itsHighBound,
               Boolean itsForward);
CDocumentIterator(TApplication* itsApplication, Boolean itsForward);
CDocumentIterator(TApplication* itsApplication);
</PRE>
 As a result, the following three declarations are all valid initializations for a CDocumentIterator object. The first two declarations reference the global application object and could be placed in any routine. The third declaration must appear in an application method. The declarations use constants provided by MacApp to specify the direction of iteration (kIterateForward and kIterateBackward). <P>
<PRE>
CDocumentIterator iter(gApplication, 1, 100, kIterateForward);

CDocumentIterator iter(gApplication, kIterateBackward);
CDocumentIterator iter(this); // From within an application method.
</PRE>
<DL>
<DT><B>Note</B>
<DD>You normally initialize a document iterator by passing a reference to the application object as the single parameter. The two constructors with longer parameter lists are rarely used.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING129-52></A>
<H3>Use the Iterator in a For Loop to Access the Items in the List</H3>
 To iterate through the items in a list, you initialize an iterator for the list and set up a <CODE>for</CODE> loop to examine the items in the list. The example shown here, from MacApp's <CODE>TView</CODE> class, iterates through all of the subviews of a view, opening each subview:<P>
<PRE>
void TView::Open()
{
   CSubViewIterator iter(this);
   for (TView * theSubView = iter.FirstSubView();
         iter.More(); theSubView = iter.NextSubView())
      theSubView-&gt;Open();
}
</PRE>
 This <CODE>for</CODE> loop starts with the first subview, continues as long as <CODE>More</CODE> returns <CODE>TRUE</CODE>, and on each pass through the loop calls <CODE>NextSubView</CODE> to get the next subview. It calls <CODE>Open</CODE> for each subview that is returned.<A NAME=MARKER-9-32></A><A NAME=MARKER-2-81></A><P>
<A NAME=HEADING129-56></A>
<H3>Optionally Add Accessor Methods</H3>
 The <CODE>TSortedList</CODE> methods <CODE>At</CODE>, <CODE>First</CODE>, and <CODE>Last</CODE> all return a pointer to a <CODE>TObject</CODE> instance. As a result, you may frequently use code like the following:<P>
<PRE>
theRow = (TRow *) theRowList-&gt;At(rowNumber);
</PRE>
 To avoid using type coercion in every piece of code that calls one of these methods, and to apply additional testing, you can add accessor methods to take the place of <CODE>At</CODE>, <CODE>First</CODE>, and <CODE>Last</CODE>. For example, you could include the following lines in the definition of the <CODE>TRowList</CODE> class:<P>
<PRE>
virtual TRow* RowAt(ArrayIndex index);
virtual TRow* RowFirst();
virtual TRow* RowLast();
</PRE>
 Each of these methods calls the similarly named method of <CODE>TSortedList</CODE>, uses MA_DYNAMIC_CAST to make sure the returned item is indeed a TRow object, and provides error handling if it isn't. For example, the RowAt method could be implemented as follows:<P>
<PRE>
TRow* RowAt(ArrayIndex index)
{
   TObject* theObject = this-&gt;At(index);
   TRow* theRow = MA_DYNAMIC_CAST(TRow, theObject);
   if (theRow != NULL)
   {
      return theRow
   }
   else
   {
      // Code to handle error condition.
   }
}
</PRE>
 You can now provide safe, built-in type coercion, using a line like the following:<P>
<PRE>
theRow = theRowList-&gt;RowAt(rowNumber);
</PRE>
 All type coercion is centralized in the three new methods rather than spread throughout your code. If, during the development process, the type ever changes, you can simply change three methods--there is no need to perform a global search and replace operation on your entire code base.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-128.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-130.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
