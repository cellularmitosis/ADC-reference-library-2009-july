<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>vImage Programming Guide: Performing Convolution Operations</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Performing Convolution Operations"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001001-CH205" title="Performing Convolution Operations"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000430" target="_top">Performance</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000430-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP30001001-CH201-TPXREF101">vImage Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../OverviewofvImage/OverviewofvImage.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../GeometricOperations/GeometricOperations.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001001-CH205-SW1" title="Performing Convolution Operations"></a><h1>Performing Convolution Operations</h1><p><strong>Convolution</strong> is a common image processing technique that changes the intensities of a pixel to reflect the intensities of the surrounding pixels. A common use of convolution is to create image filters. Using convolution, you can get popular image effects like blur, sharpen, and edge detection—effects used by applications such as Photo Booth, iPhoto, and Aperture.</p><p>If you are interested in efficiently applying image filters to large or real-time image data, you will find the vImage functions useful. In terms of image filtering, vImage’s convolution operations can perform common image filter effects such as embossing, blurring, and, posterizing.</p><p>vImage convolution operations can also be useful for sharpening or otherwise enhancing certain qualities of images. Enhancing images can be particularly useful when dealing with scientific images. Furthermore, since scientific images are often large, using these vImage operations can become necessary to achieve suitable application performance. The kinds of operations that you’d tend to use this on are edge detection, sharpening, surface contour outlining, smoothing, and motion detection.</p><p>This chapter describes convolution and shows how to use the convolution functions provided by vImage. By reading this chapter, you’ll:</p><ul class="ul"><li class="li"><p>See the sorts of effects you can get with convolution</p></li><li class="li"><p>Learn what a kernel is and how to construct one</p></li><li class="li"><p>Get an introduction to commonly used kernels and high-speed variations</p></li><li class="li"><p>Find out, through code examples, how to apply vImage convolutions functions to an image</p></li></ul>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ConvolutionOperations.html#//apple_ref/doc/uid/TP30001001-CH205-SW10">Convolution Kernels</a>
				
			<br/>
			
        
			
			
				<a href="ConvolutionOperations.html#//apple_ref/doc/uid/TP30001001-CH205-SW12">Deconvolution</a>
				
			<br/>
			
        
			
			
				<a href="ConvolutionOperations.html#//apple_ref/doc/uid/TP30001001-CH205-SW13">Using Convolution Kernels</a>
				
			<br/>
			
        
			
			
				<a href="ConvolutionOperations.html#//apple_ref/doc/uid/TP30001001-CH205-SW21">Deconvolving</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001001-CH205-SW10" title="Convolution Kernels"></a><h2>Convolution Kernels</h2><p><span class="content_text">Figure 2-1</span> shows an image before and after processing with a vImage convolution function that causes the emboss effect. To achieve this effect, vImage performs convolution using a grid-like mathematical construct called a <strong>kernel</strong>. </p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH205-SW7" title="Figure 2-1Emboss using convolution"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>Emboss using convolution</p><img src = "../Art/emboss.jpg" alt = "" ></div><br/><p><span class="content_text">Figure 2-2</span> represents a 3 x 3 kernel. The height and width of the kernel do not have to be same, though they must both be odd numbers. The numbers inside the kernel are what impact the overall effect of convolution (in this case, the kernel encodes the emboss effect). The kernel (or more specifically, the values held within the kernel) is what determines how to transform the pixels from the original image into the pixels of the processed image. It may seem non-intuitive how the nine numbers in this kernel can yield an effect such as the previous emboss example. Convolution is a series of operations that alter pixel intensities depending on the intensities of neighboring pixels. vImage handles all the convolution operations based on the kernel that you supply. The kernel provides the actual numbers that are used in those operations (see <span class="content_text"><a href="ConvolutionOperations.html#//apple_ref/doc/uid/TP30001001-CH205-SW4">Figure 2-4</a></span> for the steps involved in convolution). Using kernels to perform convolutions is known as <strong>kernel convolution</strong>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH205-SW6" title="Figure 2-23 x 3 kernel"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>3 x 3 kernel</p><img src = "../Art/kernel.jpg" alt = "" ></div><br/><p>Convolutions are per-pixel operations—the same arithmetic is repeated for every pixel in the image. Bigger images therefore require more convolution arithmetic than the same operation on a smaller image. A kernel can be thought of as a two-dimensional grid of numbers that passes over each pixel of an image in sequence, performing calculations along the way. Since images can also be thought of as two-dimensional grids of numbers (or pixel intensities—see <span class="content_text">Figure 2-3</span>), applying a kernel to an image can be visualized as a small grid (the kernel) moving across a substantially larger grid (the image).</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH205-SW5" title="Figure 2-3An image is a grid of numbers"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>An image is a grid of numbers</p><img src = "../Art/pixels_grid.jpg" alt = "" ></div><br/><p>The numbers in the kernel represent the amount by which to multiply the number underneath it. The number underneath represents the intensity of the pixel over which the kernel element is hovering. During convolution, the center of the kernel passes over each pixel in the image. The process multiplies each number in the kernel by the pixel intensity value directly underneath it. This should result in as many products as there are numbers in the kernel (per pixel). The final step of the process sums all of the products together, divides them by the amount of numbers in the kernel, and this value becomes the new intensity of the pixel that was directly under the center of the kernel. <span class="content_text">Figure 2-4</span> shows how a kernel operates on one pixel.</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH205-SW4" title="Figure 2-4Kernel convolution"></a><p><strong>Figure 2-4&nbsp;&nbsp;</strong>Kernel convolution</p><img src = "../Art/kernel_convolution.jpg" alt = "" ></div><br/><p>Even though the kernel overlaps several different pixels (or in some cases, no pixels at all), the only pixel that it ultimately changes is the source pixel underneath the center element of the kernel. The sum of all the multiplications between the kernel and image is called the weighted sum. To ensure that the processed image is not noticeably more saturated than the original, vImage gives you the opportunity to specify a divisor by which to divide the weighted sum—a common practice in kernel convolution. Since replacing a pixel with the weighted sum of its neighboring pixels can frequently result in a much larger pixel intensity (and a brighter overall image), dividing the weighted sum can scale back the intensity of the effect and ensure that the initial brightness of the image is maintained. This procedure is called normalization. The optionally divided weighted sum is what becomes the value of the center pixel. The kernel repeats this procedure for each pixel in the source image. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001001-CH205-SW11" title="Note"></a><p><strong>Note:</strong>&nbsp;To perform normalization, you must pass a divisor to the convolution function that you are using. Divisors that are an exact power of two may perform better in some cases. You can supply a divisor only when the image’s pixel type is <code>int</code>. floating-point convolutions do not make use of divisors. You can directly scale the floating-point values in the kernel to achieve the same normalization.</p></div><p>The data type used to represent the values in the kernel must match the data used to represent the pixel values in the image. For example, if the pixel type is <code>float</code>, then the values in the kernel must also be <code>float</code> values.</p><p></p><p>Keep in mind that vImage does all of this arithmetic for you, so it is not necessary to memorize the steps involved in convolution to be able to use the framework. It is a good idea to have an idea of what is going on so that you can tweak and experiment with your own kernels.</p><a name="//apple_ref/doc/uid/TP30001001-CH205-SW12" title="Deconvolution"></a><h2>Deconvolution</h2><p>Deconvolution is an operation that approximately undoes a previous convolution—typically a convolution that is physical in origin, such as diffraction effects in a lens. Usually, deconvolution is a sharpening operation.</p><p>There are many deconvolution algorithms; the one vImage uses is called the Richardson-Lucy deconvolution.</p><p>The goal of Richardson-Lucy deconvolution is to find the original value of a pixel given the post-convolution pixel intensity and the number by which it was multiplied (the kernel value).</p><p>Due to these requirements, to use vImage’s deconvolution functions you must provide the convolved image and the kernel used to perform the original convolution. Represented as <code>k</code> in the following equation, the kernel serves as a way of letting vImage know what type of convolution it should undo. For example, sharpening an image (a common use of deconvolution) can be thought of as doing the opposite of a blur convolution. If the kernel you supply is not symmetrical, you must pass a second kernel to the function that is the same as the first with the axes interchanged.</p><p>Richardson-Lucy deconvolution is an iterative operation; your application specifies the number of iterations desired. The more iterations you make, the greater the sharpening effect (and the time consumed). As with any sharpening operation, Richardson-Lucy amplifies noise, and at some number of iterations the noise becomes noticeable as artifacts. <span class="content_text">Figure 2-5</span> shows the Richardson-Lucy algorithm expressed mathematically.</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH205-SW23" title="Figure 2-5Richardson-Lucy deconvolution equation"></a><p><strong>Figure 2-5&nbsp;&nbsp;</strong>Richardson-Lucy deconvolution equation</p><img src = "../Art/revisedDeconvEq.jpg" alt = "" ></div><br/><p>In this equation:</p><ul class="ul"><li class="li"><p><em>I</em> is the starting image.</p></li><li class="li"><p><em>e<sub>i</sub></em> is the current result and <em>e<sub>i + 1</sub></em> is being calculated; <em>e<sub>0</sub></em> is 0.</p></li><li class="li"><p><em>k<sub>0</sub></em> represents the kernel.</p></li><li class="li"><p><em>k<sub>1</sub></em> is a second kernel to be used if <em>k[0]</em> is asymmetrical. If <em>k[0]</em> is symmetrical, <em>k[0]</em> is used as <em>k[1]</em>.</p></li><li class="li"><p>The * operator indicates convolution.</p></li><li class="li"><p>The . operator indicates multiplication of each element in one matrix by the corresponding element in the other matrix.</p></li></ul><p>As with convolution, vImage handles all the individual steps of deconvolution, thus it is not necessary to memorize the steps involved. When deconvolving, all you must provide is the original convolution kernel (plus an additional inverted convolution kernel if the original kernel is not symmetrical).</p><a name="//apple_ref/doc/uid/TP30001001-CH205-SW13" title="Using Convolution Kernels"></a><h2>Using Convolution Kernels</h2><p>Now that you better understand the structure of kernels and the process behind convolution, it’s time to actually use a few vImage convolution functions. This section shows you how to perform the emboss shown in <span class="content_text"><a href="ConvolutionOperations.html#//apple_ref/doc/uid/TP30001001-CH205-SW7">Figure 2-1</a></span>, and also explains the differences between convolving with and without bias.</p><a name="//apple_ref/doc/uid/TP30001001-CH205-SW2" title="Convolving"></a><h3>Convolving</h3><p>vImage takes care of the specific convolution operations for you. Your job is to provide the kernel, or in other words, describe the effect that convolution should produce. <span class="content_text">Listing 2-1</span> shows how to use convolution to produce an emboss effect. To illustrate this effect, convolving the leftmost image in <span class="content_text"><a href="ConvolutionOperations.html#//apple_ref/doc/uid/TP30001001-CH205-SW7">Figure 2-1</a></span> produces the embossed image on the right. You could use the same code to produce a different effect, such as sharpening, by specifying the appropriate kernel.</p><a name="//apple_ref/doc/uid/TP30001001-CH205-SW3" title="Listing 2-1Producing an emboss effect"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Producing an emboss effect</p><div class="codesample"><table><tr><td scope="row"><pre>int myEmboss(void *inData,<span></span></pre></td></tr><tr><td scope="row"><pre> unsigned int inRowBytes,<span></span></pre></td></tr><tr><td scope="row"><pre> void *outData,<span></span></pre></td></tr><tr><td scope="row"><pre> unsigned int outRowBytes,<span></span></pre></td></tr><tr><td scope="row"><pre> unsigned int height,<span></span></pre></td></tr><tr><td scope="row"><pre> unsigned int width,<span></span></pre></td></tr><tr><td scope="row"><pre> void *kernel,<span></span></pre></td></tr><tr><td scope="row"><pre> unsigned int kernel_height,<span></span></pre></td></tr><tr><td scope="row"><pre> unsigned int kernel_width,<span></span></pre></td></tr><tr><td scope="row"><pre> int divisor ,<span></span></pre></td></tr><tr><td scope="row"><pre> vImage_Flags flags )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    uint_8 kernel = {-2, -2, 0, -2, 6, 0, 0, 0, 0}; <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    vImage_Buffer src = { inData, height, width, inRowBytes }; <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    vImage_Buffer dest = { outData, height, width, outRowBytes }; <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    unsigned char bgColor[4] = { 0, 0, 0, 0 }; <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    vImage_Error err; <span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = vImageConvolve_ARGB8888(    &amp;src,     //const vImage_Buffer *src<span></span></pre></td></tr><tr><td scope="row"><pre>                                        &amp;dest,    //const vImage_Buffer *dest,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        0,    //unsigned int srcOffsetToROI_X,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        0,    //unsigned int srcOffsetToROI_Y,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        kernel,    //const signed int *kernel,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        kernel_height,     //unsigned int<span></span></pre></td></tr><tr><td scope="row"><pre>                                        kernel_width,    //unsigned int<span></span></pre></td></tr><tr><td scope="row"><pre>                                        divisor,    //int<span></span></pre></td></tr><tr><td scope="row"><pre>                                        bgColor,<span></span></pre></td></tr><tr><td scope="row"><pre>                                       flags | kvImageBackgroundColorFill<span></span></pre></td></tr><tr><td scope="row"><pre>                                       //vImage_Flags flags<span></span></pre></td></tr><tr><td scope="row"><pre>                                    );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Declares the emboss kernel as an <code>int</code> array. The data type of the kernel values should match the intended data type of the corresponding vImage function. Because the code sample calls <code>vImageConvolve_ARGB8888</code>, the kernel values should be unsigned, 8-bit integers (<code>uint_8</code>). vImage expects the kernel elements to be in the array in left-to-right, 1st row, 2nd row, 3rd row order (see <span class="content_text"><a href="ConvolutionOperations.html#//apple_ref/doc/uid/TP30001001-CH205-SW6">Figure 2-2</a></span> to see how this ordered).</p></li><li class="li"><p>Declares <code>vImage_Buffer</code> data structure for the source image information. Image data is store as an array of bytes (<code>inData</code>). The other members store the height, width, and bytes-per-row of the image. This data allows vImage to know how large the image data array is, and how to properly handle it.</p></li><li class="li"><p>Declares a <code>vImage_Buffer</code> data structure for the destination image information as done previously with the source image.</p></li><li class="li"><p>Declares a <code>Pixel8888</code>-formatted pixel to represent the background color for the destination image (black in this case).</p></li><li class="li"><p>Declares a <code>vImage_Err</code> data type to store the convolution function’s return value.</p></li></ol><p>After that, the code sends the declared values as parameters to the <code>vImageConvolve_ARGB8888</code> function where vImage handles the processing and stores the result in <code>dest</code>. The <code>vImageConvolve_ARGB8888</code> function is only one of several convolution functions available in vImage. vImage typically offers four variants of the same function—each for a different image format. The <code>ARGB8888</code> suffix lets you know this function is intended for interleaved (full-color) images, where each pixel is a grouping of four 8-byte integers representing the alpha (A), red (R), green (G), and blue (B) channels. For more details on the image formats vImage uses, refer to <span class="content_text"><a href="../OverviewofvImage/OverviewofvImage.html#//apple_ref/doc/uid/TP30001001-CH202-SW2">“Image Formats Available in vImage.”</a></span></p><p>In order for vImage to acknowledge the appropriate flags, the sample <code>myEmboss</code> function accepts a <code>vImage_Flags</code> parameter. This parameter represents a composite of one or more flags that the caller of <code>myEmboss</code> submitted. When the example then calls the vImage <code>vImageConvolve_ARGB8888</code> function, it passes those same flags, but this time combined with an additional specific flag constant, <code>kvImageBackgroundColorFill</code>. It does this by using the OR bitwise operator (<code>|</code>) to combine several flags into single composition of flags that can be represented with one variable. This is the standard way to signal flags to vImage. This code example requests that vImage use the provided background image color (along with whichever flags were initially passed to the function).</p><p>To become familiar with kernel effects, try using the values from the following two kernels in your own code. <span class="content_text">Figure 2-6</span> shows the kernel for producing a Gaussian blur, and <span class="content_text">Figure 2-7</span> shows a Prewitt filter, which is a kernel for edge detection.</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH205-SW14" title="Figure 2-6A kernel for Gaussian blur"></a><p><strong>Figure 2-6&nbsp;&nbsp;</strong>A kernel for Gaussian blur</p><img src = "../Art/kernel_gaus.jpg" alt = "" ></div><br/><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH205-SW15" title="Figure 2-7A kernel for edge detection"></a><p><strong>Figure 2-7&nbsp;&nbsp;</strong>A kernel for edge detection</p><img src = "../Art/kernel_edge.jpg" alt = "" ></div><br/><a name="//apple_ref/doc/uid/TP30001001-CH205-SW8" title="Convolving with Bias"></a><h3>Convolving with Bias</h3><p>vImage gives you the option to perform convolution with bias or without. Bias is the value that you can add to each element in a convolution result to add additional influence from neighboring pixels. Since with certain convolutions it is possible to get negative numbers (which are not representable in a 0–255 format), bias prevents the signal from drifting out of range. You can choose to add a bias of 127 or 128 to allow some negative numbers to be representable (with an implicit +127 or +128 in their value). The overall effect of a bias brightens or darkens the image.</p><p>For every standard convolution function in vImage (such as <code>vImageConvolve_PlanarF</code>), there is a corresponding version that uses bias, indicated by “<code>WithBias</code>” in the function name (<code>vImageConvolveWithBias_PlanarF</code>, for example). Using the biased functions is virtually identical to the non biased functions, with the exception of the additional <code>bias</code> parameter you must pass to the convolution functions that use bias. The data type for the <code>bias</code> parameter must match that of the pixel data in the image. See <em><a href="../../../Reference/vImage_convolution/index.html#//apple_ref/doc/uid/TP40005489" target="_top">vImage Convolution Reference</a></em> for details on using these functions.</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH205-SW16" title="Figure 2-8Bias versus No Bias"></a><p><strong>Figure 2-8&nbsp;&nbsp;</strong>Bias versus No Bias</p><img src = "../Art/kernel_biased.jpg" alt = "" ></div><br/><a name="//apple_ref/doc/uid/TP30001001-CH205-SW17" title="Using High-Speed Filters"></a><h3>Using High-Speed Filters</h3><p>vImage also offers functions for specific types of convolution that can be significantly faster than general convolution. Starting in Mac OS X v.10.4, you have the option to use the supplied box and tent filter functions for integer formats <code>Planar_8</code> and <code>ARGB8888</code>. These filters perform blur operations. The functions’ names are from their shape when graphed in a cartesian coordinate system. They are equivalent to convolving with certain simple kernels, but you do not need to supply any kernel. These functions can be orders of magnitude faster than performing an equivalent convolution using custom kernels.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001001-CH205-SW22" title="Note"></a><p><strong>Note:</strong>&nbsp;vImage does not provide floating-point versions of these functions because the constant cost algorithm relies on exact arithmetic to be robust. Rounding differences in the floating-point computation can leave artifacts in the image in low intensity areas near high intensity areas.</p></div><p>Box filters blur images by replacing each pixel in an image with the un-weighted average of its surrounding pixels. The operation is equivalent to applying a convolution kernel filled with all 1s. The box functions available in vImage are <code><code><a href="../../../Reference/vImage_convolution/Reference/reference.html#//apple_ref/c/func/vImageBoxConvolve_Planar8" target="_top">vImageBoxConvolve_Planar8</a></code></code> and <code><code><a href="../../../Reference/vImage_convolution/Reference/reference.html#//apple_ref/c/func/vImageBoxConvolve_ARGB8888" target="_top">vImageBoxConvolve_ARGB8888</a></code></code>. Each resulting pixel is the mean of surrounding pixels as defined by the kernel height and width. </p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH205-SW18" title="Figure 2-9Box filter"></a><p><strong>Figure 2-9&nbsp;&nbsp;</strong>Box filter</p><img src = "../Art/box_filter.jpg" alt = "" ></div><br/><p>You use tent filters to blur each pixel of an image with the weighted average of its surrounding pixels. The tent functions available in vImage are <code><code><a href="../../../Reference/vImage_convolution/Reference/reference.html#//apple_ref/c/func/vImageTentConvolve_Planar8" target="_top">vImageTentConvolve_Planar8</a></code></code> and <code><code><a href="../../../Reference/vImage_convolution/Reference/reference.html#//apple_ref/c/func/vImageTentConvolve_ARGB8888" target="_top">vImageTentConvolve_ARGB8888</a></code></code>. These blur operations are equivalent to applying a convolution kernel filled with values that decrease with distance from the center. As with <code><code><a href="../../../Reference/vImage_convolution/Reference/reference.html#//apple_ref/c/func/vImageBoxConvolve_Planar8" target="_top">vImageBoxConvolve_Planar8</a></code></code> and <code><code><a href="../../../Reference/vImage_convolution/Reference/reference.html#//apple_ref/c/func/vImageBoxConvolve_ARGB8888" target="_top">vImageBoxConvolve_ARGB8888</a></code></code>, you do not need to pass any kernel to the function — just the height and width. Specifically, for an M x N kernel size, the kernel would be the product of an M x 1 column matrix and a 1 x N row matrix. Each would have 1 as the first element, then values increasing by 1 up to the middle element, then decreasing by 1 to the last element.</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH205-SW19" title="Figure 2-10Tent filter"></a><p><strong>Figure 2-10&nbsp;&nbsp;</strong>Tent filter</p><img src = "../Art/tent_filter.jpg" alt = "" ></div><br/><p>For example, suppose the kernel size is 3 x 5. Then the first matrix is </p><br/><div><img src = "../Art/vimage_matrix11.gif" alt = "image: ../Art/vimage_matrix11.gif" width="32" height="58"></div><br/><p>and the second is</p><br/><div><img src = "../Art/vimage_matrix12.gif" alt = "image: ../Art/vimage_matrix12.gif" width="95" height="22"></div><br/><p>The product is</p><br/><div><img src = "../Art/vimage_matrix13.gif" alt = "image: ../Art/vimage_matrix13.gif" width="119" height="58"></div><br/><p>The 3 x 5 tent filter operation is equivalent to convolution with the above matrix.</p><a name="//apple_ref/doc/uid/TP30001001-CH205-SW20" title="Using Multiple Kernels"></a><h3>Using Multiple Kernels</h3><p>vImage allows you to apply multiple kernels in a single convolution. The <code>vImageConvolveMultiKernel</code> functions allow for you to specify four separate kernels—one for each channel in the image. This allows for a greater level of control when applying filters to an image since you can operate on the red, green, blue, and alpha channels individually. For example, you can use multikernel convolutions to resample the color channels of an image differently to compensate for the positioning of RGB phosphors on the screen. Since each of the four kernels can operate on a single channel, the <code>vImageConvolveMultiKernel</code> functions are available only for interleaved image formats.</p><p>The use of these functions is identical to convolution with a single kernel, except that you must supply an array of pointers to the four kernels instead of one single kernel.</p><a name="//apple_ref/doc/uid/TP30001001-CH205-SW21" title="Deconvolving"></a><h2>Deconvolving</h2><p>As with the operations behind convolution, vImage takes care of performing the previously mentioned Richardson-Lucy algorithm for you. Your job is to provide the kernel (referred to as the point spread function) of the initial convolution. <span class="content_text">Listing 2-2</span> shows how to deconvole an emboss effect. You could use the same code to deconvolve various effects, such as blurring, by specifying the appropriate kernel. Note that unlike the convolution operations, there is an additional kernel parameter. This parameter can be <code>NULL</code> unless the height and width of the kernel are not the same size. If the kernel height and width are unequal, you must supply an identical kernel, but with its rows and columns inverted.</p><p><span class="content_text">Listing 2-2</span> is an example of how to use vImage to deconvolve an <code>ARGB8888</code>-formatted image.</p><a name="//apple_ref/doc/uid/TP30001001-CH205-SW9" title="Listing 2-2Deconvolving an embossed image"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Deconvolving an embossed image</p><div class="codesample"><table><tr><td scope="row"><pre>int myDeconvolve(void *inData,<span></span></pre></td></tr><tr><td scope="row"><pre> unsigned int inRowBytes,<span></span></pre></td></tr><tr><td scope="row"><pre> void *outData,<span></span></pre></td></tr><tr><td scope="row"><pre> unsigned int outRowBytes,<span></span></pre></td></tr><tr><td scope="row"><pre> unsigned int height,<span></span></pre></td></tr><tr><td scope="row"><pre> unsigned int width,<span></span></pre></td></tr><tr><td scope="row"><pre> void *kernel,<span></span></pre></td></tr><tr><td scope="row"><pre> unsigned int kernel_height,<span></span></pre></td></tr><tr><td scope="row"><pre> unsigned int kernel_width,<span></span></pre></td></tr><tr><td scope="row"><pre> int divisor,<span></span></pre></td></tr><tr><td scope="row"><pre> int iterationCount,<span></span></pre></td></tr><tr><td scope="row"><pre> vImage_Flags flags )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    //Prepare data structures<span></span></pre></td></tr><tr><td scope="row"><pre>    uint_8 kernel = {-2, -2, 0, -2, 6, 0, 0, 0, 0}; <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    vImage_Error err; <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    unsigned char bgColor[4] = { 0, 0, 0, 0 }; <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    vImage_Buffer src = { inData, height, width, inRowBytes }; <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    vImage_Buffer dest = { outData, height, width, outRowBytes }; <span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Send data to vImage for processing<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = vImageRichardsonLucyDeConvolve_ARGB8888(    &amp;src,     <span>// 6</span></pre></td></tr><tr><td scope="row"><pre>                                        &amp;dest,    //const vImage_Buffer *dest,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        0,    //unsigned int srcOffsetToROI_X,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        0,    //unsigned int srcOffsetToROI_Y,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        kernel,    //const signed int *kernel,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        NULL, //assumes symmetric kernel<span></span></pre></td></tr><tr><td scope="row"><pre>                                        kernel_height,     //unsigned int kernel_height,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        kernel_width,    //unsigned int kernel_width,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        0, //height of second kernel<span></span></pre></td></tr><tr><td scope="row"><pre>                                        0, //width of second kernel<span></span></pre></td></tr><tr><td scope="row"><pre>                                        divisor,    //int<span></span></pre></td></tr><tr><td scope="row"><pre>                                        0, //for second kernel<span></span></pre></td></tr><tr><td scope="row"><pre>                                        bgColor,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        iterationCount, //uint32_t<span></span></pre></td></tr><tr><td scope="row"><pre>                                        kvImageBackgroundColorFill | flags<span></span></pre></td></tr><tr><td scope="row"><pre>                                        //vImage_Flags<span></span></pre></td></tr><tr><td scope="row"><pre>                                    );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Report result<span></span></pre></td></tr><tr><td scope="row"><pre>    return err; <span>// 7</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Specifies the kernel used in the original convolution that vImage should deconvolve. The example uses a symmetrical kernel (both the height and width are 3), and therefore it isn’t necessary to supply a second kernel to vImage.</p></li><li class="li"><p>Declares the <code>vImage_Error</code> structure to capture the result of the deconvolution function.</p></li><li class="li"><p>Declares a <code>Pixel8888</code>-formatted pixel to represent the background color for the destination image (black in this case).</p></li><li class="li"><p>Declares a <code>vImage_Buffer</code> data structure for the source image information. Image data is received as an array of bytes (<code>inData</code>). The other members store the height, width, and bytes-per-row of the image. This data allows vImage to know how large the image data array is, and how to properly handle it.</p></li><li class="li"><p>Declares a <code>vImage_Buffer</code> data structure for the destination image information as done previously with the source image.</p></li><li class="li"><p>Supplies the previously declared data structures to vImage for processing. Note how the example supplies the <code>vImageRichardsonDeConvolve_ARGB8888</code> function with a <code>NULL</code> parameter for the second kernel. This is because the first kernel is symmetric, and therefore inverted kernel is not necessary.</p></li><li class="li"><p>Returns the same <code>vImage_Error</code> data structure returned from deconvolution.</p></li></ol><p>Deconvolution is an iterative process. You can specify how many times that you would like vImage to perform the deconvolution. Depending on how many iterations you choose, the image result may vary, so it may be worth experimenting with several iterations to see which one yields ideal results.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../OverviewofvImage/OverviewofvImage.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../GeometricOperations/GeometricOperations.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-10-15<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Conceptual/vImage/ConvolutionOperations/ConvolutionOperations.html%3Fid%3DTP30001001-4.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Conceptual/vImage/ConvolutionOperations/ConvolutionOperations.html%3Fid%3DTP30001001-4.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Conceptual/vImage/ConvolutionOperations/ConvolutionOperations.html%3Fid%3DTP30001001-4.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>