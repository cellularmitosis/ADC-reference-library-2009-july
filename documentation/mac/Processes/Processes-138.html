<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>The Jump Table (IM: Pr)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING138></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Processes-137.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Processes-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Processes-171.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Processes-139.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="Processes-2.html"><B>Processes</B></A><BR><DD><A HREF="Processes-135.html"><B>Chapter 7 - Segment Manager</B></A> / <A HREF="Processes-136.html"><B>About the Segment Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING138-0></A>
<H2>The Jump Table<A NAME=MARKER-2-14></A></H2>
<DL>
<DT><B>Note</B>
<DD>This section describes how the Segment Manager works internally and is included for informational purposes only. You don't need this information to use the Segment Manager routine. Moreover, the information presented here might not be accurate for your development system. See the note on <A HREF=#MARKER-9-21>page 7-7</A>.<B></B>  <B>&#183;</B>
</DL>
 The loading and unloading of segments are implemented through your application's <B>jump table,</B> an area of memory in your application's partition that contains one entry for every externally referenced routine in every code segment of your application. The location of the jump table is illustrated in <A HREF=#MARKER-9-15>Figure 7-1</A>.<P>
<B>Figure 7-1  <A NAME=MARKER-9-15></A>The location of the jump table</B><P>
<BR>
<BR>
<IMG SRC="graphics/IMM-05_copy.jpg"><P>
 The jump table is accessed through the A5 register and is therefore part of your application's A5 world.<P>
 The jump table is created by your development system's linker and is stored in segment 0 of your application (which is the <CODE>'CODE'</CODE> resource with an ID of 0). Segment 0 is a special segment created by the linker for every application; it contains information about the A5 world and the jump table. <A HREF=#MARKER-9-16>Figure 7-2</A> illustrates the structure of segment 0.<P>
<B>Figure 7-2  <A NAME=MARKER-9-16></A>The structure of segment 0</B><P>
<BR>
<BR>
<IMG SRC="graphics/SL-01.jpg"><P>
 Segment 0 consists of these elements:<P>
<UL>
<LI>Size above A5. The size (in bytes) from the location pointed to by register A5 to the upper end of the application space.
<LI>Size of globals. The size (in bytes) of the application global variables plus the QuickDraw global variables.
<LI>Length of jump table. The size (in bytes) of the jump table.
<LI>A5 offset of jump table. The offset (in bytes) to the jump table from the location pointed to by register A5. This offset is stored in the global variable <CODE>CurJTOffset</CODE>.<A NAME=MARKER-2-17></A>
<LI>Jump table. A contiguous list of jump table entries.<P>
</UL>
 When the MPW linker encounters a call to a routine in another code segment, it creates a <B>jump table entry</B> for that routine. (All entries for a particular segment are stored contiguously in the jump table.) The structure of a jump table entry varies according to whether the segment it references is loaded or unloaded. If the segment is not yet loaded into memory, the jump table entry has the structure illustrated in <A HREF=#MARKER-9-20>Figure 7-3</A>.<A NAME=MARKER-2-18></A><A NAME=MARKER-2-19></A><P>
<B>Figure 7-3  <A NAME=MARKER-9-20></A>Format of an MPW jump table entry when the segment is unloaded</B><P>
<BR>
<BR>
<IMG SRC="graphics/SL-02.jpg"><P>
<DL>
<DT><B>Note</B>
<DD><A NAME=MARKER-9-21></A>Some development systems use a different format for jump table entries of unloaded routines to circumvent the 32K-byte limitation on the size of segments, global data, or the jump table itself. Consult the documentation for your development system to see whether it uses the jump table entry formats described in this section and whether you can safely call the <CODE>UnloadSeg</CODE> procedure (which changes jump table entries).<B></B>  <B>&#183;</B>
</DL>
 The jump table refers to segments by segment numbers assigned by the linker. If the segment isn't loaded, the entry contains code that loads the segment. When a segment is unloaded, all its jump table entries are in the "unloaded" state. When a call to a routine in an unloaded segment is made, the code in the last 6 bytes of its jump table entry is executed. This code calls the <CODE>_LoadSeg</CODE> trap, which loads the segment into memory, transforms all of its jump table entries to a "loaded" state, and invokes the routine by executing the instruction in the last 6 bytes of its jump table entry. <A HREF=#MARKER-9-24>Figure 7-4</A> illustrates the format of a jump table entry in the "loaded" state.<A NAME=MARKER-9-13></A><A NAME=MARKER-2-39></A><P>
<B>Figure 7-4  <A NAME=MARKER-9-24></A>Format of an MPW jump table entry when the segment is loaded</B><P>
<BR>
<BR>
<IMG SRC="graphics/SL-03.jpg"><P>
 Subsequent calls to the routine also execute this instruction. When you call <CODE>UnloadSeg</CODE>, it restores the jump table entries to their "unloaded" state. Notice that the last 6 bytes of the jump table entry are always executed; the effect depends on the state of the entry at the time.<P>
 To set all the jump table entries for a segment to a particular state, the Segment Manager needs to know exactly where in the jump table all the entries are located. It gets this information from the <B>segment header,</B> 4 bytes at the beginning of the segment that contain the offset of the first routine's entry from the beginning of the jump table (2 bytes) and the number of entries for the segment (2 bytes).<A NAME=MARKER-2-25></A><A NAME=MARKER-2-26></A><P>
</BLOCKQUOTE><P>
<HR>
<center>
<A HREF="Processes-137.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Processes-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Processes-171.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Processes-139.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Processes-3.html">&copy; Apple Computer, Inc.</A><br>17 JUN 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
