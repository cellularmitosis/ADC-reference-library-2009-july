/*** James "im" Beninghaus*/#include	<QuickDraw.h>#include	<Devices.h>#include	<stdio.h>#include	<string.h>#include	<MacTCPCommonTypes.h>#include	<AddressXlation.h>#include	<GetMyIPAddr.h>#include	<TCPPB.h>#include	<UDPPB.h>#define		_STORAGE_	true#include	<TCP.h>main (int argc, char *argv[]) {		auto	OSErr			osErr			= noErr;	auto	short			index;	auto	char			*option;	auto	char			*parameter;	auto	char			*address;	auto	char			*text;	auto	TCPNotifyProc	asrProc			= nil;	auto	TCPiopb			pb;	auto	StreamPtr		stream;	auto	char			streamBuf[4096];	auto	long			streamBufLen	= sizeof(streamBuf);	auto	Ptr				streamBufPtr;	auto	ip_addr			localIP			= cAnyIP;	auto	ip_port			localPort		= cAnyPort;	auto	ip_addr			remoteIP		= cAnyIP;	auto	ip_port			remotePort		= cReceivePort;	auto	WDS(1)			wds;		InitGraf((Ptr) &qd.thePort);	if (argc > 1) {		index = 1;		while (index < argc) {					option = argv[index++];			parameter = argv[index++];						if ('-' != option[0] || (! strchr("atn", option[1])) || index > argc) {				printf("TCPSend -a ipAddress -t text [-n]");				exit(paramErr);			} else {				switch (option[1]) {					case 'a' :						address = parameter;						break;					case 't' :						text = parameter;						break;					case 'n' :						asrProc = ASR;						index--;						break;				}			}					}	}		osErr = _TCPInit();	if (noErr == osErr) {		osErr = _TCPCreate(&pb, &stream, streamBuf, streamBufLen, (TCPNotifyProc) asrProc, (Ptr) nil,  (TCPIOCompletionProc) nil, false);		if (noErr == osErr) {			osErr = TCPDotAddress(address, &remoteIP);			if (noErr == osErr) {				osErr = _TCPActiveOpen(&pb, stream, remoteIP, remotePort, &localIP, &localPort, (Ptr) nil, (TCPIOCompletionProc) nil, false);				if (noErr == osErr) {									/* send data to the remote host */					wds.block[0].ptr	= text;					wds.block[0].length	= strlen(text) + 1;					wds.zero			= nil;					osErr = _TCPSend(&pb, stream, (wdsEntry *) &wds, (Ptr) nil, (TCPIOCompletionProc) nil, false);										osErr = _TCPClose(&pb, stream, nil, (TCPIOCompletionProc) nil, false);				}			}		}		osErr = _TCPRelease(&pb, stream, &streamBufPtr, &streamBufLen, (TCPIOCompletionProc) nil, false);	}	exit(osErr);}pascal void	StrToAddrResultProc(aHostInfo, userdata)	/* utility routine for StrToAddr */	struct hostInfo	*aHostInfo;	Ptr				userdata;{	/* simply watch the aHostInfo.rtnCode! */}OSErr TCPDotAddress(char *dotAddress, ip_addr *ipAddress) {	auto	OSErr				osErr;	auto	struct hostInfo		aHostInfo;			/* a data structure for the DNR function */	osErr = OpenResolver((char *) 0);	if (osErr) {		return osErr;	}		/* ask the DNR function to get the IP address */	StrToAddr(dotAddress, &aHostInfo, (ResultProcPtr) StrToAddrResultProc, (Ptr) 0);		/* wait for the address information or some error other than cacheFault to occur */	while (cacheFault == aHostInfo.rtnCode)		;		osErr = CloseResolver();	if (osErr) {		return osErr;	}	/* if it was an error there isn't much more we can do here but let the caller know */	if (noErr != aHostInfo.rtnCode) {		osErr = aHostInfo.rtnCode;		return osErr;	}		/* use the first IP address for this host */	*ipAddress = aHostInfo.addr[0];					return osErr;}