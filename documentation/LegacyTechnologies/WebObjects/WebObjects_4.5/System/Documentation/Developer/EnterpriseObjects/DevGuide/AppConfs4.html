<html><head><title>Application Configurations</title></head><body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOF Developer's Guide</font><br><br><!--end of path --> <a href="AppConfs.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="AppConfs3.html"><IMG SRC="ArrowLeft.gif">Previous Section</a> <a name="5204"><h1> Object Store Coordinator Configurations</h1></a><a name="4027">Recall that by default, all the EOEditingContexts in an application share the same EOObjectStoreCoordinator (see<a href="AppConfs1.html#3823"> "Sharing Editing Contexts and Coordinators"</a>). In this default configuration, all of a coordinator's editing contexts are synchronized with one another after any of the editing contexts save changes. Also, the editing contexts share underlying database connections wherever possible. This default behavior is typically what you want, but there are a some rare situations in which you might need more than one EOObjectStoreCoordinator. <p></a><a name="7061">All entity names must be unique within the scope of an EOObjectStoreCoordinator, so you need multiple coordinators when your application uses more than one connection to a database and each connection uses entities with the same name. For example, the following scenarios require multiple coordinators:<p></a><ul><a name="7063"><p><li>An application that performs two types of tasks-regular user tasks and administrative tasks</a><a name="7147"><p>The different types of tasks require different connections to the database. Regular user tasks go through a database connection that uses a regular user login while administrative tasks go through a database connection that uses a special administrative login. The &#32;two connections use different connection dictionaries, but &#32;otherwise use the same models. Consequently, the each connection uses the same entities.<p></a><a name="7074"><p><li>A WebObjects application that requires users to log in with their own login information</a><a name="7148"><p>In this scenario, you'd set up a database connection for each user session. Here, too, the database connections use different connection dictionaries, but otherwise use the same models.<p></a><a name="7064"><p><li>An application that requires multiple, simultaneous transactions open on the same database</a><a name="7149"><p>Because the transactions use the same model (and potentially the same connection information), they require their own connections to the database.<p></a></ul><a name="7055">As shown in <a href="AppConfs4.html#4036">Figure &#32;44</a>, using an additional coordinator influences the number of database connections your application maintains.<p></a><a name="4036"><p><img src="AppConfs13.gif"><p></a><a name="4040"><p>Figure 44.	  Multiple EOObjectStoreCoordinators<p></a><a name="15878">The following sections describe how to create multiple coordinators. After you create an EOObjectStoreCoordinator, it takes care of setting &#32;up &#32;its underlying network of objects as described in the sections<a href="AppConfs2.html#3880"> "Inside &#32;EOObjectStoreCoordinator"</a> <br>and <a href="AppConfs2.html#3899"> "Inside &#32;EODatabaseContext"</a>.<p></a><a name="4052"><h2> Setting Up Multiple Coordinators Programmatically</h2></a><a name="4054">If you are creating your EOEditingContexts programmatically, assigning unique EOObjectStoreCoordinators wherever necessary is straightforward. You simply:<p></a><a name="14646">In Java:<p></a><pre><a name="14653">EOObjectStoreCoordinator coordinator =<br>	new EOObjectStoreCoordinator();<br>EOEditingContext ec = new EOEditingContext(coordinator);</a></pre><a name="14647">In Objective-C:<p></a><pre><a name="14648">EOObjectStoreCoordinator *coordinator =<br>	[[[EOObjectStoreCoordinator alloc] init] autorelease];<br>EOEditingContext *ec = [[EOEditingContext alloc]<br>	initWithParentObjectStore:coordinator];</a></pre><a name="4062"><h2> Setting Up Multiple Coordinators Using Nibs</h2></a><a name="14662">If you are unarchiving your EOEditingContexts from nib files, you can specify a unique EOObjectStoreCoordinator using the EOEditingContext method <strong>setDefaultParentObjectStore</strong> (<strong>setDefaultParentObjectStore:</strong> in Objective-C) as follows:<p></a><a name="14673">In Java:<p></a><pre><a name="14674">EOObjectStoreCoordinator coordinator =<br>	new EOObjectStoreCoordinator();<br>EOEditingContext.setDefaultParentObjectStore(coordinator);<br>NSApplication.loadNibNamed("MyNib", this);<br>EOEditingContext.setDefaultParentObjectStore(null);</a></pre><a name="14675">In Objective-C:<p></a><pre><a name="14676">EOObjectStoreCoordinator *coordinator =<br>	[[[EOObjectStoreCoordinator alloc] init] autorelease];<br>[EOEditingContext<br>	setDefaultParentObjectStore:coordinator];<br>[NSApplication loadNibNamed:@"MyNib" owner:self];<br>[EOEditingContext setDefaultParentObjectStore:nil];</a></pre><a name="4070">After setting the default object store coordinator, new editing contexts (such as the one being unarchived from the nib) use the new EOObjectStoreCoordinator. After loading the nib, set the default parent object store back to the default EOObjectStoreCoordinator by sending a <strong>setDefaultParentObjectsStore</strong> message with <strong>null</strong> (<strong>nil</strong>) as the argument.<p></a><P> <a href="AppConfs.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="AppConfs5.html"><IMG SRC="ArrowRight.gif">Next Section</a><P></body></html>