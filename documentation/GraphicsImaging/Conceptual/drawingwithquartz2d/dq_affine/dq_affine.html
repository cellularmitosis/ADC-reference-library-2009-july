<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Quartz 2D Programming Guide: Transforms</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Transforms"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001066-CH204" title="Transforms"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../Quartz-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000559" target="_top">Quartz</a> &gt; <a href="../dq_intro/dq_intro.html#//apple_ref/doc/uid/TP30001066-CH201-TPXREF101">Quartz 2D Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../dq_color/dq_color.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../dq_patterns/dq_patterns.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001066-CH204-SW1" title="Transforms"></a><h1><a name="//apple_ref/doc/uid/TP30001066-CH204-TPXREF101" title="Transforms"></a>Transforms</h1><p>Using Quartz 2D you never have to rewrite your application or write additional code to adjust the output from your application for optimum display on different devices. This is because the Quartz 2D drawing model defines two completely separate coordinate spaces: user space, which represents the document page, and device space, which represents the native resolution of a device. User space coordinates are floating-point numbers that are unrelated to the resolution of pixels in device space. When you want to print or display your document, Quartz maps user space coordinates to device space coordinates. </p><p>You can modify the default user space by operating on the <strong>current transformation matrix</strong>, or CTM. After you create a graphics context, the CTM is the identity matrix. You can use Quartz transformation functions to modify the CTM and, as a result, modify drawing in user space.</p><p>This chapter:</p><ul class="ul"><li class="li"><p>Provides an overview of the functions you can use to perform transformations</p></li><li class="li"><p>Shows how to modify the CTM</p></li><li class="li"><p>Describes how to create an affine transform</p></li><li class="li"><p>Show how to determine if two transforms are equivalent</p></li><li class="li"><p>Describes how to obtain the user-to-device-space transform</p></li><li class="li"><p>Discusses the math behind affine transforms</p></li></ul>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-DontLinkElementID_1">About Quartz Transformation Functions</a>
				
			<br/>
			
        
			
			
				<a href="dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-CJBBHBEF">Modifying the Current Transformation Matrix</a>
				
			<br/>
			
        
			
			
				<a href="dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-CJBHFCIB">Creating Affine Transforms</a>
				
			<br/>
			
        
			
			
				<a href="dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-CJBJGCGI">Evaluating Affine Transforms</a>
				
			<br/>
			
        
			
			
				<a href="dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-CJBIGDFB">Getting the User to Device Space Transform</a>
				
			<br/>
			
        
			
			
				<a href="dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-CJBECIAD">The Math Behind the Matrices</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001066-CH204-DontLinkElementID_1" title="About Quartz Transformation Functions"></a><h2>About Quartz Transformation Functions</h2><p>You can easily translate, scale, and rotate your drawing using the Quartz 2D built-in transformation functions. With just a few lines of code, you can apply these transformations in any order and in any combination. <span class="content_text">Figure 5-1</span> illustrates the effects of scaling and rotating an image. Each transformation you apply updates the CTM. The CTM always represents the current mapping between user space and device space. This ensures that the output from your application looks great on any display screen or printer.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBHGHDC" title="Figure 5-1Applying scaling and rotation"></a><p><strong>Figure 5-1&nbsp;&nbsp;</strong>Applying scaling and rotation</p><img src = "../Art/spaces.gif" alt = "Applying scaling and rotation" width="310" height="144"></div><br/><p>The Quartz 2D API provides five functions that allow you to obtain and modify the CTM. You can rotate, translate, and scale the CTM, and you can concatenate an affine transformation matrix with the CTM. See <span class="content_text"><a href="dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-CJBBHBEF">“Modifying the Current Transformation Matrix.”</a></span> </p><p>Quartz also allows you to create affine transforms that don’t operate on user space until you decide to apply the transform to the CTM. You use another set of functions to create affine transforms, which can then be concatenated with the CTM. See <span class="content_text"><a href="dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-CJBHFCIB">“Creating Affine Transforms.”</a></span></p><p>You can use either set of functions without understanding anything about matrix math. However if you want to understand what Quartz does when you call one of the transform functions, read <span class="content_text"><a href="dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-CJBECIAD">“The Math Behind the Matrices.”</a></span> </p><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBBHBEF" title="Modifying the Current Transformation Matrix"></a><h2>Modifying the Current Transformation Matrix</h2><p>You manipulate the CTM to rotate, scale, or translate the page before drawing an image, thereby transforming the object you are about to draw. Before you transform the CTM, you need to save the graphics state so that you can restore it after drawing. You can also concatenate the CTM with an affine transform (see <span class="content_text"><a href="dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-CJBHFCIB">“Creating Affine Transforms”</a></span>). Each of these four operations—translation, rotation, scaling, and concatenation—is described in this section along with the CTM functions that perform each operation.</p><p>The following line of code draws an image, assuming that you provide a valid graphics context, a pointer to the rectangle to draw the image to, and a valid CGImage object. The code draws an image, such as the sample rooster image shown in <span class="content_text">Figure 5-2</span>. As you read the rest of this section, you’ll see how the image changes as you apply transformations.</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextDrawImage (myContext, rect, myImage);<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBJDEGB" title="Figure 5-2An image that is not transformed"></a><p><strong>Figure 5-2&nbsp;&nbsp;</strong>An image that is not transformed</p><img src = "../Art/normal_rooster.gif" alt = "An image that is not transformed" width="363" height="281"></div><br/><p><strong>Translation</strong> moves the origin of the coordinate space by the amount you specify for the x and y axes. You call the function <code>CGContextTranslateCTM</code> to modify the x- and y-coordinates of each point by a specified amount. <span class="content_text">Figure 5-3</span> shows an image translated by 100 units in the x axis and 50 units in the y axis, using the following line of code:</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextTranslateCTM (myContext, 100, 50);<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBDFDIF" title="Figure 5-3A translated image"></a><p><strong>Figure 5-3&nbsp;&nbsp;</strong>A translated image</p><img src = "../Art/translated_rooster.gif" alt = "A translated image" width="375" height="291"></div><br/><p><strong>Rotation</strong> moves the coordinate space by the angle you specify. You call the function <code>CGContextRotateCTM</code> to specify the rotation angle, in radians. <span class="content_text">Figure 5-4</span> shows an image rotated by –45 degrees about the origin, which is the lower left of the window, using the following line of code:</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextRotateCTM (myContext, radians(–45.));<span></span></pre></td></tr></table></div><p>The image is clipped because the rotation moved part of the image to a location outside the context. You need to specify the rotation angle in radians. </p><p>It’s useful to write a radians routine if you plan to perform many rotations.</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;math.h><span></span></pre></td></tr><tr><td scope="row"><pre>static inline double radians (double degrees) {return degrees * M_PI/180;}<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBIHCJD" title="Figure 5-4A rotated image"></a><p><strong>Figure 5-4&nbsp;&nbsp;</strong>A rotated image</p><img src = "../Art/rotated_rooster.gif" alt = "A rotated image" width="313" height="243"></div><br/><p><strong>Scaling</strong> changes the scale of the coordinate space by the x and y factors you specify, effectively stretching or shrinking coordinates. The magnitude of the x and y factors governs whether the new coordinates are larger or smaller than the original. In addition, by making the x factor negative, you can flip the coordinates along the x-axis; similarly, you can flip coordinates horizontally, along the y-axis, by making the y factor negative. You call the function <code>CGContextScaleCTM</code> to specify the x and y scaling factors. <span class="content_text">Figure 5-5</span> shows an image whose x values are scaled by .5 and whose y values are scaled by .75, using the following line of code:</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextScaleCTM (myContext, .5, .75);<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBJHDGH" title="Figure 5-5A scaled image"></a><p><strong>Figure 5-5&nbsp;&nbsp;</strong>A scaled image</p><img src = "../Art/scaled_rooster.gif" alt = "A scaled image" width="312" height="240"></div><br/><p><strong>Concatenation</strong> combines two matrices by multiplying them together. You can concatenate several matrices together to form a single matrix that contains the cumulative effects of the matrices. You call the function <code>CGContextConcatCTM</code> to combine the CTM with an affine transform. Affine transforms, and the functions that create them, are discussed in <span class="content_text"><a href="dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-CJBHFCIB">“Creating Affine Transforms.”</a></span></p><p>Another way to achieve a cumulative effect is to perform two or more transformations without restoring the graphics state between transformation calls. <span class="content_text">Figure 5-6</span> shows an image that results from translating an image and then rotating it, using the following lines of code:</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextTranslateCTM (myContext, w,h);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextRotateCTM (myContext, radians(-180.));<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBECCGC" title="Figure 5-6An image that is translated and rotated"></a><p><strong>Figure 5-6&nbsp;&nbsp;</strong>An image that is translated and rotated</p><img src = "../Art/tr_rooster.gif" alt = "An image that is translated and rotated" width="328" height="267"></div><br/><p><span class="content_text">Figure 5-7</span> shows an image that is translated, scaled, and rotated, using the following lines of code:</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextTranslateCTM (myContext, w/4, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextScaleCTM (myContext, .25,  .5);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextRotateCTM (myContext, radians ( 22.));<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBGJIBD" title="Figure 5-7An image that is translated, scaled, and then rotated"></a><p><strong>Figure 5-7&nbsp;&nbsp;</strong>An image that is translated, scaled, and then rotated</p><img src = "../Art/tsr_rooster.gif" alt = "An image that is translated, scaled, and then rotated" width="546" height="397"></div><br/><p>The order in which you perform multiple transformations matters; you get different results if you reverse the order. Reverse the order of transformations used to create <span class="content_text">Figure 5-7</span> and you get the results shown in <span class="content_text">Figure 5-8</span>, which is produced with this code:</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextRotateCTM (myContext, radians ( 22.));<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextScaleCTM (myContext, .25,  .5);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextTranslateCTM (myContext, w/4, 0);<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBFAHCG" title="Figure 5-8An image that is rotated, scaled, and then translated"></a><p><strong>Figure 5-8&nbsp;&nbsp;</strong>An image that is rotated, scaled, and then translated</p><img src = "../Art/rst_rooster.gif" alt = "An image that is rotated, scaled, and then translated" width="513" height="461"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBHFCIB" title="Creating Affine Transforms"></a><h2>Creating Affine Transforms</h2><p>The affine transform functions available in Quartz operate on matrices, not on the CTM. You can use these functions to construct a matrix that you later apply to the CTM by calling the function <code>CGContextConcatCTM</code>. The affine transform functions either operate on, or return, a <code>CGAffineTransform</code> data structure. This enables you to construct simple or complex affine transforms that you can readily reuse.</p><p>The affine transform functions perform the same operations as the CTM functions—translation, rotation, scaling, and concatenation. <span class="content_text">Table 5-1</span> lists the functions that perform these operations along with information on their use. Note that there are two functions for each of the translation, rotation, and scaling operations.</p><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBCBJAG" title="Table 5-1Affine transform functions for translation, rotation, and scaling"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 5-1&nbsp;&nbsp;</strong>Affine transform functions for translation, rotation, and scaling</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Use</p></th></tr><tr><td  scope="row"><p><code>CGAffineTransformMakeTranslation</code></p></td><td ><p>To construct a new translation matrix from x and y values that specify how much to move the origin.</p></td></tr><tr><td  scope="row"><p><code>CGAffineTransformTranslate</code></p></td><td ><p>To apply a translation operation to an existing affine transform. </p></td></tr><tr><td  scope="row"><p><code>CGAffineTransformMakeRotation</code></p></td><td ><p>To construct a new rotation matrix from a value that specifies in radians how much to rotate the coordinate system.</p></td></tr><tr><td  scope="row"><p><code>CGAffineTransformRotate</code></p></td><td ><p>To apply a rotation operation to an existing affine transform. </p></td></tr><tr><td  scope="row"><p><code>CGAffineTransformMakeScale</code></p></td><td ><p>To construct a new scaling matrix from x and y values that specify how much to stretch or shrink coordinates.</p></td></tr><tr><td  scope="row"><p><code>CGAffineTransformScale</code></p></td><td ><p>To apply a scaling operation to an existing affine transform. </p></td></tr></table></div><p>Quartz also provides an affine transform function that inverts a matrix, <code>CGAffineTransformInvert</code>. Inversion is generally used to provide reverse transformation of points within transformed objects. Inversion can be useful when you need to recover a value that has been transformed by a matrix: invert the matrix, and multiply the value by the inverted matrix, and the result is the original value. You usually don’t need to invert transforms because you can reverse the effects of transforming the CTM by saving and restoring the graphics state.</p><p>In some situations you might not want to transform the entire space, but just a point or a size. You operate on a <code>CGPoint</code> structure by calling the function <code>CGPointApplyAffineTransform</code>. You operate on a <code>CGSize</code> structure by calling the function <code>CGSizeApplyAffineTransform</code>. In Mac OS X v10.4 and later, you can operate on a <code>CGRect</code> structure by calling the function <code>CGRectApplyAffineTransform</code>. This function returns the smallest rectangle that contains the transformed corner points of the rectangle passed to it. If the affine transform that operates on the rectangle performs only scaling and translation operations, the returned rectangle coincides with the rectangle constructed from the four transformed corners.</p><p>You can create a new affine transform by calling the function <code>CGAffineTransformMake</code>, but unlike the other functions that make new affine transforms, this one requires you to supply matrix entries. To effectively use this function, you need to have an understanding of matrix math. See <span class="content_text"><a href="dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-CJBECIAD">“The Math Behind the Matrices.”</a></span></p><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBJGCGI" title="Evaluating Affine Transforms"></a><h2>Evaluating Affine Transforms</h2><p>You can determine whether one affine transform is equal to another by calling the function <code>CGAffineTransformEqualToTransform</code>. This function, available in Mac OS X v10.4 and later, returns <code>true</code> if the two transforms passed to it are equal and <code>false</code> otherwise.</p><p>The function <code>CGAffineTransformIsIdentity</code>, available in Mac OS X v10.4 and later, is a useful function for checking whether a transform is the <strong>identity transform</strong>. The identity transform performs no translation, scaling, or rotation. Applying this transform to the input coordinates always returns the input coordinates. The Quartz constant <code>CGAffineTransformIdentity</code> represents the identity transform.</p><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBIGDFB" title="Getting the User to Device Space Transform"></a><h2>Getting the User to Device Space Transform</h2><p>Typically when you draw with Quartz 2D, you need only to work in user space. Quartz takes care of transforming between user and device space for you. If your application needs to obtain the affine transform that Quartz uses to convert between user and device space, you can call the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextGetUserSpaceToDeviceSpaceTransform" target="_top">CGContextGetUserSpaceToDeviceSpaceTransform</a></code>. This function is available starting in Mac OS X v10.4. </p><p>Quartz adds a number of convenience functions in Mac OS X v10.4 to transform the following geometries between user space and device space. You might find these functions easier to use than applying the affine transform returned from the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextGetUserSpaceToDeviceSpaceTransform" target="_top">CGContextGetUserSpaceToDeviceSpaceTransform</a></code>.</p><ul class="ul"><li class="li"><p>Points. The functions <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextConvertPointToDeviceSpace" target="_top">CGContextConvertPointToDeviceSpace</a></code> and <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextConvertPointToUserSpace" target="_top">CGContextConvertPointToUserSpace</a></code> transform a <code>CGPoint</code> data type from one space to the other.</p></li><li class="li"><p>Sizes. The functions <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextConvertSizeToDeviceSpace" target="_top">CGContextConvertSizeToDeviceSpace</a></code> and <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextConvertSizeToUserSpace" target="_top">CGContextConvertSizeToUserSpace</a></code> transform a <code>CGSize</code> data type from one space to the other.</p></li><li class="li"><p>Rectangles. The functions <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextConvertRectToDeviceSpace" target="_top">CGContextConvertRectToDeviceSpace</a></code> and <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextConvertRectToUserSpace" target="_top">CGContextConvertRectToUserSpace</a></code> transform a <code>CGRect</code> data type from one space to the other.</p></li></ul><a name="//apple_ref/doc/uid/TP30001066-CH204-CJBECIAD" title="The Math Behind the Matrices"></a><h2>The Math Behind the Matrices</h2><p>The only Quartz 2D function for which you need an understanding of matrix math is the function <code>CGAffineTransformMake</code>, which makes an affine transform from the six critical entries in a 3 x 3 matrix. Even if you never plan to construct an affine transformation matrix “from scratch,” you might find the math behind the transform functions interesting. If not, you can skip the rest of this chapter.</p><p>The six critical values of a 3 x 3 transformation matrix —<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>tx</em> and <em>ty</em>— are shown in the following matrix: </p><br/><div><img src = "../Art/equation01.gif" alt = "A 3 by 3 transformation matrix." width="74" height="73"></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP30001066-CH204-DontLinkElementID_47" title="Note"></a><p><strong>Note:</strong>&nbsp;The rightmost column of the matrix always contains the constant values 0, 0, 1. Mathematically, this third column is required to allow concatenation, which is explained later in this section. It appears in this section for the sake of mathematical correctness only.</p></div><p>Given the 3 x 3 transformation matrix described above, Quartz uses this equation to transform a point (<em>x</em>, <em>y</em>) into a resultant point (<code>x</code>’, <em>y</em>’):</p><br/><div><img src = "../Art/equation02.gif" alt = "An equation that transforms a point by multiplying it with a transformation matrix" width="226" height="69"></div><br/><p>The result is in a different coordinate system, the one transformed by the variable values in the transformation matrix. The following equations are the definition of the previous matrix transform:</p><br/><div><img src = "../Art/equation03.gif" alt = "Equations that define the previous three by three matrix" width="100" height="47"></div><br/><p>The following matrix is the identity matrix. It performs no translation, scaling, or rotation. Multiplying this matrix by the input coordinates always returns the input coordinates. </p><br/><div><img src = "../Art/equation04.gif" alt = "The identity matrix." width="72" height="70"></div><br/><p>Using the formulas discussed earlier, you can see that this matrix would generate a new point (<em>x</em>’, <em>y</em>’) that is the same as the old point (<em>x</em>, <em>y</em>):</p><br/><div><img src = "../Art/equation05.gif" alt = "Formulas for generating identity point." width="144" height="45"></div><br/><p>This matrix describes a <strong>translation</strong> operation:</p><br/><div><img src = "../Art/equation06.gif" alt = "Translation matrix." width="76" height="74"></div><br/><p>These are the resulting equations that Quartz uses to apply the translation:</p><br/><div><img src = "../Art/equation07.gif" alt = "Translation equations." width="63" height="43"></div><br/><p>This matrix describes a <strong>scaling</strong> operation on a point (<em>x</em>, <em>y</em>):</p><br/><div><img src = "../Art/equation08.gif" alt = "Scaling matrix" width="79" height="69"></div><br/><p>These are the resulting equations that Quartz uses to scale the coordinates:</p><br/><div><img src = "../Art/equation09.gif" alt = "Scaling equations." width="59" height="45"></div><br/><p>This matrix describes a <strong>rotation</strong> operation, rotating the point (<em>x</em>, <em>y</em>) counterclockwise by an angle a:</p><br/><div><img src = "../Art/equation10.gif" alt = "Rotation matrix" width="121" height="68"></div><br/><p>These are the resulting equations that Quartz uses to apply the rotation:</p><br/><div><img src = "../Art/equation11.gif" alt = "Rotation equations" width="122" height="41"></div><br/><p>This equation <strong>concatenates</strong> a rotation operation with a translation operation:</p><br/><div><img src = "../Art/equation12.gif" alt = "Matrix operations for concatenating a rotation operation with a translation operation." width="335" height="72"></div><br/><p>These are the resulting equations that Quartz uses to apply the transform:</p><br/><div><img src = "../Art/equation13.gif" alt = "Equatoins for the concatentation operation." width="150" height="45"></div><br/><p>Note that the order in which you concatenate matrices is important—matrix multiplication is not commutative. That is, the result of multiplying matrix A by matrix B does not necessarily equal the result of multiplying matrix B by matrix A.</p><p>As previously mentioned, concatenation is the reason the affine transformation matrix contains a third column with the constant values 0, 0, 1. To multiply one matrix against another matrix, the number of columns of one matrix must match the number of rows of the other. This means that a 2 x 3 matrix cannot be multiplied against a 2 x 3 matrix. Thus we need the extra column containing the constant values.</p><p>An <strong>inversion</strong> operation produces original coordinates from transformed ones. Given the coordinates (<em>x</em>, <em>y</em>), which have been transformed by a given matrix A to new coordinates (<em>x</em>’, <em>y</em>’), transforming the coordinates (<em>x</em>’, <em>y</em>’) by the inverse of matrix A produces the original coordinates (<em>x</em>, <em>y</em>). When a matrix is multiplied by its inverse, the result is the identity matrix.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../dq_color/dq_color.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../dq_patterns/dq_patterns.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-12-11<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_affine/dq_affine.html%3Fid%3DTP30001066-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_affine/dq_affine.html%3Fid%3DTP30001066-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_affine/dq_affine.html%3Fid%3DTP30001066-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>