/*	File:		DTSCPlusLibrary.cp	Contains:	DTSCPlusLibrary.h contains all the global data and definitions needed when building  				more DTS C++ libraries. Every class should have this file included. 				DTSCPlusLibrary.cp contains functions that we could not inline inside the header (sigh).	Written by: 		Copyright:	Copyright © 1992-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				8/18/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				*/#ifndef _DTSCPLUSLIBRARY_#include "DTSCPlusLibrary.h"#endif#include <TextUtils.h>#include <Sound.h>// _________________________________________________________________________________________________________ //// STRING FUNCTIONS // return the len of a C stringshort clen(char *cptr){	short	i;	for (i = 0; cptr[i]; ++i)		;	return(i);}// Convert a c-string to a pascal-stringvoid c2p(char *cptr){	c2pstr(cptr);	/*char	len;	Str255 myStr;	::BlockMove(cptr, &myStr[1], len = clen(cptr));	cptr[0] = len;*/}// Convert a pascal-string to a c-stringvoid p2c(StringPtr cptr){	char	len;	::BlockMove(cptr + 1, cptr, len = *cptr);	cptr[len] = 0;}// Copy two Pascal stringsvoid Pstrcpy(StringPtr d, StringPtr s){	short	i;	i = *s;	do {		d[i] = s[i];	} while (i--);}// Concatenate two Pascal strings.void ConcatPStrings(Str255 first,						   Str255 second){	short charsToCopy;	// Truncate if concatenated string would be longer than 255 chars	charsToCopy = Min(second[0], 255 - first[0]);	::BlockMove(second + 1, first + first[0] + 1, (long)charsToCopy);	first[0] += charsToCopy;}// Compare two Pascal Strings.Boolean CompareStr255(const Str255 *first, const Str255 *second){	short state = ::RelString(*first, *second, true, true);			// call toolbox comparison routine	if(state == sortsEqual)		return true;	else		return false;}//	vxdebugstr that also prints out by default __FILE__ and __LINE__ informationvoid vxdebugstr(char* format,...) {	char buff[255];	char final[255];	va_list arglist;	va_start(arglist,format);	vsprintf(buff,format,arglist);	va_end(arglist);#ifdef FILELINEINFO		strcat(final,fileNameArray);#ifdef TESTLEVEL2	strcat(final, " ;");							// MacsBug does not like embedded ;s#endif	strcat(final, lineNumberArray);#endif	strcat(final, buff);	c2p(final);		// Print out the message, based on the testing level#ifdef TESTLEVEL1	AlertUser((StringPtr)final);#endif#ifdef TESTLEVEL2	::SysBreakStr((StringPtr)final);						// for high level debuggers#endif#ifdef TESTLEVEL3	::DebugStr((StringPtr)final);#endif}// ErrorWindow (no resources)// Here's an example of how to create a window with error information, without using Alerts or // any other resource-bound constructs:// Pre-defined messages needed in the final box.const char* kLabelMessage = "Serious Problem:";const char* kInformMessage = "Click with the mouse or hit a key to terminate the application…";void ErrorWindow(char* message)// Present a nice error window with a defined message.{	Rect windowRect, textRect, labelRect, informRect;	WindowPtr win;		// Define a window size and create a window	::SetRect(&windowRect, 90, 70, 400, 200);	win = ::NewWindow(NULL, &windowRect, "\p", true, dBoxProc, (WindowPtr)-1, false, 0L);				if(win != NULL)		{			::SetPort(win);			// switch to the right port			::InitCursor();			// make sure the cursor is normal			// First draw the label:			::SetRect(&labelRect, 20, 5, 300, 18);			::TextFace(bold);			::TETextBox(kLabelMessage, strlen(kLabelMessage), &labelRect, teJustLeft);			// Then draw the message:			::SetRect(&textRect, 20, 30, 300, 280);		// define a text rect			::TextSize(9);			::TETextBox(message, strlen(message), &textRect, teJustLeft);				// Draw the inform line at the bottom of the box			::SetRect(&informRect,10, 115, 300, 280);			::TextFace(normal);				::TETextBox(kInformMessage, strlen(kInformMessage), &informRect, teJustLeft);							// now, spin around in WaitNextEvent until user hits a key click or hits the mouse			EventRecord anEvent;			while(!::WaitNextEvent(keyDownMask+mDownMask, &anEvent, 20L, NULL))				;						// OK, we got the needed event, dispose the window.			::DisposeWindow(win);		}	// Problems, we couldn't create a window, so all we could do is to beep for the end user.		else			::SysBeep(1);				::ExitToShell();	// this is a serious problem, so we need to exit once and for all}/* example of use: ErrorWindow("Joe Montana can't play this Sunday: Error -9999");*/// _________________________________________________________________________________________________________ ///*	Change History (most recent last):  No	Init.	Date		Comment  1		khs		9/10/92		New file  2		khs		11/26/92	Added ASSERT macros and testing levels  3		khs		1/14/93		Cleanup*/