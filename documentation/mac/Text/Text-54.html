<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Saving and Restoring a TextEdit Document, and  Implementing Undo(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING54></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-53.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-55.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-40.html"><B>Chapter 2 - TextEdit</B></A> / <A HREF="Text-49.html"><B>Using TextEdit</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING54-0></A>
<H2><A NAME=MARKER-9-279></A>Saving and Restoring a TextEdit Document, and <BR>Implementing Undo</H2>
 This section describes how to save to disk the contents of a document created using TextEdit, and restore it when the user opens the document. For both monostyled and multistyled text, you need to save and restore the text and its character attribute information. This section also discusses how to implement an Undo feature.<P>
<A NAME=HEADING54-2></A>
<H3>Saving a TextEdit Document</H3>
 To save the contents of a document created using TextEdit and a monostyled edit record, you store the text. You can also save the text characteristics, such as the font and its size and style, and the text margins; you can store this information in a resource. (Save the font name, not the font number.)<P>
 To save the contents of a document created using TextEdit and a multistyled edit record, you need to save all of the associated character attribute information in addition to the text. Because the text format of the character attribute information in the style scrap is easier to export than the style record itself--it uses the Desk Manager's <CODE>'styl'</CODE> format--you should use the TextEdit routines that use the style scrap for moving character attribute information: <CODE>TEGetStyleScrapHandle</CODE> <A NAME=MARKER-2-40></A>and<A NAME=MARKER-2-41></A> <CODE>TEUseStyleScrap</CODE>. For example, you can use the following steps to save a multistyled text document to disk:<P>
<OL>
<LI>Create a text file, select all the text of the edit record, and save it in the text file's <BR>data fork.
<LI>Call <B><A NAME=MARKER-2-42></A><CODE>TEGetStyleScrapHandle</CODE></B> to get a handle to the style <A NAME=MARKER-2-45></A>scrap record. This creates the style scrap record and uses it to store the character attribute information.
<LI>Save the character attribute information in the resource fork of the file.<P>
</OL>
 The application-defined procedure <CODE>MyDoSaveAsTextEdit</CODE> shown in <A HREF=#MARKER-9-286>Listing 2-14</A> uses this method. Notice that this procedure avoids using <CODE>TESetSelect</CODE> to select all of the edit record's text. The <CODE>TESetSelect</CODE> procedure sets and highlights the selection range that you specify. Because you are selecting the text to save it, you don't want it to be highlighted. (Highlighting the text before saving it can mislead a user to presume that some other action is required.)<P>
 However, if you want to use <A NAME=MARKER-2-49></A><CODE>TESetSelect</CODE>, you can circumvent highlighting of the selection range if you first render the edit record inactive; before you call <CODE>TESetSelect</CODE>, call <CODE>TEDeactivate</CODE>. Also, if you have outline highlighting turned on through the <CODE>TEFeatureFlag</CODE> function's <CODE>teFOutlineHilite</CODE> feature, turn it off. When the edit record is not the active one, <CODE>TESetSelect</CODE> can set the selection range without causing it to <A NAME=MARKER-2-55></A>be highlighted.<P>
<B>Listing 2-14  <A NAME=MARKER-9-286></A>Saving a multistyled text edit record to disk</B><P>
<PRE>
PROCEDURE MyDoSaveAsTextEdit(textToSave: TEHandle); 
      CONST
      kFileType    = 'TEXT'; {file type of text file}
      kFileCreator = 'NIIM'; {creator code of text file}
VAR
      reply: StandardFileReply; 
         {location, name of file to save text to}
      styles:    StScrpHandle; {contains all character }
                               { attributes in text}
      dataLength: LongInt; {number of bytes of text to write}
      dataRefNum: Integer; {ref number of text file's data fork}
      rsrcRefNum: Integer; {ref number of text file's rsrc fork}
      savedStart: Integer; {saves offset of start of selection}
      savedEnd:   Integer; {saves offset of end of selection}
      error:      OSErr;   {error code from toolbox}

BEGIN
   StandardPutFile( '', '', reply);
   IF reply.sfGood THEN
      BEGIN
      {save the current starting and ending offsets of selection}
         savedStart := textToSave^^.selStart;
         savedEnd := textToSave^^.selEnd;
      {select all text; don't use TESetSelect because it }
         { draws selection}
            textToSave^^.selStart := 0;
            textToSave^^.selEnd := textToSave^^.teLength;

      {get a list of all the attributes in the text}
            styles := TEGetStyleScrapHandle(textToSave);

      {reset the selection back to what it was}
            textToSave^^.selStart := savedStart;
            textToSave^^.selEnd := savedEnd;

      {create the text file if it didn't exist before}
            IF NOT reply.sfReplacing THEN
               BEGIN
                  error := FSpCreate(reply.sfFile, 
                        kFileCreator, kFileType, reply.sfScript);
                  FSpCreateResFile(reply.sfFile, kFileCreator,
                        kFileType, reply.sfScript);
                  error := ResError;
               END;
         {open the text file}
         error := FSpOpenDF(reply.sfFile, fsCurPerm, dataRefNum);
         rsrcRefNum := FSpOpenResFile(reply.sfFile, fsCurPerm);
         error := ResError;

         {write the text to the file}
         dataLength := textToSave^^.teLength;
         error := FSWrite(dataRefNum, dataLength, 
                           textToSave^^.hText^ );

         {Write the attributes to the file}
         AddResource(Handle(styles), 'styl', 0, '');
         WriteResource(Handle(styles));
         ReleaseResource(Handle(styles));

         {close the text file}
         error := FSClose(dataRefNum);
         CloseResFile(rsrcRefNum);
         error := ResError;
      END;
END;
</PRE>
<A NAME=HEADING54-15></A>
<H3><A NAME=MARKER-2-287></A>Restoring an Existing TextEdit Document</H3>
 You can restore the text of an edit record when a user opens a document that was created using TextEdit. One way to do this is to read the text from the data fork into a handle, then write the handle to the <CODE>hText</CODE> field of the edit record; call <CODE>TECalText</CODE> after you do this. Before you write the new handle to the <CODE>hText</CODE> field, dispose of the existing handle, if there is one. For a multistyled edit record, you need to reinstate both the text and the character attribute information for it. (For information about how to open a file, see <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I>.)<P>
 You can use a method similar to the one shown in <A HREF=#MARKER-9-286>Listing 2-14 on page 2-49</A> to save a multistyled text document. However, to restore the text, you retrieve the data from the file's data fork and write it to a buffer, then call <CODE>TESetText</CODE> to make a copy of the text and set the <CODE>hText</CODE> field of the edit record to point to it. The <CODE>MyDoOpenTextEdit</CODE> procedure shown in <A HREF=Text-180.html#MARKER-9-377>Listing 2-15</A> shows an example of this. Before copying the text to a buffer, the <CODE>MyDoOpenTextEdit</CODE> procedure checks to ensure that the text length does not exceed the 32 KB limit; if it does, TextEdit truncates the text before it copies it.<P>
 The <CODE>MyDoOpenTextEdit</CODE> procedure retrieves the character attribute informatio<A NAME=MARKER-2-68></A>n from the resource fork of the disk file and reinstates it in the edit record's style record by calling <A NAME=MARKER-2-71></A><CODE>TEUseStyleScrap</CODE>.<P>
<B>Listing 2-15  <A NAME=MARKER-9-377></A>Restoring a document that uses multistyled TextEdit</B><P>
<PRE>
PROCEDURE MyDoOpenTextEdit(textToOpen: TEHandle); 
   CONST
      kFileType = 'TEXT'; {file type of text file}

   VAR
      reply:      StandardFileReply; {location, name of file to get text from}
      typeList:   SFTypeList;    {specifies 'TEXT' files in SF dialog}
      dataRefNum: Integer;  {ref number of text file's data fork}
      rsrcRefNum: Integer;  {ref number of text file's rsrc fork}
      textBuffer: Handle;  {holds text from file}
      textLength: LongInt;  {number of bytes of text to read}
      styles:     StScrpHandle;  {contains all character attributes in text}
      error:      OSErr;      {error code from toolbox}
      savedState: SignedByte; {saves state of 'styl' resource}
BEGIN
   typeList[0] := kFileType;
   StandardGetFile(NIL, 1, typeList, reply);
   IF reply.sfGood THEN
      BEGIN
         {open the data fork of the text file}
         error := FSpOpenDF(reply.sfFile, fsCurPerm, dataRefNum);
         error := SetFPos(dataRefNum, fsFromStart, 0);
         {get the number of bytes of text in the file; limit to 32KB}
         error := GetEOF( dataRefNum, textLength );
         IF textLength &gt; 32767 THEN
            textLength := 32767;
         {allocate a buffer for the text}
         textBuffer := NewHandle(textLength);
         {read the text into the buffer}
         error := FSRead( dataRefNum, textLength, textBuffer^ );
         {put the text into the TextEdit record}
         LockHHi(TextBuffer); 
         TESetText(textBuffer^, textLength, textToOpen);
         HUnlock(textBuffer);
         {get rid of the text buffer}
         DisposeHandle(textBuffer);
         {close the data fork of the text file}
         error := FSClose(dataRefNum);
         {open the resource fork of the text file}
         rsrcRefNum := FSpOpenResFile(reply.sfFile, fsCurPerm);
         error := ResError;
         {get the style scrap}
         styles := StScrpHandle(GetResource('styl', 0));
         error := ResError;
         IF styles &lt;&gt; NIL THEN
            BEGIN
               savedState := HGetState(Handle(styles));
               {apply the character attributes to the TextEdit record}
               TEUseStyleScrap(0, textLength, styles, true, textToOpen);
               {restore state of 'styl' resource}
               HSetState(Handle(styles), savedState);
            END;
         {close the forks of the text file}
         error := FSClose(dataRefNum);
         CloseResFile(rsrcRefNum);
         error := ResError;
      END;
END;
</PRE>
<A NAME=HEADING54-22></A>
<H3><A NAME=MARKER-2-326></A>Handling Undo</H3>
 Application users find Undo an especially useful feature. Users might accidently choose Clear from the Edit menu instead of Cut, or they might backspace over more words than intended. In these and cases like them, Undo is invaluable.<P>
 If you are implementing Undo for multistyled text, you need to save the character attribute information along with the text. Although this section discusses one method, there are a number of ways that you can do this. For example, when you want to save the current attributes of the selected text to allow the user to revert to them, your application calls the <CODE>TEGetStyleScrapHandle</CODE> function, which returns a handle to the style scrap's style record containing the attributes used for the selected text. To restore the style later, you call the <CODE>TEUseStyleScrap</CODE> procedure. You also need to save the offsets into the edit record's text buffer of the first and last characters to which the character attribute information is to be applied.<P>
 If your application supports any 2-byte script systems, your Undo operations needs to check for 2-byte characters. Normal cut or paste operations do not present a problem, but be careful when undoing a backspace. When TextEdit backspaces over single characters, it checks <CODE>CharByte</CODE> to determine if the character to be removed is a 2-byte character. If it is, it removes 2 bytes. (For more information about the <CODE>CharByte</CODE> function, see the chapter the "Script Manager," in this book.) When an application program maintains a buffer of characters that have been backspaced over in order to support Undo, it needs to make a test similar to that in <A HREF=#MARKER-9-292>Listing 2-16</A>.<P>
<B>Listing 2-16  <A NAME=MARKER-9-292></A>Checking for 2-byte characters when backspacing</B><P>
<PRE>
IF myChar = BS then aTeHandle^^ do begin 
   {support backspace undo}
   IF selStart &lt;&gt; selEnd then begin 
   {not an insertion point save the selection}
   END
   ELSE begin
      i := selStart;
      IF i &gt; 0 then begin
            repeat i := i - 1
            until CharByte(hText^, i) &lt;= 0;
      {Note: Guarantees that CharByte(x,0) &lt;= 0}
      {Also, CharByte does not touch the heap}
      {Put bytes from i to selStart into buffer}
      END;
   END;
END;
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-53.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-55.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
