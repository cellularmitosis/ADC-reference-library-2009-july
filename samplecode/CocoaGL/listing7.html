<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Cocoa OpenGL - /GLCheck.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">Cocoa OpenGL</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Cocoa OpenGL</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/GLCheck.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AppDelegate.h</option>
<option value="listing2.html">/AppDelegate.m</option>
<option value="listing3.html">/BasicOpenGLView.h</option>
<option value="listing4.html">/BasicOpenGLView.m</option>
<option value="listing5.html">/drawInfo.h</option>
<option value="listing6.html">/drawInfo.m</option>
<option value="listing7.html">/GLCheck.c</option>
<option value="listing8.html">/GLCheck.h</option>
<option value="listing9.html">/GLString.h</option>
<option value="listing10.html">/GLString.m</option>
<option value="listing11.html">/main.m</option>
<option value="listing12.html">/trackball.c</option>
<option value="listing13.html">/trackball.h</option></select>
				</p>
				</form>
				<p><strong><a href="CocoaGL.zip">Download Sample</a></strong> (&#147;CocoaGL.zip&#148;, 467.6K)<BR>
<strong><a href="CocoaGL.dmg">Download Sample</a></strong> (&#147;CocoaGL.dmg&#148;, 526.9K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//
// File:    GLCheck.c
//        (Originally glCheck.c)
//
// Abstract:  glcheck allows developer to check the hardware capabilities of all GPU's
//        returning an array of records reflecting the attached hardware. This
//        list can be regenerated on Display Manager notifications to keep the
//        client update to on capabilities and setup changes.  This is provided as
//        sample to allow developers the freedom to check as few or as many
//        conditions and capabilities as they would like or add their own checks
//
// Version:    1.1 - Removed QD dependencies, list of extensions
//        1.0 - Original release.
//        
//
// Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Inc. (&quot;Apple&quot;)
//        in consideration of your agreement to the following terms, and your use,
//        installation, modification or redistribution of this Apple software
//        constitutes acceptance of these terms.  If you do not agree with these
//        terms, please do not use, install, modify or redistribute this Apple
//        software.
//
//        In consideration of your agreement to abide by the following terms, and
//        subject to these terms, Apple grants you a personal, non - exclusive
//        license, under Apple's copyrights in this original Apple software ( the
//        &quot;Apple Software&quot; ), to use, reproduce, modify and redistribute the Apple
//        Software, with or without modifications, in source and / or binary forms;
//        provided that if you redistribute the Apple Software in its entirety and
//        without modifications, you must retain this notice and the following text
//        and disclaimers in all such redistributions of the Apple Software. Neither
//        the name, trademarks, service marks or logos of Apple Inc. may be used to
//        endorse or promote products derived from the Apple Software without specific
//        prior written permission from Apple.  Except as expressly stated in this
//        notice, no other rights or licenses, express or implied, are granted by
//        Apple herein, including but not limited to any patent rights that may be
//        infringed by your derivative works or by other works in which the Apple
//        Software may be incorporated.
//
//        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
//        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
//        WARRANTIES OF NON - INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
//        PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION
//        ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//
//        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
//        CONSEQUENTIAL DAMAGES ( INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//        SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//        INTERRUPTION ) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION
//        AND / OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER
//        UNDER THEORY OF CONTRACT, TORT ( INCLUDING NEGLIGENCE ), STRICT LIABILITY OR
//        OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright ( C ) 2003-2007 Apple Inc. All Rights Reserved.
//

// see glcheck.h for more explanation on the use of CheckOpenGLCaps and it's associated data

 
#include &quot;GLCheck.h&quot;

#include &lt;OpenGL/OpenGL.h&gt;
#include &lt;OpenGL/gl.h&gt;
#include &lt;OpenGL/glu.h&gt;
#include &lt;OpenGL/glext.h&gt;

#include &lt;string.h&gt;

// -------------------------

// local CF dictionary routines

static long _getDictLong (CFDictionaryRef refDict, CFStringRef key)
{
  long int_value;
  CFNumberRef num_value = (CFNumberRef)CFDictionaryGetValue(refDict, key);
  if (!num_value) // if can't get a number for the dictionary
    return -1;  // fail
  // or if cant convert it
  if (!CFNumberGetValue(num_value, kCFNumberLongType, &amp;int_value)) 
    return -1; // fail
  return int_value; // otherwise return the long value
}

static double _getDictDouble (CFDictionaryRef refDict, CFStringRef key)
{
  double double_value;
  CFNumberRef num_value = (CFNumberRef)CFDictionaryGetValue(refDict, key);
  if (!num_value) // if can't get a number for the dictionary
    return -1;  // fail
  // or if cant convert it
  if (!CFNumberGetValue(num_value, kCFNumberDoubleType, &amp;double_value)) 
    return -1; // fail
  return double_value; // otherwise return the long value
}

// -------------------------

// this does a reasonable check to see if things have changed without being 
// too heavy weight; returns 1 if changed 0 if not
// checks num displays, displayID, displayMask, each display geometry and 
// renderer VRAM and ID

unsigned char HaveOpenGLCapsChanged (GLCaps aDisplayCaps[], 
                                     CGDisplayCount dspyCnt)
{
  CGDisplayCount maxDisplays = 32;
  CGDirectDisplayID activeDspys[32];
  CGDisplayErr theError;
  short i;
  CGDisplayCount newDspyCnt = 0;
  
  if (NULL == aDisplayCaps) return 1;

  theError = CGGetActiveDisplayList(maxDisplays, activeDspys, &amp;newDspyCnt);
  // if theError getting list mark as changed
  if (theError) return 1; 
  // if number of displays not equal
  if (dspyCnt != newDspyCnt) return 1;
  
  for (i = 0; i &lt; dspyCnt; i++) {
    // get device ids
    if (aDisplayCaps[i].cgDisplayID != activeDspys[i]) return 1;
    if (aDisplayCaps[i].cglDisplayMask !=  
        CGDisplayIDToOpenGLDisplayMask(activeDspys[i])) return 1;
 
    // get current geometry
    {
      CGRect displayRect = CGDisplayBounds (activeDspys[i]);
      // get mode dictionary
      CFDictionaryRef dispMode = CGDisplayCurrentMode (activeDspys[i]);
      // check for all geometry matches 
      if (aDisplayCaps[i].deviceWidth != (long) displayRect.size.width)
        return 1;   
      if (aDisplayCaps[i].deviceHeight != (long) displayRect.size.height) 
        return 1;   
      if (aDisplayCaps[i].deviceOriginX != (long) displayRect.origin.x) 
        return 1;   
      if (aDisplayCaps[i].deviceOriginY != (long) displayRect.origin.y) 
        return 1;   
      if (aDisplayCaps[i].deviceDepth != 
                 (short) _getDictLong (dispMode,  kCGDisplayBitsPerPixel)) 
        return 1;    
      if (aDisplayCaps[i].deviceRefresh != 
          (short)(_getDictDouble (dispMode, kCGDisplayRefreshRate) + 0.5)) 
        return 1; // round to GLint
    }

    // get renderer info based on gDevice
    {
      CGLRendererInfoObj info;
      long j, numRenderers = 0, rv = 0;
      CGLError theErr = 0;
      long deviceVRAM; // video memory in bytes
      unsigned long rendererID; // renderer ID
      
      theErr = CGLQueryRendererInfo (aDisplayCaps[i].cglDisplayMask, 
                                  &amp;info, &amp;numRenderers);
      if(0 == theErr) {
        CGLDescribeRenderer (info, 0, kCGLRPRendererCount, &amp;numRenderers);
        for (j = 0; j &lt; numRenderers; j++) {
          // find accelerated renderer (assume only one)
          CGLDescribeRenderer (info, j, kCGLRPAccelerated, &amp;rv); 
          if (true == rv) { // if accelerated
            // what is the renderer ID
            CGLDescribeRenderer (info, j, kCGLRPRendererID, (long *)&amp;rendererID); 
            if (rendererID != aDisplayCaps[i].rendererID) // check match
              return 1;
            // what is the VRAM
            CGLDescribeRenderer (info, j, kCGLRPVideoMemory, &amp;deviceVRAM); 
            if (deviceVRAM != aDisplayCaps[i].deviceVRAM) // check match
              return 1;
            break; // done
          }
        }
      }
      CGLDestroyRendererInfo (info);
    }
  }
  return 0;
}

// -------------------------

// This will walk all active displays and gather information about their
// hardware renderer 

// An array length (maxDisplays) and array of GLCaps are passed in. Up to
// maxDisplays of the array are filled in with the displays meeting the
// specified criteria.  The actual number of displays filled in is returned
// in dspyCnt.  Calling this function with maxDisplays of 0 will just
// return the number of displays in dspyCnt.

// Developers should note this is NOT an exhaustive list of all the
// capabilities one could query, nor a required set of capabilities,
// feel free to add or subtract queries as you find helpful for your 
// application/use.

// one note on mirrored displays... if the display configuration is 
// changed it is possible (and likely) that the current active display
// in a mirrored configuration (as identified by the OpenGL Display Mask)
// will change if the mirrored display is removed.  
// This is due to the preference of selection the external display as 
// the active display.  This may affect full screen apps which should 
// always detect display configuration changes and respond accordingly.

void CheckOpenGLCaps (CGDisplayCount maxDspys, 
                      GLCaps dCaps[], 
                      CGDisplayCount * dCnt)
{
  CGLContextObj curr_ctx = 0;
  CGDirectDisplayID dspys[32];
  CGDisplayErr theErr;
  short i;
  short size = sizeof (GLCaps);
  
  // no devices
  *dCnt = 0;
  
  if (maxDspys == 0) { // find number of displays
    *dCnt = 0;
    theErr = CGGetActiveDisplayList (32, dspys, dCnt);
    if (theErr) // theErr getting list
      *dCnt = 0; // 0 displays since can't correctly find any
    // zero list to ensure the routines are used correctly
    memset (dspys, 0, sizeof (CGDirectDisplayID) * *dCnt);
    return; // return dCnt
  }
  if (NULL == dCaps) return;

  theErr = CGGetActiveDisplayList(maxDspys, dspys, dCnt);
  if (theErr) return; // theErr getting list
  if (0 == *dCnt) return; // no displays
  
  memset (dCaps, 0, size * *dCnt); // zero memory
  
  for (i = 0; i &lt; *dCnt; i++) {
    // get device ids
    dCaps[i].cgDisplayID = dspys[i];
    dCaps[i].cglDisplayMask = CGDisplayIDToOpenGLDisplayMask(dspys[i]);
    
    { // get current geometry
      CGRect displayRect = CGDisplayBounds (dspys[i]);
      // get mode dictionary
      CFDictionaryRef dispMode = CGDisplayCurrentMode (dspys[i]); 
      dCaps[i].deviceWidth = (long) displayRect.size.width;   
      dCaps[i].deviceHeight = (long) displayRect.size.height;   
      dCaps[i].deviceOriginX = (long) displayRect.origin.x;   
      dCaps[i].deviceOriginY = (long) displayRect.origin.y;   
      dCaps[i].deviceDepth = (short) _getDictLong (dispMode,  
                                              kCGDisplayBitsPerPixel);    
      dCaps[i].deviceRefresh = (short) (_getDictDouble (dispMode,
                                        kCGDisplayRefreshRate) + 0.5); 
    }    

    { // get renderer info based on gDevice
      CGLRendererInfoObj info;
      long j, numRenderers = 0, rv = 0;
      CGLError theErr2 = 0;
      
      theErr2 = CGLQueryRendererInfo (dCaps[i].cglDisplayMask, 
                                  &amp;info, 
                                  &amp;numRenderers);
      if(0 == theErr2) {
        CGLDescribeRenderer (info, 0, kCGLRPRendererCount, &amp;numRenderers);
        for (j = 0; j &lt; numRenderers; j++) {
          // find accelerated renderer (assume only one)
          CGLDescribeRenderer (info, j, kCGLRPAccelerated, &amp;rv); 
          if (true == rv) { // if accelerated
            // what is the renderer ID
            CGLDescribeRenderer (info, j, kCGLRPRendererID,
                                 &amp;dCaps[i].rendererID);
            // can we do full screen?
            CGLDescribeRenderer (info, j, kCGLRPFullScreen, &amp;rv); 
            dCaps[i].fullScreenCapable = (bool) rv;
            // what is the VRAM?
            CGLDescribeRenderer (info, j, kCGLRPVideoMemory,
                                 &amp;dCaps[i].deviceVRAM);
            // what is the current texture memory? 
            CGLDescribeRenderer (info, j, kCGLRPTextureMemory,
                                 &amp;dCaps[i].deviceTextureRAM);
            break; // done
          }
        }
      }
      CGLDestroyRendererInfo (info);
    }

    { // build context and context specific info
      CGLPixelFormatAttribute attribs[] = { kCGLPFADisplayMask,
                                            dCaps[i].cglDisplayMask, 
                                            (CGLPixelFormatAttribute)0 };
      CGLPixelFormatObj pixelFormat = NULL;
      long numPixelFormats = 0;
      CGLContextObj cglContext;
      
      curr_ctx = CGLGetCurrentContext (); // get current CGL context
      CGLChoosePixelFormat (attribs, &amp;pixelFormat, &amp;numPixelFormats);
      if (pixelFormat) {
        CGLCreateContext(pixelFormat, NULL, &amp;cglContext);
        CGLDestroyPixelFormat (pixelFormat);
        CGLSetCurrentContext (cglContext);
        if (cglContext) {
          const GLubyte * strExt;
          const GLubyte * strRend;
          const GLubyte * strVers;
          const GLubyte * strVend;

          // get renderer strings
          strRend = glGetString (GL_RENDERER);
          strncpy (dCaps[i].strRendererName, (char *) strRend, 255);
          strVend = glGetString (GL_VENDOR);
          strncpy (dCaps[i].strRendererVendor, (char *) strVend, 255);
          strVers = glGetString (GL_VERSION);
          strncpy (dCaps[i].strRendererVersion, (char *) strVers, 255);
          { // get BCD version
            short j = 0;
            short shiftVal = 8;
            while (((strVers[j] &lt;= '9') &amp;&amp; (strVers[j] &gt;= '0')) ||
                                            (strVers[j] == '.')) { 
            // get only basic version info (until first non-digit or non-.)
              if ((strVers[j] &lt;= '9') &amp;&amp; (strVers[j] &gt;= '0')) {
                dCaps[i].glVersion += (strVers[j] - '0') &lt;&lt; shiftVal;
                shiftVal -= 4;
              }
              j++;
            }
          }
          strExt = glGetString (GL_EXTENSIONS);

          // get caps
          glGetIntegerv (GL_MAX_TEXTURE_UNITS, 
                         &amp;dCaps[i].textureUnits);
          glGetIntegerv (GL_MAX_TEXTURE_SIZE,
                         &amp;dCaps[i].maxTextureSize); 
          glGetIntegerv (GL_MAX_3D_TEXTURE_SIZE, 
                         &amp;dCaps[i].max3DTextureSize);
          glGetIntegerv (GL_MAX_CUBE_MAP_TEXTURE_SIZE, 
                         &amp;dCaps[i].maxCubeMapTextureSize);

          // get functionality info
      dCaps[i].fSpecularVector = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_specular_vector&quot;, strExt);
          dCaps[i].fTransformHint = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_transform_hint&quot;, strExt);
          dCaps[i].fPackedPixels = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_packed_pixels&quot;, strExt) || 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_packed_pixel&quot;, strExt)  || 
        (dCaps[i].glVersion &gt;= 0x0120);
          dCaps[i].fClientStorage = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_client_storage&quot;, strExt);
          dCaps[i].fYCbCr = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_ycbcr_422&quot;, strExt);
          dCaps[i].fTextureRange = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_texture_range&quot;, strExt);
          dCaps[i].fFence = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_fence&quot;, strExt);
          dCaps[i].fVAR = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_vertex_array_range&quot;, strExt);
          dCaps[i].fVAO = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_vertex_array_object&quot;, strExt);
          dCaps[i].fElementArray = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_element_array&quot;, strExt);
          dCaps[i].fVPEvals = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_vertex_program_evaluators&quot;,strExt);
          dCaps[i].fFloatPixels = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_float_pixels&quot;, strExt);
          dCaps[i].fFlushRenderer = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_flush_render&quot;, strExt);
          dCaps[i].fPixelBuffer = 
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_pixel_buffer&quot;, strExt);
          dCaps[i].fImaging = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fTransposeMatrix = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_transpose_matrix&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fMultitexture = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_multitexture&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fTexEnvAdd = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_texture_env_add&quot;, strExt) ||
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_texture_env_add&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fTexEnvCombine = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_texture_env_combine&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fTexEnvDot3 = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_texture_env_dot3&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fTexEnvCrossbar = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_texture_env_crossbar&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fTexCubeMap = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_texture_cube_map&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fTexCompress = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_texture_compression&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fMultisample = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_multisample&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fTexBorderClamp = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_texture_border_clamp&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fPointParam = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_point_parameters&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fVertexProg = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_vertex_program&quot;, strExt);
          dCaps[i].fFragmentProg = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_fragment_program&quot;, strExt);
          dCaps[i].fTexMirrorRepeat = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_texture_mirrored_repeat&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fDepthTex = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_depth_texture&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fShadow = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_shadow&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fShadowAmbient = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_shadow_ambient&quot;, strExt);
          dCaps[i].fVertexBlend = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_vertex_blend&quot;, strExt);
          dCaps[i].fWindowPos = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_window_pos&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fTex3D = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_texture3D&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0120);
          dCaps[i].fClipVolHint = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_clip_volume_hint&quot;, strExt);
          dCaps[i].fRescaleNorm = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_rescale_normal&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0120);
          dCaps[i].fBlendColor = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_blend_color&quot;, strExt) ||
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fBlendMinMax = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_blend_minmax&quot;, strExt) ||
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fBlendSub = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_blend_subtract&quot;, strExt) ||
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fCVA = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_compiled_vertex_array&quot;, strExt);
          dCaps[i].fTexLODBias = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_texture_lod_bias&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fABGR = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_abgr&quot;, strExt);
          dCaps[i].fBGRA = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_bgra&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0120);
          dCaps[i].fTexFilterAniso = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_texture_filter_anisotropic&quot;,strExt);
          dCaps[i].fPaletteTex = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_paletted_texture&quot;, strExt);
          dCaps[i].fShareTexPalette = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_shared_texture_palette&quot;, strExt);
          dCaps[i].fSecColor = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_secondary_color&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fTexCompressS3TC = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_texture_compression_s3tc&quot;, strExt);
          dCaps[i].fTexRect = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_texture_rectangle&quot;, strExt);
          dCaps[i].fFogCoord = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_fog_coord&quot;, strExt);
          dCaps[i].fDrawRangeElements = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_draw_range_elements&quot;, strExt);
          dCaps[i].fStencilWrap = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_stencil_wrap&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fBlendFuncSep = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_blend_func_separate&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fMultiDrawArrays = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_multi_draw_arrays&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fShadowFunc = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_shadow_funcs&quot;, strExt);
          dCaps[i].fStencil2Side = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_stencil_two_side&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fColorSubtable = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_color_subtable&quot;, strExt) || 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fConvolution = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_convolution&quot;, strExt) || 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fHistogram = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_histogram&quot;, strExt) || 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fColorTable = 
        gluCheckExtension ((const GLubyte *) &quot;GL_SGI_color_table&quot;, strExt) || 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fColorMatrix = 
        gluCheckExtension ((const GLubyte *) &quot;GL_SGI_color_matrix&quot;, strExt) || 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fTexEdgeClamp = 
        gluCheckExtension ((const GLubyte *) &quot;GL_SGIS_texture_edge_clamp&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0120);
          dCaps[i].fGenMipmap = 
        gluCheckExtension ((const GLubyte *) &quot;GL_SGIS_generate_mipmap&quot;, strExt);
          dCaps[i].fTexLOD = 
        gluCheckExtension ((const GLubyte *) &quot;GL_SGIS_texture_lod&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0120);
          dCaps[i].fPointCull = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ATI_point_cull_mode&quot;, strExt);
          dCaps[i].fTexMirrorOnce = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ATI_texture_mirror_once&quot;, strExt);
          dCaps[i].fPNtriangles = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ATI_pn_triangles&quot;, strExt) ||
        gluCheckExtension ((const GLubyte *) &quot;GL_ATIX_pn_triangles&quot;, strExt);
          dCaps[i].fTextFragShader = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ATI_text_fragment_shader&quot;, strExt);
          dCaps[i].fATIBlendEqSep = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ATI_blend_equation_separate&quot;, strExt);
          dCaps[i].fBlendWeightMinMax = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ATI_blend_weighted_minmax&quot;, strExt);
          dCaps[i].fCombine3 = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ATI_texture_env_combine3&quot;, strExt);
          dCaps[i].fSepStencil = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ATI_separate_stencil&quot;, strExt);
          dCaps[i].fArrayRevComps4Byte = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ATI_array_rev_comps_in_4_bytes&quot;,strExt);
          dCaps[i].fNVPointSprite = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_point_sprite&quot;, strExt);
          dCaps[i].fRegCombiners = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_register_combiners&quot;, strExt);
          dCaps[i].fRegCombiners2 = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_register_combiners2&quot;, strExt);
          dCaps[i].fTexEnvCombine4 = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_texture_env_combine4&quot;, strExt);
          dCaps[i].fBlendSquare = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_blend_square&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fFogDist = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_fog_distance&quot;, strExt);
          dCaps[i].fMultisampleFilterHint = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_multisample_filter_hint&quot;, strExt);
          dCaps[i].fTexGenReflect = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_texgen_reflection&quot;, strExt);
          dCaps[i].fTexShader = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_texture_shader&quot;, strExt);
          dCaps[i].fTexShader2 = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_texture_shader2&quot;, strExt);
          dCaps[i].fTexShader3 = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_texture_shader3&quot;, strExt);
          dCaps[i].fDepthClamp = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_depth_clamp&quot;, strExt);
          dCaps[i].fLightMaxExp = 
        gluCheckExtension ((const GLubyte *) &quot;GL_NV_light_max_exponent&quot;, strExt);
          dCaps[i].fRasterPosClip = 
        gluCheckExtension ((const GLubyte *) &quot;GL_IBM_rasterpos_clip&quot;, strExt);
          dCaps[i].fConvBorderModes = 
        gluCheckExtension ((const GLubyte *) &quot;GL_HP_convolution_border_modes&quot;, strExt) ||
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_imaging&quot;, strExt);
      dCaps[i].fAuxDeptStencil =
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_aux_depth_stencil&quot;, strExt);
      dCaps[i].fFlushBufferRange =
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_flush_buffer_range&quot;, strExt);
      dCaps[i].fObjectPurgeable =
        gluCheckExtension ((const GLubyte *) &quot;GL_APPLE_object_purgeable&quot;, strExt);
      dCaps[i].fDrawBuffers =
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_draw_buffers&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0200);
      dCaps[i].fFragmentProgShadow =
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_fragment_program_shadow&quot;, strExt);
      dCaps[i].fFragmentShader = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_fragment_shader&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0200);
      dCaps[i].fHalfFloatPixel = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_half_float_pixel&quot;, strExt);
      dCaps[i].fOcclusionQuery = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_occlusion_query&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0150);
      dCaps[i].fPBO = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_pixel_buffer_object&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0210);
      dCaps[i].fPointSprite =       
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_point_sprite&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0200);
      dCaps[i].fShaderObjects = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_shader_objects&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0200);
      dCaps[i].fShaderTextureLOD = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_shader_texture_lod&quot;, strExt);
      dCaps[i].fShadingLanguage100 =
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_shading_language_100&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0200);
      dCaps[i].fTexFloat =
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_texture_float&quot;, strExt);
      dCaps[i].fTexNPOT = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_texture_non_power_of_two&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0200);
      dCaps[i].fVBO = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_vertex_buffer_object&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0150);
      dCaps[i].fVertexShader = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ARB_vertex_shader&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0200);
      dCaps[i].fTexComp3dc = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ATI_texture_compression_3dc&quot;, strExt);
      dCaps[i].fTexATIfloat = 
        gluCheckExtension ((const GLubyte *) &quot;GL_ATI_texture_float&quot;, strExt);
      dCaps[i].fBlendEqSep = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_blend_equation_separate&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0200);
      dCaps[i].fDepthBounds = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_depth_bounds_test&quot;, strExt);
      dCaps[i].fFBOblit =
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_framebuffer_blit&quot;, strExt);
      dCaps[i].fFBO = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_framebuffer_object&quot;, strExt);
      dCaps[i].fGeometryShader4 = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_geometry_shader4&quot;, strExt);
      dCaps[i].fGPUProgParams = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_gpu_program_parameters&quot;, strExt);
      dCaps[i].fGPUShader4 = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_gpu_shader4&quot;, strExt);
      dCaps[i].fDepthStencil = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_packed_depth_stencil&quot;, strExt);
      dCaps[i].fSepSpecColor = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_separate_specular_color&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0120);
      dCaps[i].fTexCompDXT1 =
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_texture_compression_dxt1&quot;, strExt);
      dCaps[i].fTexMirrorClamp = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_texture_mirror_clamp&quot;, strExt);
      dCaps[i].fTexSRGB = 
        gluCheckExtension ((const GLubyte *) &quot;GL_EXT_texture_sRGB&quot;, strExt) ||
        (dCaps[i].glVersion &gt;= 0x0210);      
      
      if (dCaps[i].fTexRect) // only check if extension supported
        glGetIntegerv (GL_MAX_RECTANGLE_TEXTURE_SIZE_EXT,
                 &amp;dCaps[i].maxRectTextureSize);
      else
        dCaps[i].maxRectTextureSize = 0;
      
          CGLDestroyContext (cglContext);
        }
      }
      CGLSetCurrentContext (curr_ctx); // reset current CGL context
    }
  }
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/CocoaGL/listing7.html%3Fid%3DDTS10004501-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/CocoaGL/listing7.html%3Fid%3DDTS10004501-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/CocoaGL/listing7.html%3Fid%3DDTS10004501-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>