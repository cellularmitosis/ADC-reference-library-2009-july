<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Shark User Guide: Time Profiling</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Time Profiling"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005233-CH3" title="Time Profiling"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../Performance-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000901" target="_top">Performance</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40005233-CH1-DontLinkElementID_6">Shark User Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../GettingStartedwithShark/GettingStartedwithShark.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../SystemTracing/SystemTracing.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005233-CH3-SW1" title="Time Profiling"></a><h1>Time Profiling</h1><p>The first and most frequently used Shark configuration is the <em>Time Profile</em>.  This produces a statistical sampling of the program’s or system’s execution by recording a new sample every time that a timer interrupt occurs, at a user-specified frequency (1 KHz, for 1ms sampling intervals, by default). At each interrupt, Shark records a few key facts about the state of each processor for later analysis:  the process and thread ID of the executing process, the program counter, and the callstack of the routine that was executing. From this sampled information, Shark reconstructs exactly what code from which functions was executing as samples were taken.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW25">Statistical Sampling</a>
				
			<br/>
			
        
			
			
				<a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW23">Taking a Time Profile</a>
				
			<br/>
			
        
			
			
				<a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW19">Profile Browser</a>
				
			<br/>
			
        
			
			
				<a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW21">Chart View</a>
				
			<br/>
			
        
			
			
				<a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW20">Code Browser</a>
				
			<br/>
			
        
			
			
				<a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW34">Tips and Tricks</a>
				
			<br/>
			
        
			
			
				<a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW35">Example: Optimizing MPEG-2 using Time Profiles</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005233-CH3-SW25" title="Statistical Sampling"></a><h2>Statistical Sampling</h2><p>This sampling process provides an approximate view of what is executing on the system. <span class="content_text">Figure 2-1</span> shows the worst case of an application with a sample interval greater than the lifespan of typical function calls, while <span class="content_text">Figure 2-2</span> shows the corresponding statistical sample, after post processing. In the first interval (marked #1),  sampling correctly identifies long-running routines executing in the sample interval. However, when encountering short functions, two effects are seen because execution time is attributed to functions only at the granularity of the sampling rate:</p><ul class="ul"><li class="li"><p>As seen in the third sample (marked #2), short-lived function calls can be missed entirely, so they are underrepresented in the samples.</p></li><li class="li"><p>In contrast, when brief functions occur right on the sample points, as illustrated in the seventh sample (marked #3), they are recorded as taking an entire time quantum and hence overrepresented in the samples.</p></li></ul><p>Luckily, over a large number of samples these errors average out in most cases, producing a collection of samples that fairly accurately represent the actual time spent executing each function in the application. In the example from <span class="content_text">Figure 2-1</span> and <span class="content_text">Figure 2-2</span>, the rare occasions when the small subroutine <code>bar()</code> is measured as taking an entire time quantum balances out the numerous times that it is missed entirely, providing a fairly accurate measurement of the time spent executing the routine overall. As a result, execution time measurements for the most critical routines, where the program spends most of its time executing, are generally very good.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW17" title="Figure 2-1Execution Before Sampling"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>Execution Before Sampling</p><img src = "../Art/sampling_IVa.jpg" alt = "Execution Before Sampling" ></div><br/><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW18" title="Figure 2-2Sampling Results"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>Sampling Results</p><img src = "../Art/sampling_IVb.jpg" alt = "Sampling Results" ></div><br/><p>In exchange for this inevitable measurement error, statistical sampling incurs very little overhead as it takes measurements, typically less than 2% with default settings. A major problem with performance-measuring tools is that the tool often affects the very performance it attempts to measure. The profiling tool requires a certain amount of processor time, system RAM, cache memory footprint, and other limited system resources in order to function. Inevitably, “stealing” these resources from the measured process adds artificial overhead to the program under test, sometimes skewing the performance measurements.</p><p>Statistical sampling minimizes this impact in two key ways. First, samples are taken at a relatively low frequency when compared with most event-monitoring mechanisms. The sampling mechanism's low intervention rate consumes only a small amount of processor time and memory, thereby minimizing the risk of skewed results. Second, and more subtly, samples can occur <em>anytime</em> during the execution of the program; side effects of the sampling mechanism are spread out to affect most areas of measured execution more or less equally. In contrast, most event counting-based mechanisms, such as function or basic block counting, record data at preset code locations, and therefore distort performance more near the preset sample points than elsewhere.</p><p>Statistical sampling provides helpful information about what executes most frequently, down to the level of individual assembly-language instructions, without the additional overhead required for an event-based profile at the instruction level. After sampling has ended, Shark correlates samples with the original binary to determine which assembly-language instructions or lines of original source code were executing when each interrupt occurred. Shark then accumulates results across samples, determining which individual lines of code were executing most often. In contrast, the overhead from adding the necessary code to profile at this level of detail in a non-statistical way would distort the results enough to render them virtually useless.</p><a name="//apple_ref/doc/uid/TP40005233-CH3-SW23" title="Taking a Time Profile"></a><h2>Taking a Time Profile</h2><p>Recording a <em>Time Profile</em> is generally very simple. Just use the general session-capture instructions presented in the previous chapter with the <em>Time Profile</em> configuration selected, and you will capture one. Because <em>Time Profile</em> is usually the default configuration, recording a session can be a matter of just starting Shark and pressing the “Start” button. Using the process selection menu, you may choose between capturing samples from just one process, or of the entire system at once. The former mode is usually better for analyzing most standalone applications, while the latter is better for seeing how applications interact.</p><p>If you need more control over the sampling behavior, the mini-configuration editor (<span class="content_text">Figure 2-3</span>) contains the most common options. The list is reasonably short:</p><ol class="ol"><li class="li"><p><strong>Windowed Time Facility</strong>— If enabled, Shark will collect samples until you explicitly stop it. However, it will only store the last N samples, where N is the number entered into the sample history field (10,000 by default). This mode is also described in <span class="content_text"><a href="../SelectingExecutiontoSampleorTrace/SelectingExecutiontoSampleorTrace.html#//apple_ref/doc/uid/TP40005233-CH13-SW1">“Windowed Time Facility (WTF).”</a></span></p></li><li class="li"><p><strong>Start Delay</strong>— Amount of time to wait after the user selects “Start” before data collection actually begins. This helps prevent Shark from sampling itself after you press “Start.”</p></li><li class="li"><p><strong>Sample Interval</strong>— Enter a sampling period here to determine the sampling rate. The interval is 1 ms by default.</p></li><li class="li"><p><strong>Time Limit</strong>— The maximum amount of time to record samples. This is ignored if WTF mode is enabled or if the sampling rate is high enough that the <em>Sample Limit</em> is reached first.</p></li><li class="li"><p><strong>Sample Limit </strong>— The maximum number of samples to record. Specifying a maximum of <em>N</em> samples will result in at most <em>N</em> samples being taken, even on a multi-processor system, so this should be scaled up as larger systems are sampled. When the sample limit is reached, data collection automatically stops. With the <em>Windowed Time Facility</em> mode, its sample history field replaces this one, and if the <em>Time Limit</em> is very small it may be reached first.</p></li></ol><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW16" title="Figure 2-3Time Profile mini-configuration editor"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>Time Profile mini-configuration editor</p><img src = "../Art/Time_miniconfig.jpg" alt = "Time Profile mini-configuration editor" ></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP40005233-CH3-DontLinkElementID_22" title="Note on short sample intervals"></a><p><strong>Note on short sample intervals:</strong>&nbsp;Shark will let you decrease the sample interval significantly, to a minimum of 20µs, but the very high sampling rates that result from these very short intervals are not recommended for most work, for several reasons. First, Shark will have a significant impact on system performance, since it needs some processor time when every sample is taken. Second, sample interval timing may be more erratic, because the inevitable sample timing error caused by interrupt response timing will be a larger percentage of each sample time. Finally, Shark may require significant amounts of memory to record the large number of samples that can quickly accumulate with short-interval sampling, adding significant memory pressure on systems with smaller amounts of main memory.</p></div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW19" title="Profile Browser"></a><h2>Profile Browser</h2><p>After you record a <em>Time Profile</em> session, Shark displays the a summary of the samples from the dominant process in a tabular form called a <em>Profile Browser</em>. An example is shown in <span class="content_text">Figure 2-6</span>. Samples are grouped (usually by symbol), and the groups with the most samples are listed first. This ordering is known as the “Heavy” view, and is described further below in <span class="content_text"><a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW14">“Heavy View.”</a></span> This view can be modified using the <em>View</em> popup menu (#8), if you would rather see the “Tree” view, which is described in <span class="content_text"><a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW15">“Tree View”</a></span> and organizes the sample groups according to the program’s callgraph tree, or “Heavy and Tree” view, which splits the window and shows both simultaneously.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW26" title="Figure 2-4The Profile Browser"></a><p><strong>Figure 2-4&nbsp;&nbsp;</strong>The Profile Browser</p><img src = "../Art/TimeProfile.jpg" alt = "The Profile Browser" ></div><br/><p>The window consists of several main parts:</p><ol class="ol"><li class="li"><p><strong>Pane Tabs</strong>— These tabs let you select to view your samples using this pane, the Chart view (see <span class="content_text"><a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW21">“Chart View ”</a></span>), or from among one or more Code Browsers (see <span class="content_text"><a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW20">“Code Browser”</a></span>).</p></li><li class="li"><p><strong>Results Table Column Headers</strong>— Click on any column title to select it, causing the rows to be sorted based on the contents of that column. You will usually want to sort by the “Self” or “Total” columns in this window. You can also select ascending or descending sort order using the direction triangle that appears at the right end of the selected header.</p></li><li class="li"><p><strong>Results Table</strong>— The results table summarizes your samples in a simple, tabular form. User space code is normally listed in black text while supervisor code (typically the Mac OS X kernel or driver code) is listed in dark red text. However, this color scheme can be adjusted using the <em>Advanced Settings</em>, described below in <span class="content_text"><a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW22">“Profile Display Preferences.”</a></span></p><p>The <em>Edit→Find→Find</em> command (<em>Command-F</em>) and the related <em>Edit→Find→Find Next</em> (<em>Command-G</em>) and <em>Edit→Find→Find Previous</em> (<em>Command-Shift-G</em>) commands are very useful when you are searching for particular entries in a profile browser listing many symbols. Simply type the desired library or symbol name into the <em>Find...</em> dialog box, and Shark will automatically find and highlight the next instance of that library or symbol.</p><p>The table consists of five columns:</p><ol class="ol"><li class="ol ol"><p><em>Code Tuning Advice</em>— When possible, Shark points out performance bottlenecks and problems. The availability of code tuning advice is shown by a <img src = "../Art/exclamation_point.gif" alt = "Exclamation Point Button" width="20" height="14"> button in the <em>Results Table</em>. Click on the button to display the tuning advice in a text bubble, as shown in <span class="content_text">“ISA Reference Window.”</span></p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH3-SW27" title="Figure 2-5Tuning Advice"></a><p><strong>Figure 2-5&nbsp;&nbsp;</strong>Tuning Advice</p><img src = "../Art/CalloutView.jpg" alt = "Tuning Advice" ></div></li><li class="ol ol"><p><em>Self</em>— The percentage of samples falling within this granule (i.e. symbol) <em>only</em>. Sorting on this column is a good way to locate the functions that were actively executing the most, and as a result is a good choice for use with the bottom-up “Heavy” view. By double-clicking on this, you can view the raw number of samples for each row in the table.</p></li><li class="ol ol"><p><em>Total</em>— In the “Heavy” view, this column lists the portion of each leaf entry’s time that passes through the given function (at the root level, therefore, it is equal to the <em>Self</em> column). In the “Tree” view this column lists the percentage of samples that landed in the given granule or anything called by it (self plus descendants or “children”). Sorting on this column is a good way to locate the top of callstack trees rapidly, and as a result is a good choice for use with the top-down “Tree” view. By double-clicking on this, you can view the raw number of samples for each row in the table.</p></li><li class="ol ol"><p><em>Library</em>— The name of the library (binary file) where the code of the sampled symbol is located. If no library information is available — unlikely but not impossible — the address of the beginning of the library is shown, instead.</p></li><li class="ol ol"><p><em>Symbol</em>— The symbol where this sample was located. Most of the time, this is the name of the function or subroutine that was executing when the sample was taken, but the precise definition is controlled by the compiler. One particular area for wariness is with macros and inline functions. These will usually be labeled according to the name of the calling function, and not the macro or inline function name itself. If no symbol information is available, the address of the beginning of the symbol is shown, instead.</p><p> You may click the disclosure triangle to the left of the symbol name to open up nested row(s) containing the name of all caller(s) (“Heavy” view) or callee(s) (“Tree” view). If you Option-Click on the triangle, instead, then all disclosure triangles nested within will open, too, allowing you to open up the entire stack with a single click.</p></li></ol></li><li class="li"><p><strong>Status Bar</strong>— This line shows you the number of active samples, the number of samples in any selected row(s) of the <em>Results Table</em>, and the percent of samples that are selected. Note that the number of active samples being displayed can be reduced dramatically using controls such as the <em>Process</em> pop-up, <em>Thread</em> pop-up, and data mining operations (see <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW1">“Data Mining”</a></span>).</p></li><li class="li"><p><strong>Callstack View Button</strong>— Pressing this button opens up the function <em>Callstack Table</em>, shown in <span class="content_text">Figure 2-6</span>, which allows you to view deep calling trees more easily. The most frequently occurring callstack within the selected granule (address/symbol/library) is displayed. Once open, you can click rows of the <em>Callstack Table</em> to navigate quickly to other granules that are present in the selected callstack.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH3-SW4" title="Figure 2-6Callstack Table"></a><p><strong>Figure 2-6&nbsp;&nbsp;</strong>Callstack Table</p><img src = "../Art/TimeCallstack.jpg" alt = "Callstack Table" ></div></li><li class="li"><p><strong>Process Popup Menu</strong>— This lists all of the sampled processes, in order of descending number of samples in the profile, plus an “All” option at the top. When you choose an option here, the <em>Results Table</em> is constrained to only show samples falling within the selected process. Each entry in the process list displays the following information: the percent of total samples taken within that process, process name, and process ID (PID). This information is similar to the monitoring information provided by tools such as the command-line <code>top</code> program.</p></li><li class="li"><p><strong>Thread Popup Menu</strong>— When you select a single process using the <em>Process Popup</em>, this menu lets you choose samples from a particular thread within that process. By default, the samples from all of the threads within the selected process are merged, using the “All” option.</p></li><li class="li"><p><strong>View Popup Menu</strong>— This popup menu lets you choose from among the two different view options (“Heavy” and “Tree”) described below, or to split the window and display both views at once (“Heavy and Tree”).</p></li></ol><a name="//apple_ref/doc/uid/TP40005233-CH3-SW14" title="Heavy View"></a><h3>Heavy View</h3><p>The “Heavy” view is not flat – each symbol name has a disclosure triangle next to it (closed by default). Opening the disclosure triangles shows you the call path or paths that lead to each function. This allows you first to understand which functions are most performance-critical and second to see the calling paths to those functions.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW5" title="Figure 2-7Heavy Profile View Detail"></a><p><strong>Figure 2-7&nbsp;&nbsp;</strong>Heavy Profile View Detail</p><img src = "../Art/figure2-5.jpg" alt = "Heavy Profile View Detail" ></div><br/><p>For example, <span class="content_text">Figure 2-7</span> shows a close-up of the “Heavy” profile view <code>log10()</code> entry. The library function <code>log10()</code> represents 12.7% of the time spent in the <code>Celestia</code> process. The 12.7% of the overall time spent in <code>log10()</code> is distributed between three calling paths. The <em>Total</em> column shows that the first path (through <code>StarOctree::findVisibleStars()</code>) accounts for 12.1% of the overall time. The rest of the total time spent in <code>log10()</code> is through calls made by two other functions in the example shown above</p><a name="//apple_ref/doc/uid/TP40005233-CH3-SW15" title="Tree View"></a><h3>Tree View</h3><p>In addition to the default “Heavy” or bottom-up profile view, Shark supports a call tree or top-down view (select “Tree” in the <em>Profile View</em> pop-up button). </p><p>The “Tree” view gives you an overall picture of the program calling structure. In the sample profile (<span class="content_text">Figure 2-8</span>), the top-level function is [<code>CelestiaOpenGLView drawRect:]</code>, which in turn calls <code>[CelestiaController display]</code>, which then calls <code>CelestiaCore::draw()</code>, and so on. </p><p>In “Tree” view, the <em>Total</em> column lists the amount of time spent in a function and its descendants, while the <em>Self</em> column lists the time spent only inside the listed function.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW6" title="Figure 2-8Tree Profile View"></a><p><strong>Figure 2-8&nbsp;&nbsp;</strong>Tree Profile View</p><img src = "../Art/TimeTreeView.jpg" alt = "Tree Profile View" ></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP40005233-CH3-DontLinkElementID_23" title="Note on Heavy/Tree comparisons"></a><p><strong>Note on Heavy/Tree comparisons:</strong>&nbsp;Please note that there may not be a one-to-one correspondence between entries in “Tree” view and “Heavy” view. If you select a function in “Heavy” view and then switch to “Tree” view, it will always select exactly one function in the tree. On the other hand, if you select a function in “Tree” view and then switch back to “Heavy” view, Shark will automatically select the “heaviest” symbol corresponding to that callpath. If several callpaths have similar weights, Shark may end up selecting one that is surprising to you.</p></div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW22" title="Profile Display Preferences"></a><h3>Profile Display Preferences</h3><p>Profile analysis can help you better understand the data presented in the <em>Profile Browser</em> by tailoring the formatting of the sampled information to suit your application’s code. Analysis settings are controlled separately for each session. The analysis controls are accessed per session by opening a drawer on the Profile Window, shown in <span class="content_text">“Advanced Session Management and Data Mining,”</span> using <em>File</em>→<em>Show Advanced Settings</em> (<em>Command-Shift-M</em>).</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW28" title="Figure 2-9Profile Analysis Preferences"></a><p><strong>Figure 2-9&nbsp;&nbsp;</strong>Profile Analysis Preferences</p><img src = "../Art/ProfileAdvanced.jpg" alt = "Profile Analysis Preferences" ></div><br/><p>This part of the <em>Advanced Settings</em> drawer contains many different controls:</p><ol class="ol"><li class="li"><p><strong>Show All Branches</strong>— The default “Heavy” view lists only the leaf entries (where samples landed) for the sampled callstacks. As a result, each sample only appears once in the profile. Opening disclosure triangles in the “Heavy” view reveals the contribution of each calling function to the “leaf” function’s total, if you are interested in seeing what is calling those functions. With <em>Show All Branches</em> on, a “sample” is counted for <em>all</em> symbols (root, interior and leaf), rather than only leaf entries. This results in actual samples with deep callstacks being over-represented in the profile, since they are counted many times, but makes it easier to find symbols for frequently-occurring but non-leaf functions, since one no longer must drill down through multiple levels of disclosure triangles to find them.</p><p>While Shark will allow you to use this mode with “tree” view, it is not recommended.</p></li><li class="li"><p><strong>Color By Library</strong>— Uses colors to differentiate libraries in the <em>Results</em> table.</p></li><li class="li"><p><strong>Show Symbol Length</strong>— Displays the sum of instruction lengths in bytes for each symbol.</p></li><li class="li"><p><strong>Demangle C++ Symbols</strong>— Translates compiler-generated symbol names to user-friendly names in C++ code, stripping off the name additions required to support function polymorphism.</p></li><li class="li"><p><strong>Granularity</strong>— Determines the grouping level that Shark uses to bind samples together. </p><ol class="ol"><li class="ol ol"><p><em>Address</em>— Group samples from the same program address.</p></li><li class="ol ol"><p><em>Symbol</em>— Group samples from the same symbol (usually there is a one-to-one correspondence between symbols and functions).</p></li><li class="ol ol"><p><em>Library</em>— Group samples from the same library.</p></li><li class="ol ol"><p><em>Source File</em>— Group samples from the same source file.</p></li><li class="ol ol"><p><em>Source Line</em>— Group samples from the same line of source code.</p></li></ol></li><li class="li"><p><strong>Stats Display</strong>— Selects units and a baseline number of samples.</p><ol class="ol"><li class="ol ol"><p><em>Value</em>— Shows raw sample counts rather than percentages.</p></li><li class="ol ol"><p><em>% of Scope</em>— Shows percentages based on currently selected process and/or thread.</p></li><li class="ol ol"><p><em>% of Total</em>— Shows percentages based on total samples taken.</p></li></ol></li><li class="li"><p><strong>Weight By</strong>— In Shark’s default weighting method (weight by sample count), each sample contributes a count of one. During sample processing, any time a sample lands in a particular symbol’s address range (in the case of symbol granularity) the total count (or weight) of the granule is incremented by one. In addition to context and performance counter information, each sample also saves the time interval since the last sample was recorded. When samples are weighted by time, each granule is weighted instead by the sum of the sampling interval times of all of its samples. </p></li><li class="li"><p><strong>Time Unit</strong>— Selects the time unit (µs, ms, s) used to display time values. <em>Auto</em> will select the most appropriate time unit for each value when weighting by “Time.”</p></li><li class="li"><p><strong>Process ID</strong>— Shark normally differentiates between processes according to their process ID (PID) – a unique integer assigned to each process running on the system. Thus, Shark groups together samples from the same PID. Shark can also identify processes by name. In this case, samples from processes with the same name (and possibly different PIDs) would be grouped together. This is particularly useful for programs that are run from scripts or that fork/join many processes.</p></li></ol><p>The remainder of the controls visible in the Advanced Settings Drawer, which control Data Mining, are described in <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW1">“Data Mining.”</a></span></p><a name="//apple_ref/doc/uid/TP40005233-CH3-SW21" title="Chart View "></a><h2>Chart View </h2><p>Click Shark’s <em>Chart</em> tab to explore sample data chronologically, from either a thread- or CPU-based perspective. This can help you understand the chronological calling behavior in your program, as opposed to the summary calling behavior shown in the <em>Results Table</em>. Using this chart, you can see at a glance if your program rarely/often calls functions and if there are any recurring patterns in the way your program calls functions. Based on this, you can often visually see different <em>phases</em> of execution — areas where your program is executing different pieces of its code. This information is useful, because each phase of execution will usually need to be optimized in a different way.</p><p>Shark’s <em>Chart</em> and <em>Profile</em> views are tightly integrated. The same level of scope (system/process/thread) is always displayed on both. Selected entries in the <em>Results Table</em> are highlighted in the <em>Chart</em> view. Filtering of samples using the <em>Profile Analysis</em> or <em>Data Mining</em> panes (see <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW1">“Data Mining”</a></span>) also affects the selection of samples shown in the <em>Chart</em> view. As with the <em>Callstack Table</em> shown in the <em>Profile</em> Browser, double clicking on any entry in the table opens a new <em>Code Browser</em> tab.</p><p>By default, Shark displays the currently selected scope (system, process, or thread) against an “absolute” time x-axis. This view displays gaps wherever the currently selected process or thread was not running. Use the <em>Time Axis</em> pop-up button to switch between absolute and relative time, which compresses out these out-of-scope areas.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW8" title="Figure 2-10Chart View"></a><p><strong>Figure 2-10&nbsp;&nbsp;</strong>Chart View</p><img src = "../Art/TimeChart.jpg" alt = "Chart View" ></div><br/><p>The chart view shown in <span class="content_text">Figure 2-10</span> has several parts:</p><ol class="ol"><li class="li"><p><strong>Callstack Chart</strong>— This chart displays the depth (y-axis) of the callstack for each sample, chronologically from left-to-right over time (x-axis). The figure also clearly shows several key features of the chart:</p><ol class="ol"><li class="ol ol"><p><em>User Callstack</em>— Most callstacks, in blue, represent user-level code from your program.</p></li><li class="ol ol"><p><em>Supervisor Callstack</em>— Callstacks in dark red represent supervisor-level code stacks that were sampled.</p></li><li class="ol ol"><p><em>Selected Callstack</em>— A yellow “pyramid” of callstacks is highlighted when you click on the graph to select a sample. Once you have chosen a sample, you can use the left and right arrow keys to navigate to the previous or next unique callstack “pyramid.” After highlighting the chosen sample, Shark examines the callstacks to either side and automatically extends the selection outwards to the left and right wherever the adjacent callstacks have the same symbol. In this way, you can easily see the full tenures for each function (length of time that function is in the callstack). Because functions at the base of the callstack, like <code>main</code>, have much longer tenures than the leaf functions at the top of the callstack, the shape of the highlighted area will always be a pyramid of some sort.</p><p>It is also possible to select one or more individual <em>symbols</em> within the chart view by selecting them in the Profile Browser and then switching over to the chart view. After you switch to the chart view, all of the dots on the chart representing calls to the selected symbol(s) will be highlighted in yellow, allowing you to find and examine samples containing those symbol(s) more easily in complex charts. It is usually easy to differentiate these “symbol selections” from the “sample selections” made by clicking within the chart view itself, because only elements of each callstack corresponding to the selected symbols are highlighted in the former case, and not entire samples or “pyramids,” as in the latter.</p></li><li class="ol ol"><p><em>Context Switch Lines</em>— These lines indicate where the operating system switched another process or thread into the processor. Note that because Shark uses statistical sampling, it is possible to miss very short thread contexts. They are only visible at high levels of magnification in “absolute” time mode (as chosen in #12, below), when you select the option to show them in the <em>Advanced Settings</em>.</p></li><li class="ol ol"><p><em>Out-of-Scope Callstack</em>— (not shown) Callstacks in gray, visible only in “absolute” time mode, are just placeholders for samples that are outside the current process/thread scope. In “relative” mode, they are eliminated from the graph.</p></li></ol></li><li class="li"><p><strong>Zoom Slider</strong>— You can zoom in or out of the chart by dragging this slider towards the “+” and “–” ends, respectively. You can also use the mouse to zoom into a subset of the displayed samples by dragging the mouse pointer over the desired region of the chart. Zooming out can also be accomplished by <em>Option-Clicking</em> on the chart.</p></li><li class="li"><p><strong>Chart Scroll Bar</strong>— If you have magnified the chart, then you can use this scroll bar to move left-and-right within it.</p></li><li class="li"><p><strong>Callstack Table Button</strong>— Press this button to expose or collapse the <em>Callstack Table</em>, below.</p></li><li class="li"><p><strong>Callstack Table Header</strong>— This area summarizes the CPU number, process ID, thread ID, and user/supervisor code status of the sample. This is displayed or hidden using the <em>Callstack Table Button</em> (#4).</p></li><li class="li"><p><strong>Callstack Table</strong>— This displays the functions within the callstack for the currently selected sample, with the leaf function at the top and the base of the stack at the bottom. As you select different samples in the chart, this listing will update to reflect the location of the current selection. This is displayed or hidden using the <em>Callstack Table Button</em> (#4).</p></li><li class="li"><p><strong>Sample Table Headers</strong>— Like most tables in Shark, you can click here to select the column used to sort the samples in this table, and then click on the arrow at the right end of the selected header cell to choose to sort in ascending or descending order. Choosing a column here has no other effect besides controlling the sort order, however.</p></li><li class="li"><p><strong>Sample Table</strong>— This table lists a summary of all samples recorded within the session. It lists several key facts that are recorded with each sample:</p><ol class="ol"><li class="ol ol"><p><em>Index</em>— Number of the sample within the session, starting from 1 and going up.</p></li><li class="ol ol"><p><em>Time</em>— Time that has passed between this sample and the previous one. Normally, this will be a constant amount of time equal to the sampling period, but there are some sampling modes that allow variation here.</p></li><li class="ol ol"><p><em>CPU</em>— Number of the CPU on your system where this sample was recorded, starting from 1 and going up.</p></li><li class="ol ol"><p><em>Process</em>— Process ID for this sample’s process, including the name of the application.</p></li><li class="ol ol"><p><em>Thread</em>— Thread ID for this sample’s thread.</p></li></ol></li><li class="li"><p><strong>Sample Table Callstacks</strong>— If you pull this window splitter to the left, you will expose a table listing all symbol names within the callstacks of each sample, in a large grid. Effectively, this is like looking at multiple <em>Callstack Table</em>s rotated 90 degrees and placed side-by-side. Most of the time, this level of detail about your samples is not necessary, but there may be some occasions when you might find this view helpful.</p></li><li class="li"><p><strong>Process Popup Menu</strong>— This lists all of the sampled processes, in order of descending number of samples in the profile, plus an “All” option at the top. When you choose an option here, the <em>Callstack Chart</em> is constrained to only show samples falling within the selected process. Each entry in the process list displays the following information: the percent of total samples taken within that process, process name, and process ID (PID). This information is similar to the monitoring information provided by tools such as the command-line <code>top</code> program.</p></li><li class="li"><p><strong>Thread Popup Menu</strong>— When you select a single process using the <em>Process Popup</em>, this menu lets you choose samples from a particular thread within that process. By default, the samples from all of the threads within the selected process are merged, using the “All” option.</p></li><li class="li"><p><strong>Time Popup Menu</strong>— This popup lets you choose between two different viewing modes. The first, “absolute” time mode, shows <em>all</em> samples from a particular processor, no matter what was executing. Samples from outside the current process/thread scope are grayed out, but are still plotted. On the other hand, in “relative” time mode, all out-of-scope samples are eliminated and the chart’s x-axis is adjusted to account for the smaller number of samples.</p></li><li class="li"><p><strong>View Popup Menu</strong>— This popup lets you choose to view sets of samples from different processor cores.</p></li></ol><a name="//apple_ref/doc/uid/TP40005233-CH3-SW29" title="Advanced Chart View Settings"></a><h3>Advanced Chart View Settings</h3><p>The first pane of the <em>Advanced Settings</em> drawer displays a new set of options if you switch to a <em>Chart</em> view (<span class="content_text">Figure 2-11</span>). These controls affect the appearance of the chart, and are generally fairly minor:</p><ol class="ol"><li class="li"><p><strong>Draw Context Switch Lines</strong>— Enables or disables the drawing of gray lines between samples that are from different process and/or thread contexts. They are quite useful, but can clutter the display at low levels of magnification.</p></li><li class="li"><p><strong>Hide Samples Not In Scope</strong>— When chosen, this hides all samples from processes or threads outside of the ones in the current scope, as chosen by the <em>Process</em> and <em>Thread</em> pop-up menus. Any remaining samples are compressed together to remove any gaps. This process is similar to switching to “Relative” time using the <em>Time</em> pop-up menu, but the results are slightly different.</p></li><li class="li"><p><strong>Coalesce Samples</strong>— When chosen, this combines adjacent samples containing the same callstacks together, so they are no longer individually selectable. If your Time Profiles often contain large blocks of identical samples, the use of this option can make maneuvering through the samples using the arrow keys somewhat easier.</p></li><li class="li"><p><strong>Chart Type</strong>— Selects which type of chart to plot. You will rarely need to change this, but other options are available:</p><ol class="ol"><li class="ol ol"><p><em>Saturn</em>— The default chart type, this presents a graph consisting of a solid bar representing the callstack at each sample point.</p></li><li class="ol ol"><p><em>Trace</em>— This chart type is similar to the Saturn graph type, except that it only draws an outline around the bars instead of coloring them completely. Selections are made only on a sample-by-sample basis, instead of in “pyramids.”</p></li><li class="ol ol"><p><em>Delta</em>— This is much like the trace view, including the point selections. However, it only shows <em>changes</em> in the callstacks, and not their exact depth. As a result, it is of most use when you are looking for rare changes in the callstack depth or trends over time.</p></li><li class="ol ol"><p><em>Hybrid</em>— This graph looks like a Trace graph, but uses the full “pyramid” selection capability of the Saturn graph type.</p></li></ol></li><li class="li"><p><strong>Weight By</strong>— Choose how to present the x-axis scale for the chart view. You may have Shark present this axis in terms of sample count or by time. You may also use the keyboard equivalents <em>Command-1</em> to use sample counts or <em>Command-2</em> to use time.</p></li><li class="li"><p><strong>Time Unit</strong>— Selects the time unit to use in the <em>Time</em> column of the <em>Sample Table</em>. Normally you should just leave this on the default, “Auto,” but if you would prefer you may explicitly choose to have the numbers displayed in µs, ms, or s.</p></li><li class="li"><p><strong>Color Selection</strong>— Choose colors to use for user sample callstacks, kernel sample callstacks, and the selection area by clicking on these color wells.</p></li></ol><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW10" title="Figure 2-11Advanced Settings for the Chart View"></a><p><strong>Figure 2-11&nbsp;&nbsp;</strong>Advanced Settings for the Chart View</p><img src = "../Art/ChartAdvanced.jpg" alt = "Advanced Settings for the Chart View" ></div><br/><p>The remainder of the controls visible in the Advanced Settings Drawer, which control Data Mining, are described in <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW1">“Data Mining.”</a></span></p><a name="//apple_ref/doc/uid/TP40005233-CH3-SW20" title="Code Browser"></a><h2>Code Browser</h2><p>Double-clicking on an entry in the <em>Results Table</em> or <em>Callstack Table</em> will open a <em>Code Browser</em> view for that entry, as shown in <span class="content_text">Figure 2-12</span>. If available, the source code for the selected function is displayed. Source line and file information are available if the sampled application was compiled with debugging information (see <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW43">“Debugging Information”</a></span>). The <em>Code Browser</em> shows the code from the selected function and colorizes each instruction according to its reference count (the number of times it was sampled).</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW9" title="Figure 2-12Code Browser"></a><p><strong>Figure 2-12&nbsp;&nbsp;</strong>Code Browser</p><img src = "../Art/TimeCodeBrowser.jpg" alt = "Code Browser" ></div><br/><p>The Code Browser window consists of several different parts:</p><ol class="ol"><li class="li"><p><strong>Code Browser Tab</strong>— When you double-click on an entry in a Profile Browser or Chart View, Shark dynamically adds a tab to the top of the window. This tab contains the code browser for the symbol that you double-clicked. If you return to one of the original browsers and double-click on another symbol, another tab will be added for that symbol. Unlike the default tabs, these additional tabs all have small close boxes on the left end. When clicked, the tab will be eliminated. If you open up more than about 3–5 code browsers, this may be necessary because of limited space at the top of the window.</p></li><li class="li"><p><strong>Browse Buttons</strong>— You can use these buttons to maneuver through function calls. After you double-click on a function call (denoted by blue text) and go to the actual function, the “back” button here (left arrow) will be enabled. To return to the caller, just click on the “back” button. After you have maneuvered through a function call, you can navigate through code forward and backward just as you would navigate web pages in a web browser.</p></li><li class="li"><p><strong>Address Range</strong>— This is used with the Assembly Browser (see <span class="content_text"><a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW30">“Assembly Browser”</a></span>).</p></li><li class="li"><p><strong>Code Table Headers</strong>— Click on any column title to select it, causing the rows to be sorted based on the contents of that column. You will usually want to sort by the “Line” column in this window, so that you can view your code in the original sequence order. You can also select ascending or descending sort order using the direction triangle that appears at the right end of the selected header.</p></li><li class="li"><p><strong>View Buttons</strong>— Use these buttons to choose between:, <em>Assembly View</em>, or a split-screen view showing both side-by-side.</p><ul class="ul"><li class="li"><p><em>Source View</em>: This displays the original source code for the function. It is the default, if Shark can find source code for the function. To make sure that Shark can find your source, you first need to have debugging information enabled in your compiler (see <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW43">“Debugging Information”</a></span>). Also, it is best to avoid moving the files after you compile them, so all source paths embedded in debugging information will still be accurate. Otherwise, you may need to adjust Shark’s source paths, as described in <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW5">“Shark Preferences.”</a></span></p></li><li class="li"><p><em>Assembly View</em>: This displays the raw assembly language for the function. Because it is extracted directly from the program binary, this option is always available, even for library code. See the Assembly Browser section (<span class="content_text"><a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW30">“Assembly Browser”</a></span>) for more information.</p></li><li class="li"><p><em>Both</em>: This displays both views side-by-side, and is useful when you are comparing your source input to the compiler’s output.</p></li></ul></li><li class="li"><p><strong>Code Table</strong>— This table allows you to examine your source code and see how samples were distributed among the various lines of code. Each row of the table is automatically color-coded based on the number of samples associated with that line — by default, hotter colors mean more samples — allowing you can see at a glance which code is executing the most.</p><p>You can use the <em>Edit→Find→Find</em> command (<em>Command-F</em>) and the related <em>Edit→Find→Find Next</em> (<em>Command-G</em>) and <em>Edit→Find→Find Previous</em> (<em>Command-Shift-G</em>) commands to search through your code, much like you can in most text editors. Just type the desired text into the <em>Find...</em> dialog box, and Shark will automatically find and highlight the next instance of that text in your code. You can also use this to search for comments, if you need to look for repeated instances of a tip in the comments, for example.</p><p>The table consists of several columns. Some of these are optional, and are enabled or disabled using checkboxes in the <em>Advanced Settings</em> drawer.</p><ol class="ol"><li class="ol ol"><p><em>Self</em>— This optional column lists the percentage of displayed references for each instruction or source line, using only the samples that fell within this particular address range. To see sample counts instead of percentages, double-click on the column.</p></li><li class="ol ol"><p><em>Total</em>— This optional column lists the percentage of displayed references for each instruction or source line, including called functions. To see sample counts instead of percentages, double-click on the column.</p></li><li class="ol ol"><p><em>Line</em>— The line number for each line from your original source code file. This column is particularly useful for sorting the browser window, in order to keep the line numbers there in sequence.</p></li><li class="ol ol"><p><em>Code</em>— This column lists your original source file, line-by-line. Double-clicking on this column will take you to the equivalent location in the <em>Assembly</em> display. Double-clicking on any function calls (denoted by blue text), will take you to the source code for that function.</p></li><li class="ol ol"><p><em>Code Tuning Advice</em>— When possible, Shark points out performance bottlenecks and problems. The availability of code tuning advice is shown by a <img src = "../Art/exclamation_point.gif" alt = "Exclamation Point Button" width="20" height="14"> button in this column. Click on the button to display the tuning advice in a text bubble, as shown in <span class="content_text">“ISA Reference Window.”</span> The suggestions provided in the code browser will usually be more detailed and lower-level than the ones visible within the profile browser.</p></li><li class="ol ol"><p><em>Comment</em>— This column gives a brief summary of the code tuning advice, allowing you to determine which code tuning suggestions are likely to be helpful without clicking on every last advice button.</p></li><li class="ol ol"><p><em>Performance Event Column</em>— (Not shown) This optional column, which is only available when you are looking at a code browser while using a configuration that uses performance counters (as described in <span class="content_text"><a href="../OtherProfilingandTracingTechniques/OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW21">“Event Counting and Profiling Overview”</a></span>), shows raw counts from those counters. It cannot be enabled with normal time profiles.</p></li></ol></li><li class="li"><p><strong>Code Table Scrollbar</strong>— This scrollbar (<span class="content_text">Figure 2-13</span>) is customized to show an overview of sampling hot spots; the brightness of a location in the scrollbar is proportional to the sampling reference count of the corresponding instruction in the <em>Code Table</em>.  Since programmer time is best spent optimizing code that makes up a large portion of the execution time, this visualization of hot spots helps you to quickly see and focus your development effort on the code that has the greatest influence on overall performance.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH3-SW24" title="Figure 2-13Hot Spot Scrollbar"></a><p><strong>Figure 2-13&nbsp;&nbsp;</strong>Hot Spot Scrollbar</p><img src = "../Art/figure2-12.jpg" alt = "Hot Spot Scrollbar" ></div></li><li class="li"><p><strong>Status Bar</strong>— This line shows you the number of active samples in the currently displayed memory range, the number of active samples in the entire session, and/or the number of samples in any selected row(s) of the <em>Code Table</em>. Either or both of the active samples will be eliminated from this line if the “Self” or “Total” columns in the code table are disabled. In addition, the percent of samples that are in each of these categories is displayed. </p></li><li class="li"><p><strong>Source File Popup Menu</strong>—A given memory range can contain source code from more than one file because of inlining done by the compiler. You can select which source file to view using this menu.</p></li><li class="li"><p><strong>Edit Button</strong>— You can open the currently displayed source file in Xcode by selecting the <em>Edit</em> button. The file will open up and scroll to your selected line, or the line with the most samples if nothing is selected.</p></li><li class="li"><p><strong>Function Popup Menu</strong>— This pop-up menu allows you to jump quickly to different functions in the current source file. Please note that sample counts are only shown for the source lines in the current memory range — other functions not in the current memory range may be visible, and you can still look at them, but they will show no sample counts).</p></li></ol><a name="//apple_ref/doc/uid/TP40005233-CH3-SW30" title="Assembly Browser"></a><h3>Assembly Browser</h3><p>In addition to displaying the source code from the current memory range, Shark also provides a detailed assembly-level view (<span class="content_text">Figure 2-14</span>) that can be enabled by clicking on the <em>Assembly</em> button or combined with a source browser by clicking on the <em>Both</em> button. This browser will also pop up in place of a source browser if Shark cannot find source code for the address range that you are examining. This will often be the case with common system libraries, the kernel, and precompiled applications.</p><p>Often, it is useful to examine the relationship between a line of source code and its compiler-generated instructions. Shark encourages this type of exploration: either use the <em>Both</em> button to view source and assembly simultaneously or double-click on a line in the <em>Source</em> or <em>Code</em> columns in the <em>Assembly Code Browser</em> to jump to the corresponding source line in the <em>Source Code Browser</em>. Conversely, double-click on a line of code in the <em>Source Code Browser</em> to jump back to the corresponding instructions in the <em>Assembly Code Browser</em>.</p><p>Many parts of this browser are identical to their counterparts in the <em>Source Browser</em>, including Self, Total, tuning advice, and Comment columns. However, there are a few differences:</p><ol class="ol"><li class="li"><p><strong>Browse Buttons</strong>— You can use these buttons to maneuver through branches. After you double-click on a branch with a static target address (denoted by blue text) and go to the destination, the “back” button here (left arrow) will be enabled. To return to the branch itself, just click on the “back” button. After you have maneuvered through branches, you can navigate through code forward and backward just as you would navigate web pages in a web browser.</p></li><li class="li"><p><strong>Address Range</strong>— Samples are displayed only for the address range between these two boxes (usually one symbol). Code outside of this range may have samples, but they will not be displayed.</p></li><li class="li"><p><strong>Code Table</strong>— About half of the columns have functions that are identical to the basic source browser, but the others are new or slightly different:</p><ol class="ol"><li class="ol ol"><p><em>Address Column</em>— This displays the address of the assembly-language instruction displayed on this row. With PowerPC, this value simply increases by 4 with every row, but with x86 this will change by 1–18 bytes per row, depending upon the variable length of each instruction. You can double-click on this column to switch to relative decimal or hexadecimal offsets from the beginning of the address range.</p></li><li class="ol ol"><p><em>Code Column</em>— This column displays the assembly code used by your routine. Using <em>Advanced Settings</em>, you can choose to disable disassembly and to have Shark automatically find and indent loops based on backwards branches in the code (the default). Within this column, you can double-click on a branch with a static target address (denoted by blue text) to follow a branch to its target address; after double-clicking, the function containing the target instruction will be loaded, if necessary, and the target instruction will be highlighted. Finally, double-clicking on this column will take you to the equivalent location in the corresponding <em>Source</em> display.</p></li><li class="ol ol"><p><em>Cycles Column</em>— (not shown) This PowerPC-only column displays the latency (processor cycles before an instruction’s result is available to dependent instructions) and repeat rate (processor cycles between completing instructions of this type when the corresponding pipeline is full) of the assembly instruction on this line, in processor cycles. In general, you will want to minimize the use of instructions with high latency, especially if the values that they produce are used by immediately following instructions. Use of instructions with poor (high number) repeat rates may also impact your performance if you try to issue them too frequently.</p></li><li class="ol ol"><p><em>Comment Column</em>— In addition to its usual function of providing short versions of the code analysis tips, on PowerPC the comment column also displays information about how long the instruction must stall as a result of long latency by prior instructions. You will find that very low-level optimization hints, focused on particular assembly instructions, are provided here.</p></li><li class="ol ol"><p><em>Source Column</em>— This shows the source file name and line number of where in the source code this instruction originated, when this is available. As with the <em>Code Column</em>, you can double-click here to get back to the <em>Source</em> display, scrolled to the line listed here.</p></li></ol></li><li class="li"><p><strong>Asm Help Button</strong>— Press this button to get help for the selected assembly-language instruction, as described in <span class="content_text"><a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW7">“ISA Reference Window.”</a></span></p></li></ol><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW31" title="Figure 2-14Assembly Browser"></a><p><strong>Figure 2-14&nbsp;&nbsp;</strong>Assembly Browser</p><img src = "../Art/TimeAsmBrowser.jpg" alt = "Assembly Browser" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH3-SW32" title="Advanced Code Browser Settings"></a><h3>Advanced Code Browser Settings</h3><p>The <em>Advanced Settings</em> drawer displays a new set of options if you switch to a <em>Code Browser</em> view (<span class="content_text">“Manual Session Symbolication”</span>). These options allow you to customize the viewing of source and assembly code and turn on and off various features of the browser. These are many controls in this view:</p><ul class="spaceabove"><li class="li"><p><strong>Code Browser</strong>— This section affects the display of both source and assembly-language browsers.</p><ol class="ol"><li class="li"><p><strong>CPU Model</strong>— By default, Shark uses a model of the current system’s CPU architecture when analyzing code sequences in order to determine instruction latencies and hints. You can select other CPU architectures by changing this setting.</p></li><li class="li"><p><strong>Hot Code Colors</strong>— Choose the colors that Shark uses to display the “hotness” of code here.</p></li><li class="li"><p><strong>Selection Formatting</strong>— Choose the color and whether or not an outline is used for code selections.</p></li><li class="li"><p><strong>Grid Lines</strong>— Adds grid lines between each line of code when checked (the default).</p></li><li class="li"><p><strong>Show Total Column</strong>— Toggles display of the column that lists the percentage of displayed references for each instruction or source line, including called functions.</p></li><li class="li"><p><strong>Show Self Column</strong>— Toggles display of the column that lists the percentage of displayed references for each instruction or source line, but <em>not</em> including called functions. </p></li><li class="li"><p><strong>Show Perf Event Column(s)</strong>— If the current profile contains performance counter information, this setting toggles display of that data within the browser. Otherwise, it will be disabled.</p></li><li class="li"><p><strong>Show Code Analysis Columns</strong>— Toggles display of the columns that provide optimization tips. </p></li></ol></li><li class="li"><p><strong>Source Browser</strong>— This section affects the display of the source browser only.</p><ol class="ol"><li class="li"><p><strong>Line Numbers</strong>— Toggles display of the column that lists the line number from the source code.</p></li><li class="li"><p><strong>Syntax Coloring</strong>— Enable this to have Shark color source code keywords, constants, comments, and such.</p></li><li class="li"><p><strong>Tab Width</strong>— Shark auto-indents loops by this number of spaces for every loop nest level.</p></li></ol></li><li class="li"><p><strong>Asm Browser</strong>— This section affects the display of the assembly-language browser only.</p><ol class="ol"><li class="li"><p><strong>Disassemble</strong>— Choose whether to display disassembled mnemonics or raw hexadecimal values for the instructions.</p></li><li class="li"><p><strong>Indent Loops</strong>— Choose whether or not to have Shark auto-indent loops in the code here. Loops are found based on analysis of backwards branches in typical compiled code.</p></li><li class="li"><p><strong>Simplified Mnemonics</strong>— (PowerPC-only) Choose whether or not to enable full disassembly of instructions with constant values that specify special instruction modes, or to only disassemble to fundamental opcodes and leave the modifying constants intact for your examination.</p></li><li class="li"><p><strong>Show G5 (PPC970) Dispatch Groups</strong>— (PowerPC-only) Displays outlines on the main assembly-language grid showing the breakdown of the instructions into dispatch groups. Further details on is can be found in <span class="content_text"><a href="../MiscellaneousTopics/MiscellaneousTopics.html#//apple_ref/doc/uid/TP40005233-CH14-SW2">“Code Analysis with the G5 (PPC970) Model.”</a></span> This function is always disabled for sessions recorded on Macs with other processor architectures.</p></li><li class="li"><p><strong>Show G5 (PPC970) Details Drawer</strong>— (PowerPC-only) Shark can display graphs of instruction dispatch slot and functional unit utilization in an additional, G5-specific “details” drawer. Further details on is can be found in <span class="content_text"><a href="../MiscellaneousTopics/MiscellaneousTopics.html#//apple_ref/doc/uid/TP40005233-CH14-SW2">“Code Analysis with the G5 (PPC970) Model.”</a></span> This function is always disabled for sessions recorded on Macs with other processor architectures.</p></li></ol></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW33" title="Figure 2-15Advanced Settings for the Code Browser"></a><p><strong>Figure 2-15&nbsp;&nbsp;</strong>Advanced Settings for the Code Browser</p><img src = "../Art/CodeAdvanced.jpg" alt = "Advanced Settings for the Code Browser" ></div><br/><p>Other architectures have slightly different options for items 3–5 of the <strong>Asm Browser</strong> settings. For x86-based systems, illustrated in , these options are:</p><ul class="spaceabove"><li class="li"><p><strong>Syntax</strong>— Chooses whether to display the x86 instructions in Intel assembler syntax or AT&amp;T syntax (the default).</p></li><li class="li"><p><strong>Show Prefixes</strong>— If checked, instruction prefixes (like <code>lock</code> and temporary mode shifts) will be displayed.</p></li><li class="li"><p><strong>Show Operand Sizes</strong>— If checked, each instruction explicitly encodes its operand size into the mnemonic (AT&amp;T syntax) or operand list (Intel syntax). Otherwise, the code will be streamlined but it may not be possible to tell 8, 16, 32, and 64-bit versions of instructions apart.</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW38" title="Figure 2-16x86 Asm Browser Advanced Settings"></a><p><strong>Figure 2-16&nbsp;&nbsp;</strong>x86 Asm Browser Advanced Settings</p><img src = "../Art/AsmBrowserX86.jpg" alt = "x86 Asm Browser Advanced Settings" ></div><br/><p>For ARM-based systems, illustrated in , the only option is:</p><ul class="spaceabove"><li class="li"><p><strong>ISA</strong>— Selects to decode the instructions in the block as ARM (32-bit) instructions or Thumb (16-bit) instructions. The iPhone OS uses both types of ARM instructions for different functions, so you may need to use this menu to switch from one to the other on a symbol-by-symbol basis.</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW39" title="Figure 2-17ARM Asm Browser Advanced Settings"></a><p><strong>Figure 2-17&nbsp;&nbsp;</strong>ARM Asm Browser Advanced Settings</p><img src = "../Art/AsmBrowserARM.jpg" alt = "ARM Asm Browser Advanced Settings" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH3-SW7" title="ISA Reference Window"></a><h3>ISA Reference Window</h3><p>In order to understand the low-level analysis displayed in Shark’s <em>Assembly Browser</em>, it may be helpful to view the underlying machine’s instruction set architecture (ISA). You can display the PowerPC or Intel ISA Reference Manual (<span class="content_text">Figure 2-18</span>) by clicking on the <em>Asm Help</em> button in the <em>Assembly Browser</em> or choosing the appropriate command from the <em>Help</em> menu: <em>Help→PowerPC ISA Reference</em>, <em>Help→IA32 ISA Reference</em>, or <em>Help→EM64T ISA Reference</em>.</p><p>The <em>ISA Reference Window</em> provides an indexed, searchable interface to the PowerPC, IA-32 (32-bit x86), or EM64T (64-bit x86) instruction sets. The reference is also integrated with selection in the Shark <em>Assembly Browser</em> – selecting an instruction in the table causes the <em>ISA Reference Window</em> to jump to that instruction’s definition in the manual.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW2" title="Figure 2-18ISA Reference Window"></a><p><strong>Figure 2-18&nbsp;&nbsp;</strong>ISA Reference Window</p><img src = "../Art/AsmHelp.jpg" alt = "ISA Reference Window" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH3-SW34" title="Tips and Tricks"></a><h2>Tips and Tricks</h2><p>This section points out a few things that you might see while looking at a <em>Time Profile</em>, what they may mean, and how to optimize your code if you see them. The tips and tricks listed herein are organized according to the view most commonly used to infer the associated behavior.</p><ul class="ul"><li class="li"><p><strong>Profile Browser</strong></p><ul class="nested"><li class="nested li"><p><em>Where should I start? :</em></p><p>When first presented with a Profile Browser, you will want to begin in “Heavy View” sorted by “Self” and see what pops to the top. These will be the functions that execute the most, and probably have inner loops that may be susceptible to optimization. Do not forget to pop open disclosure triangles to see what functions are calling these functions; sometimes it is easier to optimize outer loops in these calling functions, instead of inner loops in the leaf functions. If any of these outer functions look promising, you may want to consider flipping to “Tree” view in order to see the caller-callee relationships a little more clearly.</p></li><li class="nested li"><p><em>No Samples Taken:</em></p><p>Shark will come up and report that it has not taken any samples if all of the threads in your application are blocked when you choose to sample one process using <span class="content_text"><a href="../SelectingExecutiontoSampleorTrace/SelectingExecutiontoSampleorTrace.html#//apple_ref/doc/uid/TP40005233-CH13-SW12">“Process Attach”</a></span> or <span class="content_text"><a href="../SelectingExecutiontoSampleorTrace/SelectingExecutiontoSampleorTrace.html#//apple_ref/doc/uid/TP40005233-CH13-SW13">“Process Launch.”</a></span> In this case, you probably want to use <em>Time Profile (All Thread States)</em> (see <span class="content_text"><a href="../OtherProfilingandTracingTechniques/OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW18">“Time Profile (All Thread States)”</a></span>) to see where your threads are blocking.</p><p>If you are using programmatic control of Shark’s start and stop points (see <span class="content_text"><a href="../SelectingExecutiontoSampleorTrace/SelectingExecutiontoSampleorTrace.html#//apple_ref/doc/uid/TP40005233-CH13-SW16">“Programmatic Control”</a></span>), having no samples taken may also indicate that you are starting and stopping so quickly that there was simply no chance to take any meaningful samples. In this case, you should either adjust your start and stop points to increase the amount of time between them, increase the sampling rate (see <span class="content_text"><a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW23">“Taking a Time Profile”</a></span>), or both.</p></li><li class="nested li"><p><em>Too many symbols displayed:</em></p><p>If there is just too much clutter in the profile browser, then you need to use data mining. See <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW1">“Data Mining”</a></span> for details on how to do this. Sometimes, switching between “Tree” and “Heavy” view can help organize the symbols in a more helpful way, also.</p><p>If you are looking for a small number of known symbols in a large browser window, the <em>Edit→Find→Find</em> command (<em>Command-F</em>) and the related <em>Edit→Find→Find Next</em> (<em>Command-G</em>) and <em>Edit→Find→Find Previous</em> (<em>Command-Shift-G</em>) commands are probably your best bet. With these commands, Shark will automatically find and highlight the next instance of that library or symbol for you.</p></li><li class="nested li"><p><em>Lots of symbols have almost equal weight:</em></p><p>If you have many symbols popping up to the top of the list, the best thing is to quickly examine several of them using the Code Browser, while keeping an eye out for functions with loops that look easy-to-optimize.</p></li></ul></li><li class="li"><p><strong>Chart View</strong></p><ul class="nested"><li class="nested li"><p><em>Different parts of the chart look visibly different:</em></p><p>Different-looking areas were probably created by different code in your program as it executes different program <em>phases</em> of execution. In most applications, each of these will need to be optimized separately. As a result, you may want to sample these with different Shark sessions, so that you can examine the different phases separately. Alternately, you may sample them all in one session and then use data mining (see <span class="content_text"><a href="../AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW1">“Data Mining”</a></span>) to focus more selectively on each phase as you examine the session.</p></li><li class="nested li"><p><em>What is executing at a point in the chart? :</em></p><p>Click on the chart at the point of interest and then open up the Callstack Table to see the stack for that sample (#4–6 in <span class="content_text"><a href="TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW8">Figure 2-10</a></span>). You can also double-click on the chart to open a Code Browser for the function executing at that point.</p></li></ul></li><li class="li"><p><strong>Code Browser</strong></p><ul class="nested"><li class="nested li"><p><em>The assembly browser shows lots of MOV (x86) or LD/ST (PowerPC) instructions:</em></p><p>If well over half of the instructions in your Assembly Browsers are memory access instructions, instead of actual computation, then it is quite likely that you forgot to turn on compiler optimization. One of the most important compiler optimizations is <em>register allocation</em>, which assigns variables to processor registers temporarily between operations. Without this — such as when you use Xcode’s <code>gcc</code> with <code>-O0</code> optimization — the compiler will typically load and store all values to-and-from memory with every operation, resulting in multiple data movement instructions per computation instruction. WIth register allocation, however, the compiler will use registers to route data right from one computation instruction directly to another, resulting in significantly fewer instructions and hence faster code.</p><p>As a result of the significant “free” performance improvement possible using this and other optimizations, we suggest that you always use compiler optimization <em>before</em> using Shark (with Xcode’s <code>gcc</code> we suggest <code>-O2</code>, <code>-Os</code>, or <code>-O3</code>).</p></li><li class="nested li"><p><em>I do not see any source:</em></p><p>Shark finds source code based on the full path to the source at the time it was compiled, but it recovers this source as you examine the session. If your source code moved or changed between compilation and session examination, or if you are recording and examining your session on a different Mac than you used for compilation, then you are likely to have trouble finding source. In this case, you will want to either recompile your source, in order to reset the paths correctly, or add the path to your source to Shark’s list of source search paths, in <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW5">“Shark Preferences.”</a></span></p><p>Another common source of this problem is omitting the <code>-g</code> flag when you compile. You should only use Shark on fully-optimized, release-quality code, but default settings in development environments such as Xcode often turn off debugging options like <code>-g</code> when set to produce optimized code. As a result, you will often need to manually adjust the build settings to enable this option when using Shark. Please note that in Xcode you will need to adjust the build settings for the <em>Target</em> that you are testing and the correct (optimized) <em>build configuration</em>. Unfortunately, it is quite easy to set options for the wrong target or build configuration accidentally.</p></li><li class="nested li"><p><em>I want to see code coloring based on time spent here and in functions called by this code:</em></p><p>By default, the code browser only shows the <em>Self</em> value column, and code is colored based on these values, which are the percent of samples spent executing each line of code within the displayed function. If you are examining your code line-by-line, this is generally how you will want to see the weighting displayed. However, you may also be interested in seeing time spent within the function <em>and</em> all descendant functions that it calls. In this case, you will want to enable the <em>Total</em> column using the <em>Advanced Settings</em> drawer. The code browser’s color scheme will then change to show weight coloring based on the values in this column, instead.</p></li></ul></li></ul><a name="//apple_ref/doc/uid/TP40005233-CH3-SW35" title="Example: Optimizing MPEG-2 using Time Profiles"></a><h2>Example: Optimizing MPEG-2 using Time Profiles</h2><p>In this section, Shark is used to increase the performance of the reference implementation of the MPEG-2 decoder (from mpeg.org) by 5.7x on a Mac Pro with 3.0 GHz Intel® Core 2™ processor cores.</p><p>Before beginning any performance study, it is critical to define your performance metric and to justify its relevance. Measurement of your metric should be both precise and consistent. Our performance metric for MPEG-2 was defined as the frame rate, in frames per second, of the decoder when decoding a reference movie. Unlike most video decoders, our test harness for the mpeg.org reference code let it decode as quickly as possible, without trying to keep the frame rate fixed at the rate at which it was originally recorded. As a result, the frame rate was a direct function of how fast the processor was able to do the actual decoding. This kind of unlimited decoding speed is used for offline video decoding/encoding, a task performed almost constantly by video editing programs as they read and write video clips. In addition, higher decoding speed in playback settings where the processor is limited to a fixed frame rate is still a useful metric, because means that the processor will have more time between frames to do other tasks, decode larger frames, or simply shut down and save power for a longer time between frames.</p><a name="//apple_ref/doc/uid/TP40005233-CH3-SW36" title="Base"></a><h3>Base</h3><p>The reference MPEG-2 decoder source code consists of over 120 densely coded functions spread across more than 20 files. As a result, if one were handed the code and told to optimize it, the task would appear virtually hopeless — there is simply too much code to review in a reasonable amount of time! However, as in many programs, a large majority of the code handles initialization tasks and unusual corner cases, and is therefore only rarely executed. As a result, the actual quantity of code that needs modification in order to dramatically speed up the application is probably small, but Shark is required to locate it efficiently.</p><p>After compiling and running the reference decoder, Shark generated the session displayed in <span class="content_text">Figure 2-19</span>. Just by pressing the “Start” and “Stop” button, we get a session that lets us see that about half the execution time is spent in a combination of the <code>Reference_IDCT()</code> function and the <code>floor()</code> function. By clicking the callout (<img src = "../Art/exclamation_point.gif" alt = "Exclamation Point Button" width="20" height="14">) button to the left of the <code>floor()</code> function in the display, we see that Shark suggests we replace the <code>floor()</code> function with a simple, inline replacement. Following this advice garners a <strong>1.12x</strong> performance increase. This is not a huge improvement, but is very good for something that only takes a few minutes to perform.</p><p>Looking at the code more closely shows <em>why</em><code>floor()</code> was required: the IDCT (Inverse Discrete Cosine Transform) function takes short integer input, converts to floating point for calculation, and then converts the results back to short integers. While this is a good way to keep the mathematics simple in the sample “reference” platform, the numerous type conversions and slow floating point arithmetic make this routine slow.</p><p>Converting to integer mathematics throughout avoids expensive integer→FP→integer conversions and slow FP mathematics, at the expense of more convoluted math in the code. This code is available in the mpeg2play implementation (also available on mpeg.org). Switching the implementation to integer math resulted in a much more dramatic speedup over the original code of <strong>1.86x</strong>.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW12" title="Figure 2-19Original Time Profile, with Tuning Advice"></a><p><strong>Figure 2-19&nbsp;&nbsp;</strong>Original Time Profile, with Tuning Advice</p><img src = "../Art/heavy_mpeg_1.jpg" alt = "Original - Tuning Advice" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH3-SW37" title="Vectorization"></a><h3>Vectorization</h3><p>Optimizing the <code>Reference_IDCT()</code>  function by converting it from floating point to integer also presented another possible optimization that could be helpful: SIMD vectorization. All Intel Macintoshes support the SSE instruction set extensions, allowing them to process 128-bit vectors of data, and most PowerPC Macintoshes support the very similar AltiVec™ extensions. Although the methodology for vectorizing your code is beyond the scope of this document, there is a plethora of documentation and sample code available to you online at <span class="content_text"><a href="http://developer.apple.com/hardwaredrivers/ve/index.html" target="_top">http://developer.apple.com/hardwaredrivers/ve/index.html</a></span>. The very regular, mathematically intensive inner loops of the IDCT routine are perfect candidates for this kind of vectorization. Following the suggestion supplied by Shark in <span class="content_text">Figure 2-20</span> led to converting the IDCT routine to use SSE. Surprisingly, performance only increased to <strong>2.05x</strong>, with only a 10% improvement from vectorization.</p><p>At a point like this, where our optimization efforts result in non-intuitive results, it is generally a good idea to use Shark again to see how conditions have changed since our first measurement. This additional run of Shark produced the session in <span class="content_text">Figure 2-21</span>. The vectorized IDCT function, <code>IWeightIDCT()</code>, now takes up less than 5% of the total execution time. The mystery is solved: as the IDCT function was optimized while other routines were not modified, those other, unoptimized routines became the performance bottleneck instead. Further examination with Shark quickly identified the key loops in several new functions. Because, like IDCT, they were performing complex math in tight inner loops, most of the new bottlenecks were also good targets for vectorization. As seen in <span class="content_text">Table 2-1</span>, final optimization of motion compensation (<code>Flush_Buffer()</code> and <code>Add_Block()</code>), colorspace conversion (<code>dither()</code>), and pixel interpolation (<code>conv420to422()</code> and <code>conv422to444()</code>) achieved a speedup of <strong>5.69x</strong> over the original code — a dramatic improvement made possible in a relatively short amount of time thanks to the feedback provided by Shark.
</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW13" title="Figure 2-20Code Browser with Vectorization Hint"></a><p><strong>Figure 2-20&nbsp;&nbsp;</strong>Code Browser with Vectorization Hint</p><img src = "../Art/CodeBrowserCallout.jpg" alt = "Code Browser with Vectorization Hint" ></div><br/><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH3-SW11" title="Figure 2-21Time Profile after Vectorizing IDCT"></a><p><strong>Figure 2-21&nbsp;&nbsp;</strong>Time Profile after Vectorizing IDCT</p><img src = "../Art/heavy_mpeg_2.jpg" alt = "Time Profile after Vectorizing IDCT" ></div><br/>
<a name="//apple_ref/doc/uid/TP40005233-CH3-SW3" title="Table 2-1MPEG-2 Performance Improvement"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>MPEG-2 Performance Improvement</caption>

<tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Optimization Step</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Speedup</p></th></tr>

<tr><td  scope="row"><p>Original</p></td><td  align="center" ><p>1.00x</p></td></tr>
<tr><td  scope="row"><p>Fast <code>floor()</code></p></td><td  align="center" ><p>1.12x</p></td></tr>
<tr><td  scope="row"><p>Integer IDCT</p></td><td  align="center" ><p>1.86x</p></td></tr>
<tr><td  scope="row"><p>Vector IDCT</p></td><td  align="center" ><p>2.05x</p></td></tr>
<tr><td  scope="row"><p>All Vector</p></td><td  align="center" ><p>5.69x</p></td></tr>
</table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../GettingStartedwithShark/GettingStartedwithShark.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../SystemTracing/SystemTracing.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-04-14<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/SharkUserGuide/TimeProfiling/TimeProfiling.html%3Fid%3DTP40005233-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/SharkUserGuide/TimeProfiling/TimeProfiling.html%3Fid%3DTP40005233-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/SharkUserGuide/TimeProfiling/TimeProfiling.html%3Fid%3DTP40005233-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>