<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Extracting Profiles Embedded in Pictures</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING70></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="ACI-69.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ACI-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ACI-122.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ACI-71.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="ACI-2.html"><B>Advanced Color Imaging on the Mac OS</B></A> / <BR><DD><A HREF="ACI-55.html"><B>Chapter 4 - Developing ColorSync-Supportive Applications</B></A> / <A HREF="ACI-60.html"><B>Developing Your ColorSync-Supportive Application</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING70-0></A>
<H2><A NAME=MARKER-9-108></A>Extracting Profiles Embedded in Pictures</H2>
 <A NAME=MARKER-2-109></A>To color match or gamut check a picture embedded in a document, your application must first extract the source profile used to create the image, if the profile is embedded in the document, then open a reference to the profile. This process entails locating and identifying the profile for the image within the document and transferring the profile data from the document file. <P>
<DL>
<DT><B>Note</B>
<DD>If you use the high-level <CODE>NCMDrawMatchedPicture</CODE> function, you do not need to extract the source profile from the PICT file.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 To extract an embedded profile, your application can use the <A NAME=MARKER-11-110></A><CODE>CMUnflattenProfile</CODE> function. This function takes a pointer to a low-level data-transfer function that your application must supply to transfer the profile data from the document containing it. This function assumes that your low-level data-transfer function is informed about the context of the profile. After all of the profile data has been transferred, the <CODE>CMUnflattenProfile</CODE> function returns the file specification for the profile. <P>
 When your application calls the <CODE>CMUnflattenProfile</CODE> function, the ColorSync Manager uses the Component Manager to pass the pointer to your low-level data-transfer function along with the reference constant your application can use as it desires. If available, the preferred CMM calls your low-level data-transfer function. (If the preferred CMM is not available, the ColorSync Manager follows the CMM selection algorithm described in <A HREF=ACI-59.html#MARKER-9-35>"How the ColorSync Manager Selects a CMM" (page 4-7)</A>, to determine which CMM to use.) The CMM calls your low-level data-transfer function, directing it to open the file containing the profile, read segments of the profile data, and return the data to the CMM's calling function. <P>
 The CMM communicates with your low-level data-transfer function using a command parameter to identify the operation to perform. To facilitate the transfer of profile data from the file to the CMM, the CMM passes to your function a pointer to a data buffer for data, the size in bytes of the profile data your function should return, and the reference constant passed from the calling application. <P>
 On return, your function passes to the CMM segments of the profile data and the number of bytes of profile data you actually return. <P>
 <A HREF=#MARKER-9-112>Listing 4-7</A> and <A HREF=#MARKER-9-119>Listing 4-8</A> show portions of a sample application called CSDemo, available as part of the ColorSync SDK. You can find the complete sample application at the following web site:<P>
<PRE>
<a href="ftp://ftp.apple.com/developer/Development_Kits/">
ftp://ftp.apple.com/developer/Development_Kits/</a>
</PRE>
 These listings assume that all variables beginning with a lowercase letter "g" are global variables previously defined. The application uses global variables to pass data between functions that do not include reference constant parameters. The listings implement two primary steps:<P>
<UL>
<LI>count the profiles in the PICT file
<LI>extract a profile <P>
</UL>
<A NAME=HEADING70-12></A>
<H3><A NAME=MARKER-9-111></A>Step 1: Count the Profiles in the PICT File </H3>
 Given a <CODE>picHandle</CODE> value to the picture containing the embedded profile, the sample code shown in <A HREF=#MARKER-9-112>Listing 4-7</A> counts the number of profiles in the picture to identify the profile to extract. <P>
 The <CODE>MyCountProfilesInPicHandle</CODE> function sets up the port and its bottlenecks and initializes its global counter, which holds a single count summing both ColorSync 1.0 profiles and version 2.x profiles. <CODE>MyCountProfilesInPicHandle</CODE> counts the number of profiles as the picture is being drawn, using the MyCountProfilesCommentProc bottleneck procedure. <CODE>MyCountProfilesInPicHandle</CODE> doesn't use any other bottlenecks, so it defines nonoperational routines for them. For example, the <CODE>TextProc</CODE> bottleneck can be defined as follows: <P>
<PRE>
static pascal void TextProc (short byteCount, Ptr textAddr, 
                      Point numer, Point denom);
</PRE>
 <CODE>MyCountProfilesInPicHandle</CODE> calls its own<CODE> MyDrawPicHandleUsingBottleneck</CODE> function, not shown here, to draw the picture using the bottleneck routines. Because it must increment the <CODE>gCount</CODE> global counter for both ColorSync 1.0 profiles and version 2.x profiles, <CODE>MyCountProfilesCommentProc</CODE> checks for both types of profiles. <P>
<B>Listing 4-7  <A NAME=MARKER-9-112></A>Counting the number of profiles in a picture </B><P>
<PRE>
CMError MyCountProfilesInPicHandle (PicHandle pict, unsigned long *count)
{
   OSErr    err = noErr;
   CQDProcs procs;

   /* set up bottleneck for picComments so we can count the profiles */
   SetStdCProcs(&amp;procs);
   procs.textProc= NewQDTextProc (MyNoOpTextProc);
   procs.lineProc= NewQDLineProc (MyNoOpLineProc);
   procs.rectProc= NewQDRectProc (MyNoOpRectProc);
   procs.rRectProc = NewQDRRectProc (MyNoOpRRectProc);
   procs.ovalProc = NewQDOvalProc (MyNoOpOvalProc);
   procs.arcProc = NewQDArcProc (MyNoOpArcProc);
   procs.polyProc = NewQDPolyProc (MyNoOpPolyProc);
   procs.rgnProc = NewQDRgnProc (MyNoOpRgnProc);
   procs.bitsProc = NewQDBitsProc (MyNoOpBitsProc);
   procs.commentProc = NewQDCommentProc (MyCountProfilesCommentProc);
   procs.txMeasProc = NewQDTxMeasProc (MyNoOpTxMeasProc);

/* initialize the global counter to be incremented by the commentProc*/
   gCount = 0;

/* draw the picture and count the profiles while drawing */
   err = MyDrawPicHandleUsingBottlenecks (pict, procs, nil);

/* obtain the result from the count global variable */
   *count = gCount;

/* clean up and return*/
   DisposeRoutineDescriptor(procs.textProc);
   DisposeRoutineDescriptor(procs.lineProc);
   DisposeRoutineDescriptor(procs.rectProc);
   DisposeRoutineDescriptor(procs.rRectProc);
   DisposeRoutineDescriptor(procs.ovalProc);
   DisposeRoutineDescriptor(procs.arcProc);
   DisposeRoutineDescriptor(procs.polyProc);
   DisposeRoutineDescriptor(procs.rgnProc);
   DisposeRoutineDescriptor(procs.bitsProc);
   DisposeRoutineDescriptor(procs.commentProc);
   DisposeRoutineDescriptor(procs.txMeasProc);
}

pascal void MyCountProfilesCommentProc (short kind,
                              short dataSize,
                              Handle dataHandle)
{
   long  selector;

   switch (kind)
   {
      case cmBeginProfile
         gCount ++;           /* we found a ColorSync 1.0 profile */
                              /* increment the counter*/
         break;

      case cmComment; 
         if (dataSize &lt;= 4) break;/* dataSize is too small for selector
                               so break and get the selector 
                               from the first long */
         selector = *((long *)(*dataHandle));
         if (selector == cmBeginProfileSel) 
            gCount ++;        /* we found a version 2 profile; increment
                                 the counter */
            break;               
   }
}
</PRE>
<A NAME=HEADING70-19></A>
<H3><A NAME=MARKER-9-113></A>Step 2: Extract the Profile</H3>
 This part of the sample application identifies the profile to flatten, flattens the profile, and creates a temporary profile disposing of the original one. To perform these tasks, the code must again draw the picture using the bottleneck routines.<P>
<A NAME=HEADING70-21></A>
<H4><A NAME=MARKER-9-114></A>Part A: Calling the Unflatten Function </H4>
 <A HREF=#MARKER-9-119>Listing 4-8</A> shows the MyGetIndexedProfileFromPicHandle entry point function that drives the process of unflattening the profile. The function creates a universal procedure pointer (UPP), <CODE>MyflattenUPP</CODE>, that points to the low-level data-transfer procedure. <P>
 A PICT handle may contain more than one profile. To identify the profile to unflatten, the <CODE>MyGetIndexedProfileFromPicHandle</CODE> function contains an <CODE>index</CODE> parameter that passes in the profile's index. The function stores the index in the global variable <CODE>gIndex</CODE> so that the value is accessible by the application's other functions that check for the correct profile and extract it. Then, the function calls the <CODE>CMUnflattenProfile</CODE> function, passing it the <CODE>MyflattenUPP</CODE> pointer. This invokes the <CODE>MyUnflattenProc</CODE> function shown in <A HREF=#MARKER-9-125>Listing 4-9</A>.<P>
 After calling <CODE>CMUnflattenProfile</CODE>, the <A NAME=MARKER-11-121></A>MyGetIndexedProfileFromPicHandle function calls the <CODE>CMOpenProfile</CODE> function to open a reference to the file-based profile; then it calls <CODE>CMCopyProfile</CODE> to create a temporary profile. Finally, the function disposes of the original profile. To adhere to the copyright protection for embedded profiles specified by the <CODE>flags</CODE> field in the profile header, <A NAME=MARKER-11-121></A>MyGetIndexedProfileFromPicHandle creates a temporary profile and disposes of the original. <P>
<B>Listing 4-8  Calling the unflatten profile function to extract an embedded profile<A NAME=MARKER-9-119></A></B><P>
<PRE>
CMError MyGetIndexedProfileFromPicHandle (PicHandle pict,
                                 unsigned long index,
                                 CMProfileRef *prof,
                                 CMProfileLocation *profLoc)
{
   unsigned long  refCon;
   CMFlattenUPP   MyflattenUPP;
   CMError        cmErr = noErr;
   Boolean        preferredCMMNotFound;
   FSSpec         tempSpec;
   CMProfileRef   tempProf;
   CMProfileLocation tempProfLoc;

   /* create a universal procedure pointer for unflatten procedure */
   MyflattenUPP = NewCMFlattenProc(MyUnflattenProc);

   /* following assumes that index &lt;= count */

   refCon = (unsigned long) pict;
   gIndex = index;   


   /* next call invokes the MyUnflattenProc shown in Listing 4-9 */
   cmErr = CMUnflattenProfile(&amp;tempSpec, MyflattenUPP,(void*)&amp;refCon, 
                        &amp;preferredCMMNotFound);
   DisposeRoutineDescriptor(MyflattenUPP);

   if (cmErr)
      return cmErr;

   tempProfLoc.locType = cmFileBasedProfile;
   tempProfLoc.u.fileLoc.spec = tempSpec;
   cmErr = CMOpenProfile(&amp;tempProf, &amp;tempProfLoc);
   if (cmErr)
      return cmErr;
   cmErr = CMCopyProfile(prof, profLoc, tempProf);
   cmErr = CMCloseProfile(tempProf);
   cmErr = FSpDelete(&amp;tempSpec);

   return cmErr;
}
</PRE>
<A NAME=HEADING70-29></A>
<H4><A NAME=MARKER-9-120></A>Part B: Calling the Unflatten Function</H4>
 When the code in <A NAME=MARKER-11-121></A><A NAME=MARKER-2-122></A>MyGetIndexedProfileFromPicHandle (<A HREF=#MARKER-9-119>Listing 4-8</A>) calls the <CODE>CMUnflattenProc</CODE> function, passing it a pointer to the <CODE>MyUnflattenProc</CODE> function, the <CODE>MyUnflattenProc</CODE> function (<A HREF=#MARKER-9-125>Listing 4-9</A>) is called by the CMM to perform the low-level profile data transfer from the document file. <P>
 When the CMM calls this function with an open command, the function initializes global variables, creates a graphics world, and installs bottleneck procedures in the graphics world. The only bottleneck procedure actually used is <CODE>MyUnflattenProfilesCommentProc</CODE>, which checks the picture comments as the picture is drawn offscreen to identify the desired profile. <P>
 When the CMM calls the MyUnflattenPro<CODE>c</CODE> function with a read command, the function reads the appropriate segment of data from a chunk and returns it. To accomplish this, it calls the MyDrawPicHandleUsingBottlenecks function with the appropriate bottleneck procedure installed. In turn, this invokes the <CODE>MyUnflattenProfilesCommentProc</CODE> shown in <A HREF=#MARKER-9-126>Listing 4-10</A>.<P>
 When the CMM calls <A NAME=MARKER-11-123></A><A NAME=MARKER-2-124></A>MyUnflattenProc with a close command, the function releases any memory it allocated and disposes of the graphics world and bottlenecks. <P>
<B>Listing 4-9  <A NAME=MARKER-9-125></A>The unflatten procedure</B><P>
<PRE>
pascal OSErr MyUnflattenProc (long command,
                        long *sizePtr,
                        void *dataPtr,
                        void *refConPtr)
{
   OSErr             err = noErr;
   static CQDProcs   procs;
   static GWorldPtr  offscreen;
   PicHandle         pict;
   switch (command)
   {
      case cmOpenReadSpool:
         err = NewSmallGWorld(&amp;offscreen);
         if (err)
            return err;
         SetStdCProcs(&amp;procs);
         procs.textProc    = NewQDTextProc (MyNoOpTextProc);
         procs.lineProc    = NewQDLineProc (MyNoOpLineProc);
         procs.rectProc    = NewQDRectProc (MyNoOpRectProc);
         procs.rRectProc   = NewQDRRectProc (MyNoOpRRectProc);
         procs.ovalProc    = NewQDOvalProc (MyNoOpOvalProc);
         procs.arcProc     = NewQDArcProc (MyNoOpArcProc);
         procs.polyProc    = NewQDPolyProc (MyNoOpPolyProc);
         procs.rgnProc     = NewQDRgnProc (MyNoOpRgnProc);
         procs.bitsProc    = NewQDBitsProc(MyNoOpBitsProc);
         procs.commentProc = NewQDCommentProc (MyUnflattenProfilesCommentProc);
         procs.txMeasProc  = NewQDTxMeasProc (MyNoOpTxMeasProc);

         gChunkBaseHndl = nil;
         gChunkIndex = 0;
         gChunkOffset = 0;
         gChunkSize = 0;
         break;

   case cmReadSpool:
      if (gChunkOffset &gt; gChunkSize)/* if we overread the last chunk */
      {
         return ioErr;           /* use system I/O error value */
      }
      if (gChunkOffset == gChunkSize)/* if we used up the last chunk */
      {
         if (gChunkBaseHndl !=nil)
         {
            HUnlock(gChunkBaseHndl);/* dispose of the previous chunk */
            DisposeHandle(gChunkBaseHndl);
            gChunkBaseHndl = nil;
         }
         gChunkIndex++;       /* read in a new chunk */
         gChunkOffset = 0;
         gCount = 0;
         gChunkCount = 0;
         pict = *((PicHandle *)refConPtr);
         err = MyDrawPicHandleUsingBottlenecks (pict, procs, offscreen);
                     /* this invokes MyUnflattenProfilesCommentProc shown in
                        Listing 4-10 */
         if (gChunkBaseHndl==nil)/* check to see if we're overread */
            return ioErr;     /* if so, return system I/O error value */
         HLock(gChunkBaseHndl);
      }
      if (gChunkOffset &lt; gChunkSize)
      {
         *sizePtr = MIN(gChunkSize-gChunkOffset, *sizePtr);
         BlockMove((Ptr)(&amp;((*gChunkBaseHndl)[gChunkOffset])),
            (Ptr)dataPtr, *sizePtr);
         gChunkOffset += (*sizePtr);
      }
      break;
      case cmCloseSpool:
         if (gChunkBaseHndl != nil) 
         {
            HUnlock(gChunkBaseHndl);/* dispose of the previous chunk */
            DisposeHandle(gChunkBaseHndl);
            gChunkBaseHndl = nil;
         }
         DisposeGWorld(offscreen);
         DisposeRoutineDescriptor(procs.TextProc);
         DisposeRoutineDescriptor(procs.LineProc);
         DisposeRoutineDescriptor(procs.RectProc);
         DisposeRoutineDescriptor(procs.RRectProc);
         DisposeRoutineDescriptor(procs.OvalProc);
         DisposeRoutineDescriptor(procs.ArcProc);
         DisposeRoutineDescriptor(procs.PolyProc);
         DisposeRoutineDescriptor(procs.RgnProc);
         DisposeRoutineDescriptor(procs.BitsProc);
         DisposeRoutineDescriptor(procs.MyUnflattenProfilesCommentProc);
         DisposeRoutineDescriptor(procs.txMeasProc);
         break;
      default:
         break;
   }
   return err;
}
</PRE>
<A NAME=HEADING70-40></A>
<H4>Part C: Calling the Comment Procedure </H4>
 When the <CODE>MyUnflattenProc</CODE> function's <CODE>MyDrawPicHandleUsingBottlenecks </CODE>function calls the <CODE>MyUnflattenProfilesCommentProc</CODE> function, the function shown in <A HREF=#MARKER-9-126>Listing 4-10</A> finds the profile identified by the index, finds the correct segment of data within the profile, and stores the data in the <CODE>gChunkBaseHndl</CODE> global variable. <P>
<B>Listing 4-10  <A NAME=MARKER-9-126></A>The comment procedure</B><P>
<PRE>
pascal void MyUnflattenProfilesCommentProc (short kind,
                                 short dataSize,
                                 Handle dataHandle)
{
   long  selector;
   OSErr err;

   if (gChunkBaseHndl != nil) return;
            /* the handle is in use; this shouldn't happen */
   if (gCount &gt; gIndex) return;
            /* we have already found the profile */
   switch (kind)
   {
   case cmBeginProfile:
      gCount ++;     /* we found a version 1 profile */
      gChunkCount = 1;/* v1 profiles should only have 1 chunk */
      if (gCount != gIndex) break;
                     /* this is not the profile we're looking for */
      if (gChunkCount != gChunkIndex) break;
                     /* this is not the chunk we're looking for */
      gChunkBaseHndl = dataHandle;
      err = HandToHand(&amp;gChunkBaseHndl);
      gChunkSize = dataSize;
      gChunkOffset = 0;
      break;

   case cmComment:
      if (dataSize &lt;= 4) break;
                     /* the dataSize too small for selector, so break */
      selector = *((long *)(*dataHandle));
                     /* get the selector from the first long in data */
      switch (selector)
      {
         case cmBeginProfileSel:
            gCount ++;        /* we found a version 2 profile */
            gChunkCount = 1;
            if (gCount != gIndex) break;
                           /* this is not the profile we're looking for */
            if (gChunkCount!=gChunkIndex) break;
                           /* this is not the chunk we're looking for */
            gChunkBaseHndl = dataHandle;
            err = HandToHand(&amp;gChunkBaseHndl);
            gChunkSize = dataSize;
            gChunkOffset = 4;
            break;

         case cmContinueProfileSel:
            gChunkCount ++;
            if (gCount != gIndex) break;
                           /* this is not the profile we're looking for */
            if (gChunkCount!=gChunkIndex) break;
                           /* this is not the chunk we're looking for */
            gChunkBaseHndl = dataHandle;
            err = HandToHand(&amp;gChunkBaseHndl);
            gChunkSize = dataSize;
            gChunkOffset = 4;
            break;

         case cmEndProfileSel:
                           /* check to see if we're overreading */
            gChunkCount = 0;
            break;
      }
      break;
   }     
}
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="ACI-69.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ACI-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ACI-122.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ACI-71.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="ACI-3.html">&copy; Apple Computer, Inc.</A><br>13 NOV 1996<P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML> 
