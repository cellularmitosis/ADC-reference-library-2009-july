/*	File: ColorPopUpMenus.c	Contains:	This file contains an example illustrating how to show swatches	of color in a labels-like menu in your own application.  It also illustrates	how to add a user adjustable color item to the menu that can be changed by	way of the color picker interface.		Behind the scenes, the color swatches in the menu are implemented as color	icon resources.  The only real tricky part here is finding the correct place	to save the color in the color icon resource.  And, two routines have been	provided that do just that. 	Written by: John Montbriand	Copyright:	Copyright © 1999 by Apple Computer, Inc., All Rights Reserved.	You may incorporate this Apple sample source code into your program(s) without	restriction. This Apple sample source code has been provided "AS IS" and the	responsibility for its operation is yours. You are not permitted to redistribute	this Apple sample source code as "Apple sample source code" after having made	changes. If you're going to re-distribute the source, we require that you make	it clear in the source that the code was descended from Apple sample source	code, but that you've made changes.	Change History (most recent first):	7/19/1999 Karl Groethe - Updated for Metrowerks Codewarror Pro 2.1	10/7/1999 John Montbriand - removed bad menu resource definition, rewrote the rest :)*/#include "ColorPopUpMenus.h"#include <Dialogs.h>#include <Fonts.h>#include <Sound.h>#include <Resources.h>#include <ColorPicker.h>#include <Icons.h>#include <Errors.h>#include <StdDef.h>#ifndef __MWERKS__QDGlobals	qd; /* QuickDraw globals */#endif	/* gUserSelectColor is our internal copy of the user adjustable	color.  The adjustable item is initially set to this value, and	it can be adjusted by the user when ever they choose the 'Other...'	item in the pop-up menu. */RGBColor gUserSelectColor = { 0xACAC, 0xACAC, 0xACAC };	/* gUserSelectColorIcon is a handle to color icon that is used	to display the user adjustable color swatch in the 'Other...'	item in the pop-up menu. */CIconHandle gUserSelectColorIcon = NULL;/* ChangeCIconIXColor changes the index'th color in the	color icon's clut to *color. if index is out of range, then	paramErr is returned.  It'll work for any size color	icon. */	static OSErr ChangeCIconIXColor(CIconHandle cicn, short index, RGBColor *color) {	unsigned char *rover;	CTabPtr clutp;	char state;	OSErr err;		/* make sure it's in memory */	LoadResource((Handle) cicn);	if ((err = ResError()) != noErr) return err;		/* lock down the handle, we're making toolbox calls while		using a pointer to some of it's contents.  We may know that		routine probably doesn't move memory, but it's always best		to take a conservative position.  */	state = HGetState((Handle) cicn);	HLock((Handle) cicn);			/* increment to the clut in the cicn resource.  see GetCIconIXColor		for the book reference for the format spec. */	rover = ((unsigned char *) (*cicn)) + offsetof(CIcon, iconMaskData);	rover += (**cicn).iconMask.rowBytes * (**cicn).iconMask.bounds.bottom;	rover += (**cicn).iconBMap.rowBytes * (**cicn).iconBMap.bounds.bottom;	clutp = (CTabPtr) rover;			/* check to make sure the index is in range */	if ((index < 0) || (index > clutp->ctSize)) {			/* index out of range */		err = paramErr;	} else {			/* set the clut entry */		clutp->ctTable[index].rgb = *color;						/* reset the ctSeed value so QuickDraw with identify			the color table as 'unique'. */		clutp->ctSeed = GetCTSeed();					/* no problem...*/		err = noErr;	}				/* restore the resource handle's state */	HSetState((Handle) cicn, state);			/* done */	return err;}/* GetCIconIXColor retrieves the index'th color from the	color icon's clut.  if index is out of range, then paramErr is returned.		This routine isn't used in this example, but I added it as a	symetrical counterpart to ChangeCIconIXColor incase someone might	find it useful.  Normally, the UI will only reflect the state	of your program's internal state variables so there's no need	to query the interface elements for values being displayed. */	static OSErr GetCIconIXColor(CIconHandle cicn, short index, RGBColor *color) {	unsigned char *rover;	CTabPtr clutp;	OSErr err;			/* make sure it's in memory */	LoadResource((Handle) cicn);	if ((err = ResError()) != noErr) return err;			/* find the color table inside of the cicn resource.		The resource we're using in this example has a two		element color table.  Here, we're incrementing a		pointer past the structures in the cicn resource.		This structure is defined in the Color QuickDraw		chapter of Inside Macintosh.  That page can be		found on the web at:			http://developer.apple.com/techpubs/mac/QuickDraw/QuickDraw-268.html.  */	rover = ((unsigned char *) (*cicn)) + offsetof(CIcon, iconMaskData);	rover += (**cicn).iconMask.rowBytes * (**cicn).iconMask.bounds.bottom;	rover += (**cicn).iconBMap.rowBytes * (**cicn).iconBMap.bounds.bottom;	clutp = (CTabPtr) rover;			/* check the index range */	if ((index < 0) || (index > clutp->ctSize)) return paramErr;			/* save the color */	*color = clutp->ctTable[index].rgb;			/* done */	return noErr;}	/* main program.  Here, we put up a modal dialog.  When ever	the user picks the configurable color item in the menu, we	put up the color picker to allow them to adjust the color. */int main (void) {	DialogPtr dialog;	short itemHit;		/* set up the managers */	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);		/* set up the user adjustable color swatch.  We'll		initially set the color displayed to our own default		color setting. Note, we call 'GetResource' instead		of 'GetCIcon'.  When the control is created in the 		GetNewDialog call, GetCIcon will be called. */	gUserSelectColorIcon = (CIconHandle) GetResource('cicn', kOtherIconRsrc);	if (gUserSelectColorIcon == NULL) return 1;	ChangeCIconIXColor(gUserSelectColorIcon, kOutClutColorIndex, &gUserSelectColor);		/* call up the dialog containing our color choice menu. */	dialog = GetNewDialog(kMainDialog,nil,nil);	if (dialog == NULL) return 1;	SetDialogTracksCursor(dialog, true);	SetDialogDefaultItem(dialog, kMainOK);		/* loop and process dialog events */	do {				ModalDialog(NULL, &itemHit);					/* check to see if it's a hit in the menu item */		if (itemHit == kMainPopUp) {			short itemt;			ControlHandle itemc;			Rect itemb;			RGBColor inColor, outColor;			Point pickerWhere = { -1, -1 };							/* it's a hit in the menu, now test to see if the				adjustable color item was selected */			GetDialogItem(dialog, kMainPopUp, &itemt, (Handle *) &itemc, &itemb);			if (GetControlValue(itemc) == kMainPopUpOtherItem) {									/* let the user adjust the color for this item */				inColor = outColor = gUserSelectColor;				if (GetColor(pickerWhere, "\pPick a color for the menu item.", &inColor, &outColor)) {											/* if they didn't cancel out of the color picker window,						then save the color back in to our global. */					gUserSelectColor = outColor;											/* ...then save the color back into the icon's color						table. */					ChangeCIconIXColor(gUserSelectColorIcon, kOutClutColorIndex, &gUserSelectColor);						/* ...and finally, redraw the control.  This will						redraw the menu in the control, which, in turn,						will redraw the color icon with it's new color setting.*/					Draw1Control(itemc);				}			}		}	} while (itemHit != kMainOK);					/* clean up and leave */	DisposeDialog (dialog);	return 0;}