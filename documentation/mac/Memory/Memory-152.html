<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>About the Virtual Memory Manager (IM: M)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING152></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Memory-151.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-153.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Memory-2.html"><B>Memory</B></A> / <BR><DD><A HREF="Memory-151.html"><B>Chapter 3 - Virtual Memory Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING152-0></A>
<H1>About the Virtual Memory Manager</H1>
 <A NAME=MARKER-2-23></A>The Virtual Memory Manager is the part of the Operating System that provides <B>virtual memory,</B> addressable memory beyond the limits of the available physical RAM. The principal benefit of using virtual memory is that a user can run more applications at once and work with larger amounts of data than would be possible if the logical address space were limited to the available RAM. Instead of equipping a computer with amounts of RAM large enough to handle all possible needs, the user can install only enough RAM to meet average needs. Then, during those occasional times when more memory is needed for large tasks or many applications, the user can take advantage of virtual memory. When virtual memory is present, the perceived amount of RAM can be extended to as much as 14 MB on systems with 24-bit addressing and as much as 1 GB on systems with 32-bit addressing.<P>
 The Virtual Memory Manager also provides a number of routines that your software can use to modify or get information about its operations. You can use the Virtual Memory Manager to<P>
<UL>
<LI>hold portions of the logical address space in physical RAM
<LI>lock portions of the logical address space in their physical RAM locations
<LI>determine whether a particular portion of the logical address space is currently in physical RAM
<LI>determine, from a logical address, the physical address of a block of memory<P>
</UL>
 This section describes how the Virtual Memory Manager provides virtual memory. It also explains why you might need to use certain Virtual Memory Manager routines even when virtual memory is not available.<A NAME=MARKER-2-24></A><P>
<A NAME=HEADING152-8></A>
<H2>Virtual Memory</H2>
 The Virtual Memory Manager extends the logical address space by using part of the available secondary storage (such as a hard disk) to hold portions of applications and data that are not currently in use in physical memory. When an application needs to operate on portions of memory that have been transferred to disk, the Virtual Memory Manager loads those portions back into physical memory by making them trade places with other, unused segments of memory. This process of moving portions (or <B>pages</B>) of memory between physical RAM and the hard disk is called <B>paging.</B><A NAME=MARKER-2-25></A><A NAME=MARKER-2-26></A><P>
 For the most part, the Virtual Memory Manager operates invisibly to applications and to the user. Most applications do not need to know whether virtual memory is installed unless they have critical timing requirements, execute code at interrupt time, or perform debugging operations. The only time that users need to know about virtual memory is when they configure it in the Memory control panel. One visible cost of this extra memory is the use of an equivalent amount of storage on a storage device, such as a SCSI hard disk. Another cost of using virtual memory is a possible perception of sluggishness as paged-out segments of memory are pulled back into physical memory. Performance degradation due to the use of virtual memory ranges from unnoticeable to severe, depending on the ratio of virtual memory to physical RAM and the behavior of the actual applications running.<P>
 <A NAME=MARKER-2-28></A><A NAME=MARKER-2-29></A><A NAME=MARKER-2-30></A><A NAME=MARKER-2-31></A><A NAME=MARKER-9-166></A><A NAME=MARKER-2-33></A>There are two main requirements for running virtual memory. First, the computer must be running system software version 7.0 or later. Second, the computer must be equipped with an <B>MMU</B> or <B>PMMU</B> coprocessor. Apple's 68040- and 68030-based machines have an MMU built into the CPU and are ready to run virtual memory with no additional hardware. A Macintosh II (68020-based) computer can take advantage of virtual memory if it has the 68851 PMMU coprocessor on its main logic board in place of the standard <B>Address Management Unit (AMU).</B> (The PMMU is the same coprocessor needed to run A/UX.) Apple's 68000-based machines cannot take advantage of virtual memory.<A NAME=MARKER-2-34></A><P>
 Users control and configure virtual memory through the Memory control panel. Controls in this panel allow the user to turn virtual memory on or off, set the size of virtual memory, and set the volume on which the invisible backing-store file resides. (The <B>backing-store file</B> is the file in which the Operating System stores the contents of nonresident pages of memory.) Other memory-related user controls appear in this control panel. These include settings for the disk cache and for 24-bit or 32-bit Memory Manager addressing. If users change the virtual memory, addressing, or disk cache settings, they must restart the computer for the changes to take effect.<A NAME=MARKER-2-35></A><A NAME=MARKER-2-36></A><A NAME=MARKER-2-37></A><P>
 The virtual memory setting in the control panel reflects the total amount of memory available to the system (and not simply the amount of memory to be added to available RAM). Also, the backing-store file is as large as the amount of virtual memory. This backing-store file can be located on any HFS volume that allows block-level access. (This volume is known as the <B>paging device</B> or <B>backing volume.</B>) Because the paging device must support block-level access, users cannot select as the paging device a volume mounted through AppleShare. Also, users cannot select removable disks, including floppy disks, as paging devices.<A NAME=MARKER-2-38></A><A NAME=MARKER-2-39></A><A NAME=MARKER-2-40></A><A NAME=MARKER-2-41></A><A NAME=MARKER-2-42></A><P>
<A NAME=HEADING152-14></A>
<H2>The Logical Address Space<A NAME=MARKER-2-43></A></H2>
 <A NAME=MARKER-2-159></A>When virtual memory is present, the logical address space is larger than the physical address space provided by the available RAM. The actual size of the logical address space, and hence the amount of virtual memory, depends on a number of factors, including<A NAME=MARKER-2-45></A><P>
<UL>
<LI>the addressing mode currently used by the Memory Manager
<LI>the amount of space available on a secondary storage device for use by the backing-store file
<LI>if 24-bit addressing is in operation, the number of NuBus expansion cards, if any, installed in the computer<P>
</UL>
<A NAME=HEADING152-19></A>
<H3>24-Bit Addressing</H3>
 <A NAME=MARKER-2-176></A>When running with <B>24-bit addressing,</B> the Memory Manager can address at most <BR>2<EM>24</EM> bytes, or 16 MB. Of these 16 MB, at most 8 MB can be used to address physical RAM. The remaining 8 MB are devoted to ROM addresses, I/O device addresses, and NuBus slot addresses. <DFN><A HREF=#MARKER-9-47>Figure 3-1</A></DFN> illustrates the logical address space mapping used by the 24-bit Memory Manager.<P>
<DL>
<DT><B>Note</B>
<DD>In some Macintosh computers, the ROM is mapped to the address range $01000000 to $010FFFFF (indicated as belonging to slot $A in <A HREF=#MARKER-9-47>Figure 3-1</A>). In these computers, the maximum amount of physical RAM is 10 MB instead of 8 MB. The remainder of this section describes the original layout of the 24-bit logical address space only.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<B>Figure 3-1  <A NAME=MARKER-9-47></A>24-bit Memory Manager logical address space</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/VM-01.jpg"><P></P>
 When 24-bit addressing is in operation and virtual memory is available, the Virtual Memory Manager uses, as part of the addressable application memory, any 1 MB segments not assigned to a NuBus card. For example, if a Macintosh computer has three NuBus expansion cards installed, that computer can address at most 11 MB of virtual memory. The maximum amount of virtual memory possible in a 24-bit environment is <BR>14 MB (that is, 8 MB of physical RAM + 6 MB of additional space previously reserved for the NuBus); this maximum is achievable only on a computer with no NuBus expansion cards installed.<P>
 Notice in <A HREF=#MARKER-9-47>Figure 3-1</A> that addresses from $00800000 to $008FFFFF are reserved for ROM. In other words, the largest contiguous block of space that an application can allocate when virtual memory is available is somewhat less than 8 MB, even though the total amount of virtual memory available can be as large as 14 MB. The rest of the virtual memory can be in a contiguous block as large as 4 or 5 MB, unless the user has fragmented the NuBus space by making a poor choice of slots in which to install expansion cards. To maximize the amount of contiguous virtual memory, users should place cards in consecutive slots at either end of the expansion bus. A haphazard placement of NuBus cards may result in a number of 1 MB or 2 MB "islands" in the upper portion of the 24-bit address space; in general, this kind of fragmentation reduces the effectiveness of a large virtual address space.<P>
<DL>
<DT><B>Note</B>
<DD>Some Macintosh computers have fewer than six NuBus slots, and the numbering of the slots is not consistent across different models. In a Macintosh IIcx, the three available slots are numbered $9 through $B, so expansion cards should be grouped toward the lowest-numbered slot (contiguous with the ROM space). In a Macintosh IIci, the slots are numbered $C through $E, so expansion cards should be grouped toward the highest-numbered slot (contiguous with the I/O space). However, the RAM-based video on the Macintosh IIci occupies addresses reserved for slot $B; as a result, it is impossible to avoid some degree of fragmentation of the virtual address space when you use the RAM-based video option on that computer.<EM></EM><A NAME=MARKER-2-48></A><A NAME=MARKER-9-209></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING152-27></A>
<H3>32-Bit Addressing</H3>
 <A NAME=MARKER-2-50></A>When running with <B>32-bit addressing,</B> the Memory Manager can address at most <BR>2<EM>32</EM> bytes, or 4 GB. Of these 4 GB, at most 1 GB can be used to address physical RAM. The remaining 3 GB are devoted to ROM addresses, I/O device addresses, and NuBus slot addresses. <DFN><A HREF=#MARKER-9-52>Figure 3-2</A></DFN> illustrates the logical address space mapping used by the 32-bit Memory Manager.<A NAME=MARKER-2-51></A><P>
<B>Figure 3-2  <A NAME=MARKER-9-52></A>32-bit Memory Manager logical address space</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/VM-02.jpg">
<DL>
<DT><B>Note</B>
<DD>The fragmentation of the virtual address space that sometimes occurs when 24-bit addressing is in operation is never a problem when 32-bit addressing is in operation. In the 32-bit address space, virtual memory and the NuBus slots do not share space.<EM></EM><A NAME=MARKER-2-53></A><A NAME=MARKER-2-168></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING152-32></A>
<H2><A NAME=MARKER-9-55></A>The Physical Address Space</H2>
 <A NAME=MARKER-2-136></A>The original versions of the Macintosh Operating System used physical addresses exclusively. A particular location in RAM could be accessed by its physical address, regardless of whether that address was generated by an application, by the system software, or even by a NuBus expansion card. In short, there was no difference between the logical and the physical address spaces.<P>
 However, both hardware and software advances have forced the Operating System <BR>to abstract the logical address space from the physical address space. As you have seen, the logical address space is larger than the physical address space when virtual memory is available. The Operating System uses the MMU coprocessor to map logical addresses to their corresponding physical addresses.<P>
 In addition, some Macintosh computers have a discontiguous physical address space. For example, on a Macintosh IIci with 8 MB of physical RAM, the physical memory appears to the CPU and to the NuBus expansion bus as two separate 4 MB ranges <BR>(see <A HREF=#MARKER-9-58>Figure 3-3</A>). As you can see, the physical RAM occupies two separate ranges: <BR>the RAM installed in bank A, ranging from $00000000 to $003FFFFF, and the RAM installed in bank B, ranging from $04000000 to $043FFFFF.<A NAME=MARKER-2-173></A><P>
<B>Figure 3-3  <A NAME=MARKER-9-58></A>The physical address space on a Macintosh IIci with 8 MB of RAM</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/VM-03.jpg"><P></P>
 In most cases, a discontiguous physical address space causes no problems, because the Operating System uses the MMU coprocessor to map the available physical memory into a single contiguous logical address space. All memory addresses returned to your application by the Memory Manager (for instance, when you allocate a new block by calling <CODE>NewHandle</CODE>) are logical addresses. When you read or write a logical memory address, the Operating System uses the MMU coprocessor to determine the physical address corresponding to your logical address. This address translation is completely transparent to your application. For example, if you read the system global variable located at address $10C, it doesn't matter that the CPU actually looks at the physical address $0400010C.<P>
 In some cases, however, you can run into problems if you don't account for the possibility that the logical address space and the physical address space might differ. Suppose, for instance, that you are developing a driver that passes addresses to NuBus master hardware. In this case, you need to take care to pass it <I>physical</I> addresses only, because NuBus hardware does not use the MMU to translate logical addresses into physical addresses. If your driver passes a logical address, the NuBus hardware cannot translate it into a physical address because it does not have access to the MMU's address-mapping tables. If your hardware then attempts to write data to that address, it is likely to overwrite some other portion of physical memory.<P>
 To prevent this problem, you need to make certain that you always convert logical addresses to their corresponding physical addresses before you pass those addresses to any alternate bus master. You can do this by calling the <CODE>GetPhysical</CODE> function, as described later in <A HREF=Memory-153.html#MARKER-9-114>"Mapping Logical to Physical Addresses,"</A> which begins on <A HREF=Memory-153.html#MARKER-9-114>page 3-16</A>. The <CODE>GetPhysical</CODE> function is implemented in ROM on all machines that have a discontiguous physical address space--whether or not virtual memory is available. Accordingly, before you pass addresses to an alternate bus master, you should check for the availability of the <CODE>GetPhysical</CODE> call; if it's available, you should use it to translate logical to physical addresses.<A NAME=MARKER-2-222></A><A NAME=MARKER-2-5></A><P>
<DL>
<DT><B>Note</B>
<DD>Passive or slave NuBus cards (such as video cards) that do not read or write physical RAM are not likely to be affected by the presence of virtual memory or by a discontiguous physical address space.<EM></EM><A NAME=MARKER-2-61></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING152-42></A>
<H2>Page Faults</H2>
 When an application or other software component tries to access data in a page of memory that is not currently resident in RAM, the Operating System issues a special kind of bus error known as a <B>page fault.</B> The Virtual Memory Manager intercepts page faults and tries to load the affected page or pages into memory. It does so by executing its own internal page-fault handler, which handles page faults and passes other bus errors to the standard bus-error vector in low memory.<A NAME=MARKER-2-62></A><A NAME=MARKER-2-134></A><P>
 To load the required pages into memory, the Virtual Memory Manager's page-fault handler takes over the SCSI bus and makes calls directly to the driver of the backing-store file. While the Virtual Memory Manager is handling a page fault, it is essential that no other page faults occur. If a page fault did occur during page-fault handling--a condition known as a <B>double page fault</B>--the Virtual Memory Manager would have to interrupt the driver of the paging device to make a further request to load the needed page. Unless the driver of the paging device is <B>concurrent</B> (that is, able to handle several requests at once), the driver cannot handle this second request. Unfortunately, current versions of most SCSI disk drivers are not concurrent. As a result, a double page fault results in a system crash.<A NAME=MARKER-2-64></A><A NAME=MARKER-2-6></A><A NAME=MARKER-2-66></A><P>
 The Virtual Memory Manager takes special steps to avoid double page faults caused by user code (that is, code that is not executed as the result of an exception). It defers all user code while the driver of the paging device is busy. In particular, the Virtual Memory Manager defers until a safe time the following types of code:<A NAME=MARKER-2-67></A><P>
<UL>
<LI>VBL tasks<A NAME=MARKER-2-68></A>
<LI>Slot-based VBL tasks<A NAME=MARKER-2-212></A>
<LI>Time Manager tasks<A NAME=MARKER-2-70></A>
<LI>I/O completion routines<A NAME=MARKER-2-71></A><P>
</UL>
<DL>
<DT><B>Note</B>
<DD>Because these types of tasks may be deferred under virtual memory, <BR>any application or device driver that uses them to achieve real-time performance might be adversely affected by the operation of the Virtual Memory Manager.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Other software components must take care not to cause page faults at interrupt time. In particular, device drivers, which commonly run at interrupt time, should make certain that any data structures or buffers that they reference at interrupt time are in physical memory at that time. You can make sure that this happens by holding the required data in physical memory, as described in <A HREF=Memory-153.html#MARKER-9-88>"Holding and Releasing Memory" </A>on <A HREF=Memory-153.html#MARKER-9-88>page 3-14</A>.<A NAME=MARKER-2-72></A><P>
 In an effort to maintain compatibility with existing drivers, the Operating System automatically keeps the entire system heap in physical memory at all times. Therefore, <BR>if your device driver and its associated data structures are loaded into the system heap, you do not need to worry about causing page faults at interrupt time.<A NAME=MARKER-2-73></A><P>
<DL>
<DT><B>WARNING</B>
<DD>Future versions of the system software are not guaranteed to keep the entire system heap in physical memory. To be safe, you should explicitly hold in physical memory any code or data that you know might be accessed at interrupt time.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The Virtual Memory Manager provides this further level of protection against page faults caused by device drivers at interrupt time: it automatically holds in physical memory any buffers used by the Device Manager <CODE>_Read</CODE> and <CODE>_Write</CODE> operations. Any driver that uses the <CODE>_Read</CODE> and <CODE>_Write</CODE> calls to move data between main memory and the driver's associated hardware device is therefore automatically compatible with virtual memory. If, however, you use <CODE>_Status</CODE> or <CODE>_Control</CODE> calls to move data at interrupt time, you must explicitly hold or lock all buffers that are referenced in the <CODE>_Status</CODE> or <CODE>_Control</CODE> parameter block. If possible, you should rewrite your driver <BR>so that it uses <CODE>_Read</CODE> and <CODE>_Write</CODE> calls instead of <CODE>_Status</CODE> and <CODE>_Control</CODE> calls to <BR>move data.<P>
 The Virtual Memory Manager provides one other routine that you can use to help prevent double page faults. If your application or other code installs interrupt routines other than those handled automatically by the Virtual Memory Manager (such as VBL tasks, Time Manager tasks, and Device Manager completion calls), you can explicitly defer the execution of the routine by calling it via the function <CODE>DeferUserFn</CODE>. See <A HREF=Memory-153.html#MARKER-9-132>"Deferring User Interrupt Handling" </A>on <A HREF=Memory-153.html#MARKER-9-132>page 3-20</A> for details on calling <CODE>DeferUserFn</CODE>.<A NAME=MARKER-2-248></A><A NAME=MARKER-2-75></A><A NAME=MARKER-2-76></A><A NAME=MARKER-2-230></A><A NAME=MARKER-2-78></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="Memory-151.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-153.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Memory-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
