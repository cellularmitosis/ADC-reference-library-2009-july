<html><head><title>Mac OS X
 Manual Page For Expect(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/Expect" title="Mac OS X
 Manual Page for Expect(3pm)"><a name="//apple_ref/doc/man/3/Expect" title="Mac OS X
 Manual Page for Expect(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/Expect"; name=Expect(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Expect(3)                            User Contributed Perl Documentation                           Expect(3)



<b>NAME</b>
       Expect.pm - Expect for Perl

<b>VERSION</b>
       1.20

<b>SYNOPSIS</b>
         use Expect;

         # create an Expect object by spawning another process
         my $exp = Expect-&gt;spawn($command, @params)
           or die "Cannot spawn $command: $!\n";

         # or by using an already opened filehandle (e.g. from Net::Telnet)
         my $exp = Expect-&gt;exp_init(\*FILEHANDLE);

         # if you prefer the OO mindset:
         my $exp = new Expect;
         $exp-&gt;raw_pty(1);
         $exp-&gt;spawn($command, @parameters)
           or die "Cannot spawn $command: $!\n";

         # send some string there:
         $exp-&gt;send("string\n");

         # or, for the filehandle mindset:
         print $exp "string\n";

         # then do some pattern matching with either the simple interface
         $patidx = $exp-&gt;expect($timeout, @match_patterns);

         # or multi-match on several spawned commands with callbacks,
         # just like the Tcl version
         $exp-&gt;expect($timeout,
                      [ qr/regex1/ =&gt; sub { my $exp = shift;
                                            $exp-&gt;send("response\n");
                                            exp_continue; } ],
                      [ "regexp2" , \&amp;callback, @cbparms ],
                     );

         # if no longer needed, do a soft_close to nicely shut down the command
         $exp-&gt;soft_close();

         # or be less patient with
         $exp-&gt;hard_close();

       Expect.pm is built to either spawn a process or take an existing filehandle and interact with it such
       that normally interactive tasks can be done without operator assistance. This concept makes more
       sense if you are already familiar with the versatile Tcl version of Expect.  The public functions
       that make up Expect.pm are:

         Expect-&gt;new()
         Expect::interconnect(@objects_to_be_read_from)
         Expect::test_handles($timeout, @objects_to_test)
         Expect::version($version_requested | undef);
         $object-&gt;spawn(@command)
         $object-&gt;clear_accum()
         $object-&gt;set_accum($value)
         $object-&gt;debug($debug_level)
         $object-&gt;exp_internal(0 | 1)
         $object-&gt;notransfer(0 | 1)
         $object-&gt;raw_pty(0 | 1)
         $object-&gt;stty(@stty_modes) # See the IO::Stty docs
         $object-&gt;slave()
         $object-&gt;before();
         $object-&gt;match();
         $object-&gt;after();
         $object-&gt;matchlist();
         $object-&gt;match_number();
         $object-&gt;error();
         $object-&gt;command();
         $object-&gt;exitstatus();
         $object-&gt;pty_handle();
         $object-&gt;do_soft_close();
         $object-&gt;restart_timeout_upon_receive(0 | 1);
         $object-&gt;interact($other_object, $escape_sequence)
         $object-&gt;log_group(0 | 1 | undef)
         $object-&gt;log_user(0 | 1 | undef)
         $object-&gt;log_file("filename" | $filehandle | \&amp;coderef | undef)
         $object-&gt;manual_stty(0 | 1 | undef)
         $object-&gt;match_max($max_buffersize or undef)
         $object-&gt;pid();
         $object-&gt;send_slow($delay, @strings_to_send)
         $object-&gt;set_group(@listen_group_objects | undef)
         $object-&gt;set_seq($sequence,\&amp;function,\@parameters);

       There are several configurable package variables that affect the behavior of Expect. They are:

         $Expect::Debug;
         $Expect::Exp_Internal;
         $Expect::Log_Group;
         $Expect::Log_Stdout;
         $Expect::Manual_Stty;
         $Expect::Multiline_Matching;
         $Expect::Do_Soft_Close;

<b>DESCRIPTION</b>
       The Expect module is a successor of Comm.pl and a descendent of Chat.pl. It more closely ressembles
       the Tcl Expect language than its predecessors. It does not contain any of the networking code found
       in Comm.pl. I suspect this would be obsolete anyway given the advent of IO::Socket and external tools
       such as netcat.

       Expect.pm is an attempt to have more of a <u>switch()</u> &amp; case feeling to make decision processing more
       fluid.  Three separate types of debugging have been implemented to make code production easier.

       It is now possible to interconnect multiple file handles (and processes) much like Tcl's Expect. An
       attempt was made to enable all the features of Tcl's Expect without forcing Tcl on the victim
       programmer :-) .

       Please, before you consider using Expect, read the FAQs about "I want to automate password entry for
       su/ssh/scp/rsh/..." and "I want to use Expect to automate [anything with a buzzword]..."

<b>USAGE</b>
       new Expect ()
           Creates a new Expect object, i.e. a pty.  You can change parameters on it before actually
           spawning a command.  This is important if you want to modify the terminal settings for the slave.
           See <u>slave()</u> below.  The object returned is actually a reblessed IO::Pty filehandle, so see there
           for additional methods.

       Expect-&gt;exp_init(\*FILEHANDLE) <u>or</u>
       Expect-&gt;init(\*FILEHANDLE)
           Initializes $new_handle_object for use with other Expect functions. It must be passed a
           <b>_reference_</b> to FILEHANDLE if you want it to work properly.  IO::File objects are preferable.
           Returns a reference to the newly created object.

       Expect-&gt;spawn($command, @parameters) <u>or</u>
       $object-&gt;spawn($command, @parameters) <u>or</u>
       new Expect ($command, @parameters)
           Forks and execs $command. Returns an Expect object upon success or "undef" if the fork was
           unsuccessful or the command could not be found.  <u>spawn()</u> passes its parameters unchanged to Perls
           <u>exec()</u>, so look there for detailed semantics.

           Note that if spawn cannot <u>exec()</u> the given command, the Expect object is still valid and the next
           <u>expect()</u> will see "Cannot exec", so you can use that for error handling.

           Also note that you cannot reuse an object with an already spawned command, even if that command
           has exited.  Sorry, but you have to allocate a new object...

       $object-&gt;debug(0 | 1 | 2 | 3 | undef)
           Sets debug level for $object. 1 refers to general debugging information, 2 refers to verbose
           debugging and 0 refers to no debugging. If you call <u>debug()</u> with no parameters it will return the
           current debugging level.  When the object is created the debugging level will match that
           $Expect::Debug, normally 0.

           The '3' setting is new with 1.05, and adds the additional functionality of having the _full_
           accumulated buffer printed every time data is read from an Expect object. This was implemented by
           request. I recommend against using this unless you think you need it as it can create quite a
           quantity of output under some circumstances..

       $object-&gt;exp_internal(1 | 0)
           Sets/unsets 'exp_internal' debugging. This is similar in nature to its Tcl counterpart. It is
           extremely valuable when debugging <u>expect()</u> sequences.  When the object is created the
           exp_internal setting will match the value of $Expect::Exp_Internal, normally 0. Returns the
           current setting if called without parameters. It is highly recommended that you make use of the
           debugging features lest you have angry code.

       $object-&gt;raw_pty(1 | 0)
           Set pty to raw mode before spawning.  This disables echoing, CR-&gt;LF translation and an ugly hack
           for broken Solaris TTYs (which send &lt;space&gt;&lt;backspace&gt; to slow things down) and thus gives a more
           pipe-like behaviour (which is important if you want to transfer binary content).  Note that this
           must be set <u>before</u> spawning the program.

       $object-&gt;stty(qw(mode1 mode2...))
           Sets the tty mode for $object's associated terminal to the given modes.  Note that on many
           systems the master side of the pty is not a tty, so you have to modify the slave pty instead, see
           next item.  This needs IO::Stty installed, which is no longer required.

       $object-&gt;<u>slave()</u>
           Returns a filehandle to the slave part of the pty.  Very useful in modifying the terminal
           settings:

             $object-&gt;slave-&gt;stty(qw(raw -echo));

           Typical values are 'sane', 'raw', and 'raw -echo'.  Note that I recommend setting the terminal to
           'raw' or 'raw -echo', as this avoids a lot of hassle and gives pipe-like (i.e. transparent)
           behaviour (without the buffering issue).

       $object-&gt;print(@strings) <u>or</u>
       $object-&gt;send(@strings)
           Sends the given strings to the spawned command.  Note that the strings are not logged in the
           logfile (see print_log_file) but will probably be echoed back by the pty, depending on pty
           settings (default is echo) and thus end up there anyway.  This must also be taken into account
           when <u>expect()</u>ing for an answer: the next string will be the command just sent.  I suggest setting
           the pty to raw, which disables echo and makes the pty transparently act like a bidirectional
           pipe.

       $object-&gt;expect($timeout, @match_patterns)
           or, more like Tcl/Expect,

             expect($timeout,
                    '-i', [ $obj1, $obj2, ... ],
                          [ $re_pattern, sub { ...; exp_continue; }, @subparms, ],
                          [ 'eof', sub { ... } ],
                          [ 'timeout', sub { ... }, \$subparm1 ],
                    '-i', [ $objn, ...],
                          '-ex', $exact_pattern, sub { ... },
                          $exact_pattern, sub { ...; exp_continue_timeout; },
                          '-re', $re_pattern, sub { ... },
                    '-i', \@object_list, @pattern_list,
                    ...);

           <u>Simple</u> <u>interface:</u>

           Given $timeout in seconds Expect will wait for $object's handle to produce one of the
           match_patterns, which are matched exactly by default. If you want a regexp match, prefix the
           pattern with '-re'.

           Due to o/s limitations $timeout should be a round number. If $timeout is 0 Expect will check one
           time to see if $object's handle contains any of the match_patterns. If $timeout is undef Expect
           will wait forever for a pattern to match.

           If called in a scalar context, <u>expect()</u> will return the position of the matched pattern within
           $match_patterns, or undef if no pattern was matched. This is a position starting from 1, so if
           you want to know which of an array of @matched_patterns matched you should subtract one from the
           return value.

           If called in an array context <u>expect()</u> will return ($matched_pattern_position, $error,
           $successfully_matching_string, $before_match, and $after_match).

           $matched_pattern_position will contain the value that would have been returned if <u>expect()</u> had
           been called in a scalar context. $error is the error that occurred that caused <u>expect()</u> to
           return. $error will contain a number followed by a string equivalent expressing the nature of the
           error. Possible values are undef, indicating no error, '1:TIMEOUT' indicating that $timeout
           seconds had elapsed without a match, '2:EOF' indicating an eof was read from $object, '3: spawn
           id($fileno) died' indicating that the process exited before matching and '4:$!' indicating
           whatever error was set in $ERRNO during the last read on $object's handle. All handles indicated
           by set_group plus STDOUT will have all data to come out of $object printed to them during
           <u>expect()</u> if log_group and log_stdout are set.

           Changed from older versions is the regular expression handling. By default now all strings passed
           to <u>expect()</u> are treated as literals. To match a regular expression pass '-re' as a parameter in
           front of the pattern you want to match as a regexp.

           Example:

             $object-&gt;expect(15, 'match me exactly','-re','match\s+me\s+exactly');

           This change makes it possible to match literals and regular expressions in the same <u>expect()</u>
           call.

           Also new is multiline matching. ^ will now match the beginning of lines. Unfortunately, because
           perl doesn't use $/ in determining where lines break using $ to find the end of a line frequently
           doesn't work. This is because your terminal is returning "\r\n" at the end of every line. One way
           to check for a pattern at the end of a line would be to use \r?$ instead of $.

           Example: Spawning telnet to a host, you might look for the escape character.  telnet would return
           to you "\r\nEscape character is '^]'.\r\n". To find this you might use $match='^Escape
           char.*\.\r?$';

             $telnet-&gt;expect(10,'-re',$match);

           <u>New</u> <u>more</u> <u>Tcl/Expect-like</u> <u>interface:</u>

           It's now possible to expect on more than one connection at a time by specifying '"-i"' and a
           single Expect object or a ref to an array containing Expect objects, e.g.

            expect($timeout,
                   '-i', $exp1, @patterns_1,
                   '-i', [ $exp2, $exp3 ], @patterns_2_3,
                  )

           Furthermore, patterns can now be specified as array refs containing [$regexp, sub { ...},
           @optional_subprams] . When the pattern matches, the subroutine is called with parameters
           ($matched_expect_obj, @optional_subparms). The subroutine can return the symbol `exp_continue' to
           continue the expect matching with timeout starting anew or return the symbol
           `exp_continue_timeout' for continuing expect without resetting the timeout count.

            $exp-&gt;expect($timeout,
                         [ qr/username: /i, sub { my $self = shift;
                                                  $self-&gt;send("$username\n");
                                                  exp_continue; }],
                         [ qr/password: /i, sub { my $self = shift;
                                                  $self-&gt;send("$password\n");
                                                  exp_continue; }],
                         $shell_prompt);

           `expect' is now exported by default.

       $object-&gt;<u>exp</u><b>_</b><u>before()</u> <u>or</u>
       $object-&gt;<u>before()</u>
           <u>before()</u> returns the 'before' part of the last <u>expect()</u> call. If the last <u>expect()</u> call didn't
           match anything, <u>exp</u><b>_</b><u>before()</u> will return the entire output of the object accumulated before the
           <u>expect()</u> call finished.

           Note that this is something different than Tcl Expects <u>before()</u>!!

       $object-&gt;<u>exp</u><b>_</b><u>after()</u> <u>or</u>
       $object-&gt;<u>after()</u>
           returns the 'after' part of the last <u>expect()</u> call. If the last <u>expect()</u> call didn't match
           anything, <u>exp</u><b>_</b><u>after()</u> will return <u>undef()</u>.

       $object-&gt;<u>exp</u><b>_</b><u>match()</u> <u>or</u>
       $object-&gt;<u>match()</u>
           returns the string matched by the last <u>expect()</u> call, undef if no string was matched.

       $object-&gt;<u>exp</u><b>_</b><u>match</u><b>_</b><u>number()</u> <u>or</u>
       $object-&gt;<u>match</u><b>_</b><u>number()</u>
           <u>exp</u><b>_</b><u>match</u><b>_</b><u>number()</u> returns the number of the pattern matched by the last <u>expect()</u> call. Keep in
           mind that the first pattern in a list of patterns is 1, not 0. Returns undef if no pattern was
           matched.

       $object-&gt;<u>exp</u><b>_</b><u>matchlist()</u> <u>or</u>
       $object-&gt;<u>matchlist()</u>
           <u>exp</u><b>_</b><u>matchlist()</u> returns a list of matched substrings from the brackets () inside the regexp that
           last matched. ($object-&gt;matchlist)[0] thus corresponds to $1, ($object-&gt;matchlist)[1] to $2, etc.

       $object-&gt;<u>exp</u><b>_</b><u>error()</u> <u>or</u>
       $object-&gt;<u>error()</u>
           <u>exp</u><b>_</b><u>error()</u> returns the error generated by the last <u>expect()</u> call if no pattern was matched. It
           is typically useful to examine the value returned by <u>before()</u> to find out what the output of the
           object was in determining why it didn't match any of the patterns.

       $object-&gt;<u>clear</u><b>_</b><u>accum()</u>
           Clear the contents of the accumulator for $object. This gets rid of any residual contents of a
           handle after <u>expect()</u> or <u>send</u><b>_</b><u>slow()</u> such that the next <u>expect()</u> call will only see new data from
           $object. The contents of the accumulator are returned.

       $object-&gt;set_accum($value)
           Sets the content of the accumulator for $object to $value. The previous content of the
           accumulator is returned.

       $object-&gt;<u>exp</u><b>_</b><u>command()</u> <u>or</u>
       $object-&gt;<u>command()</u>
           <u>exp</u><b>_</b><u>command()</u> returns the string that was used to spawn the command. Helpful for debugging and
           for reused patternmatch subroutines.

       $object-&gt;<u>exp</u><b>_</b><u>exitstatus()</u> <u>or</u>
       $object-&gt;<u>exitstatus()</u>
           Returns the exit status of $object (if it already exited).

       $object-&gt;<u>exp</u><b>_</b><u>pty</u><b>_</b><u>handle()</u> <u>or</u>
       $object-&gt;<u>pty</u><b>_</b><u>handle()</u>
           Returns a string representation of the attached pty, for example: `spawn <!-- a --><u>id</u>(5)<!-- /a -->' (pty has fileno
           5), `handle <!-- a --><u>id</u>(7)<!-- /a -->' (pty was initialized from fileno 7) or `STDIN'. Useful for debugging.

       $object-&gt;restart_timeout_upon_receive(0 | 1)
           If this is set to 1, the expect timeout is retriggered whenever something is received from the
           spawned command.  This allows to perform some aliveness testing and still expect for patterns.

               $exp-&gt;restart_timeout_upon_receive(1);
               $exp-&gt;expect($timeout,
                            [ timeout =&gt; \&amp;report_timeout ],
                            [ qr/pattern/ =&gt; \&amp;handle_pattern],
                           );

           Now the timeout isn't triggered if the command produces any kind of output, i.e. is still alive,
           but you can act upon patterns in the output.

       $object-&gt;notransfer(1 | 0)
           Do not truncate the content of the accumulator after a match.  Normally, the accumulator is set
           to the remains that come after the matched string.  Note that this setting is per object and not
           per pattern, so if you want to have normal acting patterns that truncate the accumulator, you
           have to add a

               $exp-&gt;set_accum($exp-&gt;after);

           to their callback, e.g.

               $exp-&gt;notransfer(1);
               $exp-&gt;expect($timeout,
                            # accumulator not truncated, pattern1 will match again
                            [ "pattern1" =&gt; sub { my $self = shift;
                                                  ...
                                                } ],
                            # accumulator truncated, pattern2 will not match again
                            [ "pattern2" =&gt; sub { my $self = shift;
                                                  ...
                                                  $self-&gt;set_accum($self-&gt;after());
                                                } ],
                           );

           This is only a temporary fix until I can rewrite the pattern matching part so it can take that
           additional -notransfer argument.

       Expect::interconnect(@objects);
           Read from @objects and print to their @listen_groups until an escape sequence is matched from one
           of @objects and the associated function returns 0 or undef.  The special escape sequence 'EOF' is
           matched when an object's handle returns an end of file. Note that it is not necessary to include
           objects that only accept data in @objects since the escape sequence is _read_ from an object.
           Further note that the listen_group for a write-only object is always empty.  Why would you want
           to have objects listening to STDOUT (for example)?  By default every member of @objects _as well
           as every member of its listen group_ will be set to 'raw -echo' for the duration of
           interconnection.  Setting $object-&gt;<u>manual</u><b>_</b><u>stty()</u> will stop this behavior per object.  The
           original tty settings will be restored as interconnect exits.

           For a generic way to interconnect processes, take a look at IPC::Run.

       Expect::test_handles(@objects)
           Given a set of objects determines which objects' handles have data ready to be read. <b>Returns</b> <b>an</b>
           <b>array</b> who's members are positions in @objects that have ready handles. Returns undef if there are
           no such handles ready.

       Expect::version($version_requested or undef);
           Returns current version of Expect. As of .99 earlier versions are not supported. Too many things
           were changed to make versioning possible.

       $object-&gt;interact( "\*FILEHANDLE, $escape_sequence")
           <u>interact()</u> is essentially a macro for calling <u>interconnect()</u> for connecting 2 processes together.
           \*FILEHANDLE defaults to \*STDIN and $escape_sequence defaults to undef. Interaction ceases when
           $escape_sequence is read from <b>FILEHANDLE</b>, not $object. $object's listen group will consist solely
           of \*FILEHANDLE for the duration of the interaction.  \*FILEHANDLE will not be echoed on STDOUT.

       $object-&gt;log_group(0 | 1 | undef)
           Set/unset logging of $object to its 'listen group'. If set all objects in the listen group will
           have output from $object printed to them during $object-&gt;<u>expect()</u>, $object-&gt;<u>send</u><b>_</b><u>slow()</u>, and
           "Expect::interconnect($object , ...)". Default value is on. During creation of $object the
           setting will match the value of $Expect::Log_Group, normally 1.

       $object-&gt;log_user(0 | 1 | undef) <u>or</u>
       $object-&gt;log_stdout(0 | 1 | undef)
           Set/unset logging of object's handle to STDOUT. This corresponds to Tcl's log_user variable.
           Returns current setting if called without parameters.  Default setting is off for initialized
           handles.  When a process object is created (not a filehandle initialized with exp_init) the
           log_stdout setting will match the value of $Expect::Log_Stdout variable, normally 1.  If/when you
           initialize STDIN it is usually associated with a tty which will by default echo to STDOUT anyway,
           so be careful or you will have multiple echoes.

       $object-&gt;log_file("filename" | $filehandle | \&amp;coderef | undef)
           Log session to a file.  All characters send to or received from the spawned process are written
           to the file.  Normally appends to the logfile, but you can pass an additional mode of "w" to
           truncate the file upon <u>open()</u>:

             $object-&gt;log_file("filename", "w");

           Returns the logfilehandle.

           If called with an undef value, stops logging and closes logfile:

             $object-&gt;log_file(undef);

           If called without argument, returns the logfilehandle:

             $fh = $object-&gt;log_file();

           Can be set to a code ref, which will be called instead of printing to the logfile:

             $object-&gt;log_file(\&amp;myloggerfunc);

       $object-&gt;print_log_file(@strings)
           Prints to logfile (if opened) or calls the logfile hook function.  This allows the user to add
           arbitraty text to the logfile.  Note that this could also be done as $object-&gt;log_file-&gt;<u>print()</u>
           but would only work for log files, not code hooks.

       $object-&gt;set_seq($sequence, \&amp;function, \@function_parameters)
           During Expect-&gt;<u>interconnect()</u> if $sequence is read from $object &amp;function will be executed with
           parameters @function_parameters. It is <b>_highly</b> <b>recommended_</b> that the escape sequence be a single
           character since the likelihood is great that the sequence will be broken into to separate reads
           from the $object's handle, making it impossible to strip $sequence from getting printed to
           $object's listen group. \&amp;function should be something like 'main::control_w_function' and
           @function_parameters should be an array defined by the caller, passed by reference to <u>set</u><b>_</b><u>seq()</u>.
           Your function should return a non-zero value if execution of <u>interconnect()</u> is to resume after
           the function returns, zero or undefined if <u>interconnect()</u> should return after your function
           returns.  The special sequence 'EOF' matches the end of file being reached by $object.  See
           <u>interconnect()</u> for details.

       $object-&gt;set_group(@listener_objects)
           @listener_objects is the list of objects that should have their handles printed to by $object
           when Expect::interconnect, $object-&gt;<u>expect()</u> or $object-&gt;<u>send</u><b>_</b><u>slow()</u> are called. Calling w/out
           parameters will return the current list of the listener objects.

       $object-&gt;manual_stty(0 | 1 | undef)
           Sets/unsets whether or not Expect should make reasonable guesses as to when and how to set tty
           parameters for $object. Will match $Expect::Manual_Stty value (normally 0) when $object is
           created. If called without parameters <u>manual</u><b>_</b><u>stty()</u> will return the current manual_stty setting.

       $object-&gt;match_max($maximum_buffer_length | undef) <u>or</u>
       $object-&gt;max_accum($maximum_buffer_length | undef)
           Set the maximum accumulator size for object. This is useful if you think that the accumulator
           will grow out of hand during <u>expect()</u> calls. Since the buffer will be matched by every
           match_pattern it may get slow if the buffer gets too large. Returns current value if called
           without parameters.  Not defined by default.

       $object-&gt;notransfer(0 | 1)
           If set, matched strings will not be deleted from the accumulator.  Returns current value if
           called without parameters.  False by default.

       $object-&gt;<u>exp</u><b>_</b><u>pid()</u> <u>or</u>
       $object-&gt;<u>pid()</u>
           Return pid of $object, if one exists. Initialized filehandles will not have pids (of course).

       $object-&gt;send_slow($delay, @strings);
           print each character from each string of @strings one at a time with $delay seconds before each
           character. This is handy for devices such as modems that can be annoying if you send them data
           too fast. After each character $object will be checked to determine whether or not it has any new
           data ready and if so update the accumulator for future <u>expect()</u> calls and print the output to
           STDOUT and @listen_group if log_stdout and log_group are appropriately set.

       <b>Configurable</b> <b>Package</b> <b>Variables:</b>


       $Expect::Debug
           Defaults to 0. Newly created objects have a $object-&gt;<u>debug()</u> value of $Expect::Debug. See
           $object-&gt;<u>debug()</u>;

       $Expect::Do_Soft_Close
           Defaults to 0. When destroying objects, soft_close may take up to half a minute to shut
           everything down.  From now on, only hard_close will be called, which is less polite but still
           gives the process a chance to terminate properly.  Set this to '1' for old behaviour.

       $Expect::Exp_Internal
           Defaults to 0. Newly created objects have a $object-&gt;<u>exp</u><b>_</b><u>internal()</u> value of
           $Expect::Exp_Internal. See $object-&gt;<u>exp</u><b>_</b><u>internal()</u>.

       $Expect::Log_Group
           Defaults to 1. Newly created objects have a $object-&gt;<u>log</u><b>_</b><u>group()</u> value of $Expect::Log_Group. See
           $object-&gt;<u>log</u><b>_</b><u>group()</u>.

       $Expect::Log_Stdout
           Defaults to 1 for spawned commands, 0 for file handles attached with <u>exp</u><b>_</b><u>init()</u>. Newly created
           objects have a $object-&gt;<u>log</u><b>_</b><u>stdout()</u> value of $Expect::Log_Stdout. See $object-&gt;<u>log</u><b>_</b><u>stdout()</u>.

       $Expect::Manual_Stty
           Defaults to 0. Newly created objects have a $object-&gt;<u>manual</u><b>_</b><u>stty()</u> value of $Expect::Manual_Stty.
           See $object-&gt;<u>manual</u><b>_</b><u>stty()</u>.

       $Expect::Multiline_Matching
                   Defaults to 1. Affects whether or not expect() uses the /m flag for
           doing regular expression matching. If set to 1 /m is used.
                   This makes a difference when you are trying to match ^ and $. If
           you have this on you can match lines in the middle of a page of output
           using ^ and $ instead of it matching the beginning and end of the entire
           expression. I think this is handy.

<b>CONTRIBUTIONS</b>
       Lee Eakin &lt;leakin@japh.itg.ti.com&gt; has ported the kibitz script from Tcl/Expect to Perl/Expect.

       Jeff Carr &lt;jcarr@linuxmachines.com&gt; provided a simple example of how handle terminal window resize
       events (transmitted via the WINCH signal) in a ssh session.

       You can find both scripts in the examples/ subdir.  Thanks to both!

       Historical notes:

       There are still a few lines of code dating back to the inspirational Comm.pl and Chat.pl modules
       without which this would not have been possible.  Kudos to Eric Arnold &lt;Eric.Arnold@Sun.com&gt; and
       Randal 'Nuke your NT box with one line of perl code' Schwartz&lt;merlyn@stonehenge.com&gt; for making these
       available to the perl public.

       As of .98 I think all the old code is toast. No way could this have been done without it though.
       Special thanks to Graham Barr for helping make sense of the IO::Handle stuff as well as providing the
       highly recommended IO::Tty module.

<b>REFERENCES</b>
       Mark Rogaski &lt;rogaski@att.com&gt; wrote:

       "I figured that you'd like to know that Expect.pm has been very useful to AT&amp;T Labs over the past
       couple of years (since I first talked to Austin about design decisions). We use Expect.pm for
       managing the switches in our network via the telnet interface, and such automation has significantly
       increased our reliability. So, you can honestly say that one of the largest digital networks in
       existence (AT&amp;T Frame Relay) uses Expect.pm quite extensively."

<b>FAQ</b> <b>-</b> <b>Frequently</b> <b>Asked</b> <b>Questions</b>
       This is a growing collection of things that might help.  Please send you questions that are not
       answered here to RGiersig@cpan.org

       <b>What</b> <b>systems</b> <b>does</b> <b>Expect</b> <b>run</b> <b>on?</b>

       Expect itself doesn't have real system dependencies, but the underlying IO::Tty needs
       pseudoterminals. IO::Stty uses POSIX.pm and Fcntl.pm.

       I have used it on Solaris, Linux and AIX, others report *BSD and OSF as working.  Generally, any
       modern POSIX Unix should do, but there are exceptions to every rule.  Feedback is appreciated.

       See IO::Tty for a list of verified systems.

       <b>Can</b> <b>I</b> <b>use</b> <b>this</b> <b>module</b> <b>with</b> <b>ActivePerl</b> <b>on</b> <b>Windows?</b>

       Up to now, the answer was 'No', but this has changed.

       You still cannot use ActivePerl, but if you use the Cygwin environment (<a href="http://sources.redhat.com)">http://sources.redhat.com)</a>
       which brings its own perl, and have the latest IO::Tty (v0.05 or later) installed, it should work
       (feedback appreciated).

       <b>The</b> <b>examples</b> <b>in</b> <b>the</b> <b>tutorial</b> <b>don't</b> <b>work!</b>

       The tutorial is hopelessly out of date and needs a serious overhaul.  I appologize for this, I have
       concentrated my efforts mainly on the functionality.  Volunteers welcomed.

       <b>How</b> <b>can</b> <b>I</b> <b>find</b> <b>out</b> <b>what</b> <b>Expect</b> <b>is</b> <b>doing?</b>

       If you set

         $Expect::Exp_Internal = 1;

       Expect will tell you very verbosely what it is receiving and sending, what matching it is trying and
       what it found.  You can do this on a per-command base with

         $exp-&gt;exp_internal(1);

       You can also set

         $Expect::Debug = 1;  # or 2, 3 for more verbose output

       or

         $exp-&gt;debug(1);

       which gives you even more output.

       <b>I</b> <b>am</b> <b>seeing</b> <b>the</b> <b>output</b> <b>of</b> <b>the</b> <b>command</b> <b>I</b> <b>spawned.</b>  <b>Can</b> <b>I</b> <b>turn</b> <b>that</b> <b>off?</b>

       Yes, just set

         $Expect::Log_Stdout = 0;

       to globally disable it or

          $exp-&gt;log_stdout(0);

       for just that command.  'log_user' is provided as an alias so Tcl/Expect user get a DWIM
       experience... :-)

       <b>No,</b> <b>I</b> <b>mean</b> <b>that</b> <b>when</b> <b>I</b> <b>send</b> <b>some</b> <b>text</b> <b>to</b> <b>the</b> <b>spawned</b> <b>process,</b> <b>it</b> <b>gets</b> <b>echoed</b> <b>back</b> <b>and</b> <b>I</b> <b>have</b> <b>to</b> <b>deal</b>
       <b>with</b> <b>it</b> <b>in</b> <b>the</b> <b>next</b> <b>expect.</b>

       This is caused by the pty, which has probably 'echo' enabled.  A solution would be to set the pty to
       raw mode, which in general is cleaner for communication between two programs (no more unexpected
       character translations).  Unfortunately this would break a lot of old code that sends "\r" to the
       program instead of "\n" (translating this is also handled by the pty), so I won't add this to Expect
       just like that.  But feel free to experiment with "$exp-&gt;raw_pty(1)".

       <b>How</b> <b>do</b> <b>I</b> <b>send</b> <b>control</b> <b>characters</b> <b>to</b> <b>a</b> <b>process?</b>

       A: You can send any characters to a process with the print command. To represent a control character
       in Perl, use \c followed by the letter. For example, control-G can be represented with "\cG" . Note
       that this will not work if you single-quote your string. So, to send control-C to a process in $exp,
       do:

         print $exp "\cC";

       Or, if you prefer:

         $exp-&gt;send("\cC");

       The ability to include control characters in a string like this is provided by Perl, not by Expect.pm
       . Trying to learn Expect.pm without a thorough grounding in Perl can be very daunting. We suggest you
       look into some of the excellent Perl learning material, such as the books _Programming Perl_ and
       _Learning Perl_ by O'Reilly, as well as the extensive online Perl documentation available through the
       perldoc command.

       <b>My</b> <b>script</b> <b>fails</b> <b>from</b> <b>time</b> <b>to</b> <b>time</b> <b>without</b> <b>any</b> <b>obvious</b> <b>reason.</b>  <b>It</b> <b>seems</b> <b>that</b> <b>I</b> <b>am</b> <b>sometimes</b> <b>loosing</b>
       <b>output</b> <b>from</b> <b>the</b> <b>spawned</b> <b>program.</b>

       You could be exiting too fast without giving the spawned program enough time to finish.  Try adding
       $exp-&gt;<u>soft</u><b>_</b><u>close()</u> to terminate the program gracefully or do an <u>expect()</u> for 'eof'.

       Alternatively, try adding a 'sleep 1' after you <u>spawn()</u> the program.  It could be that pty creation
       on your system is just slow (but this is rather improbable if you are using the latest IO-Tty).

       <b>I</b> <b>want</b> <b>to</b> <b>automate</b> <b>password</b> <b>entry</b> <b>for</b> <b>su/ssh/scp/rsh/...</b>

       You shouldn't use Expect for this.  Putting passwords, especially root passwords, into scripts in
       clear text can mean severe security problems.  I strongly recommend using other means.  For 'su',
       consider switching to 'sudo', which gives you root access on a per-command and per-user basis without
       the need to enter passwords.  'ssh'/'scp' can be set up with RSA authentication without passwords.
       'rsh' can use the .rhost mechanism, but I'd strongly suggest to switch to 'ssh'; to mention 'rsh' and
       'security' in the same sentence makes an oxymoron.

       It will work for 'telnet', though, and there are valid uses for it, but you still might want to
       consider using 'ssh', as keeping cleartext passwords around is very insecure.

       <b>I</b> <b>want</b> <b>to</b> <b>use</b> <b>Expect</b> <b>to</b> <b>automate</b> <b>[anything</b> <b>with</b> <b>a</b> <b>buzzword]...</b>

       Are you sure there is no other, easier way?  As a rule of thumb, Expect is useful for automating
       things that expect to talk to a human, where no formal standard applies.  For other tasks that do
       follow a well-defined protocol, there are often better-suited modules that already can handle those
       protocols.  Don't try to do HTTP requests by spawning telnet to port 80, use LWP instead.  To
       automate FTP, take a look at Net::FTP or "ncftp" (<a href="http://www.ncftp.org)">http://www.ncftp.org)</a>  You don't use a screwdriver
       to hammer in your nails either, or do you?

       <b>I</b> <b>want</b> <b>to</b> <b>log</b> <b>the</b> <b>whole</b> <b>session</b> <b>to</b> <b>a</b> <b>file.</b>

       Use

         $exp-&gt;log_file("filename");

       or

         $exp-&gt;log_file($filehandle);

       or even

         $exp-&gt;log_file(\&amp;log_procedure);

       for maximum flexibility.

       Note that the logfile is appended to by default, but you can specify an optional mode "w" to truncate
       the logfile:

         $exp-&gt;log_file("filename", "w");

       To stop logging, just call it with a false argument:

         $exp-&gt;log_file(undef);

       <b>How</b> <b>can</b> <b>I</b> <b>turn</b> <b>off</b> <b>multi-line</b> <b>matching</b> <b>for</b> <b>my</b> <b>regexps?</b>

       To globally unset multi-line matching for all regexps:

         $Expect::Multiline_Matching = 0;

       You can do that on a per-regexp basis by stating "(?-m)" inside the regexp (you need perl5.00503 or
       later for that).

       <b>How</b> <b>can</b> <b>I</b> <b>expect</b> <b>on</b> <b>multiple</b> <b>spawned</b> <b>commands?</b>

       You can use the <b>-i</b> parameter to specify a single object or a list of Expect objects.  All following
       patterns will be evaluated against that list.

       You can specify <b>-i</b> multiple times to create groups of objects and patterns to match against within
       the same expect statement.

       This works just like in Tcl/Expect.

       See the source example below.

       <b>I</b> <b>seem</b> <b>to</b> <b>have</b> <b>problems</b> <b>with</b> <b>ptys!</b>

       Well, pty handling is really a black magic, as it is extremely system dependend.  I have extensively
       revised IO-Tty, so these problems should be gone.

       If your system is listed in the "verified" list of IO::Tty, you probably have some non-standard
       setup, e.g. you compiled your Linux-kernel yourself and disabled ptys.  Please ask your friendly
       sysadmin for help.

       If your system is not listed, unpack the latest version of IO::Tty, do a 'perl Makefile.PL; make;
       make test; uname "-a"' and send me the results and I'll see what I can deduce from that.

       <b>I</b> <b>just</b> <b>want</b> <b>to</b> <b>read</b> <b>the</b> <b>output</b> <b>of</b> <b>a</b> <b>process</b> <b>without</b> <u>expect()</u><b>ing</b> <b>anything.</b> <b>How</b> <b>can</b> <b>I</b> <b>do</b> <b>this?</b>

       [ Are you sure you need Expect for this?  How about <u>qx()</u> or open("prog|")? ]

       By using expect without any patterns to match.

         $process-&gt;expect(undef); # Forever until EOF
         $process-&gt;expect($timeout); # For a few seconds
         $process-&gt;expect(0); # Is there anything ready on the handle now?

       <b>Ok,</b> <b>so</b> <b>now</b> <b>how</b> <b>do</b> <b>I</b> <b>get</b> <b>what</b> <b>was</b> <b>read</b> <b>on</b> <b>the</b> <b>handle?</b>

         $read = $process-&gt;before();

       <b>Where's</b> <b>IO::Pty?</b>

       Find it on CPAN as IO-Tty, which provides both.

       <b>How</b> <b>come</b> <b>when</b> <b>I</b> <b>automate</b> <b>the</b> <b>passwd</b> <b>program</b> <b>to</b> <b>change</b> <b>passwords</b> <b>for</b> <b>me</b> <b>passwd</b> <b>dies</b> <b>before</b> <b>changing</b>
       <b>the</b> <b>password</b> <b>sometimes/every</b> <b>time?</b>

       What's happening is you are closing the handle before passwd exits.  When you close the handle to a
       process, it is sent a signal (SIGPIPE?)  telling it that STDOUT has gone away. The default behavior
       for processes is to die in this circumstance. Two ways you can make this not happen are:

         $process-&gt;soft_close();

       This will wait 15 seconds for a process to come up with an EOF by itself before killing it.

         $process-&gt;expect(undef);

       This will wait forever for the process to match an empty set of patterns. It will return when the
       process hits an EOF.

       As a rule, you should always <u>expect()</u> the result of your transaction before you continue with
       processing.

       <b>How</b> <b>come</b> <b>when</b> <b>I</b> <b>try</b> <b>to</b> <b>make</b> <b>a</b> <b>logfile</b> <b>with</b> <u>log</u><b>_</b><u>file()</u> <b>or</b> <u>set</u><b>_</b><u>group()</u> <b>it</b> <b>doesn't</b> <b>print</b> <b>anything</b> <b>after</b>
       <b>the</b> <b>last</b> <b>time</b> <b>I</b> <b>run</b> <u>expect()</u><b>?</b>

       Output is only printed to the logfile/group when Expect reads from the process, during <u>expect()</u>,
       <u>send</u><b>_</b><u>slow()</u> and <u>interconnect()</u>.  One way you can force this is to make use of

         $process-&gt;expect(undef);

       and

         $process-&gt;expect(0);

       which will make <u>expect()</u> run with an empty pattern set forever or just for an instant to capture the
       output of $process. The output is available in the accumulator, so you can grab it using
       $process-&gt;<u>before()</u>.

       <b>I</b> <b>seem</b> <b>to</b> <b>have</b> <b>problems</b> <b>with</b> <b>terminal</b> <b>settings,</b> <b>double</b> <b>echoing,</b> <b>etc.</b>

       Tty settings are a major pain to keep track of. If you find unexpected behavior such as double-
       echoing or a frozen session, doublecheck the documentation for default settings. When in doubt,
       handle them yourself using $exp-&gt;<u>stty()</u> and <u>manual</u><b>_</b><u>stty()</u> functions.  As of .98 you shouldn't have to
       worry about stty settings getting fouled unless you use interconnect or intentionally change them
       (like doing -echo to get a password).

       If you foul up your terminal's tty settings, kill any hung processes and enter 'stty sane' at a shell
       prompt. This should make your terminal manageable again.

       Note that IO::Tty returns ptys with your systems default setting regarding echoing, CRLF translation
       etc. and Expect does not change them.  I have considered setting the ptys to 'raw' without any
       translation whatsoever, but this would break a lot of existing things, as '\r' translation would not
       work anymore.  On the other hand, a raw pty works much like a pipe and is more WYGIWYE (what you get
       is what you expect), so I suggest you set it to 'raw' by yourself:

         $exp = new Expect;
         $exp-&gt;raw_pty(1);
         $exp-&gt;spawn(...);

       To disable echo:

         $exp-&gt;slave-&gt;stty(qw(-echo));

       <b>I'm</b> <b>spawning</b> <b>a</b> <b>telnet/ssh</b> <b>session</b> <b>and</b> <b>then</b> <b>let</b> <b>the</b> <b>user</b> <b>interact</b> <b>with</b> <b>it.</b>  <b>But</b> <b>screen-oriented</b>
       <b>applications</b> <b>on</b> <b>the</b> <b>other</b> <b>side</b> <b>don't</b> <b>work</b> <b>properly.</b>

       You have to set the terminal screen size for that.  Luckily, IO::Pty already has a method for that,
       so modify your code to look like this:

         my $exp = new Expect;
         $exp-&gt;slave-&gt;clone_winsize_from(\*STDIN);
         $exp-&gt;spawn("telnet somehost);

       Also, some applications need the TERM shell variable set so they know how to move the cursor across
       the screen.  When logging in, the remote shell sends a query (Ctrl-Z I think) and expects the
       terminal to answer with a string, e.g. 'xterm'.  If you really want to go that way (be aware, madness
       lies at its end), you can handle that and send back the value in $ENV{TERM}.  This is only a hand-
       waving explanation, please figure out the details by yourself.

       <b>I</b> <b>set</b> <b>the</b> <b>terminal</b> <b>size</b> <b>as</b> <b>explained</b> <b>above,</b> <b>but</b> <b>if</b> <b>I</b> <b>resize</b> <b>the</b> <b>window,</b> <b>the</b> <b>application</b> <b>does</b> <b>not</b>
       <b>notice</b> <b>this.</b>

       You have to catch the signal WINCH ("window size changed"), change the terminal size and propagate
       the signal to the spawned application:

         my $exp = new Expect;
         $exp-&gt;slave-&gt;clone_winsize_from(\*STDIN);
         $exp-&gt;spawn("ssh somehost);
         $SIG{WINCH} = \&amp;winch;

         sub winch {
           $exp-&gt;slave-&gt;clone_winsize_from(\*STDIN);
           kill WINCH =&gt; $exp-&gt;pid if $exp-&gt;pid;
           $SIG{WINCH} = \&amp;winch;
         }

         $exp-&gt;interact();

       There is an example file ssh.pl in the examples/ subdir that shows how this works with ssh. Please
       note that I do strongly object against using Expect to automate ssh login, as there are better way to
       do that (see ssh-keygen).

       <b>I</b> <b>noticed</b> <b>that</b> <b>the</b> <b>test</b> <b>uses</b> <b>a</b> <b>string</b> <b>that</b> <b>resembles,</b> <b>but</b> <b>not</b> <b>exactly</b> <b>matches,</b> <b>a</b> <b>well-known</b> <b>sentence</b>
       <b>that</b> <b>contains</b> <b>every</b> <b>character.</b>  <b>What</b> <b>does</b> <b>that</b> <b>mean?</b>

       That means you are anal-retentive. :-)  [Gotcha there!]

       <b>I</b> <b>get</b> <b>a</b> <b>"Could</b> <b>not</b> <b>assign</b> <b>a</b> <b>pty"</b> <b>error</b> <b>when</b> <b>running</b> <b>as</b> <b>a</b> <b>non-root</b> <b>user</b> <b>on</b> <b>an</b> <b>IRIX</b> <b>box?</b>

       The OS may not be configured to grant additional pty's (pseudo terminals) to non-root users.
       /usr/sbin/mkpts should be 4755, not 700 for this to work.  I don't know about security implications
       if you do this.

       <b>How</b> <b>come</b> <b>I</b> <b>don't</b> <b>notice</b> <b>when</b> <b>the</b> <b>spawned</b> <b>process</b> <b>closes</b> <b>its</b> <b>stdin/out/err??</b>

       You are probably on one of the systems where the master doesn't get an EOF when the slave closes
       stdin/out/err.

       One possible solution is when you spawn a process, follow it with a unique string that would indicate
       the process is finished.

         $process = Expect-&gt;spawn('telnet somehost; echo ____END____');

       And then $process-&gt;expect($timeout,'____END____','other','patterns');

<b>Source</b> <b>Examples</b>
       <b>How</b> <b>to</b> <b>automate</b> <b>login</b>

         my $telnet = new Net::Telnet ("remotehost") # see Net::Telnet
           or die "Cannot telnet to remotehost: $!\n";;
         my $exp = Expect-&gt;exp_init($telnet);

         # deprecated use of spawned telnet command
         # my $exp = Expect-&gt;spawn("telnet localhost")
         #   or die "Cannot spawn telnet: $!\n";;

         my $spawn_ok;
         $exp-&gt;expect($timeout,
                      [
                       qr'login: $',
                       sub {
                         $spawn_ok = 1;
                         my $fh = shift;
                         $fh-&gt;send("$username\n");
                         exp_continue;
                       }
                      ],
                      [
                       'Password: $',
                       sub {
                         my $fh = shift;
                         print $fh "$password\n";
                         exp_continue;
                       }
                      ],
                      [
                       eof =&gt;
                       sub {
                         if ($spawn_ok) {
                           die "ERROR: premature EOF in login.\n";
                         } else {
                           die "ERROR: could not spawn telnet.\n";
                         }
                       }
                      ],
                      [
                       timeout =&gt;
                       sub {
                         die "No login.\n";
                       }
                      ],
                      '-re', qr'[#&gt;:] $', #' wait for shell prompt, then exit expect
                     );

       <b>How</b> <b>to</b> <b>expect</b> <b>on</b> <b>multiple</b> <b>spawned</b> <b>commands</b>

         foreach my $cmd (@list_of_commands) {
           push @commands, Expect-&gt;spawn($cmd);
         }

         expect($timeout,
                '-i', \@commands,
                [
                 qr"pattern",          # find this pattern in output of all commands
                 sub {
                   my $obj = shift;    # object that matched
                   print $obj "something\n";
                   exp_continue;       # we don't want to terminate the expect call
                 }
                ],
                '-i', $some_other_command,
                [
                 "some other pattern",
                 sub {
                   my ($obj, $parmref) = @_;
                   # ...

                   # now we exit the expect command
                 },
                 \$parm
                ],
               );

       <b>How</b> <b>to</b> <b>propagate</b> <b>terminal</b> <b>sizes</b>

         my $exp = new Expect;
         $exp-&gt;slave-&gt;clone_winsize_from(\*STDIN);
         $exp-&gt;spawn("ssh somehost);
         $SIG{WINCH} = \&amp;winch;

         sub winch {
           $exp-&gt;slave-&gt;clone_winsize_from(\*STDIN);
           kill WINCH =&gt; $exp-&gt;pid if $exp-&gt;pid;
           $SIG{WINCH} = \&amp;winch;
         }

         $exp-&gt;interact();

<b>HOMEPAGE</b>
       <a href="http://sourceforge.net/projects/expectperl/">http://sourceforge.net/projects/expectperl/</a>

<b>MAILING</b> <b>LISTS</b>
       There are two mailing lists available, expectperl-announce and expectperl-discuss, at

         <a href="http://lists.sourceforge.net/lists/listinfo/expectperl-announce">http://lists.sourceforge.net/lists/listinfo/expectperl-announce</a>

       and

         <a href="http://lists.sourceforge.net/lists/listinfo/expectperl-discuss">http://lists.sourceforge.net/lists/listinfo/expectperl-discuss</a>

<b>BUG</b> <b>TRACKING</b>
       You can use the CPAN Request Tracker <a href="http://rt.cpan.org/">http://rt.cpan.org/</a> and submit new bugs under

         <a href="http://rt.cpan.org/Ticket/Create.html?Queue=Expect">http://rt.cpan.org/Ticket/Create.html?Queue=Expect</a>

<b>AUTHORS</b>
       (c) 1997 Austin Schutz &lt;<u>ASchutz@users.sourceforge.net&gt;</u> (retired)

       <u>expect()</u> interface &amp; functionality enhancements (c) 1999-2006 Roland Giersig.

       This module is now maintained by Roland Giersig &lt;<u>RGiersig@cpan.org&gt;</u>

<b>LICENSE</b>
       This module can be used under the same terms as Perl.

<b>DISCLAIMER</b>
       THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
       TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
       IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
       CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
       LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
       IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

       In other words: Use at your own risk.  Provided as is.  Your mileage may vary.  Read the source,
       Luke!

       And finally, just to be sure:

       Any Use of This Product, in Any Manner Whatsoever, Will Increase the Amount of Disorder in the
       Universe. Although No Liability Is Implied Herein, the Consumer Is Warned That This Process Will
       Ultimately Lead to the Heat Death of the Universe.

<b>POD</b> <b>ERRORS</b>
       Hey! <b>The</b> <b>above</b> <b>document</b> <b>had</b> <b>some</b> <b>coding</b> <b>errors,</b> <b>which</b> <b>are</b> <b>explained</b> <b>below:</b>

       Around line 647:
           '=item' outside of any '=over'

       Around line 691:
           You forgot a '=back' before '=head1'



perl v5.8.8                                      2006-07-19                                        Expect(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Expect.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Expect.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Expect.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
